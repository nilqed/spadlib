--------------------------------------
)abbrev package HYPGEOM HyperGeometric
--------------------------------------
HyperGeometric(): Exports == Implementation where
  R ==> Fraction Integer  -- must be FRAC INT not INT!!
  X ==> Expression R 
  NNI ==> NonNegativeInteger
  SMP ==> SparseMultivariatePolynomial(R, Kernel X) -- if R has IntegralDomain
  SUP ==> SparseUnivariatePolynomial SMP 
  
  EFSP   ==> ElementaryFunctionStructurePackage(R,X)
  FACSUP ==> Factored SUP
  FACREC ==> Record(factor:SUP, exponent:NNI)
  
  HYPER  ==> Record(ap:List X, bq:List X, fac:X)
  PARAM  ==> Record(ab:List SUP, const:List SUP)

  Exports == with
    polynomial? : (X,X) -> Boolean
      ++ polynomial?(p,x) returns true if p has the structure of a
      ++ univariate polynomial in the variable x. Notice that constants
      ++ are not considered as polynomials here. (a hack ;)
    rational? : (X,X) -> Boolean
      ++ rational?(r,x) returns true if r is of the form p/q where 
      ++ polynomial?(p,x) and polynomial?(q,x) are true.
    factoredForm : (X->X) -> Fraction(FACSUP)
      ++ factoredForm(f) returns the fraction f(?+1)/f(?) in the variable "?", 
      ++ where numerator and denominator are factored, provided that this 
      ++ fraction is a rational function; otherwise an error message is
      ++ produced.      
    getParameters : FACSUP -> PARAM
      ++ getParameters(p) gives the parameters of sparse univariate polynomial
      ++ p, that is the list of zeroes and possibly a constant factor when
      ++ different from 1.
    convert : SUP -> X
      ++ convert(p) converts the SparseUnivariatePolynomial p to Expression
      ++ Integer.
    pFq : (X->X) -> HYPER
      ++ pFq(f) provides the hypergeometric parameters as a record of the
      ++ form Record(ap:List X, bq:List X, fac:X), where X=EXPR(INT).
    construct: (HYPER,Symbol) -> X
      ++ construct(pfq,x) constructs the hypergeometric expression with 
      ++ the output of pFq in the symbol x.
    display : HYPER -> OutputForm
      ++ Fancy display the output of pFq.
    hyperLookup : HYPER -> X
      ++ Lookup the output of pFq in a table.

  Implementation == add

    polynomial?(p:X,x:X):Boolean ==
      xs:=retract(x)@Symbol -- first variables x, ifCan / 1/x excluded***
      not member?(xs, variables p) => false
      up:=univariate(p, kernel xs)
      nup:=numer up
      dup:=denom up
      degree nup = 0  => false
      degree dup >=1  => false
      cnup:=coefficients nup 
      lb:=[freeOf?(s,x) for s in cnup]
      reduce(_and,lb)

    rational?(r:X,x:X):Boolean ==
      nr:X:=numerator r
      not(polynomial?(nr,x) or freeOf?(nr,x)) => false
      dr:X:=denominator r
      not(polynomial?(dr,x) or freeOf?(dr,x)) => false
      true

    factoredForm(f:X->X):Fraction(FACSUP) ==
      ns:X:=(nsym:=new()$Symbol)::X
      q:=f(ns+1)/f(ns)
      nq:=normalize(q)$EFSP
      not rational?(nq,ns) => error "Not rational"
      dnq:=denom nq
      nnq:=numer nq
      unnq:=univariate(nnq,kernel nsym)
      udnq:=univariate(dnq,kernel nsym)
      funnq:=factor unnq
      fudnq:=factor udnq
      funnq/fudnq
      

    getParameters x ==
      qm:=create()$SingletonAsOrderedSet
      r:List FACREC:=factors x
      l1:List SUP:=[]
      l2:List SUP:=[]
      for s in r repeat
        p:SUP:=s.factor
        if variables p = [qm]
        then
          q1:=p-qm::SUP
          for i in 1..s.exponent repeat
            l1:=cons(q1,l1)
        else
          q2:=p 
          for i in 1..s.exponent repeat
            l2:=cons(q2,l2)
      return [l1,l2]$PARAM


    convert(x:SUP):X ==
      k:Kernel(X):=first tower('_%::X) --'
      y:SMP:=multivariate(x,k)$SMP
      coerce(y)$X
      

    buildConst(x:List SUP):X ==
      empty?(x) => 1$X
      p:SUP:=reduce(_*,x)
      convert p

    pFq(f:X->X):HYPER ==
      ff:=factoredForm(f)
      gpn:=getParameters(numer ff)
      gpd:=getParameters(denom ff)
      a:=[convert t for t in gpn.ab]
      b:=[convert t for t in gpd.ab]
      if member?(1$X,b) then
        b:=delete(b,position(1$X,b))
      else
        a:=cons(1$X,a)
      c:=convert unit(numer ff)
      ca:=buildConst(gpn.const)
      cb:=buildConst(gpd.const)
      [a,b,c*ca/cb]$HYPER
 
    construct(x,s) ==
      v:=s::X
      a:=x.ap
      b:=x.bq
      c:=x.fac
      av:=[paren(v+t) for t in a]
      bv:=[paren(v+t) for t in b]
      num:=1$X
      den:=1$X
      if not empty? av then
        num:=reduce(_*,av)
      if not empty? bv then
        den:=reduce(_*,bv)    
      c*num/den/(v+1$X)

    display(x:HYPER):OutputForm ==
      OF ==> OutputForm
      a:=[s::OF for s in x.ap]
      b:=[s::OF for s in x.bq]
      c:=(x.fac)::OF
      p:=(#a)::OF
      q:=(#b)::OF
      A:=sub(presub('F::OF,p),q)
      if #a < #b then
        a:=append(a,['*::OF for i in 1..#b- #a])
      else
        b:=append(b,['*::OF for i in 1..#a- #b])
      --B:=binomial(blankSeparate a, blankSeparate b)
      B:=blankSeparate [A,matrix [a,b],bracket c]
      --hconcat(A,B)

    hyperLookup(x:HYPER):X ==
      a:=x.ap
      b:=x.bq
      c:=x.fac
      p:= #a
      q:= #b
      if p=1 then
        if q=0 then
          return (1-c)^(-a.1)
      0$X

