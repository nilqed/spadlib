------------------------------------------
)abbrev package FORMAN FormalManipulations
------------------------------------------
FormalManipulations(R) : Exports == Implementation where
  
  R:Join(Comparable,IntegralDomain)
  X ==> Expression R
  PI ==> PositiveInteger
  UK ==> Union(Kernel X,"failed")
  KX ==> Kernel X
  SX ==> Segment X
  SBX ==> SegmentBinding X
  EFSP ==> ElementaryFunctionStructurePackage(Integer,X)

  Exports ==  with
  
    defop? : X -> Boolean
      ++ defop?(x) checks whether x is a definite sum, product or integral.
    defop2list : X -> List X
      ++ defop2list(x) returns a list of the form [defop,opr(%v),%v,var,lb,ub],
      ++ where defop is one of %defsum,%defprod or %defint, opr(%v) is the 
      ++ operand in the dummy variable %v, var is the original index variable 
      ++ and lb, ub the lower- and upper bound respectively.      
    list2defop : List X -> X
      ++ list2defop(l) is the inverse of defop2list, that is the defop will
      ++ be exactly restored from the list given by defop2list.


    getLB  : X -> X
    getUB  : X -> X
    getOPT : X -> X
    getOPR : X -> X
    getVAR : X -> X
    
    setLB  : (X,X) -> X
    setUB  : (X,X) -> X
    setOPT : (X,X) -> X
    setOPR : (X,X) -> X
    setVAR : (X,X) -> X

    defint? : X -> Boolean
    defprd? : X -> Boolean
    defsum? : X -> Boolean

    splitOp : (X,X) -> X
    multiplyOp : (X,X) -> X
    splitFunctions : X -> X
    shiftNTerms : (X,X) -> X
    
    mexpt? : (X,Symbol) -> Boolean 
    monomial? : (X,Symbol) -> Boolean
    polynomial? : (X,Symbol) -> Boolean
    rational? : (X,Symbol) -> Boolean
    isRational? : (X,Symbol) -> Boolean
  
  Implementation ==  add 

    defop?(x:X):Boolean ==
      mk:UK:=mainKernel x
      defops:List Symbol:=['%defsum,'%defprod,'%defint]
      if mk case KX then mk:KX:=mk else return false
      member?(name mk,defops) 
      
    defop2list(x:X):List X ==
      mk:=mainKernel x
      if mk case KX then mk:KX:=mk else return []
      mkn:=name mk 
      mka:=argument mk
      cons(mkn::X,mka)

    list2defop(k:List X):X ==
      opr:X:=subst(k.2,k.3=k.4)
      seg:SBX:=equation(retract(k.4)@Symbol,segment(k.5,k.6)$SX)$SBX
      s:=retract(k.1)@Symbol 
      s = '%defsum  => summation(opr,seg) 
      s = '%defprod => product(opr,seg) 
      s = '%defint  => integral(opr,seg) 
      error "unknown %defop"

    

    mexpt?(p:X,xs:Symbol):Boolean ==
      x:=xs::X
      np:X:=normalize(p)$EFSP
      lt:=isExpt(np)
      lt case "failed" => false
      name(lt.var) ~= xs => false
      lt.exponent < 0 => false
      true  
      
    monomial?(p:X,xs:Symbol):Boolean ==
      x:=xs::X
      np:X:=normalize(p)$EFSP
      lt:=isTimes(np)
      if lt case List(X) then
        ltf:=[u for u in lt | not freeOf?(u,x)]
        empty? ltf => true  -- a constant
        #ltf > 1 => false   -- 
        return mexpt?(first ltf,xs)
      else
        mexpt?(p,xs)
        
    polynomial?(p:X,xs:Symbol):Boolean ==
      x:=xs::X
      np:X:=normalize(p)$EFSP
      dnp:=denominator np
      not freeOf?(dnp,x) => false
      np:X:=normalize(dnp*p)$EFSP
      -- above handles isTimes, e.g. when p/z (quotients)!
      freeOf?(p,x) => true      -- a constant
      mexpt?(p,xs) => true      -- x^Integer
      monomial?(p,xs) => true   -- coeff * x^Integer
      ls:=isPlus(np)
      if ls case List X then
        lsf:List Boolean:=[polynomial?(u,xs) for u in ls]
        empty? lsf => false -- shouldn't occur
        return reduce(_and,lsf)
      else
        return false
        
    rational?(p:X,xs:Symbol):Boolean == 
      polynomial?(numerator p,xs) and polynomial?(denominator p,xs)

    
    
    isRational?(p:X,xs:Symbol):Boolean ==
      -- second variant when X=EXPR INT (best so far ;-)
      x:=xs::X
      up:=univariate(p,kernel xs)
      dup:=denom up
      nup:=numer up
      cdup:= coefficients dup
      ndup:= coefficients nup
      fox:=(u:X):Boolean+->freeOf?(u,x)
      every?(fox,cdup) and every?(fox,ndup)


    getLB x == defop2list(x).5 
    getUB x == defop2list(x).6
    getOPT x == defop2list(x).1
    getOPR x == 
      l:=defop2list(x)
      subst(l.2,l.3=l.4)
    
    getVAR x == defop2list(x).4
    
    setLB(x,y) == 
      l:=copy defop2list(x)  
      l.5:=y
      list2defop(l)
      
    setUB(x,y) == 
      l:=copy defop2list(x)  
      l.6:=y
      list2defop(l)
      
    setOPT(x,y) ==
      -- y=%defop ... checks?    
      l:=copy defop2list(x)  
      l.1:=y
      list2defop(l)
      
    setOPR(x,y) ==
      l:=copy defop2list(x)  
      l.2:=subst(y,l.4=l.3)
      list2defop(l)
    
    setVAR(x,y) ==
      -- one has to )clear properties 'x' first!
      l:=copy defop2list(x)
      l.4:=y
      list2defop l

    defint? x == test(getOPT x = '%defint::X)
    defprd? x == test(getOPT x = '%defprod::X)
    defsum? x == test(getOPT x = '%defsum::X)


    -- :todo: shall we warn when c is one of var,lb,ub?
    -- splitOp expands if c is numeric. Using box? doesn't work :
    splitOp(x:X,c:X):X ==
      not defop? x => x
      defsum? x => setUB(x,c) + setLB(x,c+1)
      defprd? x => setUB(x,c) * setLB(x,c+1)
      defint? x => setUB(x,c) + setLB(x,c)
      
      
    multiplyOp(x:X,c:X):X ==
      not defop? x => x
      defsum? x or defint? x => setOPR(x,c*getOPR(x))
      defprd? x => setOPR(x,getOPR(x)^c)
      
      
    splitFunctions(x:X):X ==
      not defop? x => x
      opr:=getOPR(x)
      if defsum? x or defint? x then
        ip:=isPlus(distribute opr)
        ip case "failed" => x
        ip:=ip::List X
        lop:=[setOPR(x,i) for i in ip]
        return reduce(_+,lop)
      else
        it:=isTimes(distribute opr)
        it case "failed" => x
        it:=it::List X
        lop:=[setOPR(x,i) for i in it]
        return reduce(_*,lop)
 
    shiftNTerms(x:X,c:X):X ==
      not defop? x => x
      l:=copy defop2list x
      l.5:=l.5+c
      l.6:=l.6+c
      l.2:=subst(l.2,l.3=l.3-c)
      list2defop l

      
      
