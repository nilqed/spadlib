------------------------------------------
)abbrev package FORMAN FormalManipulations
------------------------------------------
FormalManipulations(R) : Exports == Implementation where
  
  R:Join(Comparable,IntegralDomain)
  X ==> Expression R
  PI ==> PositiveInteger
  UK ==> Union(Kernel X,"failed")
  KX ==> Kernel X
  SX ==> Segment X
  SBX ==> SegmentBinding X
  EFSP ==> ElementaryFunctionStructurePackage(Integer,X)

  Exports ==  with
  
    defop? : X -> Boolean
      ++ defop?(x) checks whether x is a definite sum, product or integral.
    defop2list : X -> List X
      ++ defop2list(x) returns a list of the form [defop,opr(%v),%v,var,lb,ub],
      ++ where defop is one of %defsum,%defprod or %defint, opr(%v) is the 
      ++ operand in the dummy variable %v, var is the original index variable 
      ++ and lb, ub the lower- and upper bound respectively.      
    list2defop : List X -> X
      ++ list2defop(l) is the inverse of defop2list, that is the defop will
      ++ be exactly restored from the list given by defop2list.
      
    splitOp : (X,X) -> X
    multOpr : (X,X) -> X
    
    mexpt? : (X,Symbol) -> Boolean 
    monomial? : (X,Symbol) -> Boolean
    polynomial? : (X,Symbol) -> Boolean
    rational? : (X,Symbol) -> Boolean
    isRational? : (X,Symbol) -> Boolean
  
  Implementation ==  add 

    defop?(x:X):Boolean ==
      mk:UK:=mainKernel x
      defops:List Symbol:=['%defsum,'%defprod,'%defint]
      if mk case KX then mk:KX:=mk else return false
      member?(name mk,defops) 
      
    defop2list(x:X):List X ==
      mk:=mainKernel x
      if mk case KX then mk:KX:=mk else return []
      mkn:=name mk 
      mka:=argument mk
      cons(mkn::X,mka)

    list2defop(k:List X):X ==
      opr:X:=subst(k.2,k.3=k.4)
      seg:SBX:=equation(retract(k.4)@Symbol,segment(k.5,k.6)$SX)$SBX
      s:=retract(k.1)@Symbol 
      s = '%defsum  => summation(opr,seg) 
      s = '%defprod => product(opr,seg) 
      s = '%defint  => integral(opr,seg) 
      error "unknown %defop"

    

    mexpt?(p:X,xs:Symbol):Boolean ==
      x:=xs::X
      np:X:=normalize(p)$EFSP
      lt:=isExpt(np)
      lt case "failed" => false
      name(lt.var) ~= xs => false
      lt.exponent < 0 => false
      true  
      
    monomial?(p:X,xs:Symbol):Boolean ==
      x:=xs::X
      np:X:=normalize(p)$EFSP
      lt:=isTimes(np)
      if lt case List(X) then
        ltf:=[u for u in lt | not freeOf?(u,x)]
        empty? ltf => true  -- a constant
        #ltf > 1 => false   -- 
        return mexpt?(first ltf,xs)
      else
        mexpt?(p,xs)
        
    polynomial?(p:X,xs:Symbol):Boolean ==
      x:=xs::X
      np:X:=normalize(p)$EFSP
      dnp:=denominator np
      not freeOf?(dnp,x) => false
      np:X:=normalize(dnp*p)$EFSP
      -- above handles isTimes, e.g. when p/z (quotients)!
      freeOf?(p,x) => true      -- a constant
      mexpt?(p,xs) => true      -- x^Integer
      monomial?(p,xs) => true   -- coeff * x^Integer
      ls:=isPlus(np)
      if ls case List X then
        lsf:List Boolean:=[polynomial?(u,xs) for u in ls]
        empty? lsf => false -- shouldn't occur
        return reduce(_and,lsf)
      else
        return false
        
    rational?(p:X,xs:Symbol):Boolean == 
      polynomial?(numerator p,xs) and polynomial?(denominator p,xs)

    
    
    isRational?(p:X,xs:Symbol):Boolean ==
      -- second variant when X=EXPR INT (best so far ;-)
      x:=xs::X
      up:=univariate(p,kernel xs)
      dup:=denom up
      nup:=numer up
      cdup:= coefficients dup
      ndup:= coefficients nup
      fox:=(u:X):Boolean+->freeOf?(u,x)
      every?(fox,cdup) and every?(fox,ndup)

    -- :todo: shall we warn when c is one of var,lb,ub?
    -- splitOp expands if c is numeric. Using box? doesn't work :
    splitOp(x:X,c:X):X ==
      not defop? x => x
      l:=defop2list x
      l1:=copy l
      l2:=copy l
      l1.6:=c
      l2.5:=c+1
      if l1.1='%defint::X then l2.5:=c
      list2defop(l1) + list2defop(l2)
      
    multOpr(x:X,c:X):X ==
      not defop? x => x
      l:=defop2list x
      l1:=copy l
      l1.2:=c * l1.2
      if l1.1='%defprod::X then l1.2:=(l1.2)^c
      list2defop(l1)