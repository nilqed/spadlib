)abbrev package FORMAN FormalManipulations
++ Author: Kurt Pagani
++ Date Created: Tue Jun 19 19:09:16 CEST 2018
++ License: BSD
++ References:
++ Description:
++   Interactive Computer Manipulation of Formal Sums
++   (Thesis format: Monograph) by Nivedita Patil
++   Graduate Program in Computer Science
++     A thesis submitted in partial fulfillment of the requirements for the 
++     degree of Master of Science
++     The School of Graduate and Postdoctoral Studies
++     The University of Western Ontario
++     London, Ontario, Canada, (C) Nivedita Patil 2010
++     Supervisor: Dr. Stephen Watt from the Department of
++     Computer Science at University of Western Ontario
++   http://www.csd.uwo.ca/~watt/home/students/theses/NPatil2010-msc.pdf
++
++ Abstract:
++ The goal of the thesis is to explore how computer algebra systems can 
++ be augmented to allow user-guided transformation and simplification of 
++ expressions involving symbolic summation. Mathematical expressions 
++ represented as trees are one of the data objects of computer algebra 
++ systems. By accessing and manipulating these data objects we can simplify 
++ and transform expressions involving symbolic summation. To choose what 
++ transformations to be performed is under the discretion of the user. We
++ present a conceptual framework to perform transformations on expressions 
++ involving symbolic summation. This is done by creating a set of library 
++ functions for interactive manipulation of formal sums. We base our design 
++ on the properties of summation. This idea is also extended to other 
++ associative operators such as product and definite integral.
++
++ Keywords: 
++   Formal Sums, Computer Algebra System, Associative Operators.
++
FormalManipulations(R) : Exports == Implementation where
  
  R:Join(Comparable,IntegralDomain)
  X ==> Expression R
  PI ==> PositiveInteger
  UK ==> Union(Kernel X,"failed")
  KX ==> Kernel X
  SX ==> Segment X
  SBX ==> SegmentBinding X

  
  Exports ==  with
    
    splitOp : (X,X) -> X
      ++ The splitOp function splits the summation and product at a term 
      ++ and definite integral at an interval. This implements property IV 
      ++ of summation, property IV of definite integral and property II of 
      ++ product. Calling Sequence: splitOp(expr, c), Parameters: expr - 
      ++ summation, product or definite integral, c - value at which expr 
      ++ should be split.
    multiplyOp : (X,X) -> X
      ++ The multiplyOp function exponentiates the base operator, "+" to
      ++ "*", "*" to "^". The multiplicand can contain the iterating variable 
      ++ or index of summation, product or definite integral.
      ++ Calling Sequence: multiplyOp(expr, c), Parameters: expr - summation, 
      ++ product or definite integral c - value to be multiplied. 
    splitFunctions : X -> X 
      ++ The splitFunctions function splits summation and definite integral 
      ++ based on the additive term and product based on the multiplicative 
      ++ term in the inner expression. This implements property II of 
      ++ summation, property II of definite integral and property III of 
      ++ product. Calling Sequence splitFunctions(expr), Parameters:
      ++ expr - summation, product or definite integral.
    takeNTermsHigh : (X,X) -> X
      ++ The takeNTermsHigh function gets the higher terms of summation, 
      ++ product and definite integral. 
      ++ Calling Sequence: takeNTermsHigh(expr, n), Parameters: expr - 
      ++ summation, product or definite integral, n - number of terms to 
      ++ be fetched if expr is summation or product else the limit if expr 
      ++ is a definite integral.
    takeNTermsLow : (X,X) -> X
      ++ The takeNTermsLow function gets the lower terms of summation, 
      ++ product and definite integral. Calling Sequence: 
      ++ takeNTermsLow(expr, n), Parameters expr - summation, product or 
      ++ definite integral, n - number of terms to be fetched if expr is 
      ++ summation or product else the limit if expr is a definite integral.
    shiftNTerms : (X,X) -> X
      ++ The shiftNTerms function shifts or rearranges summation, product 
      ++ and definite integral. This implements property V of summation, 
      ++ property VII of definite integral and property I of product.
      ++ Calling Sequence: shiftNTerms(expr, n), Parameters: expr - 
      ++ summation, product or definite integral, n - value by which expr 
      ++ should be shifted
    splitTermsEvenOdd : X -> X
      ++ The splitTermsEvenOdd function splits summation and product into 
      ++ even and odd terms. Calling Sequence: splitTermsEvenOdd(expr),
      ++ Parameters: expr - summation or product. 
    reverseOrder : X -> X 
      ++ The reverseOrder function reverses the order of terms for summation 
      ++ and product and intervals for definite integral. This implements 
      ++ property VI of summation, property V of definite integral and 
      ++ property IV of product.
      ++ Calling Sequence: reverseOrder(expr), Parameters: expr - summation, 
      ++ product or definite integral.
    getCoefficient : (X,X,X) -> X
      ++ The getCoefficient function gets the coefficient of a term in a 
      ++ univariate polynomial which is represented as a summation.
      ++ Calling Sequence: getCoefficient(expr,k,invar), Parameters: expr 
      ++ - summation, k - coefficient for kth term, invar - variable for 
      ++ which coefficient needs to be fetched.
    takeTermsValue : (X,X,X) -> X
      ++ The takeTermsValue function gets the terms of summation and product 
      ++ and value of the definite integral. If the input is a summation 
      ++ then it returns the closed form of summation if it can be evaluated 
      ++ else it returns the summation unevaluated.
      ++ Calling Sequence: takeTermsValue(expr,start,end), Parameters:
      ++ expr - summation, product or definite integral, start - lower limit 
      ++ of expr starting from which the terms or value need to be fetched,
      ++ end - upper limit of expr until which the terms or value need to 
      ++ be fetched
    combineSplitFunctions : X -> X
      ++ The combineSplitFunctions function combines the summations and 
      ++ definite integrals split on additive terms and products split on 
      ++ multiplicative terms. This performs reverse operation as in case 
      ++ of SplitFunctions function. 
      ++ Calling Sequence: combineSplitFunctions(expr), Parameters:
      ++ expr - expression.
   
	
	
  Implementation ==  add 
  
    kernelHandler(x) ==>  -- macro
      mk:UK:=mainKernel(x)
      if mk case KX then K:KX:=mk else return x
      A:List X:=argument K 
      v:Symbol:=retract(A.3)@Symbol
        
    splitSum(x:X,s:X):X ==
      kernelHandler(x)
      S1:=summation(subst(A.1,A.2=A.3),equation(v,segment(A.4,s)$SX)$SBX)
      S2:=summation(subst(A.1,A.2=A.3),equation(v,segment(s+1,A.5)$SX)$SBX)
      S1+S2
      
    splitProduct(x:X,s:X):X ==
      kernelHandler(x)
      S1:=product(subst(A.1,A.2=A.3),equation(v,segment(A.4,s)$SX)$SBX)
      S2:=product(subst(A.1,A.2=A.3),equation(v,segment(s+1,A.5)$SX)$SBX)
      S1 * S2

    splitIntegral(x:X,s:X):X ==
      kernelHandler(x)
      S1:=integral(subst(A.1,A.2=A.3),equation(v,segment(A.4,s)$SX)$SBX)
      S2:=integral(subst(A.1,A.2=A.3),equation(v,segment(s,A.5)$SX)$SBX)
      S1+S2

    multiplySum(x:X,s:X):X ==
      kernelHandler(x) 
      summation(s*subst(A.1,A.2=A.3),equation(v,segment(A.4,A.5)$SX)$SBX)

    multiplyProduct(x:X,s:X):X ==
      kernelHandler(x) 
      product(subst(A.1,A.2=A.3)^s,equation(v,segment(A.4,A.5)$SX)$SBX)
      
    multiplyIntegral(x:X,s:X):X ==
      kernelHandler(x) 
      integral(s*subst(A.1,A.2=A.3),equation(v,segment(A.4,A.5)$SX)$SBX)

    splitFunctionSum(x:X):X ==
      kernelHandler(x)
      B:Union(List(X),"failed"):=isPlus(A.1)
      if B case List(X) then
        r:SBX:=equation(v,segment(A.4,A.5)$SX)$SBX
        reduce(_+,[summation(subst(B.j,A.2=A.3),r) for j in 1..#B]) 
      else
        x

    splitFunctionIntegral(x:X):X ==
      kernelHandler(x)
      B:Union(List(X),"failed"):=isPlus(A.1)
      if B case List(X) then
        r:SBX:=equation(v,segment(A.4,A.5)$SX)$SBX
        reduce(_+,[integral(subst(B.j,A.2=A.3),r) for j in 1..#B]) 
      else
        x

    splitFunctionProduct(x:X):X ==
      kernelHandler(x)
      B:Union(List(X),"failed"):=isTimes(A.1)
      if B case List(X) then
        r:SBX:=equation(v,segment(A.4,A.5)$SX)$SBX
        reduce(_*,[product(subst(B.j,A.2=A.3),r) for j in 1..#B]) 
      else
        x

    takeNTermsHighSum(x:X,n:X):X ==
      kernelHandler(x) 
      summation(subst(A.1,A.2=A.3),equation(v,segment(A.5-n+1,A.5)$SX)$SBX)
      
    takeNTermsHighProduct(x:X,n:X):X ==
      kernelHandler(x) 
      product(subst(A.1,A.2=A.3),equation(v,segment(A.5-n+1,A.5)$SX)$SBX)
      
    takeNTermsHighIntegral(x:X,n:X):X ==
      kernelHandler(x) 
      integral(subst(A.1,A.2=A.3),equation(v,segment(A.5-n+1,A.5)$SX)$SBX)      
      
    takeNTermsLowSum(x:X,n:X):X ==
      kernelHandler(x) 
      summation(subst(A.1,A.2=A.3),equation(v,segment(A.4,A.4+n-1)$SX)$SBX)
      
    takeNTermsLowProduct(x:X,n:X):X ==
      kernelHandler(x) 
      product(subst(A.1,A.2=A.3),equation(v,segment(A.4,A.4+n-1)$SX)$SBX) 
      
    takeNTermsLowIntegral(x:X,n:X):X ==
      kernelHandler(x) 
      integral(subst(A.1,A.2=A.3),equation(v,segment(A.4,A.4+n-1)$SX)$SBX) 
       
    shiftNTermsSum(x:X,n:X):X ==
      kernelHandler(x) 
      summation(subst(A.1,A.2=A.3-n),equation(v,segment(A.4+n,A.5+n)$SX)$SBX)
      
    shiftNTermsProduct(x:X,n:X):X ==
      kernelHandler(x) 
      product(subst(A.1,A.2=A.3-n),equation(v,segment(A.4+n,A.5+n)$SX)$SBX)
      
    shiftNTermsIntegral(x:X,n:X):X ==
      kernelHandler(x) 
      integral(subst(A.1,A.2=A.3-n),equation(v,segment(A.4+n,A.5+n)$SX)$SBX)
      

    sfloor(x:X):X ==
      f:BasicOperator := operator('floor,1)
      if R has RetractableTo(Integer) then
        rx:Union(Fraction Integer, "failed"):=retractIfCan(x)
        if rx case Fraction(Integer) then return floor(rx)::X
      f(x)

    sceiling(x:X):X ==
      c:BasicOperator := operator('ceiling,1)
      if R has RetractableTo(Integer) then
        rx:Union(Fraction Integer, "failed"):=retractIfCan(x)
        if rx case Fraction(Integer) then return ceiling(rx)::X
      c(x)

    startsplit(x:X):X ==
      ss:BasicOperator := operator('startSplit,1)
      if R has RetractableTo(Integer) then
        rx:Union(Integer, "failed"):=retractIfCan(x)
        if rx case Integer then
          q:Fraction Integer:=rx/2
          if odd? rx then
            return ceiling(q)::X
          else
            return (1+ceiling(q))::X
      ss(x)
      
       
    splitTermsEvenOddSum(x:X):X ==
      kernelHandler(x)
      s1:SX:=segment(sceiling(A.4/2::X),sfloor(A.5/2::X))$SX
      s2:SX:=segment(startsplit(A.4), sceiling(A.5/2::X))$SX
      S1:=summation(subst(A.1,A.2=2*A.3),equation(v,s1)$SBX)
      S2:=summation(subst(A.1,A.2=2*A.3-1),equation(v,s2)$SBX)
      S1+S2
      -- TODO: complete this
      -- DONE: see ref
      
    splitTermsEvenOddProduct(x:X):X ==
      kernelHandler(x)
      s1:SX:=segment(sceiling(A.4/2::X),sfloor(A.5/2::X))$SX
      s2:SX:=segment(startsplit(A.4), sceiling(A.5/2::X))$SX
      S1:=product(subst(A.1,A.2=2*A.3),equation(v,s1)$SBX)
      S2:=product(subst(A.1,A.2=2*A.3-1),equation(v,s2)$SBX)
      S1 * S2

    reverseOrderSum(x:X):X ==
      kernelHandler(x)
      s:SX:=segment(A.4-A.4,A.5-A.4)$SX
      summation(subst(A.1,A.2=A.5-A.3),equation(v,s)$SBX)
      
    reverseOrderProduct(x:X):X ==
      kernelHandler(x)
      s:SX:=segment(A.4-A.4,A.5-A.4)$SX
      product(subst(A.1,A.2=A.5-A.3),equation(v,s)$SBX)
      
    reverseOrderIntegral(x:X):X ==
      kernelHandler(x)
      s:SX:=segment(A.5,A.4)$SX
      --integral(subst(A.1,A.2=A.5-A.3),equation(v,s)$SBX)
      -integral(A.1,equation(v,s)$SBX)

    takeTermsValueSum(x:X,a:X,b:X):X ==
      kernelHandler(x)
      s:SX:=segment(a,b)$SX      
      summation(subst(A.1,A.2=A.3),equation(v,s)$SBX)

    takeTermsValueProduct(x:X,a:X,b:X):X ==
      kernelHandler(x)
      s:SX:=segment(a,b)$SX      
      product(subst(A.1,A.2=A.3),equation(v,s)$SBX)

    takeTermsValueIntegral(x:X,a:X,b:X):X ==
      kernelHandler(x)
      s:SX:=segment(a,b)$SX      
      integral(A.1,equation(v,s)$SBX)

    chkList(x:List List X,i:Integer):Boolean ==
      -- check if all lists have same element at pos i
      empty? x => false
      any?((t:List X):Boolean+->#t<i,x) => false
      any?((t:List X):Boolean+->t.i ~= x.1.i,x) => false
      true
  
    combineSplitFunctionsSum(x:X):X ==
      p:=isPlus x
      p case "failed" => x
      l:List List X :=[]
      for y in p repeat
        kernelHandler(y)
        l:=cons(A,l) -- A<-[x g'(%N), %N, k, 1, N]
      not chkList(l,4) => x
      not chkList(l,5) => x
      k:=l.1.3
      a:=l.1.4
      b:=l.1.5
      c:X:=reduce(_+,[subst(t.1,t.2=k) for t in l])
      summation(c,equation(v,segment(a,b)$SX)$SBX)
        

    --
    -- Exports
    --
    splitOp(x:X,s:X):X ==
      is?(x,'%defsum) => splitSum(x,s)
      is?(x,'%defprod) => splitProduct(x,s)
      is?(x,'%defint) => splitIntegral(x,s)
      return x
      
    multiplyOp(x:X,s:X):X ==
      is?(x,'%defsum) => multiplySum(x,s)
      is?(x,'%defprod) => multiplyProduct(x,s)
      is?(x,'%defint) => multiplyIntegral(x,s)
      return x
 
    splitFunctions(x:X):X ==
      is?(x,'%defsum) => splitFunctionSum(x)
      is?(x,'%defprod) => splitFunctionProduct(x)
      is?(x,'%defint) => splitFunctionIntegral(x)
      return x      

    takeNTermsHigh(x:X,n:X):X ==
      is?(x,'%defsum) => takeNTermsHighSum(x,n)
      is?(x,'%defprod) => takeNTermsHighProduct(x,n)
      is?(x,'%defint) => takeNTermsHighIntegral(x,n)
      return x  
      
    takeNTermsLow(x:X,n:X):X ==
      is?(x,'%defsum) => takeNTermsLowSum(x,n)
      is?(x,'%defprod) => takeNTermsLowProduct(x,n)
      is?(x,'%defint) => takeNTermsLowIntegral(x,n)
      return x  
      
    shiftNTerms(x:X,n:X):X ==
      is?(x,'%defsum) => shiftNTermsSum(x,n)
      is?(x,'%defprod) => shiftNTermsProduct(x,n)
      is?(x,'%defint) => shiftNTermsIntegral(x,n)
      return x        

    splitTermsEvenOdd(x:X):X ==
      is?(x,'%defsum) => splitTermsEvenOddSum(x)
      is?(x,'%defprod) => splitTermsEvenOddProduct(x)
      return x       
      
    reverseOrder(x:X):X ==
      is?(x,'%defsum) => reverseOrderSum(x)
      is?(x,'%defprod) => reverseOrderProduct(x)
      is?(x,'%defint) => reverseOrderIntegral(x)
      return x  

    getCoefficient(x:X,k:X,invar:X):X ==
      kernelHandler(x) 
      y:X:=eval(A.1,A.2=k)/(invar)^k
      freeOf?(y,invar) => y
      x
      
    takeTermsValue(x:X,a:X,b:X):X ==
      is?(x,'%defsum) => takeTermsValueSum(x,a,b)
      is?(x,'%defprod) => takeTermsValueProduct(x,a,b)
      is?(x,'%defint) => takeTermsValueIntegral(x,a,b)
      return x  
      
    combineSplitFunctions(x:X):X ==
      ops:List Symbol:=[name s for s in  operators x]
      member?('%defsum,ops) => combineSplitFunctionsSum(x)
      return x

--  X := operator 'X ; T:=summation(X(s),s=a..b)
--  P:=summation(X(s)*x^s,s=0..b)
--  f(n)==eval(P,b=n)
--  D(P,x,2)
--  name mainKernel(P) ->> %defsum