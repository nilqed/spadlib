This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.


File: maxima.info,  Node: Funciones y variables para gráficos estadísticos,  Prev: Funciones y variables de parámetros descriptivos,  Up: descriptive

44.4 Funciones y variables para gráficos estadísticos
=====================================================

 -- Función: barsplot (<data1>, <data2>, ..., <option_1>, <option_2>,
          ...)
 -- Función: barsplot_description (...)

     Dibuja diagramas de barras para variables estadísticas discretas,
     tanto para una como para más muestras.

     <data> puede ser una lista de resultados provenientes de una
     muestra o una matriz de <m> filas y <n> columnas, representando <n>
     muestras de tamaño <m> cada una.

     Las opciones disponibles son:

          <box_width> (valor por defecto, '3/4'): ancho relativo de los
          rectángulos.  Este valor debe pertenecer al rango '[0,1]'.

        * <grouping> (valor por defecto, 'clustered'): indica cómo se
          agrupan las diferentes muestras.  Son valores válidos:
          'clustered' y 'stacked'.

        * <groups_gap> (valor por defecto, '1'): un número positivo que
          representa la separación entre dos grupos consecutivos de
          barras.

        * <bars_colors> (valor por defecto, '[]'): una lista de colores
          para múltiples muestras.  Cuando el número de muestras sea
          mayor que el de colores especificados, los colores adicionales
          necesarios se seleccionan aleatoriamente.  Véase 'color' para
          más información.

        * <frequency> (valor por defecto, 'absolute'): indica la escala
          de las ordenadas.  Valores admitidos son: 'absolute',
          'relative' y and 'percent'.

        * <ordering> (valor por defecto, 'orderlessp'): los valores
          admitidos para esta opción son: 'orderlessp' y 'ordergreatp',
          indicando cómo se deben ordenar los resultados muestrales
          sobre el eje-<x>.

        * <sample_keys> (valor por defecto, '[]'): es una lista de
          cadenas de texto a usar como leyendas.  Cuando la lista tenga
          una longitud diferente de cero o del número de muestras, se
          devolverá un mensaje de error.

        * <start_at> (valor por defecto, '0'): indica a qué altura
          comienza a dibujarse el gráfico de barra sobre el eje de
          abscisas.

        * Todas las opciones globales de 'draw', excepto 'xtics', que se
          asigna internamente por 'barsplot'.  Si es necesario que el
          usuario le dé su propio valor a esta opción, o quiere
          construir una escena más compleja, debe hacer uso de
          'barsplot_description'.  Véase el ejemplo más abajo.

        * Las siguientes opciones locales de 'draw': 'key', 'color',
          'fill_color', 'fill_density' y 'line_width'.  Véase también
          'bars'.

     La función 'barsplot_description' crea un objeto gráfico útil para
     formar escenas complejas, junto con otros objetos gráficos.  Se
     dispone también de la función 'wxbarsplot' para crear histogramas
     incorporados en los interfaces wxMaxima y iMaxima.

     Ejemplos:

     Muestra univariante en formato matricial.  Frecuencias absolutas.

          (%i1) load (descriptive)$
          (%i2) m : read_matrix (file_search ("biomed.data"))$
          (%i3) barsplot(
                  col(m,2),
                  title        = "Ages",
                  xlabel       = "years",
                  box_width    = 1/2,
                  fill_density = 3/4)$

     Dos muestras de diferente tamaño, con frecuencias relativas y
     colores definidos por el usuario.

          (%i1) load (descriptive)$
          (%i2) l1:makelist(random(10),k,1,50)$
          (%i3) l2:makelist(random(10),k,1,100)$
          (%i4) barsplot(
                  l1,l2,
                  box_width    = 1,
                  fill_density = 1,
                  bars_colors  = [black, grey],
                  frequency = relative,
                  sample_keys = ["A", "B"])$

     Cuatro muestras no numéricas de igual tamaño.

          (%i1) load (descriptive)$
          (%i2) barsplot(
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  title  = "Asking for something to four groups",
                  ylabel = "# of individuals",
                  groups_gap   = 3,
                  fill_density = 0.5,
                  ordering     = ordergreatp)$

     Barras apiladas verticalmente.

          (%i1) load (descriptive)$
          (%i2) barsplot(
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  title  = "Asking for something to four groups",
                  ylabel = "# of individuals",
                  grouping     = stacked,
                  fill_density = 0.5,
                  ordering     = ordergreatp)$

     'barsplot' en un contexto multiplot.

          (%i1) load (descriptive)$
          (%i2) l1:makelist(random(10),k,1,50)$
          (%i3) l2:makelist(random(10),k,1,100)$
          (%i4) bp1 :
                  barsplot_description(
                   l1,
                   box_width = 1,
                   fill_density = 0.5,
                   bars_colors = [blue],
                   frequency = relative)$
          (%i5) bp2 :
                  barsplot_description(
                   l2,
                   box_width = 1,
                   fill_density = 0.5,
                   bars_colors = [red],
                   frequency = relative)$
          (%i6) draw(gr2d(bp1), gr2d(bp2))$

     Para las opciones relacionadas con los diagramas de barras, véase
     'bars' del paquete 'draw'.

     Véanse también las funciones 'histogram' y 'piechart'.

 -- Función: boxplot (<data>)
 -- Función: boxplot (<data>, <option_1>, <option_2>, ...)
 -- Función: boxplot_description (...)

     Dibuja diagramas de cajas (box-and-whishker).  El argumento <data>
     puede ser una lista, lo cual no es de gran interés, puesto que
     estos gráficos se utilizan principalmente para comparar distintas
     muestras, o una matriz, de manera que sea posible comparar dos o
     más componentes de una muestra multivariante.  También se permite
     que <data> sea una lista de muestras con posibles tamaños
     diferentes; de hecho, esta es la única función del paquete
     'descriptive' que admite esta estructura de datos.

     La caja se dibuja desde el primer cuartil hasta el tercero, con un
     segmento horizontal situado a la altura del segundo cuartil o
     mediana.  Por defecto, los bigotes inferior y superior se sitúan a
     la altura de los valores mínimo y máximo, respectivamente.  La
     opción <range> se puede utilizar para indicar que los valores
     mayores que
     'quantile(x,3/4)+range*(quantile(x,3/4)-quantile(x,1/4))', o
     menores que
     'quantile(x,1/4)-range*(quantile(x,3/4)-quantile(x,1/4))', deben
     considerarse atípicos, en cuyo caso se dibujan como puntos
     aislados, al tiempo que los bigotes se colocan en los extremos del
     resto de la muestra.

     Opciones disponibles:

        * <box_width> (valor por defecto, '3/4'): ancho relativo de las
          cajas.  This value must be in the range '[0,1]'.

        * <box_orientation> (valor por defecto, 'vertical'): valores
          posibles: 'vertical' y 'horizontal'.

        * <range> (valor por defecto, 'inf'): coeficiente positivo del
          rango intercuartílico para declarar los límites de los datos
          atípicos.

        * <outliers_size> (valor por defecto, '1'): tamaño de los
          círculos para los datos atípicos.

        * Todas las opciones globales de 'draw', excepto
          'points_joined', 'point_size', 'point_type', 'xtics', 'ytics',
          'xrange' y 'yrange', que se asignan internamente por
          'boxplot'.  Si es necesario que el usuario le dé sus propios
          valores a estas opciones, o quiere construir una escena más
          compleja, debe hacer uso de 'boxplot_description'.

        * Las siguientes opciones locales de 'draw': 'key', 'color', y
          'line_width'.

     La función 'boxplot_description' crea un objeto gráfico útil para
     formar escenas complejas, junto con otros objetos gráficos.  Se
     dispone también de la función 'wxboxplot' para crear histogramas
     incorporados en los interfaces wxMaxima y iMaxima.

     Ejemplos:

     Diagrama de cajas de una muestra multivariante.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix(file_search("wind.data"))$
          (%i3) boxplot(s2,
                  box_width  = 0.2,
                  title      = "Windspeed in knots",
                  xlabel     = "Stations",
                  color      = red,
                  line_width = 2)$

     Diagrama de cajas de tres muestras de tamaños diferentes.

          (%i1) load (descriptive)$
          (%i2) A :
                 [[6, 4, 6, 2, 4, 8, 6, 4, 6, 4, 3, 2],
                  [8, 10, 7, 9, 12, 8, 10],
                  [16, 13, 17, 12, 11, 18, 13, 18, 14, 12]]$
          (%i3) boxplot (A, box_orientation = horizontal)$

     La opción <range> puede utilizarse para tratar con datos atípicos.

          (%i1) load (descriptive)$
          (%i2) B: [[7, 15, 5, 8, 6, 5, 7, 3, 1],
                    [10, 8, 12, 8, 11, 9, 20],
                    [23, 17, 19, 7, 22, 19]] $
          (%i3) boxplot (B, range=1)$
          (%i4) boxplot (B, range=1.5, box_orientation = horizontal)$
          (%i5) draw2d(
                  boxplot_description(
                    B,
                    range            = 1.5,
                    line_width       = 3,
                    outliers_size    = 2,
                    color            = red,
                    background_color = light_gray),
                  xtics = {["Low",1],["Medium",2],["High",3]}) $

 -- Función: histogram (<list>)
 -- Función: histogram (<list>, <option_1>, <option_2>, ...)
 -- Función: histogram (<one_column_matrix>)
 -- Función: histogram (<one_column_matrix>, <option_1>, <option_2>,
          ...)
 -- Función: histogram (<one_row_matrix>)
 -- Función: histogram (<one_row_matrix>, <option_1>, <option_2>, ...)
 -- Función: histogram_description (...)

     Dibuja un histograma a partir de una muestra continua.  Los datos
     muestrales deben darse en forma de lista de números o como una
     matriz unidimensional.

     Opciones dispponibles:

        * <nclasses> (valor por defecto, '10'): número de clases del
          histograma, o una lista indicando los límites de las clases y
          su número, o solamente los límites.

        * <frequency> (valor por defecto, 'absolute'): indica la escala
          de las ordenadas.  Valores admitidos son: 'absolute',
          'relative', 'percent' y 'density'.  Con 'density', el
          histograma adquiere un área total igual a uno.

        * <htics> (valor por defecto, 'auto'): formato para las marcas
          sobre el eje de las abscisas.  Valores admitidos son: 'auto',
          'endpoints', 'intervals' o una lista de etiquetas.

        * Todas las opciones globales de 'draw', excepto 'xrange',
          'yrange' y 'xtics', que son asignadas internamente por
          'histogram'.  Si es necesario que el usuario le dé sus propios
          valores a estas opciones, debe hacer uso de
          'histogram_description'.  Véase el ejemplo más abajo.

        * Las siguientes opciones locales de 'draw': 'key', 'color',
          'fill_color', 'fill_density' y 'line_width'.  Véase también
          'bars'.

     La función 'histogram_description' crea un objeto gráfico útil para
     formar escenas complejas, junto con otros objetos gráficos.  Se
     dispone también de la función 'wxhistogram' para crear histogramas
     incorporados en los interfaces wxMaxima y iMaxima.

     Ejemplos:

     Un histograma con seis clases:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) histogram (
                     s1,
                     nclasses     = 8,
                     title        = "pi digits",
                     xlabel       = "digits",
                     ylabel       = "Absolute frequency",
                     fill_color   = grey,
                     fill_density = 0.6)$

     Ajustando los límites del histograma a -2 y 12, con 3 clases.
     También se establece un formato predefinido a las marcas del eje de
     abscisas:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) histogram (
                     s1,
                     nclasses     = [-2,12,3],
                     htics        = ["A", "B", "C"],
                     terminal     = png,
                     fill_color   = "#23afa0",
                     fill_density = 0.6)$

     Se hace uso de 'histogram_description' para ajustar la opción
     'xrange' y añadir una curva explícita a la escena:

          (%i1) load (descriptive)$
          (%i2) ( load("distrib"),
                  m: 14, s: 2,
                  s2: random_normal(m, s, 1000) ) $
          (%i3) draw2d(
                  grid   = true,
                  xrange = [5, 25],
                  histogram_description(
                    s2,
                    nclasses     = 9,
                    frequency    = density,
                    fill_density = 0.5),
                  explicit(pdf_normal(x,m,s), x, m - 3*s, m + 3* s))$

 -- Función: piechart (<list>)
 -- Función: piechart (<list>, <option_1>, <option_2>, ...)
 -- Función: piechart (<one_column_matrix>)
 -- Función: piechart (<one_column_matrix>, <option_1>, <option_2>, ...)
 -- Función: piechart (<one_row_matrix>)
 -- Función: piechart (<one_row_matrix>, <option_1>, <option_2>, ...)
 -- Función: piechart_description (...)

     Similar a 'barsplot', pero dibuja sectores en lugar de rectángulos.

     Opciones disponibles:

        * <sector_colors> (valor por defecto, '[]'): una lista de
          colores para los sectores.  Cuando el número de sectores sea
          mayor que el de colores especificados, los colores adicionales
          necesarios se seleccionan aleatoriamente.  Véase 'color' para
          más información.

        * <pie_center> (valor por defecto, '[0,0]'): centro del diagrama

        * <pie_radius> (valor por defecto, '1'): radio del diagrama.

        * Todas las opciones globales de 'draw', excepto 'key', que se
          asigna internamente por 'piechart'.  Si es necesario que el
          usuario le dé su propio valor a esta opción, o quiere
          construir una escena más compleja, debe hacer uso de
          'piechart_description'.

        * Las siguientes opciones locales de 'draw': 'key', 'color',
          'fill_density' y 'line_width'.  Véase también 'bars'.

     La función 'piechart_description' crea un objeto gráfico útil para
     formar escenas complejas, junto con otros objetos gráficos.  Se
     dispone también de la función 'wxpiechart' para crear histogramas
     incorporados en los interfaces wxMaxima y iMaxima.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) piechart(
                  s1,
                  xrange  = [-1.1, 1.3],
                  yrange  = [-1.1, 1.1],
                  title   = "Digit frequencies in pi")$

     Véase también la función 'barsplot'.

 -- Función: scatterplot (<list>)
 -- Función: scatterplot (<list>, <option_1>, <option_2>, ...)
 -- Función: scatterplot (<matrix>)
 -- Función: scatterplot (<matrix>, <option_1>, <option_2>, ...)
 -- Función: scatterplot_description (...)

     Dibuja diagramas de dispersión, tanto de muestras univariantes
     (<list>) como multivariantes (<matrix>).

     Las opciones disponibles son las mismas que admite 'histogram'.

     La función 'scatterplot_description' crea un objeto gráfico útil
     para formar escenas complejas, junto con otros objetos gráficos.
     Se dispone también de la función 'wxscatterplot' para crear
     histogramas incorporados en los interfaces wxMaxima y iMaxima.

     Ejemplos:

     Diagrama de dispersión univariante a partir de una muestra normal
     simulada.

          (%i1) load (descriptive)$
          (%i2) load (distrib)$
          (%i3) scatterplot(
                  random_normal(0,1,200),
                  xaxis      = true,
                  point_size = 2,
                  dimensions = [600,150])$

     Diagrama de dispersión bidimensional.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) scatterplot(
                 submatrix(s2, 1,2,3),
                 title      = "Data from stations #4 and #5",
                 point_type = diamant,
                 point_size = 2,
                 color      = blue)$

     Diagrama de dispersión tridimensional.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) scatterplot(submatrix (s2, 1,2), nclasses=4)$

     Diagrama de dispersión de cinco dimensiones, con histogramas de
     cinco classes.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) scatterplot(
                  s2,
                  nclasses     = 5,
                  frequency    = relative,
                  fill_color   = blue,
                  fill_density = 0.3,
                  xtics        = 5)$

     Para dibujar puntos aislados o unidos por segmentos, tanto en dos
     como en tres dimensiones, véase 'points'.  Véase también
     'histogram'.

 -- Función: starplot (<data1>, <data2>, ..., <option_1>, <option_2>,
          ...)
 -- Función: starplot_description (...)

     Dibuja diagramas de estrellas para variables estadísticas
     discretas, tanto para una como para más muestras.

     <data> puede ser una lista de resultados provenientes de una
     muestra o una matriz de <m> filas y <n> columnas, representando <n>
     muestras de tamaño <m> cada una.

     Las opciones disponibles son:

        * <stars_colors> (valor por defecto, '[]'): una lista de colores
          para muestras múltiples.  Cuando haya más muestras que colores
          especificados, los colores que faltan se eligen
          aleatoriamente.  Véase 'color' para más información.

        * <frequency> (valor por defecto, 'absolute'): indica la escala
          de los radios.  Valores admitidos son: 'absolute' y
          'relative'.

        * <ordering> (valor por defecto, 'orderlessp'): los valores
          admitidos para esta opción son: 'orderlessp' y 'ordergreatp',
          indicando cómo se deben ordenar los resultados muestrales
          sobre el eje-<x>.

        * <sample_keys> (valor por defecto, '[]'): es una lista de
          cadenas de texto a usar como leyendas.  Cuando la lista tenga
          una longitud diferente de cero o del número de muestras, se
          devolverá un mensaje de error.

        * <star_center> (valor por defecto, '[0,0]'): centro del
          diagrama.

        * <star_radius> (valor por defecto, '1'): radio del diagrama.

        * Todas las opciones globales de 'draw', excepto
          'points_joined', 'point_type', and 'key', que se asignan
          internamente por 'starplot'.  Si es necesario que el usuario
          les dé sus propios valores a estas opciones, o quiere
          construir una escena más compleja, debe hacer uso de
          'starplot_description'.

        * La siguiente opción local de 'draw': 'line_width'.

     La función 'starplot_description' crea un objeto gráfico útil para
     formar escenas complejas, junto con otros objetos gráficos.  Se
     dispone también de la función 'wxstarplot' para crear histogramas
     incorporados en los interfaces wxMaxima y iMaxima.

     Ejemplo:

     Gráfico basado en frecuencias absolutas.  La localización y el
     radios lo define el usuario.

          (%i1) load (descriptive)$
          (%i2) l1: makelist(random(10),k,1,50)$
          (%i3) l2: makelist(random(10),k,1,200)$
          (%i4) starplot(
                  l1, l2,
                  stars_colors = [blue,red],
                  sample_keys = ["1st sample", "2nd sample"],
                  star_center = [1,2],
                  star_radius = 4,
                  proportional_axes = xy,
                  line_width = 2 ) $

 -- Función: stemplot (<m>)
 -- Función: stemplot (<m>, <option>)

     Dibuja diagrama de tallos y hojas.

     La única opción disponible es:

        * <leaf_unit> (valor por defecto, '1'): indica la unidad de las
          hojas; debe ser una potencia de 10.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load(distrib)$
          (%i3) stemplot(
                  random_normal(15, 6, 100),
                  leaf_unit = 0.1);
          -5|4
           0|37
           1|7
           3|6
           4|4
           5|4
           6|57
           7|0149
           8|3
           9|1334588
          10|07888
          11|01144467789
          12|12566889
          13|24778
          14|047
          15|223458
          16|4
          17|11557
          18|000247
          19|4467799
          20|00
          21|1
          22|2335
          23|01457
          24|12356
          25|455
          27|79
          key: 6|3 =  6.3
          (%o3)                  done


File: maxima.info,  Node: diag,  Next: distrib,  Prev: descriptive,  Up: Top

45 diag
*******

* Menu:

* Funciones y variables para diag::


File: maxima.info,  Node: Funciones y variables para diag,  Prev: diag,  Up: diag

45.1 Funciones y variables para diag
====================================

 -- Función: diag (<lm>)
     Genera una matriz cuadrada con las matrices de <lm> en la diagonal,
     siendo <lm> una lista de matrices o de escalares.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) a1:matrix([1,2,3],[0,4,5],[0,0,6])$

          (%i3) a2:matrix([1,1],[1,0])$

          (%i4) diag([a1,x,a2]);
                             [ 1  2  3  0  0  0 ]
                             [                  ]
                             [ 0  4  5  0  0  0 ]
                             [                  ]
                             [ 0  0  6  0  0  0 ]
          (%o4)              [                  ]
                             [ 0  0  0  x  0  0 ]
                             [                  ]
                             [ 0  0  0  0  1  1 ]
                             [                  ]
                             [ 0  0  0  0  1  0 ]

     Antes de hacer uso de esta función ejecútese 'load("diag")'.

 -- Función: JF (<lambda>,<n>)
     Devuelve la célula de Jordan de orden <n> con valor propio
     <lambda>.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) JF(2,5);
                              [ 2  1  0  0  0 ]
                              [               ]
                              [ 0  2  1  0  0 ]
                              [               ]
          (%o2)               [ 0  0  2  1  0 ]
                              [               ]
                              [ 0  0  0  2  1 ]
                              [               ]
                              [ 0  0  0  0  2 ]
          (%i3) JF(3,2);
                                   [ 3  1 ]
          (%o3)                    [      ]
                                   [ 0  3 ]

     Antes de hacer uso de esta función ejecútese 'load("diag")'.

 -- Función: jordan (<mat>)
     Devuelve la forma de Jordan de la matriz <mat>, pero en formato de
     lista de Maxima.  Para obtener la matriz correspondiente, llámese a
     la función 'dispJordan' utilizando como argumento la salida de
     'jordan'.

     Ejemplo:
          (%i1) load("diag")$

          (%i3) a:matrix([2,0,0,0,0,0,0,0],
                         [1,2,0,0,0,0,0,0],
                         [-4,1,2,0,0,0,0,0],
                         [2,0,0,2,0,0,0,0],
                         [-7,2,0,0,2,0,0,0],
                         [9,0,-2,0,1,2,0,0],
                         [-34,7,1,-2,-1,1,2,0],
                         [145,-17,-16,3,9,-2,0,3])$

          (%i34) jordan(a);
          (%o4)             [[2, 3, 3, 1], [3, 1]]
          (%i5) dispJordan(%);
                          [ 2  1  0  0  0  0  0  0 ]
                          [                        ]
                          [ 0  2  1  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  2  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  0  2  1  0  0  0 ]
          (%o5)           [                        ]
                          [ 0  0  0  0  2  1  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  2  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  2  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  0  3 ]

     Antes de hacer uso de esta función ejecútese 'load("diag")'.
     Véanse también 'dispJordan' y 'minimalPoly'.

 -- Función: dispJordan (<l>)
     Devuelve la matriz de Jordan asociada a la codificación dada por la
     lista <l>, que habitualmente será la salida de la función 'jordan'.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i3) jordan(b1);
          (%o3)                  [[0, 3, 2]]
          (%i4) dispJordan(%);
                              [ 0  1  0  0  0 ]
                              [               ]
                              [ 0  0  1  0  0 ]
                              [               ]
          (%o4)               [ 0  0  0  0  0 ]
                              [               ]
                              [ 0  0  0  0  1 ]
                              [               ]
                              [ 0  0  0  0  0 ]

     Antes de hacer uso de esta función ejecútese 'load("diag")'.
     Véanse también 'jordan' y 'minimalPoly'.

 -- Función: minimalPoly (<l>)
     Devuelve el polinomio mínimo asociado a la codificación dada por la
     lista <l>, que habitualmente será la salida de la función 'jordan'.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                         [-2,2,1,2],
                         [-2,-1,-1,1],
                         [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) minimalPoly(%);
                                      3
          (%o4)                (x - 1)  (x + 1)

     Antes de hacer uso de esta función ejecútese 'load("diag")'.
     Véanse también 'jordan' y 'dispJordan'.

 -- Función: ModeMatrix (<A>,<l>)
     Devuelve la matriz <M> tal que (M^^-1).A.M=J, donde <J> es la forma
     de Jordan de <A>.  La lista <l> es la forma codificada de la forma
     de Jordan tal como la devuelve la función 'jordan'.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                    [-2,2,1,2],
                    [-2,-1,-1,1],
                    [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) M: ModeMatrix(a,%);
                            [  1    - 1   1   1 ]
                            [                   ]
                            [   1               ]
                            [ - -   - 1   0   0 ]
                            [   9               ]
                            [                   ]
          (%o4)             [   13              ]
                            [ - --   1   - 1  0 ]
                            [   9               ]
                            [                   ]
                            [  17               ]
                            [  --   - 1   1   1 ]
                            [  9                ]
          (%i5) is(  (M^^-1).a.M = dispJordan(%o3)  );
          (%o5)                      true
     Nótese que 'dispJordan(%o3)' es la forma de Jordan de la matriz
     'a'.

     Antes de hacer uso de esta función ejecútese 'load("diag")'.
     Véanse también 'jordan' y 'dispJordan'.

 -- Función: mat_function (<f>,<mat>)
     Devuelve f(mat), siendo <f> una función analítica y <mat> una
     matriz.  Este cálculo se basa en la fórmula integral de Cauchy, que
     establece que si 'f(x)' es analítica y
          mat=diag([JF(m1,n1),...,JF(mk,nk)]),

     entonces

          f(mat)=ModeMatrix*diag([f(JF(m1,n1)),...,f(JF(mk,nk))])
                    * ModeMatrix^^(-1)

     Nótese que hay otros métodos alternativos para realizar este
     cálculo.

     Se presentan algunos ejemplos.

     Ejemplo 1:
          (%i1) load("diag")$

          (%i2) b2:matrix([0,1,0], [0,0,1], [-1,-3,-3])$

          (%i3) mat_function(exp,t*b2);
                         2   - t
                        t  %e          - t     - t
          (%o3) matrix([-------- + t %e    + %e   ,
                           2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) + t (2 %e    - -----)
                  t       2                             t
                         t
                                   - t          - t     - t
                 - t       - t   %e        2  %e      %e
           + 2 %e   , t (%e    - -----) + t  (----- - -----)
                                   t            2       t
                         2   - t            - t     - t
               - t      t  %e        2    %e      %e        - t
           + %e   ], [- --------, - t  (- ----- - ----- + %e   ),
                           2                t       2
                                                   t
                  - t     - t      2   - t
             2  %e      %e        t  %e          - t
          - t  (----- - -----)], [-------- - t %e   ,
                  2       t          2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) - t (2 %e    - -----),
                  t       2                             t
                         t
                - t     - t                 - t
           2  %e      %e            - t   %e
          t  (----- - -----) - t (%e    - -----)])
                2       t                   t
          (%i4) ratsimp(%);
                         [   2              - t ]
                         [ (t  + 2 t + 2) %e    ]
                         [ -------------------- ]
                         [          2           ]
                         [                      ]
                         [         2   - t      ]
          (%o4)  Col 1 = [        t  %e         ]
                         [      - --------      ]
                         [           2          ]
                         [                      ]
                         [     2          - t   ]
                         [   (t  - 2 t) %e      ]
                         [   ----------------   ]
                         [          2           ]
                   [      2        - t    ]
                   [    (t  + t) %e       ]
                   [                      ]
           Col 2 = [     2            - t ]
                   [ - (t  - t - 1) %e    ]
                   [                      ]
                   [     2          - t   ]
                   [   (t  - 3 t) %e      ]
                   [        2   - t       ]
                   [       t  %e          ]
                   [       --------       ]
                   [          2           ]
                   [                      ]
                   [      2          - t  ]
           Col 3 = [    (t  - 2 t) %e     ]
                   [  - ----------------  ]
                   [           2          ]
                   [                      ]
                   [   2              - t ]
                   [ (t  - 4 t + 2) %e    ]
                   [ -------------------- ]
                   [          2           ]

     Ejemplo 2:
          (%i5) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i6) mat_function(exp,t*b1);
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o6)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i7) minimalPoly(jordan(b1));
                                       3
          (%o7)                       x
          (%i8) ident(5)+t*b1+1/2*(t^2)*b1^^2;
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o8)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i9) mat_function(exp,%i*t*b1);
                       [                           2 ]
                       [                          t  ]
                       [ 1  0  %i t  %i t  %i t - -- ]
                       [                          2  ]
                       [                             ]
          (%o9)        [ 0  1   0    %i t    %i t    ]
                       [                             ]
                       [ 0  0   1     0      %i t    ]
                       [                             ]
                       [ 0  0   0     1        0     ]
                       [                             ]
                       [ 0  0   0     0        1     ]
          (%i10) mat_function(cos,t*b1)+%i*mat_function(sin,t*b1);
                        [                           2 ]
                        [                          t  ]
                        [ 1  0  %i t  %i t  %i t - -- ]
                        [                          2  ]
                        [                             ]
          (%o10)        [ 0  1   0    %i t    %i t    ]
                        [                             ]
                        [ 0  0   1     0      %i t    ]
                        [                             ]
                        [ 0  0   0     1        0     ]
                        [                             ]
                        [ 0  0   0     0        1     ]

     Ejemplo 3:
          (%i11) a1:matrix([2,1,0,0,0,0],
                           [-1,4,0,0,0,0],
                           [-1,1,2,1,0,0],
                           [-1,1,-1,4,0,0],
                           [-1,1,-1,1,3,0],
                           [-1,1,-1,1,1,2])$

          (%i12) fpow(x):=block([k],declare(k,integer),x^k)$

          (%i13) mat_function(fpow,a1);
                          [  k      k - 1 ]         [      k - 1    ]
                          [ 3  - k 3      ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [  k      k - 1 ]
                          [  - k 3        ]         [ 3  + k 3      ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
          (%o13)  Col 1 = [               ] Col 2 = [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [  k      k - 1 ]         [      k - 1    ]
                   [ 3  - k 3      ]         [   k 3         ]
                   [               ]         [               ]
           Col 3 = [       k - 1   ] Col 4 = [  k      k - 1 ]
                   [  - k 3        ]         [ 3  + k 3      ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [    0    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
           Col 5 = [    0    ] Col 6 = [    ]
                   [         ]         [ 0  ]
                   [    k    ]         [    ]
                   [   3     ]         [ 0  ]
                   [         ]         [    ]
                   [  k    k ]         [  k ]
                   [ 3  - 2  ]         [ 2  ]

     Antes de hacer uso de esta función ejecútese 'load("diag")'.


File: maxima.info,  Node: distrib,  Next: draw,  Prev: diag,  Up: Top

46 distrib
**********

* Menu:

* Introducción a distrib::
* Funciones y variables para distribuciones continuas::
* Funciones y variables para distribuciones discretas::


File: maxima.info,  Node: Introducción a distrib,  Next: Funciones y variables para distribuciones continuas,  Prev: distrib,  Up: distrib

46.1 Introducción a distrib
===========================

El paquete 'distrib' contiene un conjunto de funciones para la
realización de cálculos probabilísticos con modelos univariantes, tanto
discretos como continuos.

A continuación un breve recordatorio de las deficiones básicas sobre
distribuciones de probabilidad.

Sea f(x) la <función de densidad> de una variable aleatoria X
absolutamente continua.  La <función de distribución> se define como
                            x
                           /
                           [
                    F(x) = I     f(u) du
                           ]
                           /
                            minf
que es igual a la probabilidad <Pr(X <= x)>.

La <media> es un parámetro de localización y se define como
                          inf
                         /
                         [
                E[X]  =  I   x f(x) dx
                         ]
                         /
                          minf

La <varianza> es una medida de dispersión,
                      inf
                     /
                     [                    2
              V[X] = I     f(x) (x - E[X])  dx
                     ]
                     /
                      minf
que es un número real positivo.  La raíz cuadrada de la varianza es la
<desviación típica>, D[X]=sqrt(V[X]), siendo otra medida de dispersión.

El <coeficiente de asimetría> es una medida de forma,
                      inf
                     /
                 1   [                    3
       SK[X] = ----- I     f(x) (x - E[X])  dx
                   3 ]
               D[X]  /
                      minf

Y el <coeficiente de curtosis> mide el apuntamiento de la densidad,
                      inf
                     /
                 1   [                    4
       KU[X] = ----- I     f(x) (x - E[X])  dx - 3
                   4 ]
               D[X]  /
                      minf
Si X es normal, KU[X]=0.  De hecho, tanto la asimetría como la curtosis
son parámetros de forma para medir la no normalidad de una distribución.

Si la variable aleatoria X es discreta, su función de densidad, o de
<probabiliad>, f(x) toma valores positivos dentro de un conjunto
numerable de valores x_i, y cero en cualquier otro lugar.  En este caso,
la función de distribución es
                            ====
                            \
                     F(x) =  >    f(x )
                            /        i
                            ====
                           x <= x
                            i

La media, varianza, desviación típica y los coeficientes de asimetría y
curtosis adquieren las formas
                            ====
                            \
                     E[X] =  >  x  f(x ) ,
                            /    i    i
                            ====
                             x
                              i

                     ====
                     \                     2
             V[X] =   >    f(x ) (x - E[X])  ,
                     /        i    i
                     ====
                      x
                       i

                    D[X] = sqrt(V[X]),

                          ====
                   1      \                     3
       SK[X] =  -------    >    f(x ) (x - E[X])
                D[X]^3    /        i    i
                          ====
                           x
                            i
y
                          ====
                   1      \                     4
       KU[X] =  -------    >    f(x ) (x - E[X])   - 3 ,
                D[X]^4    /        i    i
                          ====
                           x
                            i
respectivamente.

Por favor, consúltese cualquier manual introductorio de probabilidad y
estadística para más información sobre toda esta parafernalia
matemática.

Se sigue cierta convención a la hora de nombrar las funciones del
paquete 'distrib'.  Cada nombre tiene dos partes, el primero hace
referencia a la función o parámetro que se quiere calcular,
     Funciones:
        Función de densidad        (pdf_*)
        Función de distribución    (cdf_*)
        Cuantil                    (quantile_*)
        Media                      (mean_*)
        Varianza                   (var_*)
        Desviación típica          (std_*)
        Coeficiente de asimetría   (skewness_*)
        Coeficiente de curtosis    (kurtosis_*)
        Valor aleatorio            (random_*)

La segunda parte hace referencia explícita al modelo probabilístico,
     Distribuciones continuas:
        Normal              (*normal)
        Student             (*student_t)
        Chi^2               (*chi2)
        Chi^2 no central    (*noncentral_chi2)
        F                   (*f)
        Exponencial         (*exp)
        Lognormal           (*lognormal)
        Gamma               (*gamma)
        Beta                (*beta)
        Continua uniforme   (*continuous_uniform)
        Logística           (*logistic)
        Pareto              (*pareto)
        Weibull             (*weibull)
        Rayleigh            (*rayleigh)
        Laplace             (*laplace)
        Cauchy              (*cauchy)
        Gumbel              (*gumbel)

     Distribuciones discretas:
        Binomial             (*binomial)
        Poisson              (*poisson)
        Bernoulli            (*bernoulli)
        Geométrica           (*geometric)
        Uniforme discreta    (*discrete_uniform)
        Hipergeométrica      (*hypergeometric)
        Binomial negativa    (*negative_binomial)
        Finita discreta      (*general_finite_discrete)

Por ejemplo, 'pdf_student_t(x,n)' es la función de densidad de la
distribución de Student con <n> grados de libertad, 'std_pareto(a,b)' es
la desviación típica de la distribución de Pareto de parámetros <a> y
<b>, y 'kurtosis_poisson(m)' es el coeficiente de curtosis de la
distribución de Poisson de media <m>.

Para poder hacer uso del paquete 'distrib' es necesario cargarlo primero
tecleando
     (%i1) load(distrib)$

Para comentarios, errores o sugerencias, por favor contáctese conmigo en
<'riotorto AT yahoo DOT com'>.


File: maxima.info,  Node: Funciones y variables para distribuciones continuas,  Next: Funciones y variables para distribuciones discretas,  Prev: Introducción a distrib,  Up: distrib

46.2 Funciones y variables para distribuciones continuas
========================================================

 -- Función: pdf_normal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de la variable aleatoria Normal(m,s), con s>0.  Para hacer uso de
     esta función, ejecútese primero 'load(distrib)'.

 -- Función: cdf_normal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de la variable aleatoria Normal(m,s), con s>0.  Esta
     función se define en términos de la función de error, 'erf', de
     Maxima.

          (%i1) load (distrib)$
          (%i2) cdf_normal(x,m,s);
                                              x - m
                                        erf(---------)
                                            sqrt(2) s    1
          (%o2)                         -------------- + -
                                              2          2

     Véase también 'erf'.

 -- Función: quantile_normal (<q>,<m>,<s>)
     Devuelve el <q>-cuantil de una variable aleatoria Normal(m,s), con
     s>0; en otras palabras, es la inversa de 'cdf_normal'.  El
     argumento <q> debe ser un número de [0,1].  Para hacer uso de esta
     función, ejecútese primero 'load(distrib)'.

          (%i1) load (distrib)$
          (%i2) quantile_normal(95/100,0,1);
                                                9
          (%o2)             sqrt(2) inverse_erf(--)
                                                10
          (%i3) float(%);
          (%o3)               1.644853626951472

 -- Función: mean_normal (<m>,<s>)
     Devuelve la media de una variable aleatoria Normal(m,s), con s>0,
     es decir <m>.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: var_normal (<m>,<s>)
     Devuelve la varianza de una variable aleatoria Normal(m,s), con
     s>0, es decir <s^2>.

 -- Función: std_normal (<m>,<s>)
     Devuelve la desviación típica de una variable aleatoria
     Normal(m,s), con s>0, es decir <s>.  Para hacer uso de esta
     función, ejecútese primero 'load(distrib)'.

 -- Función: skewness_normal (<m>,<s>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Normal(m,s), con s>0, que es siempre igual a 0.  Para hacer uso de
     esta función, ejecútese primero 'load(distrib)'.

 -- Función: kurtosis_normal (<m>,<s>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Normal(m,s), con s>0, que es siempre igual a 0.  Para hacer uso de
     esta función, ejecútese primero 'load(distrib)'.

 -- Función: random_normal (<m>,<s>)
 -- Función: random_normal (<m>,<s>,<n>)
     Devuelve un valor aleatorio Normal(m,s), con s>0.  Llamando a
     'random_normal' con un tercer argumento <n>, se simula una muestra
     aleatoria de tamaño <n>.

     El algoritmo de simulación es el de Box-Mueller, tal como está
     descrito en Knuth, D.E. (1981) <Seminumerical Algorithms.  The Art
     of Computer Programming.> Addison-Wesley.

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: pdf_student_t (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Student t(n), con n>0.  Para hacer uso
     de esta función, ejecútese primero 'load(distrib)'.

 -- Función: cdf_student_t (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Student t(n), con n>0.

          (%i1) load (distrib)$
          (%i2) cdf_student_t(1/2, 7/3);
                                                   7  1  28
                       beta_incomplete_regularized(-, -, --)
                                                   6  2  31
          (%o2)    1 - -------------------------------------
                                         2
          (%i3) float(%);
          (%o3)                .6698450596140415

 -- Función: quantile_student_t (<q>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria de Student t(n),
     con n>0; en otras palabras, se trata de la inversa de
     'cdf_student_t'.  El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: mean_student_t (<n>)
     Devuelve la media de una variable aleatoria de Student t(n), con
     n>0, que vale siempre 0.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: var_student_t (<n>)
     Devuelve la varianza de una variable aleatoria de Student t(n), con
     n>2.

          (%i1) load (distrib)$
          (%i2) var_student_t(n);
                                          n
          (%o2)                         -----
                                        n - 2

 -- Función: std_student_t (<n>)
     Devuelve la desviación típica de una variable aleatoria de Student
     t(n), con n>2.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: skewness_student_t (<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Student t(n), con n>3, que vale siempre 0.  Para hacer uso de esta
     función, ejecútese primero 'load(distrib)'.

 -- Función: kurtosis_student_t (<n>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Student t(n), con n>4.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: random_student_t (<n>)
 -- Función: random_student_t (<n>,<m>)
     Devuelve un valor aleatorio t(n), con n>0.  Llamando a
     'random_student_t' con un segundo argumento <m>, se obtiene una
     muestra aleatoria simulada de tamaño <m>.

     El algoritmo utilizado está basado en el hecho de que si <Z> es una
     variable aleatoria normal N(0,1) y S^2 es una chi cuadrada de <n>
     grados de libertad, Chi^2(n), entonces
                                     Z
                           X = -------------
                               /   2  \ 1/2
                               |  S   |
                               | ---  |
                               \  n   /

     es una variable aleatoria de Student de <n> grados de libertad,
     t(n).

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: pdf_noncentral_student_t (<x>,<n>,<ncp>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria no central de Student nc_t(n,ncp), con
     n>0 grados de libertad y parámetro de no centralidad ncp.  Para
     hacer uso de esta función, ejecútese primero 'load(distrib)'.

     En ocasiones es necesario hacer algún trabajo extra para obtener el
     resultado final.

          (%i1) load (distrib)$
          (%i2) expand(pdf_noncentral_student_t(3,5,0.1));
                                     7/2                         7/2
                0.04296414417400905 5      1.323650307289301e-6 5
          (%o2) ------------------------ + -------------------------
                   3/2   5/2                       sqrt(%pi)
                  2    14    sqrt(%pi)
                                                                  7/2
                                             1.94793720435093e-4 5
                                           + ------------------------
                                                       %pi
          (%i3) float(%);
          (%o3)          .02080593159405669

 -- Función: cdf_noncentral_student_t (<x>,<n>,<ncp>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria no central de Student
     nc_t(n,ncp), con n>0 grados de libertad y parámetro de no
     centralidad ncp.  Esta función no tiene expresión compacta y se
     calcula numéricamente.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

          (%i1) load (distrib)$
          (%i2) cdf_noncentral_student_t(-2,5,-5);
          (%o2)          .9952030093319743

 -- Función: quantile_noncentral_student_t (<q>,<n>,<ncp>)
     Devuelve el <q>-cuantil de una variable aleatoria no central de
     Student nc_t(n,ncp), con n>0 grados de libertad y parámetro de no
     centralidad ncp; en otras palabras, se trata de la inversa de
     'cdf_noncentral_student_t'.  El argumento <q> debe ser un número de
     [0,1].  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: mean_noncentral_student_t (<n>,<ncp>)
     Devuelve la media de una variable aleatoria no central de Student
     nc_t(n,ncp), con n>1 grados de libertad y parámetro de no
     centralidad ncp.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

          (%i1) load (distrib)$
          (%i2) mean_noncentral_student_t(df,k);
                             df - 1
                       gamma(------) sqrt(df) k
                               2
          (%o2)        ------------------------
                                        df
                          sqrt(2) gamma(--)
                                        2

 -- Función: var_noncentral_student_t (<n>,<ncp>)
     Devuelve la varianza de una variable aleatoria no central de
     Student nc_t(n,ncp), con n>2 grados de libertad y parámetro de no
     centralidad ncp.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: std_noncentral_student_t (<n>,<ncp>)
     Devuelve la desviación típica de una variable aleatoria no central
     de Student nc_t(n,ncp), con n>2 grados de libertad y parámetro de
     no centralidad ncp.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: skewness_noncentral_student_t (<n>,<ncp>)
     Devuelve el coeficiente de asimetría de una variable aleatoria no
     central de Student nc_t(n,ncp), con n>3 grados de libertad y
     parámetro de no centralidad ncp.  Para hacer uso de esta función,
     ejecútese primero 'load(distrib)'.

 -- Función: kurtosis_noncentral_student_t (<n>,<ncp>)
     Devuelve el coeficiente de curtosis de una variable aleatoria no
     central de Student nc_t(n,ncp), con n>4 grados de libertad y
     parámetro de no centralidad ncp.  Para hacer uso de esta función,
     ejecútese primero 'load(distrib)'.

 -- Función: random_noncentral_student_t (<n>,<ncp>)
 -- Función: random_noncentral_student_t (<n>,<ncp>,<m>)
     Devuelve un valor aleatorio nc_t(n,ncp), con n>0.  Llamando a
     'random_noncentral_student_t' con un tercer argumento <m>, se
     obtiene una muestra aleatoria simulada de tamaño <m>.

     El algoritmo utilizado está basado en el hecho de que si <X> es una
     variable aleatoria normal N(ncp,1) y S^2 es una chi cuadrada de <n>
     grados de libertad, Chi^2(n), entonces
                                     X
                           U = -------------
                               /   2  \ 1/2
                               |  S   |
                               | ---  |
                               \  n   /

     es una variable aleatoria no central de Student de <n> grados de
     libertad y parámetro de no centralidad ncp, nc_t(n,ncp).

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: pdf_chi2 (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria chi-cuadrado Chi^2(n), con n>0.  La
     variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2).

          (%i1) load (distrib)$
          (%i2) pdf_chi2(x,n);
                                   n/2 - 1   - x/2
                                  x        %e
          (%o2)                   ----------------
                                    n/2       n
                                   2    gamma(-)
                                              2

 -- Función: cdf_chi2 (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria chi-cuadrado Chi^2(n), con
     n>0.

          (%i1) load (distrib)$
          (%i2) cdf_chi2(3,4);
                                                         3
          (%o2)      1 - gamma_incomplete_regularized(2, -)
                                                         2
          (%i3) float(%);
          (%o3)               .4421745996289256

 -- Función: quantile_chi2 (<q>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria Chi^2(n), con
     n>0; en otras palabras, se trata de la inversa de 'cdf_chi2'.  El
     argumento <q> debe ser un número de [0,1].

     Esta función no tiene expresión compacta y se calcula
     numéricamente.

          (%i1) load (distrib)$
          (%i2) quantile_chi2(0.99,9);
          (%o2)                   21.66599433346194

 -- Función: mean_chi2 (<n>)
     Devuelve la media de una variable aleatoria Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2).

          (%i1) load (distrib)$
          (%i2) mean_chi2(n);
          (%o2)                           n

 -- Función: var_chi2 (<n>)
     Devuelve la varianza de una variable aleatoria Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2).

          (%i1) load (distrib)$
          (%i2) var_chi2(n);
          (%o2)                          2 n

 -- Función: std_chi2 (<n>)
     Devuelve la desviación típica de una variable aleatoria Chi^2(n),
     con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2).

          (%i1) load (distrib)$
          (%i2) std_chi2(n);
          (%o2)                    sqrt(2) sqrt(n)

 -- Función: skewness_chi2 (<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2).

          (%i1) load (distrib)$
          (%i2) skewness_chi2(n);
                                               3/2
                                              2
          (%o2)                              -------
                                             sqrt(n)

 -- Función: kurtosis_chi2 (<n>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2).

          (%i1) load (distrib)$
          (%i2) kurtosis_chi2(n);
                                         12
          (%o2)                          --
                                         n

 -- Función: random_chi2 (<n>)
 -- Función: random_chi2 (<n>,<m>)
     Devuelve un valor aleatorio Chi^2(n), con n>0.  Llamando a
     'random_chi2' con un segundo argumento <m>, se simulará una muestra
     aleatoria de tamaño <m>.

     La simulación está basada en el algoritmo de Ahrens-Cheng.  Véase
     'random_gamma' para más detalles.

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: pdf_noncentral_chi2 (<x>,<n>,<ncp>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria chi-cuadrado no centrada nc_Chi^2(n,ncp),
     con n>0 y parámetro de no centralidad ncp>=0.  Para hacer uso de
     esta función ejecútese primero 'load(distrib)'.

 -- Función: cdf_noncentral_chi2 (<x>,<n>,<ncp>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria chi-cuadrado no centrada
     nc_Chi^2(n,ncp), con n>0 y parámetro de no centralidad ncp>=0.

 -- Función: quantile_noncentral_chi2 (<q>,<n>,<ncp>)
     Devuelve el <q>-cuantil de una variable aleatoria chi-cuadrado no
     centrada nc_Chi^2(n,ncp), con n>0 y parámetro de no centralidad
     ncp>=0; en otras palabras, se trata de la inversa de
     'cdf_noncentral_chi2'.  El argumento <q> debe ser un número de
     [0,1].

     Esta función no tiene expresión compacta y se calcula
     numéricamente.

 -- Función: mean_noncentral_chi2 (<n>,<ncp>)
     Devuelve la media de una variable aleatoria chi-cuadrado no
     centrada nc_Chi^2(n,ncp), con n>0 y parámetro de no centralidad
     ncp>=0.

 -- Función: var_noncentral_chi2 (<n>,<ncp>)
     Devuelve la varianza de una variable aleatoria chi-cuadrado no
     centrada nc_Chi^2(n,ncp), con n>0 y parámetro de no centralidad
     ncp>=0.

 -- Función: std_noncentral_chi2 (<n>,<ncp>)
     Devuelve la desviación típica de una variable aleatoria
     chi-cuadrado no centrada nc_Chi^2(n,ncp), con n>0 y parámetro de no
     centralidad ncp>=0.

 -- Función: skewness_noncentral_chi2 (<n>,<ncp>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     chi-cuadrado no centrada nc_Chi^2(n,ncp), con n>0 y parámetro de no
     centralidad ncp>=0.

 -- Función: kurtosis_noncentral_chi2 (<n>,<ncp>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     chi-cuadrado no centrada nc_Chi^2(n,ncp), con n>0 y parámetro de no
     centralidad ncp>=0.

 -- Función: random_noncentral_chi2 (<n>,<ncp>)
 -- Función: random_noncentral_chi2 (<n>,<ncp>,<m>)
     Devuelve un valor aleatorio nc_Chi^2(n,ncp), con n>0 y parámetro de
     no centralidad ncp>=0.  Llamando a 'random_noncentral_chi2' con un
     tercer argumento <m>, se simulará una muestra aleatoria de tamaño
     <m>.

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: pdf_f (<x>,<m>,<n>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria F(m,n), con m,n>0.  Para hacer uso de
     esta función, ejecútese primero 'load(distrib)'.

 -- Función: cdf_f (<x>,<m>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria F(m,n), con m,n>0.

          (%i1) load (distrib)$
          (%i2) cdf_f(2,3,9/4);
                                                   9  3  3
          (%o2)    1 - beta_incomplete_regularized(-, -, --)
                                                   8  2  11
          (%i3) float(%);
          (%o3)                 0.66756728179008

 -- Función: quantile_f (<q>,<m>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria F(m,n), con
     m,n>0; en otras palabras, se trata de la inversa de 'cdf_f'.  El
     argumento <q> debe ser un número de [0,1].

          (%i1) load (distrib)$
          (%i2) quantile_f(2/5,sqrt(3),5);
                                         2
          (%o2)               quantile_f(-, sqrt(3), 5)
                                         5
          (%i3) %,numer;
          (%o3)                   0.518947838573693

 -- Función: mean_f (<m>,<n>)
     Devuelve la media de una variable aleatoria F(m,n), con m>0, n>2.
     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: var_f (<m>,<n>)
     Devuelve la varianza de una variable aleatoria F(m,n), con m>0,
     n>4.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: std_f (<m>,<n>)
     Devuelve la desviación típica de una variable aleatoria F(m,n), con
     m>0, n>4.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: skewness_f (<m>,<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     F(m,n), con m>0, n>6.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: kurtosis_f (<m>,<n>)
     Devuelve el coeficiente de curtosis una variable aleatoria F(m,n),
     con m>0, n>8.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: random_f (<m>,<n>)
 -- Función: random_f (<m>,<n>,<k>)
     Devuelve un valor aleatorio F(m,n), con m,n>0.  Llamando a
     'random_f' con un tercer argumento <k>, se simulará una muestra
     aleatoria de tamaño <k>.

     El algoritmo de simulación está basado en el hecho de que si <X> es
     una variable aleatoria Chi^2(m) y Y es una Chi^2(n), entonces
                                  n X
                              F = ---
                                  m Y

     es una variable aleatoria F con <m> y <n> grados de libertad,
     F(m,n).

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: pdf_exp (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una Weibull(1,1/m).

          (%i1) load (distrib)$
          (%i2) pdf_exp(x,m);
                                          - m x
          (%o2)                       m %e

 -- Función: cdf_exp (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una Weibull(1,1/m).

          (%i1) load (distrib)$
          (%i2) cdf_exp(x,m);
                                           - m x
          (%o2)                      1 - %e

 -- Función: quantile_exp (<q>,<m>)
     Devuelve el <q>-cuantil de una variable aleatoria Exponencial(m),
     con m>0; en otras palabras, se trata de la inversa de 'cdf_exp'.
     El argumento <q> debe ser un número de [0,1].

     La variable aleatoria Exponencial(m) equivale a una Weibull(1,1/m).

          (%i1) load (distrib)$
          (%i2) quantile_exp(0.56,5);
          (%o2)                   .1641961104139661
          (%i3) quantile_exp(0.56,m);
                                                      1
          (%o3)             quantile_weibull(0.56, 1, -)
                                                      m

 -- Función: mean_exp (<m>)
     Devuelve la media de una variable aleatoria Exponencial(m), con
     m>0.

     La variable aleatoria Exponencial(m) equivale a una Weibull(1,1/m).

          (%i1) load (distrib)$
          (%i2) mean_exp(m);
                                          1
          (%o2)                           -
                                          m

 -- Función: var_exp (<m>)
     Devuelve la varianza de una variable aleatoria Exponencial(m), con
     m>0.

     La variable aleatoria Exponencial(m) equivale a una Weibull(1,1/m).

          (%i1) load (distrib)$
          (%i2) var_exp(m);
                                         1
          (%o2)                          --
                                          2
                                         m

 -- Función: std_exp (<m>)
     Devuelve la desviación típica de una variable aleatoria
     Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una Weibull(1,1/m).

          (%i1) load (distrib)$
          (%i2) std_exp(m);
                                          1
          (%o2)                           -
                                          m

 -- Función: skewness_exp (<m>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una Weibull(1,1/m).

          (%i1) load (distrib)$
          (%i2) skewness_exp(m);
          (%o2)                           2

 -- Función: kurtosis_exp (<m>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una Weibull(1,1/m).

          (%i1) load (distrib)$
          (%i2) kurtosis_exp(m);
          (%o3)                           6

 -- Función: random_exp (<m>)
 -- Función: random_exp (<m>,<k>)
     Devuelve un valor aleatorio Exponencial(m), con m>0.  Llamando a
     'random_exp2' con un segundo argumento <k>, se simulará una muestra
     aleatoria de tamaño <k>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: pdf_lognormal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Lognormal(m,s), con s>0.  Para hacer uso
     de esta función, ejecútese primero 'load(distrib)'.

 -- Función: cdf_lognormal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Lognormal(m,s), con s>0.
     Esta función se define en términos de la función de error, 'erf',
     de Maxima.

          (%i1) load (distrib)$
          (%i2) assume(x>0, s>0)$  cdf_lognormal(x,m,s);
                                     log(x) - m
                                 erf(----------)
                                     sqrt(2) s     1
          (%o2)                  --------------- + -
                                        2          2

     Véase también 'erf'.

 -- Función: quantile_lognormal (<q>,<m>,<s>)
     Devuelve el <q>-cuantil de una variable aleatoria Lognormal(m,s),
     con s>0; en otras palabras, se trata de la inversa de
     'cdf_lognormal'.  El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: mean_lognormal (<m>,<s>)
     Devuelve la media de una variable aleatoria Lognormal(m,s), con
     s>0.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: var_lognormal (<m>,<s>)
     Devuelve la varianza de una variable aleatoria Lognormal(m,s), con
     s>0.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: std_lognormal (<m>,<s>)
     Devuelve la desviación típica de una variable aleatoria
     Lognormal(m,s), con s>0.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: skewness_lognormal (<m>,<s>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Lognormal(m,s), con s>0.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: kurtosis_lognormal (<m>,<s>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Lognormal(m,s), con s>0.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: random_lognormal (<m>,<s>)
 -- Función: random_lognormal (<m>,<s>,<n>)
     Devuelve un valor aleatorio Lognormal(m,s), con s>0.  Llamando a
     'random_lognormal' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     Las variables lognormales se simulan mediante variables normales.
     Véase 'random_normal' para más detalles.

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: pdf_gamma (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Gamma(a,b), con a,b>0.  Para hacer uso de
     esta función, ejecútese primero 'load(distrib)'.

 -- Función: cdf_gamma (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Gamma(a,b), con a,b>0.

          (%i1) load (distrib)$
          (%i2) cdf_gamma(3,5,21);
                                                        1
          (%o2)     1 - gamma_incomplete_regularized(5, -)
                                                        7
          (%i3) float(%);
          (%o3)              4.402663157376807E-7

 -- Función: quantile_gamma (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria Gamma(a,b), con
     a,b>0; en otras palabras, se trata de la inversa de 'cdf_gamma'.
     El argumento <q> debe ser un número de [0,1].  Para hacer uso de
     esta función, ejecútese primero 'load(distrib)'.

 -- Función: mean_gamma (<a>,<b>)
     Devuelve la media de una variable aleatoria Gamma(a,b), con a,b>0.
     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: var_gamma (<a>,<b>)
     Devuelve la varianza de una variable aleatoria Gamma(a,b), con
     a,b>0.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: std_gamma (<a>,<b>)
     Devuelve la desviación típica de una variable aleatoria Gamma(a,b),
     con a,b>0.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: skewness_gamma (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Gamma(a,b), con a,b>0.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: kurtosis_gamma (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Gamma(a,b), con a,b>0.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: random_gamma (<a>,<b>)
 -- Función: random_gamma (<a>,<b>,<n>)
     Devuelve un valor aleatorio Gamma(a,b), con a,b>0.  Llamando a
     'random_gamma' con un tercer argumento <n>, se simulará una muestra
     aleatoria de tamaño <n>.

     El algoritmo de simulación es una combinación de dos
     procedimientos, según sea el valor del parámetro <a>:

     Para a>=1, Cheng, R.C.H. y Feast, G.M. (1979).  <Some simple gamma
     variate generators>.  Appl.  Stat., 28, 3, 290-295.

     Para 0<a<1, Ahrens, J.H. y Dieter, U. (1974).  <Computer methods
     for sampling from gamma, beta, poisson and binomial distributions>.
     Computing, 12, 223-246.

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: pdf_beta (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Beta(a,b), con a,b>0.  Para hacer uso de
     esta función, ejecútese primero 'load(distrib)'.

 -- Función: cdf_beta (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Beta(a,b), con a,b>0.

          (%i1) load (distrib)$
          (%i2) cdf_beta(1/3,15,2);
                                       11
          (%o2)                     --------
                                    14348907
          (%i3) float(%);
          (%o3)              7.666089131388195E-7

 -- Función: quantile_beta (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria Beta(a,b), con
     a,b>0; en otras palabras, se trata de la inversa de 'cdf_beta'.  El
     argumento <q> debe ser un número de [0,1].  Para hacer uso de esta
     función, ejecútese primero 'load(distrib)'.

 -- Función: mean_beta (<a>,<b>)
     Devuelve la media de una variable aleatoria Beta(a,b), con a,b>0.
     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: var_beta (<a>,<b>)
     Devuelve la varianza de una variable aleatoria Beta(a,b), con
     a,b>0.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: std_beta (<a>,<b>)
     Devuelve la desviación típica de una variable aleatoria Beta(a,b),
     con a,b>0.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: skewness_beta (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Beta(a,b), con a,b>0.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: kurtosis_beta (<a>,<b>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Beta(a,b), con a,b>0.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: random_beta (<a>,<b>)
 -- Función: random_beta (<a>,<b>,<n>)
     Devuelve un valor aleatorio Beta(a,b), con a,b>0.  Llamando a
     'random_beta' con un tercer argumento <n>, se simulará una muestra
     aleatoria de tamaño <n>.

     El algoritmo de simulación es el decrito en Cheng, R.C.H. (1978).
     <Generating Beta Variates with Nonintegral Shape Parameters>.
     Communications of the ACM, 21:317-322.

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: pdf_continuous_uniform (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Uniforme Continua(a,b), con a<b.  Para
     hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: cdf_continuous_uniform (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Uniforme Continua(a,b), con
     a<b.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: quantile_continuous_uniform (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria Uniforme
     Continua(a,b), con a<b; en otras palabras, se trata de la inversa
     de 'cdf_continuous_uniform'.  El argumento <q> debe ser un número
     de [0,1].  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: mean_continuous_uniform (<a>,<b>)
     Devuelve la media de una variable aleatoria Uniforme Continua(a,b),
     con a<b.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: var_continuous_uniform (<a>,<b>)
     Devuelve la varianza de una variable aleatoria Uniforme
     Continua(a,b), con a<b.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: std_continuous_uniform (<a>,<b>)
     Devuelve la desviación típica de una variable aleatoria Uniforme
     Continua(a,b), con a<b.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: skewness_continuous_uniform (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Uniforme Continua(a,b), con a<b.  Para hacer uso de esta función,
     ejecútese primero 'load(distrib)'.

 -- Función: kurtosis_continuous_uniform (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria Uniforme
     Continua(a,b), con a<b.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: random_continuous_uniform (<a>,<b>)
 -- Función: random_continuous_uniform (<a>,<b>,<n>)
     Devuelve un valor aleatorio Uniforme Continuo(a,b), con a<b.
     Llamando a 'random_continuous_uniform' con un tercer argumento <n>,
     se simulará una muestra aleatoria de tamaño <n>.

     Esta función es una aplicación directa de la función 'random' de
     Maxima.

     Véase también 'random'.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: pdf_logistic (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Logística(a,b), con b>0.  Para hacer uso
     de esta función, ejecútese primero 'load(distrib)'.

 -- Función: cdf_logistic (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Logística(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: quantile_logistic (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria Logística(a,b),
     con b>0; en otras palabras, se trata de la inversa de
     'cdf_logistic'.  El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: mean_logistic (<a>,<b>)
     Devuelve la media de una variable aleatoria Logística(a,b), con
     b>0.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: var_logistic (<a>,<b>)
     Devuelve la varianza de una variable aleatoria Logística(a,b), con
     b>0.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: std_logistic (<a>,<b>)
     Devuelve la desviación típica de una variable aleatoria
     Logística(a,b), con b>0.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: skewness_logistic (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Logística(a,b), con b>0.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: kurtosis_logistic (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Logística(a,b), con b>0.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: random_logistic (<a>,<b>)
 -- Función: random_logistic (<a>,<b>,<n>)
     Devuelve un valor aleatorio Logístico(a,b), con b>0.  Llamando a
     'random_logistic' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: pdf_pareto (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Pareto(a,b), con a,b>0.  Para hacer
     uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: cdf_pareto (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Pareto(a,b), con a,b>0.
     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: quantile_pareto (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Pareto(a,b),
     con a,b>0; en otras palabras, se trata de la inversa de
     'cdf_pareto'.  El argumento <q> debe ser un número de [0,1].  Para
     hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: mean_pareto (<a>,<b>)
     Devuelve la media de una variable aleatoria de Pareto(a,b), con
     a>1,b>0.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: var_pareto (<a>,<b>)
     Devuelve la varianza de una variable aleatoria de Pareto(a,b), con
     a>2,b>0.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: std_pareto (<a>,<b>)
     Devuelve la desviación típica de una variable aleatoria de
     Pareto(a,b), con a>2,b>0.  Para hacer uso de esta función,
     ejecútese primero 'load(distrib)'.

 -- Función: skewness_pareto (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Pareto(a,b), con a>3,b>0.  Para hacer uso de esta función,
     ejecútese primero 'load(distrib)'.

 -- Función: kurtosis_pareto (<a>,<b>)
     Devuelve el coeficiente de curtosis de una variable aleatoria de
     Pareto(a,b), con a>4,b>0.  Para hacer uso de esta función,
     ejecútese primero 'load(distrib)'.

 -- Función: random_pareto (<a>,<b>)
 -- Función: random_pareto (<a>,<b>,<n>)
     Devuelve un valor aleatorio Pareto(a,b), con a>0,b>0.  Llamando a
     'random_pareto' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: pdf_weibull (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Weibull(a,b), con a,b>0.  Para hacer
     uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: cdf_weibull (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Weibull(a,b), con a,b>0.
     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: quantile_weibull (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Weibull(a,b),
     con a,b>0; en otras palabras, se trata de la inversa de
     'cdf_weibull'.  El argumento <q> debe ser un número de [0,1].  Para
     hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: mean_weibull (<a>,<b>)
     Devuelve la media de una variable aleatoria de Weibull(a,b), con
     a,b>0.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: var_weibull (<a>,<b>)
     Devuelve la varianza de una variable aleatoria de Weibull(a,b), con
     a,b>0.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: std_weibull (<a>,<b>)
     Devuelve la desviación típica de una variable aleatoria de
     Weibull(a,b), con a,b>0.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: skewness_weibull (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Weibull(a,b), con a,b>0.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: kurtosis_weibull (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Weibull(a,b), con a,b>0.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: random_weibull (<a>,<b>)
 -- Función: random_weibull (<a>,<b>,<n>)
     Devuelve un valor aleatorio Weibull(a,b), con a,b>0.  Llamando a
     'random_weibull' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: pdf_rayleigh (<x>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b).

          (%i1) load (distrib)$
          (%i2) pdf_rayleigh(x,b);
                                              2  2
                                     2     - b  x
          (%o2)                   2 b  x %e

 -- Función: cdf_rayleigh (<x>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b).

          (%i1) load (distrib)$
          (%i2) cdf_rayleigh(x,b);
                                             2  2
                                          - b  x
          (%o2)                     1 - %e

 -- Función: quantile_rayleigh (<q>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Rayleigh(b),
     con b>0; en otras palabras, se trata de la inversa de
     'cdf_rayleigh'.  El argumento <q> debe ser un número de [0,1].

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b).

          (%i1) load (distrib)$
          (%i2) quantile_rayleigh(0.99,b);
                                  2.145966026289347
          (%o2)                   -----------------
                                          b

 -- Función: mean_rayleigh (<b>)
     Devuelve la media de una variable aleatoria de Rayleigh(b), con
     b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b).

          (%i1) load (distrib)$
          (%i2) mean_rayleigh(b);
                                      sqrt(%pi)
          (%o2)                       ---------
                                         2 b

 -- Función: var_rayleigh (<b>)
     Devuelve la varianza de una variable aleatoria de Rayleigh(b), con
     b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b).

          (%i1) load (distrib)$
          (%i2) var_rayleigh(b);
                                           %pi
                                       1 - ---
                                            4
          (%o2)                        -------
                                          2
                                         b

 -- Función: std_rayleigh (<b>)
     Devuelve la desviación típica de una variable aleatoria de
     Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b).

          (%i1) load (distrib)$
          (%i2) std_rayleigh(b);
                                             %pi
                                    sqrt(1 - ---)
                                              4
          (%o2)                     -------------
                                          b

 -- Función: skewness_rayleigh (<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b).

          (%i1) load (distrib)$
          (%i2) skewness_rayleigh(b);
                                   3/2
                                %pi      3 sqrt(%pi)
                                ------ - -----------
                                  4           4
          (%o2)                 --------------------
                                         %pi 3/2
                                    (1 - ---)
                                          4

 -- Función: kurtosis_rayleigh (<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b).

          (%i1) load (distrib)$
          (%i2) kurtosis_rayleigh(b);
                                            2
                                       3 %pi
                                   2 - ------
                                         16
          (%o2)                    ---------- - 3
                                        %pi 2
                                   (1 - ---)
                                         4

 -- Función: random_rayleigh (<b>)
 -- Función: random_rayleigh (<b>,<n>)
     Devuelve un valor aleatorio Rayleigh(b), con b>0.  Llamando a
     'random_rayleigh' con un segundo argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: pdf_laplace (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Laplace(a,b), con b>0.  Para hacer uso
     de esta función, ejecútese primero 'load(distrib)'.

 -- Función: cdf_laplace (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Laplace(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: quantile_laplace (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Laplace(a,b),
     con b>0; en otras palabras, se trata de la inversa de
     'cdf_laplace'.  El argumento <q> debe ser un número de [0,1].  Para
     hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: mean_laplace (<a>,<b>)
     Devuelve la media de una variable aleatoria de Laplace(a,b), con
     b>0.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: var_laplace (<a>,<b>)
     Devuelve la varianza de una variable aleatoria de Laplace(a,b), con
     b>0.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: std_laplace (<a>,<b>)
     Devuelve la desviación típica de una variable aleatoria de
     Laplace(a,b), con b>0.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: skewness_laplace (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Laplace(a,b), con b>0.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: kurtosis_laplace (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Laplace(a,b), con b>0.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: random_laplace (<a>,<b>)
 -- Función: random_laplace (<a>,<b>,<n>)
     Devuelve un valor aleatorio Laplace(a,b), con b>0.  Llamando a
     'random_laplace' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: pdf_cauchy (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Cauchy(a,b), con b>0.  Para hacer uso
     de esta función, ejecútese primero 'load(distrib)'.

 -- Función: cdf_cauchy (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Cauchy(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: quantile_cauchy (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Cauchy(a,b),
     con b>0; en otras palabras, se trata de la inversa de 'cdf_cauchy'.
     El argumento <q> debe ser un número de [0,1].  Para hacer uso de
     esta función, ejecútese primero 'load(distrib)'.

 -- Función: random_cauchy (<a>,<b>)
 -- Función: random_cauchy (<a>,<b>,<n>)
     Devuelve un valor aleatorio Cauchy(a,b), con b>0.  Llamando a
     'random_cauchy' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: pdf_gumbel (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Gumbel(a,b), con b>0.  Para hacer uso
     de esta función, ejecútese primero 'load(distrib)'.

 -- Función: cdf_gumbel (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Gumbel(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: quantile_gumbel (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Gumbel(a,b),
     con b>0; en otras palabras, se trata de la inversa de 'cdf_gumbel'.
     El argumento <q> debe ser un número de [0,1].  Para hacer uso de
     esta función, ejecútese primero 'load(distrib)'.

 -- Función: mean_gumbel (<a>,<b>)
     Devuelve la media de una variable aleatoria de Gumbel(a,b), con
     b>0.

          (%i1) load (distrib)$
          (%i2) mean_gumbel(a,b);
          (%o2)                     %gamma b + a
     donde el símbolo '%gamma' representa la constante de
     Euler-Mascheroni.  Véase también '%gamma'.

 -- Función: var_gumbel (<a>,<b>)
     Devuelve la varianza de una variable aleatoria de Gumbel(a,b), con
     b>0.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: std_gumbel (<a>,<b>)
     Devuelve la desviación típica de una variable aleatoria de
     Gumbel(a,b), con b>0.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: skewness_gumbel (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Gumbel(a,b), con b>0.

          (%i1) load (distrib)$
          (%i2) skewness_gumbel(a,b);
                                            3/2
                                         2 6    zeta(3)
          (%o2)                          --------------
                                                 3
                                              %pi
     donde 'zeta' representa la función zeta de Riemann.

 -- Función: kurtosis_gumbel (<a>,<b>)
     Devuelve el coeficiente de curtosis de una variable aleatoria de
     Gumbel(a,b), con b>0.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: random_gumbel (<a>,<b>)
 -- Función: random_gumbel (<a>,<b>,<n>)
     Devuelve un valor aleatorio Gumbel(a,b), con b>0.  Llamando a
     'random_gumbel' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.


File: maxima.info,  Node: Funciones y variables para distribuciones discretas,  Prev: Funciones y variables para distribuciones continuas,  Up: distrib

46.3 Funciones y variables para distribuciones discretas
========================================================

 -- Función: pdf_general_finite_discrete (<x>,<v>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria general discreta finita, con vector de
     probabilidades v, tal que 'Pr(X=i) = v_i'.  El vector v puede ser
     una lista de expresiones no negativas, cuyas componentes se
     normalizarán para obtener un vector de probabilidades.  Para hacer
     uso de esta función, ejecútese primero 'load(distrib)'.

          (%i1) load (distrib)$
          (%i2) pdf_general_finite_discrete(2, [1/7, 4/7, 2/7]);
                                          4
          (%o2)                           -
                                          7
          (%i3) pdf_general_finite_discrete(2, [1, 4, 2]);
                                          4
          (%o3)                           -
                                          7

 -- Función: cdf_general_finite_discrete (<x>,<v>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria general discreta finita, con
     vector de probabilidades v.

     Véase 'pdf_general_finite_discrete' para más detalles.

          (%i1) load (distrib)$
          (%i2) cdf_general_finite_discrete(2, [1/7, 4/7, 2/7]);
                                          5
          (%o2)                           -
                                          7
          (%i3) cdf_general_finite_discrete(2, [1, 4, 2]);
                                          5
          (%o3)                           -
                                          7
          (%i4) cdf_general_finite_discrete(2+1/2, [1, 4, 2]);
                                          5
          (%o4)                           -
                                          7

 -- Función: quantile_general_finite_discrete (<q>,<v>)
     Devuelve el <q>-cuantil de una variable aleatoria general discreta
     finita, con vector de probabilidades v.

     Véase 'pdf_general_finite_discrete' para más detalles.

 -- Función: mean_general_finite_discrete (<v>)
     Devuelve la media de una variable aleatoria general discreta
     finita, con vector de probabilidades v.

     Véase 'pdf_general_finite_discrete' para más detalles.

 -- Función: var_general_finite_discrete (<v>)
     Devuelve la varianza de una variable aleatoria general discreta
     finita, con vector de probabilidades v.

     Véase 'pdf_general_finite_discrete' para más detalles.

 -- Función: std_general_finite_discrete (<v>)
     Devuelve la desviación típica de una variable aleatoria general
     discreta finita, con vector de probabilidades v.

     Véase 'pdf_general_finite_discrete' para más detalles.

 -- Función: skewness_general_finite_discrete (<v>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     general discreta finita, con vector de probabilidades v.

     Véase 'pdf_general_finite_discrete' para más detalles.

 -- Función: kurtosis_general_finite_discrete (<v>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     general discreta finita, con vector de probabilidades v.

     Véase 'pdf_general_finite_discrete' para más detalles.

 -- Función: random_general_finite_discrete (<v>)
 -- Función: random_general_finite_discrete (<v>,<m>)
     Devuelve un valor aleatorio de una variable aleatoria general
     discreta finita, con vector de probabilidades v.  Llamando a
     'random_general_finite_discrete' con un segundo argumento <n>, se
     simulará una muestra aleatoria de tamaño <n>.

     Véase 'pdf_general_finite_discrete' para más detalles.

          (%i1) load (distrib)$
          (%i2) random_general_finite_discrete([1,3,1,5]);
          (%o2)                          4
          (%i3) random_general_finite_discrete([1,3,1,5], 10);
          (%o3)           [4, 2, 2, 3, 2, 4, 4, 1, 2, 2]

 -- Función: pdf_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Binomial(n,p), con 0 \leq p
     \leq 1 y n entero positivo.  Para hacer uso de esta función,
     ejecútese primero 'load(distrib)'.

 -- Función: cdf_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Binomial(n,p), con 0 \leq p
     \leq 1 y n entero positivo.

          (%i1) load (distrib)$
          (%i2) cdf_binomial(5,7,1/6);
                                      7775
          (%o2)                       ----
                                      7776
          (%i3) float(%);
          (%o3)               .9998713991769548

 -- Función: quantile_binomial (<q>,<n>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria Binomial(n,p),
     con 0 \leq p \leq 1 y n entero positivo; en otras palabras, se
     trata de la inversa de 'cdf_binomial'.  El argumento <q> debe ser
     un número de [0,1].  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: mean_binomial (<n>,<p>)
     Devuelve la media de una variable aleatoria Binomial(n,p), con 0
     \leq p \leq 1 y n entero positivo.  Para hacer uso de esta función,
     ejecútese primero 'load(distrib)'.

 -- Función: var_binomial (<n>,<p>)
     Devuelve la varianza de una variable aleatoria Binomial(n,p), con 0
     \leq p \leq 1 y n entero positivo.  Para hacer uso de esta función,
     ejecútese primero 'load(distrib)'.

 -- Función: std_binomial (<n>,<p>)
     Devuelve la desviación típica de una variable aleatoria
     Binomial(n,p), con 0 \leq p \leq 1 y n entero positivo.  Para hacer
     uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: skewness_binomial (<n>,<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Binomial(n,p), con 0 \leq p \leq 1 y n entero positivo.  Para hacer
     uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: kurtosis_binomial (<n>,<p>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     binomial Binomial(n,p), con 0 \leq p \leq 1 y n entero positivo.
     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: random_binomial (<n>,<p>)
 -- Función: random_binomial (<n>,<p>,<m>)
     Devuelve un valor aleatorio Binomial(n,p), con 0 \leq p \leq 1 y n
     entero positivo.  Llamando a 'random_binomial' con un tercer
     argumento <m>, se simulará una muestra aleatoria de tamaño <m>.

     El algoritmo de simulación es el descrito en Kachitvichyanukul, V.
     y Schmeiser, B.W. (1988) <Binomial Random Variate Generation>.
     Communications of the ACM, 31, Feb., 216.

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: pdf_poisson (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria de Poisson(m), con m>0.
     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: cdf_poisson (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Poisson(m), con m>0.

          (%i1) load (distrib)$
          (%i2) cdf_poisson(3,5);
          (%o2)       gamma_incomplete_regularized(4, 5)
          (%i3) float(%);
          (%o3)               .2650259152973623

 -- Función: quantile_poisson (<q>,<m>)
     Devuelve el <q>-cuantil de una variable aleatoria de Poisson(m),
     con m>0; en otras palabras, se trata de la inversa de
     'cdf_poisson'.  El argumento <q> debe ser un número de [0,1].  Para
     hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: mean_poisson (<m>)
     Devuelve la media de una variable aleatoria de Poisson(m), con m>0.
     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: var_poisson (<m>)
     Devuelve la varianza de una variable aleatoria de Poisson(m), con
     m>0.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: std_poisson (<m>)
     Devuelve la desviación típica de una variable aleatoria de
     Poisson(m), con m>0.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: skewness_poisson (<m>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Poisson(m), con m>0.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: kurtosis_poisson (<m>)
     Devuelve el coeficiente de curtosis de una variable aleatoria de
     Poisson(m), con m>0.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: random_poisson (<m>)
 -- Función: random_poisson (<m>,<n>)
     Devuelve un valor aleatorio Poisson(m), con m>0.  Llamando a
     'random_poisson' con un segundo argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     El algoritmo de simulación es el descrito en Ahrens, J.H. and
     Dieter, U. (1982) <Computer Generation of Poisson Deviates From
     Modified Normal Distributions>.  ACM Trans.  Math.  Software, 8, 2,
     June,163-179.

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: pdf_bernoulli (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria de Bernoulli(p), con 0 \leq
     p \leq 1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p).

          (%i1) load (distrib)$
          (%i2) pdf_bernoulli(1,p);
          (%o2)                           p

 -- Función: cdf_bernoulli (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Bernoulli(p), con 0 \leq
     p \leq 1.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: quantile_bernoulli (<q>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria de Bernoulli(p),
     con 0 \leq p \leq 1; en otras palabras, se trata de la inversa de
     'cdf_bernoulli'.  El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: mean_bernoulli (<p>)
     Devuelve la media de una variable aleatoria de Bernoulli(p), con 0
     \leq p \leq 1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p).

          (%i1) load (distrib)$
          (%i2) mean_bernoulli(p);
          (%o2)                           p

 -- Función: var_bernoulli (<p>)
     Devuelve la varianza de una variable aleatoria de Bernoulli(p), con
     0 \leq p \leq 1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p).

          (%i1) load (distrib)$
          (%i2) var_bernoulli(p);
          (%o2)                       (1 - p) p

 -- Función: std_bernoulli (<p>)
     Devuelve la desviación típica de una variable aleatoria de
     Bernoulli(p), con 0 \leq p \leq 1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p).

          (%i1) load (distrib)$
          (%i2) std_bernoulli(p);
          (%o2)                           sqrt((1 - p) p)

 -- Función: skewness_bernoulli (<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Bernoulli(p), con 0 \leq p \leq 1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p).

          (%i1) load (distrib)$
          (%i2) skewness_bernoulli(p);
                                              1 - 2 p
          (%o2)                           ---------------
                                          sqrt((1 - p) p)

 -- Función: kurtosis_bernoulli (<p>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Bernoulli(p), con 0 \leq p \leq 1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p).

          (%i1) load (distrib)$
          (%i2) kurtosis_bernoulli(p);
                                   1 - 6 (1 - p) p
          (%o2)                    ---------------
                                      (1 - p) p

 -- Función: random_bernoulli (<p>)
 -- Función: random_bernoulli (<p>,<n>)
     Devuelve un valor aleatorio Bernoulli(p), con 0 \leq p \leq 1.
     Llamando a 'random_bernoulli' con un segundo argumento <n>, se
     simulará una muestra aleatoria de tamaño <n>.

     Es aplicación directa de la función 'random' de Maxima.

     Véase también 'random'.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: pdf_geometric (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Geométrica(p), con 0 < p
     \leq 1.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: cdf_geometric (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Geométrica(p), con 0 < p
     \leq 1.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: quantile_geometric (<q>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria Geométrica(p),
     con 0 < p \leq 1; en otras palabras, se trata de la inversa de
     'cdf_geometric'.  El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: mean_geometric (<p>)
     Devuelve la media de una variable aleatoria Geométrica(p), con 0 <
     p \leq 1.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: var_geometric (<p>)
     Devuelve la varianza de una variable aleatoria Geométrica(p), con 0
     < p \leq 1.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: std_geometric (<p>)
     Devuelve la desviación típica de una variable aleatoria
     Geométrica(p), con 0 < p \leq 1.  Para hacer uso de esta función,
     ejecútese primero 'load(distrib)'.

 -- Función: skewness_geometric (<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Geométrica(p), con 0 < p \leq 1.  Para hacer uso de esta función,
     ejecútese primero 'load(distrib)'.

 -- Función: kurtosis_geometric (<p>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Geométrica(p), con 0 < p \leq 1.  Para hacer uso de esta función,
     ejecútese primero 'load(distrib)'.

 -- Función: random_geometric (<p>)
 -- Función: random_geometric (<p>,<n>)
     Devuelve un valor aleatorio Geométrico(p), con 0 < p \leq 1.
     Llamando a 'random_geometric' con un segundo argumento <n>, se
     simulará una muestra aleatoria de tamaño <n>.

     El algoritmo está basado en la simulación de ensayos de Bernoulli.

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: pdf_discrete_uniform (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Uniforme Discreta(n), con n
     entero positivo.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: cdf_discrete_uniform (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Uniforme Discreta(n), con n
     entero positivo.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: quantile_discrete_uniform (<q>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria Uniforme
     Discreta(n), con n entero positivo; en otras palabras, se trata de
     la inversa de 'cdf_discrete_uniform'.  El argumento <q> debe ser un
     número de [0,1].  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: mean_discrete_uniform (<n>)
     Devuelve la media de una variable aleatoria Uniforme Discreta(n),
     con n entero positivo.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: var_discrete_uniform (<n>)
     Devuelve la varianza de una variable aleatoria Uniforme
     Discreta(n), con n entero positivo.  Para hacer uso de esta
     función, ejecútese primero 'load(distrib)'.

 -- Función: std_discrete_uniform (<n>)
     Devuelve la desviación típica de una variable aleatoria Uniforme
     Discreta(n), con n entero positivo.  Para hacer uso de esta
     función, ejecútese primero 'load(distrib)'.

 -- Función: skewness_discrete_uniform (<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Uniforme Discreta(n), con n entero positivo.  Para hacer uso de
     esta función, ejecútese primero 'load(distrib)'.

 -- Función: kurtosis_discrete_uniform (<n>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Uniforme Discreta(n), con n entero positivo.  Para hacer uso de
     esta función, ejecútese primero 'load(distrib)'.

 -- Función: random_discrete_uniform (<n>)
 -- Función: random_discrete_uniform (<n>,<m>)
     Devuelve un valor aleatorio Uniforme Discreto(n), con n entero
     positivo.  Llamando a 'random_discrete_uniform' con un segundo
     argumento <m>, se simulará una muestra aleatoria de tamaño <m>.

     Se trata de una aplicación directa de la función 'random' de
     Maxima.

     Véase también 'random'.  Para hacer uso de esta función, ejecútese
     primero 'load(distrib)'.

 -- Función: pdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Hipergeométrica(n1,n2,n),
     con <n1>, <n2> y <n> enteros positivos y n<=n1+n2.  Siendo <n1> el
     número de objetos de la clase A, <n2> el número de objetos de la
     clase B y <n> el tamaño de una muestra sin reemplazo, esta función
     devuelve la probabilidad del suceso "extraer exactamente <x>
     objetos de la clase A".

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: cdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución of una variable aleatoria Hipergeométrica(n1,n2,n),
     con <n1>, <n2> y <n> enteros positivos y n<=n1+n2.  Véase
     'pdf_hypergeometric' para una descripción más completa.

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: quantile_hypergeometric (<q>,<n1>,<n2>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2; en otras palabras, se trata de la inversa de
     'cdf_hypergeometric'.  El argumento <q> debe ser un número de
     [0,1].  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: mean_hypergeometric (<n1>,<n2>,<n>)
     Devuelve la media de una variable aleatoria uniforme discreta
     Hyp(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y n<=n1+n2.
     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: var_hypergeometric (<n1>,<n2>,<n>)
     Devuelve la varianza de una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: std_hypergeometric (<n1>,<n2>,<n>)
     Devuelve la desviación típica de una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: skewness_hypergeometric (<n1>,<n2>,<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2.  Para hacer uso de esta función, ejecútese primero
     'load(distrib)'.

 -- Función: random_hypergeometric (<n1>,<n2>,<n>)
 -- Función: random_hypergeometric (<n1>,<n2>,<n>,<m>)
     Devuelve un valor aleatorio Hipergeométrico(n1,n2,n), con <n1>,
     <n2> y <n> enteros positivos y n<=n1+n2.  Llamando a
     'random_hypergeometric' con un cuarto argumento <m>, se simulará
     una muestra aleatoria de tamaño <m>.

     Algoritmo descrito en Kachitvichyanukul, V., Schmeiser, B.W. (1985)
     <Computer generation of hypergeometric random variates.> Journal of
     Statistical Computation and Simulation 22, 127-145.

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: pdf_negative_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Binomial Negativa(n,p), con
     0 < p \leq 1 y n positivo.  Para hacer uso de esta función,
     ejecútese primero 'load(distrib)'.

 -- Función: cdf_negative_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Binomial Negativa(n,p), con
     0 < p \leq 1 y n positivo.

          (%i1) load (distrib)$
          (%i2) cdf_negative_binomial(3,4,1/8);
                                      3271
          (%o2)                      ------
                                     524288

 -- Función: quantile_negative_binomial (<q>,<n>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria Binomial
     Negativa(n,p), con 0 < p \leq 1 y n positivo; en otras palabras, se
     trata de la inversa de 'cdf_negative_binomial'.  El argumento <q>
     debe ser un número de [0,1].  Para hacer uso de esta función,
     ejecútese primero 'load(distrib)'.

 -- Función: mean_negative_binomial (<n>,<p>)
     Devuelve la media de una variable aleatoria Binomial Negativa(n,p),
     con 0 < p \leq 1 and n positivo.  Para hacer uso de esta función,
     ejecútese primero 'load(distrib)'.

 -- Función: var_negative_binomial (<n>,<p>)
     Devuelve la varianza de una variable aleatoria Binomial
     Negativa(n,p), con 0 < p \leq 1 and n positivo.  Para hacer uso de
     esta función, ejecútese primero 'load(distrib)'.

 -- Función: std_negative_binomial (<n>,<p>)
     Devuelve la desviación típica de una variable aleatoria Binomial
     Negativa(n,p), con 0 < p \leq 1 and n positivo.  Para hacer uso de
     esta función, ejecútese primero 'load(distrib)'.

 -- Función: skewness_negative_binomial (<n>,<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Binomial Negativa(n,p), con 0 < p \leq 1 and n positivo.  Para
     hacer uso de esta función, ejecútese primero 'load(distrib)'.

 -- Función: kurtosis_negative_binomial (<n>,<p>)
     Devuelve el coeficiente de curtosis una variable aleatoria binomial
     negativa NB(n,p), con 0 < p \leq 1 and n positivo.  Para hacer uso
     de esta función, ejecútese primero 'load(distrib)'.

 -- Función: random_negative_binomial (<n>,<p>)
 -- Función: random_negative_binomial (<n>,<p>,<m>)
     Devuelve un valor aleatorio Binomial Negativo(n,p), con 0 < p \leq
     1 y n positivo.  Llamando a 'random_negative_binomial' con un
     tercer argumento <m>, se simulará una muestra aleatoria de tamaño
     <m>.

     Algoritmo descrito en Devroye, L. (1986) <Non-Uniform Random
     Variate Generation>.  Springer Verlag, p.  480.

     Para hacer uso de esta función, ejecútese primero 'load(distrib)'.


File: maxima.info,  Node: draw,  Next: drawdf,  Prev: distrib,  Up: Top

47 draw
*******

* Menu:

* Introducción a draw::
* Funciones y variables para draw::
* Funciones y variables para picture::
* Funciones y variables para worldmap::


File: maxima.info,  Node: Introducción a draw,  Next: Funciones y variables para draw,  Prev: draw,  Up: draw

47.1 Introducción a draw
========================

'draw' es un interfaz para comunicar Maxima con Gnuplot.

Tres son las funciones principales a utilizar a nivel de Maxima:
'draw2d', 'draw3d' y 'draw'.

Síganse estos enlaces para ver ejemplos más elaborados de este paquete:

<http://tecnostats.net/Maxima/gnuplot>

y

<http://tecnostats.net/Maxima/vtk>

Se necesita tener instalado Gnuplot 4.2 o superior para ejecutar este
paquete.


File: maxima.info,  Node: Funciones y variables para draw,  Next: Funciones y variables para picture,  Prev: Introducción a draw,  Up: draw

47.2 Funciones y variables para draw
====================================

47.2.1 Escenas
--------------

 -- Constructor de escena: gr2d (<Opción gráfica>, ...,
          <graphic_object>, ...)

     La función 'gr2d' construye un objeto que describe una escena 2d.
     Los argumentos son opciones gráficas y objetos gráficos o listas
     que contengan elementos de ambos tipos.  Esta escena se interpreta
     secuencialmente: las opciones gráficas afectan a aquellos objetos
     gráficos colocados a su derecha.  Algunas opciones gráficas afectan
     al aspecto global de la escena.

     La lista de objetos gráficos disponibles para escenas en dos
     dimensiones: 'bars', 'ellipse', 'explicit', 'image', 'implicit',
     'label', 'parametric', 'points', 'polar', 'polygon',
     'quadrilateral', 'rectangle', 'triangle', 'vector' y 'geomap' (este
     último definido en el paquete 'worldmap').

     Véanse también 'draw' y 'draw2d'.

     Para utilizar este objecto, ejecútese primero 'load(draw)'.

 -- Constructor de escena: gr3d (<Opción gráfica>, ...,
          <graphic_object>, ...)

     La función 'gr3d' construye un objeto que describe una escena 3d.
     Los argumentos son opciones gráficas y objetos gráficos o listas
     que contengan elementos de ambos tipos.  Esta escena se interpreta
     secuencialmente: las opciones gráficas afectan a aquellos objetos
     gráficos colocados a su derecha.  Algunas opciones gráficas afectan
     al aspecto global de la escena.

     La lista de objetos gráficos disponibles para escenas en tres
     dimensiones: 'cylindrical', 'elevation_grid', 'explicit',
     'implicit', 'label', 'mesh', 'parametric', 'parametric_surface',
     'points', 'quadrilateral', 'spherical', 'triangle', 'tube',
     'vector' y 'geomap' (este último definido en el paquete
     'worldmap').

     Véanse también 'draw' y 'draw3d'.

     Para utilizar este objeto, ejecútese primero 'load(draw)'.

47.2.2 Funciones
----------------

 -- Función: draw (<gr2d>, ..., <gr3d>, ..., <options>, ...)

     Representa gráficamente una serie de escenas; sus argumentos son
     objetos 'gr2d' y/o 'gr3d', junto con algunas opciones, o listas de
     escenas y opciones.  Por defecto, las escenas se representan en una
     columna.

     La función 'draw' acepta las siguientes opciones globales:
     'terminal', 'columns', 'dimensions', 'file_name' y 'delay'.

     Las funciones 'draw2d' y 'draw3d' son atajos a utilizar cuando se
     quiere representar una única escena en dos o tres dimensiones,
     respectivamente.

     Véanse también 'gr2d' y 'gr3d'.

     Para utilizar esta función, ejecútese primero 'load(draw)'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) scene1: gr2d(title="Ellipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triangle",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$

     Las dos sentencias gráficas siguientes son equivalentes:
          (%i1) load(draw)$
          (%i2) draw(gr3d(explicit(x^2+y^2,x,-1,1,y,-1,1)));
          (%o2)                          [gr3d(explicit)]
          (%i3) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1));
          (%o3)                          [gr3d(explicit)]

     Un fichero gif animado:
          (%i1) load(draw)$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     Véanse también 'gr2d', 'gr3d', 'draw2d' y 'draw3d'.

 -- Función: draw2d (<option>, <graphic_object>, ...)

     Esta función es un atajo para 'draw(gr2d(<options>, ...,
     <graphic_object>, ...))'.

     Puede utilizarse para representar una única escena en 2d.

     Para utilizar esta función, ejecútese primero 'load(draw)'.

     Véanse también 'draw' y 'gr2d'.

 -- Función: draw3d (<option>, <graphic_object>, ...)

     Esta función es un atajo para 'draw(gr3d(<options>, ...,
     <graphic_object>, ...))'.

     Puede utilizarse para representar una única escena en 3d.

     Para utilizar esta función, ejecútese primero 'load(draw)'.

     Véanse también 'draw' y 'gr3d'.

 -- Función: draw_file (<Opción gráfica>, ..., <Opción gráfica>, ...)

     Almacena el gráfico actual en un fichero.  Las opciones gráficas
     que acepta son: 'terminal', 'dimensions' y'file_name'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) /* dibujo en pantalla */
                draw(gr3d(explicit(x^2+y^2,x,-1,1,y,-1,1)))$
          (%i3) /* same plot in eps format */
                draw_file(terminal  = eps,
                          dimensions = [5,5]) $

 -- Función: multiplot_mode (<term>)

     Esta función permite a Maxima trabajar en modo de gráficos
     múltiples en una sola ventana del terminal <term>; argumentos
     válidos para esta función son 'screen', 'wxt', 'aquaterm' y 'none'.

     Cuando el modo de gráficos múltiples está activo, cada llamada a
     'draw' envía un nuevo gr'afico a la misma ventana, sin borrar los
     anteriores.  Para desactivar el modo de gráficos múltiples
     escríbase 'multiplot_mode(none)'.

     Cuando el modo de gráficos múltiples está activo, la opción global
     'terminal' se bloquea; para desbloquearla y cambiar de terminal es
     necesario desactivar previamente el modo de gráficos múltiples.

     Este modo de trabajo no funciona en plataformas Windows.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) set_draw_defaults(
                   xrange = [-1,1],
                   yrange = [-1,1],
                   grid   = true,
                   title  = "Step by step plot" )$
          (%i3) multiplot_mode(screen)$
          (%i4) draw2d(color=blue,  explicit(x^2,x,-1,1))$
          (%i5) draw2d(color=red,   explicit(x^3,x,-1,1))$
          (%i6) draw2d(color=brown, explicit(x^4,x,-1,1))$
          (%i7) multiplot_mode(none)$

 -- Función: set_draw_defaults (<Opción gráfica>, ..., <Opción gráfica>,
          ...)

     Establece las opciones gráficas de usuario.  Esta función es útil
     para dibujar varios gráficos con las mismas opciones.  Llamando a
     la función sin argumentos se borran las opciones de usuario por
     defecto.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) set_draw_defaults(
                   xrange = [-10,10],
                   yrange = [-2, 2],
                   color  = blue,
                   grid   = true)$
          (%i3) /* dibujo con opciones de usuario */
                draw2d(explicit(((1+x)**2/(1+x*x))-1,x,-10,10))$
          (%i4) set_draw_defaults()$
          (%i5) /* dibujo con opciones por defecto */
                draw2d(explicit(((1+x)**2/(1+x*x))-1,x,-10,10))$

     Para utilizar esta función, ejecútese primero 'load(draw)'.

47.2.3 Opciones gráficas
------------------------

 -- Opción gráfica: adapt_depth
     Valor por defecto: 10

     'adapt_depth' es el número máximo de particiones utilizadas por la
     rutina gráfica adaptativa.

     Esta opción sólo es relevante para funciones de tipo 'explicit' en
     2d.

 -- Opción gráfica: allocation
     Valor por defecto: 'false'

     Con la opción 'allocation' es posible colocar a voluntad una escena
     en la ventana de salida, lo cual resulta de utilidad en el caso de
     gráficos múltiples.  Cuando la opción toma el valor 'false', la
     escena se coloca de forma automática, dependiendo del valor
     asignado a la opción 'columns'.  En cualquier otro caso, a
     'allocation' se le debe asignar una lista con dos pares de números;
     el primero se corresponde con la posición de la esquina inferior
     izquierda del gráfico y el segundo par hace referencia al ancho y
     alto de la escena.  Todas las cantidades deben darse en coordenadas
     relativas, entre 0 y 1.

     Ejemplos:

     Gráficos internos.

          (%i1) load(draw)$
          (%i2) draw(
                  gr2d(
                    explicit(x^2,x,-1,1)),
                  gr2d(
                    allocation = [[1/4, 1/4],[1/2, 1/2]],
                    explicit(x^3,x,-1,1),
                    grid = true) ) $

     Multiplot con dimensiones establecidas por el usuario.

          (%i1) load(draw)$
          (%i2) draw(
                  terminal = wxt,
                  gr2d(
                    allocation = [[0, 0],[1, 1/4]],
                    explicit(x^2,x,-1,1)),
                  gr3d(
                    allocation = [[0, 1/4],[1, 3/4]],
                    explicit(x^2+y^2,x,-1,1,y,-1,1) ))$

     Véase también la opción 'columns'.

 -- Opción gráfica: axis_3d
     Valor por defecto: 'true'

     Cuando 'axis_3d' vale 'true', los ejes <x>, <y> y <z> permanecen
     visibles en las escenas 3d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(axis_3d = false,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Véanse también 'axis_bottom', 'axis_left', 'axis_top' y
     'axis_right' for axis in 2d.

 -- Opción gráfica: axis_bottom
     Valor por defecto: 'true'

     Cuando 'axis_bottom' vale 'true', el eje inferior permanece visible
     en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_bottom = false,
                       explicit(x^3,x,-1,1))$

     Véanse también 'axis_left', 'axis_top', 'axis_right' y 'axis_3d'.

 -- Opción gráfica: axis_left
     Valor por defecto: 'true'

     Cuando 'axis_left' vale 'true', el eje izquierdo permanece visible
     en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_left = false,
                       explicit(x^3,x,-1,1))$

     Véanse también 'axis_bottom', 'axis_top', 'axis_right' y 'axis_3d'.

 -- Opción gráfica: axis_right
     Valor por defecto: 'true'

     Cuando 'axis_right' vale 'true', el eje derecho permanece visible
     en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_right = false,
                       explicit(x^3,x,-1,1))$

     Véanse también 'axis_bottom', 'axis_left', 'axis_top' y 'axis_3d'.

 -- Opción gráfica: axis_top
     Valor por defecto: 'true'

     Cuando 'axis_top' vale 'true', el eje superior permanece visible en
     las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_top = false,
                       explicit(x^3,x,-1,1))$

     Véanse también 'axis_bottom', 'axis_left', 'axis_right' y
     'axis_3d'.

 -- Opción gráfica: background_color
     Valor por defecto: 'white'

     Establece el color de fondo en los terminales 'gif', 'png', 'jpg' y
     'gif'.  El color de fondo por defecto es blanco.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Esta opción no es compatible con los terminales 'epslatex' y
     'epslatex_standalone'.

     Véase también 'color'.

 -- Opción gráfica: border
     Valor por defecto: 'true'

     Cuando 'border' vale 'true', los bordes de los polígonos se dibujan
     de acuerdo con 'line_type' y 'line_width'.

     Esta opción afecta a los siguientes objetos gráficos:
        * 'gr2d': 'polygon', 'rectangle' y 'ellipse'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(color       = brown,
                       line_width  = 8,
                       polygon([[3,2],[7,2],[5,5]]),
                       border      = false,
                       fill_color  = blue,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Opción gráfica: capping
     Valor por defecto: '[false, false]'

     Una lista de dos elementos, 'true' y 'false', indicando si los
     extremos de un objeto gráfico 'tube' permanece abiertos o si deben
     ser cerrados.  Por defecto, ambos extremos se dejan abiertos.

     La asignación 'capping = false' equivale a 'capping = [false,
     false]' y 'capping = true' equivale a 'capping = [true, true]'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(
                  capping = [false, true],
                  tube(0, 0, a, 1,
                       a, 0, 8) )$

 -- Opción gráfica: cbrange
     Valor por defecto: 'auto'

     Cuando 'cbrange' vale 'auto', el rango de los valores que se
     colorean cuando 'enhanced3d' es diferente de 'false' se calcula
     automáticamente.  Valores fuera del rango utilizan el color del
     valor extremo más cercano.

     Cuando 'enhanced3d' o 'colorbox' vale 'false', la opción 'cbrange'
     no tiene efecto alguno.

     Si el usuario quiere especificar un intervalo para los valores a
     colorear, éste debe expresarse como una lista de Maxima, como en
     'cbrange=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d (
                  enhanced3d     = true,
                  color          = green,
                  cbrange = [-3,10],
                  explicit(x^2+y^2, x,-2,2,y,-2,2)) $

     Véanse también 'enhanced3d' y 'cbtics'.

 -- Opción gráfica: cbtics
     Valor por defecto: 'auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas en la escala de color cuando la opción 'enhanced3d' sea
     diferente de 'false'.

     Cuando 'enhanced3d' o 'colorbox' vale 'false', la opción 'cbtics'
     no tiene efecto alguno.

     Véase 'xtics' para una descripción completa.

     Ejemplo :

          (%i1) load(draw)$
          (%i2) draw3d (
                  enhanced3d = true,
                  color      = green,
                  cbtics  = {["High",10],["Medium",05],["Low",0]},
                  cbrange = [0, 10],
                  explicit(x^2+y^2, x,-2,2,y,-2,2)) $

     See also 'enhanced3d', 'colorbox' and 'cbrange'.

 -- Opción gráfica: color
     Valor por defecto: 'blue'

     'color' especifica el color para dibujar líneas, puntos, bordes de
     polígonos y etiquetas.

     Los colores se pueden dar a partir de sus nombres o en código
     hexadecimal rgb.

     Los nombres de colores disponibles son: 'white', 'black', 'gray0',
     'grey0', 'gray10', 'grey10', 'gray20', 'grey20', 'gray30',
     'grey30', 'gray40', 'grey40', 'gray50', 'grey50', 'gray60',
     'grey60', 'gray70', 'grey70', 'gray80', 'grey80', 'gray90',
     'grey90', 'gray100', 'grey100', 'gray', 'grey', 'light_gray',
     'light_grey', 'dark_gray', 'dark_grey', 'red', 'light_red',
     'dark_red', 'yellow', 'light_yellow', 'dark_yellow', 'green',
     'light_green', 'dark_green', 'spring_green', 'forest_green',
     'sea_green', 'blue', 'light_blue', 'dark_blue', 'midnight_blue',
     'navy', 'medium_blue', 'royalblue', 'skyblue', 'cyan',
     'light_cyan', 'dark_cyan', 'magenta', 'light_magenta',
     'dark_magenta', 'turquoise', 'light_turquoise', 'dark_turquoise',
     'pink', 'light_pink', 'dark_pink', 'coral', 'light_coral',
     'orange_red', 'salmon', 'light_salmon', 'dark_salmon',
     'aquamarine', 'khaki', 'dark_khaki', 'goldenrod',
     'light_goldenrod', 'dark_goldenrod', 'gold', 'beige', 'brown',
     'orange', 'dark_orange', 'violet', 'dark_violet', 'plum' y
     'purple'.

     Las componentes cromáticas en código hexadecimal se introducen en
     el formato '"#rrggbb"'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^2,x,-1,1), /* default is black */
                       color = red,
                       explicit(0.5 + x^2,x,-1,1),
                       color = blue,
                       explicit(1 + x^2,x,-1,1),
                       color = light_blue,
                       explicit(1.5 + x^2,x,-1,1),
                       color = "#23ab0f",
                       label(["This is a label",0,1.2])  )$

     Véase también 'fill_color'.

 -- Opción gráfica: colorbox
     Valor por defecto: 'true'

     Cuando 'colorbox' vale 'true', se dibuja una escala de colores sin
     título al lado de los objetos 'image' en 2D o de objetos coloreados
     en 3D. Cuando 'colorbox' vale 'false', no se presenta la escala de
     colores.  Cuando 'colorbox' es una cadena de caracteres, se
     mostrará la escala de colores con un título.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

     Escala de colores e imágenes.

          (%i1) load(draw)$
          (%i2) im: apply('matrix,
                           makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(colorbox = false, image(im,0,0,30,30))$

     Escala de colores y objeto 3D coloreado.

          (%i1) load(draw)$
          (%i2) draw3d(
                  colorbox   = "Magnitude",
                  enhanced3d = true,
                  explicit(x^2+y^2,x,-1,1,y,-1,1))$

     Véase también 'palette'.

 -- Opción gráfica: columns
     Valor por defecto: 1

     'columns' es el número de columnas en gráficos múltiples.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.  También puede
     usarse como argumento de la función 'draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) scene1: gr2d(title="Ellipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triangle",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$

 -- Opción gráfica: contour
     Valor por defecto: 'none'

     La opción 'contour' permite al usuario decidir dónde colocar las
     líneas de nivel.  Valores posibles son:

        * 'none': no se dibujan líneas de nivel.

        * 'base': las líneas de nivel se proyectan sobre el plano xy.

        * 'surface': las líneas de nivel se dibujan sobre la propia
          superficie.

        * 'both': se dibujan dos conjuntos de líneas de nivel: sobre la
          superficie y las que se proyectan sobre el plano xy.

        * 'map': las líneas de nivel se proyectan sobre el plano xy y el
          punto de vista del observador se coloca perpendicularmente a
          él.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 15,
                       contour        = both,
                       surface_hide   = true) $

     Véase también 'contour_levels'.

 -- Opción gráfica: contour_levels
     Valor por defecto: 5

     Esta opción gráfica controla cómo se dibujarán las líneas de nivel.
     A 'contour_levels' se le puede asignar un número entero positivo,
     una lista de tres números o un conjunto numérico arbitrario:

        * Si a 'contour_levels' se le asigna un entero positivo <n>,
          entonces se dibujarán <n> líneas de nivel a intervalos
          iguales.  Por defecto, se dibujaán cinco isolíneas.

        * Si a 'contour_levels' se le asigna una lista de tres números
          de la forma '[inf,p,sup]', las isolíneas se dibujarán desde
          'inf' hasta 'sup' en pasos de amplitud 'p'.

        * Si a 'contour_levels' se le asigna un conjunto de números de
          la forma '{n1, n2, ...}', entonces se dibujarán las isolíneas
          correspondientes a los niveles 'n1', 'n2', ...

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplos:

     Diez isolíneas igualmente espaciadas.  El número real puede
     ajustarse a fin de poder conseguir etiquetas más sencillas.
          (%i1) load(draw)$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 10,
                       contour        = both,
                       surface_hide   = true) $

     Desde -8 hasta 8 en pasos de amplitud 4.
          (%i1) load(draw)$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = [-8,4,8],
                       contour        = both,
                       surface_hide   = true) $

     Líneas correspondientes a los niveles -7, -6, 0.8 y 5.
          (%i1) load(draw)$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = {-7, -6, 0.8, 5},
                       contour        = both,
                       surface_hide   = true) $

     Véase también 'contour'.

 -- Opción gráfica: data_file_name
     Valor por defecto: '"data.gnuplot"'

     'data_file_name' es el nombre del fichero que almacena la
     información numérica que necesita Gnuplot para crear el gráfico
     solicitado.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.  También puede
     usarse como argumento de la función 'draw'.

     Véase ejemplo en 'gnuplot_file_name'.

 -- Opción gráfica: delay
     Valor por defecto: 5

     Este es el retraso en centésimas de segundo entre imágenes en los
     ficheros gif animados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.  También puede
     usarse como argumento de la función 'draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     La opciób 'delay' sólo se activa en caso de gifs animados; se
     ignora en cualquier otro caso.

     Véanse también 'terminal', 'dimensions'.

 -- Opción gráfica: dimensions
     Valor por defecto: '[600,500]'

     Dimensiones del terminal de salida.  Su valor es una lista formada
     por el ancho y el alto.  El significado de estos dos números
     depende del terminal con el que se esté trabajando.

     Con los terminales 'gif', 'animated_gif', 'png', 'jpg', 'svg',
     'screen', 'wxt' y 'aquaterm', los enteros representan números de
     puntos en cada dirección.  Si no son enteros se redondean.

     Con los terminales 'eps', 'eps_color', 'pdf' y 'pdfcairo', los
     números representan centésimas de cm, lo que significa que, por
     defecto, las imágenes en estos formatos tienen 6 cm de ancho por 5
     cm de alto.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.  También puede
     usarse como argumento de la función 'draw'.

     Ejemplos:

     La opción 'dimensions' aplicada a un fichero de salida y al lienzo
     wxt.

          (%i1) load(draw)$
          (%i2) draw2d(
                  dimensions = [300,300],
                  terminal   = 'png,
                  explicit(x^4,x,-1,1)) $
          (%i3) draw2d(
                  dimensions = [300,300],
                  terminal   = 'wxt,
                  explicit(x^4,x,-1,1)) $

     La opción 'dimensions' aplicada a una salida eps.  En este caso
     queremos un fichero eps con dimensiones A4.

          (%i1) load(draw)$
          (%i2) A4portrait: 100*[21, 29.7]$
          (%i3) draw3d(
                  dimensions = A4portrait,
                  terminal   = 'eps,
                  explicit(x^2-y^2,x,-2,2,y,-2,2)) $

 -- Opción gráfica: draw_realpart
     Valor por defecto: 'true'

     Cuando vale 'true', las funciones a dibujar se consideran funciones
     complejas cuyas partes reales se deben dibujar; cuando la opción
     vale 'false', no se dibujará nada en caso de que la función no
     devuelve valores reales.

     Esta opción afecta a los objetos 'explicit' y 'parametric' en 2D y
     3D, y al objeto 'parametric_surface'.

     Ejemplo:

     La opción 'draw_realpart' afecta a los objetos 'explicit' y
     'parametric'.

          (%i1) load(draw)$
          (%i2) draw2d(
                  draw_realpart = false,
                  explicit(sqrt(x^2  - 4*x) - x, x, -1, 5),
                  color         = red,
                  draw_realpart = true,
                  parametric(x,sqrt(x^2  - 4*x) - x + 1, x, -1, 5) );

 -- Opción gráfica: enhanced3d
     Valor por defecto: 'none'

     Cuando 'enhanced3d' vale 'none', las superficies no se colorean en
     escenas 3D. Para obtener una superficie coloreada se debe asignar
     una lista a la opción 'enhanced3d', en la que el primer elemento es
     una expresión y el resto son los nombres de las variables o
     parámetros utilizados en la expresión.  Una lista tal como
     '[f(x,y,z), x, y, z]' significa que al punto '[x,y,z]' de la
     superficie se le asigna el número 'f(x,y,z)', el cual será
     coloreado de acuerdo con el valor actual de 'palette'.  Para
     aquellos objetos gráficos 3D definidos en términos de parámetros,
     es posible definir el número de color en términos de dichos
     parámetros, como en '[f(u), u]', para los objetos 'parametric' y
     'tube', o '[f(u,v), u, v]', para el objeto 'parametric_surface'.
     Mientras que todos los objetos 3D admiten el modelo basado en
     coordenadas absolutas, '[f(x,y,z), x, y, z]', solamente dos de
     ellos, esto es 'explicit' y 'elevation_grid', aceptan también el
     modelo basado en las coordenadas '[x,y]', '[f(x,y), x, y]'.  El
     objeto 3D 'implicit' acepta solamente el modelo '[f(x,y,z), x, y,
     z]'.  El objeto 'points' también acepta el modelo '[f(x,y,z), x, y,
     z]', pero cuando los puntos tienen naturaleza cronológica también
     admite el modelo '[f(k), k]', siendo 'k' un parámetro de orden.

     Cuando a 'enhanced3d' se le asigna algo diferente de 'none', se
     ignoran las opciones 'color' y 'surface_hide'.

     Los nombres de las variables definidas en las listas pueden ser
     diferentes de aquellas utilizadas en las definiciones de los
     objetos gráficos.

     A fin de mantener compatibilidad con versiones anteriores,
     'enhanced3d = false' es equivalente a 'enhanced3d = none' y
     'enhanced3d = true' es equivalente a 'enhanced3d = [z, x, y, z]'.
     Si a 'enhanced3d' se le asigna una expresión, sus variables deben
     ser las mismas utilizadas en la definición de la superficie.  Esto
     no es necesario cuando se utilizan listas.

     Sobre la definición de paletas, véase 'palette'.

     Ejemplos:

     Objeto 'explicit' con coloreado definido por el modelo '[f(x,y,z),
     x, y, z]'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   enhanced3d = [x-z/10,x,y,z],
                   palette    = gray,
                   explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3))$

     Objeto 'explicit' con coloreado definido por el modelo '[f(x,y), x,
     y]'.  Los nombres de las variables definidas en las listas pueden
     ser diferentes de aquellas utilizadas en las definiciones de los
     objetos gráficos 3D; en este caso, 'r' corresponde a 'x' y 's' a
     'y'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   enhanced3d = [sin(r*s),r,s],
                   explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3))$

     Objeto 'parametric' con coloreado definido por el modelo
     '[f(x,y,z), x, y, z]'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   nticks = 100,
                   line_width = 2,
                   enhanced3d = [if y>= 0 then 1 else 0, x, y, z],
                   parametric(sin(u)^2,cos(u),u,u,0,4*%pi)) $

     Objeto 'parametric' con coloreado definido por el modelo '[f(u),
     u]'.  En este caso, '(u-1)^2' es una simplificación de
     '[(u-1)^2,u]'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   nticks = 60,
                   line_width = 3,
                   enhanced3d = (u-1)^2,
                   parametric(cos(5*u)^2,sin(7*u),u-2,u,0,2))$

     Objeto 'elevation_grid' con coloreado definido por el modelo
     '[f(x,y), x, y]'.

          (%i1) load(draw)$
          (%i2) m: apply(
                     matrix,
                     makelist(makelist(cos(i^2/80-k/30),k,1,30),i,1,20)) $
          (%i3) draw3d(
                   enhanced3d = [cos(x*y*10),x,y],
                   elevation_grid(m,-1,-1,2,2),
                   xlabel = "x",
                   ylabel = "y");

     Objeto 'tube' con coloreado definido por el modelo '[f(x,y,z), x,
     y, z]'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   enhanced3d = [cos(x-y),x,y,z],
                   palette = gray,
                   xu_grid = 50,
                   tube(cos(a), a, 0, 1, a, 0, 4*%pi) )$

     Objeto 'tube' con coloreado definido por el modelo '[f(u), u]'.  En
     este caso, 'enhanced3d = -a' puede ser una simplificación de
     'enhanced3d = [-foo,foo]'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   capping = [true, false],
                   palette = [26,15,-2],
                   enhanced3d = [-foo, foo],
                   tube(a, a, a^2, 1, a, -2, 2) )$

     Objetos 'implicit' y 'points' con coloreado definido por el modelo
     '[f(x,y,z), x, y, z]'.

          (%i1) load(draw)$
          (%i2) draw3d(
                   enhanced3d = [x-y,x,y,z],
                   implicit((x^2+y^2+z^2-1)*(x^2+(y-1.5)^2+z^2-0.5)=0.015,
                            x,-1,1,y,-1.2,2.3,z,-1,1)) $
          (%i3) m: makelist([random(1.0),random(1.0),random(1.0)],k,1,2000)$
          (%i4) draw3d(
                   point_type = filled_circle,
                   point_size = 2,
                   enhanced3d = [u+v-w,u,v,w],
                   points(m) ) $

     cuando los puntos tienen naturaleza cronológica también se admite
     el modelo '[f(k), k]', siendo 'k' un parámetro de orden.

          (%i1) load(draw)$
          (%i2) m:makelist([random(1.0), random(1.0), random(1.0)],k,1,5)$
          (%i3) draw3d(
                   enhanced3d = [sin(j), j],
                   point_size = 3,
                   point_type = filled_circle,
                   points_joined = true,
                   points(m)) $

 -- Opción gráfica: error_type
     Valor por defecto: 'y'

     Dependiendo de su valor, el cual puede ser 'x', 'y' o 'xy', el
     objeto gráfico 'errors' dibujará puntos con barras de error
     horizontales, verticales, o ambas.  Si 'error_type=boxes', se
     dibujarán cajas en lugar de cruces.

     Véase también 'errors'.

 -- Opción gráfica: file_name
     Valor por defecto: '"maxima_out"'

     'file_name' es el nombre del fichero en el que los terminales
     'png', 'jpg', 'gif', 'eps', 'eps_color', 'pdf', 'pdfcairo' y 'svg'
     guardarán el gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.  También puede
     usarse como argumento de la función 'draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'png)$

     Véanse también 'terminal', 'dimensions'.

 -- Opción gráfica: fill_color
     Valor por defecto: '"red"'

     'fill_color' especifica el color para rellenar polígonos y
     funciones explícitas bidimensionales.

     Véase 'color' para más información sobre cómo definir colores.

 -- Opción gráfica: fill_density
     Valor por defecto: 0

     'fill_density' es un número entre 0 y 1 que especifica la
     intensidad del color de relleno (dado por 'fill_color') en los
     objetos 'bars'.

     Véase 'bars' para ejemplos.

 -- Opción gráfica: filled_func
     Valor por defecto: 'false'

     La opción 'filled_func' establece cómo se van a rellenar las
     regiones limitadas por funciones.  Si 'filled_func' vale 'true', la
     región limitada por la función definida en el objeto 'explicit' y
     el borde inferior del la ventana gráfica se rellena con
     'fill_color'.  Si 'filled_func' guarda la expresión de una función,
     entonces la región limitada por esta función y la definida en el
     objeto 'explicit' será la que se rellene.  Por defecto, las
     funciones explícitas no se rellenan.

     Un caso de especial utilidad es 'filled_func=0', con lo que se
     sombrea la región limitada por el eje horizontal y la función
     explícita.

     Esta opción sólo afecta al objeto gráfico bidimensional 'explicit'.

     Ejemplo:

     Región limitada por un objeto 'explicit' y el borde inferior de la
     ventana gráfica.
          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = red,
                       filled_func = true,
                       explicit(sin(x),x,0,10) )$

     Región limitada por un objeto 'explicit' y la función definida en
     la opción 'filled_func'.  Nótese que la variable en 'filled_func'
     debe ser la misma que la utilizada en 'explicit'.
          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = grey,
                       filled_func = sin(x),
                       explicit(-sin(x),x,0,%pi));

     Véanse también 'fill_color' y 'explicit'.

 -- Opción gráfica: font
     Valor por defecto: '""' (cadena vacía)

     Esta opción permite seleccionar el tipo de fuente a utilizar por el
     terminal.  Sólo se puede utilizar un tipo de fuente y tamaño por
     gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Véase también 'font_size'.

     Gnuplot no puede gestionar por sí mismo las fuentes, dejando esta
     tarea a las librerías que dan soporte a los diferentes terminales,
     cada uno con su propia manera de controlar la tipografía.  A
     continuación un breve resumen:

        * x11: Utiliza el mecanismo habitual para suministrar las
          fuentes en x11.

          Ejemplo:
               (%i1) load(draw)$
               (%i2) draw2d(font      = "Arial",
                            font_size = 20,
                            label(["Arial font, size 20",1,1]))$

        * windows: El terminal de windows no permite cambiar fuentes
          desde dentro del gráfico.  Una vez se ha creado el gráfico, se
          pueden cambiar las fuentes haciendo clic derecho en el menú de
          la ventana gráfica.

        * png, jpeg, gif: La librería libgd utiliza la ruta a las
          fuentes almacenada en la variable de entorno 'GDFONTPATH'; en
          tal caso sólo es necesario darle a la opción 'font' el nombre
          de la fuente.  También es posible darle la ruta completa al
          fichero de la fuente.

          Ejemplos:

          A la opción 'font' se le puede dar la ruta completa al fichero
          de la fuente:
               (%i1) load(draw)$
               (%i2) path: "/usr/share/fonts/truetype/freefont/" $
               (%i3) file: "FreeSerifBoldItalic.ttf" $
               (%i4) draw2d(
                       font      = concat(path, file),
                       font_size = 20,
                       color     = red,
                       label(["FreeSerifBoldItalic font, size 20",1,1]),
                       terminal  = png)$

          Si la variable de entorno 'GDFONTPATH' almacena la ruta a la
          carpeta donde se alojan las fuentes, es posible darle a la
          opción 'font' sólo el nombre de la fuente:
               (%i1) load(draw)$
               (%i2) draw2d(
                       font      = "FreeSerifBoldItalic",
                       font_size = 20,
                       color     = red,
                       label(["FreeSerifBoldItalic font, size 20",1,1]),
                       terminal  = png)$

        * Postscript: Las fuentes estándar de Postscript son:
          '"Times-Roman"', '"Times-Italic"', '"Times-Bold"',
          '"Times-BoldItalic"', '"Helvetica"', '"Helvetica-Oblique"',
          '"Helvetica-Bold"', '"Helvetic-BoldOblique"', '"Courier"',
          '"Courier-Oblique"', '"Courier-Bold"' y
          '"Courier-BoldOblique"'.

          Ejemplo:
               (%i1) load(draw)$
               (%i2) draw2d(
                       font      = "Courier-Oblique",
                       font_size = 15,
                       label(["Courier-Oblique font, size 15",1,1]),
                       terminal = eps)$

        * pdf: Utiliza las mismas fuentes que Postscript.

        * pdfcairo: Utiliza las mismas fuentes que wxt.

        * wxt: La librería pango encuentra las fuentes por medio de la
          utilidad 'fontconfig'.

        * aqua: La fuente por defecto es '"Times-Roman"'.

     La documentación de gnuplot es una importante fuente de información
     sobre terminales y fuentes.

 -- Opción gráfica: font_size
     Valor por defecto: 10

     Esta opción permite seleccionar el tamaño de la fuente a utilizar
     por el terminal.  Sólo se puede utilizar un tipo de fuente y tamaño
     por gráfico.  'font_size' sólo se activa cuando la opción 'font'
     tiene un valor diferente de la cadena vacía.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Véase también 'font'.

 -- Opción gráfica: gnuplot_file_name
     Valor por defecto: '"maxout.gnuplot"'

     'gnuplot_file_name' es el nombre del fichero que almacena las
     instrucciones a ser procesadas por Gnuplot.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.  También puede
     usarse como argumento de la función 'draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                 file_name = "my_file",
                 gnuplot_file_name = "my_commands_for_gnuplot",
                 data_file_name    = "my_data_for_gnuplot",
                 terminal          = png,
                 explicit(x^2,x,-1,1)) $

     Véase también 'data_file_name'.

 -- Opción gráfica: grid
     Valor por defecto: 'false'

     Cuando

     Cuando 'grid' toma un valor distinto de 'false', se dibujará una
     rejilla sobre el plano <xy>.  Si a 'grid' se le asigna el valor
     'true', se dibujará una línea de la rejilla por cada marca que haya
     sobre los ejes.  Si a 'grid' se le asigna la lista '[nx,ny]', con
     <[nx,ny] > [0,0]>, se dibujarán 'nx' líneas por cada marca del
     eje-<x> y <ny> líneas por cada marca del eje-<y>.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(grid = true,
                       explicit(exp(u),u,-2,2))$

 -- Opción gráfica: head_angle
     Valor por defecto: 45

     'head_angle' indica el ángulo, en grados, entre la flecha y el
     segmento del vector.

     Esta opción sólo es relevante para objetos de tipo 'vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,10],
                       yrange      = [0,9],
                       head_length = 0.7,
                       head_angle  = 10,
                       vector([1,1],[0,6]),
                       head_angle  = 20,
                       vector([2,1],[0,6]),
                       head_angle  = 30,
                       vector([3,1],[0,6]),
                       head_angle  = 40,
                       vector([4,1],[0,6]),
                       head_angle  = 60,
                       vector([5,1],[0,6]),
                       head_angle  = 90,
                       vector([6,1],[0,6]),
                       head_angle  = 120,
                       vector([7,1],[0,6]),
                       head_angle  = 160,
                       vector([8,1],[0,6]),
                       head_angle  = 180,
                       vector([9,1],[0,6]) )$

     Véanse también 'head_both', 'head_length' y 'head_type'.

 -- Opción gráfica: head_both
     Valor por defecto: 'false'

     Cuando 'head_both' vale 'true', los vectores se dibujan
     bidireccionales.  Si vale 'false', se dibujan unidireccionales.

     Esta opción sólo es relevante para objetos de tipo 'vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,8],
                       yrange      = [0,8],
                       head_length = 0.7,
                       vector([1,1],[6,0]),
                       head_both   = true,
                       vector([1,7],[6,0]) )$

     Véanse también 'head_length', 'head_angle' y 'head_type'.

 -- Opción gráfica: head_length
     Valor por defecto: 2

     'head_length' indica, en las unidades del eje <x>, la longitud de
     las flechas de los vectores.

     Esta opción sólo es relevante para objetos de tipo 'vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,8],
                       vector([0,1],[5,5]),
                       head_length = 1,
                       vector([2,1],[5,5]),
                       head_length = 0.5,
                       vector([4,1],[5,5]),
                       head_length = 0.25,
                       vector([6,1],[5,5]))$

     Véanse también 'head_both', 'head_angle' y 'head_type'.

 -- Opción gráfica: head_type
     Valor por defecto: 'filled'

     'head_type' se utiliza para especificar cómo se habrán de dibujar
     las flechas de los vectores.  Los valores posibles para esta opción
     son: 'filled' (flechas cerradas y rellenas), 'empty' (flechas
     cerradas pero no rellenas) y 'nofilled' (flechas abiertas).

     Esta opción sólo es relevante para objetos de tipo 'vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,10],
                       head_length = 1,
                       vector([0,1],[5,5]), /* default type */
                       head_type = 'empty,
                       vector([3,1],[5,5]),
                       head_type = 'nofilled,
                       vector([6,1],[5,5]))$

     Véanse también 'head_both', 'head_angle' y 'head_length'.

 -- Opción gráfica: interpolate_color
     Valor por defecto: 'false'

     Esta opción solo es relevante si 'enhanced3d' tiene un valor
     diferente de 'false'.

     Si 'interpolate_color' vale 'false', las superficies se colorean
     con cuadriláteros homogéneos.  Si vale 'true', las transiciones de
     colores se suavizan por interpolación.

     La opción 'interpolate_color' también acepta una lista de dos
     números, '[m,n]'.  Para <m> y <n> positivos, cada cuadrilátero o
     triángulo se interpola <m> y <n> veces en la dirección respectiva.
     Para <m> y <n> negativos, la frecuencia de interpolación se elige
     de forma que se dibujen al menos <abs(m)> y <abs(n)> puntos,
     pudiéndose considerar esto como una función especial de enrejado.
     Con valores nulos, esto es 'interpolate_color=[0,0]', se
     seleccionará un número óptimo de puntos interpolados en la
     superficie.

     Además, 'interpolate_color=true' es equivalente a
     'interpolate_color=[0,0]'.

     La interpolación de colores en superficies paramétricas puede dar
     resultados imprevisibles.

     Ejemplos:

     Interpolación de color con funciones explícitas.

          (%i1) load(draw)$
          (%i2) draw3d(
                  enhanced3d   = sin(x*y),
                  explicit(20*exp(-x^2-y^2)-10, x ,-3, 3, y, -3, 3)) $
          (%i3) draw3d(
                  interpolate_color = true,
                  enhanced3d   = sin(x*y),
                  explicit(20*exp(-x^2-y^2)-10, x ,-3, 3, y, -3, 3)) $
          (%i4) draw3d(
                  interpolate_color = [-10,0],
                  enhanced3d   = sin(x*y),
                  explicit(20*exp(-x^2-y^2)-10, x ,-3, 3, y, -3, 3)) $

     Interpolación de color con el objeto 'mesh'.

          (%i1) load(draw)$
          (%i2) draw3d(
                  enhanced3d = true,
                  mesh([[1,1,3],   [7,3,1],[12,-2,4],[15,0,5]],
                       [[2,7,8],   [4,3,1],[10,5,8], [12,7,1]],
                       [[-2,11,10],[6,9,5],[6,15,1], [20,15,2]])) $
          (%i3) draw3d(
                  enhanced3d        = true,
                  interpolate_color = true,
                  mesh([[1,1,3],   [7,3,1],[12,-2,4],[15,0,5]],
                       [[2,7,8],   [4,3,1],[10,5,8], [12,7,1]],
                       [[-2,11,10],[6,9,5],[6,15,1], [20,15,2]])) $
          (%i4) draw3d(
                  enhanced3d        = true,
                  interpolate_color = true,
                  view=map,
                  mesh([[1,1,3],   [7,3,1],[12,-2,4],[15,0,5]],
                       [[2,7,8],   [4,3,1],[10,5,8], [12,7,1]],
                       [[-2,11,10],[6,9,5],[6,15,1], [20,15,2]])) $

     Véase también 'enhanced3d'.

 -- Opción gráfica: ip_grid
     Valor por defecto: '[50, 50]'

     'ip_grid' establece la rejilla del primer muestreo para los
     gráficos de funciones implícitas.

     Esta opción sólo es relevante para funciones de tipo 'implicit'.

 -- Opción gráfica: ip_grid_in
     Valor por defecto: '[5, 5]'

     'ip_grid_in' establece la rejilla del segundo muestreo para los
     gráficos de funciones implícitas.

     Esta opción sólo es relevante para funciones de tipo 'implicit'.

 -- Opción gráfica: key
     Valor por defecto: '""' (cadena vacía)

     'key' es la clave de una función en la leyenda.  Si 'key' es una
     cadena vacía, las funciones no tendrán clave asociada en la
     leyenda.

     Esta opción afecta a los siguientes objetos gráficos:
        * 'gr2d': 'points', 'polygon', 'rectangle', 'ellipse', 'vector',
          'explicit', 'implicit', 'parametric' y 'polar'.

        * 'gr3d': 'points', 'explicit', 'parametric', y
          'parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(key   = "Sinus",
                       explicit(sin(x),x,0,10),
                       key   = "Cosinus",
                       color = red,
                       explicit(cos(x),x,0,10) )$

 -- Opción gráfica: key_pos
     Valor por defecto: '""' (cadena vacía)

     La opción 'key_pos' establece en qué posición se colocará la
     leyenda.  Si 'key' es una cadena vacía, entonces se utilizará por
     defecto la posición '"top_right"'.  Los valores disponibles para
     esta opción son: 'top_left', 'top_center', 'top_right',
     'center_left', 'center', 'center_right', 'bottom_left',
     'bottom_center' y 'bottom_right'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplos:

          (%i1) load(draw)$
          (%i2) draw2d(
                  key_pos = top_left,
                  key     = "x",
                  explicit(x,  x,0,10),
                  color   = red,
                  key     = "x squared",
                  explicit(x^2,x,0,10))$
          (%i3) draw3d(
                  key_pos = center,
                  key     = "x",
                  explicit(x+y,x,0,10,y,0,10),
                  color= red,
                  key     = "x squared",
                  explicit(x^2+y^2,x,0,10,y,0,10))$

 -- Opción gráfica: label_alignment
     Valor por defecto: 'center'

     'label_alignment' se utiliza para especificar dónde se escribirán
     las etiquetas con respecto a las coordenadas de referencia.  Los
     valores posibles para esta opción son: 'center', 'left' y 'right'.

     Esta opción sólo es relevante para objetos de tipo 'label'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange          = [0,10],
                       yrange          = [0,10],
                       points_joined   = true,
                       points([[5,0],[5,10]]),
                       color           = blue,
                       label(["Centered alignment (default)",5,2]),
                       label_alignment = 'left,
                       label(["Left alignment",5,5]),
                       label_alignment = 'right,
                       label(["Right alignment",5,8]))$

     Véanse también 'label_orientation' y 'color'.

 -- Opción gráfica: label_orientation
     Valor por defecto: 'horizontal'

     'label_orientation' se utiliza para especificar la orientación de
     las etiquetas.  Los valores posibles para esta opción son:
     'horizontal' y 'vertical'.

     Esta opción sólo es relevante para objetos de tipo 'label'.

     Ejemplo:

     En este ejemplo, el punto ficticio que se añade sirve para obtener
     la imagen, ya que el paquete 'draw' necesita siempre de datos para
     construir la escena.
          (%i1) load(draw)$
          (%i2) draw2d(xrange     = [0,10],
                       yrange     = [0,10],
                       point_size = 0,
                       points([[5,5]]),
                       color      = navy,
                       label(["Horizontal orientation (default)",5,2]),
                       label_orientation = 'vertical,
                       color             = "#654321",
                       label(["Vertical orientation",1,5]))$

     Véanse también 'label_alignment' y 'color'.

 -- Opción gráfica: line_type
     Valor por defecto: 'solid'

     'line_type' indica cómo se van a dibujar las líneas; valores
     posibles son 'solid' y 'dots', que están disponibles en todos los
     terminales, y 'dashes', 'short_dashes', 'short_long_dashes',
     'short_short_long_dashes' y 'dot_dash', que no esán disponibles en
     los terminales 'png', 'jpg' y 'gif'.

     Esta opción afecta a los siguientes objetos gráficos:
        * 'gr2d': 'points', 'polygon', 'rectangle', 'ellipse', 'vector',
          'explicit', 'implicit', 'parametric' y 'polar'.

        * 'gr3d': 'points', 'explicit', 'parametric' y
          'parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(line_type = dots,
                       explicit(1 + x^2,x,-1,1),
                       line_type = solid, /* default */
                       explicit(2 + x^2,x,-1,1))$

     Véase también 'line_width'.

 -- Opción gráfica: line_width
     Valor por defecto: 1

     'line_width' es el ancho de las líneas a dibujar.  Su valor debe
     ser un número positivo.

     Esta opción afecta a los siguientes objetos gráficos:
        * 'gr2d': 'points', 'polygon', 'rectangle', 'ellipse', 'vector',
          'explicit', 'implicit', 'parametric' y 'polar'.

        * 'gr3d': 'points' y 'parametric'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^2,x,-1,1), /* default width */
                       line_width = 5.5,
                       explicit(1 + x^2,x,-1,1),
                       line_width = 10,
                       explicit(2 + x^2,x,-1,1))$

     Véase también 'line_type'.

 -- Opción gráfica: logcb
     Valor por defecto: 'false'

     Cuando 'logcb' vale 'true', la escala de colores se dibuja
     logarítmicamente.

     Cuando 'enhanced3d' o 'colorbox' vale 'false', la opción 'logcb' no
     tiene efecto alguno.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d (
                  enhanced3d = true,
                  color      = green,
                  logcb = true,
                  logz  = true,
                  palette = [-15,24,-9],
                  explicit(exp(x^2-y^2), x,-2,2,y,-2,2)) $

     Véanse también 'enhanced3d', 'colorbox' y 'cbrange'.

 -- Opción gráfica: logx
     Valor por defecto: 'false'

     Cuando 'logx' vale 'true', el eje <x> se dibuja en la escala
     logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(log(x),x,0.01,5),
                       logx = true)$

     Véanse también 'logy', 'logx_secondary', 'logy_secondary' y 'logz'.

 -- Opción gráfica: logx_secondary
     Valor por defecto: 'false'

     Si 'logx_secondary' vale 'true', el eje secundario de <x> se dibuja
     en la escala logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                  grid = true,
                  key="x^2, linear scale",
                  color=red,
                  explicit(x^2,x,1,100),
                  xaxis_secondary = true,
                  xtics_secondary = true,
                  logx_secondary  = true,
                  key = "x^2, logarithmic x scale",
                  color = blue,
                  explicit(x^2,x,1,100) )$

     Véanse también 'logx', 'logy', 'logy_secondary' y 'logz'.

 -- Opción gráfica: logy
     Valor por defecto: 'false'

     Cuando 'logy' vale 'true', el eje <y> se dibuja en la escala
     logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(logy = true,
                       explicit(exp(x),x,0,5))$

     Véanse también 'logx', 'logx_secondary', 'logy_secondary' y 'logz'.

 -- Opción gráfica: logy_secondary
     Valor por defecto: 'false'

     Si 'logy_secondary' vale 'true', el eje secundario de <y> se dibuja
     en la escala logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                  grid = true,
                  key="x^2, linear scale",
                  color=red,
                  explicit(x^2,x,1,100),
                  yaxis_secondary = true,
                  ytics_secondary = true,
                  logy_secondary  = true,
                  key = "x^2, logarithmic y scale",
                  color = blue,
                  explicit(x^2,x,1,100) )$

     Véanse también 'logx', 'logy', 'logx_secondary' y 'logz'.

 -- Opción gráfica: logz
     Valor por defecto: 'false'

     Cuando 'logz' vale 'true', el eje <z> se dibuja en la escala
     logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(logz = true,
                       explicit(exp(u^2+v^2),u,-2,2,v,-2,2))$

     Véanse también 'logx' and 'logy'.

 -- Opción gráfica: nticks
     Valor por defecto: 29

     En 2d, 'nticks' es el número de puntos a utilizar por el programa
     adaptativo que genera las funciones explícitas.  También es el
     número de puntos que se representan en las curvas paramétricas y
     polares.

     Esta opción afecta a los siguientes objetos gráficos:
        * 'gr2d': 'ellipse', 'explicit', 'parametric' y 'polar'.

        * 'gr3d': 'parametric'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(transparent = true,
                       ellipse(0,0,4,2,0,180),
                       nticks = 5,
                       ellipse(0,0,4,2,180,180) )$

 -- Opción gráfica: palette
     Valor por defecto: 'color'

     'palette' indica cómo transformar niveles de gris en componentes
     cromáticas.  Trabaja conjuntamente con la opción 'enhanced3d' en
     gráficos 3D, la cual asocia cada punto de una superficie con un
     número real o nivel de gris.  También trabaja con imágenes grises.
     Con 'palette', estos niveles se transforman en colores.

     Hay dos formas de definir estas transformaciones.

     En primer lugar, 'palette' puede ser un vector de longitud tres con
     sus componentes tomando valores enteros en el rango desde -36 a
     +36; cada valor es un índice para seleccionar una fórmula que
     transforma los niveles numéricos en las componentes cromáticas
     rojo, verde y azul:
           0: 0               1: 0.5           2: 1
           3: x               4: x^2           5: x^3
           6: x^4             7: sqrt(x)       8: sqrt(sqrt(x))
           9: sin(90x)       10: cos(90x)     11: |x-0.5|
          12: (2x-1)^2       13: sin(180x)    14: |cos(180x)|
          15: sin(360x)      16: cos(360x)    17: |sin(360x)|
          18: |cos(360x)|    19: |sin(720x)|  20: |cos(720x)|
          21: 3x             22: 3x-1         23: 3x-2
          24: |3x-1|         25: |3x-2|       26: (3x-1)/2
          27: (3x-2)/2       28: |(3x-1)/2|   29: |(3x-2)/2|
          30: x/0.32-0.78125 31: 2*x-0.84     32: 4x;1;-2x+1.84;x/0.08-11.5
          33: |2*x - 0.5|    34: 2*x          35: 2*x - 0.5
          36: 2*x - 1
     los números negativos se interpretan como colores invertidos de las
     componentes cromáticas.  'palette = gray' y 'palette = color' son
     atajos para 'palette = [3,3,3]' y 'palette = [7,5,15]',
     respectivamente.

     En segundo lugar, 'palette' puede ser una paleta de colores
     definida por el usuario.  En este caso, el formato para crear una
     paleta de longitud 'n' es 'palette=[color_1, color_2, ...,
     color_n]', donde 'color_i' es un color correctamente definido
     (véase la opción 'color'), de tal manera que 'color_1' se asigna al
     valor más bajo del nivel y 'color_n' al más alto.  El resto de
     colores se interpolan.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplos:

     Trabaja conjuntamente con la opción 'enhanced3d' en gráficos 3D.

          (%i1) load(draw)$
          (%i2) draw3d(
                  enhanced3d = [z-x+2*y,x,y,z],
                  palette = [32, -8, 17],
                  explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3))$

     También trabaja con imágenes grises.

          (%i1) load(draw)$
          (%i2) im: apply(
                     'matrix,
                      makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) /* palette = color, default */
                draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(palette = gray, image(im,0,0,30,30))$
          (%i5) draw2d(palette = [15,20,-4],
                       colorbox=false,
                       image(im,0,0,30,30))$

     'palette' puede ser una paleta de colores definida por el usuario.
     En este ejemplo, valores bajos de 'x' se colorean en rojo y altos
     en amarillo.

          (%i1) load(draw)$
          (%i2) draw3d(
                   palette = [red, blue, yellow],
                   enhanced3d = x,
                   explicit(x^2+y^2,x,-1,1,y,-1,1)) $

     Véase también 'colorbox' y 'enhanced3d'.

 -- Opción gráfica: point_size
     Valor por defecto: 1

     'point_size' establece el tamaño de los puntos dibujados.  Debe ser
     un número no negativo.

     Esta opción no tiene efecto alguno cuando a la opción gráfica
     'point_type' se le ha dado el valor 'dot'.

     Esta opción afecta a los siguientes objetos gráficos:
        * 'gr2d': 'points'.

        * 'gr3d': 'points'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                  points(makelist([random(20),random(50)],k,1,10)),
                  point_size = 5,
                  points(makelist(k,k,1,20),makelist(random(30),k,1,20)))$

 -- Opción gráfica: point_type
     Valor por defecto: 1

     'point_type' indica cómo se van a dibujar los puntos aislados.  Los
     valores para esta opción pueden ser índices enteros mayores o
     iguales que -1, o también nombres de estilos: '$none' (-1), 'dot'
     (0), 'plus' (1), 'multiply' (2), 'asterisk' (3), 'square' (4),
     'filled_square' (5), 'circle' (6), 'filled_circle' (7),
     'up_triangle' (8), 'filled_up_triangle' (9), 'down_triangle' (10),
     'filled_down_triangle' (11), 'diamant' (12) y 'filled_diamant'
     (13).

     Esta opción afecta a los siguientes objetos gráficos:
        * 'gr2d': 'points'.

        * 'gr3d': 'points'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange = [0,10],
                       yrange = [0,10],
                       point_size = 3,
                       point_type = diamant,
                       points([[1,1],[5,1],[9,1]]),
                       point_type = filled_down_triangle,
                       points([[1,2],[5,2],[9,2]]),
                       point_type = asterisk,
                       points([[1,3],[5,3],[9,3]]),
                       point_type = filled_diamant,
                       points([[1,4],[5,4],[9,4]]),
                       point_type = 5,
                       points([[1,5],[5,5],[9,5]]),
                       point_type = 6,
                       points([[1,6],[5,6],[9,6]]),
                       point_type = filled_circle,
                       points([[1,7],[5,7],[9,7]]),
                       point_type = 8,
                       points([[1,8],[5,8],[9,8]]),
                       point_type = filled_diamant,
                       points([[1,9],[5,9],[9,9]]) )$

 -- Opción gráfica: points_joined
     Valor por defecto: 'false'

     Cuando 'points_joined' vale 'true', los puntos se unen con
     segmentos; si vale 'false', se dibujarán puntos aislados.  Un
     tercer valor posible para esta opción gráfica es 'impulses'; en tal
     caso, se dibujarán segmentos verticales desde los puntos hasta el
     eje-x (2D) o hasta el plano-xy (3D).

     Esta opción afecta a los siguientes objetos gráficos:
        * 'gr2d': 'points'.

        * 'gr3d': 'points'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange        = [0,10],
                       yrange        = [0,4],
                       point_size    = 3,
                       point_type    = up_triangle,
                       color         = blue,
                       points([[1,1],[5,1],[9,1]]),
                       points_joined = true,
                       point_type    = square,
                       line_type     = dots,
                       points([[1,2],[5,2],[9,2]]),
                       point_type    = circle,
                       color         = red,
                       line_width    = 7,
                       points([[1,3],[5,3],[9,3]]) )$

 -- Opción gráfica: proportional_axes
     Valor por defecto: 'none'

     Cuando 'proportional_axes' es igual a 'xy' o 'xy', una escena 2D o
     3D se dibujará con los ejes proporcionales a sus longitudes
     relativas.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Esta opción sólo funciona con Gnuplot versión 4.2.6 o superior.

     Ejemplos:

     Gráfico en 2D.

          (%i1) load(draw)$
          (%i2) draw2d(
                  ellipse(0,0,1,1,0,360),
                  transparent=true,
                  color = blue,
                  line_width = 4,
                  ellipse(0,0,2,1/2,0,360),
                  proportional_axes = xy) $

     Multiplot.

          (%i1) load(draw)$
          (%i2) draw(
                  terminal = wxt,
                  gr2d(proportional_axes = xy,
                       explicit(x^2,x,0,1)),
                  gr2d(explicit(x^2,x,0,1),
                       xrange = [0,1],
                       yrange = [0,2],
                       proportional_axes=xy),
                  gr2d(explicit(x^2,x,0,1)))$

 -- Opción gráfica: surface_hide
     Valor por defecto: 'false'

     Cuando 'surface_hide' vale 'true', las partes ocultas no se
     muestran en las superficies de las escenas 3d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw(columns=2,
                     gr3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)),
                     gr3d(surface_hide = true,
                          explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)) )$

 -- Opción gráfica: terminal
     Valor por defecto: 'screen'

     Selecciona el terminal a utilizar por Gnuplot; valores posibles
     son: 'screen' (por defecto), 'png', 'pngcairo', 'jpg', 'gif',
     'eps', 'eps_color', 'epslatex', 'epslatex_standalone', 'svg',
     'dumb', 'dumb_file', 'pdf', 'pdfcairo', 'wxt', 'animated_gif',
     'multipage_pdfcairo', 'multipage_pdf', 'multipage_eps',
     'multipage_eps_color' y 'aquaterm'.

     Los terminales 'screen', 'wxt' y 'aquaterm' también se pueden
     definir como una lista de dos elementos: el propio nombre del
     terminal y un número entero no negativo.  De esta forma se pueden
     abrir varias ventanas al mismo tiempo, cada una de ellas con su
     número correspondiente.  Esta modalidad no funciona en plataformas
     Windows.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.  También puede
     usarse como argumento de la función 'draw'.

     pdfcairo necesita Gnuplot 4.3.  'pdf' necesita que Gnuplot haya
     sido compilado con la opción '--enable-pdf' y libpdf debe estar
     instalado
     (<http://www.pdflib.com/en/download/pdflib-family/pdflib-lite/>).

     Ejemplos:

          (%i1) load(draw)$
          (%i2) /* screen terminal (default) */
                draw2d(explicit(x^2,x,-1,1))$
          (%i3) /* png file */
                draw2d(terminal  = 'png,
                       explicit(x^2,x,-1,1))$
          (%i4) /* jpg file */
                draw2d(terminal   = 'jpg,
                       dimensions = [300,300],
                       explicit(x^2,x,-1,1))$
          (%i5) /* eps file */
                draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'eps)$
          (%i6) /* pdf file */
                draw2d(file_name = "mypdf",
                       dimensions = 100*[12.0,8.0],
                       explicit(x^2,x,-1,1),
                       terminal  = 'pdf)$
          (%i7) /* wxwidgets window */
                draw2d(explicit(x^2,x,-1,1),
                       terminal  = 'wxt)$

     Ventanas múltiples.
          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^5,x,-2,2), terminal=[screen, 3])$
          (%i3) draw2d(explicit(x^2,x,-2,2), terminal=[screen, 0])$

     Un fichero gif animado.
          (%i1) load(draw)$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     La opción 'delay' sólo se activa en caso de gifs animados; se
     ignora en cualquier otro caso.

     Salida multipágina en formato eps.
          (%i1) load(draw)$
          (%i2) draw(
                  file_name = "parabol",
                  terminal  = multipage_eps,
                  dimensions = 100*[10,10],
                  gr2d(explicit(x^2,x,-1,1)),
                  gr3d(explicit(x^2+y^2,x,-1,1,y,-1,1))) $

     Véanse también 'file_name', 'pic_width', 'pic_height' y 'delay'.

 -- Opción gráfica: title
     Valor por defecto: '""' (cadena vacía)

     La opción 'title' almacena una cadena con el título de la escena.
     Por defecto, no se escribe título alguno.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(u),u,-2,2),
                       title = "Exponential function")$

 -- Opción gráfica: transform
     Valor por defecto: 'none'

     Si 'transform' vale 'none', el espacio no sufre transformación
     alguna y los objetos gráficos se representan tal cual se definen.
     Si es necesario transformar el espacio, se debe asignar una lista a
     la opción 'transform'.  En caso de una escena 2D, la lista toma la
     forma '[f1(x,y), f2(x,y), x, y]'.  En caso de una escena 3D, la
     lista debe ser de la forma '[f1(x,y,z), f2(x,y,z), f3(x,y,z), x, y,
     z]'.

     Los nombres de las variables definidas en las listas pueden ser
     diferentes de aquellas utilizadas en las definiciones de los
     objetos gráficos.

     Ejemplos:

     Rotación en 2D.

          (%i1) load(draw)$
          (%i2) th : %pi / 4$
          (%i3) draw2d(
                  color = "#e245f0",
                  proportional_axes = 'xy,
                  line_width = 8,
                  triangle([3,2],[7,2],[5,5]),
                  border     = false,
                  fill_color = yellow,
                  transform  = [cos(th)*x - sin(th)*y,
                                sin(th)*x + cos(th)*y, x, y],
                  triangle([3,2],[7,2],[5,5]) )$

     Traslación en 3D.

          (%i1) load(draw)$
          (%i2) draw3d(
                  color     = "#a02c00",
                  explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3),
                  transform = [x+10,y+10,z+10,x,y,z],
                  color     = blue,
                  explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3) )$

 -- Opción gráfica: transparent
     Valor por defecto: 'false'

     Cuando 'transparent' vale 'false', las regiones internas de los
     polígonos se rellenan de acuerdo con 'fill_color'.

     Esta opción afecta a los siguientes objetos gráficos:
        * 'gr2d': 'polygon', 'rectangle' y 'ellipse'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(polygon([[3,2],[7,2],[5,5]]),
                       transparent = true,
                       color       = blue,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Opción gráfica: unit_vectors
     Valor por defecto: 'false'

     Cuando 'unit_vectors' vale 'true', los vectores se dibujan con
     módulo unidad.  Esta opción es útil para representar campos
     vectoriales.  Cuando 'unit_vectors' vale 'false', los vectores se
     dibujan con su longitud original.

     Esta opción sólo es relevante para objetos de tipo 'vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [-1,6],
                       yrange      = [-1,6],
                       head_length = 0.1,
                       vector([0,0],[5,2]),
                       unit_vectors = true,
                       color        = red,
                       vector([0,3],[5,2]))$

 -- Opción gráfica: user_preamble
     Valor por defecto: '""' (cadena vacía)

     Usuarios expertos en Gnuplot pueden hacer uso de esta opción para
     afinar el comportamiento de Gnuplot escribiendo código que será
     enviado justo antes de la instrucción 'plot' o 'splot'.

     El valor dado a esta opción debe ser una cadena alfanumérica o una
     lista de cadenas (una por línea).

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

     Se le indica a Gnuplot que dibuje los ejes encima de todos los
     demás objetos,
          (%i1) load(draw)$
          (%i2) draw2d(
                  xaxis =true, xaxis_type=solid,
                  yaxis =true, yaxis_type=solid,
                  user_preamble="set grid front",
                  region(x^2+y^2<1 ,x,-1.5,1.5,y,-1.5,1.5))$

 -- Opción gráfica: view
     Valor por defecto: '[60,30]'

     Un par de ángulos, medidos en grados, indicando la direcciÃ³n del
     observador en una escena 3D. El primer ángulo es la rotación
     vertical alrededor del eje <x>, dentro del intervalo [0, 360].  El
     segundo es la rotación horizontal alrededor del eje <z>, dentro del
     intervalo [0, 360].

     Dándole a la opción 'view' el valor 'map', la dirección del
     observador se sitúa perpendicularmente al plano-xy.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(view = [170, 50],
                       enhanced3d = true,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$
          (%i3) draw3d(view = map,
                       enhanced3d = true,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

 -- Opción gráfica: wired_surface
     Valor por defecto: 'false'

     Indica si las superficies en 3D en modo 'enhanced3d' deben mostrar
     o no la malla que unen los puntos.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(
                  enhanced3d    = [sin(x),x,y],
                  wired_surface = true,
                  explicit(x^2+y^2,x,-1,1,y,-1,1)) $

 -- Opción gráfica: x_voxel
     Valor por defecto: 10

     'x_voxel' es el número de voxels en la dirección x a utilizar por
     el algoritmo marching cubes implementado por el objeto 'implicit'
     tridimensional.  También se utiliza como opción del objeto gráfico
     'region'.

 -- Opción gráfica: xaxis
     Valor por defecto: 'false'

     Si 'xaxis' vale 'true', se dibujará el eje <x>.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_color = blue)$

     Véanse también 'xaxis_width', 'xaxis_type' y 'xaxis_color'.

 -- Opción gráfica: xaxis_color
     Valor por defecto: '"black"'

     'xaxis_color' especifica el color para el eje <x>.  Véase 'color'
     para ver cómo se definen los colores.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_color = red)$

     Véanse también 'xaxis', 'xaxis_width' y 'xaxis_type'.

 -- Opción gráfica: xaxis_secondary
     Valor por defecto: 'false'

     Si 'xaxis_secondary' vale 'true', los valores de las funciones se
     pueden representar respecto del eje <x> secundario, el cual se
     dibuja en la parte superior de la escena.

     Nótese que esta es una opción gráfica local que sólo afecta a
     objetos 2d.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                   key   = "Bottom x-axis",
                   explicit(x+1,x,1,2),
                   color = red,
                   key   = "Above x-axis",
                   xtics_secondary = true,
                   xaxis_secondary = true,
                   explicit(x^2,x,-1,1)) $

     Véanse también 'xrange_secondary', 'xtics_secondary',
     'xtics_rotate_secondary', 'xtics_axis_secondary' y
     'xaxis_secondary'.

 -- Opción gráfica: xaxis_type
     Valor por defecto: 'dots'

     'xaxis_type' indica cómo se debe dibujar el eje <x>; valores
     admisibles son 'solid' y 'dots'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_type  = solid)$

     Véanse también 'xaxis', 'xaxis_width' y 'xaxis_color'.

 -- Opción gráfica: xaxis_width
     Valor por defecto: 1

     'xaxis_width' es el ancho del eje <x>.  Su valor debe ser un número
     positivo.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_width = 3)$

     Véanse también 'xaxis', 'xaxis_type' y 'xaxis_color'.

 -- Opción gráfica: xlabel
     Valor por defecto: '""'

     La opción 'xlabel' almacena una cadena con la etiqueta del eje <x>.
     Por defecto, el eje tiene etiqueta '"x"'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xlabel = "Time",
                       explicit(exp(u),u,-2,2),
                       ylabel = "Population")$

     Véanse también 'xlabel_secondary', 'ylabel', 'ylabel_secondary' y
     'zlabel'.

 -- Opción gráfica: xlabel_secondary
     Valor por defecto: '""' (cadena vacía)

     La opción 'xlabel_secondary' almacena una cadena con la etiqueta
     del eje <x> secundario.  Por defecto, el eje no tiene etiqueta.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                   xaxis_secondary=true,yaxis_secondary=true,
                   xtics_secondary=true,ytics_secondary=true,
                   xlabel_secondary="t[s]",
                   ylabel_secondary="U[V]",
                   explicit(sin(t),t,0,10) )$

     Véanse también 'xlabel', 'ylabel', 'ylabel_secondary' y 'zlabel'.

 -- Opción gráfica: xrange
     Valor por defecto: 'auto'

     Cuando 'xrange' vale 'auto', el rango de la coordenada <x> se
     calcula de forma automática.

     Si el usuario quiere especificar un intervalo para <x>, éste debe
     expresarse como una lista de Maxima, como en 'xrange=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange = [-3,5],
                       explicit(x^2,x,-1,1))$

     Véanse también 'yrange' y 'zrange'.

 -- Opción gráfica: xrange_secondary
     Valor por defecto: 'auto'

     Cuando 'xrange_secondary' vale 'auto', el rango del eje <x>
     secundario se calcula de forma automática.

     Si el usuario quiere especificar un intervalo para el eje <x>
     secundario, éste debe expresarse como una lista de Maxima, como en
     'xrange_secondary=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Véanse también 'xrange', 'yrange', 'zrange' y 'yrange_secondary'.

 -- Opción gráfica: xtics
     Valor por defecto: 'true'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <x>.

        * Cuando a 'xtics' se le da el valor <true>, las marcas se
          dibujarán de forma automática.

        * Cuando a 'xtics' se le da el valor <false>, no habrá marcas en
          los ejes.

        * Cuando a 'xtics' se le da un valor numérico positivo, se
          interpretará como la distancia entre dos marcas consecutivas.

        * Cuando a 'xtics' se le da una lista de longitud tres de la
          forma '[start,incr,end]', las marcas se dibujarán desde
          'start' hasta 'end' a intervalos de longitud 'incr'.

        * Cuando a 'xtics' se le da un conjunto de números de la forma
          '{n1, n2, ...}', las marcas se dibujarán exactamente en los
          valores 'n1', 'n2', ...

        * Cuando a 'xtics' se le da un conjunto de pares de la forma
          '{["label1", n1], ["label2", n2], ...}', las marcas
          correspondientes a los valores 'n1', 'n2', ...  se etiquetarán
          con '"label1"', '"label2"', ..., respectivamente.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplos:

     Marcas desactivadas.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = 'false,
                       explicit(x^3,x,-1,1)  )$

     Marcas cada 1/4 unidades.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = 1/4,
                       explicit(x^3,x,-1,1)  )$

     Marcas desde -3/4 hasta 3/4 en saltos de 1/8.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = [-3/4,1/8,3/4],
                       explicit(x^3,x,-1,1)  )$

     Marcas en los puntos -1/2, -1/4 y 3/4.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = {-1/2,-1/4,3/4},
                       explicit(x^3,x,-1,1)  )$

     Marcas etiquetadas.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = {["High",0.75],["Medium",0],["Low",-0.75]},
                       explicit(x^3,x,-1,1)  )$

 -- Opción gráfica: xtics_axis
     Valor por defecto: 'false'

     Si 'xtics_axis' vale 'true', las marcas y sus etiquetas se dibujan
     sobre el propio eje <x>, si vale 'false' las marcas se colocan a lo
     largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: xtics_rotate
     Valor por defecto: 'false'

     Si 'xtics_rotate' vale 'true', las marcas del eje <x> se giran 90
     grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: xtics_rotate_secondary
     Valor por defecto: 'false'

     Si 'xtics_rotate_secondary' vale 'true', las marcas del eje <x>
     secundario se giran 90 grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: xtics_secondary
     Valor por defecto: 'auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <x> secundario.

     Véase 'xtics' para una descripción completa.

 -- Opción gráfica: xtics_secondary_axis
     Valor por defecto: 'false'

     Si 'xtics_secondary_axis' vale 'true', las marcas y sus etiquetas
     se dibujan sobre el propio eje <x> secundario, si vale 'false' las
     marcas se colocan a lo largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: xu_grid
     Valor por defecto: 30

     'xu_grid' es el número de coordenadas de la primera variable ('x'
     en superficies explcítas y 'u' en las paramétricas) para formar la
     rejilla de puntos muestrales.

     Esta opción afecta a los siguientes objetos gráficos:
        * 'gr3d': 'explicit' y 'parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     Véase también 'yv_grid'.

 -- Opción gráfica: xy_file
     Valor por defecto: '""' (cadena vacía)

     'xy_file' es el nombre del fichero donde se almacenarán las
     coordenadas después de hacer clic con el botón del ratón en un
     punto de la imagen y pulsado la tecla 'x'.  Por defecto, las
     coordenadas no se almacenan.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Graphic option: xyplane
     Valor por defecto: 'false'

     Coloca el plano-xy en escenas 3D. Si 'xyplane' vale 'false', el
     plano-xy se coloca automáticamente; en cambio, si toma un valor
     real, el plano-xy intersectará con el eje <z> a ese nivel.  Esta
     opción no tiene efecto alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(xyplane = %e-2,
                       explicit(x^2+y^2,x,-1,1,y,-1,1))$

 -- Opción gráfica: y_voxel
     Valor por defecto: 10

     'y_voxel' es el número de voxels en la dirección y a utilizar por
     el algoritmo marching cubes implementado por el objeto 'implicit'
     tridimensional.  También se utiliza como opción del objeto gráfico
     'region'.

 -- Opción gráfica: yaxis
     Valor por defecto: 'false'

     Si 'yaxis' vale 'true', se dibujará el eje <y>.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_color = blue)$

     Véanse también 'yaxis_width', 'yaxis_type' y 'yaxis_color'.

 -- Opción gráfica: yaxis_color
     Valor por defecto: '"black"'

     'yaxis_color' especifica el color para el eje <y>.  Véase 'color'
     para ver cómo se definen los colores.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_color = red)$

     Véanse también 'yaxis', 'yaxis_width' y 'yaxis_type'.

 -- Opción gráfica: yaxis_secondary
     Valor por defecto: 'false'

     Si 'yaxis_secondary' vale 'true', los valores de las funciones se
     pueden representar respecto del eje <y> secundario, el cual se
     dibuja al lado derecho de la escena.

     Nótese que esta es una opción gráfica local que sólo afecta a
     objetos 2d.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                   explicit(sin(x),x,0,10),
                   yaxis_secondary = true,
                   ytics_secondary = true,
                   color = blue,
                   explicit(100*sin(x+0.1)+2,x,0,10));

     Véanse también 'yrange_secondary', 'ytics_secondary',
     'ytics_rotate_secondary' y 'ytics_axis_secondary'.

 -- Opción gráfica: yaxis_type
     Valor por defecto: 'dots'

     'yaxis_type' indica cómo se debe dibujar el eje <y>; valores
     admisibles son 'solid' y 'dots'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_type  = solid)$

     Véanse también 'yaxis', 'yaxis_width' y 'yaxis_color'.

 -- Opción gráfica: yaxis_width
     Valor por defecto: 1

     'yaxis_width' es el ancho del eje <y>.  Su valor debe ser un número
     positivo.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_width = 3)$

     Véanse también 'yaxis', 'yaxis_type' y 'yaxis_color'.

 -- Opción gráfica: ylabel
     Valor por defecto: '""'

     La opción 'ylabel' almacena una cadena con la etiqueta del eje <y>.
     Por defecto, el eje tiene etiqueta '"y"'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xlabel = "Time",
                       ylabel = "Population",
                       explicit(exp(u),u,-2,2) )$

     Véanse también 'xlabel', 'xlabel_secondary', 'ylabel_secondary' y
     'zlabel'.

 -- Opción gráfica: ylabel_secondary
     Valor por defecto: '""' (cadena vacía)

     La opción 'ylabel_secondary' almacena una cadena con la etiqueta
     del eje <y> secundario.  Por defecto, el eje no tiene etiqueta.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                  key="current",
                  xlabel="t[s]",
                  ylabel="I[A]",ylabel_secondary="P[W]",
                  explicit(sin(t),t,0,10),
                  yaxis_secondary=true,
                  ytics_secondary=true,
                  color=red,key="Power",
                  explicit((sin(t))^2,t,0,10)
              )$

     Véanse también 'xlabel', 'xlabel_secondary', 'ylabel' and 'zlabel'.

 -- Opción gráfica: yrange
     Valor por defecto: 'auto'

     Cuando 'yrange' vale 'auto', el rango de la coordenada <y> se
     calcula de forma automática.

     Si el usuario quiere especificar un intervalo para <y>, éste debe
     expresarse como una lista de Maxima, como en 'yrange=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(yrange = [-2,3],
                       explicit(x^2,x,-1,1),
                       xrange = [-3,3])$

     Véanse también 'xrange' y 'zrange'.

 -- Opción gráfica: yrange_secondary
     Valor por defecto: 'auto'

     Cuando 'yrange_secondary' vale 'auto', el rango del eje <y>
     secundario se calcula de forma automática.

     Si el usuario quiere especificar un intervalo para el eje <y>
     secundario, éste debe expresarse como una lista de Maxima, como en
     'yrange_secondary=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                   explicit(sin(x),x,0,10),
                   yaxis_secondary = true,
                   ytics_secondary = true,
                   yrange = [-3, 3],
                   yrange_secondary = [-20, 20],
                   color = blue,
                   explicit(100*sin(x+0.1)+2,x,0,10)) $

     Véanse también 'xrange', 'yrange' y 'zrange'.

 -- Opción gráfica: ytics
     Valor por defecto: 'true'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <y>.

     Véase 'xtics' para una descripción completa.

 -- Opción gráfica: ytics_axis
     Valor por defecto: 'false'

     Si 'ytics_axis' vale 'true', las marcas y sus etiquetas se dibujan
     sobre el propio eje <y>, si vale 'false' las marcas se colocan a lo
     largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ytics_rotate
     Valor por defecto: 'false'

     Si 'ytics_rotate' vale 'true', las marcas del eje <y> se giran 90
     grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ytics_rotate_secondary
     Valor por defecto: 'false'

     Si 'ytics_rotate_secondary' vale 'true', las marcas del eje <y>
     secundario se giran 90 grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ytics_secondary
     Valor por defecto: 'auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <y> secundario.

     Véase 'xtics' para una descripción completa.

 -- Opción gráfica: ytics_secondary_axis
     Valor por defecto: 'false'

     Si 'ytics_secondary_axis' vale 'true', las marcas y sus etiquetas
     se dibujan sobre el propio eje <y> secundario, si vale 'false' las
     marcas se colocan a lo largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: yv_grid
     Valor por defecto: 30

     'yv_grid' es el número de coordenadas de la segunda variable ('y'
     en superficies explcítas y 'v' en las paramétricas) para formar la
     rejilla de puntos muestrales.

     Esta opción afecta a los siguientes objetos gráficos:
        * 'gr3d': 'explicit' y 'parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     Véase también 'xu_grid'.

 -- Opción gráfica: z_voxel
     Valor por defecto: 10

     'z_voxel' es el número de voxels en la dirección z a utilizar por
     el algoritmo marching cubes implementado por el objeto 'implicit'
     tridimensional.

 -- Opción gráfica: zaxis
     Valor por defecto: 'false'

     Si 'zaxis' vale 'true', se dibujará el eje <z> en escenas 3D. Esta
     opción no tiene efecto alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_color = blue)$

     Véanse también 'zaxis_width', 'zaxis_type' y 'zaxis_color'.

 -- Opción gráfica: zaxis_color
     Valor por defecto: '"black"'

     'zaxis_color' especifica el color para el eje <z>.  Véase 'color'
     para ver cómo se definen los colores.  Esta opción no tiene efecto
     alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_color = red)$

     Véanse también 'zaxis', 'zaxis_width' y 'zaxis_type'.

 -- Opción gráfica: zaxis_type
     Valor por defecto: 'dots'

     'zaxis_type' indica cómo se debe dibujar el eje <z>; valores
     admisibles son 'solid' y 'dots'.  Esta opción no tiene efecto
     alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid)$

     Véanse también 'zaxis', 'zaxis_width' y 'zaxis_color'.

 -- Opción gráfica: zaxis_width
     Valor por defecto: 1

     'zaxis_width' es el ancho del eje <z>.  Su valor debe ser un número
     positivo.  Esta opción no tiene efecto alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_width = 3)$

     Véanse también 'zaxis', 'zaxis_type' y 'zaxis_color'.

 -- Opción gráfica: zlabel
     Valor por defecto: '""'

     La opción 'zlabel' almacena una cadena con la etiqueta del eje <z>.
     Por defecto, el eje tiene etiqueta '"z"'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(zlabel = "Z variable",
                       ylabel = "Y variable",
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2),
                       xlabel = "X variable" )$

     Véanse también 'xlabel' y 'ylabel'.

 -- Opción gráfica: zrange
     Valor por defecto: 'auto'

     Cuando 'zrange' vale 'auto', el rango de la coordenada <z> se
     calcula de forma automática.

     Si el usuario quiere especificar un intervalo para <z>, éste debe
     expresarse como una lista de Maxima, como en 'zrange=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(yrange = [-3,3],
                       zrange = [-2,5],
                       explicit(x^2+y^2,x,-1,1,y,-1,1),
                       xrange = [-3,3])$

     Véanse también 'xrange' y 'yrange'.

 -- Opción gráfica: ztics
     Valor por defecto: 'true'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <z>.

     Véase 'xtics' para una descripción completa.

 -- Opción gráfica: ztics_axis
     Valor por defecto: 'false'

     Si 'ztics_axis' vale 'true', las marcas y sus etiquetas se dibujan
     sobre el propio eje <z>, si vale 'false' las marcas se colocan a lo
     largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ztics_rotate
     Valor por defecto: 'false'

     Si 'ztics_rotate' vale 'true', las marcas del eje <z> se giran 90
     grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

47.2.4 Objetos gráficos
-----------------------

 -- Objeto gráfico: bars ([<x1>,<h1>,<w1>], [<x2>,<h2>,<w2>, ...])
     Dibuja barras verticales en 2D.

     2D

     'bars ([<x1>,<h1>,<w1>], [<x2>,<h2>,<w2>, ...])' dibuja barras
     centradas en los valores <x1>, <x2>, ...  de alturas <h1>, <h2>,
     ...  y anchos <w1>, <w2>, ...

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'key', 'fill_color', 'fill_density' y 'line_width'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                 key          = "Grupo A",
                 fill_color   = blue,
                 fill_density = 0.2,
                 bars([0.8,5,0.4],[1.8,7,0.4],[2.8,-4,0.4]),
                 key          = "Grupo B",
                 fill_color   = red,
                 fill_density = 0.6,
                 line_width   = 4,
                 bars([1.2,4,0.4],[2.2,-2,0.4],[3.2,5,0.4]),
                 xaxis = true);

 -- Objeto gráfico: cylindrical
          (<radius>,<z>,<minz>,<maxz>,<azi>,<minazi>,<maxazi>)
     Dibuja funciones 3D definidas en coordenadas cilíndricas.

     3D

     'cylindrical (<radius>,<z>,<minz>,<maxz>,<azi>,<minazi>,<maxazi>)'
     dibuja la función '<radius>(<z>,<azi>)' definida en coordenadas
     cilíndricas, con la variable <z> tomando valores desde <minz> hasta
     <maxz> y el azimut <azi> tomando valores desde <minazi> hasta
     <maxazi>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'xu_grid', 'yv_grid', 'line_type', 'key', 'wired_surface',
     'enhanced3d' y 'color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(cylindrical(1,z,-2,2,az,0,2*%pi))$

 -- Objeto gráfico: elevation_grid (<mat>,<x0>,<y0>,<width>,<height>)
     Dibuja la matriz <mat> en 3D. Los valores <z> se toman de <mat>,
     las abscisas van desde <x0> hasta <x0> + <width> y las ordenadas
     desde <y0> hasta <y0> + <height>.  El elemento a(1,1) se proyecta
     sobre el punto (x0,y0+height), a(1,n) sobre (x0+width,y0+height),
     a(m,1) sobre (x0,y0) y a(m,n) sobre (x0+width,y0).

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'line_type', 'line_width', 'key', 'wired_surface', 'enhanced3d' y
     'color'.

     En versiones antiguas de Maxima, 'elevation_grid' se llamaba
     'mesh'.  Véase también 'mesh'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) m: apply(
                      matrix,
                      makelist(makelist(random(10.0),k,1,30),i,1,20)) $
          (%i3) draw3d(
                   color = blue,
                   elevation_grid(m,0,0,3,2),
                   xlabel = "x",
                   ylabel = "y",
                   surface_hide = true);

 -- Objeto gráfico: ellipse (<xc>, <yc>, <a>, <b>, <ang1>, <ang2>)
     Dibuja elipses y círculos en 2D.

     2D

     'ellipse (<xc>, <yc>, <a>, <b>, <ang1>, <ang2>)' dibuja una elipse
     de centro '[<xc>, <yc>]' con semiejes horizontal y vertical <a> y
     <b>, respectivamente, comenzando en el ángulo <ang1> y trazando un
     arco de amplitud igual al ángulo <ang2>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'nticks', 'transparent', 'fill_color', 'border', 'line_width',
     'line_type', 'key' y 'color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(transparent = false,
                       fill_color  = red,
                       color       = gray30,
                       transparent = false,
                       line_width  = 5,
                       ellipse(0,6,3,2,270,-270),
                       /* center (x,y), a, b, start & end in degrees */
                       transparent = true,
                       color       = blue,
                       line_width  = 3,
                       ellipse(2.5,6,2,3,30,-90),
                       xrange      = [-3,6],
                       yrange      = [2,9] )$

 -- Objeto gráfico: errors ([<x1>,<x2>,...], [<y1>,<y2>,...])
     Dibuja puntos con barras de error asociadas horizontales,
     verticales o de ambos tipos, según sea el valor de la opción
     'error_type'.

     2D

     Si 'error_type=x', los argumentos a 'errors' deben ser de la forma
     '[x,y,xdelta]' o '[x,y,xlow,xhigh]'.  Si 'error_type=y', los
     argumentos deben ser del tipo '[x,y,ydelta]' o '[x,y,ylow,yhigh]'.
     Si 'error_type=xy' o 'error_type=boxes', los argumentos deben ser
     de la forma '[x,y,xdelta,ydelta]' o '[x,y,xlow,xhigh,ylow,yhigh]'.

     Véase también 'error_type'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'error_type', 'points_joined', 'line_width', 'key', 'line_type',
     'color', 'fill_density', 'xaxis_secondary' y 'yaxis_secondary'.

     La opción 'fill_density' solo es relevante cuando
     'error_type=boxes'.

     Ejemplos:

     Barras de error horizontales.

          (%i1) load(draw)$
          (%i2) draw2d(
                  error_type = y,
                  errors([[1,2,1], [3,5,3], [10,3,1], [17,6,2]]))$

     Barras de error horizontales y verticales.

          (%i1) load(draw)$
          (%i2) draw2d(
                  error_type = xy,
                  points_joined = true,
                  color = blue,
                  errors([[1,2,1,2], [3,5,2,1], [10,3,1,1], [17,6,1/2,2]]));

 -- Objeto gráfico: explicit (<fcn>,<var>,<minval>,<maxval>)
 -- Objeto gráfico: explicit
          (<fcn>,<var1>,<minval1>,<maxval1>,<var2>,<minval2>,<maxval2>)
     Dibuja funciones explícitas en 2D y 3D.

     2D

     'explicit (<fcn>,<var>,<minval>,<maxval>)' dibuja la función
     explícita <fcn>, con la variable <var> tomando valores desde
     <minval> hasta <maxval>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'nticks', 'adapt_depth', 'draw_realpart', 'line_width',
     'line_type', 'key', 'filled_func', 'fill_color' y 'color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(line_width = 3,
                       color      = blue,
                       explicit(x^2,x,-3,3) )$
          (%i3) draw2d(fill_color  = brown,
                       filled_func = true,
                       explicit(x^2,x,-3,3) )$

     3D

     'explicit
     (<fcn>,<var1>,<minval1>,<maxval1>,<var2>,<minval2>,<maxval2>)'
     dibuja la función explícita <fcn>, con la variable 'var1' tomando
     valores desde <minval1> hasta <maxval1> y la variable <var2>
     tomando valores desde <minval2> hasta <maxval2>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'draw_realpart', 'xu_grid', 'yv_grid', 'line_type', 'line_width',
     'key', 'wired_surface', 'enhanced3d' y 'color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(key   = "Gauss",
                       color = "#a02c00",
                       explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3),
                       yv_grid     = 10,
                       color = blue,
                       key   = "Plane",
                       explicit(x+y,x,-5,5,y,-5,5),
                       surface_hide = true)$

     Véase también 'filled_func' para el relleno de curvas.

 -- Objeto gráfico: image (<im>,<x0>,<y0>,<width>,<height>)
     Reproduce una imagen en 2D.

     2D

     'image (<im>,<x0>,<y0>,<width>,<height>)': dibuja la imagen <im> en
     la región rectangular desde el vértice '(<x0>,<y0>)' hasta el
     '(x0+<width>,y0+<height>)' del plano real.  El argumento <im> debe
     ser una matriz de números reales, una matriz de vectores de
     longitud tres o un objeto de tipo 'picture'.

     Si <im> es una matriz de números reales, los valores de los píxeles
     se interpretan según indique la opción gráfica 'palette', que es un
     vector de longitud tres con sus componentes tomando valores enteros
     en el rango desde -36 a +36; cada valor es un índice para
     seleccionar una fórmula que transforma los niveles numéricos en las
     componentes cromáticas rojo, verde y azul:
           0: 0               1: 0.5           2: 1
           3: x               4: x^2           5: x^3
           6: x^4             7: sqrt(x)       8: sqrt(sqrt(x))
           9: sin(90x)       10: cos(90x)     11: |x-0.5|
          12: (2x-1)^2       13: sin(180x)    14: |cos(180x)|
          15: sin(360x)      16: cos(360x)    17: |sin(360x)|
          18: |cos(360x)|    19: |sin(720x)|  20: |cos(720x)|
          21: 3x             22: 3x-1         23: 3x-2
          24: |3x-1|         25: |3x-2|       26: (3x-1)/2
          27: (3x-2)/2       28: |(3x-1)/2|   29: |(3x-2)/2|
          30: x/0.32-0.78125 31: 2*x-0.84
          32: 4x;1;-2x+1.84;x/0.08-11.5
          33: |2*x - 0.5|    34: 2*x          35: 2*x - 0.5
          36: 2*x - 1
     los números negativos se interpretan como colores invertidos de las
     componentes cromáticas.

     'palette = gray' y 'palette = color' son atajos para 'palette =
     [3,3,3]' y 'palette = [7,5,15]', respectivamente.

     Si <im> es una matriz de vectores de longitud tres, éstos se
     interpretarán como las componentes cromáticas rojo, verde y azul.

     Ejemplos:

     Si <im> es una matriz de números reales, los valores de los píxeles
     se interpretan según indique la opción gráfica 'palette'.
          (%i1) load(draw)$
          (%i2) im: apply(
                     'matrix,
                      makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) /* palette = color, default */
                draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(palette = gray, image(im,0,0,30,30))$
          (%i5) draw2d(palette = [15,20,-4],
                       colorbox=false,
                       image(im,0,0,30,30))$

     Véase también 'colorbox'.

     Si <im> es una matriz de vectores de longitud tres, éstos se
     interpretarán como las componentes cromáticas rojo, verde y azul.
          (%i1) load(draw)$
          (%i2) im: apply(
                      'matrix,
                       makelist(
                         makelist([random(300),
                                   random(300),
                                   random(300)],i,1,30),i,1,30))$
          (%i3) draw2d(image(im,0,0,30,30))$

     El paquete 'draw' carga automáticamente el paquete 'picture'.  En
     este ejemplo, una imagen de niveles se define a mano,
     reproduciéndola a continuación.
          (%i1) load(draw)$
          (%i2) im: make_level_picture([45,87,2,134,204,16],3,2);
          (%o2)       picture(level, 3, 2, {Array:  #(45 87 2 134 204 16)})
          (%i3) /* default color palette */
                draw2d(image(im,0,0,30,30))$
          (%i4) /* gray palette */
                draw2d(palette = gray,
                       image(im,0,0,30,30))$

     Se lee un fichero xpm y se reproduce.
          (%i1) load(draw)$
          (%i2) im: read_xpm("myfile.xpm")$
          (%i3) draw2d(image(im,0,0,10,7))$

     Véanse también 'make_level_picture', 'make_rgb_picture' y
     'read_xpm'.

     En <http://www.telefonica.net/web2/biomates/maxima/gpdraw/image> se
     encuentran ejemplos más elaborados.

 -- Objeto gráfico: implicit (<fcn>,<x>,<xmin>,<xmax>,<y>,<ymin>,<ymax>)
 -- Objeto gráfico: implicit
          (<fcn>,<x>,<xmin>,<xmax>,<y>,<ymin>,<ymax>,<z>,<zmin>,<zmax>)
     Dibuja funciones implícitas en 2D y 3D.

     2D

     'implicit (<fcn>,<x>,<xmin>,<xmax>,<y>,<ymin>,<ymax>)' dibuja la
     función implícita <fcn>, con la variable 'x' tomando valores desde
     <xmin> hasta <xmax>, y la variable <y> tomando valores desde <ymin>
     hasta <ymax>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'ip_grid', 'ip_grid_in', 'line_width', 'line_type', 'key' y
     'color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal  = eps,
                       grid      = true,
                       line_type = solid,
                       key       = "y^2=x^3-2*x+1",
                       implicit(y^2=x^3-2*x+1, x, -4,4, y, -4,4),
                       line_type = dots,
                       key       = "x^3+y^3 = 3*x*y^2-x-1",
                       implicit(x^3+y^3 = 3*x*y^2-x-1, x,-4,4, y,-4,4),
                       title     = "Two implicit functions" )$

     3D

     'implicit (<fcn>,<x>,<xmin>,<xmax>, <y>,<ymin>,<ymax>,
     <z>,<zmin>,<zmax>)' dibuja la función implícita <fcn>, con la
     variable <x> tomando valores desde <xmin> hasta <xmax>, la variable
     <y> tomando valores desde <ymin> hasta <ymax> y la variable <z>
     tomando valores desde <zmin> hasta <zmax>.  Este objeto está
     programado con el algoritmo marching cubes.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'x_voxel', 'y_voxel', 'z_voxel', 'line_width', 'line_type', 'key',
     'wired_surface', 'enhanced3d' y 'color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(
                  color=blue,
                  implicit((x^2+y^2+z^2-1)*(x^2+(y-1.5)^2+z^2-0.5)=0.015,
                           x,-1,1,y,-1.2,2.3,z,-1,1),
                  surface_hide=true);

 -- Objeto gráfico: label ([<string>,<x>,<y>],...)
 -- Objeto gráfico: label ([<string>,<x>,<y>,<z>],...)
     Escribe etiquetas en 2D y 3D.

     Las etiquetas coloreadas sólo trabajan con Gnuplot 4.3.  Este es un
     fallo conocido del paquete 'draw'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'label_alignment', 'label_orientation' y 'color'.

     2D

     'label([<string>,<x>,<y>])' escribe la cadena de caracteres
     <string> en el punto '[<x>,<y>]'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(yrange = [0.1,1.4],
                       color = red,
                       label(["Label in red",0,0.3]),
                       color = "#0000ff",
                       label(["Label in blue",0,0.6]),
                       color = light_blue,
                       label(["Label in light-blue",0,0.9],
                             ["Another light-blue",0,1.2])  )$

     3D

     'label([<string>,<x>,<y>,<z>])' escribe la cadena de caracteres
     <string> en el punto '[<x>,<y>,<z>]'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                       color = red,
                       label(["UP 1",-2,0,3], ["UP 2",1.5,0,4]),
                       color = blue,
                       label(["DOWN 1",2,0,-3]) )$

 -- Objeto gráfico: mesh (<fila_1>,<fila_2>,...)
     Dibuja un enrejado cuadrangular en 3D.

     3D

     El argumento <fila_i> es una lista de <n> puntos en 3D de la forma
     '[[x_i1,y_i1,z_i1], ...,[x_in,y_in,z_in]]', siendo todas las filas
     de igual longitud.  Todos estos puntos definen una superficie
     arbitraria en 3D. En cierto sentido, se trata de una generalización
     del objeto 'elevation_grid'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'line_type', 'line_width', 'color', 'key', 'wired_surface',
     'enhanced3d' y 'transform'.

     Ejemplos:

     Un sencillo ejemplo.

          (%i1) load(draw)$
          (%i2) draw3d(
                   mesh([[1,1,3],   [7,3,1],[12,-2,4],[15,0,5]],
                        [[2,7,8],   [4,3,1],[10,5,8], [12,7,1]],
                        [[-2,11,10],[6,9,5],[6,15,1], [20,15,2]])) $

     Dibujando un triángulo en 3D.

          (%i1) load(draw)$
          (%i2) draw3d(
                  line_width = 2,
                  mesh([[1,0,0],[0,1,0]],
                       [[0,0,1],[0,0,1]])) $

     Dos cuadriláteros.

          (%i1) load(draw)$
          (%i2) draw3d(
                  surface_hide = true,
                  line_width   = 3,
                  color = red,
                  mesh([[0,0,0], [0,1,0]],
                       [[2,0,2], [2,2,2]]),
                  color = blue,
                  mesh([[0,0,2], [0,1,2]],
                       [[2,0,4], [2,2,4]])) $

 -- Objeto gráfico: parametric (<xfun>,<yfun>,<par>,<parmin>,<parmax>)
 -- Objeto gráfico: parametric
          (<xfun>,<yfun>,<zfun>,<par>,<parmin>,<parmax>)
     Dibuja funciones paramétricas en 2D y 3D.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'nticks', 'line_width', 'line_type', 'key', 'color' y 'enhanced3d'.

     2D

     'parametric (<xfun>,<yfun>,<par>,<parmin>,<parmax>)' dibuja la
     función paramétrica '[<xfun>,<yfun>]', con el parámetro <par>
     tomando valores desde <parmin> hasta <parmax>.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(x),x,-1,3),
                       color = red,
                       key   = "This is the parametric one!!",
                       parametric(2*cos(rrr),rrr^2,rrr,0,2*%pi))$

     3D

     'parametric (<xfun>,<yfun>,<zfun>,<par>,<parmin>,<parmax>)' dibuja
     la curva paramétrica '[<xfun>,<yfun>,<zfun>]', con el parámetro
     <par> tomando valores desde <parmin> hasta <parmax>.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                       color = royalblue,
                       parametric(cos(5*u)^2,sin(7*u),u-2,u,0,2),
                       color      = turquoise,
                       line_width = 2,
                       parametric(t^2,sin(t),2+t,t,0,2),
                       surface_hide = true,
                       title = "Surface & curves" )$

 -- Objeto gráfico: parametric_surface
          (<xfun>,<yfun>,<zfun>,<par1>,<par1min>,<par1max>,<par2>,<par2min>,<par2max>)
     Dibuja superficies paramétricas en 3D.

     3D

     'parametric_surface
     (<xfun>,<yfun>,<zfun>,<par1>,<par1min>,<par1max>,<par2>,<par2min>,<par2max>)'
     dibuja la superficie paramétrica '[<xfun>,<yfun>,<zfun>]', con el
     parámetro <par1> tomando valores desde <par1min> hasta <par1max> y
     el parámetro <par2> tomando valores desde <par2min> hasta
     <par2max>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'draw_realpart', 'xu_grid', 'yv_grid', 'line_type', 'line_width',
     'key', 'wired_surface', 'enhanced3d' y 'color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(title          = "Sea shell",
                       xu_grid        = 100,
                       yv_grid        = 25,
                       view           = [100,20],
                       surface_hide   = true,
                       parametric_surface(0.5*u*cos(u)*(cos(v)+1),
                                     0.5*u*sin(u)*(cos(v)+1),
                                     u*sin(v) - ((u+3)/8*%pi)^2 - 20,
                                     u, 0, 13*%pi, v, -%pi, %pi) )$

 -- Objeto gráfico: points ([[<x1>,<y1>], [<x2>,<y2>],...])
 -- Objeto gráfico: points ([<x1>,<x2>,...], [<y1>,<y2>,...])
 -- Objeto gráfico: points ([<y1>,<y2>,...])
 -- Objeto gráfico: points ([[<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>],...])
 -- Objeto gráfico: points ([<x1>,<x2>,...], [<y1>,<y2>,...],
          [<z1>,<z2>,...])
 -- Objeto gráfico: points (<matrix>)
 -- Objeto gráfico: points (<1d_y_array>)
 -- Objeto gráfico: points (<1d_x_array>, <1d_y_array>)
 -- Objeto gráfico: points (<1d_x_array>, <1d_y_array>, <1d_z_array>)
 -- Objeto gráfico: points (<2d_xy_array>)
 -- Objeto gráfico: points (<2d_xyz_array>)

     Dibuja puntos en 2D y 3D.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'point_size', 'point_type', 'points_joined', 'line_width', 'key',
     'line_type' y 'color'.  En modo 3D también se ve afectado por
     'enhanced3d'.

     2D

     'points ([[<x1>,<y1>], [<x2>,<y2>],...])' o 'points
     ([<x1>,<x2>,...], [<y1>,<y2>,...])' dibuja los puntos
     '[<x1>,<y1>]', '[<x2>,<y2>]', etc.  Si no se dan las abscisas,
     éstas se asignan automáticamente a enteros positivos consecutivos,
     de forma que 'points([<y1>,<y2>,...])' dibuja los puntos
     '[1,<y1>]', '[2,<y2>]', etc.  Si <matrix> es una matriz de dos
     columnas o de dos filas, 'points (<matrix>)' dibuja los puntos
     asociados.

     Si <1d_y_array> es un array lisp de números en 1D, 'points
     (<1d_y_array>)' los dibujará asignando las abscisas a números
     enteros consecutivos.  'points (<1d_x_array>, <1d_y_array>)' dibuja
     los puntos cuyas coordenadas se toman de los dos arrays pasados
     como argumentos.  Si <2d_xy_array> es un array lisp 2D de dos
     filas, o de dos columnas, 'points (<2d_xy_array>)' dibuja los
     correspondientes puntos del plano.

     Ejemplos:

     Dos tipos de argumentos para 'points', una lista de pares ordenados
     y dos listas con las coordenadas separadas.
          (%i1) load(draw)$
          (%i2) draw2d(
                  key = "Small points",
                  points(makelist([random(20),random(50)],k,1,10)),
                  point_type    = circle,
                  point_size    = 3,
                  points_joined = true,
                  key           = "Great points",
                  points(makelist(k,k,1,20),makelist(random(30),k,1,20)),
                  point_type    = filled_down_triangle,
                  key           = "Automatic abscissas",
                  color         = red,
                  points([2,12,8]))$

     Dibujando impulsos.
          (%i1) load(draw)$
          (%i2) draw2d(
                  points_joined = impulses,
                  line_width    = 2,
                  color         = red,
                  points(makelist([random(20),random(50)],k,1,10)))$

     Array con ordenadas.
          (%i1) load(draw)$
          (%i2) a: make_array (flonum, 100) $
          (%i3) for i:0 thru 99 do a[i]: random(1.0) $
          (%i4) draw2d(points(a)) $

     Dos arrays con coordenadas separadas.
          (%i1) load(draw)$
          (%i2) x: make_array (flonum, 100) $
          (%i3) y: make_array (fixnum, 100) $
          (%i4) for i:0 thru 99 do (
                  x[i]: float(i/100),
                  y[i]: random(10) ) $
          (%i5) draw2d(points(x, y)) $

     Un array 2D de dos columnas.
          (%i1) load(draw)$
          (%i2) xy: make_array(flonum, 100, 2) $
          (%i3) for i:0 thru 99 do (
                  xy[i, 0]: float(i/100),
                  xy[i, 1]: random(10) ) $
          (%i4) draw2d(points(xy)) $

     Dibujando un array rellenado con la función 'read_array'.
          (%i1) load(draw)$
          (%i2) a: make_array(flonum,100) $
          (%i3) read_array (file_search ("pidigits.data"), a) $
          (%i4) draw2d(points(a)) $

     3D

     'points ([[<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>],...])' o 'points
     ([<x1>,<x2>,...], [<y1>,<y2>,...], [<z1>,<z2>,...])' dibuja los
     puntos '[<x1>,<y1>,<z1>]', '[<x2>,<y2>,<z2>]', etc.  Si <matrix> es
     una matriz de tres columnas o de tres filas, 'points (<matrix>)'
     dibuja los puntos asociados.  Si <matrix> es una matriz columna o
     fila, las abscisas se asignan automáticamente.

     En caso de que los argumentos sean arrays lisp, 'points
     (<1d_x_array>, <1d_y_array>, <1d_z_array>)' toma las coordenadas de
     los tres arrays unidimensionales.  Si <2d_xyz_array> es un array 2D
     de tres columnas, o de tres filas, entonces 'points
     (<2d_xyz_array>)' dibuja los puntos correspondientes.

     Ejemplos:

     Una muestra tridimensional,
          (%i1) load(draw)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) draw3d(title = "Daily average wind speeds",
                       point_size = 2,
                       points(args(submatrix (s2, 4, 5))) )$

     Dos muestras tridimensionales,
          (%i1) load(draw)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) draw3d(
                   title = "Daily average wind speeds. Two data sets",
                   point_size = 2,
                   key        = "Sample from stations 1, 2 and 3",
                   points(args(submatrix (s2, 4, 5))),
                   point_type = 4,
                   key        = "Sample from stations 1, 4 and 5",
                   points(args(submatrix (s2, 2, 3))) )$

     Arrays unidimensionales,
          (%i1) load(draw)$
          (%i2) x: make_array (fixnum, 10) $
          (%i3) y: make_array (fixnum, 10) $
          (%i4) z: make_array (fixnum, 10) $
          (%i5) for i:0 thru 9 do (
                  x[i]: random(10),
                  y[i]: random(10),
                  z[i]: random(10) ) $
          (%i6) draw3d(points(x,y,z)) $

     Array bidimensional coloreado,
          (%i1) load(draw)$
          (%i2) xyz: make_array(fixnum, 10, 3) $
          (%i3) for i:0 thru 9 do (
                  xyz[i, 0]: random(10),
                  xyz[i, 1]: random(10),
                  xyz[i, 2]: random(10) ) $
          (%i4) draw3d(
                   enhanced3d = true,
                   points_joined = true,
                   points(xyz)) $

     Números de colores especificados explícitamente por el usuario.
          (%i1) load(draw)$
          (%i2) pts: makelist([t,t^2,cos(t)], t, 0, 15)$
          (%i3) col_num: makelist(k, k, 1, length(pts))$
          (%i4) draw3d(
                  enhanced3d = ['part(col_num,k),k],
                  point_size = 3,
                  point_type = filled_circle,
                  points(pts))$

 -- Objeto gráfico: polar (<radius>,<ang>,<minang>,<maxang>)
     Dibuja funciones 2D definidas en coordenadas polares.

     2D

     'polar (<radius>,<ang>,<minang>,<maxang>)' dibuja la función
     '<radius>(<ang>)' definida en coordenadas polares, con la variable
     <ang> tomando valores desde <minang> hasta <maxang>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'nticks', 'line_width', 'line_type', 'key' y 'color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(user_preamble = "set grid polar",
                       nticks        = 200,
                       xrange        = [-5,5],
                       yrange        = [-5,5],
                       color         = blue,
                       line_width    = 3,
                       title         = "Hyperbolic Spiral",
                       polar(10/theta,theta,1,10*%pi) )$

 -- Objeto gráfico: polygon ([[<x1>,<y1>], [<x2>,<y2>],...])
 -- Objeto gráfico: polygon ([<x1>,<x2>,...], [<y1>,<y2>,...])
     Dibuja polígonos en 2D.

     2D

     'polygon ([[<x1>,<y1>], [<x2>,<y2>],...])' o 'polygon
     ([<x1>,<x2>,...], [<y1>,<y2>,...])': dibuja en el plano un polígono
     de vértices '[<x1>,<y1>]', '[<x2>,<y2>]', etc..

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'transparent', 'fill_color', 'border', 'line_width', 'key',
     'line_type' y 'color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(color      = "#e245f0",
                       line_width = 8,
                       polygon([[3,2],[7,2],[5,5]]),
                       border      = false,
                       fill_color  = yellow,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Objeto gráfico: quadrilateral (<point_1>, <point_2>, <point_3>,
          <point_4>)
     Dibuja un cuadrilátero.

     2D

     'quadrilateral ([<x1>,<y1>], [<x2>,<y2>], [<x3>,<y3>],
     [<x4>,<y4>])' dibuja un cuadrilátero de vértices '[<x1>,<y1>]',
     '[<x2>,<y2>]', '[<x3>,<y3>]' y '[<x4>,<y4>]'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'transparent', 'fill_color', 'border', 'line_width', 'key',
     'xaxis_secondary', 'yaxis_secondary', 'line_type', 'transform' y
     'color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                  quadrilateral([1,1],[2,2],[3,-1],[2,-2]))$

     3D

     'quadrilateral ([<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>],
     [<x3>,<y3>,<z3>], [<x4>,<y4>,<z4>])' dibuja un cuadrilátero de
     vértices '[<x1>,<y1>,<z1>]', '[<x2>,<y2>,<z2>]', '[<x3>,<y3>,<z3>]'
     y '[<x4>,<y4>,<z4>]'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'line_type', 'line_width', 'color', 'key', 'enhanced3d' y
     'transform'.

 -- Objeto gráfico: rectangle ([<x1>,<y1>], [<x2>,<y2>])
     Dibuja rectángulos en 2D.

     2D

     'rectangle ([<x1>,<y1>], [<x2>,<y2>])' dibuja un rectángulo de
     vértices opuestos '[<x1>,<y1>]' y '[<x2>,<y2>]'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'transparent', 'fill_color', 'border', 'line_width', 'key',
     'line_type' y 'color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = red,
                       line_width  = 6,
                       line_type   = dots,
                       transparent = false,
                       fill_color  = blue,
                       rectangle([-2,-2],[8,-1]), /* opposite vertices */
                       transparent = true,
                       line_type   = solid,
                       line_width  = 1,
                       rectangle([9,4],[2,-1.5]),
                       xrange      = [-3,10],
                       yrange      = [-3,4.5] )$

 -- Objeto gráfico: region
          (<expr>,<var1>,<minval1>,<maxval1>,<var2>,<minval2>,<maxval2>)
     Dibuja una región del plano definida por desigualdades.

     2D <expr> es una expresión formada por desigualdades y los
     operadores lógicos 'and', 'or' y 'not'.  La región está acotada por
     el rectángulo definido por [<minval1>, <maxval1>] y [<minval2>,
     <maxval2>].

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'fill_color', 'key', 'x_voxel' y 'y_voxel'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                  x_voxel = 30,
                  y_voxel = 30,
                  region(x^2+y^2<1 and x^2+y^2 > 1/2,
                         x, -1.5, 1.5, y, -1.5, 1.5));

 -- Objeto gráfico: spherical
          (<radius>,<azi>,<minazi>,<maxazi>,<zen>,<minzen>,<maxzen>)
     Dibuja funciones 3D definidas en coordenadas esféricas.

     3D

     'spherical
     (<radius>,<azi>,<minazi>,<maxazi>,<zen>,<minzen>,<maxzen>)' dibuja
     la función '<radius>(<azi>,<zen>)' definida en coordenadas
     esféricas, con el azimut <azi> tomando valores desde <minazi> hasta
     <maxazi> y el zenit <zen> tomando valores desde <minzen> hasta
     <maxzen>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'xu_grid', 'yv_grid', 'line_type', 'key', 'wired_surface',
     'enhanced3d' y 'color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(spherical(1,a,0,2*%pi,z,0,%pi))$

 -- Objeto gráfico: triangle (<punto_1>, <punto_2>, <punto_3>)
     Dibuja un triángulo.

     2D

     'triangle ([<x1>,<y1>], [<x2>,<y2>], [<x3>,<y3>])' dibuja un
     triángulo de vértices '[<x1>,<y1>]', '[<x2>,<y2>]' y '[<x3>,<y3>]'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'transparent', 'fill_color', 'border', 'line_width', 'key',
     'xaxis_secondary', 'yaxis_secondary', 'line_type', 'transform' y
     'color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                  triangle([1,1],[2,2],[3,-1]))$

     3D

     'triangle ([<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>], [<x3>,<y3>,<z3>])'
     dibuja un triángulo de vértices '[<x1>,<y1>,<z1>]',
     '[<x2>,<y2>,<z2>]' y '[<x3>,<y3>,<z3>]'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'line_type', 'line_width', 'color', 'key', 'enhanced3d' y
     'transform'.

 -- Objeto gráfico: tube (<xfun>,<yfun>,<zfun>,<rfun>,<p>,<pmin>,<pmax>)
     Dibuja un tubo en 3D de diámetro variable.

     3D

     '[<xfun>,<yfun>,<zfun>]' es la curva paramétrica de parámetro <p>,
     el cual toma valores entre <pmin> y <pmax>.  Se colocan círculos de
     radio <rfun> con sus centros sobre la curva paramétrica y
     perpendiculares a ella.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'xu_grid', 'yv_grid', 'line_type', 'line_width', 'key',
     'wired_surface', 'enhanced3d', 'color' y 'capping'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(
                  enhanced3d = true,
                  xu_grid    = 50,
                  tube(cos(a), a, 0, cos(a/10)^2,
                       a, 0, 4*%pi) )$

 -- Objeto gráfico: vector ([<x>,<y>], [<dx>,<dy>])
 -- Objeto gráfico: vector ([<x>,<y>,<z>], [<dx>,<dy>,<dz>])
     Dibuja vectores en 2D y 3D.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'head_both', 'head_length', 'head_angle', 'head_type',
     'line_width', 'line_type', 'key' y 'color'.

     2D

     'vector ([<x>,<y>], [<dx>,<dy>])' dibuja el vector '[<dx>,<dy>]'
     con origen en '[<x>,<y>]'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,10],
                       head_length = 1,
                       vector([0,1],[5,5]), /* default type */
                       head_type = 'empty,
                       vector([3,1],[5,5]),
                       head_both = true,
                       head_type = 'nofilled,
                       line_type = dots,
                       vector([6,1],[5,5]))$

     3D

     'vector([<x>,<y>,<z>], [<dx>,<dy>,<dz>])' dibuja el vector
     '[<dx>,<dy>,<dz>]' con origen en '[<x>,<y>,<z>]'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(color = cyan,
                       vector([0,0,0],[1,1,1]/sqrt(3)),
                       vector([0,0,0],[1,-1,0]/sqrt(2)),
                       vector([0,0,0],[1,1,-2]/sqrt(6)) )$


File: maxima.info,  Node: Funciones y variables para picture,  Next: Funciones y variables para worldmap,  Prev: Funciones y variables para draw,  Up: draw

47.3 Funciones y variables para picture
=======================================

 -- Función: get_pixel (<pic>,<x>,<y>)
     Devuelve el pixel de la imagen <pic>.  Las coordenadas <x> e <y>
     van desde 0 hasta 'ancho-1' y 'alto-1', respectivamente.

 -- Función: make_level_picture (<data>)
 -- Función: make_level_picture (<data>,<width>,<height>)
     Devuelve un objeto 'picture' consistente en una imagen de niveles.
     'make_level_picture (<data>)' construye el objeto 'picture' a
     partir de la matriz <data>.  'make_level_picture
     (<data>,<width>,<height>)' construye el objeto a partir de una
     lista de números, en cuyo caso deben indicarse el ancho <width> y
     la altura <height> en píxeles.

     El objeto 'picture' devuelto contiene los siguientes cuatro
     elemento:

       1. el símbolo 'level'
       2. anchura de la imagen
       3. altura de la imagen
       4. un array de enteros con los valores de los píxeles entre 0 y
          255.  El argumento <data> debe contener sólo números entre 0 y
          255; los cantidades negativas se transforman en ceros y las
          que son mayores de 255 se igualan a este número.

     Ejemplo:

     Imagen de niveles a partir de una matriz.
          (%i1) load(draw)$
          (%i2) make_level_picture(matrix([3,2,5],[7,-9,3000]));
          (%o2)         picture(level, 3, 2, {Array:  #(3 2 5 7 0 255)})

     Imagen de niveles a partir de una lista numérica.
          (%i1) load(draw)$
          (%i2) make_level_picture([-2,0,54,%pi],2,2);
          (%o2)            picture(level, 2, 2, {Array:  #(0 0 54 3)})

 -- Función: make_rgb_picture (<redlevel>,<greenlevel>,<bluelevel>)
     Devuelve un objeto <picture> conteniendo una imagen en color (RGB).
     Los tres argumentos deben ser imágenes de niveles, para el rojo
     (R), verde (G) y azul (B).

     El objeto <picture> devuelto contiene los siguientes cuatro
     elemento:

       1. el símbolo 'rgb'
       2. anchura de la imagen
       3. altura de la imagen
       4. un array de enteros de <3*ancho*alto> con los valores de los
          píxeles entre 0 y 255.  Cada valor de pixel se representa en
          el array con tres números consecutivos (rojo, verde, azul).

     Ejemplo:

          (%i1) load(draw)$
          (%i2) red: make_level_picture(matrix([3,2],[7,260]));
          (%o2)           picture(level, 2, 2, {Array:  #(3 2 7 255)})
          (%i3) green: make_level_picture(matrix([54,23],[73,-9]));
          (%o3)           picture(level, 2, 2, {Array:  #(54 23 73 0)})
          (%i4) blue: make_level_picture(matrix([123,82],[45,32.5698]));
          (%o4)          picture(level, 2, 2, {Array:  #(123 82 45 33)})
          (%i5) make_rgb_picture(red,green,blue);
          (%o5) picture(rgb, 2, 2,
                        {Array:  #(3 54 123 2 23 82 7 73 45 255 0 33)})

 -- Función: negative_picture (<pic>)
     Devuelve el negativo de la imagen, sea ésta de tipo nivel (<level>)
     o color (<rgb>).

 -- Función: picture_equalp (<x>,<y>)
     Devuelve 'true' si los dos argumentos son imágenes idénticas, o
     'false' en caso contrario.

 -- Función: picturep (<x>)
     Devuelve 'true' si el argumento es una imagen bien formada, o
     'false' en caso contrario.

 -- Función: read_xpm (<xpm_file>)
     Lee el fichero gráfico en formato xpm y devuelve un objeto
     'picture'.

 -- Función: rgb2level (<pic>)
     Transforma una imagen en color <rgb> a otra de niveles <level>
     promediando los niveles.

 -- Función: take_channel (<im>,<color>)
     Si el argumento <color> es 'red', 'green' o 'blue', la función
     'take_channel' devuelve el canal de color correspondiente de la
     imagen <im>.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) red: make_level_picture(matrix([3,2],[7,260]));
          (%o2)           picture(level, 2, 2, {Array:  #(3 2 7 255)})
          (%i3) green: make_level_picture(matrix([54,23],[73,-9]));
          (%o3)           picture(level, 2, 2, {Array:  #(54 23 73 0)})
          (%i4) blue: make_level_picture(matrix([123,82],[45,32.5698]));
          (%o4)          picture(level, 2, 2, {Array:  #(123 82 45 33)})
          (%i5) make_rgb_picture(red,green,blue);
          (%o5) picture(rgb, 2, 2,
                        {Array:  #(3 54 123 2 23 82 7 73 45 255 0 33)})
          (%i6) take_channel(%,'green);  /* simple quote!!! */
          (%o6)           picture(level, 2, 2, {Array:  #(54 23 73 0)})


File: maxima.info,  Node: Funciones y variables para worldmap,  Prev: Funciones y variables para picture,  Up: draw

47.4 Funciones y variables para worldmap
========================================

Este paquete carga automáticamente el paquete 'draw'.

47.4.1 Variables y Funciones
----------------------------

 -- Global variable: boundaries_array
     Valor por defecto: 'false'

     'boundaries_array' es donde el objeto gráfico 'geomap' lee las
     coordenadas de las líneas fronterizas.

     Cada componente de 'boundaries_array' es un array de números
     decimales en coma flotante representando las coordenadas que
     definen un segmento poligonal o línea fronteriza.

     Véase también 'geomap'.

 -- Función: numbered_boundaries (<nlist>)
     Dibuja una lista de segmentos poligonales (líneas fronterizas),
     etiquetadas con sus números correspondientes (coordenadas de
     'boundaries_array').  Esta función es de mucha ayuda a la hora de
     definir nuevas entidades geográficas.

     Ejemplo:

     Mapa de Europa con las fronteras y costas etiquetadas con su
     componente numérica de 'boundaries_array'.
          (%i1) load(worldmap)$
          (%i2) european_borders:
                     region_boundaries(-31.81,74.92,49.84,32.06)$
          (%i3) numbered_boundaries(european_borders)$

 -- Función: make_poly_continent (<continent_name>)
 -- Función: make_poly_continent (<country_list>)
     Construye los polígonos necesarios para dibujar un continente o
     lista de países coloreados.

     Ejemplo:

          (%i1) load(worldmap)$
          (%i2) /* A continent */
                make_poly_continent(Africa)$
          (%i3) apply(draw2d, %)$
          (%i4) /* A list of countries */
                make_poly_continent([Germany,Denmark,Poland])$
          (%i5) apply(draw2d, %)$

 -- Función: make_poly_country (<country_name>)
     Construye los polígonos necesarios para dibujar un país coloreado.
     En caso de contener islas, un país tendrá asociados varios
     polígonos.

     Ejemplo:

          (%i1) load(worldmap)$
          (%i2) make_poly_country(India)$
          (%i3) apply(draw2d, %)$

 -- Función: make_polygon (<nlist>)
     Devuelve un objeto 'polygon' a partie de una lista de líneas
     fronterizas y de costas.  El argumento <nlist> debe ser una lista
     de componentes de 'boundaries_array'.

     Ejemplo:

     La variable Bhutan (Bután) está definida con los números
     fronterizos 171, 173 y 1143, de manera que
     'make_polygon([171,173,1143])' concatena los arrays
     'boundaries_array[171]', 'boundaries_array[173]' y
     'boundaries_array[1143]' y devuelve un objeto 'polygon' apto para
     ser dibujado por 'draw'.  A fin de evitar mensajes de errores, los
     arrays deben ser compatibles en el sentido de que dos de ellos
     consecutivos deben tener dos coordenadas comunes en los extremos.
     En este ejemplo, las dos primeras componentes de
     'boundaries_array[171]' son iguales a las dos últimas de
     'boundaries_array[173]', y las dos primeras de
     'boundaries_array[173]' coinciden con las dos primeras de
     'boundaries_array[1143]'; en conclusión, los números de segmentos
     poligonales171, 173 y 1143 (en este orden) son compatibles y el
     polígono coloreado se podrá dibujar.
          (%i1) load(worldmap)$
          (%i2) Bhutan;
          (%o2)                        [[171, 173, 1143]]
          (%i3) boundaries_array[171];
          (%o3) {Array:
                 #(88.750549 27.14727 88.806351 27.25305 88.901367 27.282221
                   88.917877 27.321039)}
          (%i4) boundaries_array[173];
          (%o4) {Array:
                 #(91.659554 27.76511 91.6008 27.66666 91.598022 27.62499
                   91.631348 27.536381 91.765533 27.45694 91.775253 27.4161
                   92.007751 27.471939 92.11441 27.28583 92.015259 27.168051
                   92.015533 27.08083 92.083313 27.02277 92.112183 26.920271
                   92.069977 26.86194 91.997192 26.85194 91.915253 26.893881
                   91.916924 26.85416 91.8358 26.863331 91.712479 26.799999
                   91.542191 26.80444 91.492188 26.87472 91.418854 26.873329
                   91.371353 26.800831 91.307457 26.778049 90.682457 26.77417
                   90.392197 26.903601 90.344131 26.894159 90.143044 26.75333
                   89.98996 26.73583 89.841919 26.70138 89.618301 26.72694
                   89.636093 26.771111 89.360786 26.859989 89.22081 26.81472
                   89.110237 26.829161 88.921631 26.98777 88.873016 26.95499
                   88.867737 27.080549 88.843307 27.108601 88.750549
                   27.14727)}
          (%i5) boundaries_array[1143];
          (%o5) {Array:
                 #(91.659554 27.76511 91.666924 27.88888 91.65831 27.94805
                   91.338028 28.05249 91.314972 28.096661 91.108856 27.971109
                   91.015808 27.97777 90.896927 28.05055 90.382462 28.07972
                   90.396088 28.23555 90.366074 28.257771 89.996353 28.32333
                   89.83165 28.24888 89.58609 28.139999 89.35997 27.87166
                   89.225517 27.795 89.125793 27.56749 88.971077 27.47361
                   88.917877 27.321039)}
          (%i6) Bhutan_polygon: make_polygon([171,173,1143])$
          (%i7) draw2d(Bhutan_polygon)$

 -- Función: region_boundaries (<x1>,<y1>,<x2>,<y2>)
     Detecta los segmentos poligonales almacenados en la variable global
     'boundaries_array' totalmente contenidos en el rectángulo de
     vértices (<x1>,<y1>) -superior izquierdo- y (<x2>,<y2>) -inferior
     derecho-.

     Ejemplo:

     Devuelve los números de los segmentos necesarios para dibujar el
     sur de Italia.
          (%i1) load(worldmap)$
          (%i2) region_boundaries(10.4,41.5,20.7,35.4);
          (%o2)                [1846, 1863, 1864, 1881, 1888, 1894]
          (%i3) draw2d(geomap(%))$

 -- Función: region_boundaries_plus (<x1>,<y1>,<x2>,<y2>)
     Detecta los segmentos poligonales almacenados en la variable global
     'boundaries_array' con al menos un vértice dentro del rectángulo
     definido por los extremos (<x1>,<y1>) -superior izquierdo- y
     (<x2>,<y2>) -inferior derecho-.

     Ejemplo:

          (%i1) load(worldmap)$
          (%i2) region_boundaries_plus(10.4,41.5,20.7,35.4);
          (%o2) [1060, 1062, 1076, 1835, 1839, 1844, 1846, 1858,
                 1861, 1863, 1864, 1871, 1881, 1888, 1894, 1897]
          (%i3) draw2d(geomap(%))$

47.4.2 Objetos gráficos
-----------------------

 -- Objeto gráfico: geomap (<numlist>)
 -- Objeto gráfico: geomap (<numlist>,<3Dprojection>)
     Dibuja mapas cartográficos en 2D y 3D.

     2D

     Esta función trabaja junto con la variable global
     'boundaries_array'.

     El argumento <numlist> es una lista de números o de listas de
     números.  Todos estos números deben ser enteros mayores o iguales
     que cero, representando las componentes del array global
     'boundaries_array'.

     Cada componente de 'boundaries_array' es un array de decimales en
     coma flotante, las coordenadas de un segmento poligonal o línea
     fronteriza.

     'geomap (<numlist>)' toma los enteros de sus argumentos y dibuja
     los segmentos poligonales asociados de 'boundaries_array'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     'line_width', 'line_type' y 'color'.

     Ejemplos:

     Un sencillo mapa hecho a mano:
          (%i1) load(worldmap)$
          (%i2) /* Vertices of boundary #0: {(1,1),(2,5),(4,3)} */
             ( bnd0: make_array(flonum,6),
               bnd0[0]:1.0, bnd0[1]:1.0, bnd0[2]:2.0,
               bnd0[3]:5.0, bnd0[4]:4.0, bnd0[5]:3.0 )$
          (%i3) /* Vertices of boundary #1: {(4,3),(5,4),(6,4),(5,1)} */
             ( bnd1: make_array(flonum,8),
               bnd1[0]:4.0, bnd1[1]:3.0, bnd1[2]:5.0, bnd1[3]:4.0,
               bnd1[4]:6.0, bnd1[5]:4.0, bnd1[6]:5.0, bnd1[7]:1.0)$
          (%i4) /* Vertices of boundary #2: {(5,1), (3,0), (1,1)} */
             ( bnd2: make_array(flonum,6),
               bnd2[0]:5.0, bnd2[1]:1.0, bnd2[2]:3.0,
               bnd2[3]:0.0, bnd2[4]:1.0, bnd2[5]:1.0 )$
          (%i5) /* Vertices of boundary #3: {(1,1), (4,3)} */
             ( bnd3: make_array(flonum,4),
               bnd3[0]:1.0, bnd3[1]:1.0, bnd3[2]:4.0, bnd3[3]:3.0)$
          (%i6) /* Vertices of boundary #4: {(4,3), (5,1)} */
             ( bnd4: make_array(flonum,4),
               bnd4[0]:4.0, bnd4[1]:3.0, bnd4[2]:5.0, bnd4[3]:1.0)$
          (%i7) /* Pack all together in boundaries_array */
             ( boundaries_array: make_array(any,5),
               boundaries_array[0]: bnd0, boundaries_array[1]: bnd1,
               boundaries_array[2]: bnd2, boundaries_array[3]: bnd3,
               boundaries_array[4]: bnd4 )$
          (%i8) draw2d(geomap([0,1,2,3,4]))$

     El paquete auxiliar 'worldmap' asigna al array global
     'boundaries_array' líneas fronterizas reales en coordenadas
     (longitud, latitud).  Estos datos son de dominio público y proceden
     de <http://www-cger.nies.go.jp/grid-e/gridtxt/grid19.html>.  El
     paquete 'worldmap' también define fronteras de países, continentes
     y líneas costeras a partir de las componentes de 'boundaries_array'
     (véase el fichero 'share/draw/worldmap.mac' para más información).
     El paquete 'worldmap' carga automáticamente el paquete 'draw'.
          (%i1) load(worldmap)$
          (%i2) c1: gr2d(geomap([Canada,United_States,
                                 Mexico,Cuba]))$
          (%i3) c2: gr2d(geomap(Africa))$
          (%i4) c3: gr2d(geomap([Oceania,China,Japan]))$
          (%i5) c4: gr2d(geomap([France,Portugal,Spain,
                                 Morocco,Western_Sahara]))$
          (%i6) draw(columns  = 2,
                     c1,c2,c3,c4)$

     'worldmap' se puede utilizar para dibujar países como polígonos.
     En este caso, ya no será necesario hacer uso del objeto gráfico
     'geomap', pero sí de 'polygon'.  Puesto que en este caso se
     utilizan listas en lugar de arrays, los mapas se reproducirán de
     forma más lenta.  Véanse también 'make_poly_country' y
     'make_poly_continent' para comprender el siguiente código.
          (%i1) load(worldmap)$
          (%i2) mymap: append(
             [color      = white],  /* borders are white */
             [fill_color = red],             make_poly_country(Bolivia),
             [fill_color = cyan],            make_poly_country(Paraguay),
             [fill_color = green],           make_poly_country(Colombia),
             [fill_color = blue],            make_poly_country(Chile),
             [fill_color = "#23ab0f"],       make_poly_country(Brazil),
             [fill_color = goldenrod],       make_poly_country(Argentina),
             [fill_color = "midnight-blue"], make_poly_country(Uruguay))$
          (%i3) apply(draw2d, mymap)$

     3D

     'geomap (<numlist>)' proyecta los mapas sobre la esfera de radio 1
     y centro (0,0,0).  Es posible cambiar la esfera o el tipo de
     proyección haciendo uso de 'geomap (<numlist>,<3Dprojection>)'.

     Proyecciones 3D disponibles:

        * '[spherical_projection,<x>,<y>,<z>,<r>]': proyecta los mapas
          sobre la esfera de radio <r> y centro (<x>,<y>,<z>).
               (%i1) load(worldmap)$
               (%i2) draw3d(geomap(Australia), /* default projection */
                            geomap(Australia,
                                   [spherical_projection,2,2,2,3]))$

        * '[cylindrical_projection,<x>,<y>,<z>,<r>,<rc>]': re-proyecta
          mapas esféricos sobre el cilindro de radio <rc> cuyo eje pasa
          a través de los polos del globo de radio <r> y centro
          (<x>,<y>,<z>).
               (%i1) load(worldmap)$
               (%i2) draw3d(geomap([America_coastlines,Eurasia_coastlines],
                                   [cylindrical_projection,2,2,2,3,4]))$

        * '[conic_projection,<x>,<y>,<z>,<r>,<alpha>]': re-proyecta
          mapas esféricos sobre los conos de ángulo <alpha>, cuyos ejes
          pasan a través de los polos del globo de radio <r> y centro
          (<x>,<y>,<z>).  Ambos conos, norte y sur, son tangentes a la
          esfera.
               (%i1) load(worldmap)$
               (%i2) draw3d(geomap(World_coastlines,
                                   [conic_projection,0,0,0,1,90]))$

     En <http://riotorto.users.sf.net/gnuplot/geomap> hay ejemplos más
     elaborados.


File: maxima.info,  Node: drawdf,  Next: dynamics,  Prev: draw,  Up: Top

48 drawdf
*********

* Menu:

* Introducción a drawdf::
* Funciones y variables para drawdf::


File: maxima.info,  Node: Introducción a drawdf,  Next: Funciones y variables para drawdf,  Prev: drawdf,  Up: drawdf

48.1 Introducción a drawdf
==========================

La función 'drawdf' dibuja el campo de direcciones de una ecuación
diferencial ordinaria de primer orden (EDO) o de un sistema de dos
ecuaciones autónomas de primer orden.

Puesto que 'drawdf' es un paquete adicional, es necesario cargarlo en
memoria ejecutando previamente la instrucción 'load(drawdf)'.  'drawdf'
utiliza el paquete 'draw', que necesita como mínimo la versión 4.2 de
Gnuplot.

Para dibujar el campo de direcciones de una EDO, ésta debe escribirse de
la forma
            dy
            -- = F(x,y)
            dx

y ser la función <F> la que se pase a 'drawdf' como argumento.  Si las
variables independiente y dependiente no son <x> e <y>, como en la
ecuación anterior, entonces deben nombrarse de forma explícita en una
lista que se pasará a 'drawdf' (ver ejemplos más abajo).

Para dibujar el campo de direcciones de un conjunto de dos EDOs
autónomas, deben escribirse de la forma
            dx             dy
            -- = G(x,y)    -- = F(x,y)
            dt             dt

y será una lista con las dos funciones <G> y <F> la que se pase a
'drawdf' como argumento.  El orden de las funciones es importante; la
primera será la derivada de la abscisa respecto del tiempo y la segunda
la derivada de la ordenada respecto del tiempo.  Si las variables no son
las <x> e <y> habituales, el segundo argumento que se pase a la función
'drawdf' será una lista con los nombres de ambas variables, primero la
correspondiente a las abscisas, seguida de la asociada a las ordenadas.

Si sólo se trata de una EDO, 'drawdf' admitirá por defecto que 'x=t' y
'G(x,y)=1', transformanado la ecuación no autónoma en un sistema de dos
ecuaciones autónomas.


File: maxima.info,  Node: Funciones y variables para drawdf,  Prev: Introducción a drawdf,  Up: drawdf

48.2 Funciones y variables para drawdf
======================================

48.2.1 Funciones
----------------

 -- Función: drawdf (<dydx>, ...options and objects...)
 -- Función: drawdf (<dvdu>, '['<u>,<v>']', ...opciones y objetos...)
 -- Función: drawdf (<dvdu>, '['<u>,<umin>,<umax>']',
          '['<v>,<vmin>,<vmax>']', ...opciones y objetos...)
 -- Función: drawdf ('['<dxdt>,<dydt>']', ...opciones y objetos...)
 -- Función: drawdf ('['<dudt>,<dvdt>']', '['<u>,<v>']', ...opciones y
          objetos...)
 -- Función: drawdf ('['<dudt>,<dvdt>']', '['<u>,<umin>,<umax>']',
          '['<v>,<vmin>,<vmax>']', ...opciones y objetos...)

     La función 'drawdf' dibuja un campo de direcciones 2D, incluyendo
     opcionalmente curvas asociadas a soluciones particulares, así como
     otros objeto gráficos del paquete 'draw'.

     El primer argumento especifica la(s) derivada(s), el cual debe
     estar formado por una expresión o una lista de dos expresiones.
     <dydx>, <dxdt> y <dydt> son expresiones que dependen de <x> y <y>.
     <dvdu>, <dudt> y <dvdt> son expresiones que dependen de <u> y <v>.

     Si las variables independiente y dependiente no son <x> e <y>, sus
     nombres deben especificarse a continuación de las derivadas, bien
     como una lista de dos nombres, '['<u>,<v>']', o como dos listas de
     la forma '['<u>,<umin>,<umax>']' y '['<v>,<vmin>,<vmax>']'.

     El resto de argumentos son opciones gráficas, objetos gráficos, o
     listas conteniendo elementos de ambos tipos.  El conjunto de
     opciones y objetos gráficos soportados por 'drawdf' incluye los
     soportados por 'draw2d' y 'gr2d' del paquete 'draw'.

     Los argumentos se iterpretan secuencialmente: las opciones gráficas
     afectan a todos los objetos gráficos que le siguen.  Además, los
     objetos gráficos se dibujan en el orden en el que se especifican,
     pudiendo tapar otros gráficos dibujados con anterioridad.  Algunas
     opciones gráficas afectan al aspecto general de la escena.

     Los nuevos objetos gráficos que se definen en 'drawdf' son:
     'solns_at', 'points_at', 'saddles_at', 'soln_at', 'point_at' y
     'saddle_at'.

     Las nuevas opciones gráficas que se definen en 'drawdf' son:
     'field_degree', 'soln_arrows', 'field_arrows', 'field_grid',
     'field_color', 'show_field', 'tstep', 'nsteps', 'duration',
     'direction', 'field_tstep', 'field_nsteps' y 'field_duration'.

     Objetos gráficos que se heredan del paquete 'draw' incluyen:
     'explicit', 'implicit', 'parametric', 'polygon', 'points',
     'vector', 'label' y cualesquiera otros soportados por 'draw2d' y
     'gr2d'.

     Opciones gráficas que se heredan del paquete 'draw' incluyen:
     'points_joined', 'color', 'point_type', 'point_size', 'line_width',
     'line_type', 'key', 'title', 'xlabel', 'ylabel', 'user_preamble',
     'terminal', 'dimensions', 'file_name' y cualesquiera otros
     soportados por 'draw2d' y 'gr2d'.

     Véase también 'draw2d'.

     Los usuarios de wxMaxima y Imaxima pueden hacer uso también
     'wxdrawdf', que es idéntica a 'drawdf', pero que inserta el gráfico
     en el propio documento utilizando la función 'wxdraw'.

     Para hacer uso de esta función, ejecútese primero 'load(drawdf)'.

     Ejemplos:

          (%i1) load(drawdf)$
          (%i2) drawdf(exp(-x)+y)$        /* default vars: x,y */
          (%i3) drawdf(exp(-t)+y, [t,y])$ /* default range: [-10,10] */
          (%i4) drawdf([y,-9*sin(x)-y/5], [x,1,5], [y,-2,2])$

     A efectos de compatibilidad, 'drawdf' acepta la mayor parte de
     parámetros soportados por 'plotdf'.

          (%i5) drawdf(2*cos(t)-1+y, [t,y], [t,-5,10], [y,-4,9],
                       [trajectory_at,0,0])$

     'soln_at' y 'solns_at' dibujan soluciones particulares que pasen
     por los puntos especificados, utilizando el integrador numérico de
     Runge Kutta de cuarto orden.

          (%i6) drawdf(2*cos(t)-1+y, [t,-5,10], [y,-4,9],
                       solns_at([0,0.1],[0,-0.1]),
                       color=blue, soln_at(0,0))$

     'field_degree=2' hace que el campo se componga de splines
     cuadráticos basados en las derivadas de primer y segundo orden en
     cada punto de la malla.  'field_grid=['<COLS>,<ROWS>']' especifica
     el número de columnas y filas a utilizar en la malla.

          (%i7) drawdf(2*cos(t)-1+y, [t,-5,10], [y,-4,9],
                       field_degree=2, field_grid=[20,15],
                       solns_at([0,0.1],[0,-0.1]),
                       color=blue, soln_at(0,0))$

     'soln_arrows=true' añade flechas a las soluciones particulares y,
     por defecto, las borra.  También cambia los colores por defecto
     para destacar las curvas de las soluciones particulares.

          (%i8) drawdf(2*cos(t)-1+y, [t,-5,10], [y,-4,9],
                       soln_arrows=true,
                       solns_at([0,0.1],[0,-0.1],[0,0]))$

     'duration=40' especifica el intervalo temporal de la integración
     numérica, cuyo valor por defecto es 10.  La integración se detendrá
     automáticamente si la solución se aparta mucho de la región a
     dibujar, o si la derivada se vuelve compleja o infinita.  Aquí
     también hacemos 'field_degree=2' para dibujar splines cuadráticos.
     Las ecuaciones de este ejemplo modelizan un sistema
     depredador-presa.

          (%i9) drawdf([x*(1-x-y), y*(3/4-y-x/2)], [x,0,1.1], [y,0,1],
                       field_degree=2, duration=40,
                       soln_arrows=true, point_at(1/2,1/2),
                       solns_at([0.1,0.2], [0.2,0.1], [1,0.8], [0.8,1],
                                [0.1,0.1], [0.6,0.05], [0.05,0.4],
                                [1,0.01], [0.01,0.75]))$

     'field_degree='solns' hace que el campo se componga de muchas
     pequeñas soluciones calculadas a partir del Runge Kutta de cuarto
     orden.

          (%i10) drawdf([x*(1-x-y), y*(3/4-y-x/2)], [x,0,1.1], [y,0,1],
                        field_degree='solns, duration=40,
                        soln_arrows=true, point_at(1/2,1/2),
                        solns_at([0.1,0.2], [0.2,0.1], [1,0.8],
                                 [0.8,1], [0.1,0.1], [0.6,0.05],
                                 [0.05,0.4], [1,0.01], [0.01,0.75]))$

     'saddles_at' trata de linearizar automáticamente la ecuación en
     cada punto de silla y dibujar la solución numérica correspondiente
     a cada vector propio, incluyendo las separatrices.  'tstep=0.05'
     establece el salto temporal máximo para el integrador numérico,
     cuyo valor por defecto es 0.1.  Las siguientes ecuaciones modelizan
     un péndulo amortiguado.

          (%i11) drawdf([y,-9*sin(x)-y/5], tstep=0.05,
                        soln_arrows=true, point_size=0.5,
                        points_at([0,0], [2*%pi,0], [-2*%pi,0]),
                        field_degree='solns,
                        saddles_at([%pi,0], [-%pi,0]))$

     'show_field=false' elimina el campo completamente.

          (%i12) drawdf([y,-9*sin(x)-y/5], tstep=0.05,
                        show_field=false, soln_arrows=true,
                        point_size=0.5,
                        points_at([0,0], [2*%pi,0], [-2*%pi,0]),
                        saddles_at([3*%pi,0], [-3*%pi,0],
                                   [%pi,0], [-%pi,0]))$

     'drawdf' pasa todos los parámetros que no reconoce a 'draw2d' o
     'gr2d', permitiendo combinar la potencia del paquete 'draw' con
     'drawdf'.

          (%i13) drawdf(x^2+y^2, [x,-2,2], [y,-2,2], field_color=gray,
                        key="soln 1", color=black, soln_at(0,0),
                        key="soln 2", color=red, soln_at(0,1),
                        key="isocline", color=green, line_width=2,
                        nticks=100, parametric(cos(t),sin(t),t,0,2*%pi))$

     'drawdf' acepta listas anidadas de opciones y objetos gráficos,
     permitiendo el uso de 'makelist' y otras funciones de forma más
     flexible para generar gráficos.

          (%i14) colors : ['red,'blue,'purple,'orange,'green]$
          (%i15) drawdf([x-x*y/2, (x*y - 3*y)/4],
                        [x,2.5,3.5], [y,1.5,2.5],
                        field_color = gray,
                        makelist([ key   = concat("soln",k),
                                   color = colors[k],
                                   soln_at(3, 2 + k/20) ],
                                 k,1,5))$


File: maxima.info,  Node: dynamics,  Next: ezunits,  Prev: drawdf,  Up: Top

49 dynamics
***********

* Menu:

* El paquete dynamics::
* Análisis gráfico de sistemas dinámicos discretos::
* Visualización usando VTK::


File: maxima.info,  Node: El paquete dynamics,  Next: Análisis gráfico de sistemas dinámicos discretos,  Prev: dynamics,  Up: dynamics

49.1 El paquete dynamics
========================

El paquete adicional 'dynamics' incluye funciones para visualización 3D,
animaciones, análisis gráfico de ecuaciones diferenciales y ecuaciones
de diferencias y para resolución numérica de ecuaciones diferenciales.
Las funciones para ecuaciones diferenciales se describen en la sección
sobre 'Métodos numéricos' y las funciones para representar las gráficas
de los conjuntos de Mandelbrot y de Julia se describen en la sección
sobre 'Gráficos'.

Todas las funciones en este paquete se cargan automáticamente la primera
vez que se usan.


File: maxima.info,  Node: Análisis gráfico de sistemas dinámicos discretos,  Next: Visualización usando VTK,  Prev: El paquete dynamics,  Up: dynamics

49.2 Análisis gráfico de sistemas dinámicos discretos
=====================================================

 -- Función: chaosgame ([[<x1>, <y1>]...[<xm>, <ym>]], [<x0>, <y0>],
          <b>, <n>, <opciones>, ...);

     Usa el método llamado juego del caos, para producir fractales: se
     dibuja un punto inicial (<x0>, <y0>) y luego se elije
     aleatoriamente uno de los <m> puntos '['<x1>, <y1>']'...'['<xm>,
     <ym>']'.  Después se dibuja un nuevo punto que estará en el
     segmento entre el último punto dibujado y el punto que se acabó de
     elegir aleatoriamente, a una distancia del punto elegido que será
     <b> veces la longitud del segmento.  El proceso se repite <n>
     veces.  Este programa acepta las mismas opciones de 'plot2d'.

     *Ejemplo*.  Gráfico del triángulo de Sierpinsky:

          (%i1) chaosgame([[0, 0], [1, 0], [0.5, sqrt(3)/2]], [0.1, 0.1], 1/2,
                           30000, [style, dots]);

 -- Función: evolution evolution (<F>, <y0>, <n>, ..., <opciones>, ...);

     Dibuja <n+1> puntos en una gráfica bidimensional (serie de tiempo),
     en que las coordenadas horizontales de los puntos son los números
     enteros 0, 1, 2, ..., <n>, y las coordenadas verticales son los
     valores <y(n)> correspondientes, obtenidos a partir de la relación
     de recurrencia
                  y(n+1) = F(y(n))

     Con valor inicial <y(0)> igual a <y0>.  <F> deberá ser una
     expresión que dependa únicamente de la variable <y> (y no de <n>),
     <y0> deberá ser un número real y <n> un número entero positivo.
     Esta función acepta las mismas opciones que 'plot2d'.

     *Ejemplo*.

          (%i1) evolution(cos(y), 2, 11);

 -- Función: evolution2d ([<F>, <G>], [<u>, <v>], [<u0>, <y0>], <n>,
          <opciones>, ...);

     Muestra, en una gráfica bidimensional, los primeros <n+1> puntos de
     la sucesión definida a partir del sistema dinámico discreto con
     relaciones de recurrencia:
                  x(n+1) = F(x(n), y(n))    y(n+1) = G(x(n), y(n))

     Con valores iniciales <x0> y <y0>.  <F> y <G> deben ser dos
     expresiones que dependan únicamente de <x> y <y>.  Esta función
     acepta las mismas opciones que 'plot2d'.

     *Ejemplo*.  Evolución de un sistema dinámico discreto en dos
     dimensiones:

          (%i1) f: 0.6*x*(1+2*x)+0.8*y*(x-1)-y^2-0.9$
          (%i2) g: 0.1*x*(1-6*x+4*y)+0.1*y*(1+9*y)-0.4$
          (%i3) evolution2d([f,g], [x,y], [-0.5,0], 50000, [style,dots]);

     Y un acercamiento de una pequeña región en ese fractal:

          (%i9) evolution2d([f,g], [x,y], [-0.5,0], 300000, [x,-0.8,-0.6],
                            [y,-0.4,-0.2], [style, dots]);

 -- Función: ifs ([<r1>, ..., <rm>], [<A1>,..., <Am>], [[<x1>, <y1>],
          ..., [<xm>, <ym>]], [<x0>, <y0>], <n>, <opciones>, ...);

     Usa el método del Sistema de Funciones Iteradas (IFS, en inglés
     Iterated Function System).  Ese método es semejante al método
     descrito en la función 'chaosgame'.  pero en vez de aproximar el
     último punto al punto elegido aleatoriamente, las dos coordenadas
     del último punto se multiplican por una matriz 2 por 2 <Ai>
     correspondiente al punto que fue elegido aleatoriamente.

     La selección aleatoria de uno de los <m> puntos atractivos puede
     ser realizada con una función de probabilidad no uniforme, definida
     con los pesos <r1>,...,<rm>.  Esos pesos deben ser dados en forma
     acumulada; por ejemplo, si se quieren 3 puntos con probabilidades
     0.2, 0.5 y 0.3, los pesos <r1>, <r2> y <r3> podrían ser 2, 7 y 10,
     o cualquier otro grupo de números que tengan la misma proporción.
     Esta función acepta las mismas opciones que 'plot2d'.

     *Ejemplo*.  El helecho de Barnsley, creado con 4 matrices y 4
     puntos:

          (%i1) a1: matrix([0.85,0.04],[-0.04,0.85])$
          (%i2) a2: matrix([0.2,-0.26],[0.23,0.22])$
          (%i3) a3: matrix([-0.15,0.28],[0.26,0.24])$
          (%i4) a4: matrix([0,0],[0,0.16])$
          (%i5) p1: [0,1.6]$
          (%i6) p2: [0,1.6]$
          (%i7) p3: [0,0.44]$
          (%i8) p4: [0,0]$
          (%i9) w: [85,92,99,100]$
          (%i10) ifs(w, [a1,a2,a3,a4], [p1,p2,p3,p4], [5,0], 50000, [style,dots]);

 -- Función: orbits (<F>, <y0>, <n1>, <n2>, [<x>, <x0>, <xf>, <xstep>],
          <opciones>, ...);

     Dibuja el diagrama de órbitas de una familia de sistemas dinámicos
     discretos unidimensionales, con un parámetro <x>; ese tipo de
     diagrama se usa para mostrar las bifurcaciones de un sistema
     discreto unidimensional.

     La función <F(y)> define una secuencia que comienza con un valor
     inicial <y0>, igual que en el caso de la función 'evolution', pero
     en este caso la función también dependerá del parámetro <x>, el
     cual tomará valores comprendidos en el intervalo de <x0> a <xf>,
     con incrementos <xstep>.  Cada valor usado para el parámetro <x> se
     muestra en el eje horizontal.  En el eje vertical se mostrarán <n2>
     valores de la sucesión <y(n1+1)>,..., <y(n1+n2+1)>, obtenidos
     después de dejarla evolucionar durante <n1> iteraciones iniciales.

     *Ejemplo*.  Diagrama de órbitas para el mapa cuadrático

          (%i1) orbits(x^2+a, 0, 50, 200, [a, -2, 0.25], [style, dots]);

     Para ampliar la región alrededor de la bifurcación en la parte de
     abajo, cerca de x '=' -1.25, se usa el comando:
          (%i2) orbits(x^2+a, 0, 100, 400, [a,-1,-1.53], [x,-1.6,-0.8],
                       [nticks, 400], [style,dots]);

 -- Función: staircase (<F>, <y0>, <n>,<opciones>,...);

     Dibuja un diagrama de escalera (o diagrama de red) para la sucesión
     definida por la ecuación de recurrencia
                  y(n+1) = F(y(n))

     La interpretación y valores permitidos de los parámetros de entrada
     es la misma que para la función 'evolution'.  Un diagrama de
     escalera consiste en una gráfica de la función <F(y)>, junto con la
     recta <G(y)> '=' <y>.  Se comienza por dibujar un segmento vertical
     desde el punto (<y0>, <y0>) en la recta, hasta el punto de
     intersección con la función <F>.  En seguida, desde ese punto se
     dibuja un segmento horizontal hasta el punto de intersección con la
     recta, (<y1>, <y1>); el procedimiento se repite <n> veces hasta
     alcanzar el punto (<yn>, <yn>).  Esta función acepta las mismas
     opciones que 'plot2d'.

     *Ejemplo*.

          (%i1) staircase(cos(y), 1, 11, [y, 0, 1.2]);

