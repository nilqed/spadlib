This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.


File: maxima.info,  Node: Visualización usando VTK,  Prev: Análisis gráfico de sistemas dinámicos discretos,  Up: dynamics

49.3 Visualización usando VTK
=============================

La función scene crea imágenes tridimensionales y animaciones usando el
software _Visualization ToolKit_ (VTK). Para poder usar esa función es
necesario tener Xmaxima y VTK instalados en el sistema (incluyendo la
biblioteca para usar VTK desde TCL que en algunos sistemas viene en un
paquete separado).

 -- Función: scene (<objetos>, ..., <opciones>, ...);

     Acepta una lista vacía o una lista de varios 'objetos' y
     'opciones'.  El programa ejecuta Xmaxima, que abre una ventana
     donde se representan los objetos dados, en un espacio
     tridimensional y aplicando las opciones dadas.  Cada objeto debe
     pertenecer una de las 4 clases: sphere, cube, cylinder o cone (ver
     'Objetos de scene').  Los objetos se identifican dando el nombre de
     su clase, o una lista en que el primer elemento es el nombre de la
     clase y los restantes elementos son opciones para ese objeto.

     *Ejemplo*.  Una pirámide hexagonal con fondo azul:
          (%i1) scene(cone, [background,"#9980e5"])$

     Presionando el botón izquierdo del ratón mientras se mueve dentro
     de la ventana gráfica, se puede rotar la cámara, mostrando
     diferentes vistas de la pirámide.  Las dos opciones 'elevation' y
     'azimuth' se pueden usar también para cambiar la orientación de la
     cámara.  La cámara se puede mover presionando el botón del medio y
     moviendo el ratón y el botón del lado derecho se usa para aumentar
     o disminuir el zoom, moviendo el ratón para arriba y para bajo.

     Cada opción de un objeto deberá ser una lista comenzando con el
     nombre de la opción, seguido por su valor.  La lista de posibles
     opciones se encuentra en la sección 'Opciones de objetos de scene'.

     *Ejemplo*.  Este ejemplo mostrará una esfera cayendo para el piso y
     rebotando sin perder energía.  Para comenzar o poner en pausa la
     animación se debe oprimir el botón de play/pausa.

          (%i1) p: makelist ([0,0,2.1- 9.8*t^2/2], t, 0, 0.64, 0.01)$

          (%i2) p: append (p, reverse(p))$

          (%i3) bola: [sphere, [radius,0.1], [thetaresolution,20],
            [phiresolution,20], [position,0,0,2.1], [color,red],
            [animate,position,p]]$

          (%i4) piso: [cube, [xlength,2], [ylength,2], [zlength,0.2],
            [position,0,0,-0.1],[color,violet]]$

          (%i5) scene (bola, piso, restart)$

     La opción <restart> fue usada para hacer que la animación
     recomienze cada vez que se llega al último punto en la lista.  Los
     valores permitidos para los colores son los mismo que para la
     opción 'color' de plot2d.

49.3.1 Opciones de scene
------------------------

 -- Opción de scene: azimuth [azimuth, <ángulo>]
     Valor predefinido: '135'

     La rotación de la cámara en el plano horizontal (x, y).  <ángulo>
     debe ser un número real; un ángulo de 0 significa que la cámara
     apunta en la dirección del eje y, haciendo que el eje x aparezca a
     la derecha.

 -- Opción de scene: background [background, <color>]
     Valor predefinido: 'black'

     El color del fondo de la ventana gráfica.  Acepta nombres de
     colores o secuencias de caracteres hexadecimales para
     rojo-verde-azul (ver la opción 'color' de plot2d).

 -- Opción de scene: elevation [elevation, <ángulo>]
     Valor predefinido: '30'

     La rotación vertical de la cámara.  El <ángulo> debe ser un número
     real; un ángulo de 0 significa que la cámara apunta en la
     horizontal y el valor predefinido de 30 significa que la cámara
     apunta 30 grados para abajo de la horizontal.

 -- Opción de scene: height [height, <pixels>]
     Valor predefinido: '500'

     La altura, en pixels, de la ventana gráfica.  <pixels> debe ser un
     número entero positivo.

 -- Opción de scene: restart [restart, <valor>]
     Valor predefinido: 'false'

     Un valor 'true' significa que la animación recomenzará
     automáticamente cuando llegue al final.  Escribir simplemente
     "restart" es equivalente a escribir [restart, <true>].

 -- Opción de scene: tstep [tstep, <tiempo>]
     Valor predefinido: '10'

     El intervalo de tiempo, en milisegundos, entre iteraciones
     consecutivas de las partes de una animación.  <tiempo> debe ser un
     número real.

 -- Opción de scene: width [width, <pixels>]
     Valor predefinido: '500'

     El ancho, en pixels, de la ventana gráfica.  <pixels> deberá ser un
     número entero positivo.

 -- Opción de scene: windowname [windowtitle, <nombre>]
     Valor predefinido: '.scene'

     <nombre> deberá ser una secuencia de caracteres que pueda ser usada
     para el nombre de una ventana de Tk, creada por Xmaxima para los
     gráficos de 'scene'.  El valor predefinido '.scene' implica que
     será creada una nueva ventana.

 -- Opción de scene: windowtitle [windowtitle, <nombre>]
     Valor predefinido: 'Xmaxima: scene'

     <nombre> debe ser una secuencia de caracteres que serán escritos en
     el encabezado de la ventana creada por 'scene'.

49.3.2 Objetos de scene
-----------------------

 -- Objeto de scene: cone [cone, <opciones>]

     Crea una pirámide regular con altura 1 unidad y base hexagonal con
     vértices a 0.5 unidades del eje.  Las opciones 'height' y 'radius'
     se pueden usar para alterar esos valores predefinidos y la opción
     'resolution' se usa para alterar el número de aristas de la base;
     valores mayores harán que la pirámide parezca un cono.  Por
     omisión, el eje estará a lo largo del eje x, el punto medio de la
     altura estará en el origen y el vértice en el lado positivo del eje
     x; las opciones 'orientation' y 'center' permiten alterar eso.

     *Ejemplo*.  El siguiente comando muestra una pirámide que comienza
     a dar vueltas cuando se oprime el botón de animación.

          (%i1) scene([cone, [orientation,0,30,0], [tstep,100],
             [animate,orientation,makelist([0,30,i],i,5,360,5)]], restart)$

 -- Objeto de scene: cube [cube, <opciones>]

     Un cubo con aristas de 1 unidad y caras paralelas al los planos xy,
     xz y yz.  Las longitudes de las 3 aristas se pueden modificar con
     las opciones 'xlength', 'ylength' y 'zlength', convirtiéndolo en un
     paralelepípedo y las caras se pueden hacer rotar con la opción
     'orientation'.

 -- Objeto de scene: cylinder [cylinder, <opciones>]

     Crea un prisma regular con altura de 1 unidad y base hexagonal con
     los vértices a 0.5 unidades del eje.  Las opciones 'height' y
     'radius' permiten modificar esos valores predefinidos y la opción
     'resolution' se puede usar para modificar el número de aristas de
     la base; valores mayores tornan el prisma más parecido a un
     cilindro.  La altura predefinida se puede alterar con la opción
     'height'.  Por omisión el eje estará orientado a lo largo del eje
     x, y el punto medio de la altura estará en el origen; se pueden
     cambiar esas propiedades con las opciones 'orientation' y 'center'.

 -- Objeto de scene: sphere [sphere, <opciones>]

     Una esfera de radio igual a 0.5 unidades y centro en el origen.

49.3.3 Opciones de objetos de scene
-----------------------------------

 -- Opción de objeto: animation [animation, <propiedad>, <posiciones>]

     <propiedad> deberá ser una de las 4 siguientes propiedades del
     objeto: 'origin', 'scale', 'position' o 'orientation' y
     <posiciones> deberá ser una lista de puntos.  Cuando se oprime el
     botón "play", esa propiedad tomará sucesivamente los valores en la
     lista, en intervalos regulares de tiempo definidos por la opción
     'tstep'.  El botón de volver al comienzo puede usarse para
     recomenzar desde el principio de la lista, haciendo que la
     animación comience nuevamente cuando se presione otra vez el botón
     de play.

     Consulte también 'track'.

 -- Opción de objeto: capping [capping, <número>]
     Valor predefinido: '1'

     En un objeto "cone" o "cylinder", determina si la base (o bases) se
     muestran o no.  Un valor de 1 para <número> torna la base visible y
     un valor de 0 la hace invisible.

 -- Opción de objeto: center [center, <punto>]
     Valor predefinido: '[0, 0, 0]'

     Coordenadas del centro geométrico del objeto, en relación a su
     posición ('position'); <punto> puede ser una lista de 3 números
     reales o 3 números separados por comas.  En objetos de clase
     "cylinder","cone" o "cube" estará localizado en el punto medio de
     la altura y en objetos de clase "sphere" estará en su centro.

 -- Opción de objeto: color [color, <nombre>]
     Valor predefinido: 'white'

     El color del objeto.  Acepta nombres de colores conocidos o
     secuencias de 6 dígitos (rojo-verde-azul) precedidos por # (ver la
     opción 'color' de plot2d).

 -- Opción de objeto: endphi [endphi, <ángulo>]
     Valor predefinido: '180'

     En una esfera, phi es el ángulo en el plano vertical que pasa por
     el eje z, medido a partir de la parte positiva del eje z.  <ángulo>
     debe ser un múmero entre 0 y 180 que determina el valor final de
     phi hasta donde se mostrará la superficie.  Valores menores que 180
     eliminan una parte de la superficie.

     Consulte también 'startphi' y 'phiresolution'.

 -- Opción de objeto: endtheta [endtheta, <ángulo>]
     Valor predefinido: '360'

     En una esfera, theta es el ángulo en el plano horizontal
     (longitud), medido desde la parte positiva del eje x.  <ángulo>
     debe ser un número entre 0 y 360 que determina el valor final donde
     la superficie terminará.  Valores menores que 360 hacen que se
     elimine una parte de la superficie de la esfera.

     Consulte también 'starttheta' y 'thetaresolution'.

 -- Opción de objeto: height [height, <valor>]
     Valor predefinido: '1'

     <valor> debe ser un número positivo que define la altura de un cono
     o cilindro.

 -- Opción de objeto: linewidth [linewidth, <valor>]
     Valor predefinido: '1'

     El ancho de las líneas cuando se usa la opción 'wireframe'.
     <valor> debe ser un número positivo.

 -- Opción de objeto: opacity [opacity, <valor>]
     Valor predefinido: '1'

     <valor> debe se un número entre 0 y 1.  Cuanto menor sea el número,
     mas transparente será el objeto.  El valor predefinido de 1 implica
     un objeto completamente opaco.

 -- Opción de objeto: orientation [orientation, <ángulos>]
     Valor predefinido: '[0, 0, 0]'

     Tres ángulos que de rotaciones que serán realizadas en el objeto,
     alrededor de los tres ejes.<ángulos> puede ser una lista con tres
     números reales o tres números separados por comas.  *Ejemplo*: '[0,
     0, 90]' rota el eje x del objeto hasta el eje y del sistema de
     referencia.

 -- Opción de objeto: origin [origin, <punto>]
     Valor predefinido: '[0, 0, 0]'

     Coordenadas del origen del objeto, en relación al cual las otras
     dimensiones serán definidas.  <punto> pueden ser tres números
     separados por comas, o una lista de tres números.

 -- Opción de objeto: phiresolution [phiresolution, <num>]
     Valor predefinido: ''

     Número de sub-intervalos en que se divide el intervalo de valores
     del ángulo phi, que comienza en 'startphi' y termina en 'endphi'.
     <num> debe ser un número entero positivo.

     Consulte también 'startphi' y 'endphi'.

 -- Opción de objeto: points [points]

     Esta opción hace que en vez de que se muestre la superficie, se
     muestren únicamente los vértices en la triangulación usada para
     construir la superficie.  *Ejemplo*: '[sphere, [points]]'

     Consulte también 'surface' y 'wireframe'.

 -- Opción de objeto: pointsize [pointsize, <valor>]
     Valor predefinido: '1'

     Tamaño de los puntos, cuando se usa la opción 'points'.  <valor>
     debe ser un número positivo.

 -- Opción de objeto: position [position, <punto>]
     Valor predefinido: '[0, 0, 0]'

     Coordenadas de la posición del objeto.  <punto> puede ser tres
     números separados por comas o una lista de tres números.

 -- Opción de objeto: radius [radius, <valor>]
     Valor predefinido: '0.5'

     El radio de una esfera o la distancia desde el eje hasta los
     vértices de la base en cilindros o conos.  <valor> debe ser un
     número positivo.

 -- Opción de objeto: resolution [resolution, <número>]
     Valor predefinido: '6'

     <número> debe ser un número entero mayor que 2, que define el
     número de aristas de la base en objetos de clase "cone" o
     "cylinder".

 -- Opción de objeto: scale [scale, <factores>]
     Valor predefinido: '[1, 1, 1]'

     Tres factores de escala en que serán deformadas las dimensiones del
     objeto en relación a los tres ejes.  <factors> pueden ser tres
     número separados por comas o una lista con tres números.
     *Ejemplo*: '[2, 0.5, 1]' estira el objeto suplicando sus
     dimensiones paralelas la eje x, reduce a mitad las dimensiones
     paralelas al eje y, dejando iguales las dimensiones paralelas al
     eje z.

 -- Opción de objeto: startphi [startphi, <ángulo>]
     Valor predefinido: '0'

     En una esfera, phi es el ángulo en el plano vertical que pasa por
     el eje z, medido a partir de la parte positiva del eje z.  <ángulo>
     debe ser un múmero entre 0 y 180 que determina el valor inicial de
     phi desde donde se mostrará la superficie.  Valores superiores a 0
     eliminan una parte de la superficie.

     Consulte también 'endphi' y 'phiresolution'.

 -- Opción de objeto: starttheta [starttheta, <ángulo>]
     Valor predefinido: '0'

     En una esfera, theta es el ángulo en el plano horizontal
     (longitud), medido desde la parte positiva del eje x.  <ángulo>
     debe ser un número entre 0 y 360 que determina el valor inicial
     donde la superficie comienza.  Valores mayores que 0 hacen que se
     elimine una parte de la superficie de la esfera.

     Consulte también 'endtheta' y 'thetaresolution'.

 -- Opción de objeto: surface [surface]

     Hace que se muestre la superficie del objeto y no los las líneas ni
     los vértices de la triangulación usada para construirlo.  Ese es el
     comportamiento habitual que se puede alterar con las opciones
     'points' o 'wireframe'.

 -- Opción de objeto: thetaresolution [thetaresolution, <num>]
     Valor predefinido: ''

     Número de sub-intervalos en que se divide el intervalo de valores
     del ángulo theta, que comienza en 'starttheta' y termina en
     'endtheta'.  <num> debe ser un número entero positivo.  Consulte
     también 'starttheta' y 'endtheta'.

 -- Opción de objeto: track [track, <posiciones>]

     <posiciones> deberá ser una lista de puntos.  Cuando se oprime el
     botón de "play", la posición del objeto tomara secuencialmente los
     valores en la lista, a intervalos regulares de tiempo definidos por
     la opción 'tstep', dejando un rastro de la trayectoria del objeto.
     El botón de volver al comienzo puede usarse para recomenzar desde
     el principio de la lista, haciendo que la animación comience
     nuevamente cuando se presione otra vez el botón de play.

     *Ejemplo*.  Estos comandos muestran la trayectoria de una bola
     lanzada con velocidad inicial de 5 m/s, a un ángulo de 45 grados,
     cuando se puede ignorar la resistencia del aire:

          (%i1) p: makelist ([0,4*t,4*t- 9.8*t^2/2], t, 0, 0.82, 0.01)$

          (%i2) bola: [sphere, [radius,0.1], [color,red], [track,p]]$

          (%i3) piso: [cube, [xlength,2], [ylength,4], [zlength,0.2],
                [position,0,1.5,-0.2],[color,green]]$

          (%i4) scene (bola, piso)$

     Consulte también 'animation'.

 -- Opción de objeto: xlength [xlength, <altura>]
     Valor predefinido: '1'

     Altura de un objeto de clase "cube", en la dirección x.  <altura>
     debe ser un número positivo.  Consulte también 'ylength' y
     'zlength'.

 -- Opción de objeto: ylength [ylength, <altura>]
     Valor predefinido: '1'

     Altura de un objeto de clase "cube", en la dirección y.  <altura>
     debe ser un número positivo.  Consulte también 'xlength' y
     'zlength'.

 -- Opción de objeto: zlength [zlength, <altura>]
     Valor predefinido: '1'

     Altura de un objeto de clase "cube", en la dirección z.  <altura>
     debe ser un número positivo.  Consulte también 'xlength' y
     'ylength'.

 -- Opción de objeto: wireframe [wireframe]

     Esta opción hace que en vez de que se muestre la superficie, se
     muestren únicamente las aristas de la triangulación usada para
     construir la superficie.  *Ejemplo*: '[cube, [wireframe]]'

     Consulte también 'surface' y 'points'.


File: maxima.info,  Node: ezunits,  Next: f90,  Prev: dynamics,  Up: Top

50 ezunits
**********

* Menu:

* Introducción a ezunits::
* Introducción a physical_constants::
* Funciones y variables para ezunits::


File: maxima.info,  Node: Introducción a ezunits,  Next: Introducción a physical_constants,  Prev: ezunits,  Up: ezunits

50.1 Introducción a ezunits
===========================

'ezunits' es un paquete para trabajar con magnitudes dimensionales,
incluyendo algunas funciones para realizar análisis dimensional.
'ezunits' puede hacer operaciones aritméticas con magnitudes
dimensionales y efectuar conversiones entre unidades.  Las unidades que
se definen son las del Sistema Internacional (SI) y otras comunes en los
Estados Unidos, siendo posible declarar otras nuevas.

Véase también 'physical_constants', una colección de constantes físicas.

Es necesario ejecutar primero 'load(ezunits)' para utilizar este
paquete.  Con 'demo(ezunits)' se podrán ver algunos ejemplos de
utilización.  La función 'known_units' devuelve una lista con todas las
unidades que están definidas y 'display_known_unit_conversions' muestra
las conversiones conocidas por el sistema en un formato de lectura
sencilla.

Una expresión tal como a ` b representa una magnitud dimensional, siendo
'a' una magnitud adimensional y 'b' las unidades.  Se puede utilizar un
símbolo como unidad, sin necesidad de declararlo como tal ni de que deba
cumplir propiedades especiales.  Tanto la magnitud como la unidad de una
expresión de la forma a ` b pueden extraerse invocando las funciones
'qty' y 'units', respectivamente.

Una expresión tal como 'a ` b `` c' convierte las unidades 'b' en 'c'.
El paquete 'ezunits' contiene funciones conversoras para unidades
fundamentales del SI, unidades derivadas, así como algunas otras
unidades ajenas al SI. Las conversiones entre unidades que no estén
programadas en 'ezunits' podrán declararse a posteriori.  Las
conversiones conocidas por 'ezunits' están especificadas en la variable
global 'known_unit_conversions', incluyendo tanto las ya declaradas por
defecto como aquéllas introducidas por el usuario.  Las conversiones
para los productos, cocientes y potencias de unidades se derivan del
conjunto de conversiones ya conocidas.

En general, Maxima prefiere números exactos (enteros o racionales) a
inexactos (decimales en coma flotante), por lo que 'ezunits' respetará
los exactos cuando aparezcan en expresiones de magnitudes dimensionales.
Todas las conversiones del paquete se han definido en términos de
números exactos.

No hay un sistema de representación de unidades que se considere
preferible, razón por la cual las unidades no se convierten a otras a
menos que se indique de forma explícita.  'ezunits' reconoce los
prefijos m-, k-, M y G- para mili-, kilo-, mega- y giga-,
respectivamente, tal como se utilizan en el SI; estos prefijos sólo se
utilizan cuando así se indica de forma explícita.

Las operaciones aritméticas con magnitudes dimensionales se realizan de
la forma convencional.

   * '(x ` a) * (y ` b)' es igual a (x * y) ` (a * b).
   * '(x ` a) + (y ` a)' es igual a (x + y) ` a.
   * '(x ` a)^y' es igual a x^y ` a^y si 'y' es adimensional.

'ezunits' no necesita que las unidades en una suma tengan las mismas
dimensiones; estos términos serán sumados sin emitirse mensaje de error.

'ezunits' incluye funciones para el análisis dimensional elemental, como
las dimensiones fundamentales, las unidades fundamentales de una
magnitud dimensional o el cálculo de magnitudes adimensionales y
unidades naturales.  Las funciones de análisis dimensional son
adaptaciones de funciones semejantes escritas por Barton Willis en otro
paquete.

Con el fin de poder llevar a cabo análisis dimensionales, se mantiene
una lista de dimensiones fundamentales y otra lista asociada de unidades
fundamentales; por defecto, las dimensiones fundamentales son longitud,
masa, tiempo, carga, temperatura y cantidad de materia, siendo las
unidades fundamentales las propias del Sistema Internacional.  En
cualquier caso, es posible declarar otras dimensiones y unidades
fundamentales.


File: maxima.info,  Node: Introducción a physical_constants,  Next: Funciones y variables para ezunits,  Prev: Introducción a ezunits,  Up: ezunits

50.2 Introducción a physical_constants
======================================

'physical_constants' contiene constantes físicas recomendadas por el
CODATA 2006 (<http://physics.nist.gov/constants>).  La instrucción
'load(physical_constants)' carga este paquete en memoria junto con el
propio 'ezunits', si éste no estaba previamente cargado.

Una constante física se representa por un símbolo con la propiedad de
ser un valor constante.  El valor constante es una magnitud dimensional
en la sintaxis de 'ezunits'.  La función 'constvalue' extrae el valor
constante, el cual no es el valor ordinario del símbolo, por lo que las
constantes físicas se mantienen inalteradas en las expresiones evaluadas
hasta que sus valores sea extraído con la función 'constvalue'.

'physical_constants' incluye cierta información adicional, como la
descripción de cada constante, una estimación del error de su valor
numérico y una propiedad para ser representada en TeX. Para identificar
constantes físicas, cada símbolo tiene la propiedad 'physical_constant',
de forma que 'propvars(physical_constant)' muestra la lista de todas las
constantes físicas.

'physical_constants' contiene las siguientes constantes:

'%c'
     velocidad de la luz en el vacío
'%mu_0'
     constante magnética
'%e_0'
     constante eléctrica
'%Z_0'
     impedancia característica del vacío
'%G'
     constante gravitatoria de Newton
'%h'
     constante de Planck
'%h_bar'
     constante de Planck
'%m_P'
     masa de Planck
'%T_P'
     temperature de Planck
'%l_P'
     longitud de Planck
'%t_P'
     tiempo de Planck
'%%e'
     carga elemental
'%Phi_0'
     flujo magnético cuántico
'%G_0'
     conductancia cuántica
'%K_J'
     constante de Josephson
'%R_K'
     constante de von Klitzing
'%mu_B'
     magnetón de Bohr
'%mu_N'
     magnetón nuclear
'%alpha'
     constante de estructura fina
'%R_inf'
     constante de Rydberg
'%a_0'
     radio de Bohr
'%E_h'
     energía de Hartree
'%ratio_h_me'
     cuanto de circulación
'%m_e'
     masa del electrón
'%N_A'
     número de Avogadro
'%m_u'
     constante de masa atómica atomic mass constant
'%F'
     constante de Faraday
'%R'
     constante molar de los gases
'%%k'
     constante de Boltzmann
'%V_m'
     volumen molar del gas ideal
'%n_0'
     constante de Loschmidt
'%ratio_S0_R'
     constante de Sackur-Tetrode (constante de entropía absoluta)
'%sigma'
     constante de Stefan-Boltzmann
'%c_1'
     primera constante de radiación
'%c_1L'
     primera constante de radiación para radiancia espectral
'%c_2'
     segunda constante de radiación
'%b'
     Constante de la ley del desplazamiento de Wien
'%b_prime'
     Constante de la ley del desplazamiento de Wien

Ejemplos:

Lista de todos los símbolos que tienen la propiedad 'physical_constant'.

     (%i1) load (physical_constants)$
     (%i2) propvars (physical_constant);
     (%o2) [%c, %mu_0, %e_0, %Z_0, %G, %h, %h_bar, %m_P, %T_P, %l_P,
     %t_P, %%e, %Phi_0, %G_0, %K_J, %R_K, %mu_B, %mu_N, %alpha,
     %R_inf, %a_0, %E_h, %ratio_h_me, %m_e, %N_A, %m_u, %F, %R, %%k,
     %V_m, %n_0, %ratio_S0_R, %sigma, %c_1, %c_1L, %c_2, %b, %b_prime]

Propiedades de la constante física '%c'.

     (%i1) load (physical_constants)$
     (%i2) constantp (%c);
     (%o2)                         true
     (%i3) get (%c, description);
     (%o3)               speed of light in vacuum
     (%i4) constvalue (%c);
                                           m
     (%o4)                     299792458 ` -
                                           s
     (%i5) get (%c, RSU);
     (%o5)                           0
     (%i6) tex (%c);
     $$c$$
     (%o6)                         false

Energía equivalente de una libra-masa.  El símbolo '%c' se mantiene
hasta que su valor es extraído con la llamada a la función 'constvalue'.

     (%i1) load (physical_constants)$
     (%i2) m * %c^2;
                                     2
     (%o2)                         %c  m
     (%i3) %, m = 1 ` lbm;
                                   2
     (%o3)                       %c  ` lbm
     (%i4) constvalue (%);
                                                 2
                                            lbm m
     (%o4)              89875517873681764 ` ------
                                               2
                                              s
     (%i5) E : % `` J;
     Computing conversions to base units; may take a moment.
                          366838848464007200
     (%o5)                ------------------ ` J
                                  9
     (%i6) E `` GJ;
                           458548560580009
     (%o6)                 --------------- ` GJ
                              11250000
     (%i7) float (%);
     (%o7)              4.0759872051556356e+7 ` GJ


File: maxima.info,  Node: Funciones y variables para ezunits,  Prev: Introducción a physical_constants,  Up: ezunits

50.3 Funciones y variables para ezunits
=======================================

 -- Operador: `

     Operador de magnitud dimensional.  Una expresión tal como a ` b
     representa una magnitud dimensional, siendo 'a' una magnitud
     adimensional y 'b' las unidades.  Se puede utilizar un símbolo como
     unidad, sin necesidad de declararlo como tal ni de que deba cumplir
     propiedades especiales.  Tanto la magnitud como la unidad de una
     expresión de la forma a ` b pueden extraerse invocando las
     funciones 'qty' y 'units', respectivamente.

     Las operaciones aritméticas con magnitudes dimensionales se
     realizan de la forma convencional.

        * '(x ` a) * (y ` b)' es igual a (x * y) ` (a * b).
        * '(x ` a) + (y ` a)' es igual a (x + y) ` a.
        * '(x ` a)^y' es igual a x^y ` a^y si 'y' es adimensional.

     'ezunits' no necesita que las unidades en una suma tengan las
     mismas dimensiones; estos términos serán sumados sin emitirse
     mensaje de error.

     Para utilizar este operador ejecútese primero 'load(ezunits)'.

     Ejemplos:

     Unidades del Sistema Internacional.

          (%i1) load (ezunits)$
          (%i2) foo : 10 ` m;
          (%o2)                        10 ` m
          (%i3) qty (foo);
          (%o3)                          10
          (%i4) units (foo);
          (%o4)                           m
          (%i5) dimensions (foo);
          (%o5)                        length

     Unidades definidas por el usuario.

          (%i1) load (ezunits)$
          (%i2) bar : x ` acre;
          (%o2)                       x ` acre
          (%i3) dimensions (bar);
                                             2
          (%o3)                        length
          (%i4) fundamental_units (bar);
                                          2
          (%o4)                          m

     Unidades ad hoc.

          (%i1) load (ezunits)$
          (%i2) baz : 3 ` sheep + 8 ` goat + 1 ` horse;
          (%o2)           8 ` goat + 3 ` sheep + 1 ` horse
          (%i3) subst ([sheep = 3*goat, horse = 10*goat], baz);
          (%o3)                       27 ` goat
          (%i4) baz2 : 1000`gallon/fortnight;
                                          gallon
          (%o4)                   1000 ` ---------
                                         fortnight
          (%i5) subst (fortnight = 14*day, baz2);
                                    500   gallon
          (%o5)                     --- ` ------
                                     7     day

     Operaciones aritméticas y magnitudes dimensionales.

          (%i1) load (ezunits)$
          (%i2) 100 ` kg + 200 ` kg;
          (%o2)                       300 ` kg
          (%i3) 100 ` m^3 - 100 ` m^3;
                                            3
          (%o3)                        0 ` m
          (%i4) (10 ` kg) * (17 ` m/s^2);
                                           kg m
          (%o4)                      170 ` ----
                                             2
                                            s
          (%i5) (x ` m) / (y ` s);
                                        x   m
          (%o5)                         - ` -
                                        y   s
          (%i6) (a ` m)^2;
                                        2    2
          (%o6)                        a  ` m

 -- Operador: ` `

     Operador de conversión de unidades.  Una expresión tal como a ` b
     `` c convierte las unidades 'b' en 'c'.  El paquete 'ezunits'
     contiene funciones conversoras para unidades fundamentales del SI,
     unidades derivadas, así como algunas otras unidades ajenas al SI.
     Las conversiones entre unidades que no estén programadas en
     'ezunits' podrán declararse a posteriori.  Las conversiones
     conocidas por 'ezunits' están especificadas en la variable global
     'known_unit_conversions', incluyendo tanto las ya declaradas por
     defecto como aquéllas introducidas por el usuario.  Las
     conversiones para los productos, cocientes y potencias de unidades
     se derivan del conjunto de conversiones ya conocidas.

     No hay un sistema de representación de unidades que se considere
     preferible, razón por la cual las unidades no se convierten a otras
     a menos que se indique de forma explícita.  Del mismo modo,
     'ezunits' no transforma prefijos (milli-, centi-, deci-, etc) a
     menos que se le indique.

     Para utilizar este operador ejecútese primero 'load(ezunits)'.

     Ejemplos:

     Conjunto de conversiones conocidas.

          (%i1) load (ezunits)$
          (%i2) display2d : false$
          (%i3) known_unit_conversions;
          (%o3) {acre = 4840*yard^2,Btu = 1055*J,cfm = feet^3/minute,
                 cm = m/100,day = 86400*s,feet = 381*m/1250,ft = feet,
                 g = kg/1000,gallon = 757*l/200,GHz = 1000000000*Hz,
                 GOhm = 1000000000*Ohm,GPa = 1000000000*Pa,
                 GWb = 1000000000*Wb,Gg = 1000000*kg,Gm = 1000000000*m,
                 Gmol = 1000000*mol,Gs = 1000000000*s,ha = hectare,
                 hectare = 100*m^2,hour = 3600*s,Hz = 1/s,inch = feet/12,
                 km = 1000*m,kmol = 1000*mol,ks = 1000*s,l = liter,
                 lbf = pound_force,lbm = pound_mass,liter = m^3/1000,
                 metric_ton = Mg,mg = kg/1000000,MHz = 1000000*Hz,
                 microgram = kg/1000000000,micrometer = m/1000000,
                 micron = micrometer,microsecond = s/1000000,
                 mile = 5280*feet,minute = 60*s,mm = m/1000,
                 mmol = mol/1000,month = 2629800*s,MOhm = 1000000*Ohm,
                 MPa = 1000000*Pa,ms = s/1000,MWb = 1000000*Wb,
                 Mg = 1000*kg,Mm = 1000000*m,Mmol = 1000000000*mol,
                 Ms = 1000000*s,ns = s/1000000000,ounce = pound_mass/16,
                 oz = ounce,Ohm = s*J/C^2,
                 pound_force = 32*ft*pound_mass/s^2,
                 pound_mass = 200*kg/441,psi = pound_force/inch^2,
                 Pa = N/m^2,week = 604800*s,Wb = J/A,yard = 3*feet,
                 year = 31557600*s,C = s*A,F = C^2/J,GA = 1000000000*A,
                 GC = 1000000000*C,GF = 1000000000*F,GH = 1000000000*H,
                 GJ = 1000000000*J,GK = 1000000000*K,GN = 1000000000*N,
                 GS = 1000000000*S,GT = 1000000000*T,GV = 1000000000*V,
                 GW = 1000000000*W,H = J/A^2,J = m*N,kA = 1000*A,
                 kC = 1000*C,kF = 1000*F,kH = 1000*H,kHz = 1000*Hz,
                 kJ = 1000*J,kK = 1000*K,kN = 1000*N,kOhm = 1000*Ohm,
                 kPa = 1000*Pa,kS = 1000*S,kT = 1000*T,kV = 1000*V,
                 kW = 1000*W,kWb = 1000*Wb,mA = A/1000,mC = C/1000,
                 mF = F/1000,mH = H/1000,mHz = Hz/1000,mJ = J/1000,
                 mK = K/1000,mN = N/1000,mOhm = Ohm/1000,mPa = Pa/1000,
                 mS = S/1000,mT = T/1000,mV = V/1000,mW = W/1000,
                 mWb = Wb/1000,MA = 1000000*A,MC = 1000000*C,
                 MF = 1000000*F,MH = 1000000*H,MJ = 1000000*J,
                 MK = 1000000*K,MN = 1000000*N,MS = 1000000*S,
                 MT = 1000000*T,MV = 1000000*V,MW = 1000000*W,
                 N = kg*m/s^2,R = 5*K/9,S = 1/Ohm,T = J/(m^2*A),V = J/C,
                 W = J/s}

     Converiones de unidades fundamentales.

          (%i1) load (ezunits)$
          (%i2) 1 ` ft `` m;
          Computing conversions to base units; may take a moment.
                                      381
          (%o2)                       ---- ` m
                                      1250
          (%i3) %, numer;
          (%o3)                      0.3048 ` m
          (%i4) 1 ` kg `` lbm;
                                      441
          (%o4)                       --- ` lbm
                                      200
          (%i5) %, numer;
          (%o5)                      2.205 ` lbm
          (%i6) 1 ` W `` Btu/hour;
                                     720   Btu
          (%o6)                      --- ` ----
                                     211   hour
          (%i7) %, numer;
                                                  Btu
          (%o7)               3.412322274881517 ` ----
                                                  hour
          (%i8) 100 ` degC `` degF;
          (%o8)                      212 ` degF
          (%i9) -40 ` degF `` degC;
          (%o9)                     (- 40) ` degC
          (%i10) 1 ` acre*ft `` m^3;
                                  60228605349    3
          (%o10)                  ----------- ` m
                                   48828125
          (%i11) %, numer;
                                                    3
          (%o11)                1233.48183754752 ` m

     Transformando pies a metros y viceversa.

          (%i1) load (ezunits)$
          (%i2) 100 ` m + 100 ` ft;
          (%o2)                  100 ` m + 100 ` ft
          (%i3) (100 ` m + 100 ` ft) `` ft;
                                     163100
          (%o3)                      ------ ` ft
                                      381
          (%i4) %, numer;
          (%o4)                428.0839895013123 ` ft
          (%i5) (100 ` m + 100 ` ft) `` m;
                                      3262
          (%o5)                       ---- ` m
                                       25
          (%i6) %, numer;
          (%o6)                      130.48 ` m

     Análisis dimensional para encontrar dimensiones y unidades
     fundamentales.

          (%i1) load (ezunits)$
          (%i2) foo : 1 ` acre * ft;
          (%o2)                      1 ` acre ft
          (%i3) dimensions (foo);
                                             3
          (%o3)                        length
          (%i4) fundamental_units (foo);
                                          3
          (%o4)                          m
          (%i5) foo `` m^3;
                                  60228605349    3
          (%o5)                   ----------- ` m
                                   48828125
          (%i6) %, numer;
                                                    3
          (%o6)                 1233.48183754752 ` m

     Declaración de conversiones.

          (%i1) load (ezunits)$
          (%i2) declare_unit_conversion (MMBtu = 10^6*Btu, kW = 1000*W);
          (%o2)                         done
          (%i3) declare_unit_conversion (kWh = kW*hour, MWh = 1000*kWh,
                                         bell = 1800*s);
          (%o3)                         done
          (%i4) 1 ` kW*s `` MWh;
          Computing conversions to base units; may take a moment.
                                       1
          (%o4)                     ------- ` MWh
                                    3600000
          (%i5) 1 ` kW/m^2 `` MMBtu/bell/ft^2;
                                 1306449      MMBtu
          (%o5)                 ---------- ` --------
                                8242187500          2
                                             bell ft

 -- Función: constvalue (<x>)
 -- Función: declare_constvalue (<a>, <x>)
 -- Función: remove_constvalue (<a>)

     Devuelve la constante declarada para un símbolo.  Los valores
     constantes se declaran con 'declare_constvalue'.

     Los valores constantes reconocidos por 'constvalue' son distintos
     de los valores declarados por 'numerval' y reconocidos por
     'constantp'.

     El paquete 'physical_units' declara los valores constantes de las
     constantes físicas.

     'remove_constvalue' deshace la acción de 'declare_constvalue'.

     Para utilizar estas funciones ejecútese primero 'load(ezunits)'.

     Ejemplos:

     Valor de una constante física.

          (%i1) load (physical_constants)$
          (%i2) constvalue (%G);
                                               3
                                              m
          (%o2)                    6.67428 ` -----
                                                 2
                                             kg s
          (%i3) get ('%G, 'description);
          (%o3)           Newtonian constant of gravitation

     Declarando una nueva constante.

          (%i1) load (ezunits)$
          (%i2) declare_constvalue (FOO, 100 ` lbm / acre);
                                           lbm
          (%o2)                      100 ` ----
                                           acre
          (%i3) FOO * (50 ` acre);
          (%o3)                     50 FOO ` acre
          (%i4) constvalue (%);
          (%o4)                      5000 ` lbm

 -- Función: units (<x>)
 -- Función: declare_units (<a>, <u>)

     Devuelve las unidades de la magnitud dimensional <x>, o 1 en caso
     de que <x> sea adimensional.

     <x> puede ser una expresión literal dimensional a ` b, un símbolo
     con unidades declaradas por medio de 'declare_units', o una
     expresión que contenga cualquiera o ambos de los anteriores.

     'declare_constvalue' declara que 'units(<a>)' debe devolver <u>,
     siendo <u> una expresión.

     Para utilizar estas funciones ejecútese primero 'load(ezunits)'.

     Ejemplos:

     'units' aplicado a expresiones dimensionales literales.

          (%i1) load (ezunits)$
          (%i2) foo : 100 ` kg;
          (%o2)                              100 ` kg
          (%i3) bar : x ` m/s;
                                                   m
          (%o3)                                x ` -
                                                   s
          (%i4) units (foo);
          (%o4)                                 kg
          (%i5) units (bar);
                                                 m
          (%o5)                                  -
                                                 s
          (%i6) units (foo * bar);
                                               kg m
          (%o6)                                ----
                                                s
          (%i7) units (foo / bar);
                                               kg s
          (%o7)                                ----
                                                m
          (%i8) units (foo^2);
                                                  2
          (%o8)                                 kg

     'units' aplicado a símbolos con unidades declaradas.

          (%i1) load (ezunits)$
          (%i2) linenum:0;
          (%o0)                                  0
          (%i1) units (aa);
          (%o1)                                  1
          (%i2) declare_units (aa, J);
          (%o2)                                  J
          (%i3) units (aa);
          (%o3)                                  J
          (%i4) units (aa^2);
                                                 2
          (%o4)                                 J
          (%i5) foo : 100 ` kg;
          (%o5)                              100 ` kg
          (%i6) units (aa * foo);
          (%o6)                                kg J

 -- Función: qty (<x>)
 -- Función: declare_qty (<a>, <x>)

     'qty' devuelve la parte adimensional de la magnitud dimensional
     <x>, o <x>, si <x> es adimensional.  <x> puede ser una expresión
     literal dimensional a ` b, un símbolo con unidades declaradas o una
     expresión que contenga cualquiera o ambos de los anteriores.

     'declare_qty' declara que 'qty(<a>)' debe devolver <x>, siendo <x>
     una magnitud dimensional.

     Para utilizar estas funciones ejecútese primero 'load(ezunits)'.

     Ejemplos:

     'qty' aplicado a expresiones dimensionales literales.

          (%i1) load (ezunits)$
          (%i2) foo : 100 ` kg;
          (%o2)                       100 ` kg
          (%i3) qty (foo);
          (%o3)                          100
          (%i4) bar : v ` m/s;
                                            m
          (%o4)                         v ` -
                                            s
          (%i5) foo * bar;
                                            kg m
          (%o5)                     100 v ` ----
                                             s
          (%i6) qty (foo * bar);
          (%o6)                         100 v

     'qty' aplicado a símbolos con unidades declaradas.

          (%i1) load (ezunits)$
          (%i2) declare_qty (aa, xx);
          (%o2)                          xx
          (%i3) qty (aa);
          (%o3)                          xx
          (%i4) qty (aa^2);
                                           2
          (%o4)                          xx
          (%i5) foo : 100 ` kg;
          (%o5)                       100 ` kg
          (%i6) qty (aa * foo);
          (%o6)                        100 xx

 -- Función: unitp (<x>)

     Devuelve 'true' si <x> es una expresión dimensional literal, un
     símbolo declarado como dimensional o una expresión en la que su
     operador principal ha sido declarado como dimensional.  En
     cualquier otro caso, 'unitp' devuelve 'false'.

     Para utilizar esta función ejecútese primero 'load(ezunits)'.

     Ejemplos:

     'unitp' aplicado a expresiones dimensionales literales.

          (%i1) load (ezunits)$
          (%i2) unitp (100 ` kg);
          (%o2)                         true

     'unitp' applied to a symbol declared dimensional.

          (%i1) load (ezunits)$
          (%i2) unitp (foo);
          (%o2)                         false
          (%i3) declare (foo, dimensional);
          (%o3)                         done
          (%i4) unitp (foo);
          (%o4)                         true

     'unitp' aplicado a una expresión en la que el operador principal se
     declara dimensional.

          (%i1) load (ezunits)$
          (%i2) unitp (bar (x, y, z));
          (%o2)                         false
          (%i3) declare (bar, dimensional);
          (%o3)                         done
          (%i4) unitp (bar (x, y, z));
          (%o4)                         true

 -- Función: declare_unit_conversion (<u> = <v>, ...)

     Añade las ecuaciones <u> = <v>, ...  a la lista de conversiones de
     unidades conocidas por el operador de conversión ``.  <u> y <v> son
     términos multiplicativos en las que las variables son unidades o
     expresiones dimensionales literales.

     De momento, es imperativo expresar las conversiones de forma que el
     miembro izquierdo de cada ecuación sea una unidad simple (en
     opsición a una expresión multiplicativa) o una expresión
     dimensional literal con la cantidad igual a 1 y con unidad simple.
     Está previsto eliminar esta restricción en versiones futuras.

     'known_unit_conversions' es la lista de conversiones de unidades
     conocidas.

     Para utilizar esta función ejecútese primero 'load(ezunits)'.

     Ejemplos:

     Conversión de unidades expresadas por ecuaciones con términos
     multiplicativos.

          (%i1) load (ezunits)$
          (%i2) declare_unit_conversion (nautical_mile = 1852 * m,
                                         fortnight = 14 * day);
          (%o2)                         done
          (%i3) 100 ` nautical_mile / fortnight `` m/s;
          Computing conversions to base units; may take a moment.
                                      463    m
          (%o3)                       ---- ` -
                                      3024   s

     Conversión de unidades expresadas por ecuaciones con expresiones
     dimensionales literales.

          (%i1) load (ezunits)$
          (%i2) declare_unit_conversion (1 ` fluid_ounce = 2 ` tablespoon);
          (%o2)                         done
          (%i3) declare_unit_conversion (1 ` tablespoon = 3 ` teaspoon);
          (%o3)                         done
          (%i4) 15 ` fluid_ounce `` teaspoon;
          Computing conversions to base units; may take a moment.
          (%o4)                     90 ` teaspoon

 -- Función: declare_dimensions (<a_1>, <d_1>, ..., <a_n>, <d_n>)
 -- Función: remove_dimensions (<a_1>, ..., <a_n>)

     'declare_dimensions' declara <a_1>, ..., <a_n> con las dimensiones
     <d_1>, ..., <d_n>, respectivamente.

     Cada <a_k> es un símbolo o lista de símbolos.  En caso de ser una
     lista, cada símbolo en <a_k> se declara de dimensión <d_k>.

     'remove_dimensions' invierte el efecto de 'declare_dimensions'.

     Ejecútese 'load(ezunits)' para hacer uso de estas funciones.

     Ejemplos:

          (%i1) load (ezunits) $
          (%i2) declare_dimensions ([x, y, z], length, [t, u], time);
          (%o2)                         done
          (%i3) dimensions (y^2/u);
                                             2
                                       length
          (%o3)                        -------
                                        time
          (%i4) fundamental_units (y^2/u);
          0 errors, 0 warnings
                                          2
                                         m
          (%o4)                          --
                                         s

 -- Función: declare_fundamental_dimensions (<d_1>, <d_2>, <d_3>, ...)
 -- Función: remove_fundamental_dimensions (<d_1>, <d_2>, <d_3>, ...)
 -- Variable global: fundamental_dimensions

     'declare_fundamental_dimensions' declara dimensiones fundamentales.
     Los símbolos <d_1>, <d_2>, <d_3>, ...  se añaden a la lista de
     dimensiones fundamentales si no están ya presentes en la lista.

     'remove_fundamental_dimensions' invierte el efecto de
     'declare_fundamental_dimensions'.

     'fundamental_dimensions' es la lista de dimensiones fundamentales.
     Por defecto, la lista comprende algunas dimensiones físicas.

     Ejecútese 'load(ezunits)' para hacer uso de estas funciones.

     Ejemplos:

          (%i1) load (ezunits) $
          (%i2) fundamental_dimensions;
          (%o2) [length, mass, time, current, temperature, quantity]
          (%i3) declare_fundamental_dimensions (money, cattle, happiness);
          (%o3)                         done
          (%i4) fundamental_dimensions;
          (%o4) [length, mass, time, current, temperature, quantity,
                                                  money, cattle, happiness]
          (%i5) remove_fundamental_dimensions (cattle, happiness);
          (%o5)                         done
          (%i6) fundamental_dimensions;
          (%o6) [length, mass, time, current, temperature, quantity, money]

 -- Función: declare_fundamental_units (<u_1>, <d_1>, ..., <u_n>, <d_n>)
 -- Función: remove_fundamental_units (<u_1>, ..., <u_n>)

     'declare_fundamental_units' declara <u_1>, ..., <u_n> de
     dimensiones <d_1>, ..., <d_n>, respectivamente.  Todos los
     argumentos deben símbolos.

     Tras la llamada a 'declare_fundamental_units', 'dimensions(<u_k>)'
     devuelve <d_k> para cada argumento <u_1>, ..., <u_n>, y
     'fundamental_units(<d_k>)' devuelve <u_k> para cada <d_1>, ...,
     <d_n>.

     'remove_fundamental_units' invierte el efecto de
     'declare_fundamental_units'.

     Ejecútese 'load(ezunits)' para hacer uso de estas funciones.

     Ejemplos:

          (%i1) load (ezunits) $
          (%i2) declare_fundamental_dimensions (money, cattle, happiness);
          (%o2)                         done
          (%i3) declare_fundamental_units (dollar, money, goat, cattle,
                                           smile, happiness);
          (%o3)                 [dollar, goat, smile]
          (%i4) dimensions (100 ` dollar/goat/km^2);
                                       money
          (%o4)                    --------------
                                                2
                                   cattle length
          (%i5) dimensions (x ` smile/kg);
                                      happiness
          (%o5)                       ---------
                                        mass
          (%i6) fundamental_units (money*cattle/happiness);
          0 errors, 0 warnings
                                     dollar goat
          (%o6)                      -----------
                                        smile

 -- Función: dimensions (<x>)
 -- Función: dimensions_as_list (<x>)

     'dimensions' devuelve las dimensiones de la magnitud dimensional
     <x> en forma de expresión que contiene productos y potencias de
     dimensiones fundamentales.

     'dimensions_as_list' devuelve las dimensiones de la magnitud
     dimensional <x> en forma de lista, cuyos elementos indican las
     potencias de las dimensiones fundamentales correspondientes.

     Para utilizar estas funciones ejecútese primero 'load(ezunits)'.

     Ejemplos:

          (%i1) load (ezunits)$
          (%i2) dimensions (1000 ` kg*m^2/s^3);
                                          2
                                    length  mass
          (%o2)                     ------------
                                           3
                                       time
          (%i3) declare_units (foo, acre*ft/hour);
                                       acre ft
          (%o3)                        -------
                                        hour
          (%i4) dimensions (foo);
                                             3
                                       length
          (%o4)                        -------
                                        time

          (%i1) load (ezunits)$
          (%i2) fundamental_dimensions;
          (%o2)  [length, mass, time, charge, temperature, quantity]
          (%i3) dimensions_as_list (1000 ` kg*m^2/s^3);
          (%o3)                 [2, 1, - 3, 0, 0, 0]
          (%i4) declare_units (foo, acre*ft/hour);
                                       acre ft
          (%o4)                        -------
                                        hour
          (%i5) dimensions_as_list (foo);
          (%o5)                 [3, 0, - 1, 0, 0, 0]

 -- Función: fundamental_units (<x>)
 -- Función: fundamental_units ()

     'fundamental_units(<x>)' devuelve las unidades asociadas a las
     dimensiones fundamentales de <x>, tal como queda determinada por
     'dimensions(<x>)'.

     <x> puede ser una expresión literal dimensional a ` b, un símbolo
     con unidades declaradas a través de 'declare_units' o una expresión
     que contenga a ambos.

     'fundamental_units()' devuelve una lista con las unidades
     fundamentales conocidas, tal como fueron declaradas por
     'declare_fundamental_units'.

     Para utilizar esta función ejecútese primero 'load(ezunits)'.

     Ejemplos:

          (%i1) load (ezunits)$
          (%i2) fundamental_units ();
          (%o2)                 [m, kg, s, A, K, mol]
          (%i3) fundamental_units (100 ` mile/hour);
                                          m
          (%o3)                           -
                                          s
          (%i4) declare_units (aa, g/foot^2);
                                          g
          (%o4)                         -----
                                            2
                                        foot
          (%i5) fundamental_units (aa);
                                         kg
          (%o5)                          --
                                          2
                                         m

 -- Función: dimensionless (<L>)

     Devuelve una expresión sin dimensiones que se puede formar a partir
     de una lista <L> de cantidades dimensionales

     Para utilizar esta función ejecútese primero 'load(ezunits)'.

     Ejemplos:

          (%i1) load (ezunits) $
          (%i2) dimensionless ([x ` m, y ` m/s, z ` s]);
          0 errors, 0 warnings
          0 errors, 0 warnings
                                         y z
          (%o2)                         [---]
                                          x

     Cantidades adimensionales obtenidas a partir de cantidades físicas.
     Nótese que el primer elemento de la lista es proporcional a la
     constante de estructura fina.

          (%i1) load (ezunits) $
          (%i2) load (physical_constants) $
          (%i3) dimensionless([%h_bar, %m_e, %m_P, %%e, %c, %e_0]);
          0 errors, 0 warnings
          0 errors, 0 warnings
                                        2
                                     %%e        %m_e
          (%o3)                [--------------, ----]
                                %c %e_0 %h_bar  %m_P

 -- Función: natural_unit (<expr>, [<v_1>, ..., <v_n>])

     Busca los exponentes <e_1>, ..., <e_n> tales que 'dimension(<expr>)
     = dimension(<v_1>^<e_1> ... <v_n>^<e_n>)'.

     Para utilizar esta función ejecútese primero 'load(ezunits)'.


File: maxima.info,  Node: f90,  Next: finance,  Prev: ezunits,  Up: Top

51 f90
******

* Menu:

* Funciones y variables para f90::


File: maxima.info,  Node: Funciones y variables para f90,  Prev: f90,  Up: f90

51.1 Funciones y variables para f90
===================================

 -- Función: f90 (<expr_1>, ..., <expr_n>)

     Imprime una o más expresiones <expr_1>, ..., <expr_n> como un
     programa Fortran 90.  El programa se obtiene a través de la salida
     estándar.

     La función 'f90' imprime su salida en el llamado formato libre de
     Fortran 90: no se presta atención alguna a las posiciones de
     caracteres respecto de las columnas y los renglones largos se
     dividen a un ancho fijo con el carácter '&' indicando continuación
     de código.

     Ejecútese 'load(f90)' antes de utilizar esta función.

     Véase también 'fortran'.

     Ejemplos:

          (%i1) load (f90)$
          (%i2) foo : expand ((xxx + yyy + 7)^4);
                   4            3         3        2    2             2
          (%o2) yyy  + 4 xxx yyy  + 28 yyy  + 6 xxx  yyy  + 84 xxx yyy
                    2        3             2
           + 294 yyy  + 4 xxx  yyy + 84 xxx  yyy + 588 xxx yyy + 1372 yyy
                4         3          2
           + xxx  + 28 xxx  + 294 xxx  + 1372 xxx + 2401
          (%i3) f90 ('foo = foo);
          foo = yyy**4+4*xxx*yyy**3+28*yyy**3+6*xxx**2*yyy**2+84*xxx*yyy**2&
          +294*yyy**2+4*xxx**3*yyy+84*xxx**2*yyy+588*xxx*yyy+1372*yyy+xxx**&
          4+28*xxx**3+294*xxx**2+1372*xxx+2401
          (%o3)                         false

     Expresiones múltiples.  Captura de la salida estándar a un fichero
     por medio de la función 'with_stdout'.

          (%i1) load (f90)$
          (%i2) foo : sin (3*x + 1) - cos (7*x - 2);
          (%o2)              sin(3 x + 1) - cos(7 x - 2)
          (%i3) with_stdout ("foo.f90",
                             f90 (x=0.25, y=0.625, 'foo=foo, 'stop, 'end));
          (%o3)                         false
          (%i4) printfile ("foo.f90");
          x = 0.25
          y = 0.625
          foo = sin(3*x+1)-cos(7*x-2)
          stop
          end
          (%o4)                        foo.f90


File: maxima.info,  Node: finance,  Next: fractals,  Prev: f90,  Up: Top

52 finance
**********

* Menu:

* Introducción a finance::
* Funciones y Variables para finance::


File: maxima.info,  Node: Introducción a finance,  Next: Funciones y Variables para finance,  Prev: finance,  Up: finance

52.1 Introducción a finance
===========================

Este es el Paquete "Finance" (Ver 0.1).

En todas las funciones, <rate> es la tasa de interés compuesto, <num> es
el número de periodos y debe ser positivo, y <flow> se refiere al flujo
de caja; entonces, si se tiene un egreso el flujo es negativo y para un
ingreso un valor positivo.

Note que antes de usar las funciones definidas en este paquete, debe
cargarla escribiendo 'load(finance)$'.

Autor: Nicolás Guarin Zapata.


File: maxima.info,  Node: Funciones y Variables para finance,  Prev: Introducción a finance,  Up: finance

52.2 Funciones y Variables para finance
=======================================

 -- Function: days360 (<año1>,<mes1>,<dia1>,<año2>,<mes2>,<dia2>)

     Calcula la distancia entre 2 fechas, asumiendo años de 360 dias y
     meses de 30 días.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) days360(2008,12,16,2007,3,25);
          (%o2)                      - 621

 -- Function: fv (<rate>,<PV>,<num>)

     Calcular el Valor Futuro a partir de uno en el Presente para una
     tasa de interés dada.  <rate> es la tasa de interés, <PV> es el
     valor prestente y <num> es el número de periodos.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) fv(0.12,1000,3);
          (%o2)                     1404.928

 -- Function: pv (<rate>,<FV>,<num>)

     Calcula el valor actual de un valor futuro dada la tasa de interés.
     <rate> es la tasa de interés, <FV> es el valor futuro y <num> es el
     número de periodos.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) pv(0.12,1000,3);
          (%o2)                711.7802478134108

 -- Function: graph_flow (<val>)

     Grafica el flujo de caja en una línea de tiempo, los valores
     positivos están en azul y hacia arriba; los negativos están en rojo
     y hacia abajo.  La dirección del flujo está dada por el signo de
     los valores.  <val> es una lista de los valores del flujo de caja.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) graph_flow([-5000,-3000,800,1300,1500,2000])$

 -- Function: annuity_pv (<rate>,<PV>,<num>)

     Calcula una anualidad conociendo el valor presente (tipo deuda),
     para unos pagos periódicos y constantes.  <rate> es la tasa de
     interés, <PV> es el valor presente y <num> es el número de
     periodos.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) annuity_pv(0.12,5000,10);
          (%o2)                884.9208207992202

 -- Function: annuity_fv (<rate>,<FV>,<num>)

     Calcula una anualidad conociendo el valor deseado (valor futuro),
     para una serie de pagos periódicos y constantes.  <rate> es la tasa
     de interés, <FV> es el valor futuroe y <num> es el número de
     periodos.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) annuity_fv(0.12,65000,10);
          (%o2)                3703.970670389863

 -- Function: geo_annuity_pv (<rate>,<growing_rate>,<PV>,<num>)

     Calcula una anualidad conociendo el valor presente (tipo deuda) en
     una serie de pagos periodicos crecientes.  <rate> es la tasa de
     interés, <growing_rate> es el crecimiento de los pagos, <PV> es el
     valor presente, y <num> es el número de periodos.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) geo_annuity_pv(0.14,0.05,5000,10);
          (%o2)                802.6888176505123

 -- Function: geo_annuity_fv (<rate>,<growing_rate>,<FV>,<num>)

     Calcular una anualidad conociendo el valor deseado (valor futuro)
     en una serie de pagos periodicos crecientes.  <rate> es la tasa de
     interés, <growing_rate> es el crecimiento de los pagos, <FV> es el
     valor futuro, y <num> es el número de periodos.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) geo_annuity_fv(0.14,0.05,5000,10);
          (%o2)                216.5203395312695

 -- Function: amortization (<rate>,<amount>,<num>)

     La tabla de amortización determinada por una tasa.  Siendo <rate>
     es la tasa de interés, <amount> es el valor de la deuda, and <num>
     es el número de periodos.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) amortization(0.05,56000,12)$
                "n"    "Balance"     "Interest"   "Amortization"  "Payment"
               0.000     56000.000         0.000         0.000         0.000
               1.000     52481.777      2800.000      3518.223      6318.223
               2.000     48787.643      2624.089      3694.134      6318.223
               3.000     44908.802      2439.382      3878.841      6318.223
               4.000     40836.019      2245.440      4072.783      6318.223
               5.000     36559.597      2041.801      4276.422      6318.223
               6.000     32069.354      1827.980      4490.243      6318.223
               7.000     27354.599      1603.468      4714.755      6318.223
               8.000     22404.106      1367.730      4950.493      6318.223
               9.000     17206.088      1120.205      5198.018      6318.223
              10.000     11748.170       860.304      5457.919      6318.223
              11.000      6017.355       587.408      5730.814      6318.223
              12.000         0.000       300.868      6017.355      6318.223

 -- Function: arit_amortization (<rate>,<increment>,<amount>,<num>)

     La tabla de amortización determinada por una tasa específica y unos
     pagos crecientes se puede hallar con 'arit_amortization'.  Nótese
     que los pagos no son constantes, estos presentan un crecimiento
     aritmético, el incremento es la diferencia entre dos filas
     consecutivas en la columna "Payment".  <rate> es la tasa de
     interés, <increment> es el incremento, <amount> es el valor de la
     deuda, and <num> es el número de periodos.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) arit_amortization(0.05,1000,56000,12)$
                "n"    "Balance"     "Interest"   "Amortization"  "Payment"
               0.000     56000.000         0.000         0.000         0.000
               1.000     57403.679      2800.000     -1403.679      1396.321
               2.000     57877.541      2870.184      -473.863      2396.321
               3.000     57375.097      2893.877       502.444      3396.321
               4.000     55847.530      2868.755      1527.567      4396.321
               5.000     53243.586      2792.377      2603.945      5396.321
               6.000     49509.443      2662.179      3734.142      6396.321
               7.000     44588.594      2475.472      4920.849      7396.321
               8.000     38421.703      2229.430      6166.892      8396.321
               9.000     30946.466      1921.085      7475.236      9396.321
              10.000     22097.468      1547.323      8848.998     10396.321
              11.000     11806.020      1104.873     10291.448     11396.321
              12.000        -0.000       590.301     11806.020     12396.321

 -- Function: geo_amortization (<rate>,<growing_rate>,<amount>,<num>)

     La tabla de amortización determinada por la tasa, el valor de la
     deuda, y el número de periodos se puede hallar con
     'geo_amortization'.  Nótese que los pagos no son constantes, estos
     presentan un crecimiento geométrico, growin_rate es entonces el
     cociente entre dos filas consecutivas de la columna "Payment".
     <rate> es la tasa de interés, <growing_rate> es el crecimeinto de
     los pagos, <amount> es el valor de la deuda, y <num> es el numero
     de periodos.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) geo_amortization(0.05,0.03,56000,12)$
                "n"    "Balance"     "Interest"   "Amortization"  "Payment"
               0.000     56000.000         0.000         0.000         0.000
               1.000     53365.296      2800.000      2634.704      5434.704
               2.000     50435.816      2668.265      2929.480      5597.745
               3.000     47191.930      2521.791      3243.886      5765.677
               4.000     43612.879      2359.596      3579.051      5938.648
               5.000     39676.716      2180.644      3936.163      6116.807
               6.000     35360.240      1983.836      4316.475      6300.311
               7.000     30638.932      1768.012      4721.309      6489.321
               8.000     25486.878      1531.947      5152.054      6684.000
               9.000     19876.702      1274.344      5610.176      6884.520
              10.000     13779.481       993.835      6097.221      7091.056
              11.000      7164.668       688.974      6614.813      7303.787
              12.000         0.000       358.233      7164.668      7522.901

 -- Function: saving (<rate>,<amount>,<num>)

     La tabla que presenta los valores para un ahorro constante y
     periódico se pueden hallar con 'saving'.  <amount> representa la
     cantidad deseada y <num> el número de periodos durante los que se
     ahorrará.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) saving(0.15,12000,15)$
                "n"    "Balance"     "Interest"   "Payment"
               0.000         0.000         0.000         0.000
               1.000       252.205         0.000       252.205
               2.000       542.240        37.831       252.205
               3.000       875.781        81.336       252.205
               4.000      1259.352       131.367       252.205
               5.000      1700.460       188.903       252.205
               6.000      2207.733       255.069       252.205
               7.000      2791.098       331.160       252.205
               8.000      3461.967       418.665       252.205
               9.000      4233.467       519.295       252.205
              10.000      5120.692       635.020       252.205
              11.000      6141.000       768.104       252.205
              12.000      7314.355       921.150       252.205
              13.000      8663.713      1097.153       252.205
              14.000     10215.474      1299.557       252.205
              15.000     12000.000      1532.321       252.205

 -- Function: npv (<rate>,<val>)

     Calcular el valor presente neto de una serie de valores para
     evaluar la viabilidad de un proyecto.  <flowValues> es una lista
     con los valores para cada periodo.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) npv(0.25,[100,500,323,124,300]);
          (%o2)                714.4703999999999

 -- Function: irr (<val>,<IO>)

     Tasa interna de retorno (en inglés Internal Rate of Return - IRR),
     es el valor de tasa que hace que el Valor Presente Neto (NPV) sea
     cero.  <flowValues> los valores para cada periodo (para periodos
     mayores a 0) y <I0> el valor para el periodo cero.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) res:irr([-5000,0,800,1300,1500,2000],0)$
          (%i3) rhs(res[1][1]);
          (%o3)                .03009250374237132

 -- Function: benefit_cost (<rate>,<input>,<output>)

     Calcular la relación Beneficio/Costo, Beneficio es el Valor
     Presente Neto (NPV) de los flujos de caja positivos (inputs), y
     Costo es el Valor Presente Neto de los flujos de caja negativos
     (outputs).  Nótese que si se desea tener un valor de cero para un
     periodo especifico, esta entrada/salida debe indicarse como cero
     para ese periodo.  <rate> es la tasa de interés, <input> es una
     lista con los ingresos, y <output> es una lista con los egresos.

     Ejemplo:

          (%i1) load(finance)$
          (%i2) benefit_cost(0.24,[0,300,500,150],[100,320,0,180]);
          (%o2)               1.427249324905784


File: maxima.info,  Node: fractals,  Next: ggf,  Prev: finance,  Up: Top

53 fractals
***********

* Menu:

* Introducción a fractals::
* Definiciones para IFS fractals::
* Definiciones para fractales complejos::
* Definiciones para cops de Koch::
* Definiciones para curvas de Peano::


File: maxima.info,  Node: Introducción a fractals,  Next: Definiciones para IFS fractals,  Prev: fractals,  Up: fractals

53.1 Introducción a fractals
============================

Este paquete define algunos fractales:

- con IFS (Iterated Function System) aleatorias: triángulo de
Sierpinsky, un árbol y un helecho.

- Fractales complejos: conjuntos de Mandelbrot y de Julia.

- Copos de Koch.

- Funciones de Peano: funciones de Sierpinski y Hilbert.

Autor: José Rammírez Labrador.

Para preguntas, sugerencias y fallos,

pepe DOT ramirez AAATTT uca DOT es


File: maxima.info,  Node: Definiciones para IFS fractals,  Next: Definiciones para fractales complejos,  Prev: Introducción a fractals,  Up: fractals

53.2 Definiciones para IFS fractals
===================================

Algunos fractales se pueden generar por medio de la aplicación iterativa
de transformaciones afines contractivas de forma aleatoria; véase

Hoggar S. G., "Mathematics for computer graphics", Cambridge University
Press 1994.

Definimos una lista con varias transformaciones afines contractivas,
luego las vamos seleccionando de forma aleatoria y recursiva.  La
probabilidad de selección de una transformación debe estar relacionada
con la razón de contracción.

Se pueden cambiar las transformaciones y encontrar nuevos fractales.

 -- Función: sierpinskiale (<n>)

     Triángulo de Sierpinski: 3 aplicaciones contractivas; constante de
     contracción de 0.5 y traslaciones.  Todas las aplicaciones tienen
     la misma constante de contracción.  El argumento <n> debe ser
     suficientemente alto, 10000 o mayor.

     Ejemplo:

          (%i1) load(fractals)$
          (%i2) n: 10000$
          (%i3) plot2d([discrete,sierpinskiale(n)], [style,dots])$

 -- Función: treefale (<n>)

     3 aplicaciones contractivas, todas ellas con el mismo coeficiente
     de contracción.  El argumento <n> debe ser suficientemente alto,
     10000 o mayor.

     Ejemplo:

          (%i1) load(fractals)$
          (%i2) n: 10000$
          (%i3) plot2d([discrete,treefale(n)], [style,dots])$

 -- Función: fernfale (<n>)

     4 aplicaciones contractivas, cuyas probabilidades de selección
     deben estar relacionadas con su constante de contracción.  El
     argumento <n> debe ser suficientemente alto, 10000 o mayor.

     Ejemplo:

          (%i1) load(fractals)$
          (%i2) n: 10000$
          (%i3) plot2d([discrete,fernfale(n)], [style,dots])$


File: maxima.info,  Node: Definiciones para fractales complejos,  Next: Definiciones para cops de Koch,  Prev: Definiciones para IFS fractals,  Up: Top

53.3 Definiciones para fractales complejos
==========================================

 -- Función: mandelbrot_set (<x>, <y>)

     Conjunto de Mandelbrot.

     Esta función debe realizar muchas operaciones y puede tardar
     bastante tiempo en ejecutarse, tiempo que también depende del
     número de puntos de la malla.

     Ejemplo:

          (%i1) load(fractals)$
          (%i2) plot3d (mandelbrot_set, [x, -2.5, 1], [y, -1.5, 1.5],
                          [gnuplot_preamble, "set view map"],
                          [gnuplot_pm3d, true],
                          [grid, 150, 150])$

 -- Función: julia_set (<x>, <y>)

     Conjuntos de Julia.

     Esta función debe realizar muchas operaciones y puede tardar
     bastante tiempo en ejecutarse, tiempo que también depende del
     número de puntos de la malla.

     Ejemplo:

          (%i1) load(fractals)$
          (%i2) plot3d (julia_set, [x, -2, 1], [y, -1.5, 1.5],
                          [gnuplot_preamble, "set view map"],
                          [gnuplot_pm3d, true],
                          [grid, 150, 150])$

     Véase también 'julia_parameter'.

 -- Variable opcional: julia_parameter
     Valor por defecto: '%i'

     Parámetro complejo para fractales de Julia.  Su valor por defecto
     es '%i', y otros que se sugieren son: '-.745+%i*.113002',
     '-.39054-%i*.58679', '-.15652+%i*1.03225', '-.194+%i*.6557' y
     '.011031-%i*.67037'.

 -- Función: julia_sin (<x>, <y>)

     Mientras que la función 'julia_set' implementa la transformación
     'julia_parameter+z^2', la función 'julia_sin' implementa
     'julia_parameter*sin(z)'.  Véase el código fuente para más
     detalles.

     Este programa es lento porque calcula muchos senos; el tiempo de
     ejecución también depende del número de puntos de la malla.

     Ejemplo:

          (%i1) load(fractals)$
          (%i2) julia_parameter:1+.1*%i$
          (%i3) plot3d (julia_sin, [x, -2, 2], [y, -3, 3],
                          [gnuplot_preamble, "set view map"],
                          [gnuplot_pm3d, true],
                          [grid, 150, 150])$

     Véase también 'julia_parameter'.


File: maxima.info,  Node: Definiciones para cops de Koch,  Next: Definiciones para curvas de Peano,  Prev: Definiciones para fractales complejos,  Up: Top

53.4 Definiciones para cops de Koch
===================================

 -- Función: snowmap (<ent>, <nn>)

     Copos de Koch.  La función 'snowmap' dibuja el copo de Koch sobre
     los vértices de un polígono convexo inicial del plano complejo.  La
     orientación del polígono es importante.  El argumento <nn> es el
     número de recursividades de la transformación de Koch, el cual debe
     ser pequeño (5 o 6).

     Ejemplos:

          (%i1) load(fractals)$
          (%i2) plot2d([discrete,
                        snowmap([1,exp(%i*%pi*2/3),exp(-%i*%pi*2/3),1],4)])$
          (%i3) plot2d([discrete,
                        snowmap([1,exp(-%i*%pi*2/3),exp(%i*%pi*2/3),1],4)])$
          (%i4) plot2d([discrete, snowmap([0,1,1+%i,%i,0],4)])$
          (%i5) plot2d([discrete, snowmap([0,%i,1+%i,1,0],4)])$


File: maxima.info,  Node: Definiciones para curvas de Peano,  Prev: Definiciones para cops de Koch,  Up: fractals

53.5 Definiciones para curvas de Peano
======================================

Funciones continuas que cubren un área.  Aviso: el número de puntos
crece exponencialmente con <n>.

 -- Función: hilbertmap (<nn>)

     Curva de Hilbert.  El argumento <nn> debe ser pequeño (por ejemplo,
     5).  Maxima se puede detener si <nn> es 7 o mayor.

     Ejemplo:

          (%i1) load(fractals)$
          (%i2) plot2d([discrete,hilbertmap(6)])$

 -- Función: sierpinskimap (<nn>)

     Curva de Sierpinski.  El argumento <nn> debe ser pequeño (por
     ejemplo, 5).  Maxima se puede detener si <nn> es 7 o mayor.

     Ejemplo:

          (%i1) load(fractals)$
          (%i2) plot2d([discrete,sierpinskimap(6)])$


File: maxima.info,  Node: ggf,  Next: graphs,  Prev: fractals,  Up: Top

54 ggf
******

* Menu:

* Funciones y variables para ggf::


File: maxima.info,  Node: Funciones y variables para ggf,  Prev: ggf,  Up: ggf

54.1 Funciones y variables para ggf
===================================

 -- Variable opcional: GGFINFINITY
     Valor por defecto: 3

     Variable opcional para la función 'ggf'.

     Cuando se calcula la fracción continua de la función generatriz, si
     un cociente parcial tiene grado estrictamente mayor que
     <GGFINFINITY> será descartado y la convergencia alcanzada hasta ese
     momento será considerada como exacta para la función generatriz.
     Lo más frecuente es que el grado de todos los cocientes parciales
     sea 0 ó 1, de modo que si se utiliza un valor mayor se deberán dar
     más términos para conseguir un cálculo más exacto.

     Véase también 'ggf'.

 -- Variable opcional: GGFCFMAX
     Valor por defeco: 3

     Variable opcional para la función 'ggf'.

     Cuando se calcula la fracción continua de la función generatriz, si
     no se ha encontrado un resultado aceptable (véase la variable
     <GGFINFINITY>) después de haber calculado <GGFCFMAX> cocientes
     parciales, la función generatriz será considerada no equivalente a
     una fracción racional y la función 'ggf' se detendrá.  Puede
     asignársele a <GGFCFMAX> un valor mayor para funciones generatrices
     más complicadas.

     Véase también 'ggf'.

 -- Función: ggf (<l>)
     Calcula la función generatriz de una sucesión de la que se
     suministran tan solo los primeros valores y cuyo término general es
     una fracción algebraica (cociente de dos polinomios).

     La solución se devuelve como una fracción de polinomios.  En caso
     de no poder encontrar una solución, se devuelve 'done'.

     Esta función está controlada por las variables globales
     <GGFINFINITY> y <GGFCFMAX>.  Véanse también <GGFINFINITY> y
     <GGFCFMAX>.

     Antes de hacer uso de esta función ejecútese 'load("ggf")'.


File: maxima.info,  Node: graphs,  Next: grobner,  Prev: ggf,  Up: Top

55 graphs
*********

* Menu:

* Introducción a graphs::
* Funciones y variables para graphs::


File: maxima.info,  Node: Introducción a graphs,  Next: Funciones y variables para graphs,  Prev: graphs,  Up: graphs

55.1 Introducción a graphs
==========================

El paquete 'graphs' permite trabajar con estructuras de grafos y
digrafos en Maxima.  Tanto los grafos como los digrafos son de
estructura simples (no tienen ni aristas mÃºltiples ni bucles), pero los
digrafos pueden tener una arista dirigida desde <u> hasta <v> y otra
desde <v> hasta <u>.

Los grafos se representan internamente como listas de adyacencia y se
implementan como estructuras de lisp.  Los vértices se identifican por
sus números de identificacin' (siempre enteros).  Las aristas/arcos se
representan por listas de longitud 2.  Se pueden asignar etiquetas a los
vértices de los grafos/digrafos y pesos a sus aristas/arcos.

La función 'draw_graph' dibuja grafos siguiendo un criterio rígido de
posicionamiento de los vértices.  También puede hacer uso del programa
graphviz disponible en <http://www.graphviz.org>.  La función
'draw_graph' utiliza el paquete 'draw' de Maxima.

Para hacer uso de este paquete, ejecútese primero 'load(graphs)'.


File: maxima.info,  Node: Funciones y variables para graphs,  Prev: Introducción a graphs,  Up: graphs

55.2 Funciones y variables para graphs
======================================

55.2.1 Construyendo grafos
--------------------------

 -- Función: create_graph (<v_list>, <e_list>)
 -- Función: create_graph (<n>, <e_list>)
 -- Función: create_graph (<v_list>, <e_list>, <directed>)

     Crea un nuevo grafo sobre el conjunto de vértices <v_list> con
     aristas <e_list>.

     <v_list> es una lista de vértices ('[v1, v2,..., vn]') o una lista
     de vértices junto con sus respectivas etiquetas ('[[v1,l1],
     [v2,l2],..., [vn,ln]]').

     <n> es el número de vértices, los cuales se identificarán desde 0
     hasta n-1.

     <e_list> es una lista de aristas ('[e1, e2,..., em]') o una lista
     de aristas con sus respectivas ponderaciones ('[[e1, w1], ..., [em,
     wm]]').

     Si <directed> is not 'false', se devolverá un grafo orientado.

     Ejemplos:

     Crea un ciclo de 3 vértices.

          (%i1) load (graphs)$
          (%i2) g : create_graph([1,2,3], [[1,2], [2,3], [1,3]])$
          (%i3) print_graph(g)$
          Graph on 3 vertices with 3 edges.
          Adjacencies:
            3 :  1  2
            2 :  3  1
            1 :  3  2

     Crea un ciclo de 3 vértices y aristas ponderadas:

          (%i1) load (graphs)$
          (%i2) g : create_graph([1,2,3], [[[1,2], 1.0], [[2,3], 2.0],
                                          [[1,3], 3.0]])$
          (%i3) print_graph(g)$
          Graph on 3 vertices with 3 edges.
          Adjacencies:
            3 :  1  2
            2 :  3  1
            1 :  3  2

     Crea un grafo orientado:

          (%i1) load (graphs)$
          (%i2) d : create_graph(
                 [1,2,3,4],
                 [
                  [1,3], [1,4],
                  [2,3], [2,4]
                 ],
                 'directed = true)$
          (%i3) print_graph(d)$
          Digraph on 4 vertices with 4 arcs.
          Adjacencies:
            4 :
            3 :
            2 :  4  3
            1 :  4  3

 -- Función: copy_graph (<g>)
     Devuelve una copia del grafo <g>.

 -- Función: circulant_graph (<n>, <d>)
     Devuelve un grafo cirlulante de parámetros <n> y <d>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : circulant_graph(10, [1,3])$
          (%i3) print_graph(g)$
          Graph on 10 vertices with 20 edges.
          Adjacencies:
            9 :  2  6  0  8
            8 :  1  5  9  7
            7 :  0  4  8  6
            6 :  9  3  7  5
            5 :  8  2  6  4
            4 :  7  1  5  3
            3 :  6  0  4  2
            2 :  9  5  3  1
            1 :  8  4  2  0
            0 :  7  3  9  1

 -- Función: clebsch_graph ()
     Devuelve el grafo de Clebsch.

 -- Función: complement_graph (<g>)
     Devuelve el complemento del grafo <g>.

 -- Función: complete_bipartite_graph (<n>, <m>)
     Devuelve el grafo bipartido completo de <n+m> vértices.

 -- Función: complete_graph (<n>)
     Devuelve el grafo completo de <n> vértices.

 -- Función: cycle_digraph (<n>)
     Devuelve el ciclo dirigido de <n> vértices.

 -- Función: cycle_graph (<n>)
     Devuelve el ciclo de <n> vértices.

 -- Función: cuboctahedron_graph (<n>)
     Devuelve el grafo cubooctaédrico.

 -- Función: cube_graph (<n>)
     Devuelve el cubo de <n> dimensiones.

 -- Función: dodecahedron_graph ()
     Devuelve el grafo del dodecaedro.

 -- Función: empty_graph (<n>)
     Devuelve el grafo vacío de <n> vértices.

 -- Función: flower_snark (<n>)
     Devuelve el grafo de flor de <4n> vértices.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) f5 : flower_snark(5)$
          (%i3) chromatic_index(f5);
          (%o3)                                  4

 -- Función: from_adjacency_matrix (<A>)
     Devuelve el grafo definido por la matriz de adyacencia <A>.

 -- Función: frucht_graph ()
     Devuelve el grafo de Frucht.

 -- Función: graph_product (<g1>, <g1>)
     Devuelve el producto dirigido de los grafos <g1> y <g2>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) grid : graph_product(path_graph(3), path_graph(4))$
          (%i3) draw_graph(grid)$

 -- Función: graph_union (<g1>, <g1>)
     Devuelve la unión (suma) de los grafos <g1> y <g2>.

 -- Función: grid_graph (<n>, <m>)
     Devuelve la rejilla <n x m>.

 -- Función: great_rhombicosidodecahedron_graph ()
     Devuelve el grafo gran rombicosidodecaédrico.

 -- Función: great_rhombicuboctahedron_graph ()
     Devuelve el grafo gran rombicocubicooctaédrico.

 -- Función: grotzch_graph ()
     Devuelve el grafo de Grotzch.

 -- Función: heawood_graph ()
     Devuelve el grafo de Heawood.

 -- Función: icosahedron_graph ()
     Devuelve el grafo icosaédrico.

 -- Función: icosidodecahedron_graph ()
     Devuelve el grafo icosidodecaédrico.

 -- Función: induced_subgraph (<V>, <g>)
     Devuelve el grafo inducido por el subconjunto <V> de vértices del
     grafo <g>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) V : [0,1,2,3,4]$
          (%i4) g : induced_subgraph(V, p)$
          (%i5) print_graph(g)$
          Graph on 5 vertices with 5 edges.
          Adjacencies:
            4 :  3  0
            3 :  2  4
            2 :  1  3
            1 :  0  2
            0 :  1  4

 -- Función: line_graph (<g>)
     Devuelve el grafo de línea del grafo <g>.

 -- Función: make_graph (<vrt>, <f>)
 -- Función: make_graph (<vrt>, <f>, <oriented>)
     Crea un grafo por medio de la función de predicado <f>.

     <vrt> es una lista o conjunto de vértices o un simplemente un
     número entero.  Si <vrt> es un número entero, entonces los vértices
     del grafo serán los enteros desde 1 hasta <vrt>.

     <f> es una función de predicado.  Dos vértices <a> y <b> se
     conectarán si 'f(a,b)=true'.

     Si <directed> no es <false>, entonces en grafo será dirigido.

     Ejemplo 1:
          (%i1) load(graphs)$
          (%i2) g : make_graph(powerset({1,2,3,4,5}, 2), disjointp)$
          (%i3) is_isomorphic(g, petersen_graph());
          (%o3)                         true
          (%i4) get_vertex_label(1, g);
          (%o4)                        {1, 2}

     Ejemplo 2:
          (%i1) load(graphs)$
          (%i2) f(i, j) := is (mod(j, i)=0)$
          (%i3) g : make_graph(20, f, directed=true)$
          (%i4) out_neighbors(4, g);
          (%o4)                    [8, 12, 16, 20]
          (%i5) in_neighbors(18, g);
          (%o5)                    [1, 2, 3, 6, 9]

 -- Función: mycielski_graph (<g>)
     Devuelve el grafo de Mycielski del grafo <g>.

 -- Función: new_graph ()
     Devuelve el grafo sin vértices ni aristas.

 -- Función: path_digraph (<n>)
     Devuelve el camino dirigido de <n> vértices.

 -- Función: path_graph (<n>)
     Devuelve el camino de <n> vértices.

 -- Función: petersen_graph ()
 -- Función: petersen_graph (<n>, <d>)
     Devuelve el grafo de Petersen <P_{n,d}>.  Los valores por defecto
     para <n> y <d> son 'n=5' y 'd=2'.

 -- Función: random_bipartite_graph (<a>, <b>, <p>)
     Devuelve un grafo aleatorio bipartido a partir de los vértices
     'a+b'.  Cada arista se genera con probabilidad <p>.

 -- Función: random_digraph (<n>, <p>)
     Devuelve un grafo aleatorio dirigido de <n> vértices.  Cada arco se
     presenta con una probabilidad <p>.

 -- Función: random_regular_graph (<n>)
 -- Función: random_regular_graph (<n>, <d>)
     Devuelve un grafo aleatorio <d>-regular de <n> vértices.  El valor
     por defecto para <d> es 'd=3'.

 -- Función: random_graph (<n>, <p>)
     Devuelve un grafo aleatorio de <n> vértices.  Cada arco se presenta
     con una probabilidad <p>.

 -- Función: random_graph1 (<n>, <m>)
     Devuelve un grafo aleatorio de <n> vértices y <m> arcos aleatorios.

 -- Función: random_network (<n>, <p>, <w>)
     Devuelve una red aleatoria de <n> vértices.  Cada arco se presenta
     con probabilidad <p> y tiene un peso dentro del rango '[0,w]'.  La
     función devuelve una lista '[network, source, sink]'.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) [net, s, t] : random_network(50, 0.2, 10.0);
          (%o2)                         [DIGRAPH, 50, 51]
          (%i3) max_flow(net, s, t)$
          (%i4) first(%);
          (%o4)                   27.65981397932507

 -- Función: random_tournament (<n>)
     Devuelve un torneo aleatorio de <n> vértices.

 -- Función: random_tree (<n>)
     Devuelve un árbol aleatorio de <n> vértices.

 -- Función: small_rhombicosidodecahedron_graph ()
     Devuelve el grafo pequeño rombicosidodecaédrico.

 -- Función: small_rhombicuboctahedron_graph ()
     Devuelve el grafo pequeño rombicocubicooctaédrico.

 -- Función: snub_cube_graph ()
     Devuelve el grafo cúbico volteado.

 -- Función: snub_dodecahedron_graph ()
     Devuelve el grafo dodecaédrico volteado.

 -- Función: truncated_cube_graph ()
     Devuelve el grafo cúbico truncado.

 -- Función: truncated_dodecahedron_graph ()
     Devuelve el grafo dodecaédrico truncado.

 -- Función: truncated_icosahedron_graph ()
     Devuelve el grafo icosaédrico truncado.

 -- Función: truncated_tetrahedron_graph ()
     Devuelve el grafo del tetraedro truncado.

 -- Función: tutte_graph ()
     Devuelve el grafo de Tutte.

 -- Función: underlying_graph (<g>)
     Devuelve el grafo asociado al grafo orientado <g>.

 -- Función: wheel_graph (<n>)
     Devuelve el grafo de rueda de <n+1> vértices.

55.2.2 Propiedades de los grafos
--------------------------------

 -- Función: adjacency_matrix (<gr>)
     Devuelve la matriz de adyacencia del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) c5 : cycle_graph(4)$
          (%i3) adjacency_matrix(c5);
                                          [ 0  1  0  1 ]
                                          [            ]
                                          [ 1  0  1  0 ]
          (%o3)                           [            ]
                                          [ 0  1  0  1 ]
                                          [            ]
                                          [ 1  0  1  0 ]

 -- Función: average_degree (<gr>)
     Devuelve el grado medio de los vértices del garfo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) average_degree(grotzch_graph());
                                                40
          (%o2)                                 --
                                                11

 -- Función: biconnected_components (<gr>)
     Devuelve los subconjuntos de vértices biconectados del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : create_graph(
                      [1,2,3,4,5,6,7],
                      [
                       [1,2],[2,3],[2,4],[3,4],
                       [4,5],[5,6],[4,6],[6,7]
                      ])$
          (%i3) biconnected_components(g);
          (%o3)               [[6, 7], [4, 5, 6], [1, 2], [2, 3, 4]]

 -- Función: bipartition (<gr>)
     Devuelve una bipartición de los vértices del grafo <gr>, o una
     lista vacía si <gr> no es bipartido.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) h : heawood_graph()$
          (%i3) [A,B]:bipartition(h);
          (%o3)         [[8, 12, 6, 10, 0, 2, 4], [13, 5, 11, 7, 9, 1, 3]]
          (%i4) draw_graph(h, show_vertices=A, program=circular)$

 -- Función: chromatic_index (<gr>)
     Devuelve el índice cromático del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) chromatic_index(p);
          (%o3)                                  4

 -- Función: chromatic_number (<gr>)
     Devuelve el número cromático del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) chromatic_number(cycle_graph(5));
          (%o2)                                  3
          (%i3) chromatic_number(cycle_graph(6));
          (%o3)                                  2

 -- Función: clear_edge_weight (<e>, <gr>)
     Elimina el peso del arco <e> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : create_graph(3, [[[0,1], 1.5], [[1,2], 1.3]])$
          (%i3) get_edge_weight([0,1], g);
          (%o3)                                 1.5
          (%i4) clear_edge_weight([0,1], g)$
          (%i5) get_edge_weight([0,1], g);
          (%o5)                                  1

 -- Función: clear_vertex_label (<v>, <gr>)
     Elimina la etiqueta del vértice <v> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : create_graph([[0,"Zero"], [1, "One"]], [[0,1]])$
          (%i3) get_vertex_label(0, g);
          (%o3)                               Zero
          (%i4) clear_vertex_label(0, g);
          (%o4)                               done
          (%i5) get_vertex_label(0, g);
          (%o5)                               false

 -- Función: connected_components (<gr>)
     Devuelve las componentes conexas del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g: graph_union(cycle_graph(5), path_graph(4))$
          (%i3) connected_components(g);
          (%o3)                  [[1, 2, 3, 4, 0], [8, 7, 6, 5]]

 -- Función: diameter (<gr>)
     Devuelve el diámetro del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) diameter(dodecahedron_graph());
          (%o2)                                 5

 -- Función: edge_coloring (<gr>)
     Devuelve una coloración óptima de los arcos del grafo <gr>.

     La función devuelve el índice cromático y una lista que representa
     el coloreado de los arcos de <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) [ch_index, col] : edge_coloring(p);
          (%o3) [4, [[[0, 5], 3], [[5, 7], 1], [[0, 1], 1], [[1, 6], 2],
          [[6, 8], 1], [[1, 2], 3], [[2, 7], 4], [[7, 9], 2], [[2, 3], 2],
          [[3, 8], 3], [[5, 8], 2], [[3, 4], 1], [[4, 9], 4], [[6, 9], 3],
          [[0, 4], 2]]]
          (%i4) assoc([0,1], col);
          (%o4)                           1
          (%i5) assoc([0,5], col);
          (%o5)                           3

 -- Función: degree_sequence (<gr>)
     Devuelve una lista con los grados de los vértices del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) degree_sequence(random_graph(10, 0.4));
          (%o2)            [2, 2, 2, 2, 2, 2, 3, 3, 3, 3]

 -- Función: edge_connectivity (<gr>)
     Devuelve la conectividad de las aristas del grafo <gr>.

     Véase también 'min_edge_cut'.

 -- Función: edges (<gr>)
     Devuelve la lista de las aristas (arcos) del grafo (dirigido) <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) edges(complete_graph(4));
          (%o2)         [[2, 3], [1, 3], [1, 2], [0, 3], [0, 2], [0, 1]]

 -- Función: get_edge_weight (<e>, <gr>)
 -- Función: get_edge_weight (<e>, <gr>, <ifnot>)
     Devuelve el peso de la arista <e> del grafo <gr>.

     Si la arista no tiene peso, la función devuelve 1.  Si la arista no
     pertenece al grafo, la función emite un mensaje de error o devuelve
     el argumento opcional <ifnot>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) c5 : cycle_graph(5)$
          (%i3) get_edge_weight([1,2], c5);
          (%o3)                                 1
          (%i4) set_edge_weight([1,2], 2.0, c5);
          (%o4)                               done
          (%i5) get_edge_weight([1,2], c5);
          (%o5)                                2.0

 -- Función: get_vertex_label (<v>, <gr>)
     Devuelve la etiqueta del vértice <v> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : create_graph([[0,"Zero"], [1, "One"]], [[0,1]])$
          (%i3) get_vertex_label(0, g);
          (%o3)                               Zero

 -- Función: graph_charpoly (<gr>, <x>)
     Devuelve el polinomio característico (de variable <x>) del grafo
     <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) graph_charpoly(p, x), factor;
                                                   5        4
          (%o3)                     (x - 3) (x - 1)  (x + 2)

 -- Función: graph_center (<gr>)
     Devuelve el centro del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : grid_graph(5,5)$
          (%i3) graph_center(g);
          (%o3)                               [12]

 -- Función: graph_eigenvalues (<gr>)
     Devuelve los valores propios del grafo <gr>.  La función devuelve
     los valores propios en el mismo formato en el que lo hace la
     función 'eigenvalue'.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) graph_eigenvalues(p);
          (%o3)                     [[3, - 2, 1], [1, 4, 5]]

 -- Función: graph_periphery (<gr>)
     Devuelve la periferia del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : grid_graph(5,5)$
          (%i3) graph_periphery(g);
          (%o3)                          [24, 20, 4, 0]

 -- Función: graph_size (<gr>)
     Devuelve el número de aristas del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) graph_size(p);
          (%o3)                                15

 -- Función: graph_order (<gr>)
     Devuelve el número de vértices del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) graph_order(p);
          (%o3)                                10

 -- Función: girth (<gr>)
     Devuelve la longitud del ciclo más corto del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : heawood_graph()$
          (%i3) girth(g);
          (%o3)                                 6

 -- Función: hamilton_cycle (<gr>)
     Devuelve el ciclo de Hamilton del grafo <gr> o una lista vacía si
     <gr> no es hamiltoniano.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) c : cube_graph(3)$
          (%i3) hc : hamilton_cycle(c);
          (%o3)              [7, 3, 2, 6, 4, 0, 1, 5, 7]
          (%i4) draw_graph(c, show_edges=vertices_to_cycle(hc))$

 -- Función: hamilton_path (<gr>)
     Devuelve el camino de Hamilton del grafo <gr> o una lista vacía si
     <gr> no los tiene.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) hp : hamilton_path(p);
          (%o3)                  [0, 5, 7, 2, 1, 6, 8, 3, 4, 9]
          (%i4) draw_graph(p, show_edges=vertices_to_path(hp))$

 -- Función: isomorphism (<gr1>, <gr2>)
     Devuelve un isomorfismo entre los grafos/digrafos <gr1> y <gr2>.
     Si <gr1> y <gr2> no son isomorfos, devuelve una lista vacía.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) clk5:complement_graph(line_graph(complete_graph(5)))$
          (%i3) isomorphism(clk5, petersen_graph());
          (%o3) [9 -> 0, 2 -> 1, 6 -> 2, 5 -> 3, 0 -> 4, 1 -> 5, 3 -> 6,
                                                    4 -> 7, 7 -> 8, 8 -> 9]

 -- Función: in_neighbors (<v>, <gr>)
     Devuelve la lista de los nodos hijos del vértice <v> del grafo
     orientado <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : path_digraph(3)$
          (%i3) in_neighbors(2, p);
          (%o3)                                 [1]
          (%i4) out_neighbors(2, p);
          (%o4)                                 []

 -- Función: is_biconnected (<gr>)
     Devuelve 'true' si <gr> está biconectado y 'false' en caso
     contrario.

     Ejemplo:

     Example:
          (%i1) load (graphs)$
          (%i2) is_biconnected(cycle_graph(5));
          (%o2)                         true
          (%i3) is_biconnected(path_graph(5));
          (%o3)                         false

 -- Función: is_bipartite (<gr>)
     Devuelve 'true' si <gr> es bipartido (2-coloreable) y 'false' en
     caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_bipartite(petersen_graph());
          (%o2)                               false
          (%i3) is_bipartite(heawood_graph());
          (%o3)                               true

 -- Función: is_connected (<gr>)
     Devuelve 'true' si el grafo <gr> es conexo y 'false' en caso
     contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_connected(graph_union(cycle_graph(4), path_graph(3)));
          (%o2)                               false

 -- Función: is_digraph (<gr>)
     Devuelve 'true' si <gr> es un grafo orientado (digrafo) y 'false'
     en caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_digraph(path_graph(5));
          (%o2)                               false
          (%i3) is_digraph(path_digraph(5));
          (%o3)                               true

 -- Función: is_edge_in_graph (<e>, <gr>)
     Devuelve 'true' si <e> es una arista (arco) del grafo (digrafo) <g>
     y 'false' en caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) c4 : cycle_graph(4)$
          (%i3) is_edge_in_graph([2,3], c4);
          (%o3)                               true
          (%i4) is_edge_in_graph([3,2], c4);
          (%o4)                               true
          (%i5) is_edge_in_graph([2,4], c4);
          (%o5)                               false
          (%i6) is_edge_in_graph([3,2], cycle_digraph(4));
          (%o6)                               false

 -- Función: is_graph (<gr>)
     Devuelve 'true' si <gr> es un grafo y 'false' en caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_graph(path_graph(5));
          (%o2)                               true
          (%i3) is_graph(path_digraph(5));
          (%o3)                               false

 -- Función: is_graph_or_digraph (<gr>)
     Devuelve 'true' si <gr> es una grafo, orientado o no, y 'false' en
     caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_graph_or_digraph(path_graph(5));
          (%o2)                               true
          (%i3) is_graph_or_digraph(path_digraph(5));
          (%o3)                               true

 -- Función: is_isomorphic (<gr1>, <gr2>)
     Devuelve 'true' si los grafos/digrafos <gr1> y <gr2> son isomorfos
     y 'false' en caso contrario.

     Véase también 'isomorphism'.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) clk5:complement_graph(line_graph(complete_graph(5)))$
          (%i3) is_isomorphic(clk5, petersen_graph());
          (%o3)                         true

 -- Función: is_planar (<gr>)
     Devuelve 'true' si <gr> es un grafo planar y 'false' en caso
     contrario.

     El algoritmo utilizado es el de Demoucron, que es de tiempo
     cuadrático.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_planar(dodecahedron_graph());
          (%o2)                                true
          (%i3) is_planar(petersen_graph());
          (%o3)                                false
          (%i4) is_planar(petersen_graph(10,2));
          (%o4)                                true

 -- Función: is_sconnected (<gr>)
     Devuelve 'true' si el grafo orientado <gr> es fuertemente conexo,
     devolviendo 'false' en caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_sconnected(cycle_digraph(5));
          (%o2)                               true
          (%i3) is_sconnected(path_digraph(5));
          (%o3)                               false

 -- Función: is_vertex_in_graph (<v>, <gr>)
     Devuelve 'true' si <v> es un vértice del grafo <g> y 'false' en
     caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) c4 : cycle_graph(4)$
          (%i3) is_vertex_in_graph(0, c4);
          (%o3)                               true
          (%i4) is_vertex_in_graph(6, c4);
          (%o4)                               false

 -- Función: is_tree (<gr>)
     Devuelve 'true' si <gr> es un árbol y 'false' en caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_tree(random_tree(4));
          (%o2)                               true
          (%i3) is_tree(graph_union(random_tree(4), random_tree(5)));
          (%o3)                               false

 -- Función: laplacian_matrix (<gr>)
     Devuelve el laplaciano de la matriz del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) laplacian_matrix(cycle_graph(5));
                                    [  2   - 1   0    0   - 1 ]
                                    [                         ]
                                    [ - 1   2   - 1   0    0  ]
                                    [                         ]
          (%o2)                     [  0   - 1   2   - 1   0  ]
                                    [                         ]
                                    [  0    0   - 1   2   - 1 ]
                                    [                         ]
                                    [ - 1   0    0   - 1   2  ]

 -- Función: max_clique (<gr>)
     Devuelve el clique máximo del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : random_graph(100, 0.5)$
          (%i3) max_clique(g);
          (%o3)       [6, 12, 31, 36, 52, 59, 62, 63, 80]

 -- Función: max_degree (<gr>)
     Devuelve el grado máximo de los vértices del grafo <gr> y un
     vértice de grado máximo.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : random_graph(100, 0.02)$
          (%i3) max_degree(g);
          (%o3)                        [6, 79]
          (%i4) vertex_degree(95, g);
          (%o4)                           3

 -- Función: max_flow (<net>, <s>, <t>)
     Devuelve el flujo maximal de la red <net> con origen en <s> y final
     en <t>.

     La función devuelve el valor del flujo maximal y una lista con los
     pesos de los arcos del flujo óptimo.

     Ejemplo:

     Example:
          (%i1) load (graphs)$
          (%i2) net : create_graph(
            [1,2,3,4,5,6],
            [[[1,2], 1.0],
             [[1,3], 0.3],
             [[2,4], 0.2],
             [[2,5], 0.3],
             [[3,4], 0.1],
             [[3,5], 0.1],
             [[4,6], 1.0],
             [[5,6], 1.0]],
            directed=true)$
          (%i3) [flow_value, flow] : max_flow(net, 1, 6);
          (%o3) [0.7, [[[1, 2], 0.5], [[1, 3], 0.2], [[2, 4], 0.2],
          [[2, 5], 0.3], [[3, 4], 0.1], [[3, 5], 0.1], [[4, 6], 0.3],
          [[5, 6], 0.4]]]
          (%i4) fl : 0$
          (%i5) for u in out_neighbors(1, net)
                   do fl : fl + assoc([1, u], flow)$
          (%i6) fl;
          (%o6)                                 0.7

 -- Función: max_independent_set (<gr>)
     Devuelve un conjunto maximal independiente de vértices del grafo
     <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) d : dodecahedron_graph()$
          (%i3) mi : max_independent_set(d);
          (%o3)             [0, 3, 5, 9, 10, 11, 18, 19]
          (%i4) draw_graph(d, show_vertices=mi)$

 -- Función: max_matching (<gr>)
     Devuelve un conjunto maximal independiente de aristas del grafo
     <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) d : dodecahedron_graph()$
          (%i3) m : max_matching(d);
          (%o3) [[5, 7], [8, 9], [6, 10], [14, 19], [13, 18], [12, 17],
                                         [11, 16], [0, 15], [3, 4], [1, 2]]
          (%i4) draw_graph(d, show_edges=m)$

 -- Función: min_degree (<gr>)
     Devuelve el grado mínimo de los vértices del grafo <gr> y un
     vértice de grado mínimo.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : random_graph(100, 0.1)$
          (%i3) min_degree(g);
          (%o3)                              [3, 49]
          (%i4) vertex_degree(21, g);
          (%o4)                                 9

 -- Función: min_edge_cut (<gr>)
     Devuelve el mínimo edge cut del grafo <gr>.  Un edge cut es un
     conjunto de aristas cuya eliminación aumenta el número de
     componentes del grafo.

     Véase también 'edge_connectivity'.

 -- Función: min_vertex_cover (<gr>)
     Devuelve el mínimo nodo covering del grafo <gr>.

 -- Función: min_vertex_cut (<gr>)
     Devuelve el mínimo vertex cut del grafo <gr>.

     Véase también 'vertex_connectivity'.

 -- Función: minimum_spanning_tree (<gr>)
     Devuelve el grafo de expansión mínimo del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : graph_product(path_graph(10), path_graph(10))$
          (%i3) t : minimum_spanning_tree(g)$
          (%i4) draw_graph(g, show_edges=edges(t))$

 -- Función: neighbors (<v>, <gr>)
     Devuelve la lista de los vecinos del vértice <v> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) neighbors(3, p);
          (%o3)                             [4, 8, 2]

 -- Función: odd_girth (<gr>)
     Devuelve la longitud del ciclo impar más corto del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : graph_product(cycle_graph(4), cycle_graph(7))$
          (%i3) girth(g);
          (%o3)                                 4
          (%i4) odd_girth(g);
          (%o4)                                 7

 -- Función: out_neighbors (<v>, <gr>)
     Devuelve la lista de los nodos padres del vértice <v> del grafo
     orientado <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : path_digraph(3)$
          (%i3) in_neighbors(2, p);
          (%o3)                                 [1]
          (%i4) out_neighbors(2, p);
          (%o4)                                 []

 -- Función: planar_embedding (<gr>)
     Devuelve la lista de caminos faciales en una proyección planar de
     <gr>, o 'false' si <gr> no es un grafo planar.

     El grafo <gr> debe estar biconectado.

     El algoritmo utilizado es el de Demoucron, que es de tiempo
     cuadrático.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) planar_embedding(grid_graph(3,3));
          (%o2) [[3, 6, 7, 8, 5, 2, 1, 0], [4, 3, 0, 1], [3, 4, 7, 6],
                                                [8, 7, 4, 5], [1, 2, 5, 4]]

 -- Función: print_graph (<gr>)
     Muestra alguna información sobre el grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) c5 : cycle_graph(5)$
          (%i3) print_graph(c5)$
          Graph on 5 vertices with 5 edges.
          Adjacencies:
            4 :  0  3
            3 :  4  2
            2 :  3  1
            1 :  2  0
            0 :  4  1
          (%i4) dc5 : cycle_digraph(5)$
          (%i5) print_graph(dc5)$
          Digraph on 5 vertices with 5 arcs.
          Adjacencies:
            4 :  0
            3 :  4
            2 :  3
            1 :  2
            0 :  1
          (%i6) out_neighbors(0, dc5);
          (%o6)                                [1]

 -- Función: radius (<gr>)
     Devuelve el radio del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) radius(dodecahedron_graph());
          (%o2)                                 5

 -- Función: set_edge_weight (<e>, <w>, <gr>)
     Asigna el peso <w> a la arista <e> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : create_graph([1, 2], [[[1,2], 1.2]])$
          (%i3) get_edge_weight([1,2], g);
          (%o3)                                1.2
          (%i4) set_edge_weight([1,2], 2.1, g);
          (%o4)                               done
          (%i5) get_edge_weight([1,2], g);
          (%o5)                                2.1

 -- Función: set_vertex_label (<v>, <l>, <gr>)
     Asigna la etiqueta <l> al vértice <v> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : create_graph([[1, "One"], [2, "Two"]], [[1,2]])$
          (%i3) get_vertex_label(1, g);
          (%o3)                                One
          (%i4) set_vertex_label(1, "oNE", g);
          (%o4)                               done
          (%i5) get_vertex_label(1, g);
          (%o5)                                oNE

 -- Función: shortest_path (<u>, <v>, <gr>)
     Devuelve el camino más corto desde <u> hasta <v> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) d : dodecahedron_graph()$
          (%i3) path : shortest_path(0, 7, d);
          (%o3)                          [0, 1, 19, 13, 7]
          (%i4) draw_graph(d, show_edges=vertices_to_path(path))$

 -- Función: shortest_weighted_path (<u>, <v>, <gr>)
     Devuelve la longitud del camino más corto ponderado y el propio
     camino más corto ponderado desde <u> hasta <v> en el grafo <gr>.

     La longitud del camino ponderado es la suma de los pesos de las
     aristas del camino.  Si una arista no tiene peso asignado, su valor
     por defecto es la unidad.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g: petersen_graph(20, 2)$
          (%i3) for e in edges(g) do set_edge_weight(e, random(1.0), g)$
          (%i4) shortest_weighted_path(0, 10, g);
          (%o4) [2.575143920268482, [0, 20, 38, 36, 34, 32, 30, 10]]

 -- Función: strong_components (<gr>)
     Devuelve las componentes fuertes del grafo orientado <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) t : random_tournament(4)$
          (%i3) strong_components(t);
          (%o3)                         [[1], [0], [2], [3]]
          (%i4) vertex_out_degree(3, t);
          (%o4)                                 3

 -- Función: topological_sort (<dag>)
     Devuelve el orden topológico de los vértices del grafo orientado
     <dag> o una lista vacía si <dag> no es un grafo orientado acíclico.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g:create_graph(
                   [1,2,3,4,5],
                   [
                    [1,2], [2,5], [5,3],
                    [5,4], [3,4], [1,3]
                   ],
                   directed=true)$
          (%i3) topological_sort(g);
          (%o3)                           [1, 2, 5, 3, 4]

 -- Función: vertex_connectivity (<g>)
     Devuelve la conectividad de los vértices del grafo <g>.

     Véase también 'min_vertex_cut'.

 -- Función: vertex_degree (<v>, <gr>)
     Devuelve el grado del vértice <v> del grafo <gr>.

 -- Función: vertex_distance (<u>, <v>, <gr>)
     Devuelve la longitud del camino más corto entre <u> y <v> del grafo
     o digrafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) d : dodecahedron_graph()$
          (%i3) vertex_distance(0, 7, d);
          (%o3)                                 4
          (%i4) shortest_path(0, 7, d);
          (%o4)                         [0, 1, 19, 13, 7]

 -- Función: vertex_eccentricity (<v>, <gr>)
     Devuelve la excentricidad del vértice <v> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g:cycle_graph(7)$
          (%i3) vertex_eccentricity(0, g);
          (%o3)                           3

 -- Función: vertex_in_degree (<v>, <gr>)
     Devuelve el grado de entrada del vértice <v> del grafo orientado
     <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p5 : path_digraph(5)$
          (%i3) print_graph(p5)$
          Digraph on 5 vertices with 4 arcs.
          Adjacencies:
            4 :
            3 :  4
            2 :  3
            1 :  2
            0 :  1
          (%i4) vertex_in_degree(4, p5);
          (%o4)                                 1
          (%i5) in_neighbors(4, p5);
          (%o5)                                [3]

 -- Función: vertex_out_degree (<v>, <gr>)
     Devuelve el grado de salida del vértice <v> del grafo orientado
     <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) t : random_tournament(10)$
          (%i3) vertex_out_degree(0, t);
          (%o3)                           2
          (%i4) out_neighbors(0, t);
          (%o4)                        [7, 1]

 -- Función: vertices (<gr>)
     Devuelve la lista de vértices del grafo <gr>.

     Example

          (%i1) load (graphs)$
          (%i2) vertices(complete_graph(4));
          (%o2)                           [3, 2, 1, 0]

 -- Función: vertex_coloring (<gr>)
     Devuelve un coloreado óptimo de los vértices del grafo <gr>.

     La función devuelve el número cromático y una lista representando
     el coloreado de los vértices de <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p:petersen_graph()$
          (%i3) vertex_coloring(p);
          (%o3) [3, [[0, 2], [1, 3], [2, 2], [3, 3], [4, 1], [5, 3],
                                           [6, 1], [7, 1], [8, 2], [9, 2]]]

 -- Función: wiener_index (<gr>)
     Devuelve el índice de Wiener del grafo <gr>.

     Ejemplo:

          (%i1) wiener_index(dodecahedron_graph());
          (%o1)                          500

55.2.3 Modificación de grafos
-----------------------------

 -- Función: add_edge (<e>, <gr>)
     Añade la arista <e> al grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : path_graph(4)$
          (%i3) neighbors(0, p);
          (%o3)                                [1]
          (%i4) add_edge([0,3], p);
          (%o4)                               done
          (%i5) neighbors(0, p);
          (%o5)                              [3, 1]

 -- Función: add_edges (<e_list>, <gr>)
     Añade las aristas de la lista <e_list> al grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : empty_graph(3)$
          (%i3) add_edges([[0,1],[1,2]], g)$
          (%i4) print_graph(g)$
          Graph on 3 vertices with 2 edges.
          Adjacencies:
            2 :  1
            1 :  2  0
            0 :  1

 -- Función: add_vertex (<v>, <gr>)
     Añade el vértice <v> al grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : path_graph(2)$
          (%i3) add_vertex(2, g)$
          (%i4) print_graph(g)$
          Graph on 3 vertices with 1 edges.
          Adjacencies:
            2 :
            1 :  0
            0 :  1

 -- Función: add_vertices (<v_list>, <gr>)
     Añade los vértices de la lista <v_list> al grafo <gr>.

 -- Función: connect_vertices (<v_list>, <u_list>, <gr>)
     Conecta todos los vértices de la lista <v_list> con los vértices de
     la lista <u_list> del grafo <gr>.

     <v_list> y <u_list> pueden ser vértices aislados o una lista de
     vértices.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : empty_graph(4)$
          (%i3) connect_vertices(0, [1,2,3], g)$
          (%i4) print_graph(g)$
          Graph on 4 vertices with 3 edges.
          Adjacencies:
            3 :  0
            2 :  0
            1 :  0
            0 :  3  2  1

 -- Función: contract_edge (<e>, <gr>)
     Contrae la arista <e> del <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g: create_graph(
                 8, [[0,3],[1,3],[2,3],[3,4],[4,5],[4,6],[4,7]])$
          (%i3) print_graph(g)$
          Graph on 8 vertices with 7 edges.
          Adjacencies:
            7 :  4
            6 :  4
            5 :  4
            4 :  7  6  5  3
            3 :  4  2  1  0
            2 :  3
            1 :  3
            0 :  3
          (%i4) contract_edge([3,4], g)$
          (%i5) print_graph(g)$
          Graph on 7 vertices with 6 edges.
          Adjacencies:
            7 :  3
            6 :  3
            5 :  3
            3 :  5  6  7  2  1  0
            2 :  3
            1 :  3
            0 :  3

 -- Función: remove_edge (<e>, <gr>)
     Elimina la arista <e> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) c3 : cycle_graph(3)$
          (%i3) remove_edge([0,1], c3)$
          (%i4) print_graph(c3)$
          Graph on 3 vertices with 2 edges.
          Adjacencies:
            2 :  0  1
            1 :  2
            0 :  2

 -- Función: remove_vertex (<v>, <gr>)
     Elimina el vértice <v> del grafo <gr>.

 -- Función: vertex_coloring (<gr>)
     Devuelve un coloreado óptimo de los vértice del grafo <gr>.

     La función devuelve el número cromático y una lista representando
     el coloreado de los vértices de <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p:petersen_graph()$
          (%i3) vertex_coloring(p);
          (%o3) [3, [[0, 2], [1, 3], [2, 2], [3, 3], [4, 1], [5, 3],
                                          [6, 1], [7, 1], [8, 2], [9, 2]]]

55.2.4 Lectura y escritura de ficheros
--------------------------------------

 -- Función: dimacs_export (<gr>, <fl>)
 -- Función: dimacs_export (<gr>, <fl>, <comment1>, ..., <commentn>)
     Exporta el grafo al fichero <fl> en formato DIMACS. Los comentarios
     adicionales se anãdirán al comienzo del fichero.

 -- Función: dimacs_import (<fl>)
     Lee el grafo almacenado en el fichero <fl> en formato DIMACS.

 -- Función: graph6_decode (<str>)
     Devuelve el grafo codificado en formato graph6 en la cadena <str>.

 -- Función: graph6_encode (<gr>)
     Devuelve una cadena codificando el grafo <gr> en formato graph6.

 -- Función: graph6_export (<gr_list>, <fl>)
     Exporta los grafos de la lista <gr_list> al fichero <fl> en formato
     graph6.

 -- Función: graph6_import (<fl>)
     Lee la lista de grafos almacenados en el fichero <fl> en formato
     graph6.

 -- Función: sparse6_decode (<str>)
     Devuelve el grafo codificado en formato sparse6 en la cadena <str>.

 -- Función: sparse6_encode (<gr>)
     Devuelve una cadena codificando el grafo <gr> en formato sparse6.

 -- Función: sparse6_export (<gr_list>, <fl>)
     Exporta los grafos de la lista <gr_list> al fichero <fl> en formato
     sparse6.

 -- Función: sparse6_import (<fl>)
     Lee la lista de grafos almacenados en el fichero <fl> en formato
     sparse6.

55.2.5 Visualización
--------------------

 -- Función: draw_graph (<graph>)
 -- Función: draw_graph (<graph>, <option1>, ..., <optionk>)
     Dibuja el grafo utilizando el paquete 'draw'.

     El algoritmo utilizado para posicionar los vértices se especifica
     con el argumento opcional <program>, cuyo valor por defecto es
     'program=spring_embedding'.  <draw_graph> también puede utilizar
     los programas de graphviz para posicionar los vértices, para lo
     cual deberá instalarse separadamente el programa graphviz.

     Ejemplo 1:

          (%i1) load (graphs)$
          (%i2) g:grid_graph(10,10)$
          (%i3) m:max_matching(g)$
          (%i4) draw_graph(g,
             spring_embedding_depth=100,
             show_edges=m, edge_type=dots,
             vertex_size=0)$

     Ejemplo 2:

          (%i1) load (graphs)$
          (%i2) g:create_graph(16,
              [
               [0,1],[1,3],[2,3],[0,2],[3,4],[2,4],
               [5,6],[6,4],[4,7],[6,7],[7,8],[7,10],[7,11],
               [8,10],[11,10],[8,9],[11,12],[9,15],[12,13],
               [10,14],[15,14],[13,14]
              ])$
          (%i3) t:minimum_spanning_tree(g)$
          (%i4) draw_graph(
              g,
              show_edges=edges(t),
              show_edge_width=4,
              show_edge_color=green,
              vertex_type=filled_square,
              vertex_size=2
              )$

     Ejemplo 3:

          (%i1) load (graphs)$
          (%i2) mi : max_independent_set(g)$
          (%i3) draw_graph(
              g,
              show_vertices=mi,
              show_vertex_type=filled_up_triangle,
              show_vertex_size=2,
              edge_color=cyan,
              edge_width=3,
              =true,
              text_color=brown
              )$

     Ejemplo 4:

          (%i1) load (graphs)$
          (%i2) net : create_graph(
              [0,1,2,3,4,5],
              [
               [[0,1], 3], [[0,2], 2],
               [[1,3], 1], [[1,4], 3],
               [[2,3], 2], [[2,4], 2],
               [[4,5], 2], [[3,5], 2]
              ],
              directed=true
              )$
          (%i3) draw_graph(
              net,
              show_weight=true,
              vertex_size=0,
              show_vertices=[0,5],
              show_vertex_type=filled_square,
              head_length=0.2,
              head_angle=10,
              edge_color="dark-green",
              text_color=blue
              )$

     Ejemplo 5:

          (%i1) load(graphs)$
          (%i2) g: petersen_graph(20, 2);
          (%o2)                         GRAPH
          (%i3) draw_graph(g, redraw=true, program=planar_embedding);
          (%o3)                         done

     Ejemplo 6:

          (%i1) load(graphs)$
          (%i2) t: tutte_graph();
          (%o2)                         GRAPH
          (%i3) draw_graph(t, redraw=true,
                              fixed_vertices=[1,2,3,4,5,6,7,8,9]);
          (%o3)                         done

 -- Variable opcional: draw_graph_program
     Valor por defecto: <spring_embedding>

     Programa a utilizar por defecto para posicionar los vértices en la
     función 'draw_graph'.

 -- Opción de draw_graph: show_id
     Valor por defecto: <false>

     Si <show_id> vale <true> entonces se muestran los números
     identificadores de los vértices.

 -- Opción de draw_graph: show_label
     Valor por defecto: <false>

     Si <show_label> vale <true> entonces se muestran las etiquetas de
     los vértices.

 -- Opción de draw_graph: label_alignment
     Valor por defecto: <center>

     Indica cómo se deben alinear las etiquetas o números
     identificadores de los vértices.  Puede ser: 'left', 'center' or
     'right'.

 -- Opción de draw_graph: show_weight
     Valor por defecto: <false>

     si <show_weight> vale <true> entonces se mostrarán los pesos de las
     aristas.

 -- Opción de draw_graph: vertex_type
     Valor por defecto: <circle>

     Establece cómo se mostrarán los vértices.  Véase la opción
     <point_type> del paquete 'draw'.

 -- Opción de draw_graph: vertex_size
     Tamanõ de los vértices.

 -- Opción de draw_graph: vertex_color
     Color a utilizar en los vértices.

 -- Opción de draw_graph: show_vertices
     Valor por defecto: []

     Dibuja los vértices seleccionados en la lista con colores
     diferentes.

 -- Opción de draw_graph: show_vertex_type
     Establece cómo se mostrarán los vértices de <show_vertices>.  Véase
     la opción <point_type> del paquete 'draw'.

 -- Opción de draw_graph: show_vertex_size
     Tamanõs de los vértices de <show_vertices>.

 -- Opción de draw_graph: show_vertex_color
     Color a utilizar en los vértices de la lista <show_vertices>.

 -- Opción de draw_graph: vertex_partition
     Valor por defecto: []

     Una partición '[[v1,v2,...],...,[vk,...,vn]]' de los vértices del
     grafo.  Los vértices de cada lista se dibujarán de diferente color.

 -- Opción de draw_graph: vertex_coloring
     Colores de los vértices.  Los colores <col> deben especificarse en
     el mismo formato que el devuelto por <vertex_coloring>.

 -- Opción de draw_graph: edge_color
     Color a utilizar en las aristas.

 -- Opción de draw_graph: edge_width
     Ancho de las aristas.

 -- Opción de draw_graph: edge_type
     Establece cómo se dibujarán las aristas.  Véase la opción
     <line_type> del paquete 'draw'.

 -- Opción de draw_graph: show_edges
     Dibuja las aristas de la lista <e_list> con colores diferentes.

 -- Opción de draw_graph: show_edge_color
     Color a utilizar en las aristas de la lista <show_edges>.

 -- Opción de draw_graph: show_edge_width
     Anchos de las aristas de <show_edges>.

 -- Opción de draw_graph: show_edge_type
     Establece cómo se dibujarán las aristas de <show_edges>.  Véase la
     opción <line_type> del paquete 'draw'.

 -- Opción de draw_graph: edge_partition
     Una partición '[[e1,e2,...],...,[ek,...,em]]' de las aristas del
     grafo.  Las aristas de cada lista se dibujarán de diferente color.

 -- Opción de draw_graph: edge_coloring
     Colores de las aristas.  Los colores <col> deben especificarse en
     el mismo formato que el devuelto por <edge_coloring>.

 -- Opción de draw_graph: redraw
     Valor por defecto: <false>

     Si <redraw> vale 'true', las posiciones de los vértices se
     recalculan incluso si las posiciones están almacenadas de un dibujo
     previo del grafo.

 -- Opción de draw_graph: head_angle
     Valor por defecto: 15

     Ángulo de las flechas de los arcos en los grafos orientados.

 -- Opción de draw_graph: head_length
     Valor por defecto: 0.1

     Longitud de las flechas de los arcos en los grafos orientados.

 -- Opción de draw_graph: spring_embedding_depth
     Valor por defecto: 50

     Número de iteraciones del algoritmo de dibujo de grafos.

 -- Opción de draw_graph: terminal
     Terminal utilizado para ver el gráfo.  Véase la opción <terminal>
     del paquete 'draw'.

 -- Opción de draw_graph: file_name
     Nombre del fichero cuando el terminal especificado no es la
     pantalla.

 -- Opción de draw_graph: program
     establece el programa para posicionado de vértices del grafo.
     Puede ser cualquiera de los programas graphviz (dot, neato, twopi,
     circ, fdp), <circular> o <spring_embedding> o <planar_embedding>;
     <planar_embedding> sl'o está disponible para grafos planares
     2-conectados.  Si 'program=spring_embedding', se puede especificar
     un conjunto de vértices de posición fija con la opción
     <fixed_vertices>.

 -- Opción de draw_graph: fixed_vertices
     Especifica una lista de vértices con posiciones fijas en un
     polígono regular.  Se puede utilizar cuando
     'program=spring_embedding'.

 -- Función: vertices_to_path (<v_list>)
     Convierte una lista <v_list> de vértices en la lista de aristas del
     camino definido por la propia <v_list>.

 -- Función: vertices_to_cycle (<v_list>)
     Convierte una lista <v_list> de vértices en la lista de aristas del
     ciclo definido por la propia <v_list>.


File: maxima.info,  Node: grobner,  Next: impdiff,  Prev: graphs,  Up: Top

56 grobner
**********

* Menu:

* Introducción a grobner::
* Funciones y variables para grobner::


File: maxima.info,  Node: Introducción a grobner,  Next: Funciones y variables para grobner,  Prev: Top,  Up: Top

56.1 Introducción a grobner
===========================

'grobner' es un paquete para operar con bases de Groebner en Maxima.

Para hacer uso de las funciones de este paquete es necesario cargar
previamente el archivo 'grobner.lisp':

     load(grobner);

Es posible ejecutar una demostración haciendo
     demo("grobner.demo");

o
     batch("grobner.demo")

Algunos de los cálculos de la demostración pueden llevar tiempo, razón
por la cual sus resultados se han guardado en el archivo
'grobner-demo.output', que se encuentra en el mismo directorio que el
archivo de demostración.

56.1.1 Notas sobre el paquete grobner
-------------------------------------

El autor del paquete es

Marek Rychlik

<http://alamos.math.arizona.edu>

habiendo sido distribuido el 24-05-2002 bajo los términos de la General
Public License (GPL) (ver archivo 'grobner.lisp').  Esta documentación
ha sido extraída de los archivos
'README', 'grobner.lisp', 'grobner.demo' y 'grobner-demo.output'

por Günter Nowak.  Las sugerencias para mejorar la documentación se
pueden hacer en la lista de correos de _maxima_,
<maxima@math.utexas.edu>.

El código está algo anticuado.  Las implementaciones modernas utilizan
el algoritmo _F4_, más rápido, descrito en
A new efficient algorithm for computing Gröbner bases (F4)
Jean-Charles Faugère
LIP6/CNRS Université Paris VI
January 20, 1999

56.1.2 Implementaciones de órdenes admisibles de monomios
---------------------------------------------------------

   * 'lex'

     lexicográfico puro; orden por defecto para la comparación de
     monomios.
   * 'grlex'

     grado total, con empates resueltos por el orden lexicográfico.

   * 'grevlex'

     grado total, con empates resueltos por el orden lexicográfico
     inverso.

   * 'invlex'

     orden lexicográfico inverso.


File: maxima.info,  Node: Funciones y variables para grobner,  Prev: Introducción a grobner,  Up: Top

56.2 Funciones y variables para grobner
=======================================

56.2.1 Variables opcionales
---------------------------

 -- Variable opcional: poly_monomial_order
     Valor por defecto: 'lex'

     Controla qué orden de monomios utiliza en los cálculos con
     polinomios y bases de Groebner.  Si no se le asigna valor alguno,
     se utilizará 'lex'.

 -- Variable opcional: poly_coefficient_ring
     Valor por defecto: 'expression_ring'

     Indica el anillo de coeficientes de los polinomios que se va a
     utilizar en los cálculos.  Si no se le asigna ningún valor, se
     utilizará el anillo de expresiones propio de _maxima_.  A esta
     variable se le puede asignar el valor 'ring_of_integers'.

 -- Variable opcional: poly_primary_elimination_order
     Valor por defecto: 'false'

     Nombre del orden por defecto para las variables eliminadas en las
     funciones basadas en eliminaciones.  Si no se le asigna ningún
     valor, se utilizará 'lex'.

 -- Variable opcional: poly_secondary_elimination_order
     Valor por defecto: 'false'

     Nombre del orden por defecto para las variables almacenadas en
     funciones basadas en eliminaciones.  Si no se le asigna ningún
     valor, se utilizará 'lex'.

 -- Variable opcional: poly_elimination_order
     Valor por defecto: 'false'

     Nombre del orden de eliminación por defecto utilizado en los
     cálculos de eliminación.  Si se le asigna un valor, ignorará los
     guardados en 'poly_primary_elimination_order' y
     'poly_secondary_elimination_order'.  El usuario se asegurará que
     este es un orden válido de eliminación.

 -- Variable opcional: poly_return_term_list
     Valor por defecto: 'false'

     Si vale 'true', todas las funciones de este paquete devolverán los
     polinomios como una lista de términos en el orden activo de
     monomios, en lugar de una expresión ordinaria de _maxima_.

 -- Variable opcional: poly_grobner_debug
     Valor por defecto: 'false'

     Si vale 'true', genera una salida de seguimiento y depuración.

 -- Variable opcional: poly_grobner_algorithm
     Valor por defecto: 'buchberger'

     Valores posibles:
        * 'buchberger'
        * 'parallel_buchberger'
        * 'gebauer_moeller'

     Es el nombre del algoritmo utilizado para encontrar las bases de
     Groebner.

 -- Variable opcional: poly_top_reduction_only
     Valor por defecto: 'false'

     Si no vale 'false', siempre que sea posible el algoritmo de
     división se detendrá tras la primera reducción.

56.2.2 Operadores simples
-------------------------

'poly_add', 'poly_subtract', 'poly_multiply' y 'poly_expt' son los
operadores aritméticos para polinomios.  Se ejecutan utilizando la
representación interna, pero los resultados se devuelven en forma de
expresión ordinaria de _maxima_.

 -- Función: poly_add (<poly1>, <poly2>, <varlist>)
     Suma los polinomios <poly1> y <poly2>.

          (%i1) poly_add(z+x^2*y,x-z,[x,y,z]);
                                              2
          (%o1)                              x  y + x

 -- Función: poly_subtract (<poly1>, <poly2>, <varlist>)
     Resta el polinomio <poly2> de <poly1>.

          (%i1) poly_subtract(z+x^2*y,x-z,[x,y,z]);
                                                2
          (%o1)                          2 z + x  y - x

 -- Función: poly_multiply (<poly1>, <poly2>, <varlist>)
     Multiplica <poly1> por <poly2>.

          (%i2) poly_multiply(z+x^2*y,x-z,[x,y,z])-(z+x^2*y)*(x-z),expand;
          (%o1)                                  0

 -- Función: poly_s_polynomial (<poly1>, <poly2>, <varlist>)
     Devuelve el _polinomio syzygy_ (_S-polinomio_) de dos polinomios
     <poly1> y <poly2>.

 -- Función: poly_primitive_part (<poly1>, <varlist>)
     Devuelve el polinomio <poly> dividido por el MCD de sus
     coeficientes.

          (%i1) poly_primitive_part(35*y+21*x,[x,y]);
          (%o1)                              5 y + 3 x

 -- Función: poly_normalize (<poly>, <varlist>)
     Devuelve el polinomio <poly> dividido por el coeficiente principal.
     Da por supuesto que la división es posible, lo cual puede no ser
     siempre cierto en anillos que no son campos.

56.2.3 Otras funciones
----------------------

 -- Función: poly_expand (<poly>, <varlist>)
     Esta función expande los polinomios.  Equivale a 'expand(<poly>)'
     si <poly> es un polinomio.  Si la representación no es compatible
     con un polinomio de variables <varlist>, devuelve un error.

          (%i1) poly_expand((x-y)*(y+x),[x,y]);
                                               2    2
          (%o1)                               x  - y
          (%i2) poly_expand((y+x)^2,[x,y]);
                                          2            2
          (%o2)                          y  + 2 x y + x
          (%i3) poly_expand((y+x)^5,[x,y]);
                            5      4         2  3       3  2      4      5
          (%o3)            y  + 5 x y  + 10 x  y  + 10 x  y  + 5 x  y + x
          (%i4) poly_expand(-1-x*exp(y)+x^2/sqrt(y),[x]);
                                                    2
                                            y      x
          (%o4)                       - x %e  + ------- - 1
                                                 sqrt(y)

          (%i5) poly_expand(-1-sin(x)^2+sin(x),[sin(x)]);
                                          2
          (%o5)                      - sin (x) + sin(x) - 1

 -- Función: poly_expt (<poly>, <number>, <varlist>)
     Eleva el polinomio <poly> a la potencia <number>, siendo este un
     entero positivo.  Si <number> no es un número entero positivo,
     devolverá un error.

          (%i1) poly_expt(x-y,3,[x,y])-(x-y)^3,expand;
          (%o1)                                  0

 -- Función: poly_content (<poly>. <varlist>)
     'poly_content' calcula el MCD de los coeficientes.

          (%i1) poly_content(35*y+21*x,[x,y]);
          (%o1)                                  7

 -- Función: poly_pseudo_divide (<poly>, <polylist>, <varlist>)
     Realiza la seudo-división del polinomio <poly> por la lista de n
     polinomios de <polylist>.  Devuelve varios resultados.  El primer
     resultado es una lista de cocientes a.  El segundo resultado es el
     resto r.  El tercer resultado es un coeficiente escalar c, tal que
     c*poly puede dividirse por <polylist> dentro del anillo de
     coeficientes, el cual no es necesariamente un campo.  Por último,
     el cuarto resultado es un entero que guarda el recuento de
     reducciones realizadas.  El objeto resultante satisface la
     ecuación:

     c*poly=sum(a[i]*polylist[i],i=1...n)+r.

 -- Función: poly_exact_divide (<poly1>, <poly2>, <varlist>)
     Divide el polinomio <poly1> por otro polinomio <poly2>.  Da por
     supuesto que es posible la división de resto nulo.  Devuelve el
     cociente.

 -- Función: poly_normal_form (<poly>, <polylist>, <varlist>)
     'poly_normal_form' encuentra la forma normal de un polinomio <poly>
     respecto de un conjunto de polinomios <polylist>.

 -- Función: poly_buchberger_criterion (<polylist>, <varlist>)
     Devuelve 'true' si <polylist> es una base de Groebner respecto del
     orden de términos activo, utilizando el criterio de Buchberger:
     para cualesquiera polinomios h1 y h2 de <polylist> el S-polinomio
     S(h1,h2) se reduce a 0 modulo <polylist>.

 -- Función: poly_buchberger (<polylist_fl> <varlist>)
     'poly_buchberger' ejecuta el algoritmo de Buchberger sobre una
     lista de polinomios y devuelve la base de Groebner resultante.

56.2.4 Postprocesamiento estándar de bases de Groebner
------------------------------------------------------

El _k-ésimo ideal de eliminación_ I_k de un ideal I sobre K[
x[1],...,x[n] ] es el ideal intersect(I, K[ x[k+1],...,x[n] ]).
El _ideal_ I:J es el ideal {h|para todo w en J: w*h pertence a I}.
El ideal I:p^inf es el ideal {h| existe un n en N: p^n*h pertence a I}.
El ideal I:J^inf es el ideal {h| existe un n en N y un p en J: p^n*h
pertence a I}.
El _ideal radical_ sqrt(I) es el ideal {h| existe un n en N : h^n
pertence a I }.

 -- Función: poly_reduction (<polylist>, <varlist>)
     'poly_reduction' reduce una lista de polinomios <polylist> de
     manera que cada polinomio se reduce completamente respecto de los
     otros polinomios.

 -- Función: poly_minimization (<polylist>, <varlist>)
     Devuelve una sublista de la lista de polinomios <polylist> con el
     mismo ideal de monomios que <polylist>, pero mínimo, esto es,
     ningún monomio principal de los polinomios de la sublista divide a
     los monomios principales de los demás polinomios.

 -- Función: poly_normalize_list (<polylist>, <varlist>)
     'poly_normalize_list' aplica 'poly_normalize' a cada polinomio de
     la lista.  Esto significa que divide cada polinomio de <polylist>
     por su coeficiente principal.

 -- Función: poly_grobner (<polylist>, <varlist>)
     Devuelve la base de Groebner del ideal asociado a los polinomios de
     <polylist>.  El resultado depende de las variables globales.

 -- Función: poly_reduced_grobner (<polylist>, <varlist>)
     Devuelve la base de Groebner reducida del ideal asociado a los
     polinomios de <polylist>.  El resultado depende de las variables
     globales.

 -- Función: poly_depends_p (<poly>, <var>, <varlist>)
     'poly_depends' comprueba si el polinomio depende de la variable
     <var>.

 -- Función: poly_elimination_ideal (<polylist>, <n>, <varlist>)
     'poly_elimination_ideal' devuelve la base de Groebner del n-ésimo
     ideal de eliminación de un ideal especificado como una lista de
     polinomios generadores (no necesariamente una base de Groebner).

 -- Función: poly_colon_ideal (<polylist1>, <polylist2>, <varlist>)
     Devuelve la base de Groebner reducida del ideal

     I(polylist1):I(polylist2)

     siendo polylist1 y polylist2 dos listas de polinomios.

 -- Función: poly_ideal_intersection (<polylist1>, <polylist2>,
          <varlist>)

     'poly_ideal_intersection' devuelve la intersección de dos ideales.

 -- Función: poly_lcm (<poly1>, <poly2>, <varlist>)
     Devuelve el MCM de <poly1> y <poly2>.

 -- Función: poly_gcd (<poly1>, <poly2>, <varlist>)
     Devuelve el MCD de <poly1> y <poly2>.

     Véanse también 'ezgcd', 'gcd', 'gcdex' y 'gcdivide'.

     Ejemplo:

          (%i1) p1:6*x^3+19*x^2+19*x+6;
                                  3       2
          (%o1)                6 x  + 19 x  + 19 x + 6
          (%i2) p2:6*x^5+13*x^4+12*x^3+13*x^2+6*x;
                            5       4       3       2
          (%o2)          6 x  + 13 x  + 12 x  + 13 x  + 6 x
          (%i3) poly_gcd(p1, p2, [x]);
                                      2
          (%o3)                    6 x  + 13 x + 6

 -- Función: poly_grobner_equal (<polylist1>, <polylist2>, <varlist>)
     'poly_grobner_equal' comprueba si dos bases de Groebner generan el
     mismo ideal.  Devuelve 'true' si dos listas de polinomios
     <polylist1> y <polylist2>, supuestas bases de Groebner, generan el
     mismo ideal, o 'false' en caso contrario.  Eso equivale a comprobar
     si cada polinomio de la primera base se reduce a 0 módulo la
     segunda base y viceversa.  Nótese que en el ejemplo que sigue la
     primera lista no es una base de Groebner, por lo que el resultado
     es 'false'.

          (%i1) poly_grobner_equal([y+x,x-y],[x,y],[x,y]);
          (%o1)                         false

 -- Función: poly_grobner_subsetp (<polylist1>, <polylist2>, <varlist>)
     'poly_grobner_subsetp' comprueba si el ideal generado por
     <polylist1> está contenido en el ideal generado por <polylist2>.
     Para que esta comprobación tenga éxito, <polylist2> debe ser una
     base de Groebner.

 -- Función: poly_grobner_member (<poly>, <polylist>, <varlist>)
     Devuelve 'true' si el polinomio <poly> pertenece al ideal generado
     por la lista de polinomios <polylist>, la cual se supone una base
     de Groebner.  Devolverá 'false' en caso contrario.

 -- Función: poly_ideal_saturation1 (<polylist>, <poly>, <varlist>)
     Devuelve la base de Groebner reducida de la saturación del ideal

     I(polylist):poly^inf

     Desde un punto de vista geométrico, sobre un campo algebraicamente
     cerrado, este es el conjunto de polinomios del ideal generado por
     <polylist> que no se anulan sobre la variedad de <poly>.

 -- Función: poly_ideal_saturation (<polylist1>, <polylist2>, <varlist>)
     Devuelve la base de Groebner reducida de la saturación del ideal

     I(polylist1):I(polylist2)^inf

     Desde un punto de vista geométrico, sobre un campo algebraicamente
     cerrado, este es el conjunto de polinomios del ideal generado por
     <polylist1> que no se anulan sobre la variedad de <polylist2>.

 -- Función: poly_ideal_polysaturation1 (<polylist1>, <polylist2>,
          <varlist>)
     <polylist2> es una lista de n poliomios '[poly1,...,polyn]'.
     Devuelve la base de Groebner reducida del ideal

     I(polylist):poly1^inf:...:polyn^inf

     obtenida a partir de una secuencia de saturaciones sucesivas de los
     polinomios de la lista <polylist2> del ideal generado por la lista
     de polinomios <polylist1>.

 -- Función: poly_ideal_polysaturation (<polylist>, <polylistlist>,
          <varlist>)
     <polylistlist> es una lista de n listas de polinomios
     '[polylist1,...,polylistn]'.  Devuelve la base de Groebner reducida
     de la saturación del ideal

     I(polylist):I(polylist_1)^inf:...:I(polylist_n)^inf

 -- Función: poly_saturation_extension (<poly>, <polylist>, <varlist1>,
          <varlist2>)
     'poly_saturation_extension' ejecuta el truco de Rabinowitz.

 -- Función: poly_polysaturation_extension (<poly>, <polylist>,
          <varlist1>, <varlist2>)


File: maxima.info,  Node: impdiff,  Next: interpol,  Prev: grobner,  Up: Top

57 impdiff
**********

* Menu:

* Funciones y variables para impdiff::


File: maxima.info,  Node: Funciones y variables para impdiff,  Prev: impdiff,  Up: impdiff

57.1 Funciones y variables para impdiff
=======================================

 -- Función: implicit_derivative (<f>,<indvarlist>,<orderlist>,<depvar>)
     Calcula las derivadas implícitas de funciones multivariantes.  <f>
     es una función array, los índices son los grados de las derivadas
     en el orden establecido en <indvarlist>, <indvarlist> es la lista
     de variables independientes, <orderlist> es el orden deseado y
     <depvar> es la variable dependiente.

     Antes de hacer uso de esta función ejecútese 'load("impdiff")'.


File: maxima.info,  Node: interpol,  Next: lapack,  Prev: impdiff,  Up: Top

58 interpol
***********

* Menu:

* Introducción a interpol::
* Funciones y variables para interpol::


File: maxima.info,  Node: Introducción a interpol,  Next: Funciones y variables para interpol,  Prev: interpol,  Up: interpol

58.1 Introducción a interpol
============================

El paquete 'interpol' desarrolla los métodos de interpolación polinómica
de Lagrange, lineal y de splines cúbicos.

Para comentarios, fallos o sugerencias, contactar con <'mario ARROBA edu
PUNTO xunta PUNTO es'>.


File: maxima.info,  Node: Funciones y variables para interpol,  Prev: Introducción a interpol,  Up: interpol

58.2 Funciones y variables para interpol
========================================

 -- Función: lagrange (<points>)
 -- Función: lagrange (<points>, <option>)
     Calcula el polinomio de interpolación por el método de Lagrange.
     El argumento <points> debe ser:

        * una matriz de dos columnas, 'p:matrix([2,4],[5,6],[9,3])',
        * una lista de pares de números, 'p: [[2,4],[5,6],[9,3]]',
        * una lista de números, 'p: [4,6,3]', en cuyo caso las abscisas
          se asignarán automáticamente a 1, 2, 3, etc.

     En los dos primeros casos los pares se ordenan con respecto a la
     primera coordenada antes de proceder a los cálculos.

     Mediante el argumento <option> es posible seleccionar el nombre de
     la variable independiente, que por defecto es ''x'; para definir
     otra, escríbase algo como 'varname='z'.

     Téngase en cuenta que cuando se trabaja con polinomios de grado
     alto, los cálculos con números decimales en coma flotante pueden
     ser muy inestables.

     Véanse también 'linearinterpol', 'cspline' y 'ratinterpol'.

     Ejemplos:

          (%i1) load(interpol)$
          (%i2) p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$
          (%i3) lagrange(p);
                 (x - 7) (x - 6) (x - 3) (x - 1)
          (%o3)  -------------------------------
                               35
             (x - 8) (x - 6) (x - 3) (x - 1)
           - -------------------------------
                           12
             7 (x - 8) (x - 7) (x - 3) (x - 1)
           + ---------------------------------
                            30
             (x - 8) (x - 7) (x - 6) (x - 1)
           - -------------------------------
                           60
             (x - 8) (x - 7) (x - 6) (x - 3)
           + -------------------------------
                           84
          (%i4) f(x):=''%;
                         (x - 7) (x - 6) (x - 3) (x - 1)
          (%o4)  f(x) := -------------------------------
                                       35
             (x - 8) (x - 6) (x - 3) (x - 1)
           - -------------------------------
                           12
             7 (x - 8) (x - 7) (x - 3) (x - 1)
           + ---------------------------------
                            30
             (x - 8) (x - 7) (x - 6) (x - 1)
           - -------------------------------
                           60
             (x - 8) (x - 7) (x - 6) (x - 3)
           + -------------------------------
                           84
          (%i5) /* Evaluate the polynomial at some points */
                expand(map(f,[2.3,5/7,%pi]));
                                            4          3           2
                              919062  73 %pi    701 %pi    8957 %pi
          (%o5)  [- 1.567535, ------, ------- - -------- + ---------
                              84035     420       210         420
                                                       5288 %pi   186
                                                     - -------- + ---]
                                                         105       5
          (%i6) %,numer;
          (%o6) [- 1.567535, 10.9366573451538, 2.89319655125692]
          (%i7) load(draw)$  /* load draw package */
          (%i8) /* Plot the polynomial together with points */
                draw2d(
                  color      = red,
                  key        = "Lagrange polynomial",
                  explicit(f(x),x,0,10),
                  point_size = 3,
                  color      = blue,
                  key        = "Sample points",
                  points(p))$
          (%i9) /* Change variable name */
                lagrange(p, varname=w);
                 (w - 7) (w - 6) (w - 3) (w - 1)
          (%o9)  -------------------------------
                               35
             (w - 8) (w - 6) (w - 3) (w - 1)
           - -------------------------------
                           12
             7 (w - 8) (w - 7) (w - 3) (w - 1)
           + ---------------------------------
                            30
             (w - 8) (w - 7) (w - 6) (w - 1)
           - -------------------------------
                           60
             (w - 8) (w - 7) (w - 6) (w - 3)
           + -------------------------------
                           84

 -- Función: charfun2 (<x>, <a>, <b>)
     Devuelve 'true' si el número <x> pertenece al intervalo [a, b), y
     'false' en caso contrario.

 -- Función: linearinterpol (<points>)
 -- Función: linearinterpol (<points>, <option>)
     Calcula rectas de interpolación.  El argumento <points> debe ser:

        * una matriz de dos columnas, 'p:matrix([2,4],[5,6],[9,3])',
        * una lista de pares de números, 'p: [[2,4],[5,6],[9,3]]',
        * una lista de números, 'p: [4,6,3]', en cuyo caso las abscisas
          se asignarán automáticamente a 1, 2, 3, etc.

     En los dos primeros casos los pares se ordenan con respecto a la
     primera coordenada antes de proceder a los cálculos.

     Mediante el argumento <option> es posible seleccionar el nombre de
     la variable independiente, que por defecto es ''x'; para definir
     otra, escríbase algo como 'varname='z'.

     Véanse también 'lagrange', 'cspline' y 'ratinterpol'.

     Ejemplos:

          (%i1) load(interpol)$
          (%i2) p: matrix([7,2],[8,3],[1,5],[3,2],[6,7])$
          (%i3) linearinterpol(p);
                  13   3 x
          (%o3)  (-- - ---) charfun2(x, minf, 3)
                  2     2
           + (x - 5) charfun2(x, 7, inf) + (37 - 5 x) charfun2(x, 6, 7)
              5 x
           + (--- - 3) charfun2(x, 3, 6)
               3

          (%i4) f(x):=''%;
                          13   3 x
          (%o4)  f(x) := (-- - ---) charfun2(x, minf, 3)
                          2     2
           + (x - 5) charfun2(x, 7, inf) + (37 - 5 x) charfun2(x, 6, 7)
              5 x
           + (--- - 3) charfun2(x, 3, 6)
               3
          (%i5)  /* Evaluate the polynomial at some points */
                 map(f,[7.3,25/7,%pi]);
                                      62  5 %pi
          (%o5)                 [2.3, --, ----- - 3]
                                      21    3
          (%i6) %,numer;
          (%o6)  [2.3, 2.952380952380953, 2.235987755982989]
          (%i7) load(draw)$  /* load draw package */
          (%i8)  /* Plot the polynomial together with points */
                 draw2d(
                   color      = red,
                   key        = "Linear interpolator",
                   explicit(f(x),x,-5,20),
                   point_size = 3,
                   color      = blue,
                   key        = "Sample points",
                   points(args(p)))$
          (%i9)  /* Change variable name */
                 linearinterpol(p, varname='s);
                 13   3 s
          (%o9) (-- - ---) charfun2(s, minf, 3)
                 2     2
           + (s - 5) charfun2(s, 7, inf) + (37 - 5 s) charfun2(s, 6, 7)
              5 s
           + (--- - 3) charfun2(s, 3, 6)
               3

 -- Función: cspline (<points>)
 -- Función: cspline (<points>, <option1>, <option2>, ...)
     Calcula el polinomio de interpolación por el método de los splines
     cúbicos.  El argumento <points> debe ser:

        * una matriz de dos columnas, 'p:matrix([2,4],[5,6],[9,3])',
        * una lista de pares de números, 'p: [[2,4],[5,6],[9,3]]',
        * una lista de números, 'p: [4,6,3]', en cuyo caso las abscisas
          se asignarán automáticamente a 1, 2, 3, etc.

     En los dos primeros casos los pares se ordenan con respecto a la
     primera coordenada antes de proceder a los cálculos.

     Esta función dispone de tres opciones para acomodarse a necesidades
     concretas:

        * ''d1', por defecto ''unknown', es la primera derivada en x_1;
          si toma el valor ''unknown', la segunda derivada en x_1 se
          iguala a 0 (spline cúbico natural); en caso de tomar un valor
          numérico, la segunda derivada se calcula en base a este
          número.

        * ''dn', por defecto ''unknown', es la primera derivada en x_n;
          si toma el valor ''unknown', la segunda derivada en x_n se
          iguala a 0 (spline cúbico natural); en caso de tomar un valor
          numérico, la segunda derivada se calcula en base a este
          número.

        * ''varname', por defecto ''x', es el nombre de la variable
          independiente.

     Véanse también 'lagrange', 'linearinterpol' y 'ratinterpol'.

     Ejemplos:

          (%i1) load(interpol)$
          (%i2) p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$
          (%i3) /* Unknown first derivatives at the extremes
                   is equivalent to natural cubic splines */
                cspline(p);
                        3         2
                  1159 x    1159 x    6091 x   8283
          (%o3)  (------- - ------- - ------ + ----) charfun2(x, minf, 3)
                   3288      1096      3288    1096
                      3         2
                2587 x    5174 x    494117 x   108928
           + (- ------- + ------- - -------- + ------) charfun2(x, 7, inf)
                 1644       137       1644      137
                    3          2
              4715 x    15209 x    579277 x   199575
           + (------- - -------- + -------- - ------) charfun2(x, 6, 7)
               1644       274        1644      274
                      3         2
                3287 x    2223 x    48275 x   9609
           + (- ------- + ------- - ------- + ----) charfun2(x, 3, 6)
                 4932       274      1644     274

          (%i4) f(x):=''%$
          (%i5) /* Some evaluations */
                map(f,[2.3,5/7,%pi]), numer;
          (%o5) [1.991460766423356, 5.823200187269903, 2.227405312429507]
          (%i6) load(draw)$  /* load draw package */
          (%i7) /* Plotting interpolating function */
                draw2d(
                  color      = red,
                  key        = "Cubic splines",
                  explicit(f(x),x,0,10),
                  point_size = 3,
                  color      = blue,
                  key        = "Sample points",
                  points(p))$
          (%i8) /* New call, but giving values at the derivatives */
                cspline(p,d1=0,dn=0);
                        3          2
                  1949 x    11437 x    17027 x   1247
          (%o8)  (------- - -------- + ------- + ----) charfun2(x, minf, 3)
                   2256       2256      2256     752
                      3          2
                1547 x    35581 x    68068 x   173546
           + (- ------- + -------- - ------- + ------) charfun2(x, 7, inf)
                  564       564        141      141
                   3          2
              607 x    35147 x    55706 x   38420
           + (------ - -------- + ------- - -----) charfun2(x, 6, 7)
               188       564        141      47
                      3         2
                3895 x    1807 x    5146 x   2148
           + (- ------- + ------- - ------ + ----) charfun2(x, 3, 6)
                 5076       188      141      47
          (%i8) /* Defining new interpolating function */
                g(x):=''%$
          (%i9) /* Plotting both functions together */
                draw2d(
                  color      = black,
                  key        = "Cubic splines (default)",
                  explicit(f(x),x,0,10),
                  color      = red,
                  key        = "Cubic splines (d1=0,dn=0)",
                  explicit(g(x),x,0,10),
                  point_size = 3,
                  color      = blue,
                  key        = "Sample points",
                  points(p))$

 -- Función: ratinterpol (<points>, <numdeg>)
 -- Función: ratinterpol (<points>, <numdeg>, <option1>)
     Genera el interpolador racional para los datos dados por <points> y
     con grado <numdeg> en el numerador; el grado del denominador se
     calcula automáticamente.  El argumento <points> debe ser:

        * una matriz de dos columnas, 'p:matrix([2,4],[5,6],[9,3])',
        * una lista de pares de números, 'p: [[2,4],[5,6],[9,3]]',
        * una lista de números, 'p: [4,6,3]', en cuyo caso las abscisas
          se asignarán automáticamente a 1, 2, 3, etc.

     En los dos primeros casos los pares se ordenan con respecto a la
     primera coordenada antes de proceder a los cálculos.

     Esta función dispone de una opción para acomodarse a necesidades
     concretas:
        * ''varname', por defecto ''x', es el nombre de la variable
          independiente.

     Véanse también 'lagrange', 'linearinterpol', 'cspline',
     'minpack_lsquares' y 'lbfgs'.

     Ejemplos:

          (%i1) load(interpol)$
          (%i2) load(draw)$
          (%i3) p:[[7.2,2.5],[8.5,2.1],[1.6,5.1],[3.4,2.4],[6.7,7.9]]$
          (%i4) for k:0 thru length(p)-1 do
                  draw2d(
                    explicit(ratinterpol(p,k),x,0,9),
                    point_size = 3,
                    points(p),
                    title = concat("Grado del numerador = ",k),
                    yrange=[0,10])$


File: maxima.info,  Node: lapack,  Next: lbfgs,  Prev: interpol,  Up: Top

59 lapack
*********

* Menu:

* Introducción a lapack::
* Funciones y variables para lapack::


File: maxima.info,  Node: Introducción a lapack,  Next: Funciones y variables para lapack,  Prev: lapack,  Up: lapack

59.1 Introducción a lapack
==========================

'lapack' es una traducción automática a Common Lisp (con el programa
'f2c') de la librería LAPACK escrita en Fortran.


File: maxima.info,  Node: Funciones y variables para lapack,  Prev: Introducción a lapack,  Up: lapack

59.2 Funciones y variables para lapack
======================================

 -- Función: dgeev (<A>)
 -- Función: dgeev (<A>, <right_p>, <left_p>)

     Calcula los autovalores y, opcionalmente, también los autovectores
     de la matriz <A>.  Todos los elementos de <A> deben ser enteros o
     números decimales en coma flotante.  Además, <A> debe ser cuadrada
     (igual número de filas que de columnas) y puede ser o no simétrica.

     'dgeev(<A>)' calcula sólo los autovalores de <A>.  'dgeev(<A>,
     <right_p>, <left_p>)' calcula los autovalores de <A> y los
     autovectores por la derecha cuando <right_p> = 'true', y los
     autovectores por la izquierda cuando <left_p> = 'true'.

     La función devuelve una lista de tres elementos.  El primer
     elemento es una lista con los autovalores.  El segundo elemento es
     'false' o la matriz de autovectores por la derecha.  El tercer
     elemento es 'false' o la matriz de autovectores por la izquierda.

     El autovector por la derecha v(j) (la j-ésima columna de la matriz
     de autovectores por la derecha) satisface

     A . v(j) = lambda(j) . v(j)

     donde lambda(j) es su autovalor asociado.

     El autovector por la izquierda u(j) (la j-ésima columna de la
     matriz de autovectores por la izquierda) satisface

     u(j)**H . A = lambda(j) . u(j)**H

     donde u(j)**H denota la transpuesta conjugada de u(j).

     La función de Maxima 'ctranspose' calcula la transpuesta conjugada.

     Los autovectores calculados están normalizados para que su norma
     euclídea valga 1 y su componente mayor tenga su parte imaginaria
     igual a cero.

     Ejemplo:

          (%i1) load (lapack)$
          (%i2) fpprintprec : 6;
          (%o2)                           6
          (%i3) M : matrix ([9.5, 1.75], [3.25, 10.45]);
                                   [ 9.5   1.75  ]
          (%o3)                    [             ]
                                   [ 3.25  10.45 ]
          (%i4) dgeev (M);
          (%o4)          [[7.54331, 12.4067], false, false]
          (%i5) [L, v, u] : dgeev (M, true, true);
                                     [ - .666642  - .515792 ]
          (%o5) [[7.54331, 12.4067], [                      ],
                                     [  .745378   - .856714 ]
                                                  [ - .856714  - .745378 ]
                                                  [                      ]]
                                                  [  .515792   - .666642 ]
          (%i6) D : apply (diag_matrix, L);
                                [ 7.54331     0    ]
          (%o6)                 [                  ]
                                [    0     12.4067 ]
          (%i7) M . v - v . D;
                          [      0.0       - 8.88178E-16 ]
          (%o7)           [                              ]
                          [ - 8.88178E-16       0.0      ]
          (%i8) transpose (u) . M - D . transpose (u);
                               [ 0.0  - 4.44089E-16 ]
          (%o8)                [                    ]
                               [ 0.0       0.0      ]

 -- Función: dgeqrf (<A>)

     Calcula la descomposición QR de la matriz <A>.  Todos los elementos
     de <A> deben ser enteros o números reales.  No es necesario que <A>
     tenga el mismo número de filas que de columnas.

     La función devuelve una lista con dos elementos; el primero es la
     matriz cuadrada ortonormal <Q>, con el mismo número de filas que
     <A>, y el segundo es la matriz triangular superior <R>, de iguales
     dimensiones que <A>.  El producto '<Q> . <R>', siendo "."  el
     operador de la multiplicación matricial, es igual a <A>, ignorando
     errores de redondeo.

          (%i1) load (lapack) $
          (%i2) fpprintprec : 6 $
          (%i3) M : matrix ([1, -3.2, 8], [-11, 2.7, 5.9]) $
          (%i4) [q, r] : dgeqrf (M);
                 [ - .0905357  .995893  ]
          (%o4) [[                      ],
                 [  .995893    .0905357 ]
                                         [ - 11.0454   2.97863   5.15148 ]
                                         [                               ]]
                                         [     0      - 2.94241  8.50131 ]
          (%i5) q . r - M;
                   [ - 7.77156E-16   1.77636E-15   - 8.88178E-16 ]
          (%o5)    [                                             ]
                   [      0.0       - 1.33227E-15   8.88178E-16  ]
          (%i6) mat_norm (%, 1);
          (%o6)                      3.10862E-15

 -- Función: dgesv (<A>, <b>)

     Calcula la solución <x> de la ecuación <A> <x> = <b>, siendo <A>
     una matriz cuadrada y <b> otra matriz con el mismo número de filas
     que <A> y un número arbitrario de columnas.  Las dimensiones de la
     solución <x> son las mismas de <b>.

     Los elementos de <A> y <b> deben ser reducibles a números decimales
     si se les aplica la función 'float', por lo que tales elementos
     pueden en principio ser de cualquier tipo numérico, constantes
     numéricas simbólicas o cualesquiera expresiones reducibles a un
     número decimal.  Los elementos de <x> son siempre números
     decimales.  Todas las operaciones aritméticas se realizan en coma
     flotante.

     'dgesv' calcula la solución mediante la descomposición LU de <A>.

     Ejemplos:

     'dgesv' calcula la solución <x> de la ecuación <A> <x> = <b>.

          (%i1) A : matrix ([1, -2.5], [0.375, 5]);
                                         [   1    - 2.5 ]
          (%o1)                          [              ]
                                         [ 0.375    5   ]
          (%i2) b : matrix ([1.75], [-0.625]);
                                            [  1.75   ]
          (%o2)                             [         ]
                                            [ - 0.625 ]
          (%i3) x : dgesv (A, b);
                                      [  1.210526315789474  ]
          (%o3)                       [                     ]
                                      [ - 0.215789473684211 ]
          (%i4) dlange (inf_norm, b - A.x);
          (%o4)                                 0.0

     <b> una matriz con el mismo número de filas que <A> y un número
     arbitrario de columnas.  Las dimensiones de <x> son las mismas de
     <b>.

          (%o0)                                done
          (%i1) A : matrix ([1, -0.15], [1.82, 2]);
                                         [  1    - 0.15 ]
          (%o1)                          [              ]
                                         [ 1.82    2    ]
          (%i2) b : matrix ([3.7, 1, 8], [-2.3, 5, -3.9]);
                                        [  3.7   1    8   ]
          (%o2)                         [                 ]
                                        [ - 2.3  5  - 3.9 ]
          (%i3) x : dgesv (A, b);
                  [  3.103827540695117   1.20985481742191    6.781786185657722  ]
          (%o3)   [                                                             ]
                  [ - 3.974483062032557  1.399032116146062  - 8.121425428948527 ]
          (%i4) dlange (inf_norm, b - A . x);
          (%o4)                       1.1102230246251565E-15

     Los elementos de <A> y <b> deben ser reducibles a números
     decimales.

          (%i1) A : matrix ([5, -%pi], [1b0, 11/17]);
                                         [   5    - %pi ]
                                         [              ]
          (%o1)                          [         11   ]
                                         [ 1.0b0   --   ]
                                         [         17   ]
          (%i2) b : matrix ([%e], [sin(1)]);
                                            [   %e   ]
          (%o2)                             [        ]
                                            [ sin(1) ]
          (%i3) x : dgesv (A, b);
                                       [ 0.690375643155986 ]
          (%o3)                        [                   ]
                                       [ 0.233510982552952 ]
          (%i4) dlange (inf_norm, b - A . x);
          (%o4)                        2.220446049250313E-16

 -- Función: dgesvd (<A>)
 -- Función: dgesvd (<A>, <left_p>, <right_p>)

     Calcula la descomposición singular (SVD, en inglés) de la matriz
     <A>, que contiene los valores singulares y, opcionalmente, los
     vectores singulares por la derecha o por la izquierda.  Todos los
     elementos de <A> deben ser enteros o números decimales en coma
     flotante.  La matriz <A> puede ser cuadrada o no (igual número de
     filas que de columnas).

     Sea m el número de filas y n el de columnas de <A>.  La
     descomposición singular de <A> consiste en calcular tres matrices:
     <U>, <Sigma> y <V^T>, tales que

     <A> = <U> . <Sigma> . <V>^T

     donde <U> es una matriz unitaria m-por-m, <Sigma> es una matriz
     diagonal m-por-n y <V^T> es una matriz unitaria n-por-n.

     Sea sigma[i] un elemento diagonal de Sigma, esto es, <Sigma>[i, i]
     = <sigma>[i].  Los elementos sigma[i] se llaman valores singulares
     de <A>, los cuales son reales y no negativos, siendo devueltos por
     la función 'dgesvd' en orden descendente.

     Las primeras min(m, n) columnas de <U> y <V> son los vectores
     singulares izquierdo y derecho de <A>.  Nótese que 'dgesvd'
     devuelve la transpuesta de <V>, no la propia matriz <V>.

     'dgesvd(<A>)' calcula únicamente los valores singulares de <A>.
     'dgesvd(<A>, <left_p>, <right_p>)' calcula los valores singulares
     de <A> y los vectores sigulares por la izquierda cuando <left_p> =
     'true', y los vectores sigulares por la derecha cuando <right_p> =
     'true'.

     La función devuelve una lista de tres elementos.  El primer
     elemento es una lista con los valores singulares.  El segundo
     elemento es 'false' o la matriz de vectores singulares por la
     izquierda.  El tercer elemento es 'false' o la matriz de vectores
     singulares por la derecha.

     Ejemplo:

          (%i1) load (lapack)$
          (%i2) fpprintprec : 6;
          (%o2)                           6
          (%i3) M: matrix([1, 2, 3], [3.5, 0.5, 8], [-1, 2, -3], [4, 9, 7]);
                                  [  1    2    3  ]
                                  [               ]
                                  [ 3.5  0.5   8  ]
          (%o3)                   [               ]
                                  [ - 1   2   - 3 ]
                                  [               ]
                                  [  4    9    7  ]
          (%i4) dgesvd (M);
          (%o4)      [[14.4744, 6.38637, .452547], false, false]
          (%i5) [sigma, U, VT] : dgesvd (M, true, true);
          (%o5) [[14.4744, 6.38637, .452547],
          [ - .256731  .00816168   .959029    - .119523 ]
          [                                             ]
          [ - .526456   .672116   - .206236   - .478091 ]
          [                                             ],
          [  .107997   - .532278  - .0708315  - 0.83666 ]
          [                                             ]
          [ - .803287  - .514659  - .180867    .239046  ]
          [ - .374486  - .538209  - .755044 ]
          [                                 ]
          [  .130623   - .836799   0.5317   ]]
          [                                 ]
          [ - .917986   .100488    .383672  ]
          (%i6) m : length (U);
          (%o6)                           4
          (%i7) n : length (VT);
          (%o7)                           3
          (%i8) Sigma:
                  genmatrix(lambda ([i, j], if i=j then sigma[i] else 0),
                            m, n);
                            [ 14.4744     0        0    ]
                            [                           ]
                            [    0     6.38637     0    ]
          (%o8)             [                           ]
                            [    0        0     .452547 ]
                            [                           ]
                            [    0        0        0    ]
          (%i9) U . Sigma . VT - M;
                    [  1.11022E-15        0.0       1.77636E-15 ]
                    [                                           ]
                    [  1.33227E-15    1.66533E-15       0.0     ]
          (%o9)     [                                           ]
                    [ - 4.44089E-16  - 8.88178E-16  4.44089E-16 ]
                    [                                           ]
                    [  8.88178E-16    1.77636E-15   8.88178E-16 ]
          (%i10) transpose (U) . U;
                 [     1.0      5.55112E-17    2.498E-16     2.77556E-17  ]
                 [                                                        ]
                 [ 5.55112E-17      1.0       5.55112E-17    4.16334E-17  ]
          (%o10) [                                                        ]
                 [  2.498E-16   5.55112E-17       1.0       - 2.08167E-16 ]
                 [                                                        ]
                 [ 2.77556E-17  4.16334E-17  - 2.08167E-16       1.0      ]
          (%i11) VT . transpose (VT);
                    [      1.0           0.0      - 5.55112E-17 ]
                    [                                           ]
          (%o11)    [      0.0           1.0       5.55112E-17  ]
                    [                                           ]
                    [ - 5.55112E-17  5.55112E-17       1.0      ]

 -- Función: dlange (<norm>, <A>)
 -- Función: zlange (<norm>, <A>)

     Calcula una norma o seudonorma de la matriz <A>.

     'max'
          Calcula max(abs(A(i, j))), siendo i y j números de filas y
          columnas, respectivamente, de <A>.  Nótese que esta función no
          es una norma matricial.
     'one_norm'
          Calcula la norma L[1] de <A>, esto es, el máximo de la suma de
          los valores absolutos de los elementos de cada columna.
     'inf_norm'
          Calcula la norma L[inf] de <A>, esto es, el máximo de la suma
          de los valores absolutos de los elementos de cada fila.
     'frobenius'
          Calcula la norma de Frobenius de <A>, esto es, la raíz
          cuadrada de la suma de los cuadrados de los elementos de la
          matriz.

 -- Función: dgemm (<A>, <B>)
 -- Función: dgemm (<A>, <B>, <options>)
     Calcula el producto de dos matrices y, opcionalmente, suma este
     producto con una tercera matriz.

     En su forma más simple, 'dgemm(<A>, <B>)' calcula el producto de
     las matrices reales <A> y <B>.

     En la segunda forma, 'dgemm' calcula <alpha> * <A> * <B> + <beta> *
     <C>, donde <A>, <B> y <C> son matrices reales de dimensiones
     apropiadas, siendo <alpha> y <beta> números reales.  De forma
     opcional, tanto <A> como <B> pueden transponerse antes de calcular
     su producto.  Los parámetros adicionales se pueden especificar en
     cualquier orden, siendo su sintaxis de la forma 'clave=valor'.  Las
     claves reconocidas son:

     'C'
          La matriz <C> que debe ser sumada.  El valor por defecto es
          'false', lo que significa que no se sumará ninguna matriz.
     'alpha'
          El producto de <A> por <B> se multiplicará por este vaalor.
          El valor por defecto es 1.
     'beta'
          Si se da la matriz <C>, se multiplicará por este valor antes
          de ser sumada.  El valor por defecto es 0, lo que significa
          que <C> no se suma, incluso estando presente.  Por lo tanto,
          téngase cuidado en especificar un valor no nulo para <beta>.
     'transpose_a'
          Si toma el valor 'true', se utilizará la transpuesta de <A>,
          en lugar de la propia matriz <A>, en el producto.  El valor
          por defecto es 'false'.
     'transpose_b'
          Si toma el valor 'true', se utilizará la transpuesta de <B>,
          en lugar de la propia matriz <B>, en el producto.  El valor
          por defecto es 'false'.

          (%i1) load (lapack)$
          (%i2) A : matrix([1,2,3],[4,5,6],[7,8,9]);
                                            [ 1  2  3 ]
                                            [         ]
          (%o2)                             [ 4  5  6 ]
                                            [         ]
                                            [ 7  8  9 ]
          (%i3) B : matrix([-1,-2,-3],[-4,-5,-6],[-7,-8,-9]);
                                         [ - 1  - 2  - 3 ]
                                         [               ]
          (%o3)                          [ - 4  - 5  - 6 ]
                                         [               ]
                                         [ - 7  - 8  - 9 ]
          (%i4) C : matrix([3,2,1],[6,5,4],[9,8,7]);
                                            [ 3  2  1 ]
                                            [         ]
          (%o4)                             [ 6  5  4 ]
                                            [         ]
                                            [ 9  8  7 ]
          (%i5) dgemm(A,B);
                                   [ - 30.0   - 36.0   - 42.0  ]
                                   [                           ]
          (%o5)                    [ - 66.0   - 81.0   - 96.0  ]
                                   [                           ]
                                   [ - 102.0  - 126.0  - 150.0 ]
          (%i6) A . B;
                                      [ - 30   - 36   - 42  ]
                                      [                     ]
          (%o6)                       [ - 66   - 81   - 96  ]
                                      [                     ]
                                      [ - 102  - 126  - 150 ]
          (%i7) dgemm(A,B,transpose_a=true);
                                   [ - 66.0  - 78.0   - 90.0  ]
                                   [                          ]
          (%o7)                    [ - 78.0  - 93.0   - 108.0 ]
                                   [                          ]
                                   [ - 90.0  - 108.0  - 126.0 ]
          (%i8) transpose(A) . B;
                                     [ - 66  - 78   - 90  ]
                                     [                    ]
          (%o8)                      [ - 78  - 93   - 108 ]
                                     [                    ]
                                     [ - 90  - 108  - 126 ]
          (%i9) dgemm(A,B,c=C,beta=1);
                                   [ - 27.0  - 34.0   - 41.0  ]
                                   [                          ]
          (%o9)                    [ - 60.0  - 76.0   - 92.0  ]
                                   [                          ]
                                   [ - 93.0  - 118.0  - 143.0 ]
          (%i10) A . B + C;
                                      [ - 27  - 34   - 41  ]
                                      [                    ]
          (%o10)                      [ - 60  - 76   - 92  ]
                                      [                    ]
                                      [ - 93  - 118  - 143 ]
          (%i11) dgemm(A,B,c=C,beta=1, alpha=-1);
                                      [ 33.0   38.0   43.0  ]
                                      [                     ]
          (%o11)                      [ 72.0   86.0   100.0 ]
                                      [                     ]
                                      [ 111.0  134.0  157.0 ]
          (%i12) -A . B + C;
                                         [ 33   38   43  ]
                                         [               ]
          (%o12)                         [ 72   86   100 ]
                                         [               ]
                                         [ 111  134  157 ]


File: maxima.info,  Node: lbfgs,  Next: lindstedt,  Prev: lapack,  Up: Top

60 lbfgs
********

* Menu:

* Introducción a lbfgs::
* Funciones y variables para lbfgs::


File: maxima.info,  Node: Introducción a lbfgs,  Next: Funciones y variables para lbfgs,  Prev: Top,  Up: Top

60.1 Introducción a lbfgs
=========================

La función 'lbfgs' implementa el llamado algoritmo L-BFGS [1] para
resolver problemas de minimización sin restricciones mediante una
técnica cuasi-Newton con memoria limitada (BFGS). El término memoria
limitada procede del hecho de que se almacena una aproximación de rango
bajo de la inversa de la matriz hessiana, en lugar de la matriz
completa.  El programa fue originalmente escrito en Fortran [2] por
Jorge Nocedal, incorporando algunas funciones escritas originalmente por
Jorge J. Moré y David J. Thuente, traducidas posteriormente a Lisp
automáticamente con el programa 'f2cl'.  El paquete 'lbfgs' contiene el
código traducido, junto con una función interfaz que para controlar
ciertos detalles.

Referencias:

[1] D. Liu and J. Nocedal.  "On the limited memory BFGS method for large
scale optimization".  Mathematical Programming B 45:503-528 (1989)

[2] <http://netlib.org/opt/lbfgs_um.shar>


File: maxima.info,  Node: Funciones y variables para lbfgs,  Prev: Introducción a lbfgs,  Up: Top

60.2 Funciones y variables para lbfgs
=====================================

 -- Función: lbfgs (<FOM>, <X>, <X0>, <epsilon>, <iprint>)
 -- Function: lbfgs ([<FOM>, <grad>] <X>, <X0>, <epsilon>, <iprint>)

     Encuentra una solución aproximada para el problema de minimización
     sin restricciones de la función objetivo <FOM> para la lista de
     variables <X>, partiendo de los estimadores iniciales <X0>, de tal
     manera que norm(grad(FOM)) < epsilon*max(1, norm(X)).

     Si el argumento <grad> está presente, debe ser el gradiente de
     <FOM> respecto de las variables <X>.  <grad> puede ser una lista o
     una función que devuelva una lista con igual número de elementos
     que <X>.  Si el argumento no está presente, el gradiente se calcula
     automáticamente mediante derivación simbólica.  Si <FOM> es una
     función, el gradiente <grad> debe ser suministrado por el usuario.

     El algoritmo utilizado es una técnica cuasi-Newton con memoria
     limitada (BFGS) [1].  El término memoria limitada procede del hecho
     de que se almacena una aproximación de rango bajo de la inversa de
     la matriz hessiana, en lugar de la matriz completa.  Cada iteración
     del algoritmo es una búsqueda a lo largo de una recta, cuya
     dirección se calcula a partir de la matriz inversa aproximada del
     hessiano.  La función objetivo decrece siempre tras cada búsqueda
     exitosa a lo largo de la recta; además, casi siempre decrece
     también el módulo del gradiente de la función.

     El argumento <iprint> controla los mensajes de progreso que envía
     la función 'lbfgs'.

     'iprint[1]'
          '<iprint>[1]' controla la frecuencia con la que se emiten los
          mensajes.
          'iprint[1] < 0'
               No se envían mensajes.
          'iprint[1] = 0'
               Mensajes únicamente en la primera y última iteraciones.
          'iprint[1] > 0'
               Imprime un mensaje cada '<iprint>[1]' iteraciones.
     'iprint[2]'
          '<iprint>[2]' controla la cantidad de información contenida en
          los mensajes.
          'iprint[2] = 0'
               Imprime contador de iteraciones, número de evaluaciones
               de <FOM>, valor de <FOM>, módulo del gradiente de <FOM> y
               amplitud del paso.
          'iprint[2] = 1'
               Igual que '<iprint>[2] = 0', incluyendo <X0> y el
               gradiente de <FOM> evaluado en <X0>.
          'iprint[2] = 2'
               Igual que '<iprint>[2] = 1', incluyendo los valores de
               <X> en cada iteración.
          'iprint[2] = 3'
               Igual que '<iprint>[2] = 2', incluyendo el gradiente de
               <FOM> en cada iteración.

     Las columnas devueltas por 'lbfgs' son las siguientes:

     'I'
          Número de iteraciones.  Se incremente tras cada búsqueda a lo
          largo de una recta.
     'NFN'
          Número de evaluaciones de la función objetivo.
     'FUNC'
          Valor de la función objetivo al final de cada iteración.
     'GNORM'
          Módulo del gradiente de la función objetivo al final de cada
          iteración.
     'STEPLENGTH'
          Un parámetro interno del algoritmo de búsqueda.

     Para más información sobre el algoritmo se puede acudir a los
     comentarios en el código original en Fortran [2].

     Véanse también 'lbfgs_nfeval_max' y 'lbfgs_ncorrections'.

     Referencias:

     [1] D. Liu and J. Nocedal.  "On the limited memory BFGS method for
     large scale optimization".  Mathematical Programming B 45:503-528
     (1989)

     [2] <http://netlib.org/opt/lbfgs_um.shar>

     Ejemplos:

     La misma función objetivo utilizada por FGCOMPUTE en el programa
     sdrive.f del paquete LBFGS de Netlib.  Nótese que las variables en
     cuestión están subindicadas.  La función objetivo tiene un mínimo
     exacto igual a cero en u[k] = 1, para k = 1, ..., 8.

          (%i1) load (lbfgs)$
          (%i2) t1[j] := 1 - u[j];
          (%o2)                     t1  := 1 - u
                                      j         j
          (%i3) t2[j] := 10*(u[j + 1] - u[j]^2);
                                                    2
          (%o3)                t2  := 10 (u      - u )
                                 j         j + 1    j
          (%i4) n : 8;
          (%o4)                           8
          (%i5) FOM : sum (t1[2*j - 1]^2 + t2[2*j - 1]^2, j, 1, n/2);
                           2 2           2              2 2           2
          (%o5) 100 (u  - u )  + (1 - u )  + 100 (u  - u )  + (1 - u )
                      8    7           7           6    5           5
                               2 2           2              2 2           2
                  + 100 (u  - u )  + (1 - u )  + 100 (u  - u )  + (1 - u )
                          4    3           3           2    1           1
          (%i6) lbfgs (FOM, '[u[1],u[2],u[3],u[4],u[5],u[6],u[7],u[8]],
                 [-1.2, 1, -1.2, 1, -1.2, 1, -1.2, 1], 1e-3, [1, 0]);
          *************************************************
            N=    8   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  9.680000000000000D+01   GNORM=  4.657353755084533D+02
          *************************************************
           I NFN   FUNC                    GNORM                   STEPLENGTH

           1   3   1.651479526340304D+01   4.324359291335977D+00   7.926153934390631D-04
           2   4   1.650209316638371D+01   3.575788161060007D+00   1.000000000000000D+00
           3   5   1.645461701312851D+01   6.230869903601577D+00   1.000000000000000D+00
           4   6   1.636867301275588D+01   1.177589920974980D+01   1.000000000000000D+00
           5   7   1.612153014409201D+01   2.292797147151288D+01   1.000000000000000D+00
           6   8   1.569118407390628D+01   3.687447158775571D+01   1.000000000000000D+00
           7   9   1.510361958398942D+01   4.501931728123679D+01   1.000000000000000D+00
           8  10   1.391077875774293D+01   4.526061463810630D+01   1.000000000000000D+00
           9  11   1.165625686278198D+01   2.748348965356907D+01   1.000000000000000D+00
          10  12   9.859422687859144D+00   2.111494974231706D+01   1.000000000000000D+00
          11  13   7.815442521732282D+00   6.110762325764183D+00   1.000000000000000D+00
          12  15   7.346380905773044D+00   2.165281166715009D+01   1.285316401779678D-01
          13  16   6.330460634066464D+00   1.401220851761508D+01   1.000000000000000D+00
          14  17   5.238763939854303D+00   1.702473787619218D+01   1.000000000000000D+00
          15  18   3.754016790406625D+00   7.981845727632704D+00   1.000000000000000D+00
          16  20   3.001238402313225D+00   3.925482944745832D+00   2.333129631316462D-01
          17  22   2.794390709722064D+00   8.243329982586480D+00   2.503577283802312D-01
          18  23   2.563783562920545D+00   1.035413426522664D+01   1.000000000000000D+00
          19  24   2.019429976373283D+00   1.065187312340952D+01   1.000000000000000D+00
          20  25   1.428003167668592D+00   2.475962450735100D+00   1.000000000000000D+00
          21  27   1.197874264859232D+00   8.441707983339661D+00   4.303451060697367D-01
          22  28   9.023848942003913D-01   1.113189216665625D+01   1.000000000000000D+00
          23  29   5.508226405855795D-01   2.380830599637816D+00   1.000000000000000D+00
          24  31   3.902893258879521D-01   5.625595817143044D+00   4.834988416747262D-01
          25  32   3.207542206881058D-01   1.149444645298493D+01   1.000000000000000D+00
          26  33   1.874468266118200D-01   3.632482152347445D+00   1.000000000000000D+00
          27  34   9.575763380282112D-02   4.816497449000391D+00   1.000000000000000D+00
          28  35   4.085145106760390D-02   2.087009347116811D+00   1.000000000000000D+00
          29  36   1.931106005512628D-02   3.886818624052740D+00   1.000000000000000D+00
          30  37   6.894000636920714D-03   3.198505769992936D+00   1.000000000000000D+00
          31  38   1.443296008850287D-03   1.590265460381961D+00   1.000000000000000D+00
          32  39   1.571766574930155D-04   3.098257002223532D-01   1.000000000000000D+00
          33  40   1.288011779655132D-05   1.207784334505595D-02   1.000000000000000D+00
          34  41   1.806140190993455D-06   4.587890258846915D-02   1.000000000000000D+00
          35  42   1.769004612050548D-07   1.790537363138099D-02   1.000000000000000D+00
          36  43   3.312164244118216D-10   6.782068546986653D-04   1.000000000000000D+00

           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o6) [u  = 1.000005339816132, u  = 1.000009942840108,
                  1                       2
          u  = 1.000005339816132, u  = 1.000009942840108,
           3                       4
          u  = 1.000005339816132, u  = 1.000009942840108,
           5                       6
          u  = 1.000005339816132, u  = 1.000009942840108]
           7                       8

     Un problema de regresión.  La función objetivo es el cuadrado medio
     de la diferencia entre la predicción F(X[i]) y el valor observado
     Y[i].  La función F es monótona y acotada (llamada en ocasiones
     "sigmoidal").  En este ejemplo, 'lbfgs' calcula valores aproximados
     para los parámetros de F y 'plot2d' hace una representación gráfica
     comparativa de F junto con los datos observados.

          (%i1) load (lbfgs)$
          (%i2) FOM : '((1/length(X))*sum((F(X[i]) - Y[i])^2, i, 1,
                                                          length(X)));
                                         2
                         sum((F(X ) - Y ) , i, 1, length(X))
                                 i     i
          (%o2)          -----------------------------------
                                      length(X)
          (%i3) X : [1, 2, 3, 4, 5];
          (%o3)                    [1, 2, 3, 4, 5]
          (%i4) Y : [0, 0.5, 1, 1.25, 1.5];
          (%o4)                [0, 0.5, 1, 1.25, 1.5]
          (%i5) F(x) := A/(1 + exp(-B*(x - C)));
                                             A
          (%o5)            F(x) := ----------------------
                                   1 + exp((- B) (x - C))
          (%i6) ''FOM;
                          A               2            A                2
          (%o6) ((----------------- - 1.5)  + (----------------- - 1.25)
                    - B (5 - C)                  - B (4 - C)
                  %e            + 1            %e            + 1
                      A             2            A               2
           + (----------------- - 1)  + (----------------- - 0.5)
                - B (3 - C)                - B (2 - C)
              %e            + 1          %e            + 1
                       2
                      A
           + --------------------)/5
                - B (1 - C)     2
             (%e            + 1)
          (%i7) estimates : lbfgs (FOM, '[A, B, C], [1, 1, 1], 1e-4, [1, 0]);
          *************************************************
            N=    3   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  1.348738534246918D-01   GNORM=  2.000215531936760D-01
          *************************************************

          I  NFN  FUNC                    GNORM                   STEPLENGTH
          1    3  1.177820636622582D-01   9.893138394953992D-02   8.554435968992371D-01
          2    6  2.302653892214013D-02   1.180098521565904D-01   2.100000000000000D+01
          3    8  1.496348495303004D-02   9.611201567691624D-02   5.257340567840710D-01
          4    9  7.900460841091138D-03   1.325041647391314D-02   1.000000000000000D+00
          5   10  7.314495451266914D-03   1.510670810312226D-02   1.000000000000000D+00
          6   11  6.750147275936668D-03   1.914964958023037D-02   1.000000000000000D+00
          7   12  5.850716021108202D-03   1.028089194579382D-02   1.000000000000000D+00
          8   13  5.778664230657800D-03   3.676866074532179D-04   1.000000000000000D+00
          9   14  5.777818823650780D-03   3.010740179797108D-04   1.000000000000000D+00

           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o7) [A = 1.461933911464101, B = 1.601593973254801,
                                                     C = 2.528933072164855]
          (%i8) plot2d ([F(x), [discrete, X, Y]], [x, -1, 6]), ''estimates;
          (%o8)

     Especificando el gradiente de la función objetivo en lugar de
     calcularlo simbólicamente.

          (%i1) load (lbfgs)$
          (%i2) F(a, b, c) := (a - 5)^2 + (b - 3)^4 + (c - 2)^6$
          (%i3) define(F_grad(a, b, c),
                       map (lambda ([x], diff (F(a, b, c), x)), [a, b, c]))$
          (%i4) estimates : lbfgs ([F, F_grad],
                             [a, b, c], [0, 0, 0], 1e-4, [1, 0]);
          *************************************************
            N=    3   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  1.700000000000000D+02   GNORM=  2.205175729958953D+02
          *************************************************

             I  NFN     FUNC                    GNORM                   STEPLENGTH

             1    2     6.632967565917637D+01   6.498411132518770D+01   4.534785987412505D-03
             2    3     4.368890936228036D+01   3.784147651974131D+01   1.000000000000000D+00
             3    4     2.685298972775191D+01   1.640262125898520D+01   1.000000000000000D+00
             4    5     1.909064767659852D+01   9.733664001790506D+00   1.000000000000000D+00
             5    6     1.006493272061515D+01   6.344808151880209D+00   1.000000000000000D+00
             6    7     1.215263596054292D+00   2.204727876126877D+00   1.000000000000000D+00
             7    8     1.080252896385329D-02   1.431637116951845D-01   1.000000000000000D+00
             8    9     8.407195124830860D-03   1.126344579730008D-01   1.000000000000000D+00
             9   10     5.022091686198525D-03   7.750731829225275D-02   1.000000000000000D+00
            10   11     2.277152808939775D-03   5.032810859286796D-02   1.000000000000000D+00
            11   12     6.489384688303218D-04   1.932007150271009D-02   1.000000000000000D+00
            12   13     2.075791943844547D-04   6.964319310814365D-03   1.000000000000000D+00
            13   14     7.349472666162258D-05   4.017449067849554D-03   1.000000000000000D+00
            14   15     2.293617477985238D-05   1.334590390856715D-03   1.000000000000000D+00
            15   16     7.683645404048675D-06   6.011057038099202D-04   1.000000000000000D+00

           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o4) [a = 5.000086823042934, b = 3.052395429705181,
                                                     c = 1.927980629919583]

 -- Variable: lbfgs_nfeval_max
     Valor por defecto: 100

     La variable 'lbfgs_nfeval_max' almacena el número máximo de
     evaluaciones de la función objetivo en 'lbfgs'.  Cuando se alcanza
     el valor 'lbfgs_nfeval_max', 'lbfgs' devuelve el resultado logrado
     en la última iteración exitosa.

 -- Variable: lbfgs_ncorrections
     Valor por defecto: 25

     La variable 'lbfgs_ncorrections' almacena el número de correcciones
     aplicadas a la matriz inversa aproximada del hessiano, la cual es
     gestionada por 'lbfgs'.


File: maxima.info,  Node: lindstedt,  Next: linearalgebra,  Prev: lbfgs,  Up: Top

61 lindstedt
************

* Menu:

* Funciones y variables para lindstedt::


File: maxima.info,  Node: Funciones y variables para lindstedt,  Prev: lindstedt,  Up: lindstedt

61.1 Funciones y variables para lindstedt
=========================================

 -- Función: Lindstedt (<eq>,<pvar>,<torder>,<ic>)
     Este es el primer paso hacia un programa para resolver ecuaciones
     de Lindstedt.  Puede resolver problemas con condiciones iniciales,
     las cuales pueden ser constantes arbitrarias (no pueden usarse
     <%k1> ni <%k2>) donde las condiciones iniciales sobre las
     ecuaciones de perturbación son z[i]=0, z'[i]=0 para i>0.  El
     argumento <ic> es la lista de condiciones iniciales.

     Ejemplo:
          (%i1) load("makeOrders")$

          (%i2) load("lindstedt")$

          (%i3) Lindstedt('diff(x,t,2)+x-(e*x^3)/6,e,2,[1,0]);
                    2
                   e  (cos(5 T) - 24 cos(3 T) + 23 cos(T))
          (%o3) [[[---------------------------------------
                                    36864
             e (cos(3 T) - cos(T))
           - --------------------- + cos(T)],
                      192
                    2
                 7 e    e
          T = (- ---- - -- + 1) t]]
                 3072   16

     Antes de hacer uso de esta función ejecútense 'load("makeOrders")'
     y 'load("lindstedt")'.


File: maxima.info,  Node: linearalgebra,  Next: lsquares,  Prev: lindstedt,  Up: Top

62 linearalgebra
****************

* Menu:

* Introducción a linearalgebra::
* Funciones y variables para linearalgebra::


File: maxima.info,  Node: Introducción a linearalgebra,  Next: Funciones y variables para linearalgebra,  Prev: linearalgebra,  Up: linearalgebra

62.1 Introducción a linearalgebra
=================================

El paquete 'linearalgebra' contiene una batería de funciones para
álgebra lineal.

Ejemplo:

     (%i1) M : matrix ([1, 2], [1, 2]);
                                 [ 1  2 ]
     (%o1)                       [      ]
                                 [ 1  2 ]
     (%i2) nullspace (M);
                                    [  1  ]
                                    [     ]
     (%o2)                     span([   1 ])
                                    [ - - ]
                                    [   2 ]
     (%i3) columnspace (M);
                                     [ 1 ]
     (%o3)                      span([   ])
                                     [ 1 ]
     (%i4) ptriangularize (M - z*ident(2), z);
                              [ 1   2 - z   ]
     (%o4)                    [             ]
                              [           2 ]
                              [ 0  3 z - z  ]
     (%i5) M : matrix ([1, 2, 3], [4, 5, 6], [7, 8, 9]) - z*ident(3);
                          [ 1 - z    2      3   ]
                          [                     ]
     (%o5)                [   4    5 - z    6   ]
                          [                     ]
                          [   7      8    9 - z ]
     (%i6) MM : ptriangularize (M, z);
                   [ 4  5 - z            6            ]
                   [                                  ]
                   [                2                 ]
                   [     66        z    102 z   132   ]
                   [ 0   --      - -- + ----- + ---   ]
     (%o6)         [     49        7     49     49    ]
                   [                                  ]
                   [               3        2         ]
                   [           49 z    245 z    147 z ]
                   [ 0    0    ----- - ------ - ----- ]
                   [            264      88      44   ]
     (%i7) algebraic : true;
     (%o7)                         true
     (%i8) tellrat (MM [3, 3]);
                              3       2
     (%o8)                  [z  - 15 z  - 18 z]
     (%i9) MM : ratsimp (MM);
                    [ 4  5 - z           6           ]
                    [                                ]
                    [                2               ]
     (%o9)          [     66      7 z  - 102 z - 132 ]
                    [ 0   --    - ------------------ ]
                    [     49              49         ]
                    [                                ]
                    [ 0    0             0           ]
     (%i10) nullspace (MM);
                             [        1         ]
                             [                  ]
                             [   2              ]
                             [  z  - 14 z - 16  ]
                             [  --------------  ]
     (%o10)             span([        8         ])
                             [                  ]
                             [    2             ]
                             [   z  - 18 z - 12 ]
                             [ - -------------- ]
                             [         12       ]
     (%i11) M : matrix ([1, 2, 3, 4], [5, 6, 7, 8],
                        [9, 10, 11, 12], [13, 14, 15, 16]);
                            [ 1   2   3   4  ]
                            [                ]
                            [ 5   6   7   8  ]
     (%o11)                 [                ]
                            [ 9   10  11  12 ]
                            [                ]
                            [ 13  14  15  16 ]
     (%i12) columnspace (M);
                                [ 1  ]  [ 2  ]
                                [    ]  [    ]
                                [ 5  ]  [ 6  ]
     (%o12)                span([    ], [    ])
                                [ 9  ]  [ 10 ]
                                [    ]  [    ]
                                [ 13 ]  [ 14 ]
     (%i13) apply ('orthogonal_complement, args (nullspace (transpose (M))));
                                [ 0 ]  [  1  ]
                                [   ]  [     ]
                                [ 1 ]  [  0  ]
     (%o13)                span([   ], [     ])
                                [ 2 ]  [ - 1 ]
                                [   ]  [     ]
                                [ 3 ]  [ - 2 ]


File: maxima.info,  Node: Funciones y variables para linearalgebra,  Prev: Introducción a linearalgebra,  Up: linearalgebra

62.2 Funciones y variables para linearalgebra
=============================================

 -- Función: addmatrices (<f>, <M_1>, ..., <M_n>)

     Utiliza la función <f> como una función aditiva, devolviendo la
     suma de las matrices <M_1>, ..., <M_n>.  La función <f> debe ser
     tal que acepte un número arbitrario de argumentos; en otras
     palabras, será una función n-aria de Maxima.

     Ejemplos:

          (%i1) m1 : matrix([1,2],[3,4])$
          (%i2) m2 : matrix([7,8],[9,10])$
          (%i3) addmatrices('max,m1,m2);
          (%o3) matrix([7,8],[9,10])
          (%i4) addmatrices('max,m1,m2,5*m1);
          (%o4) matrix([7,10],[15,20])

 -- Función: blockmatrixp (<M>)

     Devuelve el valor 'true' si y solo si <M> es una matriz cuyos
     elementos son a su vez matrices.

 -- Función: columnop (<M>, <i>, <j>, <theta>)

     Si <M> es una matriz, devuelve la matriz que resulta de hacer la
     operación columna 'C_i <- C_i - <theta> * C_j'.  Si <M> carece de
     cualquiera de las filas <i> o <j>, devuelve un mensaje de error.

 -- Función: columnswap (<M>, <i>, <j>)

     Si <M> es una matriz, intercambia las columnas <i> y <j>.  Si <M>
     carece de cualquiera de las filas <i> o <j>, devuelve un mensaje de
     error.

 -- Función: columnspace (<M>)

     Si <M> es una matriz, devuelve 'span (v_1, ..., v_n)', donde el
     conjunto '{v_1, ..., v_n}' es la base del espacio generado por las
     columnas de <M>.

 -- Función: copy (<e>)

     Devuelve una copia de la expresión <e> de Maxima.  Aunque <e> puede
     ser cualquier expresión de Maxima, la función 'copy' es
     especialmente útil cuando <e> es una lista o una matriz.
     Considérese el siguiente ejemplo:

          (%i1) m : [1,[2,3]]$
          (%i2) mm : m$
          (%i3) mm[2][1] : x$
          (%i4) m;
          (%o4)                      [1,[x,3]]
          (%i5) mm;
          (%o5)                      [1,[x,3]]
     Veamos el mismo ejemplo siendo ahora <mm> una copia de <m>
          (%i6) m : [1,[2,3]]$
          (%i7) mm : copy(m)$
          (%i8) mm[2][1] : x$
          (%i9) m;
          (%o9)                     [1,[2,3]]
          (%i10) mm;
          (%o10)                    [1,[x,3]]
     En esta ocasión, la asignación a <mm> no cambia el valor de <m>.

 -- Función: cholesky (<M>)
 -- Función: cholesky (<M>, <field>)

     Devuelve la factorización de Cholesky de la matriz autoadjunta (o
     hermítica) <M>.  El valor por defecto del segundo argumento es
     'generalring'.  Para una descripción de los posibles valores para
     <field>, véase 'lu_factor'.

 -- Función: ctranspose (<M>)

     Devuelve la transpuesta compleja conjugada de la matriz <M>.  La
     función 'ctranspose' utiliza 'matrix_element_transpose' para
     transponer cada elemento de la matriz.

 -- Función: diag_matrix (<d_1>, <d_2>, ..., <d_n>)

     Devuelve una matriz diagonal con los elementos de la diagonal
     iguales a <d_1>, <d_2>, ..., <d_n>; cuando éstos son matrices, los
     elementos nulos de la matriz devuelta son matrices nulas de tamaño
     apropiado.  Por ejemplo:

          (%i1) diag_matrix(diag_matrix(1,2),diag_matrix(3,4));

                                      [ [ 1  0 ]  [ 0  0 ] ]
                                      [ [      ]  [      ] ]
                                      [ [ 0  2 ]  [ 0  0 ] ]
          (%o1)                       [                    ]
                                      [ [ 0  0 ]  [ 3  0 ] ]
                                      [ [      ]  [      ] ]
                                      [ [ 0  0 ]  [ 0  4 ] ]
          (%i2) diag_matrix(p,q);

                                             [ p  0 ]
          (%o2)                              [      ]
                                             [ 0  q ]

 -- Función: dotproduct (<u>, <v>)

     Devuelve el producto escalar de los vectores <u> y <v>.  Equivale a
     'conjugate (transpose (<u>)) . <v>'.  Los argumentos <u> y <v>
     deben ser vectores columna.

 -- Función: eigens_by_jacobi (<A>)
 -- Función: eigens_by_jacobi (<A>, <field_type>)

     Calcula los valores y vectores propios de <A> por el método de las
     rotaciones de Jacobi.  <A> debe ser una matriz simétrica (aunque no
     necesariamente definida o semidefinida positiva).  El argumento
     <field_type> indica el tipo numérico sobre el que se realizan los
     cálculos, que puede ser tanto 'floatfield' como 'bigfloatfield'.
     En caso de que no se especifique <field_type>, su valor por defecto
     será 'floatfield'.

     Los elementos de <A> deben ser números o expresiones reducibles a
     números mediante la ejecución de 'float' o 'bfloat', según sea el
     valor de <field_type>.

     Ejemplos:

          (%i1) S : matrix ([1/sqrt(2), 1/sqrt(2)], [- 1/sqrt(2), 1/sqrt(2)]);
                               [     1         1    ]
                               [  -------   ------- ]
                               [  sqrt(2)   sqrt(2) ]
          (%o1)                [                    ]
                               [      1        1    ]
                               [ - -------  ------- ]
                               [   sqrt(2)  sqrt(2) ]
          (%i2) L : matrix ([sqrt(3), 0], [0, sqrt(5)]);
                                [ sqrt(3)     0    ]
          (%o2)                 [                  ]
                                [    0     sqrt(5) ]
          (%i3) M : S . L . transpose (S);
                      [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
                      [ ------- + -------  ------- - ------- ]
                      [    2         2        2         2    ]
          (%o3)       [                                      ]
                      [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
                      [ ------- - -------  ------- + ------- ]
                      [    2         2        2         2    ]
          (%i4) eigens_by_jacobi (M);
          The largest percent change was 0.1454972243679
          The largest percent change was 0.0
          number of sweeps: 2
          number of rotations: 1
          (%o4) [[1.732050807568877, 2.23606797749979],
                                  [  0.70710678118655   0.70710678118655 ]
                                  [                                      ]]
                                  [ - 0.70710678118655  0.70710678118655 ]
          (%i5) float ([[sqrt(3), sqrt(5)], S]);
          (%o5) [[1.732050807568877, 2.23606797749979],
                                  [  0.70710678118655   0.70710678118655 ]
                                  [                                      ]]
                                  [ - 0.70710678118655  0.70710678118655 ]
          (%i6) eigens_by_jacobi (M, bigfloatfield);
          The largest percent change was 1.454972243679028b-1
          The largest percent change was 0.0b0
          number of sweeps: 2
          number of rotations: 1
          (%o6) [[1.732050807568877b0, 2.23606797749979b0],
                          [  7.071067811865475b-1   7.071067811865475b-1 ]
                          [                                              ]]
                          [ - 7.071067811865475b-1  7.071067811865475b-1 ]

 -- Función: get_lu_factors (<x>)

     Cuando '<x> = lu_factor (<A>)', entonces 'get_lu_factors' devuelve
     una lista de la forma '[P, L, U]', donde <P> es una matriz
     permutación, <L> es triangular inferior con unos en la diagonal y
     <U> es triangular superior, verificándose que '<A> = <P> <L> <U>'.

 -- Función: hankel (<col>)
 -- Función: hankel (<col>, <row>)

     Devuelve la matriz de Hankel <H>.  La primera columna de <H>
     coincide con <col>, excepto en el primer elemento, la última fila
     de <H> es <row>.  El valor por defecto para <row> es el vector nulo
     con igual número de elementos que <col>.

 -- Función: hessian (<f>, <x>)

     Devuelve la matriz hessiana de <f> con respecto de la lista de
     variables <x>.  El elemento '(i, j)'-ésimo de la matriz hessiana es
     'diff(<f>, <x>[i], 1, <x>[j], 1)'.

     Ejemplos:

          (%i1) hessian (x * sin (y), [x, y]);
                               [   0       cos(y)   ]
          (%o1)                [                    ]
                               [ cos(y)  - x sin(y) ]
          (%i2) depends (F, [a, b]);
          (%o2)                       [F(a, b)]
          (%i3) hessian (F, [a, b]);
                                  [   2      2   ]
                                  [  d F    d F  ]
                                  [  ---   ----- ]
                                  [    2   da db ]
                                  [  da          ]
          (%o3)                   [              ]
                                  [   2      2   ]
                                  [  d F    d F  ]
                                  [ -----   ---  ]
                                  [ da db     2  ]
                                  [         db   ]

 -- Función: hilbert_matrix (<n>)

     Devuelve la matriz de Hilbert <n> por <n>.  Si <n> no es un entero
     positivo, emite un mensaje de error.

 -- Función: identfor (<M>)
 -- Función: identfor (<M>, <fld>)

     Devuelve una matriz identidad con la misma forma que la matriz <M>.
     Los elementos de la diagonal de la matriz identidad son la
     identidad multiplicativa del campo <fld>; el valor por defecto para
     <fld> es <generalring>.

     El primer argumento <M> debe ser una matriz cuadrada o no ser
     matriz en absoluto.  Si <M> es una matriz, sus elementos pueden ser
     matrices cuadradas.  La matriz puede tener bloques a cualquier
     nivel finito de profundidad.

     Véase también 'zerofor'

 -- Función: invert_by_lu (<M>, <(rng generalring)>)

     Invierte la matriz <M> mediante la factorización LU, la cual se
     hace utilizando el anillo <rng>.

 -- Función: jacobian (<f>, <x>)

     Devuelve la matriz jacobiana de la lista de funciones <f> respecto
     de la lista de variables <x>.  El elemento '(i, j)'-ésimo de la
     matriz jacobiana es 'diff(<f>[i], <x>[j])'.

     Ejemplos:

          (%i1) jacobian ([sin (u - v), sin (u * v)], [u, v]);
                            [ cos(v - u)  - cos(v - u) ]
          (%o1)             [                          ]
                            [ v cos(u v)   u cos(u v)  ]
          (%i2) depends ([F, G], [y, z]);
          (%o2)                  [F(y, z), G(y, z)]
          (%i3) jacobian ([F, G], [y, z]);
                                     [ dF  dF ]
                                     [ --  -- ]
                                     [ dy  dz ]
          (%o3)                      [        ]
                                     [ dG  dG ]
                                     [ --  -- ]
                                     [ dy  dz ]

 -- Función: kronecker_product (<A>, <B>)

     Devuelve el producto de Kroneckerde las matrices <A> y <B>.

 -- Función: listp (<e>, <p>)
 -- Función: listp (<e>)

     Dado el argumento opcional <p>, devuelve 'true' si <e> es una lista
     de Maxima y <p> toma el valor 'true' al aplicarlo a cada elemento
     de la lista.  Si a 'listp' no se le suministra el argumento
     opcional, devuelve 'true' si <e> es una lista de Maxima.  En
     cualquier otro caso, el resultado es 'false'.

 -- Función: locate_matrix_entry (<M>, <r_1>, <c_1>, <r_2>, <c_2>, <f>,
          <rel>)

     El primer argumento debe ser una matriz, mientras que los
     argumentos desde <r_1> hasta <c_2> determinan la submatriz de <M>
     tomando las filas desde <r_1> hasta <r_2> y las columnas desde
     <c_1> hasta <c_2>.

     La función 'locate_matrix_entry' busca en la submatriz de <M> un
     elemento que satisfaga cierta propiedad.  hay tres posibilidades:

     (1) '<rel> = 'bool' y <f> es un predicado:

     Rastrea la submatriz de izquierda a derecha y de arriba hacia
     abajo, devolviendo el índice del primer elemento que satisface el
     predicado <f>; si ningún elemento lo satisface, el resultado es
     'false'.

     (2) '<rel> = 'max' y <f> una función real:

     Rastrea la submatriz buscando el elemento que maximice <f>,
     devolviendo el índice correspondiente.

     (3) '<rel> = 'min' y <f> una función real:

     Rastrea la submatriz buscando el elemento que minimice <f>,
     devolviendo el índice correspondiente.

 -- Función: lu_backsub (<M>, <b>)

     Si '<M> = lu_factor (<A>, <field>)', entonces 'lu_backsub (<M>,
     <b>)' resuelve el sistema de ecuaciones lineales '<A> <x> = <b>'.

 -- Función: lu_factor (<M>, <field>)

     Devuelve una lista de la forma '[<LU>, <perm>, <fld>]', o '[<LU>,
     <perm>, <fld>, <lower-cnd> <upper-cnd>]', donde

        * La matriz <LU> contiene la factorización de <M> de forma
          empaquetada, lo que significa tres cosas.  En primer lugar,
          que las filas de <LU> están permutadas de acuerdo con la lista
          <perm>; por ejemplo, si <perm> es la lista '[3,2,1]', la
          primera fila de la factorización <LU> es la tercera fila de la
          matriz <LU>.  En segundo lugar, el factor triangular inferior
          de <M> es la parte triangular inferior de <LU> con los
          elementos de la diagonal sustituidos por unos.  Por último, el
          factor triangular superior de <M> es la parte triangular
          superior de <LU>.

        * Si el campo es 'floatfield' o 'complexfield', los números
          <lower-cnd> y <upper-cnd> son las cotas inferior y superior
          del número de condición de la norma infinita de <M>.  El
          número de condición no se puede estimar para todos los campos,
          en cuyo caso 'lu_factor' devuelve una lista de dos elementos.
          Tanto la cota inferior como la superior pueden diferir de sus
          valores verdaderos.  Véase también 'mat_cond'.

     El argumento <M> debe ser una matriz cuadrada.

     El argumento opcional <fld> debe ser un símbolo que determine un
     anillo o un campo.  Los anillos y campos predefinidos son:

       a. 'generalring' - el anillo de las expresiones de Maxima

       b. 'floatfield' - el campo de los números decimales en coma
          flotante de doble precisión

       c. 'complexfield' - el campo de los números complejos decimales
          en coma flotante de doble precisión

       d. 'crering' - el anillo de las expresiones canónicas racionales
          (Canonical Rational Expression o CRE) de Maxima

       e. 'rationalfield' - el campo de los números racionales

       f. 'runningerror' - controla los errores de redondeo de las
          operaciones en coma flotante

       g. 'noncommutingring' - el anillo de las expresiones de Maxima en
          las que el producto es el operador no conmutativo "."

     Si el campo es 'floatfield', 'complexfield' o 'runningerror', el
     algoritmo utiliza pivoteo parcial; para los demás campos, las filas
     se cambian cuando se necesita evitar pivotes nulos.

     La suma aritmética en coma flotante no es asociativa, por lo que el
     significado de 'campo' no coincide exactamente con su definición
     matemática.

     Un elemento del campo 'runningerror' consiste en una lista de
     Maxima de la forma '[x,n]', donde <x> es un número decimal en coma
     flotante y 'n' un enetro.  La diferencia relativa entre el valor
     real de 'x' y 'x' está aproximadamente acotado por el valor epsilon
     de la máquina multiplicado por 'n'.

     No es posible la definición de un nuevo campo por parte del
     usuario, a menos que éste tenga conocimientos de Common Lisp.  Para
     hacerlo, el usuario debe definir funciones para las operaciones
     aritméticas y para convertir de la representación del campo a
     Maxima y al revés.  Además, en los campos ordenados, donde se hace
     uso del pivoteo parcial, el usuario debe definir funciones para el
     módulo y para comparar números del campo.  Después de lo anterior,
     tan solo queda definir una estructura Common Lisp 'mring'.  El
     fichero 'mring' tiene muchos ejemplos.

     Para calcular la factorización, la primera tarea consiste en
     convertir cada elemento de la matriz a un elemento del campo
     especificado.  Si la conversión no es posible, la factorización se
     detiene con un mensaje de error.  Los elementos del campo no
     necesitan ser expresiones de Maxima; por ejemplo, los elementos de
     'complexfield' son números complejos de Common Lisp.  Tras la
     factorización, los elementos de la matriz deben convertirse
     nuevamente a expresiones de Maxima.

     Véase también 'get_lu_factors'.

     Ejemplos:

          (%i1) w[i,j] := random (1.0) + %i * random (1.0);
          (%o1)          w     := random(1.) + %i random(1.)
                          i, j
          (%i2) showtime : true$
          Evaluation took 0.00 seconds (0.00 elapsed)
          (%i3) M : genmatrix (w, 100, 100)$
          Evaluation took 7.40 seconds (8.23 elapsed)
          (%i4) lu_factor (M, complexfield)$
          Evaluation took 28.71 seconds (35.00 elapsed)
          (%i5) lu_factor (M, generalring)$
          Evaluation took 109.24 seconds (152.10 elapsed)
          (%i6) showtime : false$

          (%i7) M : matrix ([1 - z, 3], [3, 8 - z]);
                                  [ 1 - z    3   ]
          (%o7)                   [              ]
                                  [   3    8 - z ]
          (%i8) lu_factor (M, generalring);
                    [ 1 - z         3        ]
                    [                        ]
          (%o8)    [[   3            9       ], [1, 2], generalring]
                    [ -----  - z - ----- + 8 ]
                    [ 1 - z        1 - z     ]
          (%i9) get_lu_factors (%);
                            [   1    0 ]  [ 1 - z         3        ]
                  [ 1  0 ]  [          ]  [                        ]
          (%o9)  [[      ], [   3      ], [                9       ]]
                  [ 0  1 ]  [ -----  1 ]  [   0    - z - ----- + 8 ]
                            [ 1 - z    ]  [              1 - z     ]
          (%i10) %[1] . %[2] . %[3];
                                  [ 1 - z    3   ]
          (%o10)                  [              ]
                                  [   3    8 - z ]

 -- Función: mat_cond (<M>, 1)
 -- Función: mat_cond (<M>, inf)

     Devuelve el número de condición de la <p>-norma de la matriz <M>.
     Los valores admisibles para <p> son 1 y <inf>.  Esta función
     utiliza la factorización LU para invertir la matriz <M>, por lo que
     el tiempo de ejecución de 'mat_cond' es proporcional al cubo del
     tamaño de la matriz; 'lu_factor' determina las cotas inferior y
     superior para el número de condición de la norma infinita en un
     tiempo proporcional al cuadrado del tamaño de la matriz.

 -- Función: mat_norm (<M>, 1)
 -- Función: mat_norm (<M>, inf)
 -- Función: mat_norm (<M>, frobenius)

     Devuelve la <p>-norma de la matriz <M>.  Los valores admisibles
     para <p> son 1, 'inf' y 'frobenius' (la norma matricial de
     Frobenius).  La matriz <M> no debe contener bloques.

 -- Función: matrixp (<e>, <p>)
 -- Función: matrixp (<e>)

     Dado el argumento opcional <p>, devuelve 'true' si <e> es una
     matriz y <p> toma el valor 'true' al aplicarlo a cada elemento de
     la matriz.  Si a 'matrixp' no se le suministra el argumento
     opcional, devuelve 'true' si <e> es una matriz.  En cualquier otro
     caso, el resultado es 'false'.

     Véase también 'blockmatrixp'

 -- Función: matrix_size (<M>)

     Devuelve una lista con el número de filas y columnas de la matriz
     <M>.

 -- Función: mat_fullunblocker (<M>)

     Si <M> es una matriz de bloques, transforma la matriz llevando
     todos los elementos de los bloques al primer nivel.  Si <M> es una
     matriz, devuelve <M>; en cualquier otro caso, envía un mensaje de
     error.

 -- Función: mat_trace (<M>)

     Calcula la traza de la matriz <M>.  Si <M> no es una matriz,
     devuelve una forma nominal.  Si <M> es una matriz de bloques,
     'mat_trace(M)' calcula el mismo valor que
     'mat_trace(mat_unblocker(m))'.

 -- Función: mat_unblocker (<M>)

     Si <M> es una matriz de bloques, deshace los bloques de un nivel.
     Si <M> es una matriz, 'mat_unblocker (M)' devuelve <M>; en
     cualquier otro caso, envía un mensaje de error.

     Si todos los elementos de <M> son matrices, 'mat_unblocker (M)'
     devuelve una matriz sin bloques, pero si los elementos de <M> son a
     su vez matrices de bloques, 'mat_unblocker (M)' devuelve una matriz
     con el nivel de bloques disminuido en uno.

     En caso de trabajar con matrices de bloques, quizás sea conveniente
     darle a 'matrix_element_mult' el valor '"."' y a
     'matrix_element_transpose' el valor ''transpose'.  Véase también
     'mat_fullunblocker'.

     Ejemplo:

          (%i1) A : matrix ([1, 2], [3, 4]);
                                      [ 1  2 ]
          (%o1)                       [      ]
                                      [ 3  4 ]
          (%i2) B : matrix ([7, 8], [9, 10]);
                                      [ 7  8  ]
          (%o2)                       [       ]
                                      [ 9  10 ]
          (%i3) matrix ([A, B]);
                               [ [ 1  2 ]  [ 7  8  ] ]
          (%o3)                [ [      ]  [       ] ]
                               [ [ 3  4 ]  [ 9  10 ] ]
          (%i4) mat_unblocker (%);
                                   [ 1  2  7  8  ]
          (%o4)                    [             ]
                                   [ 3  4  9  10 ]

 -- Función: nullspace (<M>)

     Si <M> es una matriz, devuelve 'span (v_1, ..., v_n)', siendo
     '{v_1, ..., v_n}' la base del espacio nulo de <M>.  Si el espacio
     nulo contiene un único elemento, devuelve 'span ()'.

 -- Función: nullity (<M>)

     Si <M> es una matriz, devuelve la dimensión del espacio nulo de
     <M>.

 -- Función: orthogonal_complement (<v_1>, ..., <v_n>)

     Devuelve 'span (u_1, ..., u_m)', siendo '{u_1, ..., u_m}' la base
     del complemento ortogonal del conjunto '(v_1, ..., v_n)', cuyos
     elementos deben ser vectores columna.

 -- Función: polynomialp (<p>, <L>, <coeffp>, <exponp>)
 -- Función: polynomialp (<p>, <L>, <coeffp>)
 -- Función: polynomialp (<p>, <L>)

     Devuelve 'true' si <p> es un polinomio cuyas variables son las de
     la lista <L>, el predicado <coeffp> toma el valor 'true' al
     aplicarlo a cada coeficiente y el predicado <exponp> también
     alcanza el valor 'true' al ser aplicado a los exponentes de las
     variables listadas en <L>.  En caso de necesitar que <exponp> no
     sea un predicado por defecto, se deberá especificar también el
     predicado <coeffp>, aunque aquí se desee su comportamiento por
     defecto.

     La instrucción 'polynomialp (<p>, <L>, <coeffp>)' equivale a
     'polynomialp (<p>, <L>, <coeffp>, 'nonnegintegerp)', al tiempo que
     'polynomialp (<p>, <L>)' equivale a 'polynomialp (<p>, L<,>
     'constantp, 'nonnegintegerp)'.

     No es necesario expandir el polinomio:

          (%i1) polynomialp ((x + 1)*(x + 2), [x]);
          (%o1)                         true
          (%i2) polynomialp ((x + 1)*(x + 2)^a, [x]);
          (%o2)                         false

     Un ejemplo utilizando valores distintos a los utilizados por
     defecto en <coeffp> y en <exponp>:

          (%i1) polynomialp ((x + 1)*(x + 2)^(3/2), [x],
                             numberp, numberp);
          (%o1)                         true
          (%i2) polynomialp ((x^(1/2) + 1)*(x + 2)^(3/2), [x],
                             numberp, numberp);
          (%o2)                         true

     Polinomios con dos variables:

          (%i1) polynomialp (x^2 + 5*x*y + y^2, [x]);
          (%o1)                         false
          (%i2) polynomialp (x^2 + 5*x*y + y^2, [x, y]);
          (%o2)                         true

 -- Función: polytocompanion (<p>, <x>)

     Si <p> es un polinomio en <x>, devuelve la matriz compañera de <p>.
     Para un polinomio mónico <p> de grado <n> se tiene '<p> = (-1)^<n>
     charpoly (polytocompanion (<p>, <x>))'.

     Si <p> no es un polinomio en <x>, se devuelve un mensaje de error.

 -- Función: ptriangularize (<M>, <v>)

     Si <M> es una matriz en la que sus elementos son polinomios en <v>,
     devuelve una matriz <M2> tal que

       1. <M2> es triangular superior,

       2. '<M2> = <E_n> ... <E_1> <M>', donde <E_1>, ..., <E_n> son
          matrices elementales cuyos elementos son polinomios en <v>,

       3. '|det (<M>)| = |det (<M2>)|',

     Nota: esta función no comprueba si los elementos de la matriz son
     polinomios en <v>.

 -- Función: rowop (<M>, <i>, <j>, <theta>)

     Si <M> es una matriz, devuelve la matriz que resulta de relizar la
     transformación 'R_i <- R_i - theta * R_j' con las filas 'R_i' y
     'R_j'.  Si <M> no tiene estas filas, devuelve un mensaje de error.

 -- Función: rank (<M>)

     Calcula el rango de la matriz <M>.  El rango es la dimensión del
     espacio columna.  Ejemplo:
          (%i1) rank(matrix([1,2],[2,4]));
          (%o1)                                  1
          (%i2) rank(matrix([1,b],[c,d]));
          Proviso:  {d - b c # 0}
          (%o2)                                  2

 -- Función: rowswap (<M>, <i>, <j>)

     Si <M> es una matriz, intercambia las filas <i> y <j>.  Si <M>
     carece de estas filas, devuelve un mensaje de error.

 -- Función: toeplitz (<col>)
 -- Función: toeplitz (<col>, <row>)

     Devuelve una matriz de Toeplitz <T>.  La primera columna de <T> es
     <col>, excepto su primer elemento.  La primera fila de <T> es
     <row>.  El valor por defecto para <row> es el complejo conjugado de
     <col>.  Ejemplo:
          (%i1)  toeplitz([1,2,3],[x,y,z]);
                                            [ 1  y  z ]
                                            [         ]
          (%o1)                             [ 2  1  y ]
                                            [         ]
                                            [ 3  2  1 ]
          (%i2)  toeplitz([1,1+%i]);

                                        [   1     1 - %I ]
          (%o2)                         [                ]
                                        [ %I + 1    1    ]

 -- Función: vandermonde_matrix ([<x_1>, ..., <x_n>])

     Devuelve una matriz <n> por <n>, cuya <i>-ésima fila es '[1, <x_i>,
     <x_i>^2, ... <x_i>^(<n>-1)]'.

 -- Función: zerofor (<M>)
 -- Función: zerofor (<M>, <fld>)

     Devuelve la matriz nula con la misma estructura que la matriz <M>.
     Cada elemento de la matriz nula es la identidad aditiva del campo
     <fld>; el valor por defecto de <fld> es <generalring>.

     El primer argumento de <M> debe ser una matriz cuadrada o no ser
     matriz en absoluto.  Si <M> es una matriz, cada uno de sus
     elementos puede ser una matriz cuadrada, por lo que <M> puede ser
     una matriz de Maxima definida por bloques.

     Véase también 'identfor'.

 -- Función: zeromatrixp (<M>)

     Si <M> no es una matriz definida por bloques, devuelve 'true' si
     'is (equal (<e>, 0))' es verdadero para todo elemento <e> de <M>.
     Si <M> es una matriz por bloques, devuelve 'true' si 'zeromatrixp'
     devuelve a su vez 'true' para cada elemento de <e>.


File: maxima.info,  Node: lsquares,  Next: makeOrders,  Prev: linearalgebra,  Up: Top

63 lsquares
***********

* Menu:

* Funciones y variables para lsquares::


File: maxima.info,  Node: Funciones y variables para lsquares,  Prev: lsquares,  Up: lsquares

63.1 Funciones y variables para lsquares
========================================

 -- Función: lsquares_estimates (<D>, <x>, <e>, <a>)
 -- Función: lsquares_estimates (<D>, <x>, <e>, <a>, initial = <L>, tol
          = <t>)

     Estima los parámetros <a> que mejor se ajusten a la ecuación <e> de
     variables <x> y <a> a los datos <D> por el método de los mínimos
     cuadrados.  La función 'lsquares_estimates' busca primero una
     solución exacta, y si no la encuentra, buscará una aproximada.

     El resultado es una lista de listas de ecuaciones de la forma '[a =
     ..., b = ..., c = ...]'.  Cada elemento de la lista es un mínimo
     diferente de error cuadrático medio.

     Los datos deben darse en formato matricial.  Cada fila es un dato
     (el cual suele denominarse 'registro' o 'caso' en ciertos
     contextos), y las columnas contienen los valores para cada una de
     las variables.  La lista de variables <x> asigna un nombre a cada
     una de las columnas de <D>, incluso a aquellas que no intervienen
     en el análisis.  La lista <a> asigna nombres a los parámetros cuyas
     estimaciones se buscan.  El argumento <e> es una expresión o
     ecuación de variables <x> y <a>; si <e> no es una ecuación (es
     decir, carece de igualdad), se trata como si fuese '<e> = 0'.

     Se pueden dar argumentos adicionales a 'lsquares_estimates' en
     forma de ecuaciones, las cuales se pasan tal cual a la función
     'lbfgs', que es la que se encarga de calcular las estimaciones por
     el método numérico cuando no encuentra una solución exacta.

     Cuando se pueda encontrar una solución exacta, mediante 'solve',
     los datos en <D> pueden contener valores no numéricos.  Sin
     embargo, cuando no exista solución exacta, todos los elementos de
     <D> deben ser necesariamente numéricos, lo cual incluye constantes
     numéricas tales como '%pi' o '%e' y números literales (enteros,
     racionales y decimales en coma flotante, tanto los de doble
     precisión como los de precisión arbitraria).  Los cálculos
     numéricos se realizan en doble precisión con aritmética de punto
     flotante, por lo que números de cualesquiera otro tipo son
     convenientemente convertidos antes de proceder con los cálculos.

     Antes de utilizar esta función ejecútese 'load(lsquares)'.

     Véanse también 'lsquares_estimates_exact',
     'lsquares_estimates_approximate', 'lsquares_mse',
     'lsquares_residuals' y 'lsquares_residual_mse'.

     Ejemplos:

     Un problema con solución exacta.

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                  [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                            [ 1  1  1 ]
                                            [         ]
                                            [ 3       ]
                                            [ -  1  2 ]
                                            [ 2       ]
                                            [         ]
          (%o2)                             [ 9       ]
                                            [ -  2  1 ]
                                            [ 4       ]
                                            [         ]
                                            [ 3  2  2 ]
                                            [         ]
                                            [ 2  2  1 ]
          (%i3) lsquares_estimates (
                   M, [z,x,y], (z+D)^2 = A*x+B*y+C, [A,B,C,D]);
                                   59        27      10921        107
          (%o3)            [[A = - --, B = - --, C = -----, D = - ---]]
                                   16        16      1024         32

     un problema para el que no se encuentra solución exacta, por lo que
     'lsquares_estimates' recurre a la aproximación numérica.

          (%i1) load (lsquares)$
          (%i2) M : matrix ([1, 1], [2, 7/4], [3, 11/4], [4, 13/4]);
                                             [ 1  1  ]
                                             [       ]
                                             [    7  ]
                                             [ 2  -  ]
                                             [    4  ]
                                             [       ]
          (%o2)                              [    11 ]
                                             [ 3  -- ]
                                             [    4  ]
                                             [       ]
                                             [    13 ]
                                             [ 4  -- ]
                                             [    4  ]
          (%i3) lsquares_estimates (
            M, [x,y], y=a*x^b+c, [a,b,c], initial=[3,3,3], iprint=[-1,0]);
          (%o3) [[a = 1.387365874920637, b = .7110956639593767,
                                                  c = - .4142705622439105]]

 -- Función: lsquares_estimates_exact (<MSE>, <a>)

     Estima los valores de los parámetros <a> que minimizan el error
     cuadrático medio <MSE> mediante un sistema de ecuaciones que
     intentará resolver simbólicamente con 'solve'.  El error cuadrático
     medio es una expresión con parámetros <a>, como los devueltos por
     'lsquares_mse'.

     El valor devuelto por la función es una lista de listas de
     ecuaciones de la forma '[a = ..., b = ..., c = ...]'.  El resultado
     puede contener cero, uno o más elementos.  Cuando la respuesta
     contiene más de una solución, todas ellas representan mínimos del
     error cuadrático medio.

     Véanse también 'lsquares_estimates',
     'lsquares_estimates_approximate', 'lsquares_mse',
     'lsquares_residuals' y 'lsquares_residual_mse'.

     Ejemplo:

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) mse : lsquares_mse (M, [z, x, y], (z + D)^2 = A*x + B*y + C);
                     5
                    ====
                    \                 2                         2
                     >    ((D + M    )  - C - M     B - M     A)
                    /            i, 1          i, 3      i, 2
                    ====
                    i = 1
          (%o3)     ---------------------------------------------
                                          5
          (%i4) lsquares_estimates_exact (mse, [A, B, C, D]);
                            59        27      10921        107
          (%o4)     [[A = - --, B = - --, C = -----, D = - ---]]
                            16        16      1024         32

 -- Función: lsquares_estimates_approximate (<MSE>, <a>, initial = <L>,
          tol = <t>)

     Estima los valores de los parámetros <a> que minimizan el error
     cuadrático medio <MSE> mediante el algoritmo numérico 'lbfgs'.  El
     error cuadrático medio es una expresión con parámetros <a>, como
     los devueltos por 'lsquares_mse'.

     La solución devuelta por la función es un mínimo local
     (posiblemente global) del error cuadrático medio.

     Por consistencia con 'lsquares_estimates_exact', el valor devuelto
     es una lista anidada con un único elemento, consistente en una
     lista de ecuaciones de la forma '[a = ..., b = ..., c = ...]'.

     Los argumentos adicionales de 'lsquares_estimates_approximate' se
     especifican como ecuaciones y se pasan de esta forma a la función
     'lbfgs'.

     <MSE> debe devolver un número cuando a sus parámetros se les
     asignen valores numéricos, lo cual implica que los datos a partir
     de los cuales se ha generado <MSE> contengan únicamente constantes
     numéricas tales como '%pi' o '%e' y números literales (enteros,
     racionales y decimales en coma flotante, tanto los de doble
     precisión como los de precisión arbitraria).  Los cálculos
     numéricos se realizan en doble precisión con aritmética de punto
     flotante, por lo que números de cualesquiera otro tipo son
     convenientemente convertidos antes de proceder con los cálculos.

     Antes de utilizar esta función ejecútese 'load(lsquares)'.

     Véanse también 'lsquares_estimates', 'lsquares_estimates_exact',
     'lsquares_mse', 'lsquares_residuals' y 'lsquares_residual_mse'.

     Ejemplo:

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) mse : lsquares_mse (M, [z, x, y], (z + D)^2 = A*x + B*y + C);
                     5
                    ====
                    \                 2                         2
                     >    ((D + M    )  - C - M     B - M     A)
                    /            i, 1          i, 3      i, 2
                    ====
                    i = 1
          (%o3)     ---------------------------------------------
                                          5
          (%i4) lsquares_estimates_approximate (
                        mse, [A, B, C, D], iprint = [-1, 0]);
          (%o4) [[A = - 3.67850494740174, B = - 1.683070351177813,
                           C = 10.63469950148635, D = - 3.340357993175206]]

 -- Función: lsquares_mse (<D>, <x>, <e>)

     Devuelve el error medio cuadrático (MSE) para la ecuación <e> de
     variables <x> respecto de los datos <D>.  El resultado devuelto es
     una suma, definida como

                              n
                             ====
                         1   \                        2
                         -    >    (lhs(e ) - rhs(e ))
                         n   /           i         i
                             ====
                             i = 1

     siendo <n> el número de datos y '<e>[i]' es la ecuación <e>
     evaluada cuando a sus variables <x> se le asignan los valores
     asociados al dato 'i'-ésimo '<D>[i]'.

     Antes de utilizar esta función ejecútese 'load(lsquares)'.

     Ejemplo:

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) mse : lsquares_mse (M, [z, x, y], (z + D)^2 = A*x + B*y + C);
                     5
                    ====
                    \                 2                         2
                     >    ((D + M    )  - C - M     B - M     A)
                    /            i, 1          i, 3      i, 2
                    ====
                    i = 1
          (%o3)     ---------------------------------------------
                                          5
          (%i4) diff (mse, D);
                   5
                  ====
                  \                             2
                4  >    (D + M    ) ((D + M    )  - C - M     B - M     A)
                  /           i, 1         i, 1          i, 3      i, 2
                  ====
                  i = 1
          (%o4) ----------------------------------------------------------
                                            5
          (%i5) ''mse, nouns;
                         2                 2         9 2               2
          (%o5) (((D + 3)  - C - 2 B - 2 A)  + ((D + -)  - C - B - 2 A)
                                                     4
                     2               2         3 2               2
           + ((D + 2)  - C - B - 2 A)  + ((D + -)  - C - 2 B - A)
                                               2
                     2             2
           + ((D + 1)  - C - B - A) )/5

 -- Función: lsquares_residuals (<D>, <x>, <e>, <a>)

     Devuelve los residuos para la ecuación <e> de parámetros <a> y
     datos <D>.

     <D> es una matriz, <x> una lista de variables y <e> es una ecuación
     o expresión general; si <e> no es una ecuación (es decir, carece de
     igualdad), se trata como si fuese '<e> = 0'.  La lista <a> contiene
     ecuaciones que especifican valores para cualesquiera parámetros de
     <e> que no estén en <x>.

     Los residuos se definen como

                                  lhs(e ) - rhs(e )
                                       i         i

     siendo '<e>[i]' la ecuación <e> evaluada cuando las variables <x>
     toman los valores asociados al dato 'i'-ésimo '<D>[i]', y haciendo
     las asignaciones indicadas en <a> al resto de variables.

     Antes de utilizar esta función ejecútese 'load(lsquares)'.

     Ejemplo:

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                            [ 1  1  1 ]
                                            [         ]
                                            [ 3       ]
                                            [ -  1  2 ]
                                            [ 2       ]
                                            [         ]
          (%o2)                             [ 9       ]
                                            [ -  2  1 ]
                                            [ 4       ]
                                            [         ]
                                            [ 3  2  2 ]
                                            [         ]
                                            [ 2  2  1 ]
          (%i3) a : lsquares_estimates (
                    M, [z,x,y], (z+D)^2 = A*x+B*y+C, [A,B,C,D]);
                                   59        27      10921        107
          (%o3)            [[A = - --, B = - --, C = -----, D = - ---]]
                                   16        16      1024         32
          (%i4) lsquares_residuals (
                    M, [z,x,y], (z+D)^2 = A*x+B*y+C, first(a));
                                      13    13    13  13  13
          (%o4)                      [--, - --, - --, --, --]
                                      64    64    32  64  64

 -- Función: lsquares_residual_mse (<D>, <x>, <e>, <a>)

     Devuelve el residuo del error cuadrático medio (MSE) de la ecuación
     <e> para los valores parámetricos <a> y datos <D>.

     El residuo del error cuadrático medio (MSE) se define como

                              n
                             ====
                         1   \                        2
                         -    >    (lhs(e ) - rhs(e ))
                         n   /           i         i
                             ====
                             i = 1

     siendo '<e>[i]' la ecuación <e> evaluada cuando las variables <x>
     toman los valores asociados al dato 'i'-ésimo '<D>[i]', y haciendo
     las asignaciones indicadas en <a> al resto de variables.

     Antes de utilizar esta función ejecútese 'load(lsquares)'.

     Ejemplo:

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) a : lsquares_estimates (
                       M, [z,x,y], (z+D)^2 = A*x+B*y+C, [A,B,C,D]);

                            59        27      10921        107
          (%o3)     [[A = - --, B = - --, C = -----, D = - ---]]
                            16        16      1024         32
          (%i4) lsquares_residual_mse (
                       M, [z,x,y], (z + D)^2 = A*x + B*y + C, first (a));
                                        169
          (%o4)                         ----
                                        2560

 -- Función: plsquares (<Mat>,<VarList>,<depvars>)
 -- Función: plsquares (<Mat>,<VarList>,<depvars>,<maxexpon>)
 -- Función: plsquares
          (<Mat>,<VarList>,<depvars>,<maxexpon>,<maxdegree>)

     Ajuste de una función polinómica multivariante a una tabla de datos
     por el método de los mínimos cuadrados.  <Mat> es la matriz con los
     datos empíricos, <VarList> es la lista con los nombres de las
     variables (una por cada columna de <Mat>, pero puede usarse '-' en
     lugar de los nombres de variables para ignorar las columnas de
     <Mat>), <depvars> es el nombre de la variable dependiente o una
     lista con uno o más nombres de variables dependientes (cuyos
     nombres deben estar también en <VarList>), <maxexpon> es un
     argumento opcional para indicar el máximo exponente para cada una
     de las variables independientes (1 por defecto) y <maxdegree> es
     otro argumento opcional para el grado del polinomio (<maxexpon> por
     defecto); nótese que la suma de exponentes de cada término debe ser
     igual o menor que <maxdegree>.  Si 'maxdgree = 0' entonces no se
     aplicará ningún límite.

     Si <depvars> es el nombre de una variable dependiente (no en una
     lista), 'plsquares' devuelve el polinomio ajustado.  Si <depvars>
     es una lista de una o más variables dependientes, 'plsquares'
     devuelve una lista con los polinomios ajustados.  Los coeficientes
     de determinación se muestran en su orden correspondiente para
     informar sobre la bondad del ajuste.  Estos valores se almacenan
     también en la variable global <DETCOEF> en un formato de lista si
     <depvars> es a su vez una lista.

     Un ejemplo sencillo de ajuste lineal multivariante:

          (%i1) load("plsquares")$

          (%i2) plsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                          [x,y,z],z);
               Determination Coefficient for z = .9897039897039897
                                 11 y - 9 x - 14
          (%o2)              z = ---------------
                                        3

     El mismo ejemplo sin restricciones en el grado:

          (%i3) plsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                          [x,y,z],z,1,0);
               Determination Coefficient for z = 1.0
                              x y + 23 y - 29 x - 19
          (%o3)           z = ----------------------
                                        6

     Cálculo del número de diagonales de un polígono de N lados

          (%i4) plsquares(matrix([3,0],[4,2],[5,5],[6,9],[7,14],[8,20]),
                          [N,diagonals],diagonals,5);
               Determination Coefficient for diagonals = 1.0
                                          2
                                         N  - 3 N
          (%o4)              diagonals = --------
                                            2
          (%i5) ev(%, N=9);   /* Testing for a 9 sides polygon */
          (%o5)                 diagonals = 27

     Cálculo del número de formas de colocar dos reinas en un tablero n
     x n de manera que no se amenacen.

          (%i6) plsquares(matrix([0,0],[1,0],[2,0],[3,8],[4,44]),
                          [n,positions],[positions],4);
               Determination Coefficient for [positions] = [1.0]
                                   4       3      2
                                3 n  - 10 n  + 9 n  - 2 n
          (%o6)    [positions = -------------------------]
                                            6
          (%i7) ev(%[1], n=8); /* Testing for a (8 x 8) chessboard */
          (%o7)                positions = 1288

     Un ejemplo con seis variables dependientes:

          (%i8) mtrx:matrix([0,0,0,0,0,1,1,1],[0,1,0,1,1,1,0,0],
                            [1,0,0,1,1,1,0,0],[1,1,1,1,0,0,0,1])$
          (%i8) plsquares(mtrx,[a,b,_And,_Or,_Xor,_Nand,_Nor,_Nxor],
                               [_And,_Or,_Xor,_Nand,_Nor,_Nxor],1,0);
                Determination Coefficient for
          [_And, _Or, _Xor, _Nand, _Nor, _Nxor] =
          [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
          (%o2) [_And = a b, _Or = - a b + b + a,
          _Xor = - 2 a b + b + a, _Nand = 1 - a b,
          _Nor = a b - b - a + 1, _Nxor = 2 a b - b - a + 1]

     Antes de hacer uso de esta función ejecútese 'load("plsquares")'.


File: maxima.info,  Node: makeOrders,  Next: minpack,  Prev: lsquares,  Up: Top

64 makeOrders
*************

* Menu:

* Funciones y variables para makeOrders::


File: maxima.info,  Node: Funciones y variables para makeOrders,  Prev: makeOrders,  Up: makeOrders

64.1 Funciones y variables para makeOrders
==========================================

 -- Función: makeOrders (<indvarlist>,<orderlist>)
     Devuelve una lista con las potencias de las variables de un
     polinomio término a término.

          (%i1) load("makeOrders")$

          (%i2) makeOrders([a,b],[2,3]);
          (%o2) [[0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 1],
                      [1, 2], [1, 3], [2, 0], [2, 1], [2, 2], [2, 3]]
          (%i3) expand((1+a+a^2)*(1+b+b^2+b^3));
                 2  3      3    3    2  2      2    2    2
          (%o3) a  b  + a b  + b  + a  b  + a b  + b  + a  b + a b
                                                            2
                                                     + b + a  + a + 1
     donde '[0, 1]' se asocia al término b y '[2, 3]' a a^2 b^3.

     Antes de hacer uso de esta función ejecútese 'load("makeOrders")'.


File: maxima.info,  Node: minpack,  Next: mnewton,  Prev: makeOrders,  Up: Top

65 minpack
**********

* Menu:

* Introducción a minpack::
* Funciones y variables para minpack::


File: maxima.info,  Node: Introducción a minpack

65.1 Introducción a minpack
===========================

'Minpack' es una traducción a Common Lisp (via 'f2cl') de la librería
MINPACK escrita en Fortran, tal como se puede obtener de Netlib.


File: maxima.info,  Node: Funciones y variables para minpack

65.2 Funciones y variables para minpack
=======================================

 -- Función: minpack_lsquares (<flist>, <varlist>, <guess> [,
          <tolerance>, <jacobian>])

     Calcula el punto 'x' que minimiza la suma de los cuadrados de las
     funciones de la lista <flist>.  Las variables se escriben en la
     lista 'varlist'.  El argumento <guess> debe guardar una estimación
     inicial del punto óptimo.

     Los argumentos opcionales <tolerance> y <jacobian> permiten
     mantener cierto control sobre el algoritmo; <tolerance> es el error
     relativo estimado que se desea en la suma de cuadrados, mientras
     que <jacobian> puede utilizarse para especificar el jacobiano.  Si
     <jacobian> no se suministra, o se le da el valor 'true', el que ya
     tiene por defecto, el jacobiano se calcula a partir de <flist>.  Si
     <jacobian> vale 'false', se utilizará una aproximación numérica.

     'minpack_lsquares' devuelve una lista, siendo su primer elemento la
     solución estimada, el segundo la suma de cuadrados y el tercero
     indica la bondad del algoritmo, siendo sus posibles valores los
     siguientes:

     '0'
          Número incorrecto de parámetros.
     '1'
          El algoritmo estima que el error relativo de la suma de
          cuadrados es, como mucho, igual a 'tolerance'.
     '2'
          El algoritmo estima que el error relativo entre <x> y la
          solución es, como mucho, igual a 'tolerance'.
     '3'
          Las dos condiciones anteriores se cumplen.
     '4'
          El vector formado por las funciones evaluadas en el punto <x>
          es ortogonal a las columnas del jacobiano dentro de la
          precisión de la máquina.
     '5'
          El número de llamadas a las funciones ha alcanzado 100*(n+1),
          siendo n el número de variables.
     '6'
          La tolerancia es demasiado pequeña, no siendo posible reducir
          más la suma de cuadrados.
     '7'
          La tolerancia es demasiado pequeña, no siendo posible mejorar
          la solución aproximada <x>.

          /* Problem 6: Powell singular function */
          (%i1) powell(x1,x2,x3,x4) :=
                   [x1+10*x2, sqrt(5)*(x3-x4), (x2-2*x3)^2,
                        sqrt(10)*(x1-x4)^2]$
          (%i2) minpack_lsquares(powell(x1,x2,x3,x4), [x1,x2,x3,x4],
                                 [3,-1,0,1]);
          (%o2) [[1.652117596168394e-17, - 1.652117596168393e-18,
                  2.643388153869468e-18, 2.643388153869468e-18],
                 6.109327859207777e-34, 4]

          /* Same problem but use numerical approximation to Jacobian */
          (%i3) minpack_lsquares(powell(x1,x2,x3,x4), [x1,x2,x3,x4],
                                 [3,-1,0,1], jacobian = false);
          (%o3) [[5.060282149485331e-11, - 5.060282149491206e-12,
                  2.179447843547218e-11, 2.179447843547218e-11],
                 3.534491794847031e-21, 5]

 -- Función: minpack_solve (<flist>, <varlist>, <guess> [, <tolerance>,
          <jacobian>])

     Resuelve un sistema de 'n' ecuaciones con 'n' incógnitas.  Las 'n'
     ecuaciones forman la lista <flist>, estando la lista <varlist>
     formada por las incógnitas.  El argumento <guess> es una estimación
     inicial de la solución.

     Los argumentos opcionales <tolerance> y <jacobian> permiten
     mantener cierto control sobre el algoritmo; <tolerance> es el error
     relativo estimado que se desea en la suma de cuadrados, mientras
     que <jacobian> puede utilizarse para especificar el jacobiano.  Si
     <jacobian> no se suministra, o se le da el valor 'true', el que ya
     tiene por defecto, el jacobiano se calcula a partir de <flist>.  Si
     <jacobian> vale 'false', se utilizará una aproximación numérica.

     'minpack_solve' devuelve una lista, siendo su primer elemento la
     solución estimada, el segundo la suma de cuadrados y el tercero
     indica la bondad del algoritmo, siendo sus posibles valores los
     siguientes:

     '0'
          Número incorrecto de parámetros.
     '1'
          El algoritmo estima que el error relativo de la suma de
          cuadrados es, como mucho, igual a 'tolerance'.
     '2'
          El número de llamadas a las funciones ha alcanzado 100*(n+1),
          siendo n el número de incógnitas.
     '3'
          La tolerancia es demasiado pequeña, no siendo posible reducir
          más la suma de cuadrados.
     '4'
          El algoritmo no progresa adecuadamente.


File: maxima.info,  Node: mnewton,  Next: numericalio,  Prev: minpack,  Up: Top

66 mnewton
**********

* Menu:

* Funciones y variables para mnewton::


File: maxima.info,  Node: Funciones y variables para mnewton,  Prev: mnewton,  Up: mnewton

66.1 Funciones y variables para mnewton
=======================================

 -- Variable opcional: newtonepsilon
     Valor por defecto: '10.0^(-fpprec/2)'

     Precisión que determina cuando la función 'mnewton' ha conseguido
     una convergencia aceptable.  Si 'newtonepsilon' es un número
     decimal de precisión arbitraria (bigfloat), entonces 'mnewton'
     realiza los cálculos en ese formato.

     Véase también 'mnewton'.

 -- Variable opcional: newtonmaxiter
     Valor por defecto: '50'

     Número máximo de iteraciones para la función 'mnewton' en caso de
     que no se produzca convergencia, o de que ésta se haga muy lenta.

     Véase también 'mnewton'.

 -- Función: mnewton (<FuncList>,<VarList>,<GuessList>)
     Resolución de sistemas de ecuaciones no lineales por el método de
     Newton.  <FuncList> es la lista de ecuaciones a resolver, <VarList>
     es la lista con los nombres de las incógnitas y <GuessList> es la
     lista de aproximaciones iniciales.

     La solución se devuelve en el mismo formato que lo hace la función
     'solve()'.  Si no se le encuentra solución al sistema, se obtiene
     '[]' como respuesta.

     Esta función se controla con las variables globales 'newtonepsilon'
     y 'newtonmaxiter'.

          (%i1) load("mnewton")$

          (%i2) mnewton([x1+3*log(x1)-x2^2, 2*x1^2-x1*x2-5*x1+1],
                        [x1, x2], [5, 5]);
          (%o2) [[x1 = 3.756834008012769, x2 = 2.779849592817897]]
          (%i3) mnewton([2*a^a-5],[a],[1]);
          (%o3)             [[a = 1.70927556786144]]
          (%i4) mnewton([2*3^u-v/u-5, u+2^v-4], [u, v], [2, 2]);
          (%o4) [[u = 1.066618389595407, v = 1.552564766841786]]

     La variable 'newtonepsilon' controla la precisión de las
     aproximaciones.  También controla si los cálculos se realizan con
     precisión doble o arbitraria (bigfloats).

          (%i1) load(mnewton)$

          (%i2) (fpprec : 25, newtonepsilon : bfloat(10^(-fpprec+5)))$

          (%i3) mnewton([2*3^u-v/u-5, u+2^v-4], [u, v], [2, 2]);
          (%o3) [[u = 1.066618389595406772591173b0,
                                         v = 1.552564766841786450100418b0]]

     Antes de hacer uso de esta función ejecútese 'load("mnewton")'.
     Véanse también 'newtonepsilon' y 'newtonmaxiter'.


File: maxima.info,  Node: numericalio,  Next: opsubst,  Prev: mnewton,  Up: Top

67 numericalio
**************

* Menu:

* Introducción a numericalio::
* Funciones y variables para entrada y salida en formato texto::
* Funciones y variables para entrada y salida en formato binario::


File: maxima.info,  Node: Introducción a numericalio,  Next: Funciones y variables para entrada y salida en formato texto,  Prev: numericalio,  Up: numericalio

67.1 Introducción a numericalio
===============================

El paquete 'numericalio' define funciones para leer y escribir ficheros
de datos y flujos.  Las funciones de entrada y salida en formato texto
pueden leer y escribir números (enteros, decimales o decimales grandes),
símbolos y cadenas.  Las funciones de entrada y salida en formato
binario sólo pueden leer y escribir números decimales.

Si ya existe una lista, matriz o array para almacenar los datos de
entrada, las funciones de entrada de 'numericalio' pueden escribir los
datos directamente en estos objetos.  En caso contrario, 'numericalio'
tratará de generar el objeto apropiado para almacenar estos datos.

67.1.1 Entrada y salida en formato texto
----------------------------------------

In plain-text input and output, it is assumed that each item to read or
write is an atom:

En la entrada y salida de datos en formato texto se supone que cada dato
es un átomo: un número entero, decimal, decimal grande, una cadena o un
símbolo; no se admiten fracciones, números complejos o cualquier otra
expresión no atómica.  Estas funciones pueden llegar a realizar
operaciones válidas con expresiones no atómicas, pero estos resultados
no se documentan y están sujetos a cambios ulteriores.

Los átomos, tanto en los ficheros de entrada como en los de salida,
tienen el mismo formato que en los ficheros por lotes de Maxima o en la
consola interactiva.  En particular, las cadenas deben encerrarse entre
comillas dobles, la barra invertida '\' evita cualquier interpretación
especial del carácter siguiente, y el símbolo de interrogación '?' se
reconoce como el comienzo de un símbolo de Lisp.  No se reconoce ningún
carácter de continuación de línea interrumpida.

67.1.2 Separadores válidos para lectura
---------------------------------------

Las funciones para la entrada y salida de datos en formato texto tiene
un argumento opcional, <separator_flag>, para indicar qué carácter se
utiliza como separador.

Para la entrada de texto se reconocen los siguientes valores de la
variable <separator_flag>: 'comma' para los valores separados por comas,
'pipe' para los valores separados por el carácter de la barra vertical
'|', 'semicolon' para los valores separados por punto y coma ';', y
'space' para cuando los valores se separan por espacios o tabulaciones.
Si el nombre del fichero tiene extensión '.csv' y no se especifica el
argumento <separator_flag>, se tomará por defecto 'comma'.  Si el
fichero tiene cualquier otra extensión diferente de '.csv' y no se
especifica 'separator_flag', se usará por defecto 'space'.

En la entrada de texto, varios espacios y tabulaciones sucesivos cuentan
como un único separador.  Sin embargo, varias comas, barras verticales o
punto y comas sucesivos se interpretan que tienen el símbolo 'false'
entre ellos; por ejemplo, '1234,,Foo' se interpreta lo mismo que si
fuese '1234,false,Foo'.  En la salida, los átomos 'false' deben
escribirse explícitamente, por lo que la lista '[1234, false, Foo]' debe
escribirse '1234,false,Foo'.

67.1.3 Separadores válidos para escritura
-----------------------------------------

Para la entrada de texto se acepta 'tab' como valor de <separator_flag>
para datos separados por tabuladores, así como 'comma', 'pipe',
'semicolon' y 'space'.

En la escritura de texto, el átomo'false' se escribe tal cual y una
lista '[1234, false, Foo]' se escribe '1234,false,Foo'.

67.1.4 Entrada y salida de decimales en formato binario
-------------------------------------------------------

Las funciones de 'numericalio' pueden leer y escribir números decimales
en coma flotante de 8 bytes del estándar IEEE 754.  Estos números se
pueden escribir empezando por el byte menos significativo o por el más
significativo, según lo indique la variable global
'assume_external_byte_order'.  Por defecto, 'numericalio' los almacena
con el byte más significativo primero.

Cualesquiera otros tipos de decimales son transformados a 8 bytes.  El
paquete 'numericalio' no puede leer ni escribir datos binarios no
numéricos.

Ciertos entornos Lisp no reconocen valores especiales del estándar IEEE
754 (más o menos infinito, valores no numéricos, valores no normales).
El efecto que pueda producir la lectura de tales valores por parte de
'numericalio' es imprevisible.

'numericalio' incluye funciones para abrir un flujo de lectura o
escritura de flujos de bytes.


File: maxima.info,  Node: Funciones y variables para entrada y salida en formato texto,  Next: Funciones y variables para entrada y salida en formato binario,  Prev: Introducción a numericalio,  Up: numericalio

67.2 Funciones y variables para entrada y salida en formato texto
=================================================================

 -- Función: read_matrix (<S>)
 -- Función: read_matrix (<S>, <M>)
 -- Función: read_matrix (<S>, <separator_flag>)
 -- Función: read_matrix (<S>, <M>, <separator_flag>)

     'read_matrix(<S>)' lee la fuente <S> y devuelve su contenido
     completo en forma de matriz.  El tamaño de la matriz se deduce de
     los datos de entrada: cada fila del fichero forma una fila de la
     matriz.  Si hay filas con diferente número de elementos,
     'read_matrix' emite un mensaje de error.

     'read_matrix(<S>, <M>)' lee la fuente <S> y va almacenando su
     contenido en la matriz <M>, hasta que <M> esté llena o hasta que se
     consuma la fuente.  Los datos se almacenan fila a fila.  Los datos
     de entrada no necesitan tener el mismo número de filas y columnas
     que <M>.

     La fuente <S> puede ser el nombre de un fichero o de un flujo.

     Los valores aceptados para <separator_flag> son: 'comma', 'pipe',
     'semicolon' y 'space'.  Si no se especifica un valor para
     <separator_flag>, se supone que los datos están separados por
     espacios.

 -- Función: read_array (<S>, <A>)
 -- Función: read_array (<S>, <A>, <separator_flag>)

     Guarda el contenido de la fuente <S> en el array <A>, hasta que <A>
     esté lleno o hasta que se consuma la fuente.  Los datos se
     almacenan fila a fila.  Los datos de entrada no necesitan tener el
     mismo número de filas y columnas que <A>.

     La fuente <S> puede ser el nombre de un fichero o de un flujo.

     Los valores aceptados para <separator_flag> son: 'comma', 'pipe',
     'semicolon' y 'space'.  Si no se especifica un valor para
     <separator_flag>, se supone que los datos están separados por
     espacios.

 -- Función: read_hashed_array (<S>, <A>)
 -- Función: read_hashed_array (<S>, <A>, <separator_flag>)

     Lee la fuente <S> y devuelve su contenido completo en forma de
     array de claves.  La fuente <S> puede ser el nombre de un fichero o
     de un flujo.

     'read_hashed_array' interpreta el primer elemento de cada fila como
     una clave, asociando el resto de la fila, en formato de lista, a la
     clave.  Por ejemplo, la secuencia '567 12 17 32 55' equivale a
     'A[567]: [12, 17, 32, 55]$'.  Las filas no necesitan tener todas
     ellas el mismo número de elementos.

     Los valores aceptados para <separator_flag> son: 'comma', 'pipe',
     'semicolon' y 'space'.  Si no se especifica un valor para
     <separator_flag>, se supone que los datos están separados por
     espacios.

 -- Función: read_nested_list (<S>)
 -- Función: read_nested_list (<S>, <separator_flag>)

     Lee la fuente <S> y devuelve su contenido completo en forma de
     lista anidada.  La fuente <S> puede ser el nombre de un fichero o
     de un flujo.

     'read_nested_list' devuelve una lista que tiene una sublista por
     cada fila de entrada.  Los filas de entrada no necesitan tener
     todas ellas el mismo número de elementos.  Las filas en blanco no
     se ignoran, sino que se convierten en listas vacías

     Los valores aceptados para <separator_flag> son: 'comma', 'pipe',
     'semicolon' y 'space'.  Si no se especifica un valor para
     <separator_flag>, se supone que los datos están separados por
     espacios.

 -- Función: read_list (<S>)
 -- Función: read_list (<S>, <L>)
 -- Función: read_list (<S>, <separator_flag>)
 -- Función: read_list (<S>, <L>, <separator_flag>)

     'read_list(<S>)' lee la fuente <S> y devuelve su contenido como una
     lista simple.

     'read_list(<S>, <L>)' guarda el contenido de la fuente <S> en la
     lista <L>, hasta que <L> esté llena o hasta que se consuma la
     fuente.

     La fuente <S> puede ser el nombre de un fichero o de un flujo.

     Los valores aceptados para <separator_flag> son: 'comma', 'pipe',
     'semicolon' y 'space'.  Si no se especifica un valor para
     <separator_flag>, se supone que los datos están separados por
     espacios.

 -- Función: write_data (<X>, <D>)
 -- Función: write_data (<X>, <D>, <separator_flag>)

     Escribe el objeto <X> en el destino <D>.

     'write_data' escribe una matriz fila a fila; cada línea de entrada
     se corresponde con una fila.

     'write_data' escribe un array creado por 'array' o 'make_array'
     fila a fila, con una nueva línea al final de cada bloque de datos.
     Los bloques de mayores dimensiones se separan con líneas
     adicionales.

     'write_data' escribe un array de claves con cada clave seguida de
     su lista asociada en una sola línea.

     'write_data' escribe una lista anidada con una sublista por línea.

     'write_data' escribe una lista simple en una única fila.

     El destino <D> puede ser el nombre de un fichero o un flujo; en el
     primer caso, la variable global 'file_output_append' controla si el
     fichero de salida es ampliado con la nueva información o si se
     borra antes; en el segundo caso, no se realiza ningún tipo de
     acción por parte de 'write_data' después de que se hayan escrito
     los datos; en particular, el flujo se mantiene abierto.

     Los valores aceptados para <separator_flag> son: 'comma', 'pipe',
     'semicolon' y 'space'.  Si no se especifica un valor para
     <separator_flag>, se supone que los datos están separados por
     espacios.


File: maxima.info,  Node: Funciones y variables para entrada y salida en formato binario,  Prev: Funciones y variables para entrada y salida en formato texto,  Up: numericalio

67.3 Funciones y variables para entrada y salida en formato binario
===================================================================

 -- Función: assume_external_byte_order (<byte_order_flag>)

     Le indica a 'numericalio' el orden de los bytes en que debe leer y
     escribir los datos.  Los valores que reconoce <byte_order_flag> son
     dos: 'lsb', que indica que el byte menos significativo debe ser el
     primero, y 'msb', que indica que el byte más significativo es el
     que debe ir en primer lugar.

     En caso de no hacer ninguna selección, 'numericalio' interpreta que
     es el byte más significativo el que se debe leer o escribir
     primero.

 -- Función: openr_binary (<file_name>)
     Devuelve un flujo de entrada de bytes no signados para la lectura
     del fichero de nombre <file_name>.

 -- Función: openw_binary (<file_name>)
     Devuelve un flujo de entrada de bytes no signados para la escritura
     en el fichero de nombre <file_name>.

 -- Función: opena_binary (<file_name>)
     Devuelve un flujo de entrada de bytes no signados para añadir datos
     al fichero de nombre <file_name>.

 -- Función: read_binary_matrix (<S>, <M>)
     Lee números decimales en coma flotante de 8 bytes desde la fuente
     <S> y los va almacenando en la matriz <M>, bien hasta que <M> se
     llene, o bien hasta que la fuente se haya consumido.  La matriz <M>
     se rellena fila a fila.

     La fuente <S> puede ser el nombre de un fichero o un flujo.

     El orden de los bytes de los datos procedentes de la fuente se
     especifican mediante 'assume_external_byte_order'.

 -- Función: read_binary_array (<S>, <A>)
     Lee números decimales en coma flotante de 8 bytes desde la fuente
     <S> y los va almacenando en el array <A>, bien hasta que <A> se
     llene, o bien hasta que la fuente se haya consumido.  <A> debe ser
     un array creado por 'array' o por 'make_array'.  El array <A> se
     rellena fila a fila.

     La fuente <S> puede ser el nombre de un fichero o un flujo.

     El orden de los bytes de los datos procedentes de la fuente se
     especifican mediante 'assume_external_byte_order'.

 -- Función: read_binary_list (<S>)
 -- Función: read_binary_list (<S>, <L>)
     'read_binary_list(<S>)' lee el contenido completo de la fuente de
     datos <S> como una secuencia de números decimales en coma flotante
     de 8 bytes en formato binario, devolviéndolos en forma de lista.

     La fuente <S> puede ser el nombre de un fichero o un flujo.

     'read_binary_list(<S>, <L>)' lee números decimales en coma flotante
     de 8 bytes en formato binario desde la fuente <S> y los almacena en
     la lista <L>, bien hasta que ésta esté llena, o bien hasta que se
     consuman los datos de la fuente.

     El orden de los bytes de los datos procedentes de la fuente se
     especifican mediante 'assume_external_byte_order'.

 -- Función: write_binary_data (<X>, <D>)

     Escribe el objeto <X>, que contiene números decimales en coma
     flotante de 8 bytes del estándar IEEE 754, en el destino <D>.
     Cualesquiera otros tipos de decimales son transformados a 8 bytes.
     'write_binary_data' no puede escribir datos no numéricos.

     El objeto <X> puede ser una lista, una lista anidada, una matriz, o
     un array creado con 'array' o 'make_array'; <X> no puede ser ni un
     array no declarado ni cualquier otro tipo de objeto distinto a los
     citados.  'write_binary_data' escribe las listas anidadas, las
     matrices y los arrays fila a fila.

     El destino <D> puede ser el nombre de un fichero o un flujo; en el
     primer caso, la variable global 'file_output_append' controla si el
     fichero de salida es ampliado con la nueva información o si se
     borra antes; en el segundo caso, no se realiza ningún tipo de
     acción por parte de 'write_binary_data' después de que se hayan
     escrito los datos; en particular, el flujo se mantiene abierto.

     El orden de los bytes de los datos procedentes de la fuente se
     especifican mediante 'assume_external_byte_order'.


File: maxima.info,  Node: opsubst,  Next: orthopoly,  Prev: numericalio,  Up: Top

68 opsubst
**********

* Menu:

* Funciones y variables para opsubst::


File: maxima.info,  Node: Funciones y variables para opsubst,  Prev: opsubst,  Up: opsubst

68.1 Funciones y variables para opsubst
=======================================

 -- Función: opsubst (<f>,<g>,<e>)
 -- Función: opsubst (<g>=<f>,<e>)
 -- Función: opsubst ([<g1>=<f1>,<g2>=<f2>,..., <gn>=<fn>],<e>)
     La función 'opsubst' es similar a la función 'subst', excepto por
     el hecho de que 'opsubst' tan solo hace sustituciones de operadores
     en las expresiones.  En general, si <f> es un operador en la
     expresión <e>, lo cambia por <g> en la expresión <e>.

     Para determinar el operador, 'opsubst' asigna a 'inflag' el valor
     'true', lo cual significa que 'opsubst' sustituye el operador
     interno de la expresión, no el mostrado en la salida formateada.

     Ejemplo:
          (%i1) load (opsubst)$

          (%i2) opsubst(f,g,g(g(x)));
          (%o2)                     f(f(x))
          (%i3) opsubst(f,g,g(g));
          (%o3)                       f(g)
          (%i4) opsubst(f,g[x],g[x](z));
          (%o4)                       f(z)
          (%i5) opsubst(g[x],f, f(z));
          (%o5)                      g (z)
                                      x
          (%i6) opsubst(tan, sin, sin(sin));
          (%o6)                     tan(sin)
          (%i7) opsubst([f=g,g=h],f(x));
          (%o7)                       h(x)

     Internamente, Maxima no hace uso de los operadores de negación
     unaria, de división ni de la resta, por lo que:
          (%i8) opsubst("+","-",a-b);
          (%o8)                     a - b
          (%i9) opsubst("f","-",-a);
          (%o9)                      - a
          (%i10) opsubst("^^","/",a/b);
                                       a
          (%o10)                       -
                                       b

     La representación interna de -a*b es *(-1,a,b), de modo que
          (%i11) opsubst("[","*", -a*b);
          (%o11)                  [- 1, a, b]

     Si alguno de los operadores no es un símbolo de Maxima, se emitirá
     un mensaje de error:
          (%i12) opsubst(a+b,f, f(x));

          Improper name or value in functional position:
          b + a
           -- an error.  Quitting.  To debug this try debugmode(true);

     Sin embargo se permiten operadores subindicados:
          (%i13) opsubst(g[5],f, f(x));
          (%o13)                     g (x)
                                      5

     Antes de hacer uso de esta función ejecútese 'load("opsubst")'.


File: maxima.info,  Node: orthopoly,  Next: romberg,  Prev: opsubst,  Up: Top

69 orthopoly
************

* Menu:

* Introducción a polinomios ortogonales::
* Funciones y variables para polinomios ortogonales::


File: maxima.info,  Node: Introducción a polinomios ortogonales,  Next: Funciones y variables para polinomios ortogonales,  Prev: orthopoly,  Up: orthopoly

69.1 Introducción a polinomios ortogonales
==========================================

El paquete 'orthopoly' contiene funciones para la evaluación simbólica y
numérica de diversos tipos de polinomios ortogonales, como los de
Chebyshev, Laguerre, Hermite, Jacobi, Legendre y ultraesféricos
(Gegenbauer).  Además, 'orthopoly' soporta las funciones esféricas de
Bessel, Hankel y armónicas.

Referencias:
   * Abramowitz y Stegun, Handbook of Mathematical Functions, (1972,
     décima reimpresión, capítulo 22)

   * Gradshteyn y Ryzhik, Table of Integrals, Series y Products, (1980,
     edición corregida y ampliada)

   * Eugen Merzbacher, Quantum Mechanics, (1970, segunda edición)

El paquete 'orthopoly', junto con su documentación, fue escrito por
Barton Willis de la Universidad de Nebraska en Kearney.  El paquete se
distribuye con la licencia GNU General Public License (GPL).

69.1.1 Iniciándose con orthopoly
--------------------------------

'load (orthopoly)' carga el paquete 'orthopoly'.

Para obtener el polinomio de Legendre de tercer orden,

     (%i1) legendre_p (3, x);
                           3             2
                  5 (1 - x)    15 (1 - x)
     (%o1)      - ---------- + ----------- - 6 (1 - x) + 1
                      2             2

Para expresarlo como una suma de potencias de <x>, aplíquese <ratsimp> o
<rat> al resultado.

     (%i2) [ratsimp (%), rat (%)];
                             3           3
                          5 x  - 3 x  5 x  - 3 x
     (%o2)/R/            [----------, ----------]
                              2           2

De forma alternativa, conviértase el segundo argumento de to
'legendre_p' (su variable "principal") a una expresión racional canónica
(canonical rational expression, CRE)).

     (%i1) legendre_p (3, rat (x));
                                   3
                                5 x  - 3 x
     (%o1)/R/                   ----------
                                    2

Para la evaluación numérica, 'orthopoly' hace uso del análisis de error
de ejecución para estimar una cota superior del error.  Por ejemplo,

     (%i1) jacobi_p (150, 2, 3, 0.2);
     (%o1) interval(- 0.062017037936715, 1.533267919277521E-11)

Los intervalos tienen la forma 'interval (<c>, <r>)', donde <c> es el
centro y <r> el radio del intervalo.  Puesto que Maxima no soporta
aritmética de intervalos, en algunas situaciones, como en los gráficos,
puede ser necesario ignorar el error y utilizar el centro del intervalo.
Para conseguirlo conviene asignar a la variable
'orthopoly_returns_intervals' el valor 'false'.

     (%i1) orthopoly_returns_intervals : false;
     (%o1)                         false
     (%i2) jacobi_p (150, 2, 3, 0.2);
     (%o2)                  - 0.062017037936715

Véase la sección Evaluación numérica para más información.

La mayor parte de las funciones de 'orthopoly' tienen una propiedad
'gradef'; así,

     (%i1) diff (hermite (n, x), x);
     (%o1)                     2 n H     (x)
                                    n - 1
     (%i2) diff (gen_laguerre (n, a, x), x);
                   (a)               (a)
                n L   (x) - (n + a) L     (x) unit_step(n)
                   n                 n - 1
     (%o2)      ------------------------------------------
                                    x

La función 'unit_step' del segundo ejemplo evita el error que aparecería
al evaluar la expresión con <n> igual a 0.

     (%i3) ev (%, n = 0);
     (%o3)                           0

La propiedad "gradef" sólo se aplica a la variable principal; derivadas
respecto de las otras variables darán lugar normalmente a mensajes de
error; por ejemplo,

     (%i1) diff (hermite (n, x), x);
     (%o1)                     2 n H     (x)
                                    n - 1
     (%i2) diff (hermite (n, x), n);

     Maxima doesn't know the derivative of hermite with
     respect the first argument
      -- an error.  Quitting.  To debug this try debugmode(true);

Generalmente, las funciones de 'orthopoly' se distribuyen sobre listas y
matrices.  Al objeto de que la evaluación se realice completamente, las
variables opcionales 'doallmxops' y 'listarith' deben valer ambas
'true', que es el valor por defecto.  Para ilustrar la distribución
sobre matrices sirve el siguiente ejemplo

     (%i1) hermite (2, x);
                                          2
     (%o1)                    - 2 (1 - 2 x )
     (%i2) m : matrix ([0, x], [y, 0]);
                                 [ 0  x ]
     (%o2)                       [      ]
                                 [ y  0 ]
     (%i3) hermite (2, m);
                    [                             2  ]
                    [      - 2        - 2 (1 - 2 x ) ]
     (%o3)          [                                ]
                    [             2                  ]
                    [ - 2 (1 - 2 y )       - 2       ]

En el segundo ejemplo, el elemento 'i, j'-ésimo es 'hermite (2,
m[i,j])', que no es lo mismo que calcular '-2 + 4 m . m', según se ve en
el siguiente ejemplo.

     (%i4) -2 * matrix ([1, 0], [0, 1]) + 4 * m . m;
                         [ 4 x y - 2      0     ]
     (%o4)               [                      ]
                         [     0      4 x y - 2 ]

Si se evalúa una función en un punto fuera de su dominio de definición,
generalmente 'orthopoly' devolverá la función sin evaluar.  Por ejemplo,

     (%i1) legendre_p (2/3, x);
     (%o1)                        P   (x)
                                   2/3

'orthopoly' da soporte a la traducción de expresiones al formato TeX y
la representación bidimensional en el terminal.

     (%i1) spherical_harmonic (l, m, theta, phi);
                               m
     (%o1)                    Y (theta, phi)
                               l
     (%i2) tex (%);
     $$Y_{l}^{m}\left(\vartheta,\varphi\right)$$
     (%o2)                         false
     (%i3) jacobi_p (n, a, a - b, x/2);
                               (a, a - b) x
     (%o3)                    P          (-)
                               n          2
     (%i4) tex (%);
     $$P_{n}^{\left(a,a-b\right)}\left({{x}\over{2}}\right)$$
     (%o4)                         false

69.1.2 Limitaciones
-------------------

Cuando una expresión contenga varios polinomios ortogonales con órdenes
simbólicos, es posible que aunque la expresión sea nula, Maxima sea
incapaz de simplificarla a cero, por lo que si se divide por esta
cantidad, aparecerán problemas.  Por ejemplo, la siguiente expressión se
anula para enteros <n> mayores que 1, no pudiendo Maxima reducirla a
cero.

     (%i1) (2*n - 1) * legendre_p (n - 1, x) * x - n * legendre_p (n, x)
                     + (1 - n) * legendre_p (n - 2, x);
     (%o1)  (2 n - 1) P     (x) x - n P (x) + (1 - n) P     (x)
                       n - 1           n               n - 2

Para un valor específico de <n> se puede reducir la expresión a cero.

     (%i2) ev (% ,n = 10, ratsimp);
     (%o2)                           0

Generalmente, la forma polinomial de un polinomio ortogonal no es la más
apropiada para su evaluación numérica.  Aquí un ejemplo.

     (%i1) p : jacobi_p (100, 2, 3, x)$
     (%i2) subst (0.2, x, p);
     (%o2)                3.4442767023833592E+35
     (%i3) jacobi_p (100, 2, 3, 0.2);
     (%o3)  interval(0.18413609135169, 6.8990300925815987E-12)
     (%i4) float(jacobi_p (100, 2, 3, 2/10));
     (%o4)                   0.18413609135169

Este resultado se puede mejorar expandiendo el polinomio y evaluando a
continuación, lo que da una aproximación mejor.
     (%i5) p : expand(p)$
     (%i6) subst (0.2, x, p);
     (%o6) 0.18413609766122982

Sin embargo esto no vale como regla general; la expansión del polinomio
no siempre da como resultado una expresión más fácil de evaluar
numéricamente.  Sin duda, la mejor manera de hacer la evaluación
numérica consiste en hacer que uno o más de los argumentos de la función
sean decimales en coma flotante; de esta forma se utilizarán algoritmos
decimales especializados para hacer la evaluación.

La función 'float' de Maxima trabaja de forma indiscriminada; si se
aplica 'float' a una expresión que contenga un polinomio ortogonal con
el grado u orden simbólico, éstos se pueden transformar en decimales y
la expresión no ser evaluada de forma completa.  Considérese

     (%i1) assoc_legendre_p (n, 1, x);
                                    1
     (%o1)                         P (x)
                                    n
     (%i2) float (%);
                                   1.0
     (%o2)                        P   (x)
                                   n
     (%i3) ev (%, n=2, x=0.9);
                                  1.0
     (%o3)                       P   (0.9)
                                  2

La expresión en '(%o3)' no da como resultado un decimal en coma
flotante; 'orthopoly' no reconoce decimales donde espera que haya
enteros.  De forma semejante, la evaluación numérica de la función
'pochhammer' para órdenes que excedan 'pochhammer_max_index' puede ser
problemática; considérese

     (%i1) x :  pochhammer (1, 10), pochhammer_max_index : 5;
     (%o1)                         (1)
                                      10

Aplicando 'float' no da para <x> un valor decimal

     (%i2) float (x);
     (%o2)                       (1.0)
                                      10.0

A fin de evaluar <x> como decimal, es necesario asignar a
'pochhammer_max_index' en valor 11 o mayor y aplicar 'float' a <x>.

     (%i3) float (x), pochhammer_max_index : 11;
     (%o3)                       3628800.0

El valor por defecto de 'pochhammer_max_index' es 100; cámbiese este
valor tras cargar el paquete 'orthopoly'.

Por último, téngase en cuenta que las referencias bibliográficas no
coinciden a la hora de definir los polinomios ortogonales; en
'orthopoly' se han utilizado normalmente las convenciones seguidas por
Abramowitz y Stegun.

Cuando se sospeche de un fallo en 'orthopoly', compruébense algunos
casos especiales a fin de determinar si las definiciones de las que el
usuario parte coinciden con las utilizadas por el paquete 'orthopoly'.
A veces las definiciones difieren por un factor de normalización;
algunos autores utilizan versiones que hacen que las familias sean
ortogonales en otros intervalos diferentes de (-1, 1).  Así por ejemplo,
para definir un polinomio de Legendre ortogonal en (0, 1) defínase

     (%i1) shifted_legendre_p (n, x) := legendre_p (n, 2*x - 1)$

     (%i2) shifted_legendre_p (2, rat (x));
                                 2
     (%o2)/R/                 6 x  - 6 x + 1
     (%i3) legendre_p (2, rat (x));
                                    2
                                 3 x  - 1
     (%o3)/R/                    --------
                                    2

69.1.3 Evaluación numérica
--------------------------

La mayor parte de las funciones de 'orthopoly' realizan análisis de
errores en tiempo de ejecución para estimar el error en la evaluación
decimal, a excepción de las funciones esféricas de Bessel y los
polinomios asociados de Legendre de segunda especie.  Para la evaluación
numérica, las funciones esféricas de Bessel hacen uso de funciones
SLATEC. No se lleva a cabo ningún método especial de evaluación numérica
para los polinomios asociados de Legendre de segunda especie.

Es posible, aunque improbable, que el error obtenido en las evaluaciones
numéricas exceda al error estimado.

Los intervalos tienen la forma 'interval (<c>, <r>)', siendo <c> el
centro del intervalo y <r> su radio.  El centro del intervalo puede ser
un número complejo, pero el radio será siempre un número real positivo.

He aquí un ejemplo:

     (%i1) fpprec : 50$
     (%i2) y0 : jacobi_p (100, 2, 3, 0.2);
     (%o2) interval(0.1841360913516871, 6.8990300925815987E-12)
     (%i3) y1 : bfloat (jacobi_p (100, 2, 3, 1/5));
     (%o3) 1.8413609135168563091370224958913493690868904463668b-1

Se comprueba que el error es menor que el estimado

     (%i4) is (abs (part (y0, 1) - y1) < part (y0, 2));
     (%o4)                         true

En este ejemplo el error estimado es una cota superior para el error
verdadero.

Maxima no da soporte a la aritmética de intervalos.

     (%i1) legendre_p (7, 0.1) + legendre_p (8, 0.1);
     (%o1) interval(0.18032072148437508, 3.1477135311021797E-15)
             + interval(- 0.19949294375000004, 3.3769353084291579E-15)

El usuario puede definir operadores aritméticos para los intervalos.
Para definir la suma de intervalos se puede hacer

     (%i1) infix ("@+")$

     (%i2) "@+"(x,y) := interval (part (x, 1) + part (y, 1),
                                   part (x, 2) + part (y, 2))$
     (%i3) legendre_p (7, 0.1) @+ legendre_p (8, 0.1);
     (%o3) interval(- 0.019172222265624955, 6.5246488395313372E-15)

Las rutinas especiales para cálculo numérico son llamadas cuando los
argumentos son complejos.  Por ejemplo,

     (%i1) legendre_p (10, 2 + 3.0*%i);
     (%o1) interval(- 3.876378825E+7 %i - 6.0787748E+7,
                                                1.2089173052721777E-6)

Compárese con el valor verdadero.

     (%i1) float (expand (legendre_p (10, 2 + 3*%i)));
     (%o1)          - 3.876378825E+7 %i - 6.0787748E+7

Además, cuando los argumentos son números decimales grandes (big
floats), se realizan llamadas a las rutinas numéricas especiales; sin
embargo, los decimales grandes se convierten previamente a doble
precisión y de este tipo serán también los resultados.

     (%i1) ultraspherical (150, 0.5b0, 0.9b0);
     (%o1) interval(- 0.043009481257265, 3.3750051301228864E-14)

69.1.4 Gráficos y orthopoly
---------------------------

Para representar gráficamente expresiones que contengan polinomios
ortogonales se deben hacer dos cosas:
  1. Asignar a la variable opcional 'orthopoly_returns_intervals' el
     valor 'false',
  2. Comentar (con apóstrofo) las llamadas a las funciones de
     'orthopoly'.
Si las llamadas a las funciones no se comentan, Maxima las evalúa a
polinomios antes de hacer el gráfico, por lo que el código especializado
en el cálculo numérico no es llamado.  Aquí hay un ejemplo de cómo se
debe hacer para representar gráficamente una expresión que contiene un
polinomio de Legendre:

     (%i1) plot2d ('(legendre_p (5, x)), [x, 0, 1]),
           orthopoly_returns_intervals : false;
     (%o1)

La expresión 'legendre_p (5, x)' se comenta completamente, que no es lo
mismo que comentar el nombre de la función, como en ''legendre_p (5,
<x>)'.

69.1.5 Miscelánea de funciones
------------------------------

El paquete 'orthopoly' define el símbolo de Pochhammer y la función de
escalón unidad en sentencias gradef.

Para convertir los símbolos de Pochhammer en cocientes o funciones
gamma, hágase uso de 'makegamma'.

     (%i1) makegamma (pochhammer (x, n));
                               gamma(x + n)
     (%o1)                     ------------
                                 gamma(x)
     (%i2) makegamma (pochhammer (1/2, 1/2));
                                     1
     (%o2)                       ---------
                                 sqrt(%pi)

Las derivadas del símbolo de Pochhammer se dan en términos de la función
'psi'.

     (%i1) diff (pochhammer (x, n), x);
     (%o1)             (x)  (psi (x + n) - psi (x))
                          n     0             0
     (%i2) diff (pochhammer (x, n), n);
     (%o2)                   (x)  psi (x + n)
                                n    0

Es necesario tener cuidado con la expresión en '(%o1)', pues la
diferencia de las funciones 'psi' tiene polos cuando '<x> = -1, -2, ..,
-<n>'.  Estos polos se cancelan con factores de 'pochhammer (<x>, <n>)'
haciendo que la derivada sea un polinomio de grado '<n> - 1' si <n> es
entero positivo.

El símbolo de Pochhammer se define para órdenes negativos a través de su
representación como cociente de funciones gamma.  Considérese

     (%i1) q : makegamma (pochhammer (x, n));
                               gamma(x + n)
     (%o1)                     ------------
                                 gamma(x)
     (%i2) sublis ([x=11/3, n= -6], q);
                                    729
     (%o2)                        - ----
                                    2240

De forma alternativa, es posible llegar a este resultado directamente.

     (%i1) pochhammer (11/3, -6);
                                    729
     (%o1)                        - ----
                                    2240

La función de escalón unidad es continua por la izquierda; así,

     (%i1) [unit_step (-1/10), unit_step (0), unit_step (1/10)];
     (%o1)                       [0, 0, 1]

En caso de ser necesaria una función escalón unidad que no sea continua
ni por la izquierda ni por la derecha en el origen, se puede definir
haciendo uso de 'signum'; por ejemplo,

     (%i1) xunit_step (x) := (1 + signum (x))/2$

     (%i2) [xunit_step (-1/10), xunit_step (0), xunit_step (1/10)];
                                     1
     (%o2)                       [0, -, 1]
                                     2

No se debe redefinir la función 'unit_step', ya que parte del código de
'orthopoly' requiere que la función escalón sea continua por la
izquierda.

69.1.6 Algoritmos
-----------------

En general, el paquete 'orthopoly' gestiona la evaluación simbólica a
través de la representación hipergeométrica de los polinomios
ortogonales.  Las funciones hipergeométricas se evalúan utilizando las
funciones (no documentadas) 'hypergeo11' y 'hypergeo21'.  Excepciones
son las funciones de Bessel de índice semi-entero y las funciones
asociadas de Legendre de segunda especie; las funciones de Bessel de
índice semi-entero se evalúan utilizando una representación explícita,
mientras que la función asociada de Legendre de segunda especie se
evalúa recursivamente.

En cuanto a la evaluación numérica, la mayor parte de las funciones se
convierten a su forma hipergeométrica, evaluándolas mediante recursión.
Además, las excepciones son las funciones de Bessel de índice
semi-entero y las funciones asociadas de Legendre de segunda especie.
Las funciones de Bessel de índice semi-entero se evalúan numéricamente
con código SLATEC.


File: maxima.info,  Node: Funciones y variables para polinomios ortogonales,  Prev: Introducción a polinomios ortogonales,  Up: orthopoly

69.2 Funciones y variables para polinomios ortogonales
======================================================

 -- Función: assoc_legendre_p (<n>, <m>, <x>)
     Función asociada de Legendre de primera especie de grado <n> y
     orden <m>.

     Referencia: Abramowitz y Stegun, ecuaciones 22.5.37, página 779,
     8.6.6 (segunda ecuación), página 334 y 8.2.5, página 333.

 -- Función: assoc_legendre_q (<n>, <m>, <x>)
     Función asociada de Legendre de segunda especie de grado <n> y
     orden <m>.

     Referencia: Abramowitz y Stegun, ecuaciones 8.5.3 y 8.1.8.

 -- Función: chebyshev_t (<n>, <x>)
     Función de Chebyshev de primera especie.

     Referencia: Abramowitz y Stegun, ecuación 22.5.47, página 779.

 -- Función: chebyshev_u (<n>, <x>)
     Función de Chebyshev de segunda especie.

     Referencia: Abramowitz y Stegun, ecuación 22.5.48, página 779.

 -- Función: gen_laguerre (<n>, <a>, <x>)
     Polinomio de Laguerre generalizado de grado <n>.

     Referencia: Abramowitz y Stegun, ecuación 22.5.54, página 780.

 -- Función: hermite (<n>, <x>)
     Polinomio de Hermite.

     Referencia: Abramowitz y Stegun, ecuación 22.5.55, página 780.

 -- Función: intervalp (<e>)
     Devuelve 'true' si la entrada es un intervalo y 'false' en caso
     contrario.

 -- Función: jacobi_p (<n>, <a>, <b>, <x>)
     Polinomio de Jacobi.

     Los polinomios de Jacobi están definidos para todo <a> y <b>; sin
     embargo, el peso '(1 - <x>)^<a> (1 + <x>)^<b>' no es integrable
     para '<a> <= -1' o '<b> <= -1'.

     Referencia: Abramowitz y Stegun, ecuación 22.5.42, página 779.

 -- Función: laguerre (<n>, <x>)
     Polinomio de Laguerre.

     Referencia: Abramowitz y Stegun, ecuaciones 22.5.16 y 22.5.54,
     página 780.

 -- Función: legendre_p (<n>, <x>)
     Polinomio de Legendre de primera especie.

     Referencia: Abramowitz y Stegun, ecuaciones 22.5.50 y 22.5.51,
     página 779.

 -- Función: legendre_q (<n>, <x>)
     Polinomio de Legendre de segunda especie.

     Referencia: Abramowitz y Stegun, ecuaciones 8.5.3 y 8.1.8.

 -- Función: orthopoly_recur (<f>, <args>)
     Devuelve una relación recursiva para la familia de funciones
     ortogonales <f> con argumentos <args>.  La recursión se hace con
     respecto al grado del polinomio.

          (%i1) orthopoly_recur (legendre_p, [n, x]);
                              (2 n + 1) P (x) x - n P     (x)
                                         n           n - 1
          (%o1)   P     (x) = -------------------------------
                   n + 1                   n + 1

     El segundo argumento de 'orthopoly_recur' debe ser una lista con el
     número correcto de argumentos para la función <f>; si no lo es,
     Maxima emite un mensaje de error.

          (%i1) orthopoly_recur (jacobi_p, [n, x]);

          Function jacobi_p needs 4 arguments, instead it received 2
           -- an error.  Quitting.  To debug this try debugmode(true);

     Además, si <f> no es el nombre de ninguna de las familias de
     polinomios ortogonales, se emite otro mensaje de error.

          (%i1) orthopoly_recur (foo, [n, x]);

          A recursion relation for foo isn't known to Maxima
           -- an error.  Quitting.  To debug this try debugmode(true);

 -- Variable opcional: orthopoly_returns_intervals
     Valor por defecto: 'true'

     Si 'orthopoly_returns_intervals' vale 'true', los números decimales
     en coma flotante se retornan con el formato 'interval (<c>, <r>)',
     donde <c> es el centro del intervalo y <r> su radio.  El centro
     puede ser un número complejo, en cuyo caso el intervalo es un disco
     en el plano complejo.

 -- Función: orthopoly_weight (<f>, <args>)

     Devuelve una lista con tres elementos; el primer elemento es la
     fórmula del peso para la familia de polinomios ortogonales <f> con
     los argumentos dados por la lista <args>; el segundo y tercer
     elementos son los extremos inferior y superior del intervalo de
     ortogonalidad.  Por ejemplo,

          (%i1) w : orthopoly_weight (hermite, [n, x]);
                                      2
                                   - x
          (%o1)                 [%e    , - inf, inf]
          (%i2) integrate (w[1] * hermite (3, x) * hermite (2, x), x, w[2], w[3]);
          (%o2)                           0

     La variable principal de <f> debe ser un símbolo, en caso contrario
     Maxima emite un mensaje de error.

 -- Función: pochhammer (<n>, <x>)
     Símbolo de Pochhammer.  Para enteros no negativos <n> con '<n> <=
     pochhammer_max_index', la expresión 'pochhammer (<x>, <n>)' se
     evalúa como el producto '<x> (<x> + 1) (<x> + 2) ... (<x> + n - 1)'
     si '<n> > 0' y como 1 si '<n> = 0'.  Para <n> negativo, 'pochhammer
     (<x>, <n>)' se define como '(-1)^<n> / pochhammer (1 - <x>, -<n>)'.
     Así por ejemplo,

          (%i1) pochhammer (x, 3);
          (%o1)                   x (x + 1) (x + 2)
          (%i2) pochhammer (x, -3);
                                           1
          (%o2)               - -----------------------
                                (1 - x) (2 - x) (3 - x)

     A fin de convertir el símbolo de Pochhammer en un cociente de
     funciones gamma (véase Abramowitz y Stegun, ecuación 6.1.22),
     hágase uso de 'makegamma'.  Por ejemplo,

          (%i1) makegamma (pochhammer (x, n));
                                    gamma(x + n)
          (%o1)                     ------------
                                      gamma(x)

     Si <n> es mayor que 'pochhammer_max_index' o si <n> es simbólico,
     'pochhammer' devuelve una forma nominal.

          (%i1) pochhammer (x, n);
          (%o1)                         (x)
                                           n

 -- Variable opcional: pochhammer_max_index
     Valor por defecto: 100

     'pochhammer (<n>, <x>)' se evalúa como un producto si y sólo si
     '<n> <= pochhammer_max_index'.

     Ejemplos:

          (%i1) pochhammer (x, 3), pochhammer_max_index : 3;
          (%o1)                   x (x + 1) (x + 2)
          (%i2) pochhammer (x, 4), pochhammer_max_index : 3;
          (%o2)                         (x)
                                           4

     Referencia: Abramowitz y Stegun, ecuación 6.1.16, página 256.

 -- Función: spherical_bessel_j (<n>, <x>)
     Función de Bessel esférica de primera especie.

     Referencia: Abramowitz y Stegun, ecuaciones 10.1.8, página 437 y
     10.1.15, página 439.

 -- Función: spherical_bessel_y (<n>, <x>)
     Función de Bessel esférica de segunda especie.

     Referencia: Abramowitz y Stegun, ecuaciones 10.1.9, página 437 y
     10.1.15, página 439.

 -- Función: spherical_hankel1 (<n>, <x>)
     Función esférica de Hankel de primera especie.

     Referencia: Abramowitz y Stegun, ecuación 10.1.36, página 439.

 -- Función: spherical_hankel2 (<n>, <x>)
     Función esférica de Hankel de segunda especie.

     Referencia: Abramowitz y Stegun, ecuación 10.1.17, página 439.

 -- Función: spherical_harmonic (<n>, <m>, <x>, <y>)
     Función armónica esférica.

     Referencia: Merzbacher 9.64.

 -- Función: unit_step (<x>)
     Función de escalón unidad continua por la izquierda, definida de
     tal forma que 'unit_step (<x>)' se anula para '<x> <= 0' y es igual
     a 1 para '<x> > 0'.

     En caso de ser necesaria una función escalón unidad que tome el
     valor 1/2 en el origen, utilícese '(1 + signum (<x>))/2'.

 -- Función: ultraspherical (<n>, <a>, <x>)
     Polinomio ultraesférico o de Gegenbauer.

     Referencia: Abramowitz y Stegun, ecuación 22.5.46, página 779.

