This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.


File: maxima.info,  Node: Definições específicas para estatística descritiva de várias variáveis,  Next: Definições para gráficos estatísticos,  Prev: Definições para estatística descritiva,  Up: descriptive

44.4 Definições específicas para estatística descritiva de várias variáveis
===========================================================================

 -- Função: cov (<matriz>)
     A matriz de covariância da amostra de várias variáveis, definida
     como
                        n
                       ====
                    1  \           _        _
                S = -   >    (X  - X) (X  - X)'
                    n  /       j        j
                       ====
                       j = 1
     onde X_j é a j-ésima linha da matriz de amostra.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) fpprintprec : 7$  /* modifique a precisão para obter uma saída melhor */
          (%i5) cov (s2);
                [ 17.22191  13.61811  14.37217  19.39624  15.42162 ]
                [                                                  ]
                [ 13.61811  14.98774  13.30448  15.15834  14.9711  ]
                [                                                  ]
          (%o5) [ 14.37217  13.30448  15.47573  17.32544  16.18171 ]
                [                                                  ]
                [ 19.39624  15.15834  17.32544  32.17651  20.44685 ]
                [                                                  ]
                [ 15.42162  14.9711   16.18171  20.44685  24.42308 ]

     Veja também a função 'cov1'.

 -- Função: cov1 (<matriz>)
     A matriz de covariância da amostra de várias variáveis, definida
     como
                        n
                       ====
                   1   \           _        _
             S  = ---   >    (X  - X) (X  - X)'
              1   n-1  /       j        j
                       ====
                       j = 1
     where X_j is the j-th row of the sample matrix.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) fpprintprec : 7$ /* modifique a precisão para obter uma saída melhor */
          (%i5) cov1 (s2);
                [ 17.39587  13.75567  14.51734  19.59216  15.5774  ]
                [                                                  ]
                [ 13.75567  15.13913  13.43887  15.31145  15.12232 ]
                [                                                  ]
          (%o5) [ 14.51734  13.43887  15.63205  17.50044  16.34516 ]
                [                                                  ]
                [ 19.59216  15.31145  17.50044  32.50153  20.65338 ]
                [                                                  ]
                [ 15.5774   15.12232  16.34516  20.65338  24.66977 ]

     Veja também a função 'cov'.

 -- Função: global_variances (<matriz>)
 -- Função: global_variances (<matriz>, <valor_lógico>)
     A função 'global_variances' retorna uma lista de medidas de
     variância global:

        * <variância total>: 'trace(S_1)',
        * <variância média>: 'trace(S_1)/p',
        * <variância generalizada>: 'determinant(S_1)',
        * <desvio padrão generalizado>: 'sqrt(determinant(S_1))',
        * <variância efectiva> 'determinant(S_1)^(1/p)', (defined in:
          Peña, D. (2002) <Análisis de datos multivariantes>;
          McGraw-Hill, Madrid.)
        * <desvio padrão efectivo>: 'determinant(S_1)^(1/(2*p))'.
     onde <p> é a dimensão das várias variáveis aleatórias e S_1 a
     matriz de covariância retornada por 'cov1'.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) global_variances (s2);
          (%o4) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608502, 6.636590811800794, 2.576158149609762]

     A função 'global_variances' tem um argumento lógico opcional:
     'global_variances(x,true)' diz ao Maxima que 'x' é a matriz de
     dados, fazendo o mesmo que 'global_variances(x)'.  Por outro lado,
     'global_variances(x,false)' significa que 'x' não é a matriz de
     dados, mas a matriz de covariância, evitando a repetição seu
     cálculo,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) s : cov1 (s2)$
          (%i5) global_variances (s, false);
          (%o5) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608502, 6.636590811800794, 2.576158149609762]

     Veja também 'cov' e 'cov1'.

 -- Função: cor (<matriz>)
 -- Função: cor (<matriz>, <valor_lógico>)
     A matriz de correlação da maostra de várias variáveis.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) fpprintprec:7$
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) cor (s2);
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o5) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     A função 'cor' tem um argumento lógico opcional: 'cor(x,true)' diz
     ao Maxima que 'x' é a matriz de dados, fazendo o mesmo que
     'cor(x)'.  Por outro lado, 'cor(x,false)' significa que 'x' não é a
     matriz de dados, mas a matriz de covariância, evitando a repetição
     de seu cálculo,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) fpprintprec:7$
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) s : cov1 (s2)$
          (%i6) cor (s, false); /* this is faster */
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o6) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     Veja também 'cov' e 'cov1'.

 -- Função: list_correlations (<matriz>)
 -- Função: list_correlations (<matriz>, <valor_lógico>)
     A função 'list_correlations' retorna uma lista de medidas de
     correlação:

        * <matriz de precisão>: o inverso da matriz de covariância S_1,
                      -1     ij
                     S   = (s  )
                      1         i,j = 1,2,...,p

        * <vector de correlação múltipla>: (R_1^2, R_2^2, ..., R_p^2),
          com
                      2          1
                     R  = 1 - -------
                      i        ii
                              s   s
                                   ii
          sendo um indicador do melhor do ajuste do modelo de regressão
          linear de várias variáveis dobre X_i quando o resto das
          variáveis são usados como regressores.

        * <matriz de correlação parcial>: como elemento (i, j) sendo
                                        ij
                                       s
                     r        = - ------------
                      ij.rest     / ii  jj\ 1/2
                                  |s   s  |
                                  \       /

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) z : list_correlations (s2)$
          (%i5) fpprintprec : 5$ /* for pretty output */
          (%i6) z[1];  /* precision matrix */
                [  .38486   - .13856   - .15626   - .10239    .031179  ]
                [                                                      ]
                [ - .13856   .34107    - .15233    .038447   - .052842 ]
                [                                                      ]
          (%o6) [ - .15626  - .15233    .47296    - .024816  - .10054  ]
                [                                                      ]
                [ - .10239   .038447   - .024816   .10937    - .034033 ]
                [                                                      ]
                [ .031179   - .052842  - .10054   - .034033   .14834   ]
          (%i7) z[2];  /* multiple correlation vector */
          (%o7)       [.85063, .80634, .86474, .71867, .72675]
          (%i8) z[3];  /* partial correlation matrix */
                 [  - 1.0     .38244   .36627   .49908   - .13049 ]
                 [                                                ]
                 [  .38244    - 1.0    .37927  - .19907   .23492  ]
                 [                                                ]
          (%o8)  [  .36627    .37927   - 1.0    .10911    .37956  ]
                 [                                                ]
                 [  .49908   - .19907  .10911   - 1.0     .26719  ]
                 [                                                ]
                 [ - .13049   .23492   .37956   .26719    - 1.0   ]

     A função 'list_correlations' também tem um argumento lógico
     opcional: 'list_correlations(x,true)' diz ao Maxima que 'x' é a
     matriz de dados, fazendo o mesmo que 'list_correlations(x)'.  Por
     outro lado, 'list_correlations(x,false)' significa que 'x' não é a
     matriz de correlação, mas a matriz de covariancia, evitando a
     repetição de seu cálculo.

     Veja também 'cov' e 'cov1'.


File: maxima.info,  Node: Definições para gráficos estatísticos,  Prev: Definições específicas para estatística descritiva de várias variáveis,  Up: descriptive

44.5 Definições para gráficos estatísticos
==========================================

 -- Função: dataplot (<lista>)
 -- Função: dataplot (<lista>, <opção_1>, <opção_2>, ...)
 -- Função: dataplot (<matriz>)
 -- Função: dataplot (<matriz>, <opção_1>, <opção_2>, ...)
     A função 'dataplot' permite visualização directa de dados de
     amostra, ambas d uma única variável (<lista>) e de várias variáveis
     (<matriz>).  Fornecendo valores para as seguintes <opções> que são
     alguns aspéctos de impressão que podem ser controlados:

        * ''outputdev', o valor padrão é '"x"', indica o formato de
          dispositivo/ficheiro da figura de saída; valores correctos são
          '"x"', '"eps"' e '"png"', para a tela, formato de ficheiro
          postscript e formato de ficheiro png, respectivamente.

        * ''maintitle', o valor padrão é '""', é o título principal
          entre aspas duplas.

        * ''axisnames', o valor padrão é '["x","y","z"]', é uma lista de
          nomes dos eixos 'x', 'y' e 'z'.

        * ''joined', o valor padrão é 'false', um valor lógico para
          seleccionar pontos em 2D para serem unidos ou isolados.

        * ''picturescales', o valor padrão é '[1.0, 1.0]', factor de
          proporcionalidade para o tamanho do gráfico.

        * ''threedim', o valor padrão é 'true', diz ao Maxima se ou
          monta-se o gráfico de uma matriz de três colunas como um
          diagrama 3D ou se monta-se o gráfico como um diagrama de
          dispersão de várias variáveis.  Veja exemplos abaixo.

        * ''axisrot', o valor padrão é '[60, 30]', modifica o ponto de
          visualização quando ''threedim' for escolhido para 'true'
          dados forem armazenados em uma matriz de três colunas.  O
          primeiro número é o ângulo de rotação do eixo <x>, e o segundo
          número é o angulo de rotação do eixo <z>-axis, ambas as
          medidas em graus.

        * ''nclasses', o valor padrão é '10', é o número de classes para
          histogramas na diagonal de gráficos de dispersão de várias
          variáveis.

        * ''pointstyle', o valor padrão é '1', é um inteiro que indica
          como mostrar pontos de amostra.

     Por exemplo, com a seguite entrada um gráfico simples dos primeiros
     vinte dígitos de '%pi' é requisitado e a saída é armazenada em um
     ficheiro no formato eps.

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) dataplot (makelist (s1[k], k, 1, 20), 'pointstyle = 3)$

     Note que dados unidimensionais são colocados no gráfico como uma
     série de tempo.  No caso seguinte, ocorre a mesma coisa só que com
     mais dados e com mais configurações,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) dataplot (makelist (s1[k], k, 1, 50), 'maintitle = "Primeiros dígitos de pi",
           'axisnames = ["ordem do dígito", "valor do dígito"], 'pointstyle = 2,
           'joined = true)$

     A função 'dataplot' pode ser usada para montar gráficos de pontos
     no plano.  O exemplo seguinte é gráfico de dispersão de pares de
     pontos de velocidades de vento para o primeira e para o quinta
     estação meteorológica,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) dataplot (submatrix (s2, 2, 3, 4), 'pointstyle = 2,
           'maintitle = "Pares de medidas de velocidade do vento em nós",
           'axisnames = ["Velocidade do vento em A", "Velocidade do vento em E"])$

     Se pontos forem armazenados em uma matriz de duas colunas,
     'dataplot' pode montar o gráfico desses pontos directamente, mas se
     eles forem formatados em uma lista de pares, essa lista deve ser
     transformada em uma matriz como no seguinte exemplo.

          (%i1) load (descriptive)$
          (%i2) x : [[-1, 2], [5, 7], [5, -3], [-6, -9], [-4, 6]]$
          (%i3) dataplot (apply ('matrix, x), 'maintitle = "Pontos",
           'joined = true, 'axisnames = ["", ""], 'picturescales = [0.5, 1.0])$

     Pontos no espaço tridimensional podem ser vistos como uma projeção
     no plano.  Nesse exemplo, o gráfico de velocidades do vento
     correspondendo a três estações meteorológicas são requisitados,
     primeiramente em um gráfico em 3D e a seguir em um gráfico de
     dispersào de várias variáveis.

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) /* 3D plot */ dataplot (submatrix (s2, 4, 5), 'pointstyle = 2,
           'maintitle = "Pares de medidas de velocidades do vento em nós",
           'axisnames = ["Estação A", "Estação B", "Estação C"])$
          (%i5) /* Gráfico de dispersão de várias variáveis */ dataplot (submatrix (s2, 4, 5),
           'nclasses = 6, 'threedim = false)$
     Note que no último exemplo, o número de classes no histogramas da
     diagonal é escolhido para 6, e aquela opção ''threedim' for
     escolhida para 'false'.

     Para mais que três dimensões somente gráficos de dispersão de
     várias variáveis são possível, como em

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) dataplot (s2)$

 -- Função: histogram (<lista>)
 -- Função: histogram (<lista>, <opção_1>, <opção_2>, ...)
 -- Função: histogram (<one_column_matrix>)
 -- Função: histogram (<one_column_matrix>, <opção_1>, <opção_2>, ...)
     Essa função monta um gráfico de um histograma.  Dados de amostras
     devem ser armazenados em uma lista de números ou em uma matriz de
     uma coluna.  Fornecendo valores para as seguintes <opções> alguns
     aspéctos do gráfico podem ser controlados:

        * ''outputdev', o valor padrão é '"x"', indica o formato de
          ficheiro da figura de saída; valores correctos são '"x"',
          '"eps"' e '"png"', para a tela, formato de ficheiro postscript
          e formato de ficheiro png, respectivamente.

        * ''maintitle', o valor padrão é '""', é o título principal
          entre aspas duplas.

        * ''axisnames', o valor padrão é '["x", "Fr."]', é uma lista de
          nomes dos eixos 'x' e 'y'.

        * ''picturescales', o valor padrão é '[1.0, 1.0]', factor de
          proporcionalidade para o tamanho do gráfico.

        * ''nclasses', o valor padrão é '10', é o número de classes ou o
          número de barras.

        * ''relbarwidth', o valor padrão é '0.9', um número decimao
          entre 0 e 1 para controlar a largura das barras.

        * ''barcolor', o valor padrão é '1', um inteiro para indicar a
          cor das barras.

        * ''colorintensity', o valor padrão é '1', um número decimal
          entre 0 e 1 para estabelecer a intensidade da cor.

     Nos próximos dois exemplos, histogramas são requisitados para os
     primeiros 100 dígitos do número '%pi' e para velocidades do vento
     na terceira estação meteorológica.

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) histogram (s1, 'maintitle = "dígitos de pi", 'axisnames = ["", "Frequência absoluta"],
           'relbarwidth = 0.2, 'barcolor = 3, 'colorintensity = 0.6)$
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) histogram (col (s2, 3), 'colorintensity = 0.3)$
     Note tque no primeiro caso, 's1' é uma lista e o segundo exemplo,
     'col(s2,3)' é uma matriz.

     Veja também a função 'barsplot'.

 -- Função: barsplot (<lista>)
 -- Função: barsplot (<lista>, <opção_1>, <opção_2>, ...)
 -- Função: barsplot (<one_column_matrix>)
 -- Função: barsplot (<one_column_matrix>, <opção_1>, <opção_2>, ...)
     Similar a 'histogram' mas para variáveis estatísticas, numéricas ou
     divididas em categorias.  As opções estão abaixo,

        * ''outputdev', o valor padrão é '"x"', indica o formato de
          ficheiro da figura de saída; valores correctos são '"x"',
          '"eps"' e '"png"', para a tela, formato de ficheiro postscript
          e formato de ficheiro png, respectivamente.

        * ''maintitle', o valor padrão é '""', é o título principal
          entre aspas duplas.

        * ''axisnames', o valor padrão é '["x", "Fr."]', é uma lista de
          nomes dos eixos 'x' e 'y'.

        * ''picturescales', o valor padrão é '[1.0, 1.0]', factor de
          proporcionalidade para o tamanho do gráfico.

        * ''relbarwidth', o valor padrão é '0.9', um número decimao
          entre 0 e 1 para controlar a largura das barras.

        * ''barcolor', o valor padrão é '1', um inteiro para indicar a
          cor das barras.

        * ''colorintensity', o valor padrão é '1', um número decimal
          entre 0 e 1 para estabelecer a intensidade da cor.

     Esse exemplo monta um gráfico de barras para os grupos 'A' e 'B' de
     pacientes na amostra 's3',

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) barsplot (col (s3, 1), 'maintitle = "Grupos de pacientes",
           'axisnames = ["Grupo", "# de indivíduos"], 'colorintensity = 0.2)$
     A primeira coluna na amostra 's3' armazena os valores das
     categorias 'A' e 'B', também conhecidos algumas vezes como
     factores.  Por outro lado, os números inteiros positivos na segunda
     coluna sào idades, em anos, que se comportam como variável
     discreta, então podemos montar um gráfico as freqyuências absolutas
     para esses valores,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) barsplot (col (s3, 2), 'maintitle = "Idades",
           'axisnames = ["Anos", "# dos indivíduos"], 'colorintensity = 0.2,
           'relbarwidth = 0.6)$

     Veja também a função 'histogram'.

 -- Função: boxplot (<data>)
 -- Função: boxplot (<data>, <opção_1>, <opção_2>, ...)
     Essa função monta diagramas em caixas.  O argumento <data> pode ser
     uma lista, que não é de grande interesse, uma vez que esses
     diagramas são principalmente usados para comparação entre
     diferentes amostras, ou uma matriz, eentão é possível comparar dois
     ou mais componentes de uma variável estatística de várias
     variáveis.  Mas é também permitido <data> se uma lista de amostras
     com tamanhos diferentes de amostra, de facto essa é aa única função
     no pacote 'descriptive' que admite esse tipo de estrutura de dados.
     Veja o exemplo abaixo.  Abaixo etão as opções,

        * ''outputdev', o valor padrão é '"x"', indica o formato de
          ficheiro da figura de saída; valores correctos são '"x"',
          '"eps"' e '"png"', para a tela, formato de ficheiro postscript
          e formato de ficheiro png, respectivamente.

        * ''maintitle', o valor padrão é '""', é o título principal
          entre aspas duplas.

        * ''axisnames', o valor padrão é '["sample", "y"]', é uma lista
          de nomes dos eixos 'x' e 'y'.

        * ''picturescales', o valor padrão é '[1.0, 1.0]', factor de
          proporcionalidade para o tamanho do gráfico.

     Examples:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) boxplot (s2, 'maintitle = "Velocidade do vento em nós",
           'axisnames = ["Estação do ano", ""])$
          (%i5) A :
           [[6, 4, 6, 2, 4, 8, 6, 4, 6, 4, 3, 2],
            [8, 10, 7, 9, 12, 8, 10],
            [16, 13, 17, 12, 11, 18, 13, 18, 14, 12]]$
          (%i6) boxplot (A)$


File: maxima.info,  Node: diag,  Next: distrib,  Prev: descriptive,  Up: Top

45 diag
*******

* Menu:

* Definições para diag::


File: maxima.info,  Node: Definições para diag,  Prev: diag,  Up: diag

45.1 Definições para diag
=========================

 -- Função: diag (<lm>)
     Constrói a matriz quadrada com as matrizes de <lm> na diagonal.
     <lm> é uma lista de matrizes ou escalares.

     Exemplo:
          (%i1) load("diag")$

          (%i2) a1:matrix([1,2,3],[0,4,5],[0,0,6])$

          (%i3) a2:matrix([1,1],[1,0])$

          (%i4) diag([a1,x,a2]);
                             [ 1  2  3  0  0  0 ]
                             [                  ]
                             [ 0  4  5  0  0  0 ]
                             [                  ]
                             [ 0  0  6  0  0  0 ]
          (%o4)              [                  ]
                             [ 0  0  0  x  0  0 ]
                             [                  ]
                             [ 0  0  0  0  1  1 ]
                             [                  ]
                             [ 0  0  0  0  1  0 ]

     Para usar essa função escreva primeiramente 'load("diag")'.

 -- Função: JF (<lambda>,<n>)
     Retorna a célula de Jordan de ordem <n> com autovalor <lambda>.

     Exemplo:
          (%i1) load("diag")$

          (%i2) JF(2,5);
                              [ 2  1  0  0  0 ]
                              [               ]
                              [ 0  2  1  0  0 ]
                              [               ]
          (%o2)               [ 0  0  2  1  0 ]
                              [               ]
                              [ 0  0  0  2  1 ]
                              [               ]
                              [ 0  0  0  0  2 ]
          (%i3) JF(3,2);
                                   [ 3  1 ]
          (%o3)                    [      ]
                                   [ 0  3 ]

     Para usar essa função escreva primeiramente 'load("diag")'.

 -- Função: jordan (<mat>)
     Retorna a forma de Jordan da matriz <mat>, mas codificada em uma
     lista do Maxima.  Para pegar a matriz correspondente à codificação,
     chame a função 'dispJordan' sando como argumento a saída de 'JF'.

     Exemplo:
          (%i1) load("diag")$

          (%i3) a:matrix([2,0,0,0,0,0,0,0],
                         [1,2,0,0,0,0,0,0],
                         [-4,1,2,0,0,0,0,0],
                         [2,0,0,2,0,0,0,0],
                         [-7,2,0,0,2,0,0,0],
                         [9,0,-2,0,1,2,0,0],
                         [-34,7,1,-2,-1,1,2,0],
                         [145,-17,-16,3,9,-2,0,3])$

          (%i34) jordan(a);
          (%o4)             [[2, 3, 3, 1], [3, 1]]
          (%i5) dispJordan(%);
                          [ 2  1  0  0  0  0  0  0 ]
                          [                        ]
                          [ 0  2  1  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  2  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  0  2  1  0  0  0 ]
          (%o5)           [                        ]
                          [ 0  0  0  0  2  1  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  2  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  2  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  0  3 ]

     Para usar essa função escreva primeiramente 'load("diag")'.  Veja
     também 'dispJordan' e 'minimalPoly'.

 -- Função: dispJordan (<l>)
     Retorna a matriz de Jordan associada à codificação fornecida pela
     lista do Maxima <l>, que é a saída fornecida pela função 'jordan'.

     Exemplo:
          (%i1) load("diag")$

          (%i2) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i3) jordan(b1);
          (%o3)                  [[0, 3, 2]]
          (%i4) dispJordan(%);
                              [ 0  1  0  0  0 ]
                              [               ]
                              [ 0  0  1  0  0 ]
                              [               ]
          (%o4)               [ 0  0  0  0  0 ]
                              [               ]
                              [ 0  0  0  0  1 ]
                              [               ]
                              [ 0  0  0  0  0 ]

     Para usar essa função escreva primeiramente 'load("diag")'.  Veja
     também 'jordan' e 'minimalPoly'.

 -- Função: minimalPoly (<l>)
     Retorna o menor polinómio associado à codificação fornecida pela
     lista do Maxima <l>, que é a saída fornecida pela função 'jordan'.

     Exemplo:
          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                         [-2,2,1,2],
                         [-2,-1,-1,1],
                         [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) minimalPoly(%);
                                      3
          (%o4)                (x - 1)  (x + 1)

     Para usar essa função escreva prmeiramente 'load("diag")'.  Veja
     também 'jordan' e 'dispJordan'.

 -- Função: ModeMatrix (<A>,<l>)
     Retorna a matriz <M> tal que (M^^-1).A.M=J, onde <J> é a forma de
     Jordan de <A>.  A lista do Maxima <l> é a codificação da forma de
     Jordan como retornado pela função 'jordan'.

     Exemplo:
          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                    [-2,2,1,2],
                    [-2,-1,-1,1],
                    [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) M: ModeMatrix(a,%);
                            [  1    - 1   1   1 ]
                            [                   ]
                            [   1               ]
                            [ - -   - 1   0   0 ]
                            [   9               ]
                            [                   ]
          (%o4)             [   13              ]
                            [ - --   1   - 1  0 ]
                            [   9               ]
                            [                   ]
                            [  17               ]
                            [  --   - 1   1   1 ]
                            [  9                ]
          (%i5) is(  (M^^-1).a.M = dispJordan(%o3)  );
          (%o5)                      true
     Note que 'dispJordan(%o3)' é a forma de Jordan da matriz 'a'.

     Para usa essa função escreva primeiramente 'load("diag")'.  Veja
     também 'jordan' e 'dispJordan'.

 -- Função: mat_function (<f>,<mat>)
     Retorna f(mat), onde <f> é uma função analítica e <mat> uma matriz.
     Essa computação é baseada na fórmula da integral de Cauchy, que
     estabelece que se 'f(x)' for analítica e

          mat=diag([JF(m1,n1),...,JF(mk,nk)]),

     então

          f(mat)=ModeMatrix*diag([f(JF(m1,n1)),...,f(JF(mk,nk))])*ModeMatrix^^(-1)

     Note que existem entre 6 ou 8 outros métodos para esse cálculo.

     Segue-se alguns exemplos.

     Exemplo 1:
          (%i1) load("diag")$

          (%i2) b2:matrix([0,1,0], [0,0,1], [-1,-3,-3])$

          (%i3) mat_function(exp,t*b2);
                         2   - t
                        t  %e          - t     - t
          (%o3) matrix([-------- + t %e    + %e   ,
                           2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) + t (2 %e    - -----)
                  t       2                             t
                         t
                                   - t          - t     - t
                 - t       - t   %e        2  %e      %e
           + 2 %e   , t (%e    - -----) + t  (----- - -----)
                                   t            2       t
                         2   - t            - t     - t
               - t      t  %e        2    %e      %e        - t
           + %e   ], [- --------, - t  (- ----- - ----- + %e   ),
                           2                t       2
                                                   t
                  - t     - t      2   - t
             2  %e      %e        t  %e          - t
          - t  (----- - -----)], [-------- - t %e   ,
                  2       t          2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) - t (2 %e    - -----),
                  t       2                             t
                         t
                - t     - t                 - t
           2  %e      %e            - t   %e
          t  (----- - -----) - t (%e    - -----)])
                2       t                   t
          (%i4) ratsimp(%);
                         [   2              - t ]
                         [ (t  + 2 t + 2) %e    ]
                         [ -------------------- ]
                         [          2           ]
                         [                      ]
                         [         2   - t      ]
          (%o4)  Col 1 = [        t  %e         ]
                         [      - --------      ]
                         [           2          ]
                         [                      ]
                         [     2          - t   ]
                         [   (t  - 2 t) %e      ]
                         [   ----------------   ]
                         [          2           ]
                   [      2        - t    ]
                   [    (t  + t) %e       ]
                   [                      ]
           Col 2 = [     2            - t ]
                   [ - (t  - t - 1) %e    ]
                   [                      ]
                   [     2          - t   ]
                   [   (t  - 3 t) %e      ]
                   [        2   - t       ]
                   [       t  %e          ]
                   [       --------       ]
                   [          2           ]
                   [                      ]
                   [      2          - t  ]
           Col 3 = [    (t  - 2 t) %e     ]
                   [  - ----------------  ]
                   [           2          ]
                   [                      ]
                   [   2              - t ]
                   [ (t  - 4 t + 2) %e    ]
                   [ -------------------- ]
                   [          2           ]

     Exemplo 2:
          (%i5) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i6) mat_function(exp,t*b1);
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o6)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i7) minimalPoly(jordan(b1));
                                       3
          (%o7)                       x
          (%i8) ident(5)+t*b1+1/2*(t^2)*b1^^2;
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o8)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i9) mat_function(exp,%i*t*b1);
                       [                           2 ]
                       [                          t  ]
                       [ 1  0  %i t  %i t  %i t - -- ]
                       [                          2  ]
                       [                             ]
          (%o9)        [ 0  1   0    %i t    %i t    ]
                       [                             ]
                       [ 0  0   1     0      %i t    ]
                       [                             ]
                       [ 0  0   0     1        0     ]
                       [                             ]
                       [ 0  0   0     0        1     ]
          (%i10) mat_function(cos,t*b1)+%i*mat_function(sin,t*b1);
                        [                           2 ]
                        [                          t  ]
                        [ 1  0  %i t  %i t  %i t - -- ]
                        [                          2  ]
                        [                             ]
          (%o10)        [ 0  1   0    %i t    %i t    ]
                        [                             ]
                        [ 0  0   1     0      %i t    ]
                        [                             ]
                        [ 0  0   0     1        0     ]
                        [                             ]
                        [ 0  0   0     0        1     ]

     Exemplo 3:
          (%i11) a1:matrix([2,1,0,0,0,0],
                           [-1,4,0,0,0,0],
                           [-1,1,2,1,0,0],
                           [-1,1,-1,4,0,0],
                           [-1,1,-1,1,3,0],
                           [-1,1,-1,1,1,2])$

          (%i12) fpow(x):=block([k],declare(k,integer),x^k)$

          (%i13) mat_function(fpow,a1);
                          [  k      k - 1 ]         [      k - 1    ]
                          [ 3  - k 3      ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [  k      k - 1 ]
                          [  - k 3        ]         [ 3  + k 3      ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
          (%o13)  Col 1 = [               ] Col 2 = [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [  k      k - 1 ]         [      k - 1    ]
                   [ 3  - k 3      ]         [   k 3         ]
                   [               ]         [               ]
           Col 3 = [       k - 1   ] Col 4 = [  k      k - 1 ]
                   [  - k 3        ]         [ 3  + k 3      ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [    0    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
           Col 5 = [    0    ] Col 6 = [    ]
                   [         ]         [ 0  ]
                   [    k    ]         [    ]
                   [   3     ]         [ 0  ]
                   [         ]         [    ]
                   [  k    k ]         [  k ]
                   [ 3  - 2  ]         [ 2  ]

     Para usar essa função escreva primeiramente 'load("diag")'.


File: maxima.info,  Node: distrib,  Next: dynamics,  Prev: diag,  Up: Top

46 distrib
**********

* Menu:

* Introdução a distrib::
* Definições para distribuições contínuas::
* Definições para distribuições discretas::


File: maxima.info,  Node: Introdução a distrib,  Next: Definições para distribuições contínuas,  Prev: distrib,  Up: distrib

46.1 Introdução a distrib
=========================

Pacote 'distrib' contém um conjunto de funções para fazer cálculos
envolvendo probabilidades de modelos de uma única variável estatística e
de ambos os tipos discreta e contínua.

O que segue é um curto resumo de definiçoes básicas relacionadas à
teoria das probabilidades.

Seja f(x) a <função densidade de probabilidade> absoluta de uma variável
aleatória contínua X.  A <função distribuição de probabilidade> é
definida como
                            x
                           /
                           [
                    F(x) = I     f(u) du
                           ]
                           /
                            minf
que é igual à probabilidade <Pr(X <= x)>.

O valor <médio> é um parâmetro de localização e está definido como
                          inf
                         /
                         [
                E[X]  =  I   x f(x) dx
                         ]
                         /
                          minf

A <variância> é uma medida de variação,
                      inf
                     /
                     [                    2
              V[X] = I     f(x) (x - E[X])  dx
                     ]
                     /
                      minf
que é um número real positivo.  A raíz quadrada da variância é o <desvio
padrão>, D[X]=sqrt(V[X]), e esse <desvio padrão> é outra medida de
variação.

O <coeficiente de assimetria> é uma medida de não simetria,
                      inf
                     /
                 1   [                    3
       SK[X] = ----- I     f(x) (x - E[X])  dx
                   3 ]
               D[X]  /
                      minf

E o <coeficiente de curtose> mede o grau de achatamento de uma
distribuição,
                      inf
                     /
                 1   [                    4
       KU[X] = ----- I     f(x) (x - E[X])  dx - 3
                   4 ]
               D[X]  /
                      minf
Se X for gaussiana, KU[X]=0.  De facto, ambos assimetria e curtose são
parâmetros de ajuste usados para medir a não gaussianidade de uma
distribuição.

Se a variável aleatória X for discreta, a função densidade de
probabilidade, ou simplesmente <probabilidade>, f(x) toma valores
positivos dentro de certos conjuntos contáveis de números x_i, e zero em
caso contrário.  Nesse caso, a função distribuição de probabilidade é
                            ====
                            \
                     F(x) =  >    f(x )
                            /        i
                            ====
                           x <= x
                            i

A média, variância, desvio padrão, coeficiente de assimetria e
coeficiente de curtose tomam a forma
                            ====
                            \
                     E[X] =  >  x  f(x ) ,
                            /    i    i
                            ====
                             x
                              i

                     ====
                     \                     2
             V[X] =   >    f(x ) (x - E[X])  ,
                     /        i    i
                     ====
                      x
                       i

                    D[X] = sqrt(V[X]),

                          ====
                   1      \                     3
       SK[X] =  -------    >    f(x ) (x - E[X])
                D[X]^3    /        i    i
                          ====
                           x
                            i
and
                          ====
                   1      \                     4
       KU[X] =  -------    >    f(x ) (x - E[X])   - 3 ,
                D[X]^4    /        i    i
                          ====
                           x
                            i
respectively.

O Pacote 'distrib' inclui funções para simulação de variáveis
estatísticas pseudo-aleatórias.  Algumas dessas funções fazem uso de
variáveis opcionais que indicam o algoritmo a ser usado.  O método
inverso genérico (baseado no facto que se <u> for um número aleatório
uniforme no intervalo (0,1), então <F^(-1)(u)> é uma variável
estatística pseudo-aleatória com distribuição F) está implementada para
a maioria dos casos; isso é um método subóptimo em termos de
cronometragem, mas útil para fazer comparações com outros algoritmos.
Nesse exemplo, a 'perandom_formance' dos algoritmos 'ahrens_cheng' e
'inverse' em simular variáveis chi-quadradas (letra grega "chi") são
comparadas por meio de seus histogramas:

     (%i1) load(distrib)$
     (%i2) load(descriptive)$
     (%i3) showtime: true$
     Evaluation took 0.00 seconds (0.00 elapsed) using 32 bytes.
     (%i4) random_chi2_algorithm: 'ahrens_cheng$ histogram(random_chi2(10,500))$
     Evaluation took 0.00 seconds (0.00 elapsed) using 40 bytes.
     Evaluation took 0.69 seconds (0.71 elapsed) using 5.694 MB.
     (%i6) random_chi2_algorithm: 'inverse$ histogram(random_chi2(10,500))$
     Evaluation took 0.00 seconds (0.00 elapsed) using 32 bytes.
     Evaluation took 10.15 seconds (10.17 elapsed) using 322.098 MB.

Com o objectivo de fazer comparações visuais entre algoritmos para uma
variável estatística discreta, a função 'barsplot' do pacote
'descriptive' pode ser usada.

Note que algum trabalho resta para ser realizado, uma vez que essas
funções de simulação não foram ainda verificadas pelos mais
rigorosamente melhores dos testes de ajuste.

Por favor, consulte um manual introdutório sobre probabilidade e
estatística para maiores informações sobre todo esse material
matemático.

Existe uma convenção de nome no pacote 'distrib'.  Todo nome de função
tem duas partes, a primeira faz referência à função ou ao parâmetro que
queremos calcular,
     Funções:
        função densidade de probabilidade            (pdf_*)
        função distribuição de probabilidade       (cdf_*)
        Quartil                    (quantile_*)
        Média                        (mean_*)
        Variância                    (var_*)
        Desvio padrão          (std_*)
        Coeficiente de assimetria        (skewness_*)
        Coeficiente de curtose        (kurtosis_*)
        Variável estatística pseudo-aleatória              (random_*)

A segunda parte é uma referência explícita ao modelo probabilístico,
     Distribuíções contínuas:
        Normal              (*normal)
        Student             (*student_t)
        Chi^2               (*chi2)
        F                   (*f)
        Exponencial         (*exp)
        Lognormal           (*lognormal)
        Gama               (*gamma)
        Beta                (*beta)
        contínua uniforme  (*continuous_uniform)
        Logística            (*logistic)
        Pareto              (*pareto)
        Weibull             (*weibull)
        Rayleigh            (*rayleigh)
        Laplace             (*laplace)
        Cauchy              (*cauchy)
        Gumbel              (*gumbel)

     Distribuições discretas:
        Binomial             (*binomial)
        Poisson              (*poisson)
        Bernoulli            (*bernoulli)
        Geométrica            (*geometric)
        discreta uniforme     (*discrete_uniform)
        hipergeométrica       (*hypergeometric)
        Binomial Negativa    (*negative_binomial)

Por exemplo, 'pdf_student_t(x,n)' é a função densidade de probabilidade
da distribuição de Student com <n> graus de liberdade, 'std_pareto(a,b)'
é o desvio padrão da distribuição de Pareto com parâmetros <a> e <b> e
'kurtosis_poisson(m)' é o coeficiente de curtose da distribuição de
Poisson com média <m>.

Para poder usar o pacote 'distrib' precisa primeiro carregá-lo
escrevendo
     (%i1) load(distrib)$

Para comentários, melhorias ou sugestões, por favor contacte o autor em
<'mario AT edu DOT xunta DOT es'>.


File: maxima.info,  Node: Definições para distribuições contínuas,  Next: Definições para distribuições discretas,  Prev: Introdução a distrib,  Up: distrib

46.2 Definições para distribuições contínuas
============================================

 -- Função: pdf_normal (<x>,<m>,<s>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Normal(m,s), com s>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_normal (<x>,<m>,<s>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Normal(m,s), com s>0.  Essa função é
     definida em termos de funções de erro internas do Maxima, 'erf'.

          (%i1) load (distrib)$
          (%i2) assume(s>0)$ cdf_normal(x,m,s);
                                       x - m
                                 erf(---------)
                                     sqrt(2) s    1
          (%o3)                  -------------- + -
                                       2          2

     Veja também 'erf'.

 -- Função: quantile_normal (<q>,<m>,<s>)
     Retorna o <q>-quantil de uma variável aleatória Normal(m,s), com
     s>0; em outras palavras, isso é o inverso de 'cdf_normal'.  O
     argumento <q> deve ser um elemento de [0,1].  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_normal (<m>,<s>)
     Retorna a média de uma variável aleatória Normal(m,s), com s>0, a
     saber <m>.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: var_normal (<m>,<s>)
     Retorna a variância de uma variável aleatória Normal(m,s), com s>0,
     a saber <s^2>.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: std_normal (<m>,<s>)
     Retorna o desvio padrão de uma variável aleatória Normal(m,s), com
     s>0, a saber <s>.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: skewness_normal (<m>,<s>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Normal(m,s), com s>0, que é sempre igual a 0.  Para fazer uso dessa
     função,escreva primeiramente 'load(distrib)'.

 -- Função: kurtosis_normal (<m>,<s>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Normal(m,s), com s>0, que é sempre igual a 0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Variável de opção: random_normal_algorithm
     Valor por omissão: 'box_mueller'

     Esse é o algoritmo seleccionado para simular variáveis aleatórias
     normais.  O algoritmos implementados são 'box_mueller' e 'inverse':
        * 'box_mueller', Baseado no algoritmo descrito em Knuth, D.E.
          (1981) <Seminumerical Algorithms.  The Art of Computer
          Programming.> Addison-Wesley.

        * 'inverse', baseado no método inverso genérico.

     Veja também 'random_normal'.

 -- Função: random_normal (<m>,<s>)
 -- Função: random_normal (<m>,<s>,<n>)
     Retorna uma variável estatística pseudo-aleatória Normal(m,s), com
     s>0.  Chamando 'random_normal' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Existem dois algoritmos implementados para essa função, e o
     algoritmo a ser usado pode ser seleccionado fornecendo um certo
     valor para a variável global 'random_normal_algorithm', cujo valor
     padrão é 'box_mueller'.

     Veja também 'random_normal_algorithm'.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_student_t (<x>,<n>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória de Student t(n), com n>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_student_t (<x>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória de Student t(n), com n>0.  Essa função não
     tem uma forma definitiva e é calculada numericamente se a variável
     global 'numer' for igual a 'true', de outra froma 'cdf_student_t'
     retorna uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_student_t(1/2, 7/3);
                                               1  7
          (%o2)                  cdf_student_t(-, -)
                                               2  3
          (%i3) %,numer;
          (%o3)                   .6698450596140417

 -- Função: quantile_student_t (<q>,<n>)
     Retorna o <q>-quantil de uma variável aleatória de Student t(n),
     com n>0; em outras palavras, 'quantile_student_t' é o inverso de
     'cdf_student_t'.  O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_student_t (<n>)
     Retorna a média de uma variável aleatória de Student t(n), com n>0,
     que é sempre igual a 0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: var_student_t (<n>)
     Retorna a variância de uma variável aleatória de Student t(n), com
     n>2.

          (%i1) load (distrib)$
          (%i2) assume(n>2)$  var_student_t(n);
                                          n
          (%o3)                         -----
                                        n - 2

 -- Função: std_student_t (<n>)
     Retorna o desvio padrão de uma variável aleatória de Student t(n),
     com n>2.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_student_t (<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória de
     Student t(n), com n>3, que é sempre igual a 0.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: kurtosis_student_t (<n>)
     Retorna o coeficiente de curtose de uma variável aleatória de
     Student t(n), com n>4.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Variável de opção: random_student_t_algorithm
     Valor por omissão: 'ratio'

     Esse é o algoritmo seleccionado para simular variáveis estatísticas
     pseudo-aleatórias de Student.  Algorítmos implementados são
     'inverse' e 'ratio':
        * 'inverse', baseado no método inverso genérico.

        * 'ratio', baseado no facto que se <Z> for uma variável
          aleatória normal N(0,1) e S^2 for uma variável aleatória chi
          quadrada com <n> graus de liberdade, Chi^2(n), então
                                          Z
                                X = -------------
                                    /   2  \ 1/2
                                    |  S   |
                                    | ---  |
                                    \  n   /
          é uma variável aleatória de Student com <n> graus de
          liberdade, t(n).

     Veja também 'random_student_t'.

 -- Função: random_student_t (<n>)
 -- Função: random_student_t (<n>,<m>)
     Retorna uma variável estatística pseudo-aleatória de Student t(n),
     com n>0.  Chamando 'random_student_t' com um segundo argumento <m>,
     uma amostra aleatória de tamanho <m> será simulada.

     Existem dois algoritmos implementados para essa função, se pode
     seleccionar o algoritmo a ser usado fornecendo um certo valor à
     variável global 'random_student_t_algorithm', cujo valor padrão é
     'ratio'.

     Veja também 'random_student_t_algorithm'.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_chi2 (<x>,<n>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Chi-quadrada Chi^2(n), com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2),
     portanto quando Maxima não tiver informação para pegar o resultado,
     uma forma nomial baseada na função de densidade densidade de
     probabilidade da função gama é retornada.

          (%i1) load (distrib)$
          (%i2) pdf_chi2(x,n);
                                              n
          (%o2)                  pdf_gamma(x, -, 2)
                                              2
          (%i3) assume(x>0, n>0)$  pdf_chi2(x,n);
                                   n/2 - 1   - x/2
                                  x        %e
          (%o4)                   ----------------
                                    n/2       n
                                   2    gamma(-)
                                              2

 -- Função: cdf_chi2 (<x>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Chi-quadrada Chi^2(n), com n>0.

     Essa função não possui uma forma fechada e é calculada
     numericamante se a variável global 'numer' for igual a 'true', de
     outra forma essa função retorna uma expressão nominal baseada na
     distribuição gama, uma vez que a variável aleatória Chi^2(n) é
     equivalente a é equivalente a Gamma(n/2,2).

          (%i1) load (distrib)$
          (%i2) cdf_chi2(3,4);
          (%o2)                  cdf_gamma(3, 2, 2)
          (%i3) cdf_chi2(3,4),numer;
          (%o3)                   .4421745996289249

 -- Função: quantile_chi2 (<q>,<n>)
     Retorna o <q>-quantilede uma variável aleatória Chi-quadrada
     Chi^2(n), com n>0; em outras palavras, essa função é a inversa da
     função 'cdf_chi2'.  O argumento <q> deve ser um elemento de [0,1].

     This função não possui uma forma fechada e é calculada
     numericamante se a variável global 'numer' for igual a 'true', de
     outra forma essa função retorna uma expressão nominal baseada no
     quantil da função gama, uma vez que a variável aleatória Chi^2(n) é
     equivalente a Gamma(n/2,2).

          (%i1) load (distrib)$
          (%i2) quantile_chi2(0.99,9);
          (%o2)                   21.66599433346194
          (%i3) quantile_chi2(0.99,n);
                                                  n
          (%o3)              quantile_gamma(0.99, -, 2)
                                                  2

 -- Função: mean_chi2 (<n>)
     Retorna a média de uma variável aleatória Chi-quadrada Chi^2(n),
     com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na média da função gama é
     retornada.

          (%i1) load (distrib)$
          (%i2) mean_chi2(n);
                                             n
          (%o2)                   mean_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ mean_chi2(n);
          (%o4)                           n

 -- Função: var_chi2 (<n>)
     Retorna a variância de uma variável aleatória Chi-quadrada
     Chi^2(n), com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na variância da função gama é
     retornada.

          (%i1) load (distrib)$
          (%i2) var_chi2(n);
                                             n
          (%o2)                    var_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ var_chi2(n);
          (%o4)                          2 n

 -- Função: std_chi2 (<n>)
     Retorna o desvio padrão de uma variável aleatória Chi-quadrada
     Chi^2(n), com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no desvio padrão da função
     gama é retornada.

          (%i1) load (distrib)$
          (%i2) std_chi2(n);
                                             n
          (%o2)                    std_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ std_chi2(n);
          (%o4)                    sqrt(2) sqrt(n)

 -- Função: skewness_chi2 (<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Chi-quadrada Chi^2(n), com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de assimetria
     da função gama é retornada.

          (%i1) load (distrib)$
          (%i2) skewness_chi2(n);
                                               n
          (%o2)                 skewness_gamma(-, 2)
                                               2
          (%i3) assume(n>0)$ skewness_chi2(n);
                                      2 sqrt(2)
          (%o4)                       ---------
                                       sqrt(n)

 -- Função: kurtosis_chi2 (<n>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Chi-quadrada Chi^2(n), com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de curtose da
     função gama é retornada.

          (%i1) load (distrib)$
          (%i2) kurtosis_chi2(n);
                                               n
          (%o2)                 kurtosis_gamma(-, 2)
                                               2
          (%i3) assume(n>0)$ kurtosis_chi2(n);
                                         12
          (%o4)                          --
                                         n

 -- Variável de opção: random_chi2_algorithm
     Valor por omissão: 'ahrens_cheng'

     Esse é o algoritmo seleccionado para simular variáveis estatística
     pseudo-aleatórias Chi-quadradas.  Os algoritmos implementados são
     'ahrens_cheng' e 'inverse':

        * 'ahrens_cheng', baseado na simulação aleatória de variáveis
          gama.  Veja 'random_gamma_algorithm' para mais detalhes.

        * 'inverse', baseado no método inverso genérico.

     Veja também 'random_chi2'.

 -- Função: random_chi2 (<n>)
 -- Função: random_chi2 (<n>,<m>)
     Retorna uma variável estatística pseudo-aleatória Chi-square
     Chi^2(n), com n>0.  Chamando 'random_chi2' com um segundo argumento
     <m>, uma amostra aleatória de tamanho <m> será simulada.

     Existem dois algoritmos implementados para essa função, se pode
     seleccionar o algoritmo a ser usado fornecendo um certo valor à
     variável global 'random_chi2_algorithm', cujo valor padrão é
     'ahrens_cheng'.

     Veja também 'random_chi2_algorithm'.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: pdf_f (<x>,<m>,<n>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória F, F(m,n), com m,n>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_f (<x>,<m>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória F, F(m,n), com m,n>0.  Essa função não
     possui uma forma definitiva e é calculada numericamente se a
     variável global 'numer' for igual a 'true', de outra forma retorna
     uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_f(2,3,9/4);
                                               9
          (%o2)                    cdf_f(2, 3, -)
                                               4
          (%i3) %,numer;
          (%o3)                   0.66756728179008

 -- Função: quantile_f (<q>,<m>,<n>)
     Retorna o <q>-quantil de uma variável aleatória F, F(m,n), com
     m,n>0; em outras palavras, essa função é o inverso de 'cdf_f'.  O
     argumento <q> deve ser um elemento de [0,1].

     Essa função não possui uma forma fechada e é calculada
     numericamante se a variável global 'numer' for igual a 'true', de
     outra forma essa função retorna uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) quantile_f(2/5,sqrt(3),5);
                                         2
          (%o2)               quantile_f(-, sqrt(3), 5)
                                         5
          (%i3) %,numer;
          (%o3)                   0.518947838573693

 -- Função: mean_f (<m>,<n>)
     Retorna a média de uma variável aleatória F, F(m,n), com m>0, n>2.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: var_f (<m>,<n>)
     Retorna a variância de uma variável aleatória F, F(m,n), com m>0,
     n>4.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: std_f (<m>,<n>)
     Retorna o desvio padrão de uma variável aleatória F, F(m,n), com
     m>0, n>4.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_f (<m>,<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória F,
     F(m,n), com m>0, n>6.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: kurtosis_f (<m>,<n>)
     Retorna o coeficiente de curtose de uma variável aleatória F,
     F(m,n), com m>0, n>8.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Variável de opção: random_f_algorithm
     Valor por omissão: 'inverse'

     Esse é o algoritmo seleccionado para simular variáveis estatísticas
     pseudo-aleatórias F. Os algoritmos implementados são 'ratio' e
     'inverse':

        * 'ratio', baseado no facto de que se <X> for uma variável
          aleatória Chi^2(m) e Y for uma variável aleatória Chi^2(n),
          então
                                       n X
                                   F = ---
                                       m Y
          é uma variável aleatória F com <m> e <n> graus de liberdade,
          F(m,n).

        * 'inverse', baseado no método inverso genérico.

     Veja também 'random_f'.

 -- Função: random_f (<m>,<n>)
 -- Função: random_f (<m>,<n>,<k>)
     Retorna uma variável estatística pseudo-aleatória F, F(m,n), com
     m,n>0.  Chamando 'random_f' com um terceiro argumento <k>, uma
     amostra aleatória de tamanho <k> será simulada.

     Existem dois algoritmos implementados para essa função, se pode
     seleccionar o algoritmo a ser usado fornecendo um certo valor à
     variável global 'random_f_algorithm', cujo valor padrão é
     'inverse'.

     Veja também 'random_f_algorithm'.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: pdf_exp (<x>,<m>)
     Retorna o valor em <x> da função densidade de probabilidade
     variável aleatória Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na função de densidade de
     probabilidade de Weibull éretornada.

          (%i1) load (distrib)$
          (%i2) pdf_exp(x,m);
                                                  1
          (%o2)                 pdf_weibull(x, 1, -)
                                                  m
          (%i3) assume(x>0,m>0)$  pdf_exp(x,m);
                                          - m x
          (%o4)                       m %e

 -- Função: cdf_exp (<x>,<m>)
     Retorna o valor em <x> da função distribuição de probabilidade
     variável aleatória Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na distribuição de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) cdf_exp(x,m);
                                                  1
          (%o2)                 cdf_weibull(x, 1, -)
                                                  m
          (%i3) assume(x>0,m>0)$  cdf_exp(x,m);
                                           - m x
          (%o4)                      1 - %e

 -- Função: quantile_exp (<q>,<m>)
     Retorna o <q>-quantil variável aleatória Exponential(m), com m>0;
     em outras palavras, essa função é inversa da função 'cdf_exp'.  O
     argumento <q> deve ser um elemento de [0,1].

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no qualtil de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) quantile_exp(0.56,5);
          (%o2)                   .1641961104139661
          (%i3) quantile_exp(0.56,m);
                                                      1
          (%o3)             quantile_weibull(0.56, 1, -)
                                                      m

 -- Função: mean_exp (<m>)
     Retorna a média de uma variável aleatória Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na média de Weibull é
     reornada.

          (%i1) load (distrib)$
          (%i2) mean_exp(m);
                                                 1
          (%o2)                  mean_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  mean_exp(m);
                                          1
          (%o4)                           -
                                          m

 -- Função: var_exp (<m>)
     Retorna a variância de uma variável aleatória Exponential(m), com
     m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na variância de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) var_exp(m);
                                                 1
          (%o2)                   var_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  var_exp(m);
                                         1
          (%o4)                          --
                                          2
                                         m

 -- Função: std_exp (<m>)
     Retorna o desvio padrão de uma variável aleatória Exponential(m),
     com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no desvio padrão de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) std_exp(m);
                                                 1
          (%o2)                   std_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  std_exp(m);
                                          1
          (%o4)                           -
                                          m

 -- Função: skewness_exp (<m>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de assimetria
     de Weibull é retornada.

          (%i1) load (distrib)$
          (%i2) skewness_exp(m);
                                                   1
          (%o2)                skewness_weibull(1, -)
                                                   m
          (%i3) assume(m>0)$  skewness_exp(m);
          (%o4)                           2

 -- Função: kurtosis_exp (<m>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de curtose de
     Weibull é retornada.

          (%i1) load (distrib)$
          (%i2) kurtosis_exp(m);
                                                   1
          (%o2)                kurtosis_weibull(1, -)
                                                   m
          (%i3) assume(m>0)$  kurtosis_exp(m);
          (%o4)                           6

 -- Variável de opção: random_exp_algorithm
     Valor por omissão: 'inverse'

     Esse é o algoritmo seleccionado para simular variáveis exponenciais
     estatística pseudo-aleatórias.  Os algoritmos implementados são
     'inverse', 'ahrens_cheng' e 'ahrens_dieter'

        * 'inverse', baseado no método inverso genérico.

        * 'ahrens_cheng', baseado no facto de que a variável aleatória
          Exp(m) é equivalente a Gamma(1,1/m).  Veja
          'random_gamma_algorithm' para maiores detalhes.

        * 'ahrens_dieter', baseado no algoritmo descrito em Ahrens, J.H.
          e Dieter, U. (1972) <Computer methods for sampling from the
          exponential and normal distributions.> Comm, ACM, 15, Oct.,
          873-882.

     Veja também 'random_exp'.

 -- Função: random_exp (<m>)
 -- Função: random_exp (<m>,<k>)
     Retorna uma variável estatística pseudo-aleatória Exponential(m),
     com m>0.  Chamando 'random_exp' com um segundo argumento <k>, uma
     amostra aleatória de tamanho <k> será simulada.

     Existem três algoritmos implementados para essa função, se pode
     seleccionar o algoritmo a ser usado fornecendo um certo valor à
     variável global 'random_exp_algorithm', cujo valor padrão é
     'inverse'.

     Veja também 'random_exp_algorithm'.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: pdf_lognormal (<x>,<m>,<s>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Lognormal(m,s), com s>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_lognormal (<x>,<m>,<s>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Lognormal(m,s), com s>0.  Essa função é
     definida em termos de funções 'erf'de erro internas do Maxima.

          (%i1) load (distrib)$
          (%i2) assume(x>0, s>0)$  cdf_lognormal(x,m,s);
                                     log(x) - m
                                 erf(----------)
                                     sqrt(2) s     1
          (%o3)                  --------------- + -
                                        2          2

     Veja também 'erf'.

 -- Função: quantile_lognormal (<q>,<m>,<s>)
     Retorna o <q>-quantil de uma variável aleatória Lognormal(m,s), com
     s>0; em outras palavras, essa função é a inversa da função
     'cdf_lognormal'.  O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_lognormal (<m>,<s>)
     Retorna a média de uma variável aleatória Lognormal(m,s), com s>0.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: var_lognormal (<m>,<s>)
     Retorna a variância de uma variável aleatória Lognormal(m,s), com
     s>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: std_lognormal (<m>,<s>)
     Retorna o desvio padrão de uma variável aleatória Lognormal(m,s),
     com s>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_lognormal (<m>,<s>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Lognormal(m,s), com s>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: kurtosis_lognormal (<m>,<s>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Lognormal(m,s), com s>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: random_lognormal (<m>,<s>)
 -- Função: random_lognormal (<m>,<s>,<n>)
     Retorna uma variável estatística pseudo-aleatória Lognormal(m,s),
     com s>0.  Chamando 'random_lognormal' com um terceiro argumento
     <n>, uma amostra aleatória de tamanho <n> será simulada.

     Variáveis Log-normal são simuladas por meio de variáveis
     estatísticas normais pseudo-aleatórias.  Existem dois algoritmos
     implementados para essa função, se pode seleccionar o algoritmo a
     ser usado fornecendo um certo valor à variável global
     'random_normal_algorithm', cujo valor padrão é 'box_mueller'.

     Veja também 'random_normal_algorithm'.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_gamma (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Gamma(a,b), com a,b>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_gamma (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Gamma(a,b), com a,b>0.

     Essa função não possui uma forma fechada e é calculada
     numericamante se a variável global 'numer' for igual a 'true', de
     outra forma essa função retorna uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_gamma(3,5,21);
          (%o2)                  cdf_gamma(3, 5, 21)
          (%i3) %,numer;
          (%o3)                 4.402663157135039E-7

 -- Função: quantile_gamma (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Gamma(a,b), com
     a,b>0; em outras palavras, essa função é a inversa da função
     'cdf_gamma'.  O argumento <q> deve ser um elemento de [0,1].  Para
     fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_gamma (<a>,<b>)
     Retorna a média de uma variável aleatória Gamma(a,b), com a,b>0.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: var_gamma (<a>,<b>)
     Retorna a variância de uma variável aleatória Gamma(a,b), com
     a,b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: std_gamma (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Gamma(a,b), com
     a,b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_gamma (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Gamma(a,b), com a,b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: kurtosis_gamma (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Gamma(a,b), com a,b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Variável de opção: random_gamma_algorithm
     Valor por omissão: 'ahrens_cheng'

     Esse é o algoritmo seleccionado para simular variáveis estatística
     gama pseudo-aleatórias.  Os algoritmos implementados são
     'ahrens_cheng' e 'inverse'

        * 'ahrens_cheng', essa é uma combinação de dois processos,
          dependendo do valor do parâmetro <a>:

          For a>=1, Cheng, R.C.H. e Feast, G.M. (1979).  <Some simple
          gamma variate generators>.  Appl.  Stat., 28, 3, 290-295.

          For 0<a<1, Ahrens, J.H. e Dieter, U. (1974).  <Computer
          methods for sampling from gamma, beta, poisson and binomial
          cdf_tributions>.  Computing, 12, 223-246.

        * 'inverse', baseado no método inverso genérico.

     Veja também 'random_gamma'.

 -- Função: random_gamma (<a>,<b>)
 -- Função: random_gamma (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Gamma(a,b), com
     a,b>0.  Chamando 'random_gamma' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Existem dois algoritmos implementados para essa função, se pode
     seleccionar o algoritmo a ser usado fornecendo um certo valor à
     variável global 'random_gamma_algorithm', cujo valor padrão é
     'ahrens_cheng'.

     Veja também 'random_gamma_algorithm'.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: pdf_beta (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Beta(a,b), com a,b>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_beta (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Beta(a,b), com a,b>0.

     Essa função não possui uma forma fechada e é calculada
     numericamante se a variável global 'numer' for igual a 'true', de
     outra forma essa função retorna uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_beta(1/3,15,2);
                                           1
          (%o2)                   cdf_beta(-, 15, 2)
                                           3
          (%i3) %,numer;
          (%o3)                 7.666089131388224E-7

 -- Função: quantile_beta (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Beta(a,b), com
     a,b>0; em outras palavras, essa função é a inversa da função
     'cdf_beta'.  O argumento <q> deve ser um elemento de [0,1].  Para
     fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_beta (<a>,<b>)
     Retorna a média de uma variável aleatória Beta(a,b), com a,b>0.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: var_beta (<a>,<b>)
     Retorna a variância de uma variável aleatória Beta(a,b), com a,b>0.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: std_beta (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Beta(a,b), com
     a,b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_beta (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Beta(a,b), com a,b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: kurtosis_beta (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Beta(a,b), com a,b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Variável de opção: random_beta_algorithm
     Valor por omissão: 'cheng'

     Esse é o algoritmo seleccionado para simular variáveis estatísticas
     beta pseudo-aleatórias.  Os algoritmos implementados são 'cheng',
     'inverse' e 'ratio'

        * 'cheng', esse é o algoritmo definido em Cheng, R.C.H. (1978).
          <Generating Beta Variates with Nonintegral Shape Parameters>.
          Communications of the ACM, 21:317-322

        * 'inverse', baseado no método inverso genérico.

        * 'ratio', baseado no facto de que se <X> for uma variável
          aleatória Gamma(a,1) e <Y> for Gamma(b,1), então a razão
          X/(X+Y) está distribuída como Beta(a,b).

     Veja também 'random_beta'.

 -- Função: random_beta (<a>,<b>)
 -- Função: random_beta (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Beta(a,b), com
     a,b>0.  Chamando 'random_beta' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Existem três algoritmos implementados para essa função, se pode
     seleccionar o algoritmo a ser usado fornecendo um certo valor à
     variável global 'random_beta_algorithm', cujo valor padrão é
     'cheng'.

     Veja também 'random_beta_algorithm'.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: pdf_continuous_uniform (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Continuous Uniform(a,b), com a<b.  Para fazer
     uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_continuous_uniform (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Continuous Uniform(a,b), com a<b.  Para
     fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: quantile_continuous_uniform (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Continuous
     Uniform(a,b), com a<b; em outras palavras, essa função é a inversa
     da função 'cdf_continuous_uniform'.  O argumento <q> deve ser um
     elemento de [0,1].  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: mean_continuous_uniform (<a>,<b>)
     Retorna a média de uma variável aleatória Continuous Uniform(a,b),
     com a<b.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: var_continuous_uniform (<a>,<b>)
     Retorna a variância de uma variável aleatória Continuous
     Uniform(a,b), com a<b.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: std_continuous_uniform (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Continuous
     Uniform(a,b), com a<b.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: skewness_continuous_uniform (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Continuous Uniform(a,b), com a<b.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: kurtosis_continuous_uniform (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Continuous Uniform(a,b), com a<b.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: random_continuous_uniform (<a>,<b>)
 -- Função: random_continuous_uniform (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Continuous
     Uniform(a,b), com a<b.  Chamando 'random_continuous_uniform' com um
     terceiro argumento <n>, uma amostra aleatória de tamanho <n> será
     simulada.

     Essa é uma aplicação directa da função 'random' interna do Maxima.

     Veja também 'random'.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: pdf_logistic (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Logistic(a,b) , com b>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_logistic (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Logistic(a,b), com b>0.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: quantile_logistic (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Logistic(a,b) , com
     b>0; em outras palavras, essa função é a inversa da função
     'cdf_logistic'.  O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: meanlog (<a>,<b>)
     Retorna a média de uma Logistic(a,b) variável aleatória , com b>0.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: var_logistic (<a>,<b>)
     Retorna a variância de uma variável aleatória Logistic(a,b) , com
     b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: std_logistic (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Logistic(a,b) ,
     com b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_logistic (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Logistic(a,b) , com b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: kurtosis_logistic (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Logistic(a,b) , com b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: random_logistic (<a>,<b>)
 -- Função: random_logistic (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Logistic(a,b),
     com b>0.  Chamando 'random_logistic' com um terceiro argumento <n>,
     uma amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado.  Para fazer
     uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_pareto (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Pareto(a,b), com a,b>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_pareto (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Pareto(a,b), com a,b>0.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: quantile_pareto (<q>,<a>,<b>)
     Retorna o <q>-quantile de uma variável aleatória Pareto(a,b), com
     a,b>0; em outras palavras, essa função é a inversa da função
     'cdf_pareto'.  O argumento <q> deve ser um elemento de [0,1].  Para
     fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_pareto (<a>,<b>)
     Retorna a média de uma variável aleatória Pareto(a,b), com a>1,b>0.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: var_pareto (<a>,<b>)
     Retorna a variância de uma variável aleatória Pareto(a,b), com
     a>2,b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: std_pareto (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Pareto(a,b), com
     a>2,b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_pareto (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Pareto(a,b), com a>3,b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: kurtosis_pareto (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Pareto(a,b), com a>4,b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: random_pareto (<a>,<b>)
 -- Função: random_pareto (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Pareto(a,b), com
     a>0,b>0.  Chamando 'random_pareto' com um terceiro argumento <n>,
     uma amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado.  Para fazer
     uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_weibull (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Weibull(a,b), com a,b>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_weibull (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Weibull(a,b), com a,b>0.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: quantile_weibull (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Weibull(a,b), com
     a,b>0; em outras palavras, essa função é a inversa da função
     'cdf_weibull'.  O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_weibull (<a>,<b>)
     Retorna a média de uma variável aleatória Weibull(a,b), com a,b>0.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: var_weibull (<a>,<b>)
     Retorna a variância de uma variável aleatória Weibull(a,b), com
     a,b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: std_weibull (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Weibull(a,b), com
     a,b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_weibull (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Weibull(a,b), com a,b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: kurtosis_weibull (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Weibull(a,b), com a,b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: random_weibull (<a>,<b>)
 -- Função: random_weibull (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Weibull(a,b), com
     a,b>0.  Chamando 'random_weibull' com um terceiro argumento <n>,
     uma amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado.  Para fazer
     uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_rayleigh (<x>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na função densidade de
     probabilidade de Weibull é retornada.

          (%i1) load (distrib)$
          (%i2) pdf_rayleigh(x,b);
                                                  1
          (%o2)                 pdf_weibull(x, 2, -)
                                                  b
          (%i3) assume(x>0,b>0)$ pdf_rayleigh(x,b);
                                              2  2
                                     2     - b  x
          (%o4)                   2 b  x %e

 -- Função: cdf_rayleigh (<x>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na distribuição de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) cdf_rayleigh(x,b);
                                                  1
          (%o2)                 cdf_weibull(x, 2, -)
                                                  b
          (%i3) assume(x>0,b>0)$ cdf_rayleigh(x,b);
                                             2  2
                                          - b  x
          (%o4)                     1 - %e

 -- Função: quantile_rayleigh (<q>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Rayleigh(b), com
     b>0; em outras palavras, essa função é a inversa da função
     'cdf_rayleigh'.  O argumento <q> deve ser um elemento de [0,1].

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no quantil de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) quantile_rayleigh(0.99,b);
                                                      1
          (%o2)             quantile_weibull(0.99, 2, -)
                                                      b
          (%i3) assume(x>0,b>0)$ quantile_rayleigh(0.99,b);
                                  2.145966026289347
          (%o4)                   -----------------
                                          b

 -- Função: mean_rayleigh (<b>)
     Retorna a média de uma variável aleatória Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na meia de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) mean_rayleigh(b);
                                                 1
          (%o2)                  mean_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ mean_rayleigh(b);
                                      sqrt(%pi)
          (%o4)                       ---------
                                         2 b

 -- Função: var_rayleigh (<b>)
     Retorna a variância de uma variável aleatória Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na variância de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) var_rayleigh(b);
                                                 1
          (%o2)                   var_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ var_rayleigh(b);
                                           %pi
                                       1 - ---
                                            4
          (%o4)                        -------
                                          2
                                         b

 -- Função: std_rayleigh (<b>)
     Retorna o desvio padrão de uma variável aleatória Rayleigh(b), com
     b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na Weibull desvio padrão é
     retornada.

          (%i1) load (distrib)$
          (%i2) std_rayleigh(b);
                                                 1
          (%o2)                   std_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ std_rayleigh(b);
                                             %pi
                                    sqrt(1 - ---)
                                              4
          (%o4)                     -------------
                                          b

 -- Função: skewness_rayleigh (<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de assimetria
     de Weibull é retornada.

          (%i1) load (distrib)$
          (%i2) skewness_rayleigh(b);
                                                   1
          (%o2)                skewness_weibull(2, -)
                                                   b
          (%i3) assume(b>0)$ skewness_rayleigh(b);
                                   3/2
                                %pi      3 sqrt(%pi)
                                ------ - -----------
                                  4           4
          (%o4)                 --------------------
                                         %pi 3/2
                                    (1 - ---)
                                          4

 -- Função: kurtosis_rayleigh (<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de curtose de
     Weibull é retornada.

          (%i1) load (distrib)$
          (%i2) kurtosis_rayleigh(b);
                                                   1
          (%o2)                kurtosis_weibull(2, -)
                                                   b
          (%i3) assume(b>0)$ kurtosis_rayleigh(b);
                                            2
                                       3 %pi
                                   2 - ------
                                         16
          (%o4)                    ---------- - 3
                                        %pi 2
                                   (1 - ---)
                                         4

 -- Função: random_rayleigh (<b>)
 -- Função: random_rayleigh (<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Rayleigh(b), com
     b>0.  Chamando 'random_rayleigh' com um segundo argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado.  Para fazer
     uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_laplace (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Laplace(a,b), com b>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_laplace (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Laplace(a,b), com b>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: quantile_laplace (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Laplace(a,b), com
     b>0; em outras palavras, essa função é a inversa da função
     'cdf_laplace'.  O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_laplace (<a>,<b>)
     Retorna a média de uma variável aleatória Laplace(a,b), com b>0.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: var_laplace (<a>,<b>)
     Retorna a variância de uma variável aleatória Laplace(a,b), com
     b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: std_laplace (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Laplace(a,b), com
     b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_laplace (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Laplace(a,b), com b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: kurtosis_laplace (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Laplace(a,b), com b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: random_laplace (<a>,<b>)
 -- Função: random_laplace (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Laplace(a,b), com
     b>0.  Chamando 'random_laplace' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado.  Para fazer
     uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_cauchy (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Cauchy(a,b), com b>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_cauchy (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Cauchy(a,b), com b>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: quantile_cauchy (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Cauchy(a,b), com
     b>0; em outras palavras, essa função é a inversa da função
     'cdf_cauchy'.  O argumento <q> deve ser um elemento de [0,1].  Para
     fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: random_cauchy (<a>,<b>)
 -- Função: random_cauchy (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo aleatória Cauchy(a,b), com
     b>0.  Chamando 'random_cauchy' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado.  Para fazer
     uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_gumbel (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Gumbel(a,b), com b>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_gumbel (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Gumbel(a,b), com b>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: quantile_gumbel (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Gumbel(a,b), com
     b>0; em outras palavras, essa função é a inversa da função
     'cdf_gumbel'.  O argumento <q> deve ser um elemento de [0,1].  Para
     fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_gumbel (<a>,<b>)
     Retorna a média de uma variável aleatória Gumbel(a,b), com b>0.

          (%i1) load (distrib)$
          (%i2) assume(b>0)$  mean_gumbel(a,b);
          (%o3)                     %gamma b + a
     onde o símbolol '%gamma' representa a constante de
     Euler-Mascheroni.  Veja também '%gamma'.

 -- Função: var_gumbel (<a>,<b>)
     Retorna a variância de uma variável aleatória Gumbel(a,b), com b>0.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: std_gumbel (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Gumbel(a,b), com
     b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_gumbel (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Gumbel(a,b), com b>0.

          (%i1) load (distrib)$
          (%i2) assume(b>0)$ skewness_gumbel(a,b);
                                 12 sqrt(6) zeta(3)
          (%o3)                  ------------------
                                           3
                                        %pi
          (%i4) numer:true$ skewness_gumbel(a,b);
          (%o5)                   1.139547099404649
     onde 'zeta' representa a função zeta de Riemann.

 -- Função: kurtosis_gumbel (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Gumbel(a,b), com b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: random_gumbel (<a>,<b>)
 -- Função: random_gumbel (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Gumbel(a,b), com
     b>0.  Chamando 'random_gumbel' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado.  Para fazer
     uso dessa função, escreva primeiramente 'load(distrib)'.


File: maxima.info,  Node: Definições para distribuições discretas,  Prev: Definições para distribuições contínuas,  Up: distrib

46.3 Definições para distribuições discretas
============================================

 -- Função: pdf_binomial (<x>,<n>,<p>)
     Retorna o valor em <x> da função de probabilidade de uma
     Binomial(n,p) variável aleatória, com 0<p<1 e n um inteiro
     positivo.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: cdf_binomial (<x>,<n>,<p>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma Binomial(n,p) variável aleatória, com 0<p<1 e n um inteiro
     positivo.

     'cdf_binomial' é calculada numéricamente se a variável global
     'numer' for igual a 'true', de outra forma 'cdf_binomial' retorna
     uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_binomial(5,7,1/6);
                                                   1
          (%o2)                 cdf_binomial(5, 7, -)
                                                   6
          (%i3) cdf_binomial(5,7,1/6), numer;
          (%o3)                   .9998713991769548

 -- Função: quantile_binomial (<q>,<n>,<p>)
     Retorna o <q>-quantil de uma variável aleatória Binomial(n,p), com
     0<p<1 e n um inteiro positivo; em outras palavras, essa função é a
     inversa da função 'cdf_binomial'.  O argumento <q> deve ser um
     elemento de [0,1].  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: mean_binomial (<n>,<p>)
     Retorna a média de uma variável aleatória Binomial(n,p), com 0<p<1
     e n um inteiro positivo.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: var_binomial (<n>,<p>)
     Retorna a variância de uma variável aleatória Binomial(n,p), com
     0<p<1 e n um inteiro positivo.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: std_binomial (<n>,<p>)
     Retorna o desvio padrão de uma variável aleatória Binomial(n,p),
     com 0<p<1 e n um inteiro positivo.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: skewness_binomial (<n>,<p>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Binomial(n,p), com 0<p<1 e n um inteiro positivo.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: kurtosis_binomial (<n>,<p>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Binomial(n,p), com 0<p<1 e n um inteiro positivo.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Variável de opção: random_binomial_algorithm
     Valor por omissão: 'kachit'

     Esse é o algoritmo seleccionado para simular rvariáveis
     estatísticas pseudo-aleatórias binomiais.  Os algoritmos
     implementados são 'kachit', 'bernoulli' e 'inverse':

        * 'kachit', baseado no algoritmo descrito em Kachitvichyanukul,
          V. and Schmeiser, B.W. (1988) <Binomial Random Variate
          Generation>.  Communications of the ACM, 31, Feb., 216.

        * 'bernoulli', baseado na simulação testes de Bernoulli.

        * 'inverse', baseado no método inverso genérico.

     Veja também 'random_binomial'.

 -- Função: random_binomial (<n>,<p>)
 -- Função: random_binomial (<n>,<p>,<m>)
     Retorna uma variável estatística pseudo-aleatória Binomial(n,p),
     com 0<p<1 e n um inteiro positivo.  Chamando 'random_binomial' com
     um terceiro argumento <m>, uma amostra aleatória de tamanho <m>
     será simulada.

     Existem três algoritmos implementado para essa função, se pode
     seleccionar o algoritmo a ser usado fornecendo um certo valor à
     variável global 'random_binomial_algorithm', cujo valor padrão é
     'kachit'.

     Veja também 'random_binomial_algorithm'.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_poisson (<x>,<m>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Poisson(m), com m>0.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: cdf_poisson (<x>,<m>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Poisson(m), com m>0.

     Essa função é calculada numéricamente se a variável global 'numer'
     for igual a 'true', de outra forma essa função retorna uma
     expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_poisson(3,5);
          (%o2)                   cdf_poisson(3, 5)
          (%i3) cdf_poisson(3,5), numer;
          (%o3)                   .2650259152973617

 -- Função: quantile_poisson (<q>,<m>)
     Retorna o <q>-quantil de uma variável aleatória Poisson(m), com
     m>0; em outras palavras, essa função é a inversa da função
     'cdf_poisson'.  O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_poisson (<m>)
     Retorna a média de uma variável aleatória Poisson(m), com m>0.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: var_poisson (<m>)
     Retorna a variância de uma variável aleatória Poisson(m), com m>0.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: std_poisson (<m>)
     Retorna o desvio padrão de uma variável aleatória Poisson(m), com
     m>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_poisson (<m>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Poisson(m), com m>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: kurtosis_poisson (<m>)
     Retorna o coeficiente de curtose de uma Poisson variável aleatória
     Poi(m), com m>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Variável de opção: random_poisson_algorithm
     Valor por omissão: 'ahrens_dieter'

     Esse é o algoritmo seleccionado para simular variáveis estatísticas
     pseudo-aleatórias de Poisson.Os algoritmos implementados são
     'ahrens_dieter' e 'inverse':

        * 'ahrens_dieter', baseado no algoritmo descrito em Ahrens, J.H.
          and Dieter, U. (1982) <Computer Generation of Poisson Deviates
          From Modified Normal Distributions>.  ACM Trans.  Math.
          Software, 8, 2, June,163-179.

        * 'inverse', baseado no método inverso genérico.

     Veja também 'random_poisson'.

 -- Função: random_poisson (<m>)
 -- Função: random_poisson (<m>,<n>)
     Retorna uma variável estatística pseudo-aleatória Poisson(m), com
     m>0.  Chamando 'random_poisson' com um segundo argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Existem dois algoritmos implementado para essa função, se pode
     seleccionar o algoritmo a ser usado fornecendo um certo valor à
     variável global 'random_poisson_algorithm', cujo valor padrão é
     'ahrens_dieter'.

     Veja também 'random_poisson_algorithm'.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_bernoulli (<x>,<p>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Bernoulli(p), com 0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na função binomial de
     probabilidade é retornada.

          (%i1) load (distrib)$
          (%i2) pdf_bernoulli(1,p);
          (%o2)                 pdf_binomial(1, 1, p)
          (%i3) assume(0<p,p<1)$ pdf_bernoulli(1,p);
          (%o4)                           p

 -- Função: cdf_bernoulli (<x>,<p>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Bernoulli(p), com 0<p<1.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: quantile_bernoulli (<q>,<p>)
     Retorna o <q>-quantil de uma variável aleatória Bernoulli(p), com
     0<p<1; em outras palavras, essa função é a inversa da função
     'cdf_bernoulli'.  O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_bernoulli (<p>)
     Retorna a média de uma variável aleatória Bernoulli(p), com 0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na média binomial é retornada.

          (%i1) load (distrib)$
          (%i2) mean_bernoulli(p);
          (%o2)                  mean_binomial(1, p)
          (%i3) assume(0<p,p<1)$ mean_bernoulli(p);
          (%o4)                           p

 -- Função: var_bernoulli (<p>)
     Retorna a variância de uma variável aleatória Bernoulli(p), com
     0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na variância binomial é
     retornada.

          (%i1) load (distrib)$
          (%i2) var_bernoulli(p);
          (%o2)                  var_binomial(1, p)
          (%i3) assume(0<p,p<1)$ var_bernoulli(p);
          (%o4)                       (1 - p) p

 -- Função: std_bernoulli (<p>)
     Retorna o desvio padrão de uma variável aleatória Bernoulli(p), com
     0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no desvio padrão binomial é
     retornada.

          (%i1) load (distrib)$
          (%i2) std_bernoulli(p);
          (%o2)                  std_binomial(1, p)
          (%i3) assume(0<p,p<1)$ std_bernoulli(p);
          (%o4)                  sqrt(1 - p) sqrt(p)

 -- Função: skewness_bernoulli (<p>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Bernoulli(p), com 0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de assimetria
     binomial é retornada.

          (%i1) load (distrib)$
          (%i2) skewness_bernoulli(p);
          (%o2)                skewness_binomial(1, p)
          (%i3) assume(0<p,p<1)$ skewness_bernoulli(p);
                                       1 - 2 p
          (%o4)                  -------------------
                                 sqrt(1 - p) sqrt(p)

 -- Função: kurtosis_bernoulli (<p>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Bernoulli(p), com 0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de curtose
     binomial é retornada.

          (%i1) load (distrib)$
          (%i2) kurtosis_bernoulli(p);
          (%o2)                kurtosis_binomial(1, p)
          (%i3) assume(0<p,p<1)$ kurtosis_bernoulli(p);
                                   1 - 6 (1 - p) p
          (%o4)                    ---------------
                                      (1 - p) p

 -- Função: random_bernoulli (<p>)
 -- Função: random_bernoulli (<p>,<n>)
     Retorna uma variável estatística pseudo-aleatória Bernoulli(p), com
     0<p<1.  Chamando 'random_bernoulli' com um segundo argumento <n>,
     uma amostra aleatória de tamanho <n> será simulada.

     Essa é uma aplicação directa da função 'random' built-in função do
     Maxima.

     Veja também 'random'.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: pdf_geometric (<x>,<p>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Geometric(p), com 0<p<1.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: cdf_geometric (<x>,<p>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Geometric(p), com 0<p<1.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: quantile_geometric (<q>,<p>)
     Retorna o <q>-quantil de uma variável aleatória Geometric(p), com
     0<p<1; em outras palavras, essa função é a inversa da função
     'cdf_geometric'.  O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_geometric (<p>)
     Retorna a média de uma variável aleatória Geometric(p), com 0<p<1.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: var_geometric (<p>)
     Retorna a variância de uma variável aleatória Geometric(p), com
     0<p<1.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: std_geometric (<p>)
     Retorna o desvio padrão de uma variável aleatória Geometric(p), com
     0<p<1.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_geometric (<p>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Geometric(p), com 0<p<1.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: kurtosis_geometric (<p>)
     Retorna o coeficiente de curtose de uma geometric variável
     aleatória Geo(p), com 0<p<1.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Variável de opção: random_geometric_algorithm
     Valor por omissão: 'bernoulli'

     Esse é o algoritmo seleccionado para simular variáveis estatísticas
     pseudo-aleatórias geométricas.  Algorítmos implementados são
     'bernoulli', 'devroye' e 'inverse':

        * 'bernoulli', baseado na simulação de testes de Bernoulli.

        * 'devroye', baseado no algoritmo descrito em Devroye, L. (1986)
          <Non-Uniform Random Variate Generation.> Springer Verlag, p.
          480.

        * 'inverse', baseado no método inverso genérico.

     Veja também 'random_geometric'.

 -- Função: random_geometric (<p>)
 -- Função: random_geometric (<p>,<n>)
     Retorna um Geometric(p) variável estatística pseudo-aleatória, com
     0<p<1.  Chamando 'random_geometric' com um segundo argumento <n>,
     uma amostra aleatória de tamanho <n> será simulada.

     Existem três algoritmos implementados para essa função, se pode
     seleccionar o algoritmo a ser usado fornecendo um certo valor à
     variável global 'random_geometric_algorithm', cujo valor padrão é
     'bernoulli'.

     Veja também 'random_geometric_algorithm'.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_discrete_uniform (<x>,<n>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Discrete Uniform(n), com n a strictly positive integer.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_discrete_uniform (<x>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Discrete Uniform(n), com n inteiro
     estritamente positivo.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: quantile_discrete_uniform (<q>,<n>)
     Retorna o <q>-quantil de uma variável aleatória Discrete
     Uniform(n), com n um inteiro estritamente positivo; em outras
     palavras, essa função é a inversa da função 'cdf_discrete_uniform'.
     O argumento <q> deve ser um elemento de [0,1].  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_discrete_uniform (<n>)
     Retorna a média de uma variável aleatória Discrete Uniform(n), com
     n um inteiro estritamente positivo.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: var_discrete_uniform (<n>)
     Retorna a variância de uma variável aleatória Discrete Uniform(n),
     com n um inteiro estritamente positivo.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: std_discrete_uniform (<n>)
     Retorna o desvio padrão de uma variável aleatória Discrete
     Uniform(n), com n um inteiro estritamente positivo.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: skewness_discrete_uniform (<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Discrete Uniform(n), com n um inteiro estritamente positivo.  Para
     fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: kurtosis_discrete_uniform (<n>)
     Retorna o coeficiente de curtose de uma variável aleatória Discrete
     Uniform(n), com n um inteiro estritamente positivo.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: random_discrete_uniform (<n>)
 -- Função: random_discrete_uniform (<n>,<m>)
     Retorna uma variável estatística pseudo-aleatória Discrete
     Uniform(n), com n um inteiro estritamente positivo.  Chamando
     'random_discrete_uniform' com um segundo argumento <m>, uma amostra
     aleatória de tamanho <m> será simulada.

     Isso é uma aplicação directa da função 'random' built-in função do
     Maxima.

     Veja também 'random'.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: pdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros
     não negativos e n<=n1+n2.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: cdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Hypergeometric(n1,n2,n), com <n1>, <n2> e
     <n> inteiros não negativos e n<=n1+n2.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: quantile_hypergeometric (<q>,<n1>,<n2>,<n>)
     Retorna o <q>-quantil de uma variável aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2; em outras palavras, essa função é a inversa
     da função 'cdf_hypergeometric'.  O argumento <q> deve ser um
     elemento de [0,1].  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: mean_hypergeometric (<n1>,<n2>,<n>)
     Retorna a média de uma variável aleatória discreta univorme
     Hyp(n1,n2,n), com <n1>, <n2> e <n> inteiros não negativos e
     n<=n1+n2.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: var_hypergeometric (<n1>,<n2>,<n>)
     Retorna a variância de uma variável aleatória hipergeométrica
     Hyp(n1,n2,n), com <n1>, <n2> e <n> inteiros não negativos e
     n<=n1+n2.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: std_hypergeometric (<n1>,<n2>,<n>)
     Retorna o desvio padrão de uma variável aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: skewness_hypergeometric (<n1>,<n2>,<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: kurtosis_hypergeometric (<n1>,<n2>,<n>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Variável de opção: random_hypergeometric_algorithm
     Valor por omissão: 'kachit'

     Esse é o algoritmo seleccionado para simular variáveis estatísticas
     pseudo aleatórias hipergeométricas.Os algoritmos implementados são
     'kachit' e 'inverse':

        * 'kachit', baseado no algoritmo descrito em Kachitvichyanukul,
          V., Schmeiser, B.W. (1985) <Computer generation of
          hypergeometric variáveis estatística pseudo-aleatórias.>
          Journal of Statistical Computation and Simulation 22, 127-145.

        * 'inverse', baseado no método inverso genérico.

     Veja também 'random_hypergeometric'.

 -- Função: random_hypergeometric (<n1>,<n2>,<n>)
 -- Função: random_hypergeometric (<n1>,<n2>,<n>,<m>)
     Retorna uma variável estatística pseudo-aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2.  Chamando 'random_hypergeometric' com um
     quarto argumento <m>, uma amostra aleatória de tamanho <m> será
     simulada.

     Existem dois algoritmos implementados para essa função, se pode
     seleccionar o algoritmo a ser usado fornecendo um certo valor à
     variável global 'random_hypergeometric_algorithm', cujo valor
     padrão é 'kachit'.

     Veja também 'random_hypergeometric_algorithm'.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_negative_binomial (<x>,<n>,<p>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Negative Binomial(n,p), com 0<p<1 e n um inteiro
     positivo.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: cdf_negative_binomial (<x>,<n>,<p>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma Negative Binomial(n,p) variável aleatória, com 0<p<1 e n um
     inteiro positivo.

     Essa função é calculada numéricamente se a variável global 'numer'
     for igual a 'true', de outra forma essa função retorna uma
     expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_negative_binomial(3,4,1/8);
                                                       1
          (%o2)            cdf_negative_binomial(3, 4, -)
                                                       8
          (%i3) cdf_negative_binomial(3,4,1/8), numer;
          (%o3)                  .006238937377929698

 -- Função: quantile_negative_binomial (<q>,<n>,<p>)
     Retorna o <q>-quantil de uma variável aleatória Negative
     Binomial(n,p), com 0<p<1 e n um inteiro positivo; em outras
     palavras, essa função é a inversa da função
     'cdf_negative_binomial'.  O argumento <q> deve ser um elemento de
     [0,1].  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: mean_negative_binomial (<n>,<p>)
     Retorna a média de uma variável aleatória Negative Binomial(n,p),
     com 0<p<1 e n um inteiro positivo.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: var_negative_binomial (<n>,<p>)
     Retorna a variância de uma variável aleatória Negative
     Binomial(n,p), com 0<p<1 e n um inteiro positivo.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: std_negative_binomial (<n>,<p>)
     Retorna o desvio padrão de uma variável aleatória Negative
     Binomial(n,p), com 0<p<1 e n um inteiro positivo.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: skewness_negative_binomial (<n>,<p>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Negative Binomial(n,p), com 0<p<1 e n um inteiro positivo.  Para
     fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: kurtosis_negative_binomial (<n>,<p>)
     Retorna o coeficiente de curtose de uma variável aleatória Negative
     Binomial(n,p), com 0<p<1 e n um inteiro positivo.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Variável de opção: random_negative_binomial_algorithm
     Valor por omissão: 'bernoulli'

     Esse é o algoritmo seleccionado para simular variáveis estatísticas
     pseuso-aleatórias binomiais negativas.  Os algoritmos implementados
     são 'devroye', 'bernoulli' e 'inverse':

        * 'devroye', baseado no algoritmo descrito em Devroye, L. (1986)
          <Non-Uniform Random Variate Generation>.  Springer Verlag, p.
          480.

        * 'bernoulli', baseado na simulação de testes de Bernoulli.

        * 'inverse', baseado no método inverso genérico.

     Veja também 'random_negative_binomial'.

 -- Função: random_negative_binomial (<n>,<p>)
 -- Função: random_negative_binomial (<n>,<p>,<m>)
     Retorna uma variável estatística pseudo-aleatória Negative
     Binomial(n,p), com 0<p<1 e n um inteiro positivo.  Chamando
     'random_negative_binomial' com um terceiro argumento <m>, uma
     amostra aleatória de tamanho <m> será simulada.

     Existem três algoritmos implementados para essa função, se pode
     seleccionar o algoritmo a ser usado fornecendo um certo valor à
     variável global 'random_negative_binomial_algorithm', cujo valor
     padrão é 'bernoulli'.

     Veja também 'random_negative_binomial_algorithm'.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.


File: maxima.info,  Node: dynamics,  Next: eval_string,  Prev: distrib,  Up: Top

47 dynamics
***********

* Menu:

* O pacote dynamics::
* Análise gráfica de sistemas dinâmicos discretos::
* Visualização usando VTK::


File: maxima.info,  Node: O pacote dynamics,  Next: Análise gráfica de sistemas dinâmicos discretos,  Prev: dynamics,  Up: dynamics

47.1 O pacote dynamics
======================

O pacote adicional 'dynamics' inclui várias funções para criar diversas
representações gráficas de sistemas dinâmicos e fractais, para além duma
implementaçõ do método numérico de Runge-Kutta de quarta ordem, para
resolver sistemas de equações diferenciais.

Para usar as funções neste pacote será necessário primeiro que tudo
carregá-lo com 'load("dynamics")'; as funções que criam gráficos
precisam que o Xmaxima esteja instalado.


File: maxima.info,  Node: Análise gráfica de sistemas dinâmicos discretos,  Next: Visualização usando VTK,  Prev: O pacote dynamics,  Up: dynamics

47.2 Análise gráfica de sistemas dinâmicos discretos
====================================================

 -- Função: chaosgame ('[['<x1>, <y1>']'...'['<xm>, <ym>']]', '['<x0>,
          <y0>']', <b>, <n>, ...opções...);

     Usa o método designado de _jogo do caos_, para produzir fractais:
     desenha-se um ponto inicial (<x0>, <y0>) e logo escolhe-se
     aleatoriamente um dos <m> pontos '['<x1>, <y1>']'...'['<xm>,
     <ym>']'.  A seguir, desenha-se um novo ponto que estará no segmento
     entre o último ponto desenhado e o ponto que se acabou de
     seleccionar aleatoriamente, a uma distância do ponto seleccionado
     que será <b> vezes o comprimento do segmento.  O processo repete-se
     <n> vezes.

 -- Função: evolution (<F>, <y0>, <n>,...opções...);

     Desenha <n+1> pontos num gráfico bidimensional (série de tempo),
     onde as coordenadas horizontais dos pontos são os números inteiros
     0, 1, 2, ..., <n>, e as coordenadas verticais são os valores <y(n)>
     correspondentes, obtidos a partir da relação de recorrência
                  y(n+1) = F(y(n))

     Com valor inicial <y(0)> igual a <y0>.  <F> deverá ser uma
     expressão que dependa unicamente da variável <y> (e não de <n>),
     <y0> deverá ser um número real e <n> um número inteiro positivo.

 -- Função: evolution2d ('['<F>, <G>']', '['<x0>, <y0>']', <n>,
          ...opções...);

     Mostra, num gráfico bidimensional, os primeiros <n+1> pontos da
     sucessão definida a partir do sistema dinâmico discreto com
     relações de recorrência:
                  x(n+1) = F(x(n), y(n))    y(n+1) = G(x(n), y(n))

     Com valores iniciais <x0> e <y0>.  <F> e <G> deverão ser duas
     expressões que dependam unicamente de <x> e <y>.

 -- Função: ifs ('['<r1>,...,<rm>']','['<A1>,...,<Am>']',
          '[['<x1>,<y1>']'...'['<xm>, <ym>']]', '['<x0>,<y0>']',
     <n>, ...opções...);

     Usa o método do Sistema de Funções Iteradas (IFS, em inglês
     _Iterated Function System_).  Esse método é semelhante ao método
     descrito na função 'chaosgame', mas em vez de aproximar o último
     ponto para ponto seleccionado aleatoriamente, as duas coordenadas
     do último ponto multiplicam-se por uma matriz 2 por 2 <Ai>
     correspondente ao ponto que tenha sido escolhido aleatoriamente.

     A selecção aleatória de um dos <m> pontos atractivos pode se
     realizada com uma função de probabilidade não uniforme, definida
     com os pesos <r1>,...,<rm>.  Pesos esses que deverão ser dados em
     forma acumulada; por exemplo, se quiser usar 3 pontos com
     probabilidades 0.2, 0.5 e 0.3, os pesos <r1>, <r2> e <r3> poderiam
     ser 2, 7 e 10, ou qualquer outro grupo de números que estejam na
     mesma proporção.

 -- Função: orbits (<F>, <y0>, <n1>, <n2>, [<x>, <x0>, <xf>, <xstep>],
          ...opções...);

     Desenha o diagrama de órbitas duma família de sistemas dinâmicos
     discretos unidimensionais, com um parâmetro <x>; esse tipo de
     diagrama usa-se para mostrar as bifurcações dum sistema discreto
     unidimensional.

     A função <F(y)> define uma sequência que começa com um valor
     inicial <y0>, igual que no caso da função 'evolution', mas neste
     caso a função também dependerá do parâmetro <x>, o qual terá
     valores compreendidos no intervalo de <x0> a <xf>, com incrementos
     <xstep>.  Cada valor usado para o parâmetro <x> apresenta-se no
     eixo horizontal.  No eixo vertical apresentam-se <n2> valores da
     sucessão <y(n1+1)>,..., <y(n1+n2+1)>, obtidos após deixá-la evoluir
     durante <n1> iterações iniciais.

 -- Função: rk (EDO, var, inicial, dominio)
 -- Função: rk ([EDO1,...,EDOm], [v1,...,vm], [inic1,...,inicm],
          domínio)

     A primeira forma usa-se para resolver numericamente uma equação
     diferencial ordinária de primeira ordem (EDO), e a segunda forma
     resolve numericamente um sistema de <m> dessas equações, usando o
     método de Runge-Kutta de quarta ordem.  <var> representa a variável
     dependente.  EDO deverá ser uma expressão que dependa unicamente
     das variáveis independente e dependente, e define a derivada da
     variável dependente em função da variável independente.

     A variável independente representa-se com <domínio>, que deverá ser
     uma lista com quatro elementos, como, por exemplo:
          [t, 0, 10, 0.1]
     o primeiro elemento da lista identifica a variável independente, os
     segundo e terceiro elementos são os valores inicial e final para
     essa variável, e o último elemento dá o valor dos incrementos que
     deverão ser usados dentro desse intervalo.

     Se se estiverem a resolver <m> equações, deverá haver <m> variáveis
     dependentes <v1>, <v2>, ..., <vm>.  Os valores iniciais para essas
     variáveis serão <inic1>, <inic2>, ..., <inicm>.  Continuará
     existindo apenas uma variável independente, definida pela lista
     <domain>, tal como no caso anterior.  <EDO1>, ..., <EDOm> são as
     expressões que definem as derivadas de cada uma das variáveis
     dependentes, em função da variável independente.  As únicas
     variáveis que podem aparecer em cada uma dessas expressões são a
     variável independente e qualquer uma das variáveis dependentes.  É
     importante que as derivadas <EDO1>, ..., <EDOm> sejam colocadas na
     lista na mesma ordem em que forem agrupadas as variáveis
     dependentes; por exemplo, o terceiro elemento da lista será
     interpretado como a derivada da terceira variável dependente.

     O programa tenta integrar as equações desde o valor inicial da
     variável independente, até o valor final, usando incrementos fixos.
     Se em algum passo uma das variáveis dependentes atingir um valor
     absoluto muito elevado, a integração será interrompida nesse ponto.
     O resultado será uma lista com um número de elementos igual ao
     número de iterações realizadas.  Cada elemento na lista de
     resultados é também uma lista com <m>+1 elementos: o valor da
     variável independente, seguido dos valores das variáveis
     dependentes nesse ponto.

 -- Função: staircase (<F>, <y0>, <n>, ...opções...);

     Desenha um diagrama de degraus (ou diagrama de teia de aranha) para
     a sucessão definida pela equação de recorrência
                  y(n+1) = F(y(n))

     A interpretação e valores permitidos dos parâmetros de entrada é
     igual que para a função 'evolution'.  Um diagrama de degraus
     consiste num gráfico da função <F(y)>, junto com a recta <G(y)> '='
     <y>.  Começa-se por desenhar um segmento vertical desde o ponto
     (<y0>, <y0>) na recta, até o ponto de intersecção com a função <F>.
     A seguir, desde esse ponto desenha-se um segmento horizontal até o
     ponto de intersecção com a recta, (<y1>, <y1>); o processo
     repete-se <n> vezes até alcançar o ponto (<yn>, <yn>).

Opções

Cada opção é uma lista com dois ou mais elementos.  O primeiro elemento
na lista é o nome da opção e os restantes são os argumentos para essa
opção.

As opções aceites pelas funções evolution, evolution2, staircase,
orbits, ifs e chaosgame são as seguintes:

   * "domain" especifica os valores mínimo y máximo da variável
     independente para o gráfico da função <F> representada por
     'staircase'.

   * "pointsize" define o raio de cada ponto desenhado, em unidades de
     pontos.  O valor por omissão é 1.

   * "xaxislabel" é o nome que será dado ao eixo horizontal.

   * "xcenter" é a coordenada x do ponto que deverá aparecer no centro
     do gráfico.  Esta opção não é usada pela função 'orbits'.

   * "xradius" é metade do comprimento do intervalo de valores de x que
     serão representados.  Esta opção não é usada pela função 'orbits'.

   * "yaxislabel" é o nome que será dado ao eixo vertical.

   * "ycenter" é a coordenada y do ponto que deverá aparecer no centro
     do gráfico.

   * "yradius" é metade do comprimento do intervalo de valores de y que
     serão representados.

As opções aceites pelos programas juli Exemplos

Representação gráfica e diagrama de degraus da sequência: 2, cos(2),
cos(cos(2)),...

     (%i1) load("dynamics")$
     (%i2) evolution(cos(y), 2, 11, [yaxislabel, "y"], [xaxislabel,"n"]);
     (%i3) staircase(cos(y), 1, 11, [domain, 0, 1.2]);

Se o seu processador for lento, terá que reduzir o número de iterações
usado nos exemplos seguintes.  E o valor de <pointsize> que dá os
melhores resultados dependerá do monitor e da resolução usada.  Terá que
experimentar com diferentes valores.

Diagrama de órbitas para o mapa quadrático
             y(n+1) = x + y(n)^2

     (%i4) orbits(y^2+x, 0, 50, 200, [x, -2, 0.25, 0.01], [pointsize, 0.9]);

Para ampliar a região à volta da bifurcação na parte de baixo, perto de
x '=' -1.25, use o comando:
     (%i5) orbits(x+y^2, 0, 100, 400, [x,-1,-1.53,-0.001], [pointsize,0.9],
                  [ycenter,-1.2], [yradius,0.4]);

Evolução dum sistema em duas dimensões, que conduz a um fractal:

     (%i6) f: 0.6*x*(1+2*x)+0.8*y*(x-1)-y^2-0.9$
     (%i7) g: 0.1*x*(1-6*x+4*y)+0.1*y*(1+9*y)-0.4$
     (%i8) evolution2d([f,g],[-0.5,0],50000,[pointsize,0.7]);

E uma ampliação de uma pequena região no fractal:

     (%i9) evolution2d([f,g],[-0.5,0],300000,[pointsize,0.7], [xcenter,-0.7],
                       [ycenter,-0.3],[xradius,0.1],[yradius,0.1]);

Um gráfico do triângulo de Sierpinsky, obtido com o jogo do caos:

     (%i9) chaosgame([[0, 0], [1, 0], [0.5, sqrt(3)/2]], [0.1, 0.1], 1/2,
                      30000, [pointsize,0.7]);

O feto de Barnsley, obtido com o Sistema de Funções Iteradas:

     (%i10) a1: matrix([0.85,0.04],[-0.04,0.85])$
     (%i11) a2: matrix([0.2,-0.26],[0.23,0.22])$
     (%i12) a3: matrix([-0.15,0.28],[0.26,0.24])$
     (%i13) a4: matrix([0,0],[0,0.16])$
     (%i14) p1: [0,1.6]$
     (%i15) p2: [0,1.6]$
     (%i16) p3: [0,0.44]$
     (%i17) p4: [0,0]$
     (%i18) w: [85,92,99,100]$
     (%i19) ifs(w,[a1,a2,a3,a4],[p1,p2,p3,p4],[5,0],50000,[pointsize,0.9]);

Para resolver numericamente a equação diferencial

               dx/dt = t - x^2

Com valor inicial x(t=0) = 1, no intervalo de t desde 0 até 8, e com
incrementos de 0.1, usa-se:

     (%i20) resultados: rk(t-x^2,x,1,[t,0,8,0.1])$

os resultados ficarão armazenados na lista resultados.

Para resolver numericamente o sistema:

             dx/dt = 4-x^2-4*y^2     dy/dt = y^2-x^2+1

para t entre 0 e 4, com valores iniciais -1.25 e 0.75 para (x, y) em
t=0:

     (%i21) sol: rk([4-x^2-4*y^2,y^2-x^2+1],[x,y],[-1.25,0.75],[t,0,4,0.02])$


File: maxima.info,  Node: Visualização usando VTK,  Prev: Análise gráfica de sistemas dinâmicos discretos,  Up: dynamics

47.3 Visualização usando VTK
============================

A função scene cria imagens a três dimensões e animações, usando o
software _Visualization ToolKit_ (VTK). Para poder usar essa função é
necessário ter Xmaxima e VTK instalados no sistema (incluindo a libraria
para utilizar VTK desde TCL, que pode vir num pacote separado em alguns
sistemas).


File: maxima.info,  Node: eval_string,  Next: f90,  Prev: dynamics,  Up: Top

48 eval_string
**************

* Menu:

* Definições para eval_string::


File: maxima.info,  Node: Definições para eval_string,  Prev: eval_string,  Up: eval_string

48.1 Definições para eval_string
================================

 -- Função: eval_string (<str>)
     Entrega a sequência de caracteres do Maxima <str> como uma
     expressão do Maxima e a avalia.  <str> é uma sequência de
     caracteres do Maxima.  Essa sequência pode ou não ter um marcador
     de final (sinal de dólar '$' ou ponto e vírgula ';').  Somente a
     primeira expressão é entregue e avaliada, se ouver mais de uma.

     Reclama se <str> não for uma sequência de caracteres do Maxima.

     Exemplos:
          (%i1) load("eval_string")$

          (%i2) eval_string ("foo: 42; bar: foo^2 + baz");
          (%o2)                       42
          (%i3) eval_string ("(foo: 42, bar: foo^2 + baz)");
          (%o3)                   baz + 1764

     Para usar essa função escreva primeiro 'load("eval_string")'.  Veja
     também 'parse_string'.

 -- Função: parse_string (<str>)
     Entrega a sequência de caracteres do Maxima <str> como uma
     expressão do Maxima (sem fazer nenhuma avaliação dessa expressão).
     <str> é uma sequência de caracteres do Maxima.  Essa sequência pode
     ou não ter um marcador de final (sinal de dólar '$' ou ponto e
     vírgula ';').  Somente a primeira expressão é entregue e avaliada,
     se ouver mais de uma.

     Reclama se <str> não for uma sequência de caracteres do Maxima.

     Exemplos:
          (%i1) load("eval_string")$

          (%i2) parse_string ("foo: 42; bar: foo^2 + baz");
          (%o2)                    foo : 42
          (%i3) parse_string ("(foo: 42, bar: foo^2 + baz)");
                                             2
          (%o3)          (foo : 42, bar : foo  + baz)

     Para usar essa função escreva primeiro 'load("eval_string")'.  Veja
     também a função 'eval_string'.


File: maxima.info,  Node: f90,  Next: ggf,  Prev: eval_string,  Up: Top

49 f90
******

* Menu:

* Definições para f90::


File: maxima.info,  Node: Definições para f90,  Prev: f90,  Up: f90

49.1 Definições para f90
========================

 -- Função: f90 (<expr>)
     O comando f90 é uma actualização do comando 'fortran' original do
     maxima.  A principal diferença é na forma como são divididas as
     linhas muito compridas.

     No exemplo seguinte, observe como o comando 'fortran' divide linhas
     no meio de símbolos.  O comando 'f90' nunca separa uma linha no
     meio de um símbolo.

          (%i1) load("f90")$

          (%i2) expr:expand((xxx+yyy+7)^4);
                   4            3         3        2    2
          (%o2) yyy  + 4 xxx yyy  + 28 yyy  + 6 xxx  yyy
                       2          2        3             2
           + 84 xxx yyy  + 294 yyy  + 4 xxx  yyy + 84 xxx  yyy
                                         4         3          2
           + 588 xxx yyy + 1372 yyy + xxx  + 28 xxx  + 294 xxx
           + 1372 xxx + 2401
          (%i3) fortran(expr);
                yyy**4+4*xxx*yyy**3+28*yyy**3+6*xxx**2*yyy**2+84*xxx*yyy**2+294*yy
               1   y**2+4*xxx**3*yyy+84*xxx**2*yyy+588*xxx*yyy+1372*yyy+xxx**4+28*
               2   xxx**3+294*xxx**2+1372*xxx+2401
          (%o3)                       done
          (%i4) f90(expr);
          yyy**4+4*xxx*yyy**3+28*yyy**3+6*xxx**2*yyy**2+84*xxx*yyy**2+294* &
               yyy**2+4*xxx**3*yyy+84*xxx**2*yyy+588*xxx*yyy+1372*yyy+xxx** &
               4+28*xxx**3+294*xxx**2+1372*xxx+2401
          (%o4)                       done

     A função 'f90' foi criada como uma forma rápida de resolver um
     problema.  Não será necessariamente um bom exemplo a seguir para
     traduções de outras linguagens de programação.

     Para usar esta função, use primeiro 'load("f90")'.


File: maxima.info,  Node: ggf,  Next: impdiff,  Prev: f90,  Up: Top

50 ggf
******

* Menu:

* Definições para ggf::


File: maxima.info,  Node: Definições para ggf,  Prev: ggf,  Up: ggf

50.1 Definições para ggf
========================

 -- Variável de Opção: GGFINFINITY
     Valor por omissão: 3

     Essa é uma variável de opção para a função 'ggf'.

     Quando calculando a fração contínua da função geradora, um
     quociente parcial tendo um grau (estritamente) maior que
     <GGFINFINITY> será descartado e o convergente actual será
     considerado como o valor exato da função geradora; na grande mioria
     dos casos o grau de todos os quocientes parciais será ou 0 ou 1; se
     usar um valor muito grande, então poderá fornecer termos
     suficientes com o objectivo de fazer o cálculo preciso o bastante.

     Veja também 'ggf'.

 -- Variável de opção: GGFCFMAX
     Valor por omissão: 3

     Essa é uma variável de opção para a função 'ggf'.

     Quando calculando a fração contínua da função geradora, se nenhum
     bom resultado for encontrado (veja o sinalizador <GGFINFINITY>)
     após se ter calculado uma quantidade de <GGFCFMAX> quocientes
     parciais, a função geradora será considerada como não sendo uma
     fração de dois polinómios e a função irá terminar.  Coloque
     livemente um valor muito grande para funções geradoras mais
     complicadas.

     Veja também 'ggf'.

 -- Função: ggf (<l>)
     Calcula a função geradora (se for uma fração de dois polinómios) de
     uma sequência, sendo dados seus primeiros termos.  <l> é uma lista
     de números.

     A solução é retornada como uma fração de dois polinómios.  Se
     nenhuma solução tiver sido encontrada, é retornado 'done'.

     Essa função é controlada attravés das variáveis globais
     <GGFINFINITY> e <GGFCFMAX>.  Veja também <GGFINFINITY> e
     <GGFCFMAX>.

     Para usar essa função primeiro escreva 'load("ggf")'.


File: maxima.info,  Node: impdiff,  Next: interpol,  Prev: ggf,  Up: Top

51 impdiff
**********

* Menu:

* Definições para impdiff::


File: maxima.info,  Node: Definições para impdiff,  Prev: impdiff,  Up: impdiff

51.1 Definições para impdiff
============================

 -- Função: implicit_derivative (<f>,<indvarlist>,<orderlist>,<depvar>)
     Essa subrotina calcula derivadas implícitas de funções de várias
     variáveis.  <f> é uma função do tipo array, os índices são o grau
     da derivada na ordem <indvarlist>; <indvarlist> é a lista de
     variáveis independentes; <orderlist> é a ordem desejada; e <depvar>
     é a variável dependente.

     Para usar essa função escreva primeiro 'load("impdiff")'.


File: maxima.info,  Node: interpol,  Next: lbfgs,  Prev: impdiff,  Up: Top

52 interpol
***********

* Menu:

* Introdução a interpol::
* Definições para interpol::


File: maxima.info,  Node: Introdução a interpol,  Next: Definições para interpol,  Prev: interpol,  Up: interpol

52.1 Introdução a interpol
==========================

Pacote 'interpol' define os métodos Lagrangiano, linear e o de splines
cúbicos para interpolação polinomial.

Comentários, correções e sugestões, por favor contacte-me em <'mario AT
edu DOT xunta DOT es'>.


File: maxima.info,  Node: Definições para interpol,  Prev: Introdução a interpol,  Up: interpol

52.2 Definições para interpol
=============================

 -- Função: lagrange (<pontos>)
 -- Função: lagrange (<pontos>, <opção>)
     Calcula a interpolação polinomial através do método Lagrangiano.  O
     argumento <pontos> deve ser um dos seguintes:

        * uma matriz de duas colunas, 'p:matrix([2,4],[5,6],[9,3])',
        * uma lista de pares, 'p: [[2,4],[5,6],[9,3]]',
        * uma lista de números, 'p: [4,6,3]', e nesse caso as abcissas
          irão ser atribuídas automaticamente aos valores 1, 2, 3, etc.

     Nos dois primeiros casos os pares são ordenados em relação à
     primeira coordenada antes de fazer os cálculos.

     Com o argumento <opção> é possível escolher o nome da variável
     independente, o qual é ''x' por padrão; para definir qualquer
     outra, z por exemplo, escreva 'varname='z'.

     Exemplos:

          (%i1) load("interpol")$
          (%i2) p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$
          (%i3) lagrange(p);
                           4        3         2
                       73 x    701 x    8957 x    5288 x   186
          (%o3)        ----- - ------ + ------- - ------ + ---
                        420     210       420      105      5
          (%i4) f(x):=''%;
                               4        3         2
                           73 x    701 x    8957 x    5288 x   186
          (%o4)    f(x) := ----- - ------ + ------- - ------ + ---
                            420     210       420      105      5
          (%i5) /* Evaluate the polynomial at some points */
                map(f,[2.3,5/7,%pi]);
                                       919062
          (%o5)  [- 1.567534999999992, ------,
                                       84035
                                   4          3           2
                             73 %pi    701 %pi    8957 %pi    5288 %pi   186
                             ------- - -------- + --------- - -------- + ---]
                               420       210         420        105       5
          (%i6) %,numer;
          (%o6) [- 1.567534999999992, 10.9366573451538, 2.89319655125692]
          (%i7) /* Plot the polynomial together with points */
                plot2d([f(x),[discrete,p]],[x,0,10],
                     [gnuplot_curve_styles,
                           ["with lines","with points pointsize 3"]])$
          (%i8) /* Change variable name */
                lagrange(p, varname=w);
                           4        3         2
                       73 w    701 w    8957 w    5288 w   186
          (%o8)        ----- - ------ + ------- - ------ + ---
                        420     210       420      105      5

 -- Função: charfun2 (<x>, <a>, <b>)
     Retorna 'true', i.  e., verdadeiro se o número <x> pertence ao
     intervalo [a, b), e 'false', i.  e., falsono caso contrário.

 -- Função: linearinterpol (<pontos>)
 -- Função: linearinterpol (<pontos>, <opção>)
     Calcula a interpolação polinomial através do método linear.  O
     argumento <pontos> deve ser um dos seguintes:

        * uma matriz de duas colunas, 'p:matrix([2,4],[5,6],[9,3])',
        * uma lista de pares, 'p: [[2,4],[5,6],[9,3]]',
        * uma lista de números, 'p: [4,6,3]', e nesse caso as abcissas
          irão ser atribuídas automaticamente aos valores 1, 2, 3, etc.

     Nos dois primeiros casos os pares são ordenados em relação à
     primeira coordenada antes de fazer os cálculos.

     Com o argumento <opção> é possível escolher o nome da variável
     independente, o qual é ''x' por padrão; para definir qualquer
     outra, z por exemplo, escreva 'varname='z'.

     Examples:
          (%i1) load("interpol")$
          (%i2) p: matrix([7,2],[8,3],[1,5],[3,2],[6,7])$
          (%i3) linearinterpol(p);
                  13   3 x
          (%o3)  (-- - ---) charfun2(x, minf, 3)
                  2     2
           + (x - 5) charfun2(x, 7, inf) + (37 - 5 x) charfun2(x, 6, 7)
              5 x
           + (--- - 3) charfun2(x, 3, 6)
               3

          (%i4) f(x):=''%;
                          13   3 x
          (%o4)  f(x) := (-- - ---) charfun2(x, minf, 3)
                          2     2
           + (x - 5) charfun2(x, 7, inf) + (37 - 5 x) charfun2(x, 6, 7)
              5 x
           + (--- - 3) charfun2(x, 3, 6)
               3
          (%i5)  /* Evaluate the polynomial at some points */
                 map(f,[7.3,25/7,%pi]);
                                      62  5 %pi
          (%o5)                 [2.3, --, ----- - 3]
                                      21    3
          (%i6) %,numer;
          (%o6)  [2.3, 2.952380952380953, 2.235987755982989]
          (%i7)  /* Plot the polynomial together with points */
                 plot2d(['(f(x)),[discrete,args(p)]],[x,-5,20],
                     [gnuplot_curve_styles,
                           ["with lines","with points pointsize 3"]])$
          (%i8)  /* Change variable name */
                 linearinterpol(p, varname='s);
                 13   3 s
          (%o8) (-- - ---) charfun2(s, minf, 3)
                 2     2
           + (s - 5) charfun2(s, 7, inf) + (37 - 5 s) charfun2(s, 6, 7)
              5 s
           + (--- - 3) charfun2(s, 3, 6)
               3

 -- Função: cspline (<pontos>)
 -- Função: cspline (<pontos>, <opção1>, <opção2>, ...)
     Calcula a interpolação polnomial pelo método de splines (
     polinómios de ordem k que interpolam os dados e têm k-1 derivadas
     contínuas em todo o intervalo ) cúbicos.  O argumento <pontos> deve
     ser um dos seguintes:

        * uma matriz de duas colunas, 'p:matrix([2,4],[5,6],[9,3])',
        * uma lista de pares, 'p: [[2,4],[5,6],[9,3]]',
        * uma lista de números, 'p: [4,6,3]', e nesse caso as abcissas
          irão ser atribuídas automaticamente aos valores 1, 2, 3, etc.

     Nos dois primeiros casos os pares são ordenados em relação à
     primeira coordenada antes de fazer os cálculos.

     Existem três opções para ajustar necessidades específicas:
        * ''d1', o padrão é ''unknown', é a primeira derivada em x_1; se
          essa primeira derivada for desconhecida, ''unknown', a segunda
          derivada em x_1 é igualada a 0 (o spline cúbico natural); se
          essa primeira derivada for igual a um número, a segunda
          derivada é calculada baseando-se nesse número.

        * ''dn', o padrão é ''unknown', é a primeira derivada em x_n; se
          essa primeira derivada for desconhecida, ''unknown', a segunda
          derivada em x_n é igualada a 0 (o spline cúbico natural); se
          essa primeira derivada for igual a um número, a segunda
          derivada é calculada baseando-se nesse número.

        * ''nome_var', o padrão é ''x', é o nome da variável
          independente.

     Exemplos:
          (%i1) load("interpol")$
          (%i2) p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$
          (%i3) /* Unknown first derivatives at the extremes
                   is equivalent to natural cubic splines */
                cspline(p);
                        3         2
                  1159 x    1159 x    6091 x   8283
          (%o3)  (------- - ------- - ------ + ----) charfun2(x, minf, 3)
                   3288      1096      3288    1096
                      3         2
                2587 x    5174 x    494117 x   108928
           + (- ------- + ------- - -------- + ------) charfun2(x, 7, inf)
                 1644       137       1644      137
                    3          2
              4715 x    15209 x    579277 x   199575
           + (------- - -------- + -------- - ------) charfun2(x, 6, 7)
               1644       274        1644      274
                      3         2
                3287 x    2223 x    48275 x   9609
           + (- ------- + ------- - ------- + ----) charfun2(x, 3, 6)
                 4932       274      1644     274

          (%i4) f(x):=''%$
          (%i5) /* Some evaluations */
                map(f,[2.3,5/7,%pi]), numer;
          (%o5) [1.991460766423356, 5.823200187269903, 2.227405312429507]
          (%i6) /* Plotting interpolating function */
                plot2d(['(f(x)),[discrete,p]],[x,0,10],
                    [gnuplot_curve_styles,
                         ["with lines","with points pointsize 3"]])$
          (%i7) /* New call, but giving values at the derivatives */
                cspline(p,d1=0,dn=0);
                        3          2
                  1949 x    11437 x    17027 x   1247
          (%o7)  (------- - -------- + ------- + ----) charfun2(x, minf, 3)
                   2256       2256      2256     752
                      3          2
                1547 x    35581 x    68068 x   173546
           + (- ------- + -------- - ------- + ------) charfun2(x, 7, inf)
                  564       564        141      141
                   3          2
              607 x    35147 x    55706 x   38420
           + (------ - -------- + ------- - -----) charfun2(x, 6, 7)
               188       564        141      47
                      3         2
                3895 x    1807 x    5146 x   2148
           + (- ------- + ------- - ------ + ----) charfun2(x, 3, 6)
                 5076       188      141      47
          (%i8) /* Defining new interpolating function */
                g(x):=''%$
          (%i9) /* Plotting both functions together */
                plot2d(['(f(x)),'(g(x)),[discrete,p]],[x,0,10],
                     [gnuplot_curve_styles,
                        ["with lines","with lines","with points pointsize 3"]])$


File: maxima.info,  Node: lbfgs,  Next: lindstedt,  Prev: interpol,  Up: Top

53 lbfgs
********

* Menu:

* Introdução a lbfgs::
* Definições para lbfgs::


File: maxima.info,  Node: Introdução a lbfgs,  Next: Definições para lbfgs,  Prev: Top,  Up: Top

53.1 Introdução a lbfgs
=======================

'lbfgs' é uma implementação do algoritmo[1] L-BFGS
(Broyden-Fletcher-Goldfarb-Shanno) para resolver problemas de
minimização não limitada através de um algoritmo de memória limitada
quasi-Newton (BFGS). Esse algoritmo é chamado de método de memória
limitada porque uma aproximação de baixo ranque da inverso da matriz
Hessiana é armazenado em lugar da inversa da matriz Hessiana completa.
O programa foi escrito origináriamente em Fortran [2] por Jorge Nocedal,
incorporando algumas funções originalmente escritas por Jorge J. Moré e
David J. Thuente, e traduzidas para Lisp automaticamente através do
programa 'f2cl'.  O pacote do Maxima 'lbfgs' compreende o código
traduzido e adicionalmente uma interface de função que gerencia alguns
detallhes.

Referências:

[1] D. Liu and J. Nocedal.  "On the limited memory BFGS method for large
scale optimization".  Mathematical Programming B 45:503-528 (1989)

[2] http://netlib.org/opt/lbfgs_um.shar


File: maxima.info,  Node: Definições para lbfgs,  Prev: Introdução a lbfgs,  Up: Top

53.2 Definições para lbfgs
==========================

 -- Função: lbfgs (<FOM>, <X>, <X0>, <epsilon>, <iprint>)

     Encontra uma solução aproximada da minimização não limitada de
     número de mérito <FOM> sobre a lista de variáveis <X>, começando a
     partir da estimativa inicial <X0>, tal que norm grad FOM < epsilon
     max(1, norm X).

     O algoritmo aplicado é um algoritmo de memória limitada[1]
     quasi-Newton (BFGS). Esse algoritmo é chamado de método de memória
     limitada porque uma aproximação de baixo ranque da inverso da
     matriz Hessiana é armazenado em lugar da inversa da matriz Hessiana
     completa.

     <iprint> controla as messaens de progresso mostradas através de
     'lbfgs'.

     'iprint[1]'
          '<iprint>[1]' controla a frequência das mensagens de
          progresso.
          'iprint[1] < 0'
               Nenhuma mensagem de progresso.
          'iprint[1] = 0'
               Messagens na primeira iteração e na última iteração.
          'iprint[1] > 0'
               Mostra uma mensagem a cada '<iprint>[1]' iterações.
     'iprint[2]'
          '<iprint>[2]' controla a quantidade de informações fornecidas
          pelas mensagens de progresso (verbosidade).
          'iprint[2] = 0'
               Mostra na tela o contador de iterações, o número de
               avaliações de <FOM>, o valor de <FOM>, a norma do
               gradiente de <FOM>, e o comprimento do salto.
          'iprint[2] = 1'
               O mesmo que '<iprint>[2] = 0', adicionando <X0> e o
               gradiente de <FOM> avaliado em <X0>.
          'iprint[2] = 2'
               O mesmo que '<iprint>[2] = 1', adicionando valores de <X>
               a cada iteração.
          'iprint[2] = 3'
               O mesmo que '<iprint>[2] = 2', adicionando o gradiente de
               <FOM> a cada iteração.

     Veja também 'lbfgs_nfeval_max' e 'lbfgs_ncorrections'.

     Referências:

     [1] D. Liu and J. Nocedal.  "On the limited memory BFGS method for
     large scale optimization".  Mathematical Programming B 45:503-528
     (1989)

     Exemplo:

          (%i1) load (lbfgs);
          (%o1)   /usr/share/maxima/5.10.0cvs/share/lbfgs/lbfgs.mac
          (%i2) FOM : '((1/length(X))*sum((F(X[i]) - Y[i])^2, i, 1, length(X)));
                                         2
                         sum((F(X ) - Y ) , i, 1, length(X))
                                 i     i
          (%o2)          -----------------------------------
                                      length(X)
          (%i3) X : [1, 2, 3, 4, 5];
          (%o3)                    [1, 2, 3, 4, 5]
          (%i4) Y : [0, 0.5, 1, 1.25, 1.5];
          (%o4)                [0, 0.5, 1, 1.25, 1.5]
          (%i5) F(x) := A/(1 + exp(-B*(x - C)));
                                             A
          (%o5)            F(x) := ----------------------
                                   1 + exp((- B) (x - C))
          (%i6) ''FOM;
                          A               2            A                2
          (%o6) ((----------------- - 1.5)  + (----------------- - 1.25)
                    - B (5 - C)                  - B (4 - C)
                  %e            + 1            %e            + 1
                      A             2            A               2
           + (----------------- - 1)  + (----------------- - 0.5)
                - B (3 - C)                - B (2 - C)
              %e            + 1          %e            + 1
                       2
                      A
           + --------------------)/5
                - B (1 - C)     2
             (%e            + 1)
          (%i7) estimates : lbfgs (FOM, '[A, B, C], [1, 1, 1], 1e-4, [1, 0]);
          *************************************************
            N=    3   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  1.348738534246918D-01   GNORM=  2.000215531936760D-01
          *************************************************

             I  NFN     FUNC                    GNORM                   STEPLENGTH

             1    3     1.177820636622582D-01   9.893138394953992D-02   8.554435968992371D-01
             2    6     2.302653892214013D-02   1.180098521565904D-01   2.100000000000000D+01
             3    8     1.496348495303005D-02   9.611201567691633D-02   5.257340567840707D-01
             4    9     7.900460841091139D-03   1.325041647391314D-02   1.000000000000000D+00
             5   10     7.314495451266917D-03   1.510670810312237D-02   1.000000000000000D+00
             6   11     6.750147275936680D-03   1.914964958023047D-02   1.000000000000000D+00
             7   12     5.850716021108205D-03   1.028089194579363D-02   1.000000000000000D+00
             8   13     5.778664230657791D-03   3.676866074530332D-04   1.000000000000000D+00
             9   14     5.777818823650782D-03   3.010740179797255D-04   1.000000000000000D+00

           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o7) [A = 1.461933911464101, B = 1.601593973254802,
                                                     C = 2.528933072164854]
          (%i8) plot2d ([F(x), [discrete, X, Y]], [x, -1, 6]), ''estimates;
          (%o8)

 -- Variãvel: lbfgs_nfeval_max
     Valor por omissão: 100

 -- Variãvel: lbfgs_ncorrections
     Valor por omissão: 25


File: maxima.info,  Node: lindstedt,  Next: linearalgebra,  Prev: lbfgs,  Up: Top

54 lindstedt
************

* Menu:

* Definições para lindstedt::


File: maxima.info,  Node: Definições para lindstedt,  Prev: lindstedt,  Up: lindstedt

54.1 Definições para lindstedt
==============================

 -- Função: Lindstedt (<eq>,<pvar>,<torder>,<ic>)
     Esse é um primeiro passo para um código de Lindstedt.  Esse código
     pode resolver problemas com condições iniciais fornecidas, às quais
     podem ser constantes arbitrárias, (não apenas <%k1> e <%k2>) onde
     as condições iniciais sobre as equações de perturbação são z[i]=0,
     z'[i]=0 para i>0.  <ic> é a lista de condições iniciais.

     Problemas ocorrem quando condições iniciais não forem dadas, como
     as constantes nas equações de perturbação são as mesmas que a
     solução da equação de ordem zero.  Também, problemas ocorrem quando
     as condições iniciais para as equações de perturbação não são
     z[i]=0, z'[i]=0 para i>0, tais como a equação de Van der Pol.

     Exemplo:
          (%i1) load("makeOrders")$

          (%i2) load("lindstedt")$

          (%i3) Lindstedt('diff(x,t,2)+x-(e*x^3)/6,e,2,[1,0]);
                    2
                   e  (cos(5 T) - 24 cos(3 T) + 23 cos(T))
          (%o3) [[[---------------------------------------
                                    36864
             e (cos(3 T) - cos(T))
           - --------------------- + cos(T)],
                      192
                    2
                 7 e    e
          T = (- ---- - -- + 1) t]]
                 3072   16

     Para usar essa função escreva primeiro 'load("makeOrders")' e
     'load("lindstedt")'.


File: maxima.info,  Node: linearalgebra,  Next: lsquares,  Prev: lindstedt,  Up: Top

55 linearalgebra
****************

* Menu:

* Introdução a linearalgebra::
* Definições para linearalgebra::


File: maxima.info,  Node: Introdução a linearalgebra,  Next: Definições para linearalgebra,  Prev: linearalgebra,  Up: linearalgebra

55.1 Introdução a linearalgebra
===============================

'linearalgebra' é uma colecção de funções para álgebra linear.

Exemplo:

     (%i1) load (linearalgebra);
     Warning - you are redefining the Maxima function require_list
     Warning - you are redefining the Maxima function matrix_size
     Warning - you are redefining the Maxima function rank
     (%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
     (%i2) M : matrix ([1, 2], [1, 2]);
                                 [ 1  2 ]
     (%o2)                       [      ]
                                 [ 1  2 ]
     (%i3) nullspace (M);
                                    [  1  ]
                                    [     ]
     (%o3)                     span([   1 ])
                                    [ - - ]
                                    [   2 ]
     (%i4) columnspace (M);
                                     [ 1 ]
     (%o4)                      span([   ])
                                     [ 1 ]
     (%i5) ptriangularize (M - z*ident(2), z);
                              [ 1   2 - z   ]
     (%o5)                    [             ]
                              [           2 ]
                              [ 0  3 z - z  ]
     (%i6) M : matrix ([1, 2, 3], [4, 5, 6], [7, 8, 9]) - z*ident(3);
                          [ 1 - z    2      3   ]
                          [                     ]
     (%o6)                [   4    5 - z    6   ]
                          [                     ]
                          [   7      8    9 - z ]
     (%i7) MM : ptriangularize (M, z);
                   [ 4  5 - z            6            ]
                   [                                  ]
                   [                2                 ]
                   [     66        z    102 z   132   ]
                   [ 0   --      - -- + ----- + ---   ]
     (%o7)         [     49        7     49     49    ]
                   [                                  ]
                   [               3        2         ]
                   [           49 z    245 z    147 z ]
                   [ 0    0    ----- - ------ - ----- ]
                   [            264      88      44   ]
     (%i8) algebraic : true;
     (%o8)                         true
     (%i9) tellrat (MM [3, 3]);
                              3       2
     (%o9)                  [z  - 15 z  - 18 z]
     (%i10) MM : ratsimp (MM);
                    [ 4  5 - z           6           ]
                    [                                ]
                    [                2               ]
     (%o10)         [     66      7 z  - 102 z - 132 ]
                    [ 0   --    - ------------------ ]
                    [     49              49         ]
                    [                                ]
                    [ 0    0             0           ]
     (%i11) nullspace (MM);
                             [        1         ]
                             [                  ]
                             [   2              ]
                             [  z  - 14 z - 16  ]
                             [  --------------  ]
     (%o11)             span([        8         ])
                             [                  ]
                             [    2             ]
                             [   z  - 18 z - 12 ]
                             [ - -------------- ]
                             [         12       ]
     (%i12) M : matrix ([1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]);
                            [ 1   2   3   4  ]
                            [                ]
                            [ 5   6   7   8  ]
     (%o12)                 [                ]
                            [ 9   10  11  12 ]
                            [                ]
                            [ 13  14  15  16 ]
     (%i13) columnspace (M);
                                [ 1  ]  [ 2  ]
                                [    ]  [    ]
                                [ 5  ]  [ 6  ]
     (%o13)                span([    ], [    ])
                                [ 9  ]  [ 10 ]
                                [    ]  [    ]
                                [ 13 ]  [ 14 ]
     (%i14) apply ('orthogonal_complement, args (nullspace (transpose (M))));
                                [ 0 ]  [  1  ]
                                [   ]  [     ]
                                [ 1 ]  [  0  ]
     (%o14)                span([   ], [     ])
                                [ 2 ]  [ - 1 ]
                                [   ]  [     ]
                                [ 3 ]  [ - 2 ]


File: maxima.info,  Node: Definições para linearalgebra,  Prev: Introdução a linearalgebra,  Up: linearalgebra

55.2 Definições para linearalgebra
==================================

 -- Função: addmatrices (<f>, <M_1>, ..., <M_n>)

     Usando a função <f> como a função de adição, retorne a adição das
     matrizes <M_1>, ..., <M_n>.  A função <f> deve aceitar qualquer
     número de argumentos (uma função enária do Maxima).

     Exemplos:

          (%i1) m1 : matrix([1,2],[3,4])$
          (%i2) m2 : matrix([7,8],[9,10])$
          (%i3) addmatrices('max,m1,m2);
          (%o3) matrix([7,8],[9,10])
          (%i4) addmatrices('max,m1,m2,5*m1);
          (%o4) matrix([7,10],[15,20])

 -- Função: blockmatrixp (<M>)

     Retorna 'true' se e somente se <M> for uma matriz e toda entrada de
     <M> também for uma matriz.

 -- Função: columnop (<M>, <i>, <j>, <theta>)

     Se <M> for uma matriz, retorna a matriz que resulta de fazer a
     operação de coluna 'C_i <- C_i - <theta> * C_j'.  Se <M> não tiver
     uma linha <i> ou <j>, emite uma mensagem de erro.

 -- Função: columnswap (<M>, <i>, <j>)

     Se <M> for uma matriz, troca as colunas <i> e <j>.  Se <M> não
     tiver uma coluna <i> ou <j>, emite uma mensagem de erro.

 -- Função: columnspace (<M>)

     Se <M> for uma matriz, retorna 'span (v_1, ..., v_n)', onde o
     conjunto '{v_1, ..., v_n}' é uma base para o espaço coluna de <M>.
     A diferença entre o maior elemento e o menor elemento do conjunto
     vazio é '{0}'.  Dessa forma, quando o espaço coluna tiver somente
     um membro, retorna 'span ()'.

 -- Função: copy (<e>)

     Retorna uma cópia da expressão <e> do Maxima.  Embora <e> possa ser
     qualquer expressão do Maxima, Afunção 'copy' é mais útil quando <e>
     for ou uma lista ou uma matriz; considere: load (linearalgebra); m
     : [1,[2,3]]$ mm : m$ mm[2][1] : x$ m; mm;
          (%i1) load("linearalgebra")$
          (%i2) m : [1,[2,3]]$
          (%i3) mm : m$
          (%i4) mm[2][1] : x$
          (%i5) m;
          (%o5) [1,[x,3]]
          (%i6) mm;
          (%o6) [1,[x,3]]
     Vamos tentar a mesma experiência, mas dessa vez tomemos <mm> como
     sendo uma cópia de <m> m : [1,[2,3]]$ mm : copy(m)$ mm[2][1] : x$
     m; mm;
          (%i7) m : [1,[2,3]]$
          (%i8) mm : copy(m)$
          (%i9) mm[2][1] : x$
          (%i10) m;
          (%o10) [1,[2,3]]
          (%i11) mm;
          (%o11) [1,[x,3]]
     Dessa vez, a atribuição a <mm> não muda o valor de <m>.

 -- Função: cholesky (<M>)
 -- Função: cholesky (<M>, <corpo>)

     Retorna factorização de Cholesky da matriz hermitiana (or
     autoadjunta) <M>.  O valor padrão para o segundo argumento é
     'generalring'.  Para uma descrição dos possíveis valores para
     <corpo>, veja 'lu_factor'.

 -- Função: ctranspose (<M>)

     Retorna a matriz transposta conjugada complexa da matriz <M>.  A
     função 'ctranspose' usa 'matrix_element_transpose' para transpor
     cada elemento da matriz.

 -- Função: diag_matrix (<d_1>, <d_2>,...,<d_n>)

     Retorna uma matriz diagonal matriz com entradas de diagonal <d_1>,
     <d_2>,...,<d_n>.  Quando as entradas de diagonal forem matrizes, as
     entradas zero da matriz retornada serão todas matrizes de tamanho
     apropriado; por exemplo:
          (%i1) load(linearalgebra)$

          (%i2) diag_matrix(diag_matrix(1,2),diag_matrix(3,4));

                                      [ [ 1  0 ]  [ 0  0 ] ]
                                      [ [      ]  [      ] ]
                                      [ [ 0  2 ]  [ 0  0 ] ]
          (%o2)                       [                    ]
                                      [ [ 0  0 ]  [ 3  0 ] ]
                                      [ [      ]  [      ] ]
                                      [ [ 0  0 ]  [ 0  4 ] ]
          (%i3) diag_matrix(p,q);

                                             [ p  0 ]
          (%o3)                              [      ]
                                             [ 0  q ]

 -- Função: dotproduct (<u>, <v>)

     Retorna o produto do ponto (produto escalar) dos vectores <u> e
     <v>.  Isso é o mesmo que 'conjugate (transpose (<u>)) . <v>'.  Os
     argumentos <u> e <v> devem ser vectores coluna.

 -- Função: eigens_by_jacobi (<A>)
 -- Função: eigens_by_jacobi (<A>, <tipo_corpo>)

     Calculam os autovalores e autovectores de <A> pelo método de
     rotações de Jacobi.  <A> deve ser uma matriz simétrica (mas essa
     matriz simétrica precisa não ser nem definida positiva e nem
     semidefinida positiva).  <tipo_corpo> indica o corpo computacional,
     pode ser ou 'floatfield' ou 'bigfloatfield'.  Se <tipo_corpo> não
     for especificado, o padrão é 'floatfield'.

     Os elementos de <A> devem ser números ou expressões que avaliam
     para números via 'float' ou 'bfloat' (dependendo do valor de
     <tipo_corpo>).

     Exemplos:

          (%i1) load (linearalgebra);
          (%o1) /home/robert/tmp/maxima-head/maxima/share/linearalgebra/li\
          nearalgebra.mac
          (%i2) S : matrix ([1/sqrt(2), 1/sqrt(2)], [- 1/sqrt(2), 1/sqrt(2)]);
                               [     1         1    ]
                               [  -------   ------- ]
                               [  sqrt(2)   sqrt(2) ]
          (%o2)                [                    ]
                               [      1        1    ]
                               [ - -------  ------- ]
                               [   sqrt(2)  sqrt(2) ]
          (%i3) L : matrix ([sqrt(3), 0], [0, sqrt(5)]);
                                [ sqrt(3)     0    ]
          (%o3)                 [                  ]
                                [    0     sqrt(5) ]
          (%i4) M : S . L . transpose (S);
                      [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
                      [ ------- + -------  ------- - ------- ]
                      [    2         2        2         2    ]
          (%o4)       [                                      ]
                      [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
                      [ ------- - -------  ------- + ------- ]
                      [    2         2        2         2    ]
          (%i5) eigens_by_jacobi (M);
          The largest percent change was 0.1454972243679
          The largest percent change was 0.0
          number of sweeps: 2
          number of rotations: 1
          (%o5) [[1.732050807568877, 2.23606797749979],
                                  [  0.70710678118655   0.70710678118655 ]
                                  [                                      ]]
                                  [ - 0.70710678118655  0.70710678118655 ]
          (%i6) float ([[sqrt(3), sqrt(5)], S]);
          (%o6) [[1.732050807568877, 2.23606797749979],
                                  [  0.70710678118655   0.70710678118655 ]
                                  [                                      ]]
                                  [ - 0.70710678118655  0.70710678118655 ]
          (%i7) eigens_by_jacobi (M, bigfloatfield);
          The largest percent change was 1.454972243679028b-1
          The largest percent change was 0.0b0
          number of sweeps: 2
          number of rotations: 1
          (%o7) [[1.732050807568877b0, 2.23606797749979b0],
                          [  7.071067811865475b-1   7.071067811865475b-1 ]
                          [                                              ]]
                          [ - 7.071067811865475b-1  7.071067811865475b-1 ]

 -- Função: get_lu_factors (<x>)

     Quando '<x> = lu_factor (<A>)', então 'get_lu_factors' retorna uma
     lista da forma '[P, L, U]', onde <P> é uma matriz de permutação,
     <L> é triangular baixa com a diagonal preenchida com a unidade, e
     <U> é triangular alta, e '<A> = <P> <L> <U>'.

 -- Função: hankel (<col>)
 -- Função: hankel (<col>, <lin>)

     Retorna uma matriz de Hankel <H>.  A primeira coluna de <H> é
     <col>; excepto para a primeira entrada, a última linha de <H> é
     <lin>.  O valor padrão para <lin> é o vector nulo com o mesmo
     comprimento que <col>.

 -- Função: hessian (<f>,<vars>)

     Retorna a matriz hessiana de <f> com relação às variáveis na lista
     <vars>.  As entradas <i>,<j> da matriz hessiana são <diff(f
     vars[i],1,vars[j],1)>.

 -- Função: hilbert_matrix (<n>)

     Retorna the <n> by <n> matriz de Hilbert.  Quando <n> não for um
     inteiro positivo, emite uma mensagem de erro.

 -- Função: identfor (<M>)
 -- Função: identfor (<M>, <corpo>)

     Retorna uma matriz identidade que tem o mesmo tamanho que a matriz
     <M>.  As entradas de diagonal da matriz identidade são a identidade
     multiplicativa do corpo <corpo>; o padrão para <corpo> é
     <generalring>.

     O primeiro argumento <M> pode ser uma matriz quadrada ou um não
     matriz.  Quando <M> for uma matriz, cada entrada de <M> pode ser
     uma matriz quadrada - dessa forma <M> pode ser uma matriz de bloco
     do Maxima.  A matriz pode ser de bloco para qualquer (finita)
     quantidade de níveis.

     Veja também 'zerofor'

 -- Função: invert_by_lu (<M>, <(rng generalring)>)

     Inverte a matriz <M> através de factorização linear alta (LU). A
     factorização LU é concluída usando o anel <rng>.

 -- Função: kronecker_product (<A>, <B>)

     Retorna o produto de Kronecker das matrizes <A> e <B>.

 -- Função: listp (<e>, <p>)
 -- Função: listp (<e>)

     Recebendo um argumento opcional <p>, retorna 'true' se <e> for uma
     lista do Maxima e <p> avalia para 'true' para elemento da lista.
     Quando 'listp' não recebe o argumento opcional, retorna 'true' se
     <e> for uma lista do Maxima.  em todos os outros casos, retorna
     'false'.

 -- Função: locate_matrix_entry (<M>, <r_1>, <c_1>, <r_2>, <c_2>, <f>,
          <rel>)

     O primeiro argumento deve ser uma matriz; os argumentos que vão de
     <r_1> até <c_2> determinam um sub-matriz de <M> que consiste de
     linhas que vão de <r_1> até <r_2> e colunas que vão de <c_1> até
     <c_2>.

     Encontra uma entrada na sub-matriz <M> que satisfaz alguma
     propriedade.  Existem três casos:

     (1) '<rel> = 'bool' e <f> um predicado:

     Examina a sub-matriz da esquerda para a direita e de cima para
     baixo, e retorna o índice da primeira entrada que satisfizer o
     predicado <f>.  Se nenhuma entrada da matriz satisfizer o predicado
     <f>, retorna 'false'.

     (2) '<rel> = 'max' e <f> avaliar para um número real:

     Examina a sub-matriz procurando por uma entrada que maximize <f>.
     Retorna retorna o índice da entrada maximizada.

     (3) '<rel> = 'min' e <f> avaliar para um número real:

     Examina a sub-matriz procurando por uma entrada que minimize <f>.
     Retorna o índice de uma entrada minimizada.

 -- Função: lu_backsub (<M>, <b>)

     Quando '<M> = lu_factor (<A>, <corpo>)', então 'lu_backsub (<M>,
     <b>)' resolve o sistema linear '<A> <x> = <b>'.

 -- Função: lu_factor (<M>, <corpo>)

     Retorna uma lista da forma '[<LU>, <perm>, <corpo>]', ou da forma
     '[<LU>, <perm>, <cmp>, <baixo-cnd> <alto-cnd>]', onde

     (1) A matriz <LU> contéa factorização de <M> na forma enpacotada.
     Forma empacotada significa três coisas: Primeiro, as linhas de <LU>
     são permutadas confirme a lista <perm>.  Se, por exemplo, <perm>
     for a lista list '[3,2,1]', a primeira linha actual da factorização
     <LU> será a terceira linha da matriz <LU>.  Segundo, o factor
     triangular baixo de m é a parte triangular baixa de <LU> com as
     entradas de diagonal todas substituídas pela unidade.  Terceiro, o
     factor triangular alto de <M> é a parte triangular alta de <LU>.

     (2) Quando o corpo for ou 'floatfield' ou 'complexfield', os
     números <baixo-cnd> e <alto-cnd> serão associados baixo e alto para
     o número condicional de norma infinita de <M>.  Para todos os
     corpos (fields), o número condicional de norma infinita não pode
     ser estimado; para tais corpos, 'lu_factor' retorna uma lista com
     dois itens.  Ambos o baixo e o alto associado podem diferir de seus
     verdadeiros valores de factores arbitráriamente grandes.  (Veja
     também 'mat_cond'.)

     O argumento <M> deve ser a matriz quadrada.

     O argumento opcional <cmp> deve ser um símbolo que determine um
     anel ou corpo.  Os corpos e anéis predefinidos são:

     (a) 'generalring' - o anel de expressões do Maxima, (b)
     'floatfield' - o corpo dos números em ponto flutuante do tipo de
     precisão dupla, (c) 'complexfield' - o corpo dos números complexos
     em ponto flutuante do tipo de precisão dupla, (d) 'crering' - o
     anel das expressões racionais canónicas (CRE) do Maxima, (e)
     'rationalfield' - o corpo dos números racionais, (f) 'runningerror'
     - rastro de todos os erros de arredondamento de números em ponto
     flutuante, (g) 'noncommutingring' - o anel de expressões do Maxima
     onde multiplicação for o operador ponto não comutativo.

     Quando o corpo for 'floatfield', 'complexfield', ou 'runningerror',
     o algoritmo usa pivotagem parcial; para todos os outros corpos,
     linhas são comutadas somente quando necessário para evitar um pivô
     nulo.

     A adição aritmética em ponto flutuante não é associativa, então o
     significado de 'corpo' difere da definição matemática.

     Um membro do corpo 'runningerror' é uma lista do Máxima de dois
     membros da forma '[x,n]',onde <x> é um número em onto flutuante e
     'n' é um inteiro.  A diferença relativa entre o valor de
     'verdadeiro' de 'x' e 'x' é aproximadamente associado pelo épsilon
     da máquina vezes 'n'.  O erro de execução associado arrasta alguns
     termos da ordem do quadrado do épsilon da máquina.

     Não existe interface de utilizador definida um novo anel.  Um
     utilizador que estiver familiazrizado com o Lisp Comum está apto
     para definir um novo corpo.  Para fazer isso, um utilizador deve
     definir funções para as operações aritméticas e funções para
     conversão para a representação de corpo do Máxima e vice-versa.
     Adicionalmente, para corpos ordenados (onde a pivotagem parcial
     será usada), um uduário deve definir funções para módulo e para
     comparar membros do corpo.  Após isso tudo que resta é definir uma
     estrutura de Lisp Comum 'mring'.  O ficheiro 'mring' tem muitos
     exemplos.

     Para calcular a factorização, a primeira tarefa é converter cada
     entrada de matriz para um elemento do corpo indicado.  Quando a
     cnversão não for possível, a factorização encerra com uma mensagem
     de erro.  Elementos do corpo não precisam ser expressões do Maxima.
     Elementos do 'complexfield', por exemplo, são números complexos do
     Lisp Comum.  Dessa forma após calcular a factorização, como
     entradas da matriz devem ser convertidas para expressões do Maxima.

     Veja também 'get_lu_factors'.

     Exemplos:
          (%i1) load (linearalgebra);
          Warning - you are redefining the Maxima function require_list
          Warning - you are redefining the Maxima function matrix_size
          Warning - you are redefining the Maxima function rank
          (%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
          (%i2) w[i,j] := random (1.0) + %i * random (1.0);
          (%o2)          w     := random(1.) + %i random(1.)
                          i, j
          (%i3) showtime : true$
          Evaluation took 0.00 seconds (0.00 elapsed)
          (%i4) M : genmatrix (w, 100, 100)$
          Evaluation took 7.40 seconds (8.23 elapsed)
          (%i5) lu_factor (M, complexfield)$
          Evaluation took 28.71 seconds (35.00 elapsed)
          (%i6) lu_factor (M, generalring)$
          Evaluation took 109.24 seconds (152.10 elapsed)
          (%i7) showtime : false$

          (%i8) M : matrix ([1 - z, 3], [3, 8 - z]);
                                  [ 1 - z    3   ]
          (%o8)                   [              ]
                                  [   3    8 - z ]
          (%i9) lu_factor (M, generalring);
                         [ 1 - z         3        ]
                         [                        ]
          (%o9)         [[   3            9       ], [1, 2]]
                         [ -----  - z - ----- + 8 ]
                         [ 1 - z        1 - z     ]
          (%i10) get_lu_factors (%);
                            [   1    0 ]  [ 1 - z         3        ]
                  [ 1  0 ]  [          ]  [                        ]
          (%o10) [[      ], [   3      ], [                9       ]]
                  [ 0  1 ]  [ -----  1 ]  [   0    - z - ----- + 8 ]
                            [ 1 - z    ]  [              1 - z     ]
          (%i11) %[1] . %[2] . %[3];
                                  [ 1 - z    3   ]
          (%o11)                  [              ]
                                  [   3    8 - z ]

 -- Função: mat_cond (<M>, 1)
 -- Função: mat_cond (<M>, inf)

     Retorna o número condiciona da norma de ordem <p> da matriz <m>.
     Os valores permitidos para <p> são 1 e <inf>.  Essa função utiliza
     a factorização linear alta para inverter a matriz <m>.  Dessa forma
     o tempode execução para 'mat_cond' é proporcional ao cubo do
     tamanho da matriz; 'lu_factor' determina as associaçãoes baixa e
     alta para o número de condição de norma infinita em tempo
     proporcional ao quadrado do tamanho da matriz.

 -- Função: mat_norm (<M>, 1)
 -- Função: mat_norm (<M>, inf)
 -- Função: mat_norm (<M>, frobenius)

     Retorna a matriz de norma <p> da matriz <M>.  Os valores permitidos
     para <p> são 1, 'inf', e 'frobenius' (a norma da matriz de
     Frobenius).  A matriz <M> pode ser uma matriz não de bloco.

 -- Função: matrixp (<e>, <p>)
 -- Função: matrixp (<e>)

     Fornecendo um argumento opcional <p>, 'matrixp' retorna 'true' se
     <e> for uma matriz e <p> avaliar para 'true' para todo elemento da
     matriz.  Quando a 'matrixp' não for fornecido umargumento opcional,
     retorna 'true' se 'e' for uma matriz.  em todos os outros casos,
     retorna 'false'.

     Veja também 'blockmatrixp'

 -- Função: matrix_size (<M>)

     Retorna uma lista com dois elementos que fornecem o número de
     linhas e colunas, respectivamente da matriz <M>.

 -- Função: mat_fullunblocker (<M>)

     Se <M> for uma matriz de bloco, expande todos os blocos da matriz
     em todos os níveis.  Se <M> for uma matriz, retorna <M>; de outra
     forma, emite uma mensagem de erro.

 -- Função: mat_trace (<M>)

     Retorna o traço da matriz <M>.  Se <M> não for uma matriz, retorna
     uma forma substantiva.  Quando <M> for uma matriz de bloco,
     'mat_trace(M)' retorna o mesmo valor retornado por
     'mat_trace(mat_unblocker(m))'.

 -- Função: mat_unblocker (<M>)

     Se <M> for uma matriz de bloco, 'mat_unbloker' desfaz o bloco de
     <M> um nível.  Se <M> for uma matriz, 'mat_unblocker (M)' retorna
     <M>; de outra forma, emite uma mensagem de erro.

     Dessa forma se cada entrada de <M> for matriz, 'mat_unblocker (M)'
     retorna uma matriz "desblocada", mas se cada entrada de <M> for uma
     matriz de bloco, 'mat_unblocker (M)' retorna uma matriz de bloco
     com um nível de bloco a menos.

     Se usar matrizes de bloco, muito provavelmente irá querer escolher
     'matrix_element_mult' para '"."' e 'matrix_element_transpose' para
     ''transpose'.  Veja também 'mat_fullunblocker'.

     Exemplo:

          (%i1) load (linearalgebra);
          Warning - you are redefining the Maxima function require_list
          Warning - you are redefining the Maxima function matrix_size
          Warning - you are redefining the Maxima function rank
          (%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
          (%i2) A : matrix ([1, 2], [3, 4]);
                                      [ 1  2 ]
          (%o2)                       [      ]
                                      [ 3  4 ]
          (%i3) B : matrix ([7, 8], [9, 10]);
                                      [ 7  8  ]
          (%o3)                       [       ]
                                      [ 9  10 ]
          (%i4) matrix ([A, B]);
                               [ [ 1  2 ]  [ 7  8  ] ]
          (%o4)                [ [      ]  [       ] ]
                               [ [ 3  4 ]  [ 9  10 ] ]
          (%i5) mat_unblocker (%);
                                   [ 1  2  7  8  ]
          (%o5)                    [             ]
                                   [ 3  4  9  10 ]

 -- Função: nonnegintegerp (<n>)

     Retorna 'true' se e somente se '<n> >= 0' e <n> for um inteiro.

 -- Função: nullspace (<M>)

     Se <M> for uma matriz, retorna 'span (v_1, ..., v_n)', onde o
     conjunto '{v_1, ..., v_n}' é uma base para o espaço nulo de <M>.  A
     diferença entre o maior elemento e o menor elemento do conjunto
     vazio é '{0}'.  Dessa forma, quando o espaço nulo tiver somente um
     membro, retorna 'span ()'.

 -- Função: nullity (<M>)

     Se <M> for uma matriz, retorna a dimensão do espaço nulo de <M>.

 -- Função: orthogonal_complement (<v_1>, ..., <v_n>)

     Retorna 'span (u_1, ..., u_m)', onde o conjunto '{u_1, ..., u_m}' é
     uma base para o complemento ortogonal do conjunto '(v_1, ...,
     v_n)'.

     Cada vector no intervalo de <v_1> até <v_n> deve ser um vector
     coluna.

 -- Função: polynomialp (<p>, <L>, <coeffp>, <exponp>)
 -- Função: polynomialp (<p>, <L>, <coeffp>)
 -- Função: polynomialp (<p>, <L>)

     Retorna 'true' se <p> for um polinómio nas variáveis da lista <L>,
     O predicado <coeffp> deve avaliar para 'true' para cada
     coeficiente, e o predicado <exponp> deve avaliar para 'true' para
     todos os expoentes das variáveis na lista <L>.  Se quiser usar um
     valor personalizado para <exponp>, deverá fornecer <coeffp> com um
     valor mesmo se quiser o valor padrão para <coeffp>.

     'polynomialp (<p>, <L>, <coeffp>)' é equivalente a 'polynomialp
     (<p>, <L>, <coeffp>, 'nonnegintegerp)'.

     'polynomialp (<p>, <L>)' é equivalente a 'polynomialp (<p>, L<,>
     'constantp, 'nonnegintegerp)'.

     O polinómio não precisa ser expandido:

          (%i1) load (linearalgebra);
          Warning - you are redefining the Maxima function require_list
          Warning - you are redefining the Maxima function matrix_size
          Warning - you are redefining the Maxima function rank
          (%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
          (%i2) polynomialp ((x + 1)*(x + 2), [x]);
          (%o2)                         true
          (%i3) polynomialp ((x + 1)*(x + 2)^a, [x]);
          (%o3)                         false

     Um exemplo usando um valor personalizado para 'coeffp' e para
     'exponp':

          (%i1) load (linearalgebra);
          Warning - you are redefining the Maxima function require_list
          Warning - you are redefining the Maxima function matrix_size
          Warning - you are redefining the Maxima function rank
          (%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
          (%i2) polynomialp ((x + 1)*(x + 2)^(3/2), [x], numberp, numberp);
          (%o2)                         true
          (%i3) polynomialp ((x^(1/2) + 1)*(x + 2)^(3/2), [x], numberp, numberp);
          (%o3)                         true

     Polinómios com duas variáveis:

          (%i1) load (linearalgebra);
          Warning - you are redefining the Maxima function require_list
          Warning - you are redefining the Maxima function matrix_size
          Warning - you are redefining the Maxima function rank
          (%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
          (%i2) polynomialp (x^2 + 5*x*y + y^2, [x]);
          (%o2)                         false
          (%i3) polynomialp (x^2 + 5*x*y + y^2, [x, y]);
          (%o3)                         true

 -- Função: polytocompanion (<p>, <x>)

     Se <p> for um polinómio em <x>, retorna a atriz companheira de <p>.
     Para um polinómio mônico <p> de grau <n>, temos '<p> = (-1)^<n>
     charpoly (polytocompanion (<p>, <x>))'.

     Quando <p> não for um polinómio em <x>, emite uma mensagem de erro.

 -- Função: ptriangularize (<M>, <v>)

     Se <M> for uma matriz onde cada entrada dessa matriz for um
     polinómio em <v>, retorna a matriz <M2> tal que

     (1) <M2> é triangular alta,

     (2) '<M2> = <E_n> ... <E_1> <M>', onde os elemetnos de <E_1> a
     <E_n> são matrizes elementares cujas entrada são polinómios em <v>,

     (3) '|det (<M>)| = |det (<M2>)|',

     Nota: Essa função não verifica se toda entrada é um polinómio em
     <v>.

 -- Função: rowop (<M>, <i>, <j>, <theta>)

     Se <M> for uma matriz, retorna a matriz que resulta de se fazer a
     operação de linha 'R_i <- R_i - theta * R_j'.  Se <M> não tiver uma
     linha <i> ou <j>, emite uma mensagem de erro.

 -- Função: rank (<M>)

     Retorna o ranque daquela matriz <M>.  O rank é a dimensão do espaço
     coluna.  Exemplo:
          (%i1) load (linearalgebra)$
          WARNING: DEFUN/DEFMACRO: redefining function $COPY in
                   /share/maxima/5.11.0/share/linearalgebra/linalg-utilities.lisp,
                   was defined in
                   /maxima-5.11.0/src/binary-clisp/comm2.fas
          (%i2) rank(matrix([1,2],[2,4]));
          (%o2)                                  1
          (%i3) rank(matrix([1,b],[c,d]));
          Proviso:  {d - b c # 0}
          (%o3)                                  2

 -- Função: rowswap (<M>, <i>, <j>)

     Se <M> for uma matriz, permuta as linha <i> e <j>.  Se <M> não
     tiver uma linha <i> ou <j>, emite uma mensagem de erro.

 -- Função: toeplitz (<col>)
 -- Função: toeplitz (<col>, <lin>)

     Retorna uma matriz de Toeplitz <T>.  a primeira coluna de <T> é
     <col>; excepto para a primeira entrada, a primeira linha de <T> é
     <lin>.  O padrão para <lin> é o conjugado complexo de <col>.
     Exemplo:
          (%i1) load(linearalgebra)$

          (%i2)  toeplitz([1,2,3],[x,y,z]);

                                            [ 1  y  z ]
                                            [         ]
          (%o2)                             [ 2  1  y ]
                                            [         ]
                                            [ 3  2  1 ]
          (%i3)  toeplitz([1,1+%i]);

                                        [   1     1 - %I ]
          (%o3)                         [                ]
                                        [ %I + 1    1    ]

 -- Função: vandermonde_matrix ([<x_1>, ..., <x_n>])

     Retorna uma matriz <n> por <n> cuja <i>-ésima linha é '[1, <x_i>,
     <x_i>^2, ... <x_i>^(<n>-1)]'.

 -- Função: zerofor (<M>)
 -- Função: zerofor (<M>, <fld>)

     Retorna uma matriz zero que tem o mesmo tamanho da matriz <M>.
     Toda entrada da matriz zero é a identidade aditiva do anel <fld>; o
     valor padrão para <fld> é <generalring>.

     O primeiro argumento <M> pode ser uma matriz quadrada ou uma não
     matriz.  Quando <M> for uma matriz, cada entrada de <M> pode ser
     uma matriz quadrada - dessa forma <M> pode ser uma matriz de bloco
     do Maxima.  A matriz pode ser de bloco para qualquer nível
     (finito).

     Veja também 'identfor'

 -- Função: zeromatrixp (<M>)

     Se <M> não for uma matriz de bloco, retorna 'true' se 'is (equal
     (<e>, 0))' for verdadeiro para cada elemento <e> da matriz <M>.  Se
     <M> for uma matriz de bloco, retorna 'true' se 'zeromatrixp'
     avaliar para 'true' para cada elemento de <e>.


File: maxima.info,  Node: lsquares,  Next: makeOrders,  Prev: linearalgebra,  Up: Top

56 lsquares
***********

/lsquares.texi/1.1/Mon Feb 27 22:09:17 2006//
* Menu:

* Definições para lsquares::


File: maxima.info,  Node: Definições para lsquares,  Prev: lsquares,  Up: lsquares

56.1 Definições para lsquares
=============================

 -- Variável global: DETCOEF

     Essa variável é usada pelas funções 'lsquares' e 'plsquares' para
     armazenar o Coeficiente de Determinação que mede o melhor ajuste.
     Esse intervalo vai de 0 (nenhuma correlação) a 1 (correlação
     exacta).

     Quando 'plsquares' for chamada com uma lista de variáveis
     independentes, <DETCOEF> é escolhida para uma lista de Coeficientes
     de Determinação.  Veja 'plsquares' para detalhes.

     Veja também 'lsquares'.

 -- Função: lsquares (<Mat>,<VarList>,<equação>,<ParamList>)
 -- Função: lsquares
          (<Mat>,<VarList>,<equação>,<ParamList>,<EsperadosList>)
     Ajuste múltiplo de equações não lineares de uma tabela de dados
     pelo método dos "mínimos quadrados".  <Mat> é uma matriz contendo
     os dados, <VarList> é uma lista de nomes de variáveis (um para cada
     coluna de <Mat>), <equação> é a equação a ser ajustada (essa
     equação deve estar na forma: 'depvar=f(indepvari,..., paramj,...)',
     'g(depvar)=f(indepvari,..., paramj,...)' ou na forma 'g(depvar,
     paramk,...)=f(indepvari,..., paramj,...)'), <ParamList> é a lista
     de parâmetros para obter, e <EsperadosList> é uma lista opcional de
     aproximações iniciais para os parâmetros; quando esse último
     argumento estiver presente, 'mnewton' é usado em lugar de 'solve'
     com o objectivo de pegar os parâmetros.

     A equação pode ser completamente não linear com relação às
     variáveis independentes e à variável dependente.  Com o objectivo
     de usar 'solve()', as equações devem ser lineares ou polinomiais
     com relação aos parâmetros.  Equações como 'y=a*b^x+c' podem ser
     ajustadas para '[a,b,c]' com 'solve' se os valores de 'x' forem
     inteiros positivos pequenos e existirem poucos dados (veja o
     exemplo em lsquares.dem).  'mnewton' permite ajustar uma equação
     não linear com relação aos parâmetros, mas um bom conjunto de
     aproximações iniciais deve ser fornecido.

     Se possível, a equação ajustada é retornada.  Se existir mais de
     uma solução, uma lista de equações é retornada.  O Coeficiente de
     Determinação é mostrado para informar sobre o melhor ajuste, de 0
     (nenhuma correlação) a 1 (correlação exacta).  Esse valor é também
     armazenado na variável global <DETCOEF>.

     Exemplos usando 'solve':
          (%i1) load("lsquares")$

          (%i2) lsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                         [x,y,z], z=a*x*y+b*x+c*y+d, [a,b,c,d]);
                Determination Coefficient = 1.0
                              x y + 23 y - 29 x - 19
          (%o2)           z = ----------------------
                                        6
          (%i3) lsquares(matrix([0,0],[1,0],[2,0],[3,8],[4,44]),
                         [n,p], p=a4*n^4+a3*n^3+a2*n^2+a1*n+a0,
                   [a0,a1,a2,a3,a4]);
                Determination Coefficient = 1.0
                               4       3      2
                            3 n  - 10 n  + 9 n  - 2 n
          (%o3)         p = -------------------------
                                        6
          (%i4) lsquares(matrix([1,7],[2,13],[3,25]),
                         [x,y], (y+c)^2=a*x+b, [a,b,c]);
                Determination Coefficient = 1.0
          (%o4) [y = 28 - sqrt(657 - 216 x),
                                          y = sqrt(657 - 216 x) + 28]
          (%i5) lsquares(matrix([1,7],[2,13],[3,25],[4,49]),
                         [x,y], y=a*b^x+c, [a,b,c]);
                Determination Coefficient = 1.0
                                        x
          (%o5)                  y = 3 2  + 1

     Exemplos usando 'mnewton':
          (%i6) load("lsquares")$

          (%i7) lsquares(matrix([1.1,7.1],[2.1,13.1],[3.1,25.1],[4.1,49.1]),
                         [x,y], y=a*b^x+c, [a,b,c], [5,5,5]);
                                                       x
          (%o7) y = 2.799098974610482 1.999999999999991
                                                  + 1.099999999999874
          (%i8) lsquares(matrix([1.1,4.1],[4.1,7.1],[9.1,10.1],[16.1,13.1]),
                         [x,y], y=a*x^b+c, [a,b,c], [4,1,2]);
                                       .4878659755898127
          (%o8) y = 3.177315891123101 x
                                                  + .7723843491402264
          (%i9) lsquares(matrix([0,2,4],[3,3,5],[8,6,6]),
                        [m,n,y], y=(A*m+B*n)^(1/3)+C, [A,B,C], [3,3,3]);
                                                               1/3
          (%o9) y = (3.999999999999862 n + 4.999999999999359 m)
                                                   + 2.00000000000012

     Para usar essa função escreva primeiro 'load("lsquares")'.  Veja
     também 'DETCOEF' e 'mnewton'.

 -- Função: plsquares (<Mat>,<VarList>,<depvars>)
 -- Função: plsquares (<Mat>,<VarList>,<depvars>,<maxexpon>)
 -- Função: plsquares (<Mat>,<VarList>,<depvars>,<maxexpon>,<maxdegree>)
     Ajuste de polinómios de várias variáveis de uma tabela de dados
     pelo método dos "mínimos quadrados".  <Mat> é uma matriz contendo
     os dados, <VarList> é uma lista de nomes de variáveis (um nome para
     cada coluna de Mat, mas use "-" em lugar de nomes de variáveis para
     colunas de Mat), <depvars> é o nome de uma variável dependente ou
     uma lista com um ou mais nomes de variáveis dependentes (cujos
     nomes podem estar em <VarList>), <maxexpon> é o expoente máximo
     opcional para cada variável independente (1 por padrão), e
     <maxdegree> é o argumento opcional grau máximo do polinómio
     (<maxexpon> por padrão); note que a soma dos expoentes de cada
     termo deve ser menor ou igual a <maxdegree>, e se 'maxdgree = 0'
     então nenhum limite é aplicado.

     Se <depvars> é o nome de uma variável dependente (fora de uma
     lista), 'plsquares' retorna o polinómio ajustado.  Se <depvars> for
     uma lista de uma ou mais variáveis dependentes, 'plsquares' retorna
     uma lista com o(s) polinómio(s) ajustado(s).  Os Coeficientes de
     Determinação são mostrados com o objectivo de informar sobre o
     melhor do ajuste, cujo intervalo vai de 0 (nenhuma correlação) a 1
     (correlação exacta).  Esses valores são também armazenados na
     variável global <DETCOEF> (uma lista se <depvars> for tambn'uma
     lista).

     Um simples exemplo de ajuste linear de várias variáveis:
          (%i1) load("plsquares")$

          (%i2) plsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                          [x,y,z],z);
               Determination Coefficient for z = .9897039897039897
                                 11 y - 9 x - 14
          (%o2)              z = ---------------
                                        3

     O mesmo exemplo sem restrições de grau:
          (%i3) plsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                          [x,y,z],z,1,0);
               Determination Coefficient for z = 1.0
                              x y + 23 y - 29 x - 19
          (%o3)           z = ----------------------
                                        6

     Quantas diagonais possui um polígono de N lados?  Que grau
     polinomial deverá ser usado?
          (%i4) plsquares(matrix([3,0],[4,2],[5,5],[6,9],[7,14],[8,20]),
                          [N,diagonais],diagonais,5);
               Determination Coefficient for diagonais = 1.0
                                          2
                                         N  - 3 N
          (%o4)              diagonais = --------
                                            2
          (%i5) ev(%, N=9);   /* Testando para um polígono de 9 lados - o eneágono */
          (%o5)                 diagonals = 27

     De quantas formas dispomos para colocar duas raínhas sem que elas
     estejam ameaçadas num tabuleiro de xadrez n x n ?
          (%i6) plsquares(matrix([0,0],[1,0],[2,0],[3,8],[4,44]),
                          [n,posicoes],[posicoes],4);
               Determination Coefficient for [posicoes] = [1.0]
                                   4       3      2
                                3 n  - 10 n  + 9 n  - 2 n
          (%o6)    [posicoes  = -------------------------]
                                            6
          (%i7) ev(%[1], n=8); /* Testando para um tabuleiro de (8 x 8) */
          (%o7)                posicoes = 1288

     Um exemplo com seis variáveis dependentes:
          (%i8) mtrx:matrix([0,0,0,0,0,1,1,1],[0,1,0,1,1,1,0,0],
                            [1,0,0,1,1,1,0,0],[1,1,1,1,0,0,0,1])$
          (%i8) plsquares(mtrx,[a,b,_And,_Or,_Xor,_Nand,_Nor,_Nxor],
                               [_And,_Or,_Xor,_Nand,_Nor,_Nxor],1,0);
                Determination Coefficient for
          [_And, _Or, _Xor, _Nand, _Nor, _Nxor] =
          [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
          (%o2) [_And = a b, _Or = - a b + b + a,
          _Xor = - 2 a b + b + a, _Nand = 1 - a b,
          _Nor = a b - b - a + 1, _Nxor = 2 a b - b - a + 1]

     Para usar essa função escreva primeiramente 'load("lsquares")'.


File: maxima.info,  Node: makeOrders,  Next: mnewton,  Prev: lsquares,  Up: Top

57 makeOrders
*************

* Menu:

* Definições para makeOrders::


File: maxima.info,  Node: Definições para makeOrders,  Prev: makeOrders,  Up: makeOrders

57.1 Definições para makeOrders
===============================

 -- Função: makeOrders (<indvarlist>,<orderlist>)
     Retorna uma lista de todos os expoentes para um polinómio acima de
     e incluindo os argumentos.

          (%i1) load("makeOrders")$

          (%i2) makeOrders([a,b],[2,3]);
          (%o2) [[0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 1],
                      [1, 2], [1, 3], [2, 0], [2, 1], [2, 2], [2, 3]]
          (%i3) expand((1+a+a^2)*(1+b+b^2+b^3));
                 2  3      3    3    2  2      2    2    2
          (%o3) a  b  + a b  + b  + a  b  + a b  + b  + a  b + a b
                                                            2
                                                     + b + a  + a + 1
     onde '[0, 1]' está associado ao termo b e '[2, 3]' está associado
     ao termo a^2 b^3.

     Para usar essa função escreva primeiro 'load("makeOrders")'.


File: maxima.info,  Node: mnewton,  Next: numericalio,  Prev: makeOrders,  Up: Top

58 mnewton
**********

* Menu:

* Definições para mnewton::


File: maxima.info,  Node: Definições para mnewton,  Prev: mnewton,  Up: mnewton

58.1 Definições para mnewton
============================

 -- Variável de opção: newtonepsilon
     Valor por omissão: '10.0^(-fpprec/2)'

     Precisão para determinar quando a função 'mnewton' convergiu em
     direção à solução.

     Veja também 'mnewton'.

 -- Variável de opção: newtonmaxiter
     Valor por omissão: '50'

     Número máximo de iterações que para a função 'mnewton' caso essa
     função não seja convergente ou se convergir muito lentamente.

     Veja também 'mnewton'.

 -- Função: mnewton (<FuncList>,<VarList>,<GuessList>)
     Solução de multiplas funções não lineares usando o método de
     Newton.  <FuncList> é a lista de funções a serem resolvidas,
     <VarList> é a lista dos nomes de variáveis, e <GuessList> é a lista
     de aproximações iniciais.

     A solução é retornada no mesmo formato retornado pela função
     'solve()'.  Caso a solução não seja encontrada, '[]' é retornado.

     Essa função é controlada através das variáveis globais
     'newtonepsilon' e 'newtonmaxiter'.

          (%i1) load("mnewton")$

          (%i2) mnewton([x1+3*log(x1)-x2^2, 2*x1^2-x1*x2-5*x1+1],
                        [x1, x2], [5, 5]);
          (%o2) [[x1 = 3.756834008012769, x2 = 2.779849592817897]]
          (%i3) mnewton([2*a^a-5],[a],[1]);
          (%o3)             [[a = 1.70927556786144]]
          (%i4) mnewton([2*3^u-v/u-5, u+2^v-4], [u, v], [2, 2]);
          (%o4) [[u = 1.066618389595407, v = 1.552564766841786]]

     Para usar essa função primeiro escreva 'load("mnewton")'.  Veja
     também 'newtonepsilon' e 'newtonmaxiter'.


File: maxima.info,  Node: numericalio,  Next: opsubst,  Prev: mnewton,  Up: Top

59 numericalio
**************

* Menu:

* Introdução a numericalio::
* Definições para numericalio::


File: maxima.info,  Node: Introdução a numericalio,  Next: Definições para numericalio,  Prev: numericalio,  Up: numericalio

59.1 Introdução a numericalio
=============================

'numericalio' é uma colecção de funções para ler e escrever ficheiros de
dados.  O ficheiro é lido completamente para construir um objecto;
leituras parciais não são suportadas.

É assumido que cada item a ler ou escrever é atômico: um número inteiro,
número em ponto flutuante, grande número em ponto flutuante, sequência
de caracteres, ou símbolo, e não um número racional ou um número
complexo ou qualquer outro tipo de expressão não atômica.  Essas funções
podem tentar fazer alguma coisa levemente parecida com expressões não
atômicas, mas os resultados não são especificados aqui e são sujeitos a
mudanças.

Átomos em ambos os ficheiros de entrada e saída possuem o mesmo formato
que em ficheiros de lote do Maxima ou no console interativo.  Em
particular, sequência de caracteres são contidas dentro de aspas duplas,
contrabarra '\' evita qualquer interpretação especial do caractere
seguinte, e o ponto de interrogação '?' é reconhecido no início de um
símbolo para significar um símbolo do Lisp (em oposição a um símbolo do
Maxima).  Nenhum caractere de continuação (para continuar linhas
quebradas) é reconhecido.

<separator_flag> diz que caracteres separa elementos.  <separator_flag>
é um argumento opcional para todas as funções de leitura e escrita.

Para entrada, os valores de <separator_flag> reconhecidos são: 'comma'
para valores separados por vírgula, 'pipe' para valores separados pelo
caractere barra vertical '|', 'semicolon' para valores separados por
ponto e vírgula ';', e 'space' para valores separados pelos caracteres
de espaço e de tabulação.  Se o nome do ficheiro a ser lido/escrito
termina em '.csv' e <separator_flag> não for especificado, 'comma' é
assumido.  Se o nome do ficheiro termina em alguma outra coisa que não
'.csv' e 'separator_flag' não for especificado, 'space' é assumido.

Para saída, os mesmos quatro sinalizadores são reconhecidos como na
entrada, e também 'tab', para valores separados pelo caractere de
tabulaçao.

Em entrada, múltiplos espaços e múltiplas tabulações sucessivas contam
como um separador simples.  Todavia, múltiplas vírgulas, barras
verticais, ou ponto-e-vírgulas são significativos.  Sucessivas vírgulas,
barras verticais, ou ponto-e-vírgulas (com ou sem intercalação de
espaços ou tabulações) são considerados como tendo 'false' entre os
separadores.  Por exemplo, '1234,,Foo' é tratado da mesma forma que
'1234,false,Foo'.  Em saídas, os átomos 'false' são escritos como tais;
uma lista '[1234, false, Foo]' é escrita '1234,false,Foo', e não é
tentado colapsar a saída para '1234,,Foo'.


File: maxima.info,  Node: Definições para numericalio,  Prev: Introdução a numericalio,  Up: numericalio

59.2 Definições para numericalio
================================

 -- Função: read_matrix (<nomeficheiro>)
 -- Função: read_matrix (<nomeficheiro>, <separator_flag>)
     Lê o ficheiro <nomeficheiro> e retorna seu conteúdo completo como
     uma matriz.  Se <separator_flag> não for especificado, o ficheiro é
     assumido como delimitado por espaços em branco.

     'read_matrix' infere o tamanho da matriz dos dados de entrada.
     Cada linha do ficheiro inicia uma linha da matriz.  Se algumas
     linhas possuirem diferentes comprimentos, 'read_matrix' reclama.

 -- Função: read_lisp_array (<nomeficheiro>, <A>)
 -- Função: read_lisp_array (<nomeficheiro>, <A>, <separator_flag>)

     'read_lisp_array' exige que o array seja declarado através de
     'make_array' antes de chamar a função de leitura.  (Isso obviamente
     é necessário para inferir a dimensão do array, que pode ser um
     problema para arrays com múltiplas dimensões.)

     'read_lisp_array' não verifica para ver se o ficheiro de entrada
     está de acordo com as dimensãoes do array; a entrada é lida como
     uma lista monótona, então o array é preenchido usando 'fillarray'.

 -- Função: read_maxima_array (<nomeficheiro>, <A>)
 -- Função: read_maxima_array (<nomeficheiro>, <A>, <separator_flag>)

     'read_maxima_array' requer que o array seja declarado através de
     'array' antes de chamar a função de leitura.  (Isso obviamente é
     necessário para inferir a dimensão do array, que pode ser uma
     hassle para arrays com múltiplas dimensões.)

     'read_maxima_array' não verifica para ver se o ficheiro de entrada
     está de acordo com as dimensãoes do array; a entrada é lida como
     uma lista monótona, então o array é preenchido usando 'fillarray'.

 -- Função: read_hashed_array (<nomeficheiro>, <A>)
 -- Função: read_hashed_array (<nomeficheiro>, <A>, <separator_flag>)

     'read_hashed_array' trata o primeiro item sobre uma linha como uma
     chave hash, e associa o restante da linha (como uma lista) com a
     chava.  Por exemplo, a linha '567 12 17 32 55' é equivalente a
     'A[567]: [12, 17, 32, 55]$'.  Linhas não precisam ter o mesmo
     número de elementos.

 -- Função: read_nested_list (<nomeficheiro>)
 -- Função: read_nested_list (<nomeficheiro>, <separator_flag>)

     'read_nested_list' retorna uma lista que tem uma sublista para cada
     linha de entrada.  Linhas não precisam ter o mesmo número de
     elementos.  Linhas vazias não são ignoradas: uma linha vazia
     retorna uma sublista vazia.

 -- Função: read_list (<nomeficheiro>)
 -- Função: read_list (<nomeficheiro>, <separator_flag>)

     'read_list' lê todas as entradas em uma lista monótona.
     'read_list' ignora o caractere de fim de linha.

 -- Função: write_data (<X>, <nomeficheiro>)
 -- Função: write_data (<object>, <nomeficheiro>, <separator_flag>)

     'write_data' escreve o objecto <X> no ficheiro <nomeficheiro>.

     'write_data' escreve matrizes da forma usual, com uma linha por
     fileira.

     'write_data' escreve arrays declarados do Lisp e do Maxima da forma
     usual, com um caractere de nova linha no final de todo pedaço.
     Pedaços dimensionais muito grandes são separados por meio de novas
     linhas adicionais.

     'write_data' escreve arrays desordenados com uma chave seguida por
     a lista associada sobre cada linha.

     'write_data' escreve a lista seguinte com cada sublista em uma
     linha.

     'write_data' escreve uma lista monótona toda em uma linha.

     Se 'write_data' anexa ao final ou abandona os excessos em seus
     ficheiros de saída é governado através da variável global
     'file_output_append'.


File: maxima.info,  Node: opsubst,  Next: orthopoly,  Prev: numericalio,  Up: Top

60 opsubst
**********

* Menu:

* Definições para  opsubst::


File: maxima.info,  Node: Definições para opsubst,  Prev: opsubst,  Up: opsubst

60.1 Definições para opsubst
============================

 -- Função: opsubst (<f>,<g>,<e>)
 -- Função: opsubst (<g>=<f>,<e>)
 -- Função: opsubst ([<g1>=<f1>,<g2>=<f2>,..., <gn>=<fn>],<e>)
     A função 'opsubst' similar à função 'subst', excepto que 'opsubst'
     somente faz substituições para as operações em uma expressões.  Em
     geral, quando <f> for um operador em uma expressão <e>, substitui
     <g> por <f> na expressão <e>.

     Para determinar o operador, 'opsubst' escolhe 'inflag' para
     verdadeiro ( true ).  Isso significa que 'opsubst' substitui para a
     forma de operador interna, não para a mostrada, na expressão.

     Exemplos:
          (%i1) load (opsubst)$

          (%i2) opsubst(f,g,g(g(x)));
          (%o2)                     f(f(x))
          (%i3) opsubst(f,g,g(g));
          (%o3)                       f(g)
          (%i4) opsubst(f,g[x],g[x](z));
          (%o4)                       f(z)
          (%i5) opsubst(g[x],f, f(z));
          (%o5)                      g (z)
                                      x
          (%i6) opsubst(tan, sin, sin(sin));
          (%o6)                     tan(sin)
          (%i7) opsubst([f=g,g=h],f(x));
          (%o7)                       h(x)

     Internamente, Maxima não usa os operadores de negação unária,
     divisão, ou de subtração; dessa forma:
          (%i8) opsubst("+","-",a-b);
          (%o8)                     a - b
          (%i9) opsubst("f","-",-a);
          (%o9)                      - a
          (%i10) opsubst("^^","/",a/b);
                                       a
          (%o10)                       -
                                       b

     A representação interna de -a*b é *(-1,a,b); dessa forma
          (%i11) opsubst("[","*", -a*b);
          (%o11)                  [- 1, a, b]

     Quando o operador não for um símbolo Maxima, geralmente alguma
     outra função sinalizará um erro:
          (%i12) opsubst(a+b,f, f(x));

          Improper name or value in functional position:
          b + a
           -- an error.  Quitting.  To debug this try debugmode(true);

     Todavia, operadores subscritos são permitidos:
          (%i13) opsubst(g[5],f, f(x));
          (%o13)                     g (x)
                                      5

     Para usar essa função escreva primeiramente 'load("opsubst")'.


File: maxima.info,  Node: orthopoly,  Next: plotdf,  Prev: opsubst,  Up: Top

61 orthopoly
************

* Menu:

* Introdução a polinómios ortogonais::
* Definições para polinómios ortogonais::


File: maxima.info,  Node: Introdução a polinómios ortogonais,  Next: Definições para polinómios ortogonais,  Prev: orthopoly,  Up: orthopoly

61.1 Introdução a polinómios ortogonais
=======================================

'orthopoly' é um pacote para avaliação simbólica e numérica de muitos
tipos de polinómios ortogonais, incluindo polinómios de Chebyshev,
Laguerre, Hermite, Jacobi, Legendre, e ultraesférico (Gegenbauer).
Adicionalmentey, 'orthopoly' inclui suporte funções esféricas segundo o
critério de Bessel, esféricas segundo o critério de Hankel, e funções
harmônica esféricas.

Em sua maior parte, 'orthopoly' segue as convenções de Abramowitz e
Stegun Handbook of Mathematical Functions, Chapter 22 (10th printing,
December 1972); adicionalmente, usamos Gradshteyn e Ryzhik, Table of
Integrals, Series, and Products (1980 corrected and enlarged edition), e
Eugen Merzbacher Quantum Mechanics (2nd edition, 1970).

Barton Willis da University de Nebraska e Kearney (UNK) escreveu o
pacote 'orthopoly' e sua documetação.  O pacote é liberado segundo a
licença pública geral GNU (GPL).

61.1.1 Iniciando com orthopoly
------------------------------

'load (orthopoly)' torna o pacote 'orthopoly' disponível para uso.

Para encontrar o polinómio de Legendre de terceira ordem,

     (%i1) legendre_p (3, x);
                           3             2
                  5 (1 - x)    15 (1 - x)
     (%o1)      - ---------- + ----------- - 6 (1 - x) + 1
                      2             2

Para expressar esse polinómio como uma soma de potências de <x>, aplique
<ratsimp> ou <rat> para o resultado anterior.

     (%i2) [ratsimp (%), rat (%)];
                             3           3
                          5 x  - 3 x  5 x  - 3 x
     (%o2)/R/            [----------, ----------]
                              2           2

Alternativamente, faça o segundo argumento para 'legendre_p' (sua
variável "principal") uma expressão racional canónica (CRE) usando
'rat(x)' em lugar de somente 'x'.

     (%i1) legendre_p (3, rat (x));
                                   3
                                5 x  - 3 x
     (%o1)/R/                   ----------
                                    2

Para avaliação em ponto flutuante, 'orthopoly' usa uma análise de erro
durante a execução para estimar uma associação superior para o erro.
Por exemplo,

     (%i1) jacobi_p (150, 2, 3, 0.2);
     (%o1) interval(- 0.062017037936715, 1.533267919277521E-11)

intervalos possuem a forma 'interval (<c>, <r>)', onde <c> é o centro e
<r> é o raio do intervalo.  Uma vez que Maxima não suporta aritmética
sobre intervalos, em algumas situações, tais como em gráficos, vai
querer suprimir o erro e sair somente com o centro do intervalo.  Para
fazer isso, escolha a variável de opção 'orthopoly_returns_intervals'
para 'false'.

     (%i1) orthopoly_returns_intervals : false;
     (%o1)                         false
     (%i2) jacobi_p (150, 2, 3, 0.2);
     (%o2)                  - 0.062017037936715

Veja a secção *note Avaliação em Ponto Flutuante:: para maiores
informações.

Muitas funções em 'orthopoly' possuem uma propriedade 'gradef'; dessa
forma

     (%i1) diff (hermite (n, x), x);
     (%o1)                     2 n H     (x)
                                    n - 1
     (%i2) diff (gen_laguerre (n, a, x), x);
                   (a)               (a)
                n L   (x) - (n + a) L     (x) unit_step(n)
                   n                 n - 1
     (%o2)      ------------------------------------------
                                    x

A função de um único passo no segundo exemplo previne um erro que
poderia de outra forma surgir através da avaliação de <n> para 0.

     (%i3) ev (%, n = 0);
     (%o3)                           0

A propriedade 'gradef' somente aplica para a variável "principal";
dderivadas com relação a outros argumentos usualmente resultam em uma
mensagem de erro; por exemplo

     (%i1) diff (hermite (n, x), x);
     (%o1)                     2 n H     (x)
                                    n - 1
     (%i2) diff (hermite (n, x), n);

     Maxima doesn't know the derivative of hermite with respect the first argument
      -- an error.  Quitting.  To debug this try debugmode(true);

Geralmente, funções em 'orthopoly' mapeiam sobre listas e matrizes.
Para o mapeamento para avaliação total, as variáveis de opção
'doallmxops' e 'listarith' devem ambas serem 'true' (o valor padrão).
Para ilustrar o mapeamento sobre matrizes, considere

     (%i1) hermite (2, x);
                                          2
     (%o1)                    - 2 (1 - 2 x )
     (%i2) m : matrix ([0, x], [y, 0]);
                                 [ 0  x ]
     (%o2)                       [      ]
                                 [ y  0 ]
     (%i3) hermite (2, m);
                    [                             2  ]
                    [      - 2        - 2 (1 - 2 x ) ]
     (%o3)          [                                ]
                    [             2                  ]
                    [ - 2 (1 - 2 y )       - 2       ]

No segundo exemplo, o elemento 'i, j' do valor é 'hermite (2, m[i,j])';
isso não é o mesmo que calcular '-2 + 4 m . m', como visto no próximo
exemplo.

     (%i4) -2 * matrix ([1, 0], [0, 1]) + 4 * m . m;
                         [ 4 x y - 2      0     ]
     (%o4)               [                      ]
                         [     0      4 x y - 2 ]

Se avaliar uma função em um ponto fora do seu domínio, geralmente
'orthopoly' retorna uma função não avaliada.  Por exemplo,

     (%i1) legendre_p (2/3, x);
     (%o1)                        P   (x)
                                   2/3

'orthopoly' suporta tradução em TeX; 'orthopoly' também faz saídas
bidimensionais em um terminal.

     (%i1) spherical_harmonic (l, m, theta, phi);
                               m
     (%o1)                    Y (theta, phi)
                               l
     (%i2) tex (%);
     $$Y_{l}^{m}\left(\vartheta,\varphi\right)$$
     (%o2)                         false
     (%i3) jacobi_p (n, a, a - b, x/2);
                               (a, a - b) x
     (%o3)                    P          (-)
                               n          2
     (%i4) tex (%);
     $$P_{n}^{\left(a,a-b\right)}\left({{x}\over{2}}\right)$$
     (%o4)                         false

61.1.2 Limitations
------------------

Quando uma expressão envolve muitos polinómios ortogonais com ordens
simbólicas, é possível que a expressão actualmente tenda para zero, e
ainda ocorre também que Maxima estar incapacitado de simplificar essa
expressão para zero.  Se fizer uma divisão por tal quantidade que tende
a zero, poderá ficar em apuros.  Por exemplo, a seguinte expressão tende
para zero para inteiros <n> maiores que 1, e ainda ocorre também que
Maxima está incapacitado de simplificar essa expressão para zero.

     (%i1) (2*n - 1) * legendre_p (n - 1, x) * x - n * legendre_p (n, x) + (1 - n) * legendre_p (n - 2, x);
     (%o1)  (2 n - 1) P     (x) x - n P (x) + (1 - n) P     (x)
                       n - 1           n               n - 2

Para um <n> específico, podemos reduzir a expressão a zero.

     (%i2) ev (% ,n = 10, ratsimp);
     (%o2)                           0

Geralmente, a forma polinomial de um polinómio ortogonal esteja adequada
de forma hostil para avaliaçao em ponto flutuante.  Aqui está um
exemplo.

     (%i1) p : jacobi_p (100, 2, 3, x)$

     (%i2) subst (0.2, x, p);
     (%o2)                3.4442767023833592E+35
     (%i3) jacobi_p (100, 2, 3, 0.2);
     (%o3)  interval(0.18413609135169, 6.8990300925815987E-12)
     (%i4) float(jacobi_p (100, 2, 3, 2/10));
     (%o4)                   0.18413609135169

O verdadeiro valor está em torno de 0.184; ess calculo suporta erro de
cancelamento por extremo subtrativo.Expandindo o polinómio e então
avaliando, fornecendo um melhor resultado.
     (%i5) p : expand(p)$
     (%i6) subst (0.2, x, p);
     (%o6) 0.18413609766122982

Essa não é uma regra geral; expandindo o polinómio não resulta sempre em
expressões que são melhores adaptadas a avaliação numérica.  Com grande
folga, o melhor caminho para fazer avaliação numérica é fazer um ou mais
argumentos da função serem números em ponto flutuante.  Em função disso,
algoritmos especializados em ponto flutuante são usados para avaliação.

A função 'float' do Maxima é até certo ponto indiscriminada; se aplicar
'float' a uma expressão envolvendo um polinómio ortogonal com um grau
simbólico ou um parâmetro de ordem, esses parâmetos (inteiros) podem ser
convertido em números em ponto flutuante; após o que, a expressão não
irá avaliar completamente.  Considere

     (%i1) assoc_legendre_p (n, 1, x);
                                    1
     (%o1)                         P (x)
                                    n
     (%i2) float (%);
                                   1.0
     (%o2)                        P   (x)
                                   n
     (%i3) ev (%, n=2, x=0.9);
                                  1.0
     (%o3)                       P   (0.9)
                                  2

A expressão em (%o3) não irá avaliar para um número em ponto flutuante;
'orthopoly' não reconhece valores em ponto flutuante em lugares onde
deve haver valores inteiros.  Similarmente, avaliação numérica da função
'pochhammer' para ordens que excedam 'pochhammer_max_index' pode ser
perturbador; considere

     (%i1) x :  pochhammer (1, 10), pochhammer_max_index : 5;
     (%o1)                         (1)
                                      10

Aplicando 'float' não avalia <x> para um número em ponto flutuante

     (%i2) float (x);
     (%o2)                       (1.0)
                                      10.0

Para avaliar <x> para um número em ponto flutuante, irá precisar
associar 'pochhammer_max_index' a 11 ou mais e aplicar 'float' a <x>.

     (%i3) float (x), pochhammer_max_index : 11;
     (%o3)                       3628800.0

O valor padrão de 'pochhammer_max_index' é 100; modifique esse valor
após chama 'orthopoly'.

Finalmente, tenha consciência que os livros citados nas referências
adotam diferentes definições de polinómios ortogonais; geralmente
adotamos as convenções citadas nas convenções de Abramowitz e Stegun.

Antes de suspeitar de um erro no pacote 'orthopoly', verifique alguns
casos especiais para determinar se suas definições coincidem com aquelas
usadas por 'orthopoly'.  Definitions muitas vezes diferem por uma
normalização; ocasionalmente, autores utilizam versões "modificadas" das
funções que fazem a família ortogonal sobre um intervalo diferente do
intervalo (-1, 1).  Para definir, por exemplo, um polinómio de Legendre
que é ortogonal a (0, 1), defina

     (%i1) shifted_legendre_p (n, x) := legendre_p (n, 2*x - 1)$

     (%i2) shifted_legendre_p (2, rat (x));
                                 2
     (%o2)/R/                 6 x  - 6 x + 1
     (%i3) legendre_p (2, rat (x));
                                    2
                                 3 x  - 1
     (%o3)/R/                    --------
                                    2

61.1.3 Avaliação em Ponto Flutuante
-----------------------------------

Muitas funções em 'orthopoly' utilizam análise de erro durante a
execução para estimar o erro em avaliações em ponto flutuante; as
exceções são funções de Bessel esféricas e os polinómios associados de
Legendre do segundo tipo.  Para avaliações numéricas, as funções de
Bessel esféricas chamam funções da colecção de programas 'SLATEC'.
Nenhum método especializado é usado para avaliação numérica dos
polinómios associados de Legendre do segundo tipo.

A análise de erro durante a execução ignora erros que são de segunda
ordem ou maior na máquina (também conhecida como perda de algarismos).
A análise de erro durante a execução também ignora alguns poucos outros
tipos de erro.  É possível (embora não provável) que o erro actual
exceda o estimado.

Intervalos possuem a forma 'interval (<c>, <r>)', onde <c> é o centro do
intervalo e <r> é seu raio.  O centro de um intervalo pode sr um número
complexo, e o raio é sempre um número real positivo.

Aqui está um exemplo.

     (%i1) fpprec : 50$

     (%i2) y0 : jacobi_p (100, 2, 3, 0.2);
     (%o2) interval(0.1841360913516871, 6.8990300925815987E-12)
     (%i3) y1 : bfloat (jacobi_p (100, 2, 3, 1/5));
     (%o3) 1.8413609135168563091370224958913493690868904463668b-1

Vamos testar o quanto o erro actual é é menor que o erro estimado

     (%i4) is (abs (part (y0, 1) - y1) < part (y0, 2));
     (%o4)                         true

Realmente, por esse exemplo o erro estimado é um maior que o erro
verdadeiro.

Maxima não suporta aritmética sobre intervalos.

     (%i1) legendre_p (7, 0.1) + legendre_p (8, 0.1);
     (%o1) interval(0.18032072148437508, 3.1477135311021797E-15)
             + interval(- 0.19949294375000004, 3.3769353084291579E-15)

Um utilizador pode definir operadores aritméticos que fazem matemática
de intervalos.  Para definir adição de intervalos, podemos definir

     (%i1) infix ("@+")$

     (%i2) "@+"(x,y) := interval (part (x, 1) + part (y, 1), part (x, 2) + part (y, 2))$

     (%i3) legendre_p (7, 0.1) @+ legendre_p (8, 0.1);
     (%o3) interval(- 0.019172222265624955, 6.5246488395313372E-15)

As rotinas eseciais em ponto flutuante são chamadas quando os argumentos
forem complexos.  Por exemplo,

     (%i1) legendre_p (10, 2 + 3.0*%i);
     (%o1) interval(- 3.876378825E+7 %i - 6.0787748E+7,
                                                1.2089173052721777E-6)

Let's compare this to the true value.

     (%i1) float (expand (legendre_p (10, 2 + 3*%i)));
     (%o1)          - 3.876378825E+7 %i - 6.0787748E+7

Adicionalmente, quando os argumentos forem grandes números em ponto
flutuante, as rotinas especiais de ponto flutuante são chamadas;
todavia, tos grandes números em ponto flutuante são convertidos para
números em ponto flutuante de dupla precisão e o resultado final é
número em ponto flutuante de precisão dupla.

     (%i1) ultraspherical (150, 0.5b0, 0.9b0);
     (%o1) interval(- 0.043009481257265, 3.3750051301228864E-14)

61.1.4 Gráficos e 'orthopoly'
-----------------------------

Para desenhar gráficos de expressões que envolvem polinómios ortogonais,
deverá fazer duas coisas:
  1. Escolher a variável de opção 'orthopoly_returns_intervals' para
     'false',
  2. Colocar apóstrofo em qualquer chamada a funções do pacote
     'orthopoly'.
Se chamadas a funções não receberem apóstrofo, Maxima irá avaliá-las
para polinómios antes de montar o gráfico; consequêntemente, as rotinas
especializadas em ponto flutuante não serão chamadas.  Aqui está um
exemplo de como montar o gráfico de uma expressão que envolve um
polinómio de Legendre.

     (%i1) plot2d ('(legendre_p (5, x)), [x, 0, 1]), orthopoly_returns_intervals : false;
     (%o1)

A expressão completa 'legendre_p (5, x)' recebe apóstrofo; isso é
diferente de apenas colocar apóstrofo no nome da função usando
''legendre_p (5, <x>)'.

61.1.5 Funções Diversas
-----------------------

O pacote 'orthopoly' define o síbolo de Pochhammer e uma função de passo
de unidade.  'orthopoly' utiliza a função delta de Kronecker e a função
de passo de unidade em declarações 'gradef'.

Para converter os símbolos Pochhammer em quocientes da funções gama, use
'makegamma'.

     (%i1) makegamma (pochhammer (x, n));
                               gamma(x + n)
     (%o1)                     ------------
                                 gamma(x)
     (%i2) makegamma (pochhammer (1/2, 1/2));
                                     1
     (%o2)                       ---------
                                 sqrt(%pi)

Derivadas de símbolos de Pochhammer são fornecidas em termos de 'psi'
function.

     (%i1) diff (pochhammer (x, n), x);
     (%o1)             (x)  (psi (x + n) - psi (x))
                          n     0             0
     (%i2) diff (pochhammer (x, n), n);
     (%o2)                   (x)  psi (x + n)
                                n    0

É preciso ser cuidadoso com expressões como (%o1); a diferença das
funções 'psi' possuem polinómios quando '<x> = -1, -2, .., -<n>'.  Esses
polinómios cacelam-se com factores em 'pochhammer (<x>, <n>)' fazendo da
derivada um polinómio de grau '<n> - 1' quando <n> for um inteiro
positivo.

O símbolo de Pochhammer é definido de ordens negativas até sua
representação como um quociente de funções gama.  Considere

     (%i1) q : makegamma (pochhammer (x, n));
                               gamma(x + n)
     (%o1)                     ------------
                                 gamma(x)
     (%i2) sublis ([x=11/3, n= -6], q);
                                    729
     (%o2)                        - ----
                                    2240

Alternativamente, podemos tomar ese resultado directamente.

     (%i1) pochhammer (11/3, -6);
                                    729
     (%o1)                        - ----
                                    2240

A função passo de unidade é contínua à esquerda; dessa forma

     (%i1) [unit_step (-1/10), unit_step (0), unit_step (1/10)];
     (%o1)                       [0, 0, 1]

Se precisar de uma função de degrau unitário que seja ou contínua à
esquerda ou contínua à direita do zero, defina a sua própria função
usando 'signum'; por exemplo,

     (%i1) xunit_step (x) := (1 + signum (x))/2$

     (%i2) [xunit_step (-1/10), xunit_step (0), xunit_step (1/10)];
                                     1
     (%o2)                       [0, -, 1]
                                     2

Não redefina a própria 'unit_step'; alguns código em 'orthopoly'
requerem que a função de passo de unidade seja contínua à esquerda.

61.1.6 Algorítmos
-----------------

Geralmente, 'orthopoly' faz avaliações simbólicas pelo uso de uma
representação hipergeométrica de polinómios ortogonais.  As funções
hipegeométricas são avaliadas usando as funções (não documetadas)
'hypergeo11' e 'hypergeo21'.  As excessões são as funções de Bessel
metade inteiras e a função de Legendre associada de segundo tipo.  As
funções de Bessel metade inteiras são avaliadas usando uma representação
explícita, e a função de Legendre associada de segundo tipo é avaliada
usando recursividade.

Para avaliação em ponto flutuante, nós novamente convertemos muitas
fuções em uma forma hipergeométrica; nós avaliamos as funções
hipergeométricas usando recursividade para frente.  Novamente, as
excessões são as funções de Bessel metade inteiras e a função de
Legendre associada de segundo tipo.  Numericamente, as funções de Bessel
meio inteiras são avaliadas usando o código SLATEC.


File: maxima.info,  Node: Definições para polinómios ortogonais,  Prev: Introdução a polinómios ortogonais,  Up: orthopoly

61.2 Definições para polinómios ortogonais
==========================================

 -- Função: assoc_legendre_p (<n>, <m>, <x>)
     As funções de Legendre associadas de primeiro tipo.

     Referência: Abramowitz e Stegun, equações 22.5.37, página 779,
     8.6.6 (segunda equação), página 334, e 8.2.5, página 333.

 -- Função: assoc_legendre_q (<n>, <m>, <x>)
     A função de Legendre associada de segundo tipo.

     Referência: Abramowitz e Stegun, equação 8.5.3 e 8.1.8.

 -- Função: chebyshev_t (<n>, <x>)
     A função de Chebyshev de primeiro tipo.

     Referência: Abramowitz e Stegun, equação 22.5.47,página 779.

 -- Função: chebyshev_u (<n>, <x>)
     A função de Chebyshev do segundo tipo.

     Referência: Abramowitz e Stegun, equação 22.5.48,página 779.

 -- Função: gen_laguerre (<n>, <a>, <x>)
     O poliômio generalizado de Laguerre.

     Referência: Abramowitz e Stegun, equação 22.5.54,página 780.

 -- Função: hermite (<n>, <x>)
     O polinómio de Hermite.

     Referência: Abramowitz e Stegun, equação 22.5.55,página 780.

 -- Função: intervalp (<e>)
     Retorna 'true' se a entrada for um intervalo e retorna 'false' se
     não for.

 -- Função: jacobi_p (<n>, <a>, <b>, <x>)
     o polinómio de Jacobi.

     Os polinómios de Jacobi são actualmente definidos para todo <a> e
     <b>; todavia, o peso do polinómio de Jacobi '(1 - <x>)^<a> (1 +
     <x>)^<b>' não é integrável para '<a> <= -1' ou '<b> <= -1'.

     Referência: Abramowitz e Stegun, equação 22.5.42,página 779.

 -- Função: laguerre (<n>, <x>)
     O polinómio de Laguerre.

     Referência: Abramowitz e Stegun, equatções 22.5.16 e 22.5.54,página
     780.

 -- Função: legendre_p (<n>, <x>)
     O polinómio de Legendre de primeiro tipo.

     Referência: Abramowitz e Stegun, equações 22.5.50 e 22.5.51,página
     779.

 -- Função: legendre_q (<n>, <x>)
     O polinómio de Legendre de primeiro tipo.

     Referência: Abramowitz e Stegun, equações 8.5.3 e 8.1.8.

 -- Função: orthopoly_recur (<f>, <args>)
     Retorna uma relação recursiva para a família de funções ortogonais
     <f> com argumentos <args>.  A recursividade é com relação ao grau
     do polinómio.

          (%i1) orthopoly_recur (legendre_p, [n, x]);
                          (2 n - 1) P     (x) x + (1 - n) P     (x)
                                     n - 1                 n - 2
          (%o1)   P (x) = -----------------------------------------
                   n                          n

     O segundo argumento a 'orthopoly_recur' deve ser uma lista com o
     número correcto de argumentos para a função <f>; se o número de
     argumentos não for o correcto, Maxima sinaliza com um erro.

          (%i1) orthopoly_recur (jacobi_p, [n, x]);

          Function jacobi_p needs 4 arguments, instead it received 2
           -- an error.  Quitting.  To debug this try debugmode(true);

     Adicionalmente, quando <f> não for o nome de uma das famílias de
     polinómios ortogonais, um erro é sinalizado.

          (%i1) orthopoly_recur (foo, [n, x]);

          A recursion relation for foo isn't known to Maxima
           -- an error.  Quitting.  To debug this try debugmode(true);

 -- Variable: orthopoly_returns_intervals
     Valor por omissão: 'true'

     Quando 'orthopoly_returns_intervals' for 'true', resultados em
     ponto flutuante são retornados na forma 'interval (<c>, <r>)', onde
     <c> é o centro de um intervalo e <r> é seu raio.  O centro pode ser
     um número complexo; nesse caso, o intervalo é um disco no plano
     complexo.

 -- Função: orthopoly_weight (<f>, <args>)

     Retorna uma lista de três elementos; o primeiro elemento é a
     fórmula do peso para a família de polinómios ortogonais <f> com
     argumentos fornecidos pela lista <args>; os segundos e terceiros
     elementos fornecem os pontos finais inferior e superior do
     intervalo de ortogonalidade.  Por exemplo,

          (%i1) w : orthopoly_weight (hermite, [n, x]);
                                      2
                                   - x
          (%o1)                 [%e    , - inf, inf]
          (%i2) integrate (w[1] * hermite (3, x) * hermite (2, x), x, w[2], w[3]);
          (%o2)                           0

     A variável principal de <f> deve ser um símbolo; Se não for, Maxima
     sinaliza com um erro.

 -- Função: pochhammer (<n>, <x>)
     O símbolo de Pochhammer.  Para inteiros não negativos <n> com '<n>
     <= pochhammer_max_index', a expressão 'pochhammer (<x>, <n>)'
     avalia para o produto '<x> (<x> + 1) (<x> + 2) ... (<x> + n - 1)'
     when '<n> > 0' e para 1 quando '<n> = 0'.  Para valores negativos
     de <n>, 'pochhammer (<x>, <n>)' é definido como '(-1)^<n> /
     pochhammer (1 - <x>, -<n>)'.  Dessa forma

          (%i1) pochhammer (x, 3);
          (%o1)                   x (x + 1) (x + 2)
          (%i2) pochhammer (x, -3);
                                           1
          (%o2)               - -----------------------
                                (1 - x) (2 - x) (3 - x)

     Para converter um símbolo de Pochhammer em um quociente de funções
     gama, (veja Abramowitz e Stegun, equação 6.1.22) use 'makegamma';
     por exemplo

          (%i1) makegamma (pochhammer (x, n));
                                    gamma(x + n)
          (%o1)                     ------------
                                      gamma(x)

     Quando <n> exceder 'pochhammer_max_index' ou quando <n> for
     simbólico, 'pochhammer' retorna uma forma substantiva.

          (%i1) pochhammer (x, n);
          (%o1)                         (x)
                                           n

 -- Variável: pochhammer_max_index
     Valor por omissão: 100

     'pochhammer (<n>, <x>)' expande para um produto se e somente se
     '<n> <= pochhammer_max_index'.

     Exemplos:

          (%i1) pochhammer (x, 3), pochhammer_max_index : 3;
          (%o1)                   x (x + 1) (x + 2)
          (%i2) pochhammer (x, 4), pochhammer_max_index : 3;
          (%o2)                         (x)
                                           4

     Referência: Abramowitz e Stegun, equação 6.1.16,página 256.

 -- Função: spherical_bessel_j (<n>, <x>)
     A Função de Bessel esférica de primeiro tipo.

     Referência: Abramowitz e Stegun, equações 10.1.8,página 437 e
     10.1.15,página 439.

 -- Função: spherical_bessel_y (<n>, <x>)
     A Função de Bessel esférica de segundo tipo.

     Referência: Abramowitz e Stegun, equações 10.1.9,página 437 e
     10.1.15,página 439.

 -- Função: spherical_hankel1 (<n>, <x>)
     A Função de Hankel esférica de primeiro tipo.

     Referência: Abramowitz e Stegun, equação 10.1.36,página 439.

 -- Função: spherical_hankel2 (<n>, <x>)
     A Função de Hankel esférica de segundo tipo.

     Referência: Abramowitz e Stegun, equação 10.1.17,página 439.

 -- Função: spherical_harmonic (<n>, <m>, <x>, <y>)
     A função armônica esférica.

     Referência: Merzbacher 9.64.

 -- Função: unit_step (<x>)
     A função de passo de unidade contínua à esquerda; dessa forma
     'unit_step (<x>)' tende para '<x> <= 0' e é igual a 1 para '<x> >
     0'.

     Se quiser uma função de degrau unitário que tome o valor 1/2 em
     zero, use '(1 + signum (<x>))/2'.

 -- Função: ultraspherical (<n>, <a>, <x>)
     A função polinômial ultraesférica (também conhecida como função
     polinomial de Gegenbauer).

     Referência: Abramowitz e Stegun, equação 22.5.46,página 779.


File: maxima.info,  Node: plotdf,  Next: romberg,  Prev: orthopoly,  Up: Top

62 plotdf
*********

* Menu:

* Introdução a plotdf::
* Definições para plotdf::


File: maxima.info,  Node: Introdução a plotdf,  Next: Definições para plotdf,  Prev: plotdf,  Up: plotdf

62.1 Introdução a plotdf
========================

A função 'plotdf' cria um gráfico do campo de direcções para uma Equação
Diferencial Ordinária (EDO) de primeira ordem, ou para um sistema de
duas EDO's autónomas, de primeira ordem.

Por tratar-se de um pacote adicional, para poder usá-lo deverá primeiro
carregá-lo com o comando 'load("plotdf")'.  Também é necessário que
Xmaxima esteja instalado, inclusivamente se executar o Maxima desde
outra interface diferente.

Para desenhar o campo de direcções de uma única EDO, essa equação deverá
escrever-se na forma seguinte:
            dy
            -- = F(x,y)
            dx

e a função <F> será dada como argumento para o comando 'plotdf'.  A
variável independente tem que ser sempre <x> e a variável dependente
<y>.  A essas duas variáveis não poderá estar associado nenhum valor
numérico.

Para desenhar o campo de direcções de um sistema autónomo de duas EDO's,
as duas equações devem ser escritas na forma seguinte
            dx             dy
            -- = G(x,y)    -- = F(x,y)
            dt             dt

e o argumento para o comando 'plotdf' será uma lista com duas expressões
para as funções <F> e <G>.

Quando se trabalha com uma única equação, 'plotdf' assume implicitamente
que 'x=t' e 'G(x,y)=1', transformando a equação num sistema autónomo com
duas equações.


File: maxima.info,  Node: Definições para plotdf,  Prev: Introdução a plotdf,  Up: plotdf

62.2 Definições para plotdf
===========================

 -- Function: plotdf (<dydx>,...opções...)
 -- Function: plotdf ('['<dxdt>,<dydt>']',...opções...)

     Desenha um campo de direcções em duas dimensões <x> e <y>.

     <dydx>, <dxdt> e <dydt> são expressões que dependem de <x> e <y>.
     Para além dessas duas variáveis, as duas expressões podem depender
     de um conjunto de parâmetros, com valores numéricos que são dados
     por meio da opção 'parameters' (a sintaxe dessa opção explica-se
     mais para a frente), ou com um intervalo de possíveis valores
     definidos com a opção <sliders>.

     Várias outras opções podem incluirem-se dentro do comando, ou serem
     seleccionadas no menú.  Clicando num ponto do gráfico faz com que
     seja desenhada a curva integral que passa por esse ponto; o mesmo
     pode ser feito dando as coordenadas do ponto com a opção
     'trajectory_at' dentro do comando plotdf.  A direcção de integração
     pode controlar-se com a opção 'direction', que aceita valores de
     _forward_, _backward_ ou _both_.  O número de passos realizados na
     integração numérica controla-se com a opção 'nsteps' e o incremento
     do tempo em cada passo com a opção 'tstep'.  Usa-se o método de
     Adams Moulton para fazer a integração numérica; também é possível
     mudar para o método de Runge-Kutta de quarta ordem com ajuste de
     passos.

     Menú da janela do gráfico:

     O menú da janela gráfica inclui as seguintes opções: _Zoom_, que
     permite mudar o comportamento do rato, de maneira que servirá para
     fazer zoom na região do gráfico clicando com o botão esquerdo.
     Cada clic alarga a imagem mantendo no centro dela o ponto onde se
     clicou.  Mantendo carregada a tecla <Shift> enquanto se faz clic,
     faz diminuir o tamanho.  Para continuar a desenhar trajectórias com
     um clic, selecciona-se a opção _Integrate_ do menú.

     A opção _Config_ do menú pode usar-se para mudar a(s) EDO(S) e
     fazer alguns outros ajustes.  Após ter feito alguma alteração,
     deverá usar a opção _Replot_ para activar as novas configurações.
     Se introduzir duas coordenadas no campo _Trajectory at_ do menú de
     diálogo do _Config_, e a seguir carregar na tecla <Enter>, será
     acrescentada mais uma curva integral.  Se seleccionar a opção
     _Replot_, só será apresentada a última curva integral seleccionada.

     Mantendo o botão direito carregado enquanto se desloca o cursor,
     poderá arrastar o gráfico na horizontal e na vertical.  Outros
     parâmetros, por exemplo, o número de passos, o valor inicial de
     <t>, as coordenadas do centro e o raio, podem ser alterados no
     sub-menú da opção _Config_.

     Com a opção _Save_, pode imprimir-se o gráfico numa impressora
     Postscript ou gravar uma cópia num ficheiro Postscript.  Para optar
     entre impressão ou gravação em ficheiro, selecciona-se _Print
     Options_ na janela de diálogo de _Config_.  Após ter preenchido os
     campos da janela de diálogo de _Save_, será necessário seleccionar
     a opção _Save_ do primeiro menú para criar o ficheiro ou imprimir o
     gráfico.

     Opções gráficas:

     A função 'plotdf' admite varias opções, cada uma sendo uma lista de
     duas ou mais elementos.  O primeiro elemento é o nome da opção, e o
     resto estará formado pelos argumentos para essa opção.

     A função 'plotdf' reconhece as seguintes opções:

        * "tstep" estabelece a amplitude dos incrementos da variável
          independente <t>, utilizados para calcular as curvas
          integrais.  Se for dada só uma expressão <dydx>, a variável
          <x> será directamente proporcional a <t>.  O valor por omissão
          é 0.1.

        * "nsteps" estabelece o número de passos de comprimento 'tstep'
          que se utilizarão na variável independente para calcular a
          curva integral.  O valor por omissão é 100.

        * "direction" estabelece a direcção da variável independente que
          será seguida para calcular uma curva integral.  Os valores
          possí são: 'forward', para fazer que a variável independente
          aumente 'nsteps' vezes, com incrementos 'tstep'; 'backward',
          para fazer que a variável independente diminua; 'both', para
          estender a curva integral 'nsteps' passos para a frente e
          'nsteps' passos para atrás.  As palavras 'right' e 'left'
          podem serem usadas como sinónimos de 'forward' e 'backward'.
          O valor por omissão é 'both'.

        * "tinitial" estabelece o valor inicial da variável <t>
          utilizado para calcular curvas integrais.  Já que as equações
          diferenciais são autónomas, esta opção só aparecerá nos
          gráficos das curvas em função de <t>.  O valor por omissão é
          0.

        * "versus_t" utiliza-se para criar uma segunda janela gráfica,
          com o gráfico de uma curva integral, como duas funções <x>,
          <y>, de variável independente <t>.  Se for dado a 'versus_t'
          qualquer valor diferente de 0, mostrar-se-á a segunda janela
          gráfica, que inclui outro menú, similar ao da janela
          principal.  O valor por omissão é 0.

        * "trajectory_at" estabelece as coordenadas <xinitial> e
          <yinitial> para o ponto inicial da curva integral.  Não tem
          atribuído nenhum valor por omissão.

        * "parameters" estabelece uma lista de parâmetros, junto com os
          seus valores numéricos, que são utilizados na definição da
          equação diferencial.  Os nomes dos parâmetros e os seus
          valores devem escrever-se em formato de cadeia de caracteres
          como uma sequência de pares 'nome=valor' separados por
          vírgulas.

        * "sliders" estabelece uma lista de parâmetros que poderão ser
          alterados interactivamente usando barras com sliders, assim
          como os intervalos de variação dos ditos parâmetros.  Os nomes
          dos parâmetros e os seus intervalos devem escrever-se em
          formato de cadeia de caracteres como uma sequência de pares
          'nome=min:max' separados por vírgulas.

        * "xfun" estabelece uma cadeia de caracteres com funções de <x>
          separadas por ponto e vírgula para ser representadas por cima
          do campo de direcções.  Essas funções serão interpretadas por
          Tcl, e não por Maxima.

        * "xradius" é metade do comprimento do intervalo de valores a
          representar na direcção x.  O valor por omissão é 10.

        * "yradius" é metade do comprimento do intervalo de valores a
          representar na direcção y.  O valor por omissão é 10.

        * "xcenter" é a coordenada x do ponto situado no centro do
          gráfico.  O valor por omissão é 0.

        * "ycenter" é a coordenada y do ponto situado no centro do
          gráfico.  O valor por omissão é 0.

        * "width" estabelece a largura da janela gráfica em pixels.  O
          valor por omissão é 500.

        * "height" estabelece a altura da janela gráfica em pixels.  O
          valor por omissão é 500.

     Exemplos:

     NOTA: Em alguns casos, dependendo da interface usada para executar
     o Maxima, as funções que usam 'openmath', em particular 'plotdf',
     podem desencadear um bug se terminarem em ponto e vírgula, e não
     com o símbolo de dólar.  Para evitar problemas, usaremos o símbolo
     de dóla nos exemplos a seguir.

        * Para mostrar o campo de direcções da equação diferencial y' =
          exp(-x) + y e a solução que passa por (2, -0.1):
               (%i1) load("plotdf")$

               (%i2) plotdf(exp(-x)+y,[trajectory_at,2,-0.1]);

        * Para mostrar o campo de direcções da equação diff(y,x) = x -
          y^2 e a solução com condição inicial y(-1) = 3, pode
          utilizar-se o comando:
               (%i3) plotdf(x-y^2,[xfun,"sqrt(x);-sqrt(x)"],
                         [trajectory_at,-1,3], [direction,forward],
                         [yradius,5],[xcenter,6]);
          O gráfico também mostra a função y = sqrt(x).

        * O exemplo seguinte mostra o campo de direcções de um oscilador
          harmónico, definido pelas equações dx/dt = y e dy/dt = -k*x/m,
          e a curva integral que passa por (x,y) = (6,0), com uma barra
          de slider que permitirá mudar o valor de m interactivamente (k
          permanecerá fixo em 2):
               (%i4) plotdf([y,-k*x/m],[parameters,"m=2,k=2"],
                           [sliders,"m=1:5"], [trajectory_at,6,0]);

        * Para representar o campo de direcções da equação de Duffing,
          m*x''+c*x'+k*x+b*x^3 = 0, introduz-se a variável y=x' e
          faz-se:
               (%i5) plotdf([y,-(k*x + c*y + b*x^3)/m],
                             [parameters,"k=-1,m=1.0,c=0,b=1"],
                             [sliders,"k=-2:2,m=-1:1"],[tstep,0.1]);

        * O campo de direcções dum pêndulo amortecido, incluindo a
          solução para condições iniciales dadas, com uma barra de
          slider que pode usar-se para mudar o valor da masa, m, e com o
          gráfico das duas variáveis de estado em função do tempo:

               (%i6) plotdf([y,-g*sin(x)/l - b*y/m/l],
                        [parameters,"g=9.8,l=0.5,m=0.3,b=0.05"],
                        [trajectory_at,1.05,-9],[tstep,0.01],
                        [xradius,6],[yradius,14],
                        [xcenter,-4],[direction,forward],[nsteps,300],
                        [sliders,"m=0.1:1"], [versus_t,1]);


File: maxima.info,  Node: romberg,  Next: simplex,  Prev: plotdf,  Up: Top

63 romberg
**********

* Menu:

* Definições para romberg::


File: maxima.info,  Node: Definições para romberg,  Prev: Top,  Up: Top

63.1 Definições para romberg
============================

 -- Função: romberg (<expr>, <x>, <a>, <b>)
 -- Função: romberg (<F>, <a>, <b>)

     Calcula uma integração numérica pelo método de Romberg.

     'romberg(<expr>, <x>, <a>, <b>)' retorna uma estimativa da integral
     'integrate(<expr>, <x>, <a>, <b>)'.  <expr> deve ser uma expressão
     que avalie para um valor em ponto flutuante quando <x> estiver
     associado a um valor em ponto flutuante.

     'romberg(<F>, <a>, <b>)' retorna uma estimativa da integral
     'integrate(<F>(x), x, <a>, <b>)' onde 'x' representa o não nomeado,
     isolado argumeno de <F>; o actual argumento não é chamado 'x'.  <F>
     deve ser uma função do Maxima ou do Lisp que retorne um valor em
     ponto flutuante quando o argumento for um número em ponto
     flutuante.  <F> pode nomear uma função traduzida ou compilada do
     Maxima.

     A precisão de 'romberg' é governada pelas variáveis globais
     'rombergabs' e 'rombergtol'.  'romberg' termina com sucesso quando
     a diferença absoluta entre duas aproximações sucessivas for menor
     que 'rombergabs', ou a diferença relativa em aproximações
     sucessivas for menor que 'rombergtol'.  Dessa forma quando
     'rombergabs' for 0.0 (o padrão) somente o erro relativo tem algum
     efeito sobre 'romberg'.

     'romberg' divide ao meio o tamanho do passo no máximo 'rombergit'
     vezes antes de interromper; o número máximo de avaliações de função
     é portanto '2^rombergit'.  Se o critério de erro estabelecido por
     'rombergabs' e por 'rombergtol' não for satisfeito, 'romberg'
     mostra uma mensagem de erro.  'romberg' sempre faz ao menos
     'rombergmin' iterações; isso é uma intenção eurísstica de previnir
     encerramentos espúrios quando o integrando for oscilatório.

     'romberg' repetidamente avalia o integrando após associar a
     variável de integração a um valor específico (e não antes).  Essa
     política de avaliação torna possível aninhar chamadas a 'romberg',
     para calcular integrais multidimensionais.  Todavia, os cálculos de
     erro não tomam os erros de integrações aninhadas em consideração,
     então erros podem ser subestimados.  Também, métodos imaginados
     especialmente para problemas multidimensionais podem retornar a
     mesma precisão com poucas avaliações de função.

     'load(romberg)' torna essa função disponível para uso.

     Veja também 'QUADPACK', uma colecção de funções de integração
     numérica.

     Exemplos:

     Uma integração unidimensonal.

          (%i1) load (romberg);
          (%o1)    /usr/share/maxima/5.11.0/share/numeric/romberg.lisp
          (%i2) f(x) := 1/((x - 1)^2 + 1/100) + 1/((x - 2)^2 + 1/1000) + 1/((x - 3)^2 + 1/200);
                              1                 1                1
          (%o2) f(x) := -------------- + --------------- + --------------
                               2    1           2    1            2    1
                        (x - 1)  + ---   (x - 2)  + ----   (x - 3)  + ---
                                   100              1000              200
          (%i3) rombergtol : 1e-6;
          (%o3)                 9.9999999999999995E-7
          (%i4) rombergit : 15;
          (%o4)                          15
          (%i5) estimate : romberg (f(x), x, -5, 5);
          (%o5)                   173.6730736617464
          (%i6) exact : integrate (f(x), x, -5, 5);
          (%o6) 10 sqrt(10) atan(70 sqrt(10))
           + 10 sqrt(10) atan(30 sqrt(10)) + 10 sqrt(2) atan(80 sqrt(2))
           + 10 sqrt(2) atan(20 sqrt(2)) + 10 atan(60) + 10 atan(40)
          (%i7) abs (estimate - exact) / exact, numer;
          (%o7)                7.5527060865060088E-11

     Uma integração bidimensional, implementada com chamadas aninhadas a
     'romberg'.

          (%i1) load (romberg);
          (%o1)    /usr/share/maxima/5.11.0/share/numeric/romberg.lisp
          (%i2) g(x, y) := x*y / (x + y);
                                              x y
          (%o2)                   g(x, y) := -----
                                             x + y
          (%i3) rombergtol : 1e-6;
          (%o3)                 9.9999999999999995E-7
          (%i4) estimate : romberg (romberg (g(x, y), y, 0, x/2), x, 1, 3);
          (%o4)                   0.81930239628356
          (%i5) assume (x > 0);
          (%o5)                        [x > 0]
          (%i6) integrate (integrate (g(x, y), y, 0, x/2), x, 1, 3);
                                                    3
                                              2 log(-) - 1
                              9                     2        9
          (%o6)       - 9 log(-) + 9 log(3) + ------------ + -
                              2                    6         2
          (%i7) exact : radcan (%);
                              26 log(3) - 26 log(2) - 13
          (%o7)             - --------------------------
                                          3
          (%i8) abs (estimate - exact) / exact, numer;
          (%o8)                1.3711979871851024E-10

 -- Variável de opção: rombergabs
     Valor por omissão: 0.0

     A precisão de 'romberg' é governada pelas variávies globais
     'rombergabs' e 'rombergtol'.  'romberg' termina com sucesso quando
     a diferença absoluta entre duas aproximações sucessivas for menor
     que 'rombergabs', ou a diferença relativa em aproximações
     sucessivas for menor que 'rombergtol'.  Dessa forma quando
     'rombergabs' for 0.0 (o padrão) somente o erro relativo tem algum
     efeito sobre 'romberg'.

     Veja também 'rombergit' e 'rombergmin'.

 -- Variável de opção: rombergit
     Valor por omissão: 11

     'romberg' divide ao meio o tamanho do passo no máximo 'rombergit'
     vezes antes de interromper; o número máximo de avaliações de função
     é portanto '2^rombergit'.  Se o critério de erro estabelecido por
     'rombergabs' e por 'rombergtol' não for satisfeito, 'romberg'
     mostra uma mensagem de erro.  'romberg' sempre faz ao menos
     'rombergmin' iterações; isso é uma intenção eurísstica de previnir
     encerramentos espúrios quando o integrando for oscilatório.

     Veja também 'rombergabs' e 'rombergtol'.

 -- Variável de opção: rombergmin
     Valor por omissão: 0

     'romberg' sempre faz ao menos 'rombergmin' iterações; isso é uma
     intenção eurísstica para prevenir terminações espúrias quando o
     integrando for.

     Veja também 'rombergit', 'rombergabs', e 'rombergtol'.

 -- Variável de opção: rombergtol
     Valor por omissão: 1e-4

     A precisão de 'romberg' é governada pelas variáveis globais
     'rombergabs' e 'rombergtol'.  'romberg' termina com sucesso quando
     a diferença absoluta entre duas aproximações sucessivas for menor
     que 'rombergabs', ou a diferença relativa em aproximações
     sucessivas for menor que 'rombergtol'.  Dessa forma quando
     'rombergabs' for 0.0 (o padrão) somente o erro relativo tem algum
     efeito sobre 'romberg'.

     Veja também 'rombergit' e 'rombergmin'.


File: maxima.info,  Node: simplex,  Next: simplification,  Prev: romberg,  Up: Top

64 simplex
**********

* Menu:

* Introdução a simplex::
* Definições para simplex::


File: maxima.info,  Node: Introdução a simplex,  Next: Definições para simplex,  Prev: simplex,  Up: simplex

64.1 Introdução a simplex
=========================

'simplex' é um pacote para optimização linear usando o algoritmo
simplex.

Exemplo:

     (%i1) load("simplex")$
     (%i2) minimize_sx(x+y, [3*x+2*y>2, x+4*y>3]);
                       9        7       1
     (%o2)            [--, [y = --, x = -]]
                       10       10      5


File: maxima.info,  Node: Definições para simplex,  Prev: Introdução a simplex,  Up: simplex

64.2 Definições para simplex
============================

 -- Variável de opção: epsilon_sx
     Valor por omissão: '10^-8'

     Epsilon usando para cálculos numéricos em 'linear_program'.

     Veja também: 'linear_program'.

 -- Função: linear_program (<A>, <b>, <c>)

     'linear_program' é uma implementação do algoritmo simplex.
     'linear_program(A, b, c)' calcula um vetor <x> para o qual 'c.x' é
     o mínimo possível entre vetores para os quais 'A.x = b' e 'x >= 0'.
     O argumento <A> é uma matriz e os argumentos <b> e <c> são listas.

     'linear_program' retorna uma lista contendo o vetor minimizado <x>
     e o valor mínimo 'c.x'.  Se o problema for não associado, é
     retornado "Problem not bounded!"  e se o problema for não viável, é
     retornado "Problem not feasible!".

     Para usar essa função primeiramente chame o pacote 'simplex' com
     'load(simplex);'.

     Exemplo:

          (%i2) A: matrix([1,1,-1,0], [2,-3,0,-1], [4,-5,0,0])$
          (%i3) b: [1,1,6]$
          (%i4) c: [1,-2,0,0]$
          (%i5) linear_program(A, b, c);
                             13     19        3
          (%o5)            [[--, 4, --, 0], - -]
                             2      2         2

     Veja também: 'minimize_sx', 'scale_sx', e 'epsilon_sx'.

 -- Função: maximize_sx (<obj>, <cond>, [<pos>])

     Maximiza a função linear objetiva <obj> submetida a alguma
     restrição linear <cond>.  Veja 'minimize_sx' para uma descrição
     detalhada de argumentos e valores de retorno.

     Veja também: 'minimize_sx'.

 -- Função: minimize_sx (<obj>, <cond>, [<pos>])

     Minimiza uma função linear objetiva <obj> submetida a alguma
     restrição linear <cond>.  <cond> é uma lista de equações lineares
     ou desigualdades.  Em desigualdades estritas '>' é substituido por
     '>=' e '<' por '<='.  O argumento opcional <pos> é uma lista de
     variáveis de decisão que são assumidas como sendo positivas.

     Se o mínimo existir, 'minimize_sx' retorna uma lista que contém o
     menor valor da função objetiva e uma lista de valores de variáveis
     de decisão para os quais o mínimo é alcançado.  Se o problema for
     não associado, 'minimize_sx' retorna "Problem not bounded!"  e se o
     problema for não viável, é retornado "Ploblem not feasible!".

     As variáveis de decisão não são assumidas para serem não negativas
     por padrão.  Se todas as variáveis de dicisão forem não negativas,
     escolha 'nonegative_sx' para 'true'.  Se somente algumas das
     variáveis de decisão forem positivas, coloque-as então no argumento
     opcional <pos> (note que isso é mais eficiente que adicionar
     restrições).

     'minimize_sx' utiliza o algoritmo simplex que é implementado na
     função 'linear_program' do Maxima.

     Para usar essa função primeiramente chame o pacote 'simplex' com
     'load(simplex);'.

     Exemplos:

          (%i1) minimize_sx(x+y, [3*x+y=0, x+2*y>2]);
                                4       6        2
          (%o1)                [-, [y = -, x = - -]]
                                5       5        5
          (%i2) minimize_sx(x+y, [3*x+y>0, x+2*y>2]), nonegative_sx=true;
          (%o2)                [1, [y = 1, x = 0]]
          (%i3) minimize_sx(x+y, [3*x+y=0, x+2*y>2]), nonegative_sx=true;
          (%o3)                Problem not feasible!
          (%i4) minimize_sx(x+y, [3*x+y>0]);
          (%o4)                Problem not bounded!

     Veja também: 'maximize_sx', 'nonegative_sx', 'epsilon_sx'.

 -- Variável de opção: nonegative_sx
     Valor por omissão: 'false'

     Se 'nonegative_sx' for verdadeiro (true) todas as variáveis de
     decisão para 'minimize_sx' e 'maximize_sx' são assumidas para serem
     positivas.

     Veja também: 'minimize_sx'.


File: maxima.info,  Node: simplification,  Next: solve_rec,  Prev: simplex,  Up: Top

65 simplification
*****************

* Menu:

* Introdução a simplification::
* Definições para simplification::


File: maxima.info,  Node: Introdução a simplification,  Next: Definições para simplification,  Prev: simplification,  Up: simplification

65.1 Introdução a simplification
================================

O directório 'maxima/share/simplification' contém muitos scripts que
implementam regras de simplificação e funções, e também algumas funções
não relacionadas a simplificação.


File: maxima.info,  Node: Definições para simplification,  Prev: Introdução a simplification,  Up: simplification

65.2 Definições para simplification
===================================

65.2.1 Package absimp
---------------------

O pacote 'absimp' contém regras de comparação de sequências decaractere
que extendem as regras internas de simplificação para as funções 'abs' e
'signum'.  'absimp' respeita as relações estabelecidas com a função
interna 'assume' e por meio de declarações tais como 'modedeclare (m,
even, n, odd)' para inteiros paes ou ímpares.

'absimp' define as funções 'unitramp' e 'unitstep' em termos de 'abs' e
'signum'.

'load (absimp)' torna esse pacote disponível para uso.  'demo (absimp)'
faz uma demonstração desse pacote.

Exemplos:

     (%i1) load (absimp)$
     (%i2) (abs (x))^2;
                                            2
     (%o2)                                 x
     (%i3) diff (abs (x), x);
                                           x
     (%o3)                               ------
                                         abs(x)
     (%i4) cosh (abs (x));
     (%o4)                               cosh(x)

65.2.2 Package facexp
---------------------

O pacote 'facexp' contém muitas funções relacionadas a simplificações
que fornecem ao utilizador a habilidade de estruturar expressões por
meio de expansão controlada.  Essa capacidade é especialmente útil
quando a expressão contém variáveis que possuem significado físico,
porque é muitas vezes verdadeiro que a forma mais econômica de uma tal
expressão pode ser obtida por meio de uma expansão completa da expressão
com relação a essas variáveis, e então factorizar seus coeficientes.
Apesar de ser verdadeiro que esse procedimento é fácil de realizar
usando as funções padrão do Maxima, ajustes adicionais podem se
desejáveis, e esses toques finais podem ser mais difíceis de aplicar.

A função 'facsum' e suas formas relacionadas fornecem um meio
conveniente de controlar a estrutura de expressões por esse caminho.
Outra função, 'collectterms', pode ser usada para adicionar duas ou mais
expressões que já tenham sido simplificadas para essa forma, sem
resimplificar a expressão completa novamente.  Essa função pode ser útil
quando expressões forem muito grandes.

'load (facexp)' torna dispon;ivel para uso esse pacote.  'demo (facexp)'
faz uma demonstração desse pacote.

 -- Função: facsum (<expr>, <arg_1>, ..., <arg_n>)
     Retorna uma forma de <expr> que depende dos argumentos <arg_1>,
     ..., <arg_n>.  Os argumentos podem ser quaisquer formas adequadas
     para 'ratvars', ou eles podem ser listas de tais formas.  Se os
     argumentos não forem listas, então a forma retornada é
     completamente expandida com relação aos argumentos, e os
     coeficientes dos argumentos foram factorizados.  Esses coeficientes
     são livres dos argumentos, excepto talvez no sentido não racional.

     Se quaisquer dos argumentos forem listas, então todas as tais
     listas são combinadas em uma lista simples, e em lugar de chamar
     'factor' sobre os coeficientes dos argumentos, 'facsum' chama a si
     mesma sobre esses coeficientes, usando essa nova lista simples que
     foi construída como o novo argumento listo para essa chamada
     recursiva.  Esse processo pode ser repetido para um quantidade
     arbitrária de repetições por através do aninhamento dos elementos
     desejados nas listas.

     É possível que alguém possa querer usar 'facsum' com relação a
     subexpressões mais complicadas, tal como 'log (x + y)'.  Tais
     argumentos são também permitidos.  Sem especificação de variável,
     por exemplo 'facsum (<expr>)', o resultado retornado é o mesmo que
     o que é retornado por meio de 'ratsimp (<expr>)'.

     Ocasionalmente o utilizador pode querer obter quaisquer das formas
     abaixo para expressões que são especificadas somente por meio de
     seus operadores líderes.  Por exemplo, alguém pode querer usar
     'facsum' com relação a todos os 'log''s.  Nessa situação, alguém
     pode incluir no meio dos argumentos ou o código dos 'log''s
     eespecíficos que devem ser tratados po esse caminho ou
     alternativamente a expressão 'operator (log)' ou a expressão
     ''operator (log)'.  Se alguém quiser usar 'facsum' na expressão
     <expr> com relação aos operadores <op_1>, ..., <op_n>, pode-se
     avaliar 'facsum (<expr>, operator (<op_1>, ..., <op_n>))'.  A forma
     'operator' pode também aparecer dentro de uma lista de argumentos.

     Adicionalmente, a escolha de comutadores 'facsum_combine' e
     'nextlayerfactor' pode afectar o ressultado de 'facsum'.

 -- Variável global: nextlayerfactor
     Valor por omissão: 'false'

     Quando 'nextlayerfactor' for 'true', chamadas recursivas a 'facsum'
     são aplicdas aos factores da forma factorizada dos coeficientes dos
     argumentos.

     Quando 'nextlayerfactor' for 'false', 'facsum' é aplicada a cada
     coeficiente como um todo mesmo se chamadas recursivas a 'facsum'
     acontecerem.

     A inclusão do átomo 'nextlayerfactor' na lista argumento de
     'facsum' tem o efieto de 'nextlayerfactor: true', mas para o
     próximo nível da expressão somente.  Uma vez que 'nextlayerfactor'
     é sempre associado ou a 'true' ou a 'false', 'nextlayerfactor' deve
     ser apresentada com apóstrofo simples mesmo que 'nextlayerfactor'
     apareça na lista de argumento de 'facsum'.

 -- Variável global: facsum_combine
     Valor por omissão: 'true'

     'facsum_combine' controla a forma do resultado final retornada por
     meio de 'facsum' quando seu argumento é um quociente de polinómios.
     Se 'facsum_combine' for 'false' então a forma será retornada como
     um somatório completametne expandido como descrito acima, mas se
     'true', então a expressão retornada é uma razão de polinómios, com
     cada polinómio na forma descrita acima.

     A escolha de 'true' desse comutador é útil quando se deseja para
     'facsum' ambos o dumerador e o denominador de uma expressão
     racional, mas não se deseja que o denominador seja multiplicado de
     forma completa pelos termos do numerador.

 -- Função: factorfacsum (<expr>, <arg_1>, ... <arg_n>)
     Retorna uma forma de <expr> que é obtida por meio de chamada a
     'facsum' sobre os factores de <expr> com <arg_1>, ...  <arg_n> como
     argumentos.  Se qualqeur dos factores de <expr> estiver elevado a
     um expoente, ambos o factor e o expoente irão ser processados por
     esse meio.

 -- Função: collectterms (<expr>, <arg_1>, ..., <arg_n>)
     Se muitas expressões tiverem sido simplificadas com 'facsum',
     'factorfacsum', 'factenexpand', 'facexpten' ou com
     'factorfacexpten', e elas estão para serem adicionadas umas às
     outras, pode ser desejável combiná-las usando a função
     'collecterms'.  'collecterms' pode pegar como argumentos todos os
     argumentos que podem ser fornecidos para essas outras funções
     associadas com excessão de 'nextlayerfactor', que não tem efeito
     sobre 'collectterms'.  A vantagem de 'collectterms' está em que
     'collectterms' retorna uma forma similar a 'facsum', mas uma vez
     que 'collectterms' está adicionando forma que já tenham sido
     processadas por 'facsum', 'collectterms' não precisa repetir aquele
     esforço.  Essa capacidade é especialmente útil quando a expressão a
     ser somada for muito grande.

65.2.3 Pacote functs
--------------------

 -- Função: rempart (<expr>, <n>)
     Remove a parte <n> da expressão <expr>.

     Se <n> é uma lsita da forma '[<l>, <m>]' então as partes de <l> até
     <m> são removidas.

     Para usar essa função escreva primeiramente 'load(functs)'.

 -- Função: wronskian ([<f_1>, ..., <f_n>], <x>)
     Retorna a matriz Wronskiana das funções <f_1>, ..., <f_n> na
     variável <x>.

     <f_1>, ..., <f_n> pode ser o nome de funções definidas pelo
     utilizador, ou expressões na variável <x>.

     O determinante da matriz Wronskiana é o determinante Wronskiano do
     conjunto de funções.  As funções são linearmente independentes
     entre si se seu determinante for igual a zero.

     Para usar essa função escreva primeiramente 'load(functs)'.

 -- Função: tracematrix (<M>)
     Retorna o traço (somatório dos elementos da diagonal principal) da
     matriz <M>.

     Para usar essa função escreva primeiramente 'load(functs)'.

 -- Função: rational ('z')
     Multiplica o numerador e o denominador de <z> pelo complexo
     conjugado do denominador, racionando dessa forma o denominador
     complexo.  Retorna a forma de expressão racional canónica (CRE) se
     fornecida uma CRE, caso contrário retorna a forma geral.

     Para usar essa função escreva primeiramente 'load(functs)'.

 -- Função: nonzeroandfreeof (<x>, <expr>)
     Retorna 'true' se <expr> for diferente de zero e 'freeof (<x>,
     <expr>)' retorna 'true'.  Retorna 'false' de outra forma.

     Para usar essa função escreva primeiramente 'load(functs)'.

 -- Função: linear (<expr>, <x>)
     Quando <expr> for uma expressão linear na variável <x>, 'linear'
     retorna '<a>*<x> + <b>' onde <a> é diferente de zero, e <a> e <b>
     são livres de <x>.  De outra forma, 'linear' retorna <expr>.

     Para usar essa função escreva primeiramente 'load(functs)'.

 -- Função: gcdivide (<p>, <q>)
     Quando 'takegcd' for 'true', 'gcdivide' divide os polinómios <p> e
     <q> por seu maior divisor comum (MDC) e retorna a razão dos
     resultados.

     Quando 'takegcd' for 'false', 'gcdivide' retorna a razão '<p>/<q>'.

     Para usar essa função escreva primeiramente 'load(functs)'.

 -- Função: arithmetic (<a>, <d>, <n>)
     Retorna o <n>-ésiomo termo da série aritmética '<a>, <a> + <d>, <a>
     + 2*<d>, ..., <a> + (<n> - 1)*<d>'.

     Para usar essa função escreva primeiramente 'load(functs)'.

 -- Função: geometric (<a>, <r>, <n>)
     Retorna o <n>-ésimo termo da série geométrica '<a>, <a>*<r>,
     <a>*<r>^2, ..., <a>*<r>^(<n> - 1)'.

     Para usar essa função escreva primeiramente 'load(functs)'.

 -- Função: harmonic (<a>, <b>, <c>, <n>)
     Retorna o <n>-ésimo termo da série harmônica '<a>/<b>, <a>/(<b> +
     <c>), <a>/(<b> + 2*<c>), ..., <a>/(<b> + (<n> - 1)*<c>)'.

     Para usar essa função escreva primeiramente 'load(functs)'.

 -- Função: arithsum (<a>, <d>, <n>)
     Retorna a soma dos elementos da série aritmética de 1 a <n>.

     Para usar essa função escreva primeiramente 'load(functs)'.

 -- Função: geosum (<a>, <r>, <n>)
     Retorna a soma dos elementos da série geométrica de 1 a <n>.  Se
     <n> for infinito ('inf') então a soma será finita se e somente se o
     valor absoluto de <r> for menor que 1.

     Para usar essa função escreva primeiramente 'load(functs)'.

 -- Função: gaussprob (<x>)
     Retorna a função de probalilidade de Gauss '%e^(-<x>^2/2) /
     sqrt(2*%pi)'.

     Para usar essa função escreva primeiramente 'load(functs)'.

 -- Função: gd (<x>)
     Retorna a função de Gudermann '2 * atan(%e^<x> - %pi/2)'.

     Para usar essa função escreva primeiramente 'load(functs)'.

 -- Função: agd (<x>)
     Retorna o inverso da função de Gudermann 'log (tan (%pi/4 +
     x/2)))'.

     Para usar essa função escreva primeiramente 'load(functs)'.

 -- Função: vers (<x>)
     Retorna o sinus versus '1 - cos (x)'.

     Para usar essa função escreva primeiramente 'load(functs)'.

 -- Função: covers (<x>)
     Retorna o sinus versus do complemento '1 - sin (<x>)'.

     Para usar essa função escreva primeiramente 'load(functs)'.

 -- Função: exsec (<x>)
     Retorna a parte externa da secante 'sec (<x>) - 1'.

     Para usar essa função escreva primeiramente 'load(functs)'.

 -- Função: hav (<x>)
     Retorna o semi-sinus versus '(1 - cos(x))/2'.

     Para usar essa função escreva primeiramente 'load(functs)'.

 -- Função: combination (<n>, <r>)
     Retorna o número de combinações de <n> objectos tomados em grupos
     de <r> elementos.

     Para usar essa função escreva primeiramente 'load(functs)'.

 -- Função: permutation (<n>, <r>)
     Retorna o número de permutações de <r> objectos seleccionados de um
     conjunto de <n> objectos.

     Para usar essa função escreva primeiramente 'load(functs)'.

65.2.4 Package ineq
-------------------

O pacote 'ineq' contém regras de simplificação para desigualdades.

Sessão exemplo:

     (%i1) load(ineq)$
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     (%i2) a>=4;  /* uma desigualdade exemplo */
     (%o2)                               a >= 4
     (%i3) (b>c)+%; /* adiciona uma segunda e estrita desigualdade */
     (%o3)                            b + a > c + 4
     (%i4) 7*(x<y); /* multiplica por um número positivo */
     (%o4)                              7 x < 7 y
     (%i5) -2*(x>=3*z); /* multiplica por um número negativo */
     (%o5)                           - 2 x <= - 6 z
     (%i6) (1+a^2)*(1/(1+a^2)<=1); /* Maxima sabe que 1+a^2 > 0 */
                                             2
     (%o6)                             1 <= a  + 1
     (%i7) assume(x>0)$ x*(2<3); /* assumindo x>0 */
     (%o7)                              2 x < 3 x
     (%i8) a>=b; /* outa desigualdade */
     (%o8)                               a >= b
     (%i9) 3+%; /* adiciona alguma coisa à desigualdade imediatamente acima */
     (%o9)                           a + 3 >= b + 3
     (%i10) %-3; /* retirando essa alguma coisa */
     (%o10)                              a >= b
     (%i11) a>=c-b; /* ainda outra desigualdade */
     (%o11)                            a >= c - b
     (%i12) b+%; /* adiciona b a ambos os lados da desigualdade */
     (%o12)                            b + a >= c
     (%i13) %-c; /* subtrai c de ambos os lados */
     (%o13)                         - c + b + a >= 0
     (%i14) -%;  /* multiplica por -1 */
     (%o14)                          c - b - a <= 0
     (%i15) (z-1)^2>-2*z; /* determinando a verdade de uma assertiva */
                                           2
     (%o15)                         (z - 1)  > - 2 z
     (%i16) expand(%)+2*z; /* expandindo essa assertiva e adicionado 2*z a ambos os lados */
                                        2
     (%o16)                            z  + 1 > 0
     (%i17) %,pred;
     (%o17)                               true

Seja cuidadoso com o uso dos parêntesis em torno de desigualdades:
quando o utilizador digita '(A > B) + (C = 5)' o resltado é 'A + C > B +
5', mas 'A > B + C = 5' é um erro de sintaxe, e '(A > B + C) = 5' é
alguma coisa completametne diferente.

Faça 'disprule (all)' para ver uma lista completa das definições de
regras.

O utilizador será questionado se o Maxima for incapaz de decidir o sinal
de uma quantidade multiplicando uma desigualdade.

O mais comum recurso estranho é ilustrado por:

     (%i1) eq: a > b;
     (%o1)                                a > b
     (%i2) 2*eq;
     (%o2)                              2 (a > b)
     (%i3) % - eq;
     (%o3)                                a > b

Outro problema é 0 vezes uma desigualdade; o padrão para isso acontecer
é 0 ter sido colocado à esquerda sozinho.  Contudo, se digitar
'X*<some_inequality>' e Maxima perguntar sobre o sinal de 'X' e
responder 'zero' (ou 'z'), o programa retorna 'X*<some_inequality>' e
não utiliza a informação que 'X' é 0.  Pode usar 'ev (%, x: 0)' em casos
semelhantes a esse; a base de dados irá somente ser usada para
propósitos de comparação em decisões, e não para o propósito de
avaliação de 'X'.

O utilizador pode notar uma resposta lenta quando esse pacote é
disponibilizado para uso, como o simplificador é forçado a examinar mais
regras do precisaria sem esse pacote, então pode desejar remover essas
regras após fazer uso delas.  Faça 'kill (rules)' para eliminar todas as
regras (incluindo qualquer regra que possa ter definido); ou pode ser
mais selectivo eliminando somente algumas delas; ou use 'remrule' sobre
uma regra específica.

Note que se disponibilizar esse pacote para ser usado, após definir suas
próprias regras, irá sobrescrever as suas regras que possuirem nomes
identicos a nomes contidos nas regras do pacote.  As regras no pacote
são: '*rule1', ..., '*rule8', '+rule1', ..., '+rule18', e deve colocar o
nome de regra entre aspas duplas ao referir-se a eles, como em 'remrule
("+", "+rule1")' para especificamente remover a primeira regra sobre
'"+"' ou 'disprule ("*rule2")' para mostrar a definição da segunda regra
multiplicativa.

65.2.5 Package rducon
---------------------

 -- Função: reduce_consts (<expr>)
     Substitui subexpressões constantes de <expr> com construída com
     átomos constantes, gravando a definição de todas essas constantes
     construídas na lista de equações 'const_eqns', e retornando a
     expressão modificada <expr>.  Essas partes de <expr> são constantes
     que retornam 'true' quando operadas por meio da função 'constantp'.
     Consequêntemente, antes de usar 'reduce_consts', se pode fazer

          declare ([<objecto que vai receber a propriedade constante>], constant)$

     para escolher a base de dados das quantidades constantes ocorrendo
     em suas expressões.

     Se está a planear gerar saídas em Fortran após esses cálculos
     simbólicos, uma das primeiras secções de código pode ser o cálculo
     de todas as constantes.  Para gerar esse segmento de código, faça

          map ('fortran, const_eqns)$

     Variables como 'const_eqns' que afectam 'reduce_consts' são:

     'const_prefix' (valor padrão: 'xx') é a sequência de caracteres
     usada para prefixar todos os símbolos gerados por 'reduce_consts'
     para representar subexpressões constantes.

     'const_counter' (valor padrão: 1) é o índice inteiro usado para
     gerar símbolos únicos para representar cada subexpressão constante
     emcontrada por 'reduce_consts'.

     'load (rducon)' torna essa função disponível para uso.  'demo
     (rducon)' faz uma demonstração dessa função.

65.2.6 Pacote scifac
--------------------

 -- Função: gcfac (<expr>)
     'gcfac' função de factorização que tenta aplicar a mesma heurística
     que cientístas aplicam em tentativas de fazer expressões
     extremamente simples.  'gcfac' está limitada a factorizações
     monomiais.  Para um somatório, 'gcfac' faz o seguinte:

       1. Factores sobre os inteiros.
       2. Coloca em evidência o maior expoente de termos ocorrendo como
          coeficientes, independentemente da complexidade dos termos.
       3. Usa (1) e (2) em factorizações de pares de termos adjascentes.
       4. Repetidamente e recursivamente aplica essas técnicas até que a
          expressão não mais mude.

     O item (3) não necessáriamente faz uma tarefa óptima factorização
     par a par devido à dificuldade combinatória natural de encontrar
     qual de todas dos possíveis rearranjos de pares retorna o mais
     compacto resultado de factorização de um par.

     'load (scifac)' torna essa função disponível para uso.  'demo
     (scifac)' faz uma demonstração dessa função.

65.2.7 Pacote sqdnst
--------------------

 -- Função: sqrtdenest (<expr>)
     Desaninha 'sqrt' de simples, numérico, binômios de raízes
     irracionais de números racionais , onde for possível.  E.g.

          (%i1) load (sqdnst)$
          (%i2) sqrt(sqrt(3)/2+1)/sqrt(11*sqrt(2)-12);
                                              sqrt(3)
                                         sqrt(------- + 1)
                                                 2
          (%o2)                        ---------------------
                                       sqrt(11 sqrt(2) - 12)
          (%i3) sqrtdenest(%);
                                            sqrt(3)   1
                                            ------- + -
                                               2      2
          (%o3)                            -------------
                                              1/4    3/4
                                           3 2    - 2

     Algumas vezes isso ajuda na hora de aplicar 'sqrtdenest' mais que
     uma vez, sobre coisas como '(19601-13860 sqrt(2))^(7/4)'.

     'load (sqdnst)' Torna essa função disponível para uso.

