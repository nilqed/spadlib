This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.


File: maxima.info,  Node: Matrizes e Álgebra Linear,  Next: Funções Afins,  Prev: Arrays,  Up: Top

25 Matrizes e Álgebra Linear
****************************

* Menu:

* Introdução a Matrizes e Álgebra Linear::  
* Definições para Matrizes e Álgebra Linear::  


File: maxima.info,  Node: Introdução a Matrizes e Álgebra Linear,  Next: Definições para Matrizes e Álgebra Linear,  Prev: Matrizes e Álgebra Linear,  Up: Matrizes e Álgebra Linear

25.1 Introdução a Matrizes e Álgebra Linear
===========================================

* Menu:

* Ponto::                         
* Vetores::                     
* auto::


File: maxima.info,  Node: Ponto,  Next: Vetores,  Prev: Introdução a Matrizes e Álgebra Linear,  Up: Introdução a Matrizes e Álgebra Linear

25.1.1 Ponto
------------

O operador '.' representa multiplicação não comutativa e produto
escalar.  Quando os operandos são matrizes 1-coluna ou 1-linha 'a' e
'b', a expresão 'a.b' é equivalente a 'sum (a[i]*b[i], i, 1,
length(a))'.  Se 'a' e 'b' não são complexos, isso é o produto escalar,
também chamado produto interno ou produto do ponto, de 'a' e 'b'.  O
produto escalar é definido como 'conjugate(a).b' quando 'a' e 'b' são
complexos; 'innerproduct' no pacote 'eigen' fornece o produto escalar
complexo.

Quando os operandos são matrizes mais gerais, o produto é a matriz
produto 'a' e 'b'.  O número de linhas de 'b' deve ser igual ao número
de colunas de 'a', e o resultado tem número de linhas igual ao número de
linhas de 'a' e número de colunas igual ao número de colunas de 'b'.

Para distinguir '.' como um operador aritmético do ponto decimal em um
número em ponto flutuante, pode ser necessário deixar espaços em cada
lado.  Por exemplo, '5.e3' é '5000.0' mas '5 . e3' é '5' vezes 'e3'.

Existem muitos sinalizadores que governam a simplificação de expresões
envolvendo '.', a saber 'dot', 'dot0nscsimp', 'dot0simp', 'dot1simp',
'dotassoc', 'dotconstrules', 'dotdistrib', 'dotexptsimp', 'dotident', e
'dotscrules'.


File: maxima.info,  Node: Vetores,  Next: auto,  Prev: Ponto,  Up: Introdução a Matrizes e Álgebra Linear

25.1.2 Vetores
--------------

'vect' é um pacote de funções para análise vectorial.  'load ("vect")'
chama esse pacote, e 'demo ("vect")' permite visualizar uma
demonstração.

O pacote de análise vectorial pode combinar e simplificar expresões
simbólicas incluindo produtos dos pontos e productos dos x, juntamente
com o gradiente, divergencia, torção, e operadores Laplacianos.  A
distribuição desses operadores sobre adições ou produtos é governada por
muitos sinalizadores, como são várias outras expansões, incluindo
expansão dentro de componentes em qualquer sistema de coordenadas
ortogonais.  Existem também funções para derivar o escalar ou vector
potencial de um campo.

O pacote 'vect' contém essas funções: 'vectorsimp', 'scalefactors',
'express', 'potential', e 'vectorpotential'.

Atenção: o pacote 'vect' declara o operador ponto '.' como sendo um
operador comutativo.


File: maxima.info,  Node: auto,  Prev: Vetores,  Up: Introdução a Matrizes e Álgebra Linear

25.1.3 auto
-----------

O pacote 'eigen' contém muitas funções devotadas para a computação
simbólica de autovalores e autovectores.  Maxima chama o pacote
automaticamente se uma das funções 'eigenvalues' ou 'eigenvectors' é
invocada.  O pacote pode ser chamado explicitamente com 'load
("eigen")'.

'demo ("eigen")' mostra uma demonstração das compatibilidades desse
pacote.  'batch ("eigen")' executa a mesma demonstração, mas sem
lembretes de utilizador entre sucessivas computações.

As funções no pacote 'eigen' são 'innerproduct', 'unitvector',
'columnvector', 'gramschmidt', 'eigenvalues', 'eigenvectors',
'uniteigenvectors', e 'similaritytransform'.


File: maxima.info,  Node: Definições para Matrizes e Álgebra Linear,  Prev: Introdução a Matrizes e Álgebra Linear,  Up: Matrizes e Álgebra Linear

25.2 Definições para Matrizes e Álgebra Linear
==============================================

 -- Função: addcol (<M>, <list_1>, ..., <list_n>)
     Anexa a(s) coluna(s) dadas por uma ou mais listas (ou matrizes)
     sobre a matriz <M>.

 -- Função: addrow (<M>, <list_1>, ..., <list_n>)
     Anexa a(s) linha(s) dadas por uma ou mais listas (ou matrizes)
     sobre a matriz <M>.

 -- Função: adjoint (<M>)
     Retorna a matriz adjunta da matriz <M>.  A matriz adjunta é a
     transposta da matriz dos cofactores de <M>.

 -- Função: augcoefmatrix ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Retorna a matriz dos coeficientes aumentada para as variáveis
     <x_1>, ..., <x_n> do sistema de equações lineares <eqn_1>, ...,
     <eqn_m>.  Essa é a matriz dos coeficientes com uma coluna anexada
     para os termos independentes em cada equação (i.e., esses termos
     não dependem de <x_1>, ..., <x_n>).

          (%i1) m: [2*x - (a - 1)*y = 5*b, c + b*y + a*x = 0]$
          (%i2) augcoefmatrix (m, [x, y]);
                                 [ 2  1 - a  - 5 b ]
          (%o2)                  [                 ]
                                 [ a    b      c   ]

 -- Função: charpoly (<M>, <x>)
     Retorna um polinómio característico para a matriz <M> em relação à
     variável <x>.  Que é, 'determinant (<M> - diagmatrix (length (<M>),
     <x>))'.

          (%i1) a: matrix ([3, 1], [2, 4]);
                                      [ 3  1 ]
          (%o1)                       [      ]
                                      [ 2  4 ]
          (%i2) expand (charpoly (a, lambda));
                                     2
          (%o2)                lambda  - 7 lambda + 10
          (%i3) (programmode: true, solve (%));
          (%o3)               [lambda = 5, lambda = 2]
          (%i4) matrix ([x1], [x2]);
                                       [ x1 ]
          (%o4)                        [    ]
                                       [ x2 ]
          (%i5) ev (a . % - lambda*%, %th(2)[1]);
                                    [ x2 - 2 x1 ]
          (%o5)                     [           ]
                                    [ 2 x1 - x2 ]
          (%i6) %[1, 1] = 0;
          (%o6)                     x2 - 2 x1 = 0
          (%i7) x2^2 + x1^2 = 1;
                                      2     2
          (%o7)                     x2  + x1  = 1
          (%i8) solve ([%th(2), %], [x1, x2]);
                            1               2
          (%o8) [[x1 = - -------, x2 = - -------],
                         sqrt(5)         sqrt(5)

                                                       1             2
                                              [x1 = -------, x2 = -------]]
                                                    sqrt(5)       sqrt(5)

 -- Função: coefmatrix ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Retorna a matriz dos coeficientes para as variáveis <x_1>, ...,
     <x_n> do sistema de equações lineares <eqn_1>, ..., <eqn_m>.

          (%i1) coefmatrix([2*x-(a-1)*y+5*b = 0, b*y+a*x = 3], [x,y]);
                                           [ 2  1 - a ]
          (%o1)                            [          ]
                                           [ a    b   ]

 -- Função: col (<M>, <i>)
     Reorna a <i>'ésima coluna da matriz <M>.  O valor de retorno é uma
     matriz.

 -- Função: columnvector (<L>)
 -- Função: covect (<L>)
     Retorna uma matriz de uma coluna e 'length (<L>)' linhas, contendo
     os elementos da lista <L>.

     'covect' é um sinônimo para 'columnvector'.

     'load ("eigen")' chama essa função.

     Isso é útil se quiser usar partes das saídas das funções nesse
     pacote em cálculos matriciais.

     Exemplo:

          (%i1) load ("eigen")$
          Warning - you are redefining the Macsyma function autovalores
          Warning - you are redefining the Macsyma function autovectores
          (%i2) columnvector ([aa, bb, cc, dd]);
                                       [ aa ]
                                       [    ]
                                       [ bb ]
          (%o2)                        [    ]
                                       [ cc ]
                                       [    ]
                                       [ dd ]

 -- Função: conjugate (<x>)
     Retorna o conjugado complexo de <x>.

          (%i1) declare ([aa, bb], real, cc, complex, ii, imaginary);

          (%o1)                         done
          (%i2) conjugate (aa + bb*%i);

          (%o2)                      aa - %i bb
          (%i3) conjugate (cc);

          (%o3)                     conjugate(cc)
          (%i4) conjugate (ii);

          (%o4)                         - ii
          (%i5) conjugate (xx + yy);

          (%o5)             conjugate(yy) + conjugate(xx)

 -- Função: copymatrix (<M>)
     Retorna uma cópia da matriz <M>.  Esse é o único para fazer uma
     copia separada copiando <M> elemento a elemento.

     Note que uma atribuição de uma matriz para outra, como em 'm2: m1',
     não copia 'm1'.  Uma atribuição 'm2 [i,j]: x' ou 'setelmx (x, i, j,
     m2' também modifica 'm1 [i,j]'.  criando uma cópia com 'copymatrix'
     e então usando atribução cria uma separada e modificada cópia.

 -- Função: determinant (<M>)
     Calcula o determinante de <M> por um método similar à eliminação de
     Gauss.

     A forma do resultado depende da escolha do comutador 'ratmx'.

     Existe uma rotina especial para calcular determinantes esparsos que
     é chamada quando os comutadores 'ratmx' e 'sparse' são ambos
     'true'.

 -- Variável: detout
     Valor por omissão: 'false'

     Quando 'detout' é 'true', o determinante de uma matriz cuja inversa
     é calculada é factorado fora da inversa.

     Para esse comutador ter efeito 'doallmxops' e 'doscmxops' deveram
     ambos serem 'false' (veja suas transcrições).  Alternativamente
     esses comutadores podem ser dados para 'ev' o que faz com que os
     outros dois sejam escolhidos correctamente.

     Exemplo:

          (%i1) m: matrix ([a, b], [c, d]);
                                      [ a  b ]
          (%o1)                       [      ]
                                      [ c  d ]
          (%i2) detout: true$
          (%i3) doallmxops: false$
          (%i4) doscmxops: false$
          (%i5) invert (m);
                                    [  d   - b ]
                                    [          ]
                                    [ - c   a  ]
          (%o5)                     ------------
                                     a d - b c

 -- Função: diagmatrix (<n>, <x>)
     Retorna uma matriz diagonal de tamanho <n> por <n> com os elementos
     da diagonal todos iguais a <x>.  'diagmatrix (<n>, 1)' retorna uma
     matriz identidade (o mesmo que 'ident (<n>)').

     <n> deve avaliar para um inteiro, de outra forma 'diagmatrix'
     reclama com uma mensagem de erro.

     <x> pode ser qualquer tipo de expresão, incluindo outra matriz.  Se
     <x> é uma matriz, isso não é copiado; todos os elementos da
     diagonal referem-se à mesma instância, <x>.

 -- Variável: doallmxops
     Valor por omissão: 'true'

     Quando 'doallmxops' é 'true', todas as operações relacionadas a
     matrizes são realizadas.  Quando isso é 'false' então a escolha de
     comutadores individuais 'dot' governam quais operações são
     executadas.

 -- Variável: domxexpt
     Valor por omissão: 'true'

     Quando 'domxexpt' é 'true', uma matriz exponencial, 'exp (<M>)'
     onde <M> é a matriz, é interpretada como uma matriz com elementos
     '[i,j' iguais a 'exp (m[i,j])'.  de outra forma 'exp (<M>)' avalia
     para 'exp (<ev(M)>'.

     'domxexpt' afecta todas as expresões da forma '<base>^<expoente>'
     onde <base> é uma expresão assumida escalar ou constante, e
     <expoente> é uma lista ou matriz.

     Exemplo:

          (%i1) m: matrix ([1, %i], [a+b, %pi]);
                                   [   1    %i  ]
          (%o1)                    [            ]
                                   [ b + a  %pi ]
          (%i2) domxexpt: false$
          (%i3) (1 - c)^m;
                                       [   1    %i  ]
                                       [            ]
                                       [ b + a  %pi ]
          (%o3)                 (1 - c)
          (%i4) domxexpt: true$
          (%i5) (1 - c)^m;
                            [                      %i  ]
                            [    1 - c      (1 - c)    ]
          (%o5)             [                          ]
                            [        b + a         %pi ]
                            [ (1 - c)       (1 - c)    ]

 -- Variável de opção: domxmxops
     Valor por omissão: 'true'

     Quando 'domxmxops' é 'true', todas as operações matriz-matriz ou
     matriz-lista são realizadas (mas não operações escalar-matriz); se
     esse comutador é 'false' tais operações não são.

 -- Variável de opção: domxnctimes
     Valor por omissão: 'false'

     Quando 'domxnctimes' é 'true', produtos não comutativos de matrizes
     são realizados.

 -- Variável de opção: dontfactor
     Valor por omissão: '[]'

     'dontfactor' pode ser escolhido para uma lista de variáveis em
     relação a qual factoração não é para ocorrer.  (A lista é
     inicialmente vazia.)  Factoração também não pegará lugares com
     relação a quaisquer variáveis que são menos importantes, conforme a
     hierarquía de variável assumida para a forma expresão racional
     canónica (CRE), que essas na lista 'dontfactor'.

 -- Variável de opção: doscmxops
     Valor por omissão: 'false'

     Quando 'doscmxops' é 'true', operações escalar-matriz são
     realizadas.

 -- Variável de opção: doscmxplus
     Valor por omissão: 'false'

     Quando 'doscmxplus' é 'true', operações escalar-matriz retornam uma
     matriz resultado.  Esse comutador não é subsomado sob 'doallmxops'.

 -- Variável de opção: dot0nscsimp
     Valor por omissão: 'true'

     Quando 'dot0nscsimp' é 'true', um produto não comutativo de zero e
     um termo não escalar é simplificado para um produto comutativo.

 -- Variável de opção: dot0simp
     Valor por omissão: 'true'

     Quando 'dot0simp' é 'true', um produto não comutativo de zero e um
     termo escalar é simplificado para um produto não comutativo.

 -- Variável de opção: dot1simp
     Valor por omissão: 'true'

     Quando 'dot1simp' é 'true', um produto não comutativo de um e outro
     termo é simplificado para um produto comutativo.

 -- Variável de opção: dotassoc
     Valor por omissão: 'true'

     Quando 'dotassoc' é 'true', uma expresão '(A.B).C' simplifica para
     'A.(B.C)'.

 -- Variável de opção: dotconstrules
     Valor por omissão: 'true'

     Quando 'dotconstrules' é 'true', um produto não comutativo de uma
     constante e outro termo é simplificado para um produto comutativo.
     Ativando esse sinalizador efectivamente activamos 'dot0simp',
     'dot0nscsimp', e 'dot1simp' também.

 -- Variável de opção: dotdistrib
     Valor por omissão: 'false'

     Quando 'dotdistrib' é 'true', uma expresão 'A.(B + C)' simplifica
     para 'A.B + A.C'.

 -- Variável de opção: dotexptsimp
     Valor por omissão: 'true'

     Quando 'dotexptsimp' é 'true', uma expresão 'A.A' simplifica para
     'A^^2'.

 -- Variável de opção: dotident
     Valor por omissão: 1

     'dotident' é o valor retornado por 'X^^0'.

 -- Variável de opção: dotscrules
     Valor por omissão: 'false'

     Quando 'dotscrules' é 'true', uma expresão 'A.SC' ou 'SC.A'
     simplifica para 'SC*A' e 'A.(SC*B)' simplifica para 'SC*(A.B)'.

 -- Função: echelon (<M>)
     Retorna a forma escalonada da matriz <M>, como produzido através da
     eliminação de Gauss.  A forma escalonada é calculada de <M> por
     operações elementares de linha tais que o primeiro elemento não
     zero em cada linha na matriz resultante seja o número um e os
     elementos da coluna abaixo do primeiro número um em cada linha
     sejam todos zero.

     'triangularize' também realiza eliminação de Gaussian, mas não
     normaliza o elemento líder não nulo em cada linha.

     'lu_factor' e 'cholesky' são outras funções que retornam matrizes
     triangularizadas.

          (%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                                 [  3   7  aa  bb ]
                                 [                ]
          (%o1)                  [ - 1  8  5   2  ]
                                 [                ]
                                 [  9   2  11  4  ]
          (%i2) echelon (M);
                            [ 1  - 8  - 5      - 2     ]
                            [                          ]
                            [         28       11      ]
                            [ 0   1   --       --      ]
          (%o2)             [         37       37      ]
                            [                          ]
                            [              37 bb - 119 ]
                            [ 0   0    1   ----------- ]
                            [              37 aa - 313 ]

 -- Função: eigenvalues (<M>)
 -- Função: eivals (<M>)
     Retorna uma lista de duas listas contendo os autovalores da matriz
     <M>.  A primeira sublista do valor de retorno é a lista de
     autovalores da matriz, e a segunda sublista é a lista de
     multiplicidade dos autovalores na ordem correspondente.

     'eivals' é um sinônimo de 'eigenvalues'.

     'eigenvalues' chama a função 'solve' para achar as raízes do
     polinómio característico da matriz.  Algumas vezes 'solve' pode não
     estar habilitado a achar as raízes do polinómio; nesse caso algumas
     outras funções nesse pacote (except 'innerproduct', 'unitvector',
     'columnvector' e 'gramschmidt') não irão trabalhar.

     Em alguns casos os autovalores achados por 'solve' podem ser
     expresões complicadas.  (Isso pode acontecer quando 'solve' retorna
     uma expresão real não trivial para um autovalor que é sabidamente
     real.)  Isso pode ser possível para simplificar os autovalores
     usando algumas outras funções.

     O pacote 'eigen.mac' é chamado automaticamente quando 'eigenvalues'
     ou 'eigenvectors' é referenciado.  Se 'eigen.mac' não tiver sido
     ainda chamado, 'load ("eigen")' chama-o.  Após ser chamado, todas
     as funções e variáveis no pacote estarão disponíveis.

 -- Função: eigenvectors (<M>)
 -- Função: eivects (<M>)
     pegam uma matriz <M> como seu argumento e retorna uma lista de
     listas cuja primeira sublista é a saída de 'eigenvalues' e as
     outras sublistas são os autovectores da matriz correspondente para
     esses autovalores respectivamente.

     'eivects' é um sinônimo para 'eigenvectors'.

     O pacote 'eigen.mac' é chamado automaticamente quando 'eigenvalues'
     ou 'eigenvectors' é referenciado.  Se 'eigen.mac' não tiver sido
     ainda chamado, 'load ("eigen")' chama-o.  Após ser chamado, todas
     as funções e variáveis no pacote estarão disponíveis.

     Os sinalizadores que afectam essa função são:

     'nondiagonalizable' é escolhido para 'true' ou 'false' dependendo
     de se a matriz é não diagonalizável ou diagonalizável após o
     retorno de 'eigenvectors'.

     'hermitianmatrix' quando 'true', faz com que os autovectores
     degenerados da matriz Hermitiana sejam ortogonalizados usando o
     algoritmo de Gram-Schmidt.

     'knowneigvals' quando 'true' faz com que o pacote 'eigen' assumir
     que os autovalores da matriz são conhecidos para o utilizador e
     armazenados sob o nome global 'listeigvals'.  'listeigvals' poderá
     ser escolhido para uma lista similar à saída de 'eigenvalues'.

     A função 'algsys' é usada aqui para resolver em relação aos
     autovectores.  Algumas vezes se os autovalores estão ausêntes,
     'algsys' pode não estar habilitado a achar uma solução.  Em alguns
     casos, isso pode ser possível para simplificar os autovalores por
     primeiro achando e então usando o comando 'eigenvalues' e então
     usando outras funções para reduzir os autovalores a alguma coisa
     mais simples.  Continuando a simplificação, 'eigenvectors' pode ser
     chamada novamente com o sinalizador 'knowneigvals' escolhido para
     'true'.

 -- Função: ematrix (<m>, <n>, <x>, <i>, <j>)
     Retorna uma matriz <m> por <n>, todos os elementos da qual são zero
     excepto para o elemento '[<i>, <j>]' que é <x>.

 -- Função: entermatrix (<m>, <n>)
     Retorna uma matriz <m> por <n>, lendo os elementos interativamente.

     Se <n> é igual a <m>, Maxima pergunta pelo tipo de matriz
     (diagonal, simétrica, antisimétrica, ou genérica) e por cada
     elemento.  Cada resposta é terminada por um ponto e vírgula ';' ou
     sinal de dólar '$'.

     Se <n> não é igual a <m>, Maxima pergunta por cada elemento.

     Os elementos podem ser quaisquer expressões, que são avaliadas.
     'entermatrix' avalia seus argumentos.

          (%i1) n: 3$
          (%i2) m: entermatrix (n, n)$

          Is the matriz  1.  Diagonal  2.  Symmetric  3.  Antisymmetric  4.  General
          Answer 1, 2, 3 or 4 :
          1$
          Row 1 Column 1:
          (a+b)^n$
          Row 2 Column 2:
          (a+b)^(n+1)$
          Row 3 Column 3:
          (a+b)^(n+2)$

          Matriz entered.
          (%i3) m;
                          [        3                     ]
                          [ (b + a)      0         0     ]
                          [                              ]
          (%o3)           [                  4           ]
                          [    0      (b + a)      0     ]
                          [                              ]
                          [                            5 ]
                          [    0         0      (b + a)  ]

 -- Função: genmatrix (<a>, <i_2>, <j_2>, <i_1>, <j_1>)
 -- Função: genmatrix (<a>, <i_2>, <j_2>, <i_1>)
 -- Função: genmatrix (<a>, <i_2>, <j_2>)
     Retorna uma matriz gerada de <a>, pegando o elemento
     '<a>[<i_1>,<j_1>]' como o elemento do canto superior esquerdo e
     '<a>[<i_2>,<j_2>]' como o elemento do canto inferior directo da
     matriz.  Aqui <a> é um array declarado (criado através de 'array'
     mas não por meio de 'make_array') ou um array não declarado, ou uma
     função array, ou uma expressão lambda de dois argumentos.  (Uma
     funçãO array é criado como outras funções com ':=' ou 'define', mas
     os argumentos são colocados entre colchêtes em lugar de
     parêntesis.)

     Se <j_1> é omitido, isso é assumido ser igual a <i_1>.  Se ambos
     <j_1> e <i_1> são omitidos, ambos são assumidos iguais a 1.

     Se um elemento seleccionado 'i,j' de um array for indefinido, a
     matriz conterá um elemento simbólico '<a>[i,j]'.

     Exemplos:

          (%i1) h [i, j] := 1 / (i + j - 1);
                                              1
          (%o1)                  h     := ---------
                                  i, j    i + j - 1
          (%i2) genmatrix (h, 3, 3);
                                     [    1  1 ]
                                     [ 1  -  - ]
                                     [    2  3 ]
                                     [         ]
                                     [ 1  1  1 ]
          (%o2)                      [ -  -  - ]
                                     [ 2  3  4 ]
                                     [         ]
                                     [ 1  1  1 ]
                                     [ -  -  - ]
                                     [ 3  4  5 ]
          (%i3) array (a, fixnum, 2, 2);
          (%o3)                           a
          (%i4) a [1, 1] : %e;
          (%o4)                          %e
          (%i5) a [2, 2] : %pi;
          (%o5)                          %pi
          (%i6) genmatrix (a, 2, 2);
                                     [ %e   0  ]
          (%o6)                      [         ]
                                     [ 0   %pi ]
          (%i7) genmatrix (lambda ([i, j], j - i), 3, 3);
                                   [  0    1   2 ]
                                   [             ]
          (%o7)                    [ - 1   0   1 ]
                                   [             ]
                                   [ - 2  - 1  0 ]
          (%i8) genmatrix (B, 2, 2);
                                  [ B      B     ]
                                  [  1, 1   1, 2 ]
          (%o8)                   [              ]
                                  [ B      B     ]
                                  [  2, 1   2, 2 ]

 -- Função: gramschmidt (<x>)
 -- Função: gschmit (<x>)
     Realiza o algoritmo de ortonalização de Gram-Schmidt sobre <x>,
     seja ela uma matriz ou uma lista de listas.  <x> não é modificado
     por 'gramschmidt'.

     Se <x> é uma matriz, o algoritmo é aplicado para as linhas de <x>.
     Se <x> é uma lista de listas, o algoritmo é aplicado às sublistas,
     que devem ter igual números de elementos.  Nos dois casos, o valor
     de retorno é uma lista de listas, as sublistas das listas são
     ortogonais e gera o mesmo spaço que <x>.  Se a dimensão do conjunto
     gerador de <x> é menor que o número de linhas ou sublistas, algumas
     sublistas do valor de retorno são zero.

     'factor' é chamada a cada estágio do algoritmo para simplificar
     resultados intermédios.  Como uma consequência, o valor de retorno
     pode conter inteiros factorados.

     'gschmit' (nota ortográfica) é um sinônimo para 'gramschmidt'.

     'load ("eigen")' chama essa função.

     Exemplo:

          (%i1) load ("eigen")$
          Warning - you are redefining the Macsyma function autovalores
          Warning - you are redefining the Macsyma function autovectores
          (%i2) x: matrix ([1, 2, 3], [9, 18, 30], [12, 48, 60]);
                                   [ 1   2   3  ]
                                   [            ]
          (%o2)                    [ 9   18  30 ]
                                   [            ]
                                   [ 12  48  60 ]
          (%i3) y: gramschmidt (x);
                                 2      2            4     3
                                3      3   3 5      2  3  2  3
          (%o3)  [[1, 2, 3], [- ---, - --, ---], [- ----, ----, 0]]
                                2 7    7   2 7       5     5
          (%i4) i: innerproduct$
          (%i5) [i (y[1], y[2]), i (y[2], y[3]), i (y[3], y[1])];
          (%o5)                       [0, 0, 0]

 -- Função: ident (<n>)
     Retorna uma matriz identidade <n> por <n>.

 -- Função: innerproduct (<x>, <y>)
 -- Função: inprod (<x>, <y>)
     Retorna o produto interno (também chamado produto escalar ou
     produto do ponto) de <x> e <y>, que são listas de igual
     comprimento, ou ambas matrizes 1-coluna ou 1-linha de igual
     comprimento.  O valor de retorno é 'conjugate (x) . y', onde '.' é
     o operador de multiplicação não comutativa.

     'load ("eigen")' chama essa função.

     'inprod' é um sinônimo para 'innerproduct'.

 -- Função: invert (<M>)
     Retorna a inversa da matriz <M>.  A inversa é calculada pelo método
     adjunto.

     Isso permite a um utilizador calcular a inversa de uma matriz com
     entradas bfloat ou polinómios com coeficientes em ponto flutuante
     sem converter para a forma CRE.

     Cofactores são calculados pela função 'determinant', então se
     'ratmx' é 'false' a inversa é calculada sem mudar a representação
     dos elementos.

     A implementação corrente é ineficiente para matrizes de alta ordem.

     Quando 'detout' é 'true', o determinante é factorado fora da
     inversa.

     Os elementos da inversa não são automaticamente expandidos.  Se <M>
     tem elementos polinomiais, melhor aparência de saída pode ser
     gerada por 'expand (invert (m)), detout'.  Se isso é desejável para
     ela divisão até pelo determinante pode ser excelente por 'xthru
     (%)' ou alternativamente na unha por

          expe (adjoint (m)) / expand (determinant (m))
          invert (m) := adjoint (m) / determinant (m)

     Veja '^^' (expoente não comutativo) para outro método de inverter
     uma matriz.

 -- Variável de opção: lmxchar
     Valor por omissão: '['

     'lmxchar' é o caractere mostrado como o delimitador esquerdo de uma
     matriz.  Veja também 'rmxchar'.

     Exemplo:

          (%i1) lmxchar: "|"$
          (%i2) matrix ([a, b, c], [d, e, f], [g, h, i]);
                                     | a  b  c ]
                                     |         ]
          (%o2)                      | d  e  f ]
                                     |         ]
                                     | g  h  i ]

 -- Função: matrix (<row_1>, ..., <row_n>)
     Retorna uma matriz retangular que tem as linhas <row_1>, ...,
     <row_n>.  Cada linha é uma lista de expressões.  Todas as linhas
     devem ter o mesmo comprimento.

     As operações '+' (adição), '-' (subtração), '*' (multiplicação), e
     '/' (divisão), são realizadas elemento por elemento quando os
     operandos são duas matrizes, um escalar e uma matriz, ou uma matriz
     e um escalar.  A operação '^' (exponenciação, equivalentemente
     '**') é realizada elemento por elemento se os operandos são um
     escalar e uma matriz ou uma matriz e um escalar, mas não se os
     operandos forem duas matrizes.  Todos as operações são normalmente
     realizadas de forma completa, incluindo '.' (multiplicação não
     comutativa).

     Multiplicação de matrizes é representada pelo operador de
     multiplicação não comutativa '.'.  O correspondente operador de
     exponenciação não comutativa é '^^'.  Para uma matriz '<A>',
     '<A>.<A> = <A>^^2' e '<A>^^-1' é a inversa de <A>, se existir.

     Existem comutadores para controlar a simplificação de expresões
     envolvendo operações escalar e matriz-lista.  São eles
     'doallmxops', 'domxexpt' 'domxmxops', 'doscmxops', e 'doscmxplus'.

     Existem opções adicionais que são relacionadas a matrizes.  São
     elas: 'lmxchar', 'rmxchar', 'ratmx', 'listarith', 'detout',
     'scalarmatrix', e 'sparse'.

     Existe um número de funções que pegam matrizes como argumentos ou
     devolvem matrizes como valor de retorno.  Veja 'eigenvalues',
     'eigenvectors', 'determinant', 'charpoly', 'genmatrix', 'addcol',
     'addrow', 'copymatrix', 'transpose', 'echelon', e 'rank'.

     Exemplos:

        * Construção de matrizes de listas.
          (%i1) x: matrix ([17, 3], [-8, 11]);
                                     [ 17   3  ]
          (%o1)                      [         ]
                                     [ - 8  11 ]
          (%i2) y: matrix ([%pi, %e], [a, b]);
                                     [ %pi  %e ]
          (%o2)                      [         ]
                                     [  a   b  ]
        * Adição, elemento por elemento.
          (%i3) x + y;
                                [ %pi + 17  %e + 3 ]
          (%o3)                 [                  ]
                                [  a - 8    b + 11 ]
        * Subtração, elemento por elemento.
          (%i4) x - y;
                                [ 17 - %pi  3 - %e ]
          (%o4)                 [                  ]
                                [ - a - 8   11 - b ]
        * Multiplicação, elemento por elemento.
          (%i5) x * y;
                                  [ 17 %pi  3 %e ]
          (%o5)                   [              ]
                                  [ - 8 a   11 b ]
        * Divisão, elemento por elemento.
          (%i6) x / y;
                                  [ 17       - 1 ]
                                  [ ---  3 %e    ]
                                  [ %pi          ]
          (%o6)                   [              ]
                                  [   8    11    ]
                                  [ - -    --    ]
                                  [   a    b     ]
        * Matriz para um expoente escalar, elemento por elemento.
          (%i7) x ^ 3;
                                   [ 4913    27  ]
          (%o7)                    [             ]
                                   [ - 512  1331 ]
        * Base escalar para um expoente matriz, elemento por elemento.
          (%i8) exp(y);
                                   [   %pi    %e ]
                                   [ %e     %e   ]
          (%o8)                    [             ]
                                   [    a     b  ]
                                   [  %e    %e   ]
        * Base matriz para um expoente matriz.  Essa não é realizada
          elemento por elemento.
          (%i9) x ^ y;
                                          [ %pi  %e ]
                                          [         ]
                                          [  a   b  ]
                               [ 17   3  ]
          (%o9)                [         ]
                               [ - 8  11 ]
        * Multiplicação não comutativa de matrizes.
          (%i10) x . y;
                            [ 3 a + 17 %pi  3 b + 17 %e ]
          (%o10)            [                           ]
                            [ 11 a - 8 %pi  11 b - 8 %e ]
          (%i11) y . x;
                          [ 17 %pi - 8 %e  3 %pi + 11 %e ]
          (%o11)          [                              ]
                          [  17 a - 8 b     11 b + 3 a   ]
        * Exponenciação não comutativa de matrizes.  Uma base escalar
          <b> para uma potência matriz <M> é realizada elemento por
          elemento e então 'b^^m' é o mesmo que 'b^m'.
          (%i12) x ^^ 3;
                                  [  3833   1719 ]
          (%o12)                  [              ]
                                  [ - 4584  395  ]
          (%i13) %e ^^ y;
                                   [   %pi    %e ]
                                   [ %e     %e   ]
          (%o13)                   [             ]
                                   [    a     b  ]
                                   [  %e    %e   ]
        * A matriz elevada a um expoente -1 com exponenciação não
          comutativa é a matriz inversa, se existir.
          (%i14) x ^^ -1;
                                   [ 11      3  ]
                                   [ ---  - --- ]
                                   [ 211    211 ]
          (%o14)                   [            ]
                                   [  8    17   ]
                                   [ ---   ---  ]
                                   [ 211   211  ]
          (%i15) x . (x ^^ -1);
                                      [ 1  0 ]
          (%o15)                      [      ]
                                      [ 0  1 ]

 -- Função: matrixmap (<f>, <M>)
     Retorna uma matriz com elemento 'i,j' igual a '<f>(<M>[i,j])'.

     Veja também 'map', 'fullmap', 'fullmapl', e 'apply'.

 -- Função: matrixp (<expr>)
     Retorna 'true' se <expr> é uma matriz, de outra forma retorna
     'false'.

 -- Variável de opção: matrix_element_add
     Valor por omissão: '+'

     'matrix_element_add' é a operação invocada em lugar da adição em
     uma multiplicação de matrizes.  A 'matrix_element_add' pode ser
     atribuído qualquer operador n-ário (que é, uma função que manuseia
     qualquer número de argumentos).  Os valores atribuídos podem ser o
     nome de um operador entre aspas duplas, o nome da função, ou uma
     expressão lambda.

     Veja também 'matrix_element_mult' e 'matrix_element_transpose'.

     Exemplo:

          (%i1) matrix_element_add: "*"$
          (%i2) matrix_element_mult: "^"$
          (%i3) aa: matrix ([a, b, c], [d, e, f]);
                                     [ a  b  c ]
          (%o3)                      [         ]
                                     [ d  e  f ]
          (%i4) bb: matrix ([u, v, w], [x, y, z]);
                                     [ u  v  w ]
          (%o4)                      [         ]
                                     [ x  y  z ]
          (%i5) aa . transpose (bb);
                               [  u  v  w   x  y  z ]
                               [ a  b  c   a  b  c  ]
          (%o5)                [                    ]
                               [  u  v  w   x  y  z ]
                               [ d  e  f   d  e  f  ]

 -- Variável de opção: matrix_element_mult
     Valor por omissão: '*'

     'matrix_element_mult' é a operação invocada em lugar da
     multiplicação em uma multiplicação de matrizes.  A
     'matrix_element_mult' pode ser atribuído qualquer operador binário.
     O valor atribuído pode ser o nome de um operador entre aspas
     duplas, o nome de uma função, ou uma expressão lambda.

     O operador do ponto '.' é uma escolha útil em alguns contextos.

     Veja também 'matrix_element_add' e 'matrix_element_transpose'.

     Exemplo:

          (%i1) matrix_element_add: lambda ([[x]], sqrt (apply ("+", x)))$
          (%i2) matrix_element_mult: lambda ([x, y], (x - y)^2)$
          (%i3) [a, b, c] . [x, y, z];
                                    2          2          2
          (%o3)         sqrt((c - z)  + (b - y)  + (a - x) )
          (%i4) aa: matrix ([a, b, c], [d, e, f]);
                                     [ a  b  c ]
          (%o4)                      [         ]
                                     [ d  e  f ]
          (%i5) bb: matrix ([u, v, w], [x, y, z]);
                                     [ u  v  w ]
          (%o5)                      [         ]
                                     [ x  y  z ]
          (%i6) aa . transpose (bb);
                         [             2          2          2  ]
                         [ sqrt((c - w)  + (b - v)  + (a - u) ) ]
          (%o6)  Col 1 = [                                      ]
                         [             2          2          2  ]
                         [ sqrt((f - w)  + (e - v)  + (d - u) ) ]

                                   [             2          2          2  ]
                                   [ sqrt((c - z)  + (b - y)  + (a - x) ) ]
                           Col 2 = [                                      ]
                                   [             2          2          2  ]
                                   [ sqrt((f - z)  + (e - y)  + (d - x) ) ]

 -- Variável de opção: matrix_element_transpose
     Valor por omissão: 'false'

     'matrix_element_transpose' é a operação aplicada a cada elemento de
     uma matriz quando for uma transposta.  A 'matrix_element_mult' pode
     ser atribuído qualquer operador unário.  O valor atribuído pode ser
     nome de um operador entre aspas duplas, o nome de uma função, ou
     uma expressão lambda.

     Quando 'matrix_element_transpose' for igual a 'transpose', a função
     'transpose' é aplicada a todo elemento.  Quando
     'matrix_element_transpose' for igual a 'nonscalars', a função
     'transpose' é aplicada a todo elemento não escalar.  Se algum
     elemento é um átomo, a opção 'nonscalars' aplica 'transpose'
     somente se o átomo for declarado não escalar, enquanto a opção
     'transpose' sempre aplica 'transpose'.

     O valor padrão, 'false', significa nenhuma operação é aplicada.

     Veja também 'matrix_element_add' e 'matrix_element_mult'.

     Exemplos:

          (%i1) declare (a, nonscalar)$
          (%i2) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o2)                   [              ]
                                  [      b       ]
          (%i3) matrix_element_transpose: nonscalars$
          (%i4) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o4)                   [              ]
                                  [      b       ]
          (%i5) matrix_element_transpose: transpose$
          (%i6) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o6)                   [              ]
                                  [ transpose(b) ]
          (%i7) matrix_element_transpose: lambda ([x], realpart(x) - %i*imagpart(x))$
          (%i8) m: matrix ([1 + 5*%i, 3 - 2*%i], [7*%i, 11]);
                               [ 5 %i + 1  3 - 2 %i ]
          (%o8)                [                    ]
                               [   7 %i       11    ]
          (%i9) transpose (m);
                                [ 1 - 5 %i  - 7 %i ]
          (%o9)                 [                  ]
                                [ 2 %i + 3    11   ]

 -- Função: mattrace (<M>)
     Retorna o traço (que é, a soma dos elementos sobre a diagonal
     principal) da matriz quadrada <M>.

     'mattrace' é chamada por 'ncharpoly', uma alternativa para
     'charpoly' do Maxima.

     'load ("nchrpl")' chama essa função.

 -- Função: minor (<M>, <i>, <j>)
     Retorna o <i>, <j> menor do elemento localizado na linha <i> coluna
     <j> da matriz <M>.  Que é <M> com linha <i> e coluna <j> ambas
     removidas.

 -- Função: ncexpt (<a>, <b>)
     Se uma expressão exponencial não comutativa é muito alta para ser
     mostrada como '<a>^^<b>' aparecerá como 'ncexpt (<a>,<b>)'.

     'ncexpt' não é o nome de uma função ou operador; o nome somente
     aparece em saídas, e não é reconhecido em entradas.

 -- Função: ncharpoly (<M>, <x>)
     Retorna o polinómio característico da matriz <M> com relação a <x>.
     Essa é uma alternativa para 'charpoly' do Maxima.

     'ncharpoly' trabalha pelo cálculo dos traços das potências na dada
     matriz, que são sabidos serem iguais a somas de potências das
     raízes do polinómio característico.  Para essas quantidade a função
     simétrica das raízes pode ser calculada, que nada mais são que os
     coeficientes do polinómio característico.  'charpoly' trabalha
     formatando o determinante de '<x> * ident [n] - a'.  Dessa forma
     'ncharpoly' é vencedor, por exemplo, no caso de largas e densas
     matrizes preencidas com inteiros, desde que isso evite inteiramente
     a aritmética polinomial.

     'load ("nchrpl")' loads this file.

 -- Função: newdet (<M>, <n>)
     Calcula o determinante de uma matriz ou array <M> pelo algoritmo da
     árvore menor de Johnson-Gentleman.  O argumento <n> é a ordem; isso
     é opcional se <M> for uma matriz.

 -- Declaração: nonscalar
     Faz átomos ser comportarem da mesma forma que uma lista ou matriz
     em relação ao operador do ponto.

 -- Função: nonscalarp (<expr>)
     Retorna 'true' se <expr> é um não escalar, i.e., isso contém átomos
     declarados como não escalares, listas, ou matrizes.

 -- Função: permanent (<M>, <n>)
     Calcula o permanente da matriz <M>.  Um permanente é como um
     determinante mas sem mudança de sinal.

 -- Função: rank (<M>)
     Calcula o posto da matriz <M>.  Que é, a ordem do mais largo
     determinante não singular de <M>.

     <rank> pode retornar uma resposta ruim se não puder determinar que
     um elemento da matriz que é equivalente a zero é realmente isso.

 -- Variável de opção: ratmx
     Valor por omissão: 'false'

     Quando 'ratmx' é 'false', adição, subtração, e multiplicação para
     determinantes e matrizes são executados na representação dos
     elementos da matriz e fazem com que o resultado da inversão de
     matrizes seja esquerdo na representação geral.

     Quando 'ratmx' é 'true', as 4 operações mencionadas acima são
     executadas na forma CRE e o resultado da matriz inversa é dado na
     forma CRE. Note isso pode fazer com que os elementos sejam
     expandidos (dependendo da escolha de 'ratfac') o que pode não ser
     desejado sempre.

 -- Função: row (<M>, <i>)
     retorna a <i>'ésima linha da matriz <M>.  O valor de retorno é uma
     matriz.

 -- Variável de opção: scalarmatrixp
     Valor por omissão: 'true'

     Quando 'scalarmatrixp' é 'true', então sempre que uma matriz 1 x 1
     é produzida como um resultado de cálculos o produto do ponto de
     matrizes é simplificado para um escalar, a saber o elemento
     solitário da matriz.

     Quando 'scalarmatrixp' é 'all', então todas as matrizes 1 x 1 serão
     simplificadas para escalares.

     Quando 'scalarmatrixp' é 'false', matrizes 1 x 1 não são
     simplificadas para escalares.

 -- Função: scalefactors (<coordinatetransform>)
     Aqui coordinatetransform avalia para a forma [[expresão1,
     expresão2, ...], indeterminação1, indeterminação2, ...], onde
     indeterminação1, indeterminação2, etc.  são as variáveis de
     coordenadas curvilíneas e onde a escolha de componentes cartesianas
     retangulares é dada em termos das coordenadas curvilíneas por
     [expresão1, expresão2, ...].  'coordinates' é escolhida para o
     vector [indeterminação1, indeterminação2,...], e 'dimension' é
     escolhida para o comprimento desse vector.  SF[1], SF[2], ...,
     SF[DIMENSION] são escohidos para factores de escala de coordenada,
     e 'sfprod' é escohido para o produto desse factores de escala.
     Inicialmente, 'coordinates' é [X, Y, Z], 'dimension' é 3, e
     SF[1]=SF[2]=SF[3]=SFPROD=1, correspondendo a coordenadas
     Cartesianas retangulares 3-dimensional.  Para expandir uma expresão
     dentro de componentes físicos no sistema de coordenadas corrente ,
     existe uma função com uso da forma

 -- Função: setelmx (<x>, <i>, <j>, <M>)
     Atribue <x> para o (<i>, <j>)'ésimo elemento da matriz <M>, e
     retorna a matriz alterada.

     '<M> [<i>, <j>]: <x>' tem o mesmo efeito, mas retorna <x> em lugar
     de <M>.

 -- Função: similaritytransform (<M>)
 -- Função: simtran (<M>)
     'similaritytransform' calcula uma transformação homotética da
     matriz 'M'.  Isso retorna uma lista que é a saída do comando
     'uniteigenvectors'.  Em adição se o sinalizador 'nondiagonalizable'
     é 'false' duas matrizes globais 'leftmatrix' e 'rightmatrix' são
     calculadas.  Essas matrizes possuem a propriedade de 'leftmatrix .
     <M> . rightmatrix' é uma matriz diagonal com os autovalores de <M>
     sobre a diagonal.  Se 'nondiagonalizable' é 'true' as matrizes
     esquerda e direita não são computadas.

     Se o sinalizador 'hermitianmatrix' é 'true' então 'leftmatrix' é o
     conjugado complexo da transposta de 'rightmatrix'.  De outra forma
     'leftmatrix' é a inversa de 'rightmatrix'.

     'rightmatrix' é a matriz cujas colunas são os autovectores
     unitários de <M>.  Os outros sinalizadores (veja 'eigenvalues' e
     'eigenvectors') possuem o mesmo efeito desde que
     'similaritytransform' chama as outras funções no pacote com o
     objectivo de estar habilitado para a forma 'rightmatrix'.

     'load ("eigen")' chama essa função.

     'simtran' é um sinônimo para 'similaritytransform'.

 -- Variável de opção: sparse
     Valor por omissão: 'false'

     Quando 'sparse' é 'true', e se 'ratmx' é 'true', então
     'determinant' usará rotinas especiais para calcular determinantes
     esparsos.

 -- Função: submatrix (<i_1>, ..., <i_m>, <M>, <j_1>, ..., <j_n>)
 -- Função: submatrix (<i_1>, ..., <i_m>, <M>)
 -- Função: submatrix (<M>, <j_1>, ..., <j_n>)
     Retorna uma nova matriz formada pela matrix <M> com linhas <i_1>,
     ..., <i_m> excluídas, e colunas <j_1>, ..., <j_n> excluídas.

 -- Função: transpose (<M>)
     Retorna a transposta de <M>.

     Se <M> é uma matriz, o valor de retorno é outra matriz <N> tal que
     'N[i,j] = M[j,i]'.

     Se <M> for uma lista, o valor de retorno é uma matrix <N> de
     'length (m)' linhas e 1 coluna, tal que 'N[i,1] = M[i]'.

     De outra forma <M> é um símbolo, e o valor de retorno é uma
     expressão substantiva ''transpose (<M>)'.

 -- Função: triangularize (<M>)
     Retorna a maior forma triangular da matriz 'M', como produzido
     através da eliminação de Gauss.  O valor de retorno é o mesmo que
     'echelon', excepto que o o coeficiente lider não nulo em cada linha
     não é normalizado para 1.

     'lu_factor' e 'cholesky' são outras funções que retornam matrizes
     triangularizadas.

          (%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                                 [  3   7  aa  bb ]
                                 [                ]
          (%o1)                  [ - 1  8  5   2  ]
                                 [                ]
                                 [  9   2  11  4  ]
          (%i2) triangularize (M);
                       [ - 1   8         5            2      ]
                       [                                     ]
          (%o2)        [  0   - 74     - 56         - 22     ]
                       [                                     ]
                       [  0    0    626 - 74 aa  238 - 74 bb ]

 -- Função: uniteigenvectors (<M>)
 -- Função: ueivects (<M>)
     Calcula autovectores unitários da matriz <M>.  O valor de retorno é
     uma lista de listas, a primeiro sublista é a saída do comando
     'eigenvalues', e as outras sublistas são os autovectores unitários
     da matriz correspondente a esses autovalores respectivamente.

     Os sinalizadores mencionados na descrição do comando 'eigenvectors'
     possuem o mesmo efeito aqui também.

     Quando 'knowneigvects' é 'true', o pacote 'eigen' assume que os
     autovectores da matriz são conhecidos para o utilizador são
     armazenados sob o nome global 'listeigvects'.  'listeigvects' pode
     ser ecolhido para uma lista similar à saída do comando
     'eigenvectors'.

     Se 'knowneigvects' é escolhido para 'true' e a lista de
     autovectores é dada a escolha do sinalizador 'nondiagonalizable'
     pode não estar correcta.  Se esse é o caso por favor ecolha isso
     para o valor correcto.  O autor assume que o utilizador sabe o que
     está fazendo e que não tentará diagonalizar uma matriz cujos
     autovectores não geram o mesmo espaço vectorial de dimensão
     apropriada.

     'load ("eigen")' chama essa função.

     'ueivects' é um sinônimo para 'uniteigenvectors'.

 -- Função: unitvector (<x>)
 -- Função: uvect (<x>)
     Retorna <x>/norm(<x>); isso é um vector unitário na mesma direção
     que <x>.

     'load ("eigen")' chama essa função.

     'uvect' é um sinônimo para 'unitvector'.

 -- Função: vectorsimp (<expr>)
     Aplica simplificações e expansões conforme os seguintes
     sinalizadores globais:

     'expandall', 'expanddot', 'expanddotplus', 'expandcross',
     'expandcrossplus', 'expandcrosscross', 'expandgrad',
     'expandgradplus', 'expandgradprod', 'expanddiv', 'expanddivplus',
     'expanddivprod', 'expandcurl', 'expandcurlplus', 'expandcurlcurl',
     'expandlaplacian', 'expandlaplacianplus', e 'expandlaplacianprod'.

     Todos esses sinalizadores possuem valor padrão 'false'.  O sufixo
     'plus' refere-se a utilização aditivamente ou distribuitivamente.
     O sufixo 'prod' refere-se a expansão para um operando que é
     qualquer tipo de produto.

     'expandcrosscross'
          Simplifica p ~ (q ~ r) para (p . r)*q - (p . q)*r.
     'expandcurlcurl'
          Simplifica curl curl p para grad div p + div grad p.
     'expandlaplaciantodivgrad'
          Simplifica laplacian p para div grad p.
     'expandcross'
          Habilita 'expandcrossplus' e 'expandcrosscross'.
     'expandplus'
          Habilita 'expanddotplus', 'expandcrossplus', 'expandgradplus',
          'expanddivplus', 'expandcurlplus', e 'expandlaplacianplus'.
     'expandprod'
          Habilita 'expandgradprod', 'expanddivprod', e
          'expandlaplacianprod'.

     Esses sinalizadores foram todos declarados 'evflag'.

 -- Variável de opção: vect_cross
     Valor por omissão: 'false'

     Quando 'vect_cross' é 'true', isso permite DIFF(X~Y,T) trabalhar
     onde ~ é definido em SHARE;VECT (onde VECT_CROSS é escolhido para
     'true', de qualqeur modo.)

 -- Função: zeromatrix (<m>, <n>)
     Retorna um matriz <m> por <n>, com todos os elementos sendo zero.

 -- Símbolo especial: [
 -- Símbolo especial: ]
     '[' e ']' marcam o omeço e o fim, respectivamente, de uma lista.

     '[' e ']' também envolvem os subscritos de uma lista, array, array
     desordenado, ou função array.

     Exemplos:

          (%i1) x: [a, b, c];
          (%o1)                       [a, b, c]
          (%i2) x[3];
          (%o2)                           c
          (%i3) array (y, fixnum, 3);
          (%o3)                           y
          (%i4) y[2]: %pi;
          (%o4)                          %pi
          (%i5) y[2];
          (%o5)                          %pi
          (%i6) z['foo]: 'bar;
          (%o6)                          bar
          (%i7) z['foo];
          (%o7)                          bar
          (%i8) g[k] := 1/(k^2+1);
                                            1
          (%o8)                     g  := ------
                                     k     2
                                          k  + 1
          (%i9) g[10];
                                          1
          (%o9)                          ---
                                         101


File: maxima.info,  Node: Funções Afins,  Next: itensor,  Prev: Matrizes e Álgebra Linear,  Up: Top

26 Funções Afins
****************

* Menu:

* Definições para Funções Afins::      


File: maxima.info,  Node: Definições para Funções Afins,  Prev: Funções Afins,  Up: Funções Afins

26.1 Definições para Funções Afins
==================================

 -- Função: fast_linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ...,
          <x_n>])
     Resolve equações lineares simultâneas <expr_1>, ..., <expr_m> para
     as variáveis <x_1>, ..., <x_n>.  Cada <expr_i> pode ser uma equação
     ou uma expressão geral; se for dada como uma expressão geral, será
     tratada como uma equação na forma '<expr_i> = 0'.

     O valor de retorno é uma lista de equações da forma '[<x_1> =
     <a_1>, ..., <x_n> = <a_n>]' onde <a_1>, ..., <a_n> são todas livres
     de <x_1>, ..., <x_n>.

     'fast_linsolve' é mais rápido que 'linsolve' para sistemas de
     equações que são esparsas.

     Para usar essa função escreva primeiramente 'load(affine)'.

 -- Função: grobner_basis ([<expr_1>, ..., <expr_m>])
     Retorna uma base de Groebner para as equações <expr_1>, ...,
     <expr_m>.  A funçã 'polysimp' pode então ser usada para simplificar
     outras funções relativas às equações.

          grobner_basis ([3*x^2+1, y*x])$

          polysimp (y^2*x + x^3*9 + 2) ==> -3*x + 2

     'polysimp(f)' produz 0 se e somente se <f> está no ideal gerado por
     <expr_1>, ..., <expr_m>, isto é, se e somente se <f> for uma
     combinação polinomial dos elementos de <expr_1>, ..., <expr_m>.

     Para usar essa função escreva primeiramente 'load(affine)'.

 -- Função: set_up_dot_simplifications (<eqns>, <check_through_degree>)
 -- Função: set_up_dot_simplifications (<eqns>)
     As <eqns> são equações polinomiais em variáveis não comutativas.  O
     valor de 'current_variables' é uma lista de variáveis usadas para
     calcular graus.  As equações podem ser homogéneas, de forma a que o
     procedimento termine.

     Se tiver optado por sobreposição de simplificações em
     'dot_simplifications' acima do grau de <f>, então o seguinte é
     verdadeiro: 'dotsimp (<f>)' retorna 0 se, e somente se, <f> está no
     ideal gerado pelas equações, i.e., se e somente se <f> for uma
     combinação polinomial dos elementos das equações.

     O grau é aquele retornado por 'nc_degree'.  Isso por sua vez é
     influenciado pelos pesos das variáveis individuais.

     Para usar essa função escreva primeiramente 'load(affine)'.

 -- Função: declare_weights (<x_1>, <w_1>, ..., <x_n>, <w_n>)
     Atribui pesos <w_1>, ..., <w_n> to <x_1>, ..., <x_n>,
     respectivamente.  Esses são pesos usados em cálculos 'nc_degree'.

     Para usar essa função escreva primeiramente 'load(affine)'.

 -- Função: nc_degree (<p>)
     Retorna o grau de um polinómio não comutativo <p>.  Veja
     'declare_weights'.

     Para usar essa função escreva primeiramente 'load(affine)'.

 -- Função: dotsimp (<f>)
     Retorna 0 se e somente se <f> for um ideal gerado pelas equações,
     i.e., se e somente se <f> for uma combinação polinomial dos
     elementos das equações.

     Para usar essa função escreva primeiramente 'load(affine)'.

 -- Função: fast_central_elements ([<x_1>, ..., <x_n>], <n>)
     Se 'set_up_dot_simplifications' tiver sido feito previamente, ache
     o polinómio central nas variáveis <x_1>, ..., <x_n> no grau dado,
     <n>.

     Por exemplo:
          set_up_dot_simplifications ([y.x + x.y], 3);
          fast_central_elements ([x, y], 2);
          [y.y, x.x];

     Para usar essa função escreva primeiramente 'load(affine)'.

 -- Função: check_overlaps (<n>, <add_to_simps>)
     Verifica as sobreposições através do grau <n>, garantindo que tem
     regras de simplificaçõ suficientes em cada grau, para 'dotsimp'
     trabalhar correctamente.  Esse processo pode ser mais rápido se
     souber de antemão a dimensão do espaço de monómios.  Se for de
     dimensão global finita, então 'hilbert' pode ser usada.  Se não
     conhece as dimensões monomiais, não especifique nenhum
     'rank_function'.  Um terceiro argumento opcional, 'reset', 'false'
     diz para não se incomodar em perguntar sobre reiniciar coisas.

     Para usar essa função escreva primeiramente 'load(affine)'.

 -- Função: mono ([<x_1>, ..., <x_n>], <n>)
     Retorna a lista de monómios independentes relativamente à
     simplificação actual do grau <n> nas variáveis <x_1>, ..., <x_n>.

     Para usar essa função escreva primeiramente 'load(affine)'.

 -- Função: monomial_dimensions (<n>)
     Calcula a série de Hilbert através do grau <n> para a algebra
     corrente.

     Para usar essa função escreva primeiramente 'load(affine)'.

 -- Função: extract_linear_equations ([<p_1>, ..., <p_n>], [<m_1>, ...,
          <m_n>])

     Faz uma lista dos coeficientes dos polinómios não comutativos
     <p_1>, ..., <p_n> dos monomios não comutatvos <m_1>, ..., <m_n>.
     Os coeficientes podem ser escalares.  Use 'list_nc_monomials' para
     construir a lista dos monómios.

     Para usar essa função escreva primeiramente 'load(affine)'.

 -- Função: list_nc_monomials ([<p_1>, ..., <p_n>])
 -- Função: list_nc_monomials (<p>)

     Retorna uma lista de monómios não comutativos que ocorrem em um
     polinómio <p> ou em uma lista de polinómios <p_1>, ..., <p_n>.

     Para usar essa função escreva primeiramente 'load(affine)'.

 -- Variável de opção: all_dotsimp_denoms
     Valor por omissão: 'false'

     Quando 'all_dotsimp_denoms' é uma lista, os denominadores
     encontrados por 'dotsimp' são adicionados ao final da lista.
     'all_dotsimp_denoms' pode ser iniciado como uma lista vazia '[]'
     antes chamando 'dotsimp'.

     Por padrão, denominadores não são colectados por 'dotsimp'.


File: maxima.info,  Node: itensor,  Next: ctensor,  Prev: Funções Afins,  Up: Top

27 itensor
**********

* Menu:

* Introdução a itensor::
* Definições para itensor::


File: maxima.info,  Node: Introdução a itensor,  Next: Definições para itensor,  Prev: itensor,  Up: itensor

27.1 Introdução a itensor
=========================

Maxima implementa a manipulação de tensores simbólicos d dois tipos
distintos: manipulação de componentes de tensores (pacote 'ctensor') e
manipulação de tensores indiciais (pacote 'itensor').

Note bem: Por favor veja a nota sobre 'nova notação de tensor' abaixo.

Manipulação de componentes de tensores significa que objectos do tipo
tensor geométrico são representados como arrays ou matrizes.  Operações
com tensores tais com contração ou diferenciação covariante são
realizadas sobre índices (que ocorrem exactamente duas vezes) repetidos
com declarações 'do'.  Isto é, se executa explicitamente operações sobre
as componentes apropriadas do tensor armazenadas em um array ou uma
matriz.

Manipulação tensorial de índice é implementada através da representação
de tensores como funções e suas covariantes, contravariantes e índices
de derivação.  Operações com tensores como contração ou diferenciação
covariante são executadas através de manipulação dos índices em si
mesmos em lugar das componentes para as quais eles correspondem.

Esses dois métodos aproximam-se do tratamento de processos diferenciais,
algébricos e analíticos no contexto da geometria de Riemannian possuem
várias vantagens e desvantagens as quais se revelam por si mesmas
somente apesar da natureza particular e dificuldade dos problemas de
utilizador.  Todavia, se pode ter em mente as seguintes características
das duas implementações:

As representações de tensores e de operações com tensores explicitamente
em termos de seus componntes tornam o pacote 'ctensor' fácil de usar.
Especificação da métrica e o cálculo de tensores induzidos e invariantes
é directo.  Embora todas a capacidade de simplificação poderosa do
Maxima está em manusear, uma métrica complexa com intrincada dependência
funcional e de coordenadas pode facilmente conduzir a expressões cujo
tamanho é excessivo e cuja estrutura está escondida.  Adicionalmente,
muitos cálculos envolvem expressões intermédias cujo crescimento fazem
com que os programas terminem antes de serem completados.  Através da
experiência, um utilizador pode evitar muitas dessas dificuldade.

O motivo de caminhos especiais através dos quais tensores e operações de
tensores são representados em termos de operações simbólicas sobre seus
índices, expressões cujas representação de componentes podem ser não
gerenciaveis da forma comum podem algumas vezes serem grandemente
simplificadas através do uso das rotinas especiais para objectos
simétricos em 'itensor'.  Nesse caminho a estrutura de uma expressão
grande pode ser mais transparente.  Por outro lado, o motivo da
representação indicial especial em 'itensor', faz com que em alguns
casos o utilizador possa encontrar dificuldade com a especificação da
métrica, definição de função, e a avaliação de objectos "indexados"
diferenciados.

27.1.1 Nova notação d tensores
------------------------------

Até agora, o pacote 'itensor' no Maxima tinha usado uma notação que
algumas vezes conduzia a ordenação incorrecta de índices.  Considere o
seguinte, por exemplo:

     (%i2) imetric(g);
     (%o2)                                done
     (%i3) ishow(g([],[j,k])*g([],[i,l])*a([i,j],[]))$
                                      i l  j k
     (%t3)                           g    g    a
                                                i j
     (%i4) ishow(contract(%))$
                                           k l
     (%t4)                                a

O resultado está incorrecto a menos que ocorra ser 'a' um tensor
simétrico.  A razão para isso é que embora 'itensor' mantenha
correctamente a ordem dentro do conjunto de índices covariantes e
contravariantes, assim que um índice é incrementado ou decrementado, sua
posição relativa para o outro conjunto de índices é perdida.

Para evitar esse problema, uma nova notação tem sido desenvolvida que
mantém total compatibilidade com a notação existente e pode ser usada
intercambiavelmente.  Nessa notação, índices contravariantes são
inseridos na posição apropriada na lista de índices covariantes, mas com
um sinal de menos colocado antes.  Funções como 'contract' e 'ishow'
estão agora consciente dessa nova notação de índice e podem processar
tensores apropriadamente.

Nessa nova notação, o exemplo anterior retorna um resultado correcto:

     (%i5) ishow(g([-j,-k],[])*g([-i,-l],[])*a([i,j],[]))$
                                      i l       j k
     (%t5)                           g    a    g
                                           i j
     (%i6) ishow(contract(%))$
                                           l k
     (%t6)                                a

Presentemente, o único código que faz uso dessa notação é a função
'lc2kdt'.  Através dessa notação, a função 'lc2kdt' encontra com êxito
resultados consistentes como a aplicação do tensor métrico para resolver
os símbolos de Levi-Civita sem reordenar para índices numéricos.

Uma vez que esse código é um tipo novo, provavelmente contém erros.
Enquanto esse tipo novo não tiver sido testado para garantir que ele não
interrompe nada usando a "antiga" notação de tensor, existe uma
considerável chance que "novos" tensores irão falhar em interoperar com
certas funções ou recursos.  Essas falhas serão corrigidas à medida que
forem encontradas...  até então, seja cuidadoso!

27.1.2 Manipulação de tensores indiciais
----------------------------------------

o pacote de manipulação de tensores indiciais pode ser chamado através
de 'load(itensor)'.  Demonstações estão também disponíveis: tente
'demo(tensor)'.  Em 'itensor' um tensor é representado como um "objecto
indexado" .  Um "objecto indexado" é uma função de 3 grupos de índices
os quais representam o covariante, o contravariante e o índice de
derivação.  Os índices covariantes são especificados através de uma
lista com o primeiro argumento para o objecto indexado, e os índices
contravariantes através de uma lista como segundo argumento.  Se o
objecto indexado carece de algum desses grupos de índices então a lista
vazia '[]' é fornecida como o argumento correspondente.  Dessa forma,
'g([a,b],[c])' representa um objecto indexado chamado 'g' o qual tem
dois índices covariantes '(a,b)', um índice contravariante ('c') e não
possui índices de derivação.

Os índices de derivação, se estiverem presente, são anexados ao final
como argumentos adicionais para a função numérica representando o
tensor.  Eles podem ser explicitamente especificado pelo utilizador ou
serem criados no processo de diferenciação com relação a alguma variável
coordenada.  Uma vez que diferenciação ordinária é comutativa, os
índices de derivação são ordenados alfanumericamente, a menos que
'iframe_flag' seja escolhida para 'true', indicando que um referencial
métrico está a ser usado.  Essa ordenação canónica torna possível para
Maxima reconhecer que, por exemplo, 't([a],[b],i,j)' é o mesmo que
't([a],[b],j,i)'.  Diferenciação de um objecto indexado com relação a
alguma coordenada cujos índices não aparecem como um argumento para o
objecto indexado podem normalmente retornar zero.  Isso é porque Maxima
pode não saber que o tensor representado através do objecto indexado
possívelmente depende implicitamente da respectiva coordenada.  Pela
modificação da função existente no Maxima, 'diff', em 'itensor', Maxima
sabe assumir que todos os objectos indexados dependem de qualquer
variável de diferenciação a menos que seja declarado de outra forma.
Isso torna possível para a convençào de somatório ser extendida para
índices derivativos.  Pode ser verificado que 'itensor' não possui a
compatibilidade de incrementar índices derivativos, e então eles são
sempre tratados como covariantes.

As seguintes funções estão disponíveis no pacote tensor para manipulação
de objectos.  Actualmente, com relação às rotinas de simplificação, é
assumido que objectos indexados não possuem por padrão propriedades
simétricas.  Isso pode ser modificado através da escolha da variável
'allsym[false]' para 'true', o que irá resultar no tratamento de todos
os objectos indexados completamente simétricos em suas listas de índices
covariantes e simétricos em suas listas de índices contravariantes.

O pacote 'itensor' geralmente trata tensores como objectos opacos.
Equações tensoriais são manipuladas baseadas em regras algébricas,
especificamente simetria e regras de contração.  Adicionalmente, o
pacote 'itensor' não entende diferenciação covariante, curvatura, e
torsão.  Cálculos podem ser executados relativamente a um métrica de
referenciais de movimento, dependendo da escolha para a variável
'iframe_flag'.

Uma sessão demonstrativa abaixo mostra como chamar o pacote 'itensor',
especificando o nome da métrica, e executando alguns cálculos simples.

     (%i1) load(itensor);
     (%o1)      /share/tensor/itensor.lisp
     (%i2) imetric(g);
     (%o2)                                done
     (%i3) components(g([i,j],[]),p([i,j],[])*e([],[]))$
     (%i4) ishow(g([k,l],[]))$
     (%t4)                               e p
                                            k l
     (%i5) ishow(diff(v([i],[]),t))$
     (%t5)                                  0
     (%i6) depends(v,t);
     (%o6)                               [v(t)]
     (%i7) ishow(diff(v([i],[]),t))$
                                         d
     (%t7)                               -- (v )
                                         dt   i
     (%i8) ishow(idiff(v([i],[]),j))$
     (%t8)                                v
                                           i,j
     (%i9) ishow(extdiff(v([i],[]),j))$
     (%t9)                             v    - v
                                        j,i    i,j
                                       -----------
                                            2
     (%i10) ishow(liediff(v,w([i],[])))$
                                    %3          %3
     (%t10)                        v   w     + v   w
                                        i,%3    ,i  %3
     (%i11) ishow(covdiff(v([i],[]),j))$
                                                   %4
     (%t11)                        v    - v   ichr2
                                    i,j    %4      i j
     (%i12) ishow(ev(%,ichr2))$
                    %4 %5
     (%t12) v    - g      v   (e p       + e   p     - e p       - e    p
             i,j           %4     j %5,i    ,i  j %5      i j,%5    ,%5  i j

                                                     + e p       + e   p    )/2
                                                          i %5,j    ,j  i %5
     (%i13) iframe_flag:true;
     (%o13)                               true
     (%i14) ishow(covdiff(v([i],[]),j))$
                                                  %6
     (%t14)                        v    - v   icc2
                                    i,j    %6     i j
     (%i15) ishow(ev(%,icc2))$
                                                  %6
     (%t15)                        v    - v   ifc2
                                    i,j    %6     i j
     (%i16) ishow(radcan(ev(%,ifc2,ifc1)))$
                  %6 %8                    %6 %8
     (%t16) - (ifg      v   ifb       + ifg      v   ifb       - 2 v
                         %6    j %8 i             %6    i j %8      i,j

                                                         %6 %8
                                                    - ifg      v   ifb      )/2
                                                                %6    %8 i j
     (%i17) ishow(canform(s([i,j],[])-s([j,i])))$
     (%t17)                            s    - s
                                        i j    j i
     (%i18) decsym(s,2,0,[sym(all)],[]);
     (%o18)                               done
     (%i19) ishow(canform(s([i,j],[])-s([j,i])))$
     (%t19)                                 0
     (%i20) ishow(canform(a([i,j],[])+a([j,i])))$
     (%t20)                            a    + a
                                        j i    i j
     (%i21) decsym(a,2,0,[anti(all)],[]);
     (%o21)                               done
     (%i22) ishow(canform(a([i,j],[])+a([j,i])))$
     (%t22)                                 0


File: maxima.info,  Node: Definições para itensor,  Prev: Introdução a itensor,  Up: itensor

27.2 Definições para itensor
============================

27.2.1 Gerenciando objectos indexados
-------------------------------------

 -- Função: entertensor (<nome>)

     É uma função que, através da linha de comando, permite criar um
     objecto indexado chamado <nome> com qualquer número de índices de
     tensores e derivativos.  Ou um índice simples ou uma lista de
     índices (às quais podem ser nulas) são entradas aceitáveis (veja o
     exemplo sob 'covdiff').

 -- Função: changename (<antigo>, <novo>, <expr>)

     Irá mudar o nome de todos os objectos indexados chamados <antigo>
     para <novo> em <expr>.  <antigo> pode ser ou um símbolo ou uma
     lista da forma '[<nome>, <m>, <n>]' nesse caso somente esses
     objectos indexados chamados <nome> com índice covariante <m> e
     índice contravariante <n> serão renomeados para <novo>.

 -- Função: listoftens

     Lista todos os tensores em uma expressão tensorial, incluindo seus
     índices.  E.g.,


          (%i6) ishow(a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e)$
                                                   k
          (%t6)                        d e c    + a    b
                                            x y    i j  u,v
          (%i7) ishow(listoftens(%))$
                                         k
          (%t7)                        [a   , b   , c   , d]
                                         i j   u,v   x y

 -- Função: ishow (<expr>)

     Mostra <expr> com os objectos indexados tendo seus índices
     covariantes como subscritos e índices contravariantes como
     sobrescritos.  Os índices derivativos são mostrados como
     subscritos, separados dos índices covariantes por uma vírgula (veja
     os exemplos através desse documento).

 -- Função: indices (<expr>)

     Retorna uma lista de dois elementos.  O primeiro é uma lista de
     índices livres em <expr> (aqueles que ocorrem somente uma vez).  O
     segundo é uma lista de indices que ocorrem exactamente duas vezes
     em <expr> (dummy) como demonstra o seguinte exemplo.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i,j],[k,l],m,n)*b([k,o],[j,m,p],q,r))$
                                          k l      j m p
          (%t2)                          a        b
                                          i j,m n  k o,q r
          (%i3) indices(%);
          (%o3)                 [[l, p, i, n, o, q, r], [k, j, m]]

     Um produto de tensores contendo o mesmo índice mais que duas vezes
     é sintaticamente ilegal.  'indices' tenta lidar com essas
     expressões de uma forma razoável; todavia, quando 'indices' é
     chamada para operar sobre tal uma expressão ilegal, seu
     comportamento pode ser considerado indefinido.

 -- Função: rename (<expr>)
 -- Função: rename (<expr>, <contador>)

     Retorna uma expressão equivalente para <expr> mas com índices que
     ocorrem exactamente duas vezes em cada termo alterado do conjunto
     '[%1, %2,...]', se o segundo argumento opcional for omitido.  De
     outra forma, os índices que ocorrem exactamente duas vezes são
     indexados começando no valor de <contador>.  Cada índice que ocorre
     exactamente duas vezes em um produto será diferente.  Para uma
     adição, 'rename' irá operar sobre cada termo na a adição zerando o
     contador com cada termo.  Nesse caminho 'rename' pode servir como
     um simplificador tensorial.  Adicionalmente, os índices serão
     ordenados alfanumericamente (se 'allsym' for 'true') com relação a
     índices covariantes ou contravariantes dependendo do valor de
     'flipflag'.  Se 'flipflag' for 'false' então os índices serão
     renomeados conforme a ordem dos índices contravariantes.  Se
     'flipflag' for 'true' a renomeação ocorrerá conforme a ordem dos
     índices covariantes.  Isso muitas vezes ajuda que o efeito
     combinado dos dois restantes sejam reduzidos a uma expressão de
     valor um ou mais que um por si mesma.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) allsym:true;
          (%o2)                                true
          (%i3) g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%4],[%3])*
          ichr2([%2,%3],[u])*ichr2([%5,%6],[%1])*ichr2([%7,r],[%2])-
          g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%2],[u])*
          ichr2([%3,%5],[%1])*ichr2([%4,%6],[%3])*ichr2([%7,r],[%2]),noeval$
          (%i4) expr:ishow(%)$

                 %4 %5  %6 %7      %3         u          %1         %2
          (%t4) g      g      ichr2      ichr2      ichr2      ichr2
                                   %1 %4      %2 %3      %5 %6      %7 r

                        %4 %5  %6 %7      u          %1         %3         %2
                     - g      g      ichr2      ichr2      ichr2      ichr2
                                          %1 %2      %3 %5      %4 %6      %7 r
          (%i5) flipflag:true;
          (%o5)                                true
          (%i6) ishow(rename(expr))$
                 %2 %5  %6 %7      %4         u          %1         %3
          (%t6) g      g      ichr2      ichr2      ichr2      ichr2
                                   %1 %2      %3 %4      %5 %6      %7 r

                        %4 %5  %6 %7      u          %1         %3         %2
                     - g      g      ichr2      ichr2      ichr2      ichr2
                                          %1 %2      %3 %4      %5 %6      %7 r
          (%i7) flipflag:false;
          (%o7)                                false
          (%i8) rename(%th(2));
          (%o8)                                  0
          (%i9) ishow(rename(expr))$
                 %1 %2  %3 %4      %5         %6         %7        u
          (%t9) g      g      ichr2      ichr2      ichr2     ichr2
                                   %1 %6      %2 %3      %4 r      %5 %7

                        %1 %2  %3 %4      %6         %5         %7        u
                     - g      g      ichr2      ichr2      ichr2     ichr2
                                          %1 %3      %2 %6      %4 r      %5 %7

 -- Variável de Opção: flipflag

     Valor por omissão: 'false'.  Se 'false' então os índices irão ser
     renomeados conforme a ordem dos índices contravariantes, de outra
     forma serão ordenados conforme a ordem dos índices covariantes.

     Se 'flipflag' for 'false' então 'rename' forma uma lista de índices
     contravariantes na ordem em que forem encontrados da esquerda para
     a direita (se 'true' então de índices contravariantes).  O primeiro
     índice que ocorre exactamente duas vezes na lista é renomeado para
     '%1', o seguinte para '%2', etc.  Então a ordenação ocorre após a
     ocorrência do 'rename' (veja o exemplo sob 'rename').

 -- Função: defcon (<tensor_1>)
 -- Função: defcon (<tensor_1>, <tensor_2>, <tensor_3>)
     Dado <tensor_1> a propriedade que a contração de um produto do
     <tensor_1> e do <tensor_2> resulta em <tensor_3> com os índices
     apropriados.  Se somente um argumento, <tensor_1>, for dado, então
     a contração do produto de <tensor_1> com qualquer objecto indexado
     tendo os índices apropriados (digamos 'my_tensor') irá retornar
     como resultado um objecto indexado com aquele nome, i.e.
     'my_tensor', e com uma nova escolha de índices refletindo as
     contrações executadas.  Por exemplo, se 'imetric:g', então
     'defcon(g)' irá implementar o incremento e decremento de índices
     através da contração com o tensor métrico.  Mais de uma 'defcon'
     pode ser dada para o mesmo objecto indexado; o último fornecido que
     for aplicado a uma contração particular será usado.  'contractions'
     é uma lista de objectos indexados que tenham fornecido propriedades
     de contrações com 'defcon'.

 -- Função: remcon (<tensor_1>, ..., <tensor_n>)
 -- Função: remcon (all)
     Remove todas as propriedades de contração de <tensor_1>, ...,
     <tensor_n>).  'remcon(all)' remove todas as propriedades de
     contração de todos os objectos indexados.

 -- Função: contract (<expr>)

     Realiza contrações tensoriais em <expr> a qual pode ser qualquer
     combinação de adições e produtos.  Essa função usa a informação
     dada para a função 'defcon'.  Para melhores resultados, 'expr' pode
     ser completamente expandida.  'ratexpand' é o meio mais rápido para
     expandir produtos e expoentes de adições se não existirem variáveis
     nos denominadores dos termos.  O comutador 'gcd' pode ser 'false'
     se cancelamentos de máximo divisor comum forem desnecessários.

 -- Função: indexed_tensor (<tensor>)

     Deve ser executada antes de atribuir componentes para um <tensor>
     para o qual um valor interno já existe como com 'ichr1', 'ichr2',
     'icurvature'.  Veja o exemplo sob 'icurvature'.

 -- Função: components (<tensor>, <expr>)

     Permite que se atribua um valor indicial a uma expressão <expr>
     dando os valores das componentes do <tensor>.  Esses são
     automaticamente substituídos para o tensor mesmo que isso ocorra
     com todos os seus índices.  O tensor deve ser da forma
     't([...],[...])' onde qualquer lista pode ser vazia.  <expr> pode
     ser qualquer expressão indexada envolvendo outros objectos com os
     mesmos índices livres que <tensor>.  Quando usada para atribuir
     valores a um tensor métrico no qual as componentes possuem índices
     que ocorrem exactamente duas vezes se deve ser cuidadoso para
     definir esses índices de forma a evitar a geração de índices que
     ocorrem exactamente duas vezes e que são múltiplos.  a remoção
     dessas atribuições é dada para a função 'remcomps'.

     É importante ter em mente que 'components' cuida somente da
     valência de um tensor, e que ignora completamente qualquer
     ordenação particular de índices.  Dessa forma atribuindo
     componentes a, digamos, 'x([i,-j],[])', 'x([-j,i],[])', ou
     'x([i],[j])' todas essas atribuições produzem o mesmo resultado, a
     saber componentes sendo atribuidas a um tensor chamado 'x' com
     valência '(1,1)'.

     Componentes podem ser atribuidas a uma expressão indexada por
     quatro caminhos, dois dos quais envolvem o uso do comando
     'components':

     1) Como uma expressão indexada.  Por exemplo:


          (%i2) components(g([],[i,j]),e([],[i])*p([],[j]))$
          (%i3) ishow(g([],[i,j]))$
                                                i  j
          (%t3)                                e  p

     2) Como uma matriz:


          (%i6) components(g([i,j],[]),lg);
          (%o6)                                done
          (%i7) ishow(g([i,j],[]))$
          (%t7)                                g
                                                i j
          (%i8) g([3,3],[]);
          (%o8)                                  1
          (%i9) g([4,4],[]);
          (%o9)                                 - 1

     3) Como uma função.  Pode usar uma função Maxima para especificar
     as componentes de um tensor baseado nesses índices.  Por exemplo,
     os seguintes códigos atribuem 'kdelta' a 'h' se 'h' tiver o mesmo
     número de índices covariantes e índices contravariantes e nenhum
     índice derivativo, e atribui 'kdelta' a 'g' caso as condições
     anteriores não sejam atendidas:


          (%i4) h(l1,l2,[l3]):=if length(l1)=length(l2) and length(l3)=0
            then kdelta(l1,l2) else apply(g,append([l1,l2], l3))$
          (%i5) ishow(h([i],[j]))$
                                                    j
          (%t5)                               kdelta
                                                    i
          (%i6) ishow(h([i,j],[k],l))$
                                               k
          (%t6)                               g
                                               i j,l

     4) Usando a compatibilidade dos modelos de coincidência do Maxima,
     especificamente os comandos 'defrule' e 'applyb1':


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) matchdeclare(l1,listp);
          (%o2)                                done
          (%i3) defrule(r1,m(l1,[]),(i1:idummy(),
                g([l1[1],l1[2]],[])*q([i1],[])*e([],[i1])))$

          (%i4) defrule(r2,m([],l1),(i1:idummy(),
                w([],[l1[1],l1[2]])*e([i1],[])*q([],[i1])))$

          (%i5) ishow(m([i,n],[])*m([],[i,m]))$
                                              i m
          (%t5)                              m    m
                                                   i n
          (%i6) ishow(rename(applyb1(%,r1,r2)))$
                                     %1  %2  %3 m
          (%t6)                     e   q   w     q   e   g
                                                   %1  %2  %3 n


 -- Função: remcomps (<tensor>)

     Desassocia todos os valores de <tensor> que foram atribuídos com a
     função 'components'.

 -- Função: showcomps (<tensor>)

     Mostra atribuições de componentes de um tensor, feitas usando o
     comando 'components'.  Essa função pode ser particularmente útil
     quando uma matriz é atribuída a um tensor indicial usando
     'components', como demonstrado através do seguinte exemplo:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) load(itensor);
          (%o2)      /share/tensor/itensor.lisp
          (%i3) lg:matrix([sqrt(r/(r-2*m)),0,0,0],[0,r,0,0],
                          [0,0,sin(theta)*r,0],[0,0,0,sqrt((r-2*m)/r)]);
                         [         r                                     ]
                         [ sqrt(-------)  0       0              0       ]
                         [      r - 2 m                                  ]
                         [                                               ]
                         [       0        r       0              0       ]
          (%o3)          [                                               ]
                         [       0        0  r sin(theta)        0       ]
                         [                                               ]
                         [                                      r - 2 m  ]
                         [       0        0       0        sqrt(-------) ]
                         [                                         r     ]
          (%i4) components(g([i,j],[]),lg);
          (%o4)                                done
          (%i5) showcomps(g([i,j],[]));
                            [         r                                     ]
                            [ sqrt(-------)  0       0              0       ]
                            [      r - 2 m                                  ]
                            [                                               ]
                            [       0        r       0              0       ]
          (%t5)      g    = [                                               ]
                      i j   [       0        0  r sin(theta)        0       ]
                            [                                               ]
                            [                                      r - 2 m  ]
                            [       0        0       0        sqrt(-------) ]
                            [                                         r     ]
          (%o5)                                false

     O comando 'showcomps' pode também mostrar componentes de um tensor
     de categoria maior que 2.

 -- Função: idummy ()

     Incrementos 'icounter' e retorno como seu valor um índice da forma
     '%n' onde n é um inteiro positivo.  Isso garante que índices que
     ocorrem exactamente duas vezes e que são necessários na formação de
     expressões não irão conflitar com índices que já estiverem sendo
     usados (veja o exemplo sob 'indices').

 -- Variável de opção: idummyx
     Valor por omissão: '%'

     É o prefixo para índices que ocorrem exactamente duas vezes (veja o
     exemplo sob índices 'indices').

 -- Variável de Opção: icounter
     Valor por omissão: '1'

     Determina o sufixo numérico a ser usado na geração do próximo
     índice que ocorre exactamente duas vezes no pacote tensor.  O
     prefixo é determinado através da opção 'idummy' (padrão: '%').

 -- Função: kdelta (<L1>, <L2>)
     é a função delta generalizada de Kronecker definida no pacote
     'itensor' com <L1> a lista de índices covariantes e <L2> a lista de
     índices contravariantes.  'kdelta([i],[j])' retorna o delta de
     Kronecker comum.  O comando 'ev(<expr>,kdelta)' faz com que a
     avaliação de uma expressão contendo 'kdelta([],[])' se dê para a
     dimensão de multiplicação.

     No que conduzir a um abuso dessa notação, 'itensor' também permite
     'kdelta' ter 2 covariantes e nenhum contravariante, ou 2
     contravariantes e nenhum índice covariante, com efeito fornecendo
     uma compatibilidade para "matriz unitária" covariante ou
     contravariante.  Isso é estritamente considerado um recurso de
     programação e não significa implicar que 'kdelta([i,j],[])' seja um
     objecto tensorial válido.

 -- Função: kdels (<L1>, <L2>)

     Delta de Kronecker simetrizado, usado em alguns cálculos.  Por
     exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) kdelta([1,2],[2,1]);
          (%o2)                                 - 1
          (%i3) kdels([1,2],[2,1]);
          (%o3)                                  1
          (%i4) ishow(kdelta([a,b],[c,d]))$
                                       c       d         d       c
          (%t4)                  kdelta  kdelta  - kdelta  kdelta
                                       a       b         a       b
          (%i4) ishow(kdels([a,b],[c,d]))$
                                       c       d         d       c
          (%t4)                  kdelta  kdelta  + kdelta  kdelta
                                       a       b         a       b

 -- Função: levi_civita (<L>)
     é o tensor de permutação (ou de Levi-Civita) que retorna 1 se a
     lista <L> consistir de uma permutação par de inteiros, -1 se isso
     consistir de uma permutação ímpar, e 0 se alguns índices em <L>
     forem repetidos.

 -- Função: lc2kdt (<expr>)
     Simplifica expressões contendo os símbolos de Levi-Civita,
     convertendo esses para expressões delta de Kronecker quando
     possível.  A principal diferença entre essa função e simplesmente
     avaliar os simbolos de Levi-Civita é que a avaliação directa muitas
     vezes resulta em expressões Kronecker contendo índices numéricos.
     Isso é muitas vezes indesejável como na prevenção de simplificação
     adicional.  A função 'lc2kdt' evita esse problema, retornando
     expressões que são mais facilmente simplificadas com 'rename' ou
     'contract'.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) expr:ishow('levi_civita([],[i,j])*'levi_civita([k,l],[])*a([j],[k]))$
                                            i j  k
          (%t2)                  levi_civita    a  levi_civita
                                                 j            k l
          (%i3) ishow(ev(expr,levi_civita))$
                                            i j  k       1 2
          (%t3)                       kdelta    a  kdelta
                                            1 2  j       k l
          (%i4) ishow(ev(%,kdelta))$
                       i       j         j       i   k
          (%t4) (kdelta  kdelta  - kdelta  kdelta ) a
                       1       2         1       2   j

                                         1       2         2       1
                                  (kdelta  kdelta  - kdelta  kdelta )
                                         k       l         k       l
          (%i5) ishow(lc2kdt(expr))$
                               k       i       j    k       j       i
          (%t5)               a  kdelta  kdelta  - a  kdelta  kdelta
                               j       k       l    j       k       l
          (%i6) ishow(contract(expand(%)))$
                                           i           i
          (%t6)                           a  - a kdelta
                                           l           l

     A função 'lc2kdt' algumas vezes faz uso de tensores métricos.  Se o
     tensor métrico não tiver sido definido previamente com 'imetric',
     isso resulta em um erro.


          (%i7) expr:ishow('levi_civita([],[i,j])*'levi_civita([],[k,l])*a([j,k],[]))$
                                           i j            k l
          (%t7)                 levi_civita    levi_civita    a
                                                               j k
          (%i8) ishow(lc2kdt(expr))$
          Maxima encountered a Lisp error:

           Error in $IMETRIC [or a callee]:
           $IMETRIC [or a callee] requires less than two arguments.

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i9) imetric(g);
          (%o9)                                done
          (%i10) ishow(lc2kdt(expr))$
                   %3 i       k   %4 j       l     %3 i       l   %4 j       k
          (%t10) (g     kdelta   g     kdelta   - g     kdelta   g     kdelta  ) a
                              %3             %4               %3             %4   j k
          (%i11) ishow(contract(expand(%)))$
                                            l i      l i
          (%t11)                           a    - a g

 -- Função: lc_l

     Regra de simplificação usada para expressões contendo símbolos não
     avaliados de Levi-Civita ('levi_civita').  Juntamente com 'lc_u',
     pode ser usada para simplificar muitas expressões mais
     eficientemente que a avaliação de 'levi_civita'.  Por exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2)  el1:ishow('levi_civita([i,j,k],[])*a([],[i])*a([],[j]))$
                                       i  j
          (%t2)                       a  a  levi_civita
                                                       i j k
          (%i3) el2:ishow('levi_civita([],[i,j,k])*a([i])*a([j]))$
                                                 i j k
          (%t3)                       levi_civita      a  a
                                                        i  j
          (%i4) ishow(canform(contract(expand(applyb1(el1,lc_l,lc_u)))))$
          (%t4)                                  0
          (%i5) ishow(canform(contract(expand(applyb1(el2,lc_l,lc_u)))))$
          (%t5)                                  0

 -- Função: lc_u

     Regra de simplificação usada para expressões contendo símbolos não
     avaliados de Levi-Civita ('levi_civita').  Juntamente com 'lc_u',
     pode ser usada para simplificar muitas expressões mais
     eficientemente que a avaliação de 'levi_civita'.  Para detalhes,
     veja 'lc_l'.

 -- Função: canten (<expr>)
     Simplifica <expr> por renomeação (veja 'rename') e permutando
     índices que ocorrem exactamente duas vezes.  'rename' é restrito a
     adições de produto de tensores nos quais nenhum índice derivativo
     estiver presente.  Como tal isso é limitado e pode somente ser
     usado se 'canform' não for capaz de realizar a simplificação
     requerida.

     A função 'canten' retorna um resultado matematicamente correcto
     somente se seu argumento for uma expressão que é completamente
     simétrica em seus índices.  Por essa razão, 'canten' retorna um
     erro se 'allsym' não for posicionada em 'true'.

 -- Função: concan (<expr>)
     Similar a 'canten' mas também executa contração de índices.

27.2.2 Simetrias de tensores
----------------------------

 -- Variável de Opção: allsym

     Valor por omissão: 'false'.  Se 'true' então todos os objectos
     indexados são assumidos simétricos em todos os seus índices
     covariantes e contravariantes.  Se 'false' então nenhum simétrico
     de qualquer tipo é assumidos nesses índices.  Índices derivativos
     são sempre tomados para serem simétricos a menos que 'iframe_flag'
     seja escolhida para 'true'.

 -- Função: decsym (<tensor>, <m>, <n>, [<cov_1>, <cov_2>, ...],
          [<contr_1>, <contr_2>, ...])

     Declara propriedades de simetria para <tensor> de covariante <m> e
     <n> índices contravariantes.  As <cov_i> e <contr_i> são
     pseudofunções expressando relações de simetrias em meio a índices
     covariante e índices contravariantes respectivamente.  Esses são da
     forma 'symoper(<index_1>, <index_2>,...)' onde 'symoper' é um entre
     'sym', 'anti' ou 'cyc' e os <index_i> são inteiros indicando a
     posição do índice no <tensor>.  Isso irá declarar <tensor> para ser
     simétrico, antisimétrico ou cíclico respectivamente nos <index_i>.
     'symoper(all)' é também forma permitida que indica todos os índices
     obedecem à condição de simetria.  Por exemplo, dado um objecto 'b'
     com 5 índices covariantes,
     'decsym(b,5,3,[sym(1,2),anti(3,4)],[cyc(all)])' declara 'b'
     simétrico no seu primeiro e no seu segundo índices e antisimétrico
     no seu terceiro e quarto índices covariantes, e cíclico em todos de
     seus índices contravariantes.  Qualquer lista de declarações de
     simetria pode ser nula.  A função que executa as simplificações é
     'canform' como o exemplo abaixo ilustra.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) expr:contract(expand(a([i1,j1,k1],[])*kdels([i,j,k],[i1,j1,k1])))$
          (%i3) ishow(expr)$
          (%t3)         a      + a      + a      + a      + a      + a
                         k j i    k i j    j k i    j i k    i k j    i j k
          (%i4) decsym(a,3,0,[sym(all)],[]);
          (%o4)                                done
          (%i5) ishow(canform(expr))$
          (%t5)                              6 a
                                                i j k
          (%i6) remsym(a,3,0);
          (%o6)                                done
          (%i7) decsym(a,3,0,[anti(all)],[]);
          (%o7)                                done
          (%i8) ishow(canform(expr))$
          (%t8)                                  0
          (%i9) remsym(a,3,0);
          (%o9)                                done
          (%i10) decsym(a,3,0,[cyc(all)],[]);
          (%o10)                               done
          (%i11) ishow(canform(expr))$
          (%t11)                        3 a      + 3 a
                                           i k j      i j k
          (%i12) dispsym(a,3,0);
          (%o12)                     [[cyc, [[1, 2, 3]], []]]

 -- Função: remsym (<tensor>, <m>, <n>)
     Remove todas as propriedades de simetria de <tensor> que tem <m>
     índices covariantes e <n> índices contravariantes.

 -- Função: canform (<expr>)
     Simplifica <expr> através de mudança de nome de índices que ocorrem
     exactamente duas vezes e reordenação de todos os índices como
     ditados pelas condições de simetria impostas sobre eles.  Se
     'allsym' for 'true' então todos os índices são assumidos
     simétricos, de outra forma a informação de simetria fornecida pelas
     declarações 'decsym' irão ser usadas.  Os índices que ocorrem
     exactamente duas vezes são renomeados da mesma maneira que na
     função 'rename'.  Quando 'canform' é aplicada a uma expressão larga
     o cálculo pode tomar um considerável montante de tempo.  Esse tempo
     pode ser diminuído através do uso de 'rename' sobre a expressão em
     primeiro lugar.  Também veja o exemplo sob 'decsym'.  Nota:
     'canform' pode não estar apta a reduzir um expressão completamente
     para sua forma mais simples embora retorne sempre um resultado
     matemáticamente correcto.

27.2.3 Cálculo de tensores indiciais
------------------------------------

 -- Função: diff (<expr>, <v_1>, [<n_1>, [<v_2>, <n_2>] ...])

     É a função usual de diferenciação do Maxima que tem sido expandida
     nessas habilidades para 'itensor'.  'diff' toma a derivada de
     <expr> <n_1> vezes com relação a <v_1>, <n_2> vezes com relação a
     <v_2> , etc.  Para o pacote 'tensor', a função tem sido modificada
     de forma que os <v_i> possam ser inteiros de 1 até o valor da
     variável 'dim'.  Isso causará a conclusão da diferenciação com
     relação ao <v_i>ésimo membro da lista 'vect_coords'.  Se
     'vect_coords' for associado a uma variável atômica, então aquela
     variável subscrita através de <v_i> será usada para a variável de
     diferenciação.  Isso permite que um array de nomes de coordenadas
     ou nomes subscritos como 'x[1]', 'x[2]', ...  sejam usados.

 -- Função: idiff (<expr>, <v_1>, [<n_1>, [<v_2>, <n_2>] ...])
     Diferenciação indicial.  A menos que 'diff', que diferencia com
     relação a uma variável independente, 'idiff' possa ser usada para
     diferenciar com relação a uma coordenada.  Para um objecto
     indexado, isso equivale a anexar ao final os <v_i> como índices
     derivativos.  Subsequêntemente, índices derivativos irão ser
     ordenados, a menos que 'iframe_flag' seja escolhida para 'true'.

     'idiff' pode também ser o determinante de um tensor métrico.  Dessa
     forma, se 'imetric' tiver sido associada a 'G' então
     'idiff(determinant(g),k)' irá retornar
     '2*determinant(g)*ichr2([%i,k],[%i])' onde o índice que ocorre
     exactamente duas vezes '%i' é escolhido apropriadamente.

 -- Função: liediff (<v>, <ten>)

     Calcula a derivada de Lie da expressão tensorial <ten> com relação
     ao campo vectorial <v>.  <ten> pode ser qualquer expressão
     tensorial indexada; <v> pode ser o nome (sem índices) de um campo
     vectorial.  Por exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(liediff(v,a([i,j],[])*b([],[k],l)))$
                 k    %2            %2          %2
          (%t2) b   (v   a       + v   a     + v   a    )
                 ,l       i j,%2    ,j  i %2    ,i  %2 j

                                          %1  k        %1  k      %1  k
                                      + (v   b      - b   v    + v   b   ) a
                                              ,%1 l    ,l  ,%1    ,l  ,%1   i j

 -- Função: rediff (<ten>)

     Avalia todas as ocorrências do comando 'idiff' na expressão
     tensorial <ten>.

 -- Função: undiff (<expr>)

     Retorna uma expressão equivalente a <expr> mas com todas as
     derivadas de objectos indexados substituídas pela forma substantiva
     da função 'idiff'.  Seu argumento pode retornar aquele objecto
     indexado se a diferenciação for concluída.  Isso é útil quando for
     desejado substituir um objecto indexado que sofreu diferenciação
     com alguma definição de função resultando em <expr> e então
     concluir a diferenciação através de digamos 'ev(<expr>, idiff)'.

 -- Função: evundiff (<expr>)

     Equivalente à execução de 'undiff', seguida por 'ev' e 'rediff'.

     O ponto dessa operação é facilmente avaliar expressões que não
     possam ser directamente avaliadas na forma derivada.  Por exemplo,
     o seguinte causa um erro:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) icurvature([i,j,k],[l],m);
          Maxima encountered a Lisp error:

           Error in $ICURVATURE [or a callee]:
           $ICURVATURE [or a callee] requires less than three arguments.

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.

     Todavia, se 'icurvature' é informado em sua forma substantiva, pode
     ser avaliado usando 'evundiff':

          (%i3) ishow('icurvature([i,j,k],[l],m))$
                                                   l
          (%t3)                          icurvature
                                                   i j k,m
          (%i4) ishow(evundiff(%))$
                       l              l         %1           l           %1
          (%t4) - ichr2        - ichr2     ichr2      - ichr2       ichr2
                       i k,j m        %1 j      i k,m        %1 j,m      i k

                          l              l         %1           l           %1
                   + ichr2        + ichr2     ichr2      + ichr2       ichr2
                          i j,k m        %1 k      i j,m        %1 k,m      i j

     Nota: Em versões anteriores do Maxima, formas derivadas dos
     símbolos de Christoffel também não podiam ser avaliadas.  Isso foi
     corrigido actualmente, de forma que 'evundiff' não mais é
     necessária para expressões como essa:

          (%i5) imetric(g);
          (%o5)                                done
          (%i6) ishow(ichr2([i,j],[k],l))$
                 k %3
                g     (g         - g         + g        )
                        j %3,i l    i j,%3 l    i %3,j l
          (%t6) -----------------------------------------
                                    2

                                   k %3
                                  g     (g       - g       + g      )
                                   ,l     j %3,i    i j,%3    i %3,j
                                + -----------------------------------
                                                   2

 -- Função: flush (<expr>, <tensor_1>, <tensor_2>, ...)
     Escolhe para zero, em <expr>, todas as ocorrências de <tensor_i>
     que não tiverem índices derivativos.

 -- Função: flushd (<expr>, <tensor_1>, <tensor_2>, ...)
     Escolhe para zero, em <expr>, todas as ocorrências de <tensor_i>
     que tiverem índices derivativos.

 -- Função: flushnd (<expr>, <tensor>, <n>)
     Escolhe para zero, em <expr>, todas as ocorrências do objecto
     diferenciado <tensor> que tem <n> ou mais índices derivativos como
     demonstra o seguinte exemplo.

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i],[J,r],k,r)+a([i],[j,r,s],k,r,s))$
                                          J r      j r s
          (%t2)                          a      + a
                                          i,k r    i,k r s
          (%i3) ishow(flushnd(%,a,3))$
                                               J r
          (%t3)                               a
                                               i,k r

 -- Função: coord (<tensor_1>, <tensor_2>, ...)

     Dados os <tensor_i> a propriedade de diferenciação da coordenada
     que a derivada do vector contravariante cujo nome é um dos
     <tensor_i> retorna um delta de Kronecker.  Por exemplo, se
     'coord(x)' tiver sido concluída então 'idiff(x([],[i]),j)' fornece
     'kdelta([i],[j])'.  'coord' que é uma lista de todos os objectos
     indexados tendo essa propriedade.

 -- Função: remcoord (<tensor_1>, <tensor_2>, ...)
 -- Função: remcoord (all)

     Remove a propriedade de coordenada de diferenciação dos 'tensor_i'
     que foram estabelecidos através da função 'coord'.  'remcoord(all)'
     remove essa propriedade de todos os objectos indexados.

 -- Função: makebox (<expr>)
     Mostra <expr> da mesma maneira que 'show'; todavia, qualquer tensor
     d'Alembertiano ocorrendo em <expr> será indicado usando o símbolo
     '[]'.  Por exemplo, '[]p([m],[n])' representa
     'g([],[i,j])*p([m],[n],i,j)'.

 -- Função: conmetderiv (<expr>, <tensor>)

     Simplifica expressões contendo derivadas comuns de ambas as formas
     covariantes e contravariantes do tensor métrico (a restrição
     corrente).  Por exemplo, 'conmetderiv' pode relatar a derivada do
     tensor contravariante métrico com símbolos de Christoffel como
     visto adiante:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(g([],[a,b],c))$
                                                a b
          (%t2)                                g
                                                ,c
          (%i3) ishow(conmetderiv(%,g))$
                                   %1 b      a       %1 a      b
          (%t3)                 - g     ichr2     - g     ichr2
                                             %1 c              %1 c

 -- Função: simpmetderiv (<expr>)
 -- Função: simpmetderiv (<expr>[, <stop>])

     Simplifica expressões contendo produtos de derivadas de tensores
     métricos.  Especificamente, 'simpmetderiv' reconhece duas
     identidades:


             ab        ab           ab                 a
            g   g   + g   g     = (g   g  )   = (kdelta )   = 0
             ,d  bc        bc,d         bc ,d          c ,d

     consequêntemente


             ab          ab
            g   g   = - g   g
             ,d  bc          bc,d

     e


            ab          ab
           g   g     = g   g
            ,j  ab,i    ,i  ab,j

     que seguem de simetrias de símbolos de Christoffel.

     A função 'simpmetderiv' toma um parâmetro opcional que, quando
     presente, faz com que a função pare após a primeira substituição
     feita com sucesso em uma expressão produto.  A função
     'simpmetderiv' também faz uso da variável global <flipflag> que
     determina como aplicar uma ordenação "canonica" para os índices de
     produto.

     Colocados juntos, essas compatibilidades podem ser usadas
     poderosamente para encontrar simplificações que são difíceis ou
     impossíveis de realizar de outra forma.  Isso é demonstrado através
     do seguinte exemplo que explicitamente usa o recurso de
     simplificação parcial de 'simpmetderiv' para obter uma expressão
     contractível:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric(g);
          (%o2)                                done
          (%i3) ishow(g([],[a,b])*g([],[b,c])*g([a,b],[],d)*g([b,c],[],e))$
                                       a b  b c
          (%t3)                       g    g    g      g
                                                 a b,d  b c,e
          (%i4) ishow(canform(%))$

          errexp1 has improper indices
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) ishow(simpmetderiv(%))$
                                       a b  b c
          (%t5)                       g    g    g      g
                                                 a b,d  b c,e
          (%i6) flipflag:not flipflag;
          (%o6)                                true
          (%i7) ishow(simpmetderiv(%th(2)))$
                                         a b  b c
          (%t7)                         g    g    g    g
                                         ,d   ,e   a b  b c
          (%i8) flipflag:not flipflag;
          (%o8)                                false
          (%i9) ishow(simpmetderiv(%th(2),stop))$
                                         a b  b c
          (%t9)                       - g    g    g      g
                                              ,e   a b,d  b c
          (%i10) ishow(contract(%))$
                                              b c
          (%t10)                           - g    g
                                              ,e   c b,d

     Veja também 'weyl.dem' para um exemplo que usa 'simpmetderiv' e
     'conmetderiv' juntos para simplificar contrações do tensor de Weyl.

 -- Função: flush1deriv (<expr>, <tensor>)

     Escolhe para zero, em 'expr', todas as ocorrências de 'tensor' que
     possuem exactamente um índice derivativo.

27.2.4 Tensores em espaços curvos
---------------------------------

 -- Função: imetric (<g>)
 -- Variável de sistema: imetric

     Especifica a métrica através de atribuição à variável 'imetric:<g>'
     adicionalmente, as propriedades de contração da métrica <g> são
     escolhidas através da execução dos comandos
     'defcon(<g>),defcon(<g>,<g>,kdelta)'.  A variável 'imetric'
     (desassociada por padrão), é associada à métrica, atribuida pelo
     comando 'imetric(<g>)'.

 -- Função: idim (<n>)
     Escolhe as dimensões da métrica.  Também inicializa as propriedades
     de antisimetria dos símbolos de Levi-Civita para as dimensões
     dadas.

 -- Função: ichr1 ([<i>, <j>, <k>])
     Retorna o símbolo de Christoffel de primeiro tipo via definição
                 (g      + g      - g     )/2 .
                   ik,j     jk,i     ij,k
     Para avaliar os símbolos de Christoffel para uma métrica
     particular, à variável 'imetric' deve ser atribuída um nome como no
     exemplo sob 'chr2'.

 -- Função: ichr2 ([<i>, <j>], [<k>])
     Retorna o símbolo de Christoffel de segundo tipo definido pela
     relação
                                 ks
             ichr2([i,j],[k]) = g    (g      + g      - g     )/2
                                       is,j     js,i     ij,s

 -- Função: icurvature ([<i>, <j>, <k>], [<h>])
     Retorna o tensor da curvatura de Riemann em termos de símbolos de
     Christoffel de segundo tipo ('ichr2').  A seguinte notação é usada:
                         h             h            h         %1         h
               icurvature     = - ichr2      - ichr2     ichr2    + ichr2
                         i j k         i k,j        %1 j      i k        i j,k
                                         h          %1
                                  + ichr2      ichr2
                                         %1 k       i j

 -- Função: covdiff (<expr>, <v_1>, <v_2>, ...)
     Retorna a derivada da covariante de <expr> com relação às variáveis
     <v_i> em termos de símbolos de Christoffel de segundo tipo
     ('ichr2').  Com o objectivo de avaliar esses, se pode usar
     'ev(<expr>,ichr2)'.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) entertensor()$
          Enter tensor name: a;
          Enter a list of the índices covariantes: [i,j];
          Enter a list of the índices contravariantes: [k];
          Enter a list of the derivative indices: [];
                                                k
          (%t2)                                a
                                                i j
          (%i3) ishow(covdiff(%,s))$
                       k         %1     k         %1     k            k     %1
          (%t3)     - a     ichr2    - a     ichr2    + a      + ichr2     a
                       i %1      j s    %1 j      i s    i j,s        %1 s  i j
          (%i4) imetric:g;
          (%o4)            g
          (%i5) ishow(ev(%th(2),ichr2))$
            %1 %4  k
           g      a     (g       - g       + g  )
            i %1   s %4,j  j s,%4    j %4,s
          (%t5) - ------------------------------------------
                 2
              %1 %3  k
             g   a     (g       - g    + g     )
              %1 j   s %3,i    i s,%3    i %3,s
           - ------------------------------------------
                   2
              k %2  %1
             g     a    (g        - g    + g      )
             i j   s %2,%1    %1 s,%2    %1 %2,s   k
           + ------------------------------------------- + a
             2     i j,s
          (%i6)

 -- Função: lorentz_gauge (<expr>)
     Impõe a condição de Lorentz através da substituição de 0 para todos
     os objectos indexados em <expr> que possui um índice de derivada
     idêntico ao índice contravariante.

 -- Função: igeodesic_coords (<expr>, <nome>)

     Faz com que símbolos de Christoffel não diferenciados e a primeira
     derivada do tensor métrico tendam para zero em <expr>.  O <nome> na
     função 'igeodesic_coords' refere-se à métrica <nome> (se isso
     aparecer em <expr>) enquando os coeficientes de conecção devem ser
     chamados com os nomes 'ichr1' e/ou 'ichr2'.  O seguinte exemplo
     demonstra a verificação da identidade cíclica satisfeita através do
     tensor da curvatura de Riemann usando a função 'igeodesic_coords'.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(icurvature([r,s,t],[u]))$
                       u            u         %1         u            u         %1
          (%t2) - ichr2      - ichr2     ichr2    + ichr2      + ichr2     ichr2
                       r t,s        %1 s      r t        r s,t        %1 t      r s
          (%i3) ishow(igeodesic_coords(%,ichr2))$
                                           u            u
          (%t3)                       ichr2      - ichr2
                                           r s,t        r t,s
          (%i4) ishow(igeodesic_coords(icurvature([r,s,t],[u]),ichr2)+
                      igeodesic_coords(icurvature([s,t,r],[u]),ichr2)+
                      igeodesic_coords(icurvature([t,r,s],[u]),ichr2))$
                       u            u            u            u            u
          (%t4) - ichr2      + ichr2      + ichr2      - ichr2      - ichr2
                       t s,r        t r,s        s t,r        s r,t        r t,s

                                                                            u
                                                                     + ichr2
                                                                            r s,t
          (%i5) canform(%);
          (%o5)                                  0

27.2.5 Referenciais móveis
--------------------------

Maxima actualmente tem a habilidade de executar cálculos usando
referenciais móveis.  Essas podem ser referenciais ortonormais (tetrads,
vielbeins) ou um referencial arbitrária.

Para usar referenciais, primeiro escolha 'iframe_flag' para 'true'.
Isso faz com que os símbolos de Christoffel, 'ichr1' e 'ichr2', sejam
substituídos pelos referenciais mais gerais de coeficientes de conecção
'icc1' e 'icc2' em cálculos.  Especialmente, o comportamento de
'covdiff' e 'icurvature' são alterados.

O referencial é definido através de dois tensores: o campo de
referencial inversa ('ifri'), a base tetrad dual), e a métrica do
referencial 'ifg'.  A métrica do referencial é a matriz identidade para
referenciais ortonormais, ou a métrica de Lorentz para referenciais
ortonormais no espaço-tempo de Minkowski.  O campo de referencial
inverso define a base do referencial (vectores unitários).  Propriedades
de contração são definidas para o campo de referencial e para a métrica
do referencial.

Quando 'iframe_flag' for 'true', muitas expressões 'itensor' usam a
métrica do referencial 'ifg' em lugar da métrica definida através de
'imetric' para o decremento e para o incremento de índices.

IMPORTANTE: Escolhendo a variável 'iframe_flag' para 'true' NÃO remove a
definição das propriedades de contração de uma métrica definida através
de uma chamada a 'defcon' ou 'imetric'.  Se um campo de referencial for
usado, ele é melhor para definir a métrica através de atribuição desse
nome para a variável 'imetric' e NÃO invoque a função 'imetric'.

Maxima usa esses dois tensores para definir os coeficientes de
referencial ('ifc1' e 'ifc2') cuja forma parte dos coeficientes de
conecção ('icc1' e 'icc2'), como demonstra o seguinte exemplo:


     (%i1) load(itensor);
     (%o1)      /share/tensor/itensor.lisp
     (%i2) iframe_flag:true;
     (%o2)                                true
     (%i3) ishow(covdiff(v([],[i]),j))$
                                    i        i     %1
     (%t3)                         v   + icc2     v
                                    ,j       %1 j
     (%i4) ishow(ev(%,icc2))$
                             %1      i           i        i
     (%t4)                  v   (ifc2     + ichr2    ) + v
                                     %1 j        %1 j     ,j
     (%i5) ishow(ev(%,ifc2))$
                 %1    i %2
                v   ifg     (ifb        - ifb        + ifb       )
                                j %2 %1      %2 %1 j      %1 j %2     i
     (%t5)      -------------------------------------------------- + v
                                        2                             ,j
     (%i6) ishow(ifb([a,b,c]))$
                            %5    %4
     (%t6)               ifr   ifr   (ifri        - ifri       )
                            a     b       c %4,%5       c %5,%4

Um método alternativo é usado para calcular o suporte do referencial
('ifb') se o sinalizador 'iframe_bracket_form' é escolhido para 'false':


     (%i8) block([iframe_bracket_form:false],ishow(ifb([a,b,c])))$
                            %7    %6        %6      %7
     (%t8)              (ifr   ifr     - ifr     ifr  ) ifri
                            a     b,%7      a,%7    b       c %6

 -- Função: iframes ()

     Uma vez que nessa versão do Maxima, identidades de contração para
     'ifr' e 'ifri' são sempre definidas, como é o suporte do
     referencial ('ifb'), essa função não faz nada.

 -- Variável: ifb

     O suporte do referencial.  A contribuição da métrica do referencial
     para os coeficientes de conecção é expressa usando o suporte do
     referencial:


                    - ifb      + ifb      + ifb
                         c a b      b c a      a b c
          ifc1    = --------------------------------
              abc                  2

     O suporte do referencial por si mesmo é definido em termos de campo
     de referencial e métrica do referencial.  Dois métodos alternativos
     de cálculo são usados dependendo do valor de 'frame_bracket_form'.
     Se 'true' (o padrão) ou se o sinalizador 'itorsion_flag' for
     'true':


                    d      e                                      f
          ifb =  ifr    ifr   (ifri      - ifri      - ifri    itr   )
             abc    b      c       a d,e       a e,d       a f    d e


     Otherwise:


                       e      d        d      e
          ifb    = (ifr    ifr    - ifr    ifr   ) ifri
             abc       b      c,e      b,e    c        a d

 -- Variável: icc1

     Coeficientes de conecção de primeiro tipo.  Em 'itensor', definido
     como


          icc1    = ichr1    - ikt1    - inmc1
              abc        abc       abc        abc

     Nessa expressão, se 'iframe_flag' for 'true', o símbolo de
     Christoffel 'ichr1' é substituído com o coeficiente de conecção do
     referencial 'ifc1'.  Se 'itorsion_flag' for 'false', 'ikt1' será
     omitido.  'ikt1' é também omitido se uma base de referencial for
     usada, como a torsão está já calculada como parte do suporte do
     referencial.  Ultimamente, como 'inonmet_flag' é 'false', 'inmc1'
     não estará presente.

 -- Variável: icc2

     Coeficientes de conecção de segundo tipo.  Em 'itensor', definido
     como


              c         c        c         c
          icc2   = ichr2   - ikt2   - inmc2
              ab        ab       ab        ab

     Nessa expressão, se 'iframe_flag' for 'true', o símbolo de
     Christoffel 'ichr2' é substituído com o coeficiente de conecção
     'ifc2'.  Se 'itorsion_flag' for 'false', 'ikt2' será omitido.
     'ikt2' também será omitido se uma base de referencial for usada,
     uma vez que a torsão já está calculada como parte do suporte do
     referencial.  Ultimamente, como 'inonmet_flag' é 'false', 'inmc2'
     não estará presente.

 -- Variável: ifc1

     Coeficiente de referencial de primeiro tipo (também conhecido como
     coeficientes de rotação de Ricci).  Esse tensor representa a
     contribuição da métrica do referencial para o coeficiente de
     conecção de primeiro tipo.  Definido como:


                    - ifb      + ifb      + ifb
                         c a b      b c a      a b c
          ifc1    = --------------------------------
              abc                   2


 -- Variável: ifc2

     Coeficiente de referencial de primeiro tipo.  Esse tensor
     representa a contribuição da métrica do referencial para o
     coeficiente de conecção de primeiro tipo.  Definido como uma
     permutação de suporte de referencial ('ifb') com os índices
     apropriados incrementados e decrementados como necessário:


              c       cd
          ifc2   = ifg   ifc1
              ab             abd

 -- Variável: ifr

     O campo do referencial.  Contrai ('ifri') para e com a forma do
     campo inverso do referencial para formar a métrica do referencial
     ('ifg').

 -- Variável: ifri

     O campo inverso do referencial.  Especifica a base do referencial
     (vectores base duais).  Juntamente com a métrica do referencial,
     forma a base de todos os cálculos baseados em referenciais.

 -- Variável: ifg

     A métrica do referencial.  O valor padrão é 'kdelta', mas pode ser
     mudada usando 'components'.

 -- Variável: ifgi

     O inverso da métrica do referencial.  Contrai com a métrica do
     referencial ('ifg') para 'kdelta'.

 -- Variável de Opção: iframe_bracket_form
     Valor por omissão: 'true'

     Especifica como o suporte do referencial ('ifb') é calculado.

27.2.6 Torsão e não metricidade
-------------------------------

Maxima pode trabalhar com torsão e não metricidade.  Quando o
sinalizador 'itorsion_flag' for escolhido para 'true', a contribuição de
torsão é adicionada aos coeficientes de conecção.  Similarmente, quando
o sinalizador 'inonmet_flag' for 'true', componentes de não metricidades
são incluídos.

 -- Variável: inm

     O vector de não metricidade.  Conforme a não metricidade está
     definida através da derivada covariante do tensor métrico.
     Normalmente zero, o tensor da métrica derivada covariante irá
     avaliar para o seguinte quando 'inonmet_flag' for escolhido para
     'true':


          g     =- g  inm
           ij;k     ij  k

 -- Variável: inmc1

     Permutação covariante de componentes do vector de não metricidade.
     Definida como


                     g   inm  - inm  g   - g   inm
                      ab    c      a  bc    ac    b
          inmc1    = ------------------------------
               abc                 2

     (Substitue 'ifg' em lugar de 'g' se um referencial métrico for
     usada.)

 -- Variável: inmc2

     Permutação covariante de componentes do vector de não metricidade.
     Usada nos coeficicientes de conecção se 'inonmet_flag' for 'true'.
     Definida como:


                                c         c         cd
                    -inm  kdelta  - kdelta  inm  + g   inm  g
               c        a       b         a    b          d  ab
          inmc2   = -------------------------------------------
               ab                        2

     (Substitue 'ifg' em lugar de 'g' se um referencial métrico for
     usada.)

 -- Variável: ikt1

     Permutação covariante do tensor de torsão (também conhecido como
     contorsão).  Definido como:


                            d           d       d
                    -g   itr  - g    itr   - itr   g
                      ad    cb    bd    ca      ab  cd
          ikt1    = ----------------------------------
              abc                   2

     (Substitue 'ifg' em lugar de 'g' se um referencial métrico for
     usada.)

 -- Variável: ikt2

     Permutação contravariante do tensor de torsão (também conhecida
     como contorsão).  Definida como:


              c     cd
          ikt2   = g   ikt1
              ab           abd

     (Substitue 'ifg' em lugar de 'g' se um referencial métrico for
     usada.)

 -- Variável: itr

     O tensor de torsão.  Para uma métrica com torsão, diferenciação
     covariante repetida sobre uma funçào escalar não irá comutar,como
     demonstrado através do seguinte exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric:g;
          (%o2)                                  g
          (%i3) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$
          (%i4) ishow(%)$
                                             %4              %2
          (%t4)                    f    ichr2    - f    ichr2
                                    ,%4      j i    ,%2      i j
          (%i5) canform(%);
          (%o5)                                  0
          (%i6) itorsion_flag:true;
          (%o6)                                true
          (%i7) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$
          (%i8) ishow(%)$
                                     %8             %6
          (%t8)             f    icc2    - f    icc2    - f     + f
                             ,%8     j i    ,%6     i j    ,j i    ,i j
          (%i9) ishow(canform(%))$
                                             %1             %1
          (%t9)                     f    icc2    - f    icc2
                                     ,%1     j i    ,%1     i j
          (%i10) ishow(canform(ev(%,icc2)))$
                                             %1             %1
          (%t10)                    f    ikt2    - f    ikt2
                                     ,%1     i j    ,%1     j i
          (%i11) ishow(canform(ev(%,ikt2)))$
                                %2 %1                    %2 %1
          (%t11)          f    g      ikt1       - f    g      ikt1
                           ,%2            i j %1    ,%2            j i %1
          (%i12) ishow(factor(canform(rename(expand(ev(%,ikt1))))))$
                                     %3 %2            %1       %1
                               f    g      g      (itr    - itr   )
                                ,%3         %2 %1     j i      i j
          (%t12)               ------------------------------------
                                                2
          (%i13) decsym(itr,2,1,[anti(all)],[]);
          (%o13)                               done
          (%i14) defcon(g,g,kdelta);
          (%o14)                               done
          (%i15) subst(g,nounify(g),%th(3))$
          (%i16) ishow(canform(contract(%)))$
                                                     %1
          (%t16)                           - f    itr
                                              ,%1    i j

27.2.7 Álgebra externa (como em produto externo)
------------------------------------------------

O pacote 'itensor' pode executar operações sobre campos tensores
covariantes totalmente antisimétricos.  Um campo tensor totalmente
antisimétrico de classe (0,L) corresponde a uma forma diferencial L.
Sobre esses objectos, uma operação de multiplicação funciona como um
produto externo, ou produto cunha, é definido.

Desafortunadamente, nem todos os autores concordam sobre a definição de
produto cunha.  Alguns autores preferem uma definição que corresponde à
noção de antisimetrização: nessas palavras, o produto cunha de dois
campos vectoriais, por exemplo, pode ser definido como

                 a a  - a a
                  i j    j i
      a  /\ a  = -----------
       i     j        2

Mais geralmente, o produto de uma forma p e uma forma q pode ser
definido como

                            1     k1..kp l1..lq
     A       /\ B       = ------ D              A       B
      i1..ip     j1..jq   (p+q)!  i1..ip j1..jq  k1..kp  l1..lq

onde 'D' simboliza o delta de Kronecker.

Outros autores, todavia, preferem uma definição "geométrica" que
corresponde à notação de elemento volume:

     a  /\ a  = a a  - a a
      i     j    i j    j i

e, no caso geral

                            1    k1..kp l1..lq
     A       /\ B       = ----- D              A       B
      i1..ip     j1..jq   p! q!  i1..ip j1..jq  k1..kp  l1..lq

Uma vez que 'itensor' é um pacote de algebra de tensores, a primeira
dessas duas definições aparenta ser a mais natural por si mesma.  Muitas
aplicações, todavia, usam a segunda definição.  Para resolver esse
dilema, um sinalizador tem sido implementado que controla o
comportamento do produto cunha: se 'igeowedge_flag' for 'false' (o
padrão), a primeira, definição "tensorial" é usada, de outra forma a
segunda, definição "geométrica" irá ser aplicada.

 -- Operador: ~
     O operador do produto cunha é definido como sendo o acento til '~'.
     O til é um operador binário.  Seus argumentos podem ser expressões
     envolvendo escalares, tensores covariantes de categoria 1, ou
     tensores covariantes de categoria 'l' que tiverem sido declarados
     antisimétricos em todos os índices covariantes.

     O comportamento do operador do produto cunha é controlado através
     do sinalizador 'igeowedge_flag', como no seguinte exemplo:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i])~b([j]))$
                                           a  b  - b  a
                                            i  j    i  j
          (%t2)                            -------------
                                                 2
          (%i3) decsym(a,2,0,[anti(all)],[]);
          (%o3)                                done
          (%i4) ishow(a([i,j])~b([k]))$
                                    a    b  + b  a    - a    b
                                     i j  k    i  j k    i k  j
          (%t4)                     ---------------------------
                                                 3
          (%i5) igeowedge_flag:true;
          (%o5)                                true
          (%i6) ishow(a([i])~b([j]))$
          (%t6)                            a  b  - b  a
                                            i  j    i  j
          (%i7) ishow(a([i,j])~b([k]))$
          (%t7)                     a    b  + b  a    - a    b
                                     i j  k    i  j k    i k  j

 -- Operador: |
     A barra vertical '|' denota a operação binária "contração com um
     vector".  Quando um tensor covariante totalmente antisimétrico é
     contraído com um vector contravariante, o resultado é o mesmo
     independente de qual índice foi usado para a contração.  Dessa
     forma, é possível definir a operação de contração de uma forma
     livre de índices.

     No pacote 'itensor', contração com um vector é sempre realizada com
     relação ao primeiro índice na ordem literal de ordenação.  Isso
     garante uma melhor simplificação de expressões envolvendo o
     operador '|'.  Por exemplo:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) decsym(a,2,0,[anti(all)],[]);
          (%o2)                                done
          (%i3) ishow(a([i,j],[])|v)$
                                              %1
          (%t3)                              v   a
                                                  %1 j
          (%i4) ishow(a([j,i],[])|v)$
                                               %1
          (%t4)                             - v   a
                                                   %1 j

     Note que isso é essencial que os tensores usado como o operador '|'
     seja declarado totalmente antisimétrico em seus índices
     covariantes.  De outra forma, os resultados serão incorrectos.

 -- Função: extdiff (<expr>, <i>)

     Calcula a derivada externa de <expr> com relação ao índice <i>.  A
     derivada externa é formalmente definida como o produto cunha do
     operador de derivada parcial e uma forma diferencial.  Como tal,
     essa operação é também controlada através da escolha de
     'igeowedge_flag'.  Por exemplo:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(extdiff(v([i]),j))$
                                            v    - v
                                             j,i    i,j
          (%t2)                             -----------
                                                 2
          (%i3) decsym(a,2,0,[anti(all)],[]);
          (%o3)                                done
          (%i4) ishow(extdiff(a([i,j]),k))$
                                     a      - a      + a
                                      j k,i    i k,j    i j,k
          (%t4)                      ------------------------
                                                3
          (%i5) igeowedge_flag:true;
          (%o5)                                true
          (%i6) ishow(extdiff(v([i]),j))$
          (%t6)                             v    - v
                                             j,i    i,j
          (%i7) ishow(extdiff(a([i,j]),k))$
          (%t7)                      a      - a      + a
                                      j k,i    i k,j    i j,k

 -- Função: hodge (<expr>)

     Calcula o Hodge dual de <expr>.  Por exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric(g);
          (%o2)                            done
          (%i3) idim(4);
          (%o3)                            done
          (%i4) icounter:100;
          (%o4)                             100
          (%i5) decsym(A,3,0,[anti(all)],[])$

          (%i6) ishow(A([i,j,k],[]))$
          (%t6)                           A
                                           i j k
          (%i7) ishow(canform(hodge(%)))$
                                    %1 %2 %3 %4
                         levi_civita            g        A
                                                 %1 %102  %2 %3 %4
          (%t7)          -----------------------------------------
                                             6
          (%i8) ishow(canform(hodge(%)))$
                           %1 %2 %3 %8            %4 %5 %6 %7
          (%t8) levi_civita            levi_civita            g        g
                                                               %1 %106  %2 %107
                                                      g        g      A        /6
                                                       %3 %108  %4 %8  %5 %6 %7
          (%i9) lc2kdt(%)$

          (%i10) %,kdelta$

          (%i11) ishow(canform(contract(expand(%))))$
          (%t11)                     - A
                                        %106 %107 %108

 -- Variável de Opção: igeowedge_flag
     Valor por omissão: 'false'

     Controla o comportamento de produto cunha e derivada externa.
     Quando for esconhida para 'false' (o padrão), a noção de formas
     diferenciais irá corresponder àquela de um campo tensor covariante
     totalmente antisimétrico.  Quando escolhida para 'true', formas
     diferenciais irão concordar com a noção do elemento volume.

27.2.8 Exportando expressões TeX
--------------------------------

O pacote 'itensor' fornece suporte limitado à exportação de expressões
de tensores para o TeX. Uma vez que expressões 'itensor' aparecem como
chamada a funções, o comando regular 'tex' do Maxima não produzirá a
saída esperada.  Pode tentar no seu lugar o comando 'tentex', o qual
tenta traduzir expressões de tensores dentro de objectos TeX indexados
apropriadamente.

 -- Função: tentex (<expr>)

     Para usar a função 'tentex', deve primeiro chamar 'tentex', como no
     seguinte exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) load(tentex);
          (%o2)       /share/tensor/tentex.lisp
          (%i3) idummyx:m;
          (%o3)                                  m
          (%i4) ishow(icurvature([j,k,l],[i]))$
                      m1       i           m1       i           i            i
          (%t4)  ichr2    ichr2     - ichr2    ichr2     - ichr2      + ichr2
                      j k      m1 l        j l      m1 k        j l,k        j k,l
          (%i5) tentex(%)$
          $$\Gamma_{j\,k}^{m_1}\,\Gamma_{l\,m_1}^{i}-\Gamma_{j\,l}^{m_1}\,
           \Gamma_{k\,m_1}^{i}-\Gamma_{j\,l,k}^{i}+\Gamma_{j\,k,l}^{i}$$

     Note o uso da declaração 'idummyx', para evitar o aparecimento do
     sinal de porcentagem na expressão TeX, o qual pode induzir a erros
     de compilação.

     Note Bem: Essa vesão da função 'tentex' é um tanto quanto
     experimental.

27.2.9 Interagindo com o pacote 'ctensor'
-----------------------------------------

O pacote 'itensor' possui a habilidade de gerar código Maxima que pode
então ser executado no contexto do pacote 'ctensor'.  A função que
executa essa tarefa é 'ic_convert'.

 -- Função: ic_convert (<eqn>)

     Converte a equação <eqn> na sintaxe 'itensor' para uma declaração
     de atribuição 'ctensor'.  Adições implícitas sobre índices que
     ocorrem exactamente duas vezes são tornadas explícitas enquanto
     objectos indexados são transformados em arrays (os arrays
     subscritos estão na ordem de covariância seguidos de índices
     contravariantes dos objectos indexados).  A derivada de um objecto
     indexado será substituída pela forma substantiva de 'diff' tomada
     com relação a 'ct_coords' subscrita pelo índice de derivação.  Os
     símbolos de Christoffel 'ichr1' e 'ichr2' irão ser traduzidos para
     'lcs' e 'mcs', respectivamente e se 'metricconvert' for 'true'
     então todas as ocorrências da métrica com dois índices covariantes
     (ou contravariantes) irão ser renomeadas para 'lg' (ou 'ug').
     Adicionalmente, ciclos 'do' irão ser introduzidos adicionando sobre
     todos os índices livres de forma que a declaração de atribuição
     transformada pode ser avaliada através de apenas fazendo 'ev'.  Os
     seguintes exemplos demonstam os recursos dessa função.

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) eqn:ishow(t([i,j],[k])=f([],[])*g([l,m],[])*a([],[m],j)*b([i],[l,k]))$
                                       k        m   l k
          (%t2)                       t    = f a   b    g
                                       i j      ,j  i    l m
          (%i3) ic_convert(eqn);
          (%o3) for i thru dim do (for j thru dim

          do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                                 i, j, k                   m           j   i, l, k

           g    , l, 1, dim), m, 1, dim)))
            l, m
          (%i4) imetric(g);
          (%o4)                                done
          (%i5) metricconvert:true;
          (%o5)                                true
          (%i6) ic_convert(eqn);
          (%o6) for i thru dim do (for j thru dim

          do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                                 i, j, k                   m           j   i, l, k

           lg    , l, 1, dim), m, 1, dim)))
             l, m

27.2.10 Palavras reservadas
---------------------------

As palavras seguintes do Maxima são usadas internamente pelo pacote
'itensor' e não podem ser redefinidas:

       Keyword    Comments
       ------------------------------------------
       indices2() versão interna de indices()
       conti      Lista de índices contravariantes
       covi       Lista de índices covariantes de um objecto indexado
       deri       Lista de índices de derivada de um objecto indexado
       name       Retorna o nome de um objecto indexado
       concan
       irpmon
       lc0
       _lc2kdt0
       _lcprod
       _extlc


File: maxima.info,  Node: ctensor,  Next: Pacote atensor,  Prev: itensor,  Up: Top

28 ctensor
**********

* Menu:

* Introdução a ctensor::     
* Definições para ctensor::     


File: maxima.info,  Node: Introdução a ctensor,  Next: Definições para ctensor,  Prev: ctensor,  Up: ctensor

28.1 Introdução a ctensor
=========================

'ctensor' é um pacote de manipulação de componentes.  Para usar o pacote
'ctensor', digite 'load(ctensor)'.  Para começar uma sessão iterativa
com 'ctensor', digite 'csetup()'.  O primeiro que será pedido pelo
pacote é a dimensão a ser manipulada.  Se a dimensão for 2, 3 ou 4 então
a lista de coordenadas padrão é '[x,y]', '[x,y,z]' ou '[x,y,z,t]'
respectivamente.  Esses nomes podem ser mudados através da atribuição de
uma nova lista de coordenadas para a variável 'ct_coords' (descrita
abaixo) e o utilizador é questionado sobre isso.  Deve ter o cuidado de
evitar conflitos de nomes de coordenadas com outras definições de
objectos.

No próximo passo, o utilizador informa a métrica ou directamente ou de
um ficheiro especificando sua posição ordinal.  Como um exemplo de um
ficheiro de métrica comum, veja 'share/tensor/metrics.mac'.  A métrica é
armazenada na matriz LG. Finalmente, o inverso da métrica é calculado e
armazenado na matriz UG. Se tem a opção de realizar todos os cálculos em
séries de potência.

A seguir, mostramos um exemplo de protocolo para a métrica estática,
esfericamente simétrica (coordenadas padrão) que será aplicada ao
problema de derivação das equações de vácuo de Einstein (que levam à
solução de Schwarzschild).  Muitas das funções em 'ctensor' irão ser
mostradas como exemplos para a métrica padrão.

     (%i1) load(ctensor);
     (%o1)      /usr/local/lib/maxima/share/tensor/ctensor.mac
     (%i2) csetup();
     Enter the dimension of the coordinate system:
     4;
     Do you wish to change the coordinate names?
     n;
     Do you want to
     1. Enter a new metric?

     2. Enter a metric from a file?

     3. Approximate a metric with a Taylor series?
     1;

     Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
     Answer 1, 2, 3 or 4
     1;
     Row 1 Column 1:
     a;
     Row 2 Column 2:
     x^2;
     Row 3 Column 3:
     x^2*sin(y)^2;
     Row 4 Column 4:
     -d;

     Matrix entered.
     Enter functional dependencies with the DEPENDS function or 'N' if none
     depends([a,d],x);
     Do you wish to see the metric?
     y;
                               [ a  0       0        0  ]
                               [                        ]
                               [     2                  ]
                               [ 0  x       0        0  ]
                               [                        ]
                               [         2    2         ]
                               [ 0  0   x  sin (y)   0  ]
                               [                        ]
                               [ 0  0       0       - d ]
     (%o2)                                done
     (%i3) christof(mcs);
                                                 a
                                                  x
     (%t3)                          mcs        = ---
                                       1, 1, 1   2 a

                                                  1
     (%t4)                           mcs        = -
                                        1, 2, 2   x

                                                  1
     (%t5)                           mcs        = -
                                        1, 3, 3   x

                                                 d
                                                  x
     (%t6)                          mcs        = ---
                                       1, 4, 4   2 d

                                                   x
     (%t7)                          mcs        = - -
                                       2, 2, 1     a

                                                cos(y)
     (%t8)                         mcs        = ------
                                      2, 3, 3   sin(y)

                                                    2
                                               x sin (y)
     (%t9)                      mcs        = - ---------
                                   3, 3, 1         a

     (%t10)                   mcs        = - cos(y) sin(y)
                                 3, 3, 2

                                                 d
                                                  x
     (%t11)                         mcs        = ---
                                       4, 4, 1   2 a
     (%o11)                               done


File: maxima.info,  Node: Definições para ctensor,  Prev: Introdução a ctensor,  Up: ctensor

28.2 Definições para ctensor
============================

28.2.1 Inicialização e configuração
-----------------------------------

 -- Função: csetup ()
     É uma função no pacote 'ctensor' (component tensor) que inicializa
     o pacote e permite ao utilizador inserir uma métrica
     interativamente.  Veja 'ctensor' para mais detalhes.

 -- Função: cmetric (<dis>)
 -- Função: cmetric ()
     É uma função no pacote 'ctensor' que calcula o inverso da métrica e
     prepara o pacote para cálculos adiante.

     Se 'cframe_flag' for 'false', a função calcula a métrica inversa
     'ug' a partir da matriz 'lg' (definida pelo utilizador).  O
     determinante da métrica é também calculado e armazenado na variável
     'gdet'.  Mais adiante, o pacote determina se a métrica é diagonal e
     escolhe o valor de 'diagmetric' conforme a determinação.  Se o
     argumento opcional <dis> estiver presente e não for 'false', a
     saída é mostrada ao utilizador pela linha de comando para que ele
     possa ver o inverso da métrica.

     Se 'cframe_flag' for 'true', a função espera que o valor de 'fri'
     (a matriz referencial inversa) e 'lfg' (a métrica do referencial)
     sejam definidas.  A partir dessas, a matriz do referencial 'fr' e a
     métrica do referencial inverso 'ufg' são calculadas.

 -- Função: ct_coordsys (<sistema_de_coordenadas>, <extra_arg>)
 -- Função: ct_coordsys (<sistema_de_coordenadas>)
     Escolhe um sistema de coordenadas predefinido e uma métrica.  O
     argumento <sistema_de_coordenadas> pode ser um dos seguintes
     símbolos:


            SYMBOL               Dim Coordenadas       Descrição/comentários
            --------------------------------------------------------------------------
            cartesian2d           2  [x,y]             Sist. de coord. cartesianas 2D
            polar                 2  [r,phi]           Sist. de coord. Polare
            elliptic              2  [u,v]
            confocalelliptic      2  [u,v]
            bipolar               2  [u,v]
            parabolic             2  [u,v]
            cartesian3d           3  [x,y,z]           Sist. de coord. cartesianas 3D
            polarcylindrical      3  [r,theta,z]
            ellipticcylindrical   3  [u,v,z]           Elíptica 2D com Z cilíndrico
            confocalellipsoidal   3  [u,v,w]
            bipolarcylindrical    3  [u,v,z]           Bipolar 2D com Z cilíndrico
            paraboliccylindrical  3  [u,v,z]           Parabólico 2D com Z cilíndrico
            paraboloidal          3  [u,v,phi]
            conical               3  [u,v,w]
            toroidal              3  [u,v,phi]
            spherical             3  [r,theta,phi]     Sist. de coord. Esféricas
            oblatespheroidal      3  [u,v,phi]
            oblatespheroidalsqrt  3  [u,v,phi]
            prolatespheroidal     3  [u,v,phi]
            prolatespheroidalsqrt 3  [u,v,phi]
            ellipsoidal           3  [r,theta,phi]
            cartesian4d           4  [x,y,z,t]         Sist. de coord. 4D
            spherical4d           4  [r,theta,eta,phi]
            exteriorschwarzschild 4  [t,r,theta,phi]   Métrica de Schwarzschild
            interiorschwarzschild 4  [t,z,u,v]        Métrica de Schwarzschild Interior
            kerr_newman           4  [t,r,theta,phi]   Métrica simétrica axialmente alterada

     'sistema_de_coordenadas' pode também ser uma lista de funções de
     transformação, seguida por uma lista contendo as varáveis
     coordenadas.  Por exemplo, pode especificar uma métrica esférica
     como segue:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
                r*sin(theta),[r,theta,phi]]);
          (%o2)                                done
          (%i3) lg:trigsimp(lg);
                                     [ 1  0         0        ]
                                     [                       ]
                                     [     2                 ]
          (%o3)                      [ 0  r         0        ]
                                     [                       ]
                                     [         2    2        ]
                                     [ 0  0   r  cos (theta) ]
          (%i4) ct_coords;
          (%o4)                           [r, theta, phi]
          (%i5) dim;
          (%o5)                                  3

     Funções de transformação podem também serem usadas quando
     'cframe_flag' for 'true':


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) cframe_flag:true;
          (%o2)                                true
          (%i3) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
                r*sin(theta),[r,theta,phi]]);
          (%o3)                                done
          (%i4) fri;
                [ cos(phi) cos(theta)  - cos(phi) r sin(theta)  - sin(phi) r cos(theta) ]
                [                                                                       ]
          (%o4) [ sin(phi) cos(theta)  - sin(phi) r sin(theta)   cos(phi) r cos(theta)  ]
                [                                                                       ]
                [     sin(theta)            r cos(theta)                   0            ]
          (%i5) cmetric();
          (%o5)                                false
          (%i6) lg:trigsimp(lg);
                                     [ 1  0         0        ]
                                     [                       ]
                                     [     2                 ]
          (%o6)                      [ 0  r         0        ]
                                     [                       ]
                                     [         2    2        ]
                                     [ 0  0   r  cos (theta) ]

     O argumento opcional <extra_arg> pode ser qualquer um dos
     seguintes:

     'cylindrical' diz a 'ct_coordsys' para anexar uma coordenada
     adicional cilíndrica.

     'minkowski' diz a 'ct_coordsys' para anexar uma coordenada com
     assinatura métrica negativa.

     'all' diz a 'ct_coordsys' para chamar 'cmetric' e 'christof(false)'
     após escolher a métrica.

     Se a variável global 'verbose' for escolhida para 'true',
     'ct_coordsys' mostra os valores de 'dim', 'ct_coords', e ou 'lg' ou
     'lfg' e 'fri', dependendo do valor de 'cframe_flag'.

 -- Função: init_ctensor ()
     Inicializa o pacote 'ctensor'.

     A função 'init_ctensor' reinicializa o pacote 'ctensor'.  Essa
     função remove todos os arrays e matrizes usados por 'ctensor',
     coloca todos os sinalizadores de volta a seus valores padrão,
     retorna 'dim' para 4, e retorna a métrica do referencial para a
     métrica do referencial de Lorentz.

28.2.2 Os tensores do espaço curvo
----------------------------------

O principal propósito do pacote 'ctensor' é calcular os tensores do
espaç(tempo) curvo, mais notavelmente os tensores usados na relatividade
geral.

Quando uma base métrica é usada, 'ctensor' pode calcular os seguintes
tensores:


      lg  -- ug
        \      \
         lcs -- mcs -- ric -- uric
                   \      \       \
                    \      tracer - ein -- lein
                     \
                      riem -- lriem -- weyl
                          \
                           uriem


'ctensor' pode também usar referenciais móveis.  Quando 'cframe_flag'
for escolhida para 'true', os seguintes tensores podem ser calculados:


      lfg -- ufg
          \
      fri -- fr -- lcs -- mcs -- lriem -- ric -- uric
           \                       |  \      \       \
            lg -- ug               |   weyl   tracer - ein -- lein
                                   |\
                                   | riem
                                   |
                                   \uriem

 -- Função: christof (<dis>)
     Uma função no pacote 'ctensor'.  Essa função calcula os símbolos de
     Christoffel de ambos os tipos.  O argumento <dis> determina quais
     resultados são para serem imediatamente mostrados.  Os símbolos de
     Christoffel de primeiro e de segundo tipo são armazenados nos
     arrays 'lcs[i,j,k]' e 'mcs[i,j,k]' respectivamente e definidos para
     serem simétricos nos primeiros dois índices.  Se o argumento para
     'christof' for 'lcs' ou for 'mcs' então o único valor não nulo de
     'lcs[i,j,k]' ou de 'mcs[i,j,k]', respectivamente, será mostrado.
     Se o argumento for 'all' então o único valor não nulo de
     'lcs[i,j,k]' e o único valor não nulo de 'mcs[i,j,k]' serão
     mostrados.  Se o argumento for 'false' então a exibição dos
     elementos não acontecerá.  Os elementos do array 'mcs[i,j,k]' são
     definidos de uma tal maneira que o índice final é contravariante.

 -- Função: ricci (<dis>)
     Uma função no pacote 'ctensor'.  'ricci' calcula as componentes
     contravariantes (simétricas) 'ric[i,j]' do tensor de Ricci.  Se o
     argumento <dis> for 'true', então as componentes não nulas são
     mostradas.

 -- Função: uricci (<dis>)
     Essa função primeiro calcula as componentes contravariantes
     'ric[i,j]' do tensor de Ricci.  Então o tensor misto de Ricci é
     calculado usando o tensor métrico contravariante.  Se o valor do
     argumento <dis> for 'true', então essas componentes mistas,
     'uric[i,j]' (o índice "i" é covariante e o índice "j" é
     contravariante), serão mostradas directamente.  De outra forma,
     'ricci(false)' irá simplesmente calcular as entradas do array
     'uric[i,j]' sem mostrar os resultados.

 -- Função: scurvature ()

     Retorna a curvatura escalar (obtida através da contração do tensor
     de Ricci) do Riemaniano multiplicado com a métrica dada.

 -- Função: einstein (<dis>)
     Uma função no pacote 'ctensor'.  'einstein' calcula o tensor misto
     de Einstein após os símbolos de Christoffel e o tensor de Ricci
     terem sido obtidos (com as funções 'christof' e 'ricci').  Se o
     argumento <dis> for 'true', então os valores não nulos do tensor
     misto de Einstein 'ein[i,j]' serão mostrados quando 'j' for o
     índice contravariante.  A variável 'rateinstein' fará com que a
     simplificação racional ocorra sobre esses componentes.  Se 'ratfac'
     for 'true' então as componentes irão também ser factoradas.

 -- Função: leinstein (<dis>)
     Tensor covariante de Einstein.  'leinstein' armazena o valor do
     tensor covariante de Einstein no array 'lein'.  O tensor covariante
     de Einstein é calculado a partir tensor misto de Einstein 'ein'
     através da multiplicação desse pelo tensor métrico.  Se o argumento
     <dis> for 'true', então os valores não nulos do tensor covariante
     de Einstein são mostrados.

 -- Função: riemann (<dis>)
     Uma função no pacote 'ctensor'.  'riemann' calcula o tensor de
     curvatura de Riemann a partir da métrica dada e correspondendo aos
     símbolos de Christoffel.  As seguintes convenções de índice são
     usadas:

                          l      _l       _l       _l   _m    _l   _m
           R[i,j,k,l] =  R    = |      - |      + |    |   - |    |
                          ijk     ij,k     ik,j     mk   ij    mj   ik

     Essa notação é consistente com a notação usada por no pacote
     'itensor' e sua função 'icurvature'.  Se o argumento opcional <dis>
     for 'true', as componentes não nulas 'riem[i,j,k,l]' serão
     mostradas.  Como com o tensor de Einstein, vários comutadores
     escolhidos pelo utilizador controlam a simplificação de componentes
     do tensor de Riemann.  Se 'ratriemann' for 'true', então
     simplificação racional será feita.  Se 'ratfac' for 'true' então
     cada uma das componentes irá também ser factorada.

     Se a variável 'cframe_flag' for 'false', o tensor de Riemann é
     calculado directamente dos símbolos de Christoffel.  Se
     'cframe_flag' for 'true', o tensor covariante de Riemann é
     calculado primeiro dos coeficientes de campo do referencial.

 -- Função: lriemann (<dis>)
     Tensor covariante de Riemann ('lriem[]').

     Calcula o tensor covariante de Riemann como o array 'lriem'.  Se o
     argumento <dis> for 'true', únicos valores não nulos são mostrados.

     Se a variável 'cframe_flag' for 'true', o tensor covariante de
     Riemann é calculado directamente dos coeficientes de campo do
     referencial.  De outra forma, o tensor (3,1) de Riemann é calculado
     primeiro.

     Para informação sobre a ordenação de índice, veja 'riemann'.

 -- Função: uriemann (<dis>)
     Calcula as componentes contravariantes do tensor de curvatura de
     Riemann como elementos do array 'uriem[i,j,k,l]'.  Esses são
     mostrados se <dis> for 'true'.

 -- Função: rinvariant ()
     Compõe o invariante de Kretchmann ('kinvariant') obtido através da
     contração dos tensores

          lriem[i,j,k,l]*uriem[i,j,k,l].

     Esse objecto não é automaticamente simplificado devido ao facto de
     poder ser muito largo.

 -- Função: weyl (<dis>)
     Calcula o tensor conformal de Weyl.  Se o argumento <dis> for
     'true', as componentes não nulas 'weyl[i,j,k,l]' irão ser mostradas
     para o utilizador.  De outra forma, essas componentes irão
     simplesmente serem calculadas e armazenadas.  Se o comutador
     'ratweyl' é escolhido para 'true', então as componentes irão ser
     racionalmente simplificadas; se 'ratfac' for 'true' então os
     resultados irão ser factorados também.

28.2.3 Expansão das séries de Taylor
------------------------------------

O pacote 'ctensor' possui a habilidade para truncar resultados assumindo
que eles são aproximações das séries de Taylor.  Esse comportamenteo é
controlado através da variável 'ctayswitch'; quando escolhida para
'true', 'ctensor' faz uso internamente da função 'ctaylor' quando
simplifica resultados.

A função 'ctaylor' é invocada pelas seguintes funções de 'ctensor':


         Function     Comments
         ---------------------------------
         christof()   só para mcs
         ricci()
         uricci()
         einstein()
         riemann()
         weyl()
         checkdiv()

 -- Função: ctaylor ()

     A função 'ctaylor' trunca seus argumentos através da conversão
     destes para uma série de Taylor usando 'taylor', e então chamando
     'ratdisrep'.  Isso tem efeito combinado de abandonar termos de
     ordem mais alta na variável de expansão 'ctayvar'.  A ordem dos
     termos que podem ser abandonados é definida através de 'ctaypov'; o
     ponto em torno do qual a expansão da série é realizada está
     especificado em 'ctaypt'.

     Como um exemplo, considere uma métrica simples que é uma
     perturbação da métrica de Minkowski.  Sem restrições adicionais,
     mesmo uma métrica diagonal produz expressões para o tensor de
     Einstein que são de longe muito complexas:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ratfac:true;
          (%o2)                                true
          (%i3) derivabbrev:true;
          (%o3)                                true
          (%i4) ct_coords:[t,r,theta,phi];
          (%o4)                         [t, r, theta, phi]
          (%i5) lg:matrix([-1,0,0,0],[0,1,0,0],[0,0,r^2,0],[0,0,0,r^2*sin(theta)^2]);
                                  [ - 1  0  0         0        ]
                                  [                            ]
                                  [  0   1  0         0        ]
                                  [                            ]
          (%o5)                   [          2                 ]
                                  [  0   0  r         0        ]
                                  [                            ]
                                  [              2    2        ]
                                  [  0   0  0   r  sin (theta) ]
          (%i6) h:matrix([h11,0,0,0],[0,h22,0,0],[0,0,h33,0],[0,0,0,h44]);
                                      [ h11   0    0    0  ]
                                      [                    ]
                                      [  0   h22   0    0  ]
          (%o6)                       [                    ]
                                      [  0    0   h33   0  ]
                                      [                    ]
                                      [  0    0    0   h44 ]
          (%i7) depends(l,r);
          (%o7)                               [l(r)]
          (%i8) lg:lg+l*h;
                   [ h11 l - 1      0          0                 0            ]
                   [                                                          ]
                   [     0      h22 l + 1      0                 0            ]
                   [                                                          ]
          (%o8)    [                        2                                 ]
                   [     0          0      r  + h33 l            0            ]
                   [                                                          ]
                   [                                    2    2                ]
                   [     0          0          0       r  sin (theta) + h44 l ]
          (%i9) cmetric(false);
          (%o9)                                done
          (%i10) einstein(false);
          (%o10)                               done
          (%i11) ntermst(ein);
          [[1, 1], 62]
          [[1, 2], 0]
          [[1, 3], 0]
          [[1, 4], 0]
          [[2, 1], 0]
          [[2, 2], 24]
          [[2, 3], 0]
          [[2, 4], 0]
          [[3, 1], 0]
          [[3, 2], 0]
          [[3, 3], 46]
          [[3, 4], 0]
          [[4, 1], 0]
          [[4, 2], 0]
          [[4, 3], 0]
          [[4, 4], 46]
          (%o12)                               done

     Todavia, se nós recalcularmos esse exemplo como uma aproximação que
     é linear na variável 'l', pegamos expressões muito simples:


          (%i14) ctayswitch:true;
          (%o14)                               true
          (%i15) ctayvar:l;
          (%o15)                                 l
          (%i16) ctaypov:1;
          (%o16)                                 1
          (%i17) ctaypt:0;
          (%o17)                                 0
          (%i18) christof(false);
          (%o18)                               done
          (%i19) ricci(false);
          (%o19)                               done
          (%i20) einstein(false);
          (%o20)                               done
          (%i21) ntermst(ein);
          [[1, 1], 6]
          [[1, 2], 0]
          [[1, 3], 0]
          [[1, 4], 0]
          [[2, 1], 0]
          [[2, 2], 13]
          [[2, 3], 2]
          [[2, 4], 0]
          [[3, 1], 0]
          [[3, 2], 2]
          [[3, 3], 9]
          [[3, 4], 0]
          [[4, 1], 0]
          [[4, 2], 0]
          [[4, 3], 0]
          [[4, 4], 9]
          (%o21)                               done
          (%i22) ratsimp(ein[1,1]);
                                   2      2  4               2     2
          (%o22) - (((h11 h22 - h11 ) (l )  r  - 2 h33 l    r ) sin (theta)
                                        r               r r

                                          2               2      4    2
                            - 2 h44 l    r  - h33 h44 (l ) )/(4 r  sin (theta))
                                     r r                r



     Essa compatibilidade pode ser útil, por exemplo, quando trabalhamos
     no limite do campo fraco longe de uma fonte gravitacional.

28.2.4 Campos de referencial
----------------------------

Quando a variável 'cframe_flag' for escolhida para 'true', o pacote
'ctensor' executa seus cálculos usando um referencial móvel.

 -- Função: frame_bracket (<fr>, <fri>, <diagframe>)
     O delimitador do referencial ('fb[]').

     Calcula o delimitador do referencial conforme a seguinte definição:

             c          c         c        d     e
          ifb   = ( ifri    - ifri    ) ifr   ifr
             ab         d,e       e,d      a     b

28.2.5 Classificação Algébrica
------------------------------

Um novo recurso (a partir de November de 2004) de 'ctensor' é sua
habilidade para calcular a classificação de Petrov de uma métrica espaço
tempo tetradimensional.  Para uma demonstração dessa compatibilidade,
veja o ficheiro 'share/tensor/petrov.dem'.

 -- Função: nptetrad ()
     Calcula um tetrad nulo de Newman-Penrose ('np') e seus índices
     ascendentes em contrapartida ('npi').  Veja 'petrov' para um
     exemplo.

     O tetrad nulo é construído assumindo que um referencial métrico
     ortonormal tetradimensional com assinatura métrica (-,+,+,+) está
     sendo usada.  As componentes do tetrad nulo são relacionadas para a
     matriz referencial inversa como segue:


          np  = (fri  + fri ) / sqrt(2)
            1       1      2

          np  = (fri  - fri ) / sqrt(2)
            2       1      2

          np  = (fri  + %i fri ) / sqrt(2)
            3       3         4

          np  = (fri  - %i fri ) / sqrt(2)
            4       3         4

 -- Função: psi (<dis>)
     Calcula os cinco coeficientes de Newman-Penrose
     'psi[0]'...'psi[4]'.  Se 'psi' for escolhida para 'true', os
     coeficientes são mostrados.  Veja 'petrov' para um exemplo.

     Esses coeficientes são calculados a partir do tensor de Weyl em uma
     base de coordenada.  Se uma base de referencial for usada, o tensor
     de Weyl é primeiro convertido para a base de coordenada, que pode
     ser um procedimento computacional expansível.  Por essa razão, em
     alguns casos pode ser mais vantajoso usar uma base de coordenada em
     primeiro lugar antes que o tensor de Weyl seja calculado.  Note
     todavia, que para a construção de um tetrad nulo de Newman-Penrose
     é necessário uma base de referencial.  Portanto, uma sequência de
     cálculo expressiva pode começar com uma base de referencial, que é
     então usada para calcular 'lg' (calculada automaticamente através
     de 'cmetric') e em seguida calcula 'ug'.  Nesse ponto, pode comutar
     de volta para uma base de coordenada escolhendo 'cframe_flag' para
     'false' antes de começar a calcular os símbolos de Christoffel.
     Mudando para uma base de referencial num estágio posterior pode
     retornar resultados inconsistentes, já que pode terminar com uma
     grande mistura de tensores, alguns calculados numa base de
     referencial, e outros numa base de coordenada, sem nenhum modo para
     distinguir entre os dois tipos.

 -- Função: petrov ()
     Calcula a classificação de petrov da métrica caracterizada através
     de 'psi[0]'...'psi[4]'.

     Por exemplo, o seguinte demonstra como obter a classificação de
     Petrov da métrica de Kerr:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) (cframe_flag:true,gcd:spmod,ctrgsimp:true,ratfac:true);
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) ug:invert(lg)$
          (%i5) weyl(false);
          (%o5)                                done
          (%i6) nptetrad(true);
          (%t6) np =

                 [  sqrt(r - 2 m)           sqrt(r)                                     ]
                 [ ---------------   ---------------------      0             0         ]
                 [ sqrt(2) sqrt(r)   sqrt(2) sqrt(r - 2 m)                              ]
                 [                                                                      ]
                 [  sqrt(r - 2 m)            sqrt(r)                                    ]
                 [ ---------------  - ---------------------     0             0         ]
                 [ sqrt(2) sqrt(r)    sqrt(2) sqrt(r - 2 m)                             ]
                 [                                                                      ]
                 [                                              r      %i r sin(theta)  ]
                 [        0                    0             -------   ---------------  ]
                 [                                           sqrt(2)       sqrt(2)      ]
                 [                                                                      ]
                 [                                              r       %i r sin(theta) ]
                 [        0                    0             -------  - --------------- ]
                 [                                           sqrt(2)        sqrt(2)     ]

                                       sqrt(r)          sqrt(r - 2 m)
          (%t7) npi = matrix([- ---------------------, ---------------, 0, 0],
                                sqrt(2) sqrt(r - 2 m)  sqrt(2) sqrt(r)

                    sqrt(r)            sqrt(r - 2 m)
          [- ---------------------, - ---------------, 0, 0],
             sqrt(2) sqrt(r - 2 m)    sqrt(2) sqrt(r)

                     1               %i
          [0, 0, ---------, --------------------],
                 sqrt(2) r  sqrt(2) r sin(theta)

                     1                 %i
          [0, 0, ---------, - --------------------])
                 sqrt(2) r    sqrt(2) r sin(theta)

          (%o7)                                done
          (%i7) psi(true);
          (%t8)                              psi  = 0
                                                0

          (%t9)                              psi  = 0
                                                1

                                                    m
          (%t10)                             psi  = --
                                                2    3
                                                    r

          (%t11)                             psi  = 0
                                                3

          (%t12)                             psi  = 0
                                                4
          (%o12)                               done
          (%i12) petrov();
          (%o12)                                 D

     A função de classificação Petrov é baseada no algoritmo publicado
     em "Classifying geometries in general relativity: III
     Classification in practice" por Pollney, Skea, e d'Inverno, Class.
     Quant.  Grav.  17 2885-2902 (2000).  Exceto para alguns casos de
     teste simples, a implementação não está testada até 19 de Dezembro
     de 2004, e é provável que contenha erros.

28.2.6 Torsão e não metricidade
-------------------------------

'ctensor' possui a habilidade de calcular e incluir coeficientes de
torsão e não metricidade nos coeficientes de conecção.

Os coeficientes de torsão são calculados a partir de um tensor fornecido
pelo utilizador 'tr', que pode ser um tensor de categoria (2,1).  A
partir disso, os coeficientes de torsão 'kt' são calculados de acordo
com a seguinte fórmula:


                   m          m      m
            - g  tr   - g   tr   - tr   g
               im  kj    jm   ki     ij  km
     kt   = -------------------------------
       ijk                 2


       k     km
     kt   = g   kt
       ij         ijm

Note que somente o tensor de índice misto é calculao e armazenado no
array 'kt'.

Os coeficientes de não metricidade são calculados a partir do vector de
não metricidade fornecido pelo utilizador 'nm'.  A partir disso, os
coeficientes de não metricidade 'nmc' são calculados como segue:


                  k    k        km
            -nm  D  - D  nm  + g   nm  g
        k      i  j    i   j         m  ij
     nmc  = ------------------------------
        ij                2

onde D simboliza o delta de Kronecker.

Quando 'ctorsion_flag' for escolhida para 'true', os valores de 'kt' são
subtraídos dos coeficientes de conecção indexados mistos calculados
através de 'christof' e armazenados em 'mcs'.  Similarmente, se
'cnonmet_flag' for escolhida para 'true', os valores de 'nmc' são
subtraídos dos coeficientes de conecção indexados mistos.

Se necessário, 'christof' chama as funções 'contortion' e 'nonmetricity'
com o objectivo de calcular 'kt' e 'nm'.

 -- Função: contortion (<tr>)

     Calcula os coeficientes de contorsão de categoria (2,1) a partir do
     tensor de torsão <tr>.

 -- Função: nonmetricity (<nm>)

     Calcula o coeficiente de não metricidade de categoria (2,1) a
     partir do vector de não metricidade <nm>.

28.2.7 Recursos diversos
------------------------

 -- Função: ctransform (<M>)
     Uma função no pacote 'ctensor' que irá executar uma transformação
     de coordenadas sobre uma matriz simétrica quadrada arbitrária <M>.
     O utilizador deve informar as funçãoes que definem a transformação.
     (Formalmente chamada 'transform'.)

 -- Função: findde (<A>, <n>)

     Retorna uma lista de equações diferenciais únicas (expressões)
     correspondendo aos elementos do array quadrado <n> dimensional <A>.
     Actualmente, <n> pode ser 2 ou 3.  'deindex' é uma lista global
     contendo os índices de <A> correspondendo a essas únicas equações
     diferenciais.  Para o tensor de Einstein ('ein'), que é um array
     dimensional, se calculado para a métrica no exemplo abaixo,
     'findde' fornece as seguintes equações diferenciais independentes:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) dim:4;
          (%o3)                                  4
          (%i4) lg:matrix([a,0,0,0],[0,x^2,0,0],[0,0,x^2*sin(y)^2,0],[0,0,0,-d]);
                                    [ a  0       0        0  ]
                                    [                        ]
                                    [     2                  ]
                                    [ 0  x       0        0  ]
          (%o4)                     [                        ]
                                    [         2    2         ]
                                    [ 0  0   x  sin (y)   0  ]
                                    [                        ]
                                    [ 0  0       0       - d ]
          (%i5) depends([a,d],x);
          (%o5)                            [a(x), d(x)]
          (%i6) ct_coords:[x,y,z,t];
          (%o6)                            [x, y, z, t]
          (%i7) cmetric();
          (%o7)                                done
          (%i8) einstein(false);
          (%o8)                                done
          (%i9) findde(ein,2);
                                                      2
          (%o9) [d  x - a d + d, 2 a d d    x - a (d )  x - a  d d  x + 2 a d d
                  x                     x x         x        x    x            x

                                                                  2          2
                                                          - 2 a  d , a  x + a  - a]
                                                               x      x
          (%i10) deindex;
          (%o10)                     [[1, 1], [2, 2], [4, 4]]

 -- Função: cograd ()
     Calcula o gradiente covariante de uma função escalar permitindo ao
     utilizador escolher o nome do vector correspondente como o exemplo
     sob 'contragrad' ilustra.
 -- Função: contragrad ()

     Calcula o gradiente contravariante de uma função escalar permitindo
     ao utilizador escolher o nome do vector correspondente como o
     exemplo abaixo como ilustra a métrica de Schwarzschild:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) depends(f,r);
          (%o4)                               [f(r)]
          (%i5) cograd(f,g1);
          (%o5)                                done
          (%i6) listarray(g1);
          (%o6)                            [0, f , 0, 0]
                                                r
          (%i7) contragrad(f,g2);
          (%o7)                                done
          (%i8) listarray(g2);
                                         f  r - 2 f  m
                                          r        r
          (%o8)                      [0, -------------, 0, 0]
                                               r

 -- Função: dscalar ()
     Calcula o tensor d'Alembertiano da função escalar assim que as
     dependências tiverem sido declaradas sobre a função.  Po exemplo:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) depends(p,r);
          (%o4)                               [p(r)]
          (%i5) factor(dscalar(p));
                                    2
                              p    r  - 2 m p    r + 2 p  r - 2 m p
                               r r           r r        r          r
          (%o5)               --------------------------------------
                                                 2
                                                r

 -- Função: checkdiv ()

     Calcula a divergência covariante do tensor de segunda categoria
     misto (cujo primeiro índice deve ser covariante) imprimindo as
     correspondentes n componentes do campo do vector (a divergência)
     onde n = 'dim'.  Se o argumento para a função for 'g' então a
     divergência do tensor de Einstein será formada e pode ser zero.
     Adicionalmente, a divergência (vector) é dada no array chamado
     'div'.

 -- Função: cgeodesic (<dis>)
     Uma função no pacote 'ctensor'.  'cgeodesic' calcula as equações
     geodésicas de movimento para uma dada métrica.  Elas são
     armazenadas no array 'geod[i]'.  Se o argumento <dis> for 'true'
     então essas equações são mostradas.

 -- Função: bdvac (<f>)

     Gera as componentes covariantes das equações de campo de vácuo da
     teoria de gravitação de Brans-Dicke.  O campo escalar é
     especificado através do argumento <f>, que pode ser um nome de
     função (com apóstrofo) com dependências funcionais, e.g., ''p(x)'.

     As componentes de segunda categoria do tensor campo covariante são
     as componentes de segunda categoria representadas pelo array 'bd'.

 -- Função: invariant1 ()

     Gera o tensor misto de Euler-Lagrange (equações de campo) para a
     densidade invariante de R^2.  As equações de campo são componentes
     de um array chamado 'inv1'.

 -- Função: invariant2 ()

     *** NOT YET IMPLEMENTED ***

     Gera o tensor misto de Euler-Lagrange (equações de campo) para a
     densidade invariante de 'ric[i,j]*uriem[i,j]'.  As equações de
     campo são as componentes de um array chamado 'inv2'.

 -- Função: bimetric ()

     *** NOT YET IMPLEMENTED ***

     Gera as euauações de campo da teoria bimétrica de Rosen.  As
     equações de campo são as componentes de um array chamado 'rosen'.

28.2.8 Funções utilitárias
--------------------------

 -- Função: diagmatrixp (<M>)

     Retorna 'true' se <M> for uma matriz diagonal ou um array (2D).

 -- Função: symmetricp (<M>)

     Retorna 'true' se <M> for uma matriz simétrica ou um array (2D).

 -- Função: ntermst (<f>)
     Fornece ao utilizador um rápido quadro do "tamanho" do tensor
     duplamente subscrito (array) <f>.  Imprime uma lista de dois
     elementos onde o segundo elemento corresponde a N-TERMOS de
     componentes especificadas através dos primeiros elementos.  Nesse
     caminho, é possível rapidamente encontrar as expressões não nulas e
     tentar simplificação.

 -- Função: cdisplay (<ten>)
     Mostra todos os elementos do tensor <ten>, como representados por
     um array multidimensional.  Tensores de categoria 0 e 1, assim como
     outros tipos de variáveis, são mostrados com 'ldisplay'.  Tensores
     de categoria 2 são mostrados como matrizes bidimensionais, enquanto
     tensores de alta categoria são mostrados como uma lista de matrizes
     bidimensionais.  Por exemplo, o tensor de Riemann da métrica de
     Schwarzschild pode ser visto como:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ratfac:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) riemann(false);
          (%o4)                                done
          (%i5) cdisplay(riem);
                         [ 0               0                    0            0      ]
                         [                                                          ]
                         [                              2                           ]
                         [      3 m (r - 2 m)   m    2 m                            ]
                         [ 0  - ------------- + -- - ----       0            0      ]
                         [            4          3     4                            ]
                         [           r          r     r                             ]
                         [                                                          ]
              riem     = [                                 m (r - 2 m)              ]
                  1, 1   [ 0               0               -----------       0      ]
                         [                                      4                   ]
                         [                                     r                    ]
                         [                                                          ]
                         [                                              m (r - 2 m) ]
                         [ 0               0                    0       ----------- ]
                         [                                                   4      ]
                         [                                                  r       ]

                                          [    2 m (r - 2 m)       ]
                                          [ 0  -------------  0  0 ]
                                          [          4             ]
                                          [         r              ]
                               riem     = [                        ]
                                   1, 2   [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]

                                          [         m (r - 2 m)    ]
                                          [ 0  0  - -----------  0 ]
                                          [              4         ]
                                          [             r          ]
                               riem     = [                        ]
                                   1, 3   [ 0  0        0        0 ]
                                          [                        ]
                                          [ 0  0        0        0 ]
                                          [                        ]
                                          [ 0  0        0        0 ]

                                          [            m (r - 2 m) ]
                                          [ 0  0  0  - ----------- ]
                                          [                 4      ]
                                          [                r       ]
                               riem     = [                        ]
                                   1, 4   [ 0  0  0        0       ]
                                          [                        ]
                                          [ 0  0  0        0       ]
                                          [                        ]
                                          [ 0  0  0        0       ]

                                         [       0         0  0  0 ]
                                         [                         ]
                                         [       2 m               ]
                                         [ - ------------  0  0  0 ]
                              riem     = [    2                    ]
                                  2, 1   [   r  (r - 2 m)          ]
                                         [                         ]
                                         [       0         0  0  0 ]
                                         [                         ]
                                         [       0         0  0  0 ]

                             [     2 m                                         ]
                             [ ------------  0        0               0        ]
                             [  2                                              ]
                             [ r  (r - 2 m)                                    ]
                             [                                                 ]
                             [      0        0        0               0        ]
                             [                                                 ]
                  riem     = [                         m                       ]
                      2, 2   [      0        0  - ------------        0        ]
                             [                     2                           ]
                             [                    r  (r - 2 m)                 ]
                             [                                                 ]
                             [                                         m       ]
                             [      0        0        0         - ------------ ]
                             [                                     2           ]
                             [                                    r  (r - 2 m) ]

                                          [ 0  0       0        0 ]
                                          [                       ]
                                          [            m          ]
                                          [ 0  0  ------------  0 ]
                               riem     = [        2              ]
                                   2, 3   [       r  (r - 2 m)    ]
                                          [                       ]
                                          [ 0  0       0        0 ]
                                          [                       ]
                                          [ 0  0       0        0 ]

                                          [ 0  0  0       0       ]
                                          [                       ]
                                          [               m       ]
                                          [ 0  0  0  ------------ ]
                               riem     = [           2           ]
                                   2, 4   [          r  (r - 2 m) ]
                                          [                       ]
                                          [ 0  0  0       0       ]
                                          [                       ]
                                          [ 0  0  0       0       ]

                                                [ 0  0  0  0 ]
                                                [            ]
                                                [ 0  0  0  0 ]
                                                [            ]
                                     riem     = [ m          ]
                                         3, 1   [ -  0  0  0 ]
                                                [ r          ]
                                                [            ]
                                                [ 0  0  0  0 ]

                                                [ 0  0  0  0 ]
                                                [            ]
                                                [ 0  0  0  0 ]
                                                [            ]
                                     riem     = [    m       ]
                                         3, 2   [ 0  -  0  0 ]
                                                [    r       ]
                                                [            ]
                                                [ 0  0  0  0 ]

                                         [   m                      ]
                                         [ - -   0   0       0      ]
                                         [   r                      ]
                                         [                          ]
                                         [        m                 ]
                                         [  0   - -  0       0      ]
                              riem     = [        r                 ]
                                  3, 3   [                          ]
                                         [  0    0   0       0      ]
                                         [                          ]
                                         [              2 m - r     ]
                                         [  0    0   0  ------- + 1 ]
                                         [                 r        ]

                                              [ 0  0  0    0   ]
                                              [                ]
                                              [ 0  0  0    0   ]
                                              [                ]
                                   riem     = [            2 m ]
                                       3, 4   [ 0  0  0  - --- ]
                                              [             r  ]
                                              [                ]
                                              [ 0  0  0    0   ]

                                          [       0        0  0  0 ]
                                          [                        ]
                                          [       0        0  0  0 ]
                                          [                        ]
                               riem     = [       0        0  0  0 ]
                                   4, 1   [                        ]
                                          [      2                 ]
                                          [ m sin (theta)          ]
                                          [ -------------  0  0  0 ]
                                          [       r                ]

                                          [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]
                                          [                        ]
                               riem     = [ 0        0        0  0 ]
                                   4, 2   [                        ]
                                          [         2              ]
                                          [    m sin (theta)       ]
                                          [ 0  -------------  0  0 ]
                                          [          r             ]

                                        [ 0  0          0          0 ]
                                        [                            ]
                                        [ 0  0          0          0 ]
                                        [                            ]
                             riem     = [ 0  0          0          0 ]
                                 4, 3   [                            ]
                                        [                2           ]
                                        [         2 m sin (theta)    ]
                                        [ 0  0  - ---------------  0 ]
                                        [                r           ]

                           [        2                                             ]
                           [   m sin (theta)                                      ]
                           [ - -------------         0                0         0 ]
                           [         r                                            ]
                           [                                                      ]
                           [                         2                            ]
                           [                    m sin (theta)                     ]
                riem     = [        0         - -------------         0         0 ]
                    4, 4   [                          r                           ]
                           [                                                      ]
                           [                                          2           ]
                           [                                   2 m sin (theta)    ]
                           [        0                0         ---------------  0 ]
                           [                                          r           ]
                           [                                                      ]
                           [        0                0                0         0 ]

          (%o5)                                done

 -- Função: deleten (<L>, <n>)
     Retorna uma nova lista consistindo de <L> com o <n>'ésimo elemento
     apagado.

28.2.9 Variáveis usadas por 'ctensor'
-------------------------------------

 -- Variável de opção: dim
     Valor por omissão: 4

     Uma opção no pacote 'ctensor'.  'dim' é a dimensão de multiplicação
     com o padrão 4.  O comando 'dim: n' irá escolher a dimensão para
     qualquer outro valor 'n'.

 -- Variável de opção: diagmetric
     Valor por omissão: 'false'

     Uma opção no pacote 'ctensor'.  Se 'diagmetric' for 'true' rotinas
     especiais calculam todos os objectos geométricos (que possuem o
     tensor métrico explicitamente) levando em consideração a
     diagonalidade da métrica.  Tempo de execuçào reduzido irá, com
     certeza, resultar dessa escolha.  Nota: essa opção é escolhida
     automaticamente por 'csetup' se uma métrica diagonal for
     especificada.

 -- Variável de opção: ctrgsimp

     Faz com que simplificações trigonométricas sejam usadas quando
     tensores forem calculados.  Actualmente, 'ctrgsimp' afecta somente
     cálculos envolvendo um referencial móvel.

 -- Variável de opção: cframe_flag

     Faz com que cálculos sejam executados relativamente a um
     referencial móvel em oposição a uma métrica holonómica.  O
     referencial é definido através do array do referencial inverso
     'fri' e da métrica do referencial 'lfg'.  Para cálculos usando um
     referencial Cartesiano, 'lfg' pode ser a matriz unitária de
     dimensão apropriada; para cálculos num referencial de Lorentz,
     'lfg' pode ter a assinatura apropriada.

 -- Variável de opção: ctorsion_flag

     Faz com que o tensor de contorsão seja incluído no cálculo dos
     coeficientes de conecção.  O tensor de contorsão por si mesmo é
     calculado através de 'contortion' a partir do tensor 'tr' fornecido
     pelo utilizador.

 -- Variável de opção: cnonmet_flag

     Faz com que os coeficientes de não metricidade sejam incluídos no
     cálculo dos coeficientes de conecção.  Os coeficientes de não
     metricidade são calculados a partir do vector de não metricidade
     'nm' fornecido pelo utilizador através da função 'nonmetricity'.

 -- Variável de opção: ctayswitch

     Se escolhida para 'true', faz com que alguns cálculos de 'ctensor'
     sejam realizados usando expansões das séries de Taylor.
     actualmente, 'christof', 'ricci', 'uricci', 'einstein', e 'weyl'
     levam em conta essa escolha.

 -- Variável de opção: ctayvar

     Variável usada pela expansão de séries de Taylor se 'ctayswitch' é
     escolhida para 'true'.

 -- Variável de opção: ctaypov

     Maximo expoente usado em expansões de séries de Taylor quando
     'ctayswitch' for escolhida para 'true'.

 -- Variável de opção: ctaypt

     Ponto em torno do qual expansões de séries de Taylor sao realizadas
     quando 'ctayswitch' for escolhida para 'true'.

 -- Variável de sistema: gdet

     O determinante do tensor métrico 'lg'.  Calculado através de
     'cmetric' quando 'cframe_flag' for escolhido para 'false'.

 -- Variável de opção: ratchristof

     Faz com que simplificações racionais sejam aplicadas através de
     'christof'.

 -- Variável de opção: rateinstein
     Valor por omissão: 'true'

     Se 'true' simplificação racional será executada sobre as
     componentes não nulas de tensores de Einstein; se 'ratfac' for
     'true' então as componentes irão também ser factoradas.

 -- Variável de opção: ratriemann
     Valor por omissão: 'true'

     Um dos comutadores que controlam simplificações dos tensores de
     Riemann; se 'true', então simplificações racionais irão ser
     concluídas; se 'ratfac' for 'true' então cada uma das componentes
     irá também ser factorada.

 -- Variável de opção: ratweyl
     Valor por omissão: 'true'

     Se 'true', esse comutador faz com que a função de 'weyl' aplique
     simplificações racionais aos valores do tensor de Weyl.  Se
     'ratfac' for 'true', então as componentes irão também ser
     factoradas.

 -- Variável: lfg
     O referencial métrico covariante.  Por padrão, é inicializado para
     o referencial tetradimensional de Lorentz com assinatura (+,+,+,-).
     Usada quando 'cframe_flag' for 'true'.

 -- Variável: ufg
     A métrica do referencial inverso.  Calculada de 'lfg' quando
     'cmetric' for chamada enquanto 'cframe_flag' for escolhida para
     'true'.

 -- Variável: riem
     O tensor de categoria (3,1) de Riemann.  Calculado quando a função
     'riemann' é invocada.  Para informação sobre ordenação de índices,
     veja a descrição de 'riemann'.

     Se 'cframe_flag' for 'true', 'riem' é calculado a partir do tensor
     covariante de Riemann 'lriem'.

 -- Variável: lriem

     O tensor covariante de Riemann.  Calculado através de 'lriemann'.

 -- Variável: uriem

     O tensor contravariante de Riemann.  Calculado através de
     'uriemann'.

 -- Variável: ric

     O tensor misto de Ricci.  Calculado através de 'ricci'.

 -- Variável: uric

     O tensor contravariante de Ricci.  Calculado através de 'uricci'.

 -- Variável: lg

     O tensor métrico.  Esse tensor deve ser especificado (como uma
     'dim' através da matriz 'dim') antes que outro cálculo possa ser
     executado.

 -- Variável: ug

     O inverso do tensor métrico.  Calculado através de 'cmetric'.

 -- Variável: weyl

     O tensor de Weyl.  Calculado através de 'weyl'.

 -- Variável: fb

     Coeficientes delimitadores do referencial, como calculado através
     de 'frame_bracket'.

 -- Variável: kinvariant

     O invariante de Kretchmann.  Calculado através de 'rinvariant'.

 -- Variável: np

     Um tetrad nulo de Newman-Penrose.  Calculado através de 'nptetrad'.

 -- Variável: npi

     O índice ascendente do tetrad nulo de Newman-Penrose.  Calculado
     através de 'nptetrad'.  Definido como 'ug.np'.  O produto
     'np.transpose(npi)' é constante:

          (%i39) trigsimp(np.transpose(npi));
                                        [  0   - 1  0  0 ]
                                        [                ]
                                        [ - 1   0   0  0 ]
          (%o39)                        [                ]
                                        [  0    0   0  1 ]
                                        [                ]
                                        [  0    0   1  0 ]

 -- Variável: tr

     Tensor de categoria 3 fornecido pelo utilizador representando
     torsão.  Usado por 'contortion'.

 -- Variável: kt

     O tensor de contorsão, calculado a partir de 'tr' através de
     'contortion'.

 -- Variável: nm

     Vetor de não metrcidade fornecido pelo utilizador.  Usado por
     'nonmetricity'.

 -- Variável: nmc

     Os coeficientes de não metricidade, calculados a partir de 'nm' por
     'nonmetricity'.

 -- Variável de sistema: tensorkill

     Variável indicando se o pacote tensor foi inicializado.  Escolhida
     e usada por 'csetup', retornada ao seu valor original através de
     'init_ctensor'.

 -- Variável de opção: ct_coords
     Valor por omissão: '[]'

     Uma opção no pacote 'ctensor'.  'ct_coords' contém uma lista de
     coordenadas.  Enquanto normalmente definida quando a função
     'csetup' for chamada, se pode redefinir as coordenadas com a
     atribuição 'ct_coords: [j1, j2, ..., jn]' onde os j's são os novos
     nomes de coordenadas.  Veja também 'csetup'.

28.2.10 Nomes reservados
------------------------

Os seguintes nomes são usados internamente pelo pacote 'ctensor' e não
devem ser redefinidos:

       Name         Description
       ---------------------------------------
       _lg()        Avalia para lfg se for usado o referencial métrico,
                         para lg de outra forma
       _ug()        Avalia para ufg se for usado o referencial métrico,
                         para ug de outra forma
       cleanup()    Remove ítens da lista deindex
       contract4()  Usado por psi()
       filemet()    Usado por csetup() quando lendo a métrica de um ficheiro
       findde1()    Usado por findde()
       findde2()    Usado por findde()
       findde3()    Usado por findde()
       kdelt()      Delta de Kronecker (não generalizado)
       newmet()     Usado por csetup() para escolher uma métrica
                         interativamente
       setflags()   Usado por init_ctensor()
       readvalue()
       resimp()
       sermet()     Usado por csetup() para informar uma métricacom série
                         de Taylor
       txyzsum()
       tmetric()    Referencial métrico, usado por cmetric() quando
                         cframe_flag:true
       triemann()   Tensor de Riemann na base do referencial, usado quando
                         cframe_flag:true
       tricci()     Tensor de Ricci na base do referencial, usado quando
                         cframe_flag:true
       trrc()       Coeficientes de rotação de Ricci, usado por
                         christof()
       yesp()

28.2.11 Modificações
--------------------

Em Novembro de 2004, o pacote 'ctensor' foi extensivamente reescrito.
Muitas funções e variáveis foram renomeadas com o objectivo de tornar o
pacote com a versão comercial do Macsyma.

       Novo Nome    Nome Antigo     Descrição
       --------------------------------------------------------------------
       ctaylor()    DLGTAYLOR()     Expansão da série de Taylor de uma
       -----------------------------expressão
       lgeod[]      EM              Equações geodésicas
       ein[]        G[]             Tensor misto de Einstein
       ric[]        LR[]            Tensor misto de Ricci
       ricci()      LRICCICOM()     Calcula o tensor misto de Ricci
       ctaypov      MINP            Maximo expoente em expansões de séries de
       -----------------------------Taylor
       cgeodesic()  MOTION          Calcula as equações geodésicas
       ct_coords    OMEGA           Coordenadas métricas
       ctayvar      PARAM           Variável de expansão de séries de
       -----------------------------Taylor
       lriem[]      R[]             Tensor covariante de Riemann
       uriemann()   RAISERIEMANN()  Calcula o tensor contravariante de
       -----------------------------Riemann
       ratriemann   RATRIEMAN       Simplificação racional do tensor de
       -----------------------------Riemann
       uric[]       RICCI[]         Tensor de Ricci contravariante
       uricci()     RICCICOM()      Calcula o tensor de Ricci contravariante
       cmetric()    SETMETRIC()     Escolhe a métrica
       ctaypt       TAYPT           Ponto para expansões de séries de Taylor
       ctayswitch   TAYSWITCH       Escolhe o comutador de séries de Taylor
       csetup()     TSETUP()        Inicia sessão interativa de configuração
       ctransform() TTRANSFORM()    Transformação de coordenadas interativa
       uriem[]      UR[]            Tensor contravariante de Riemann
       weyl[]       W[]             Tensor (3,1) de Weyl


File: maxima.info,  Node: Pacote atensor,  Next: Séries,  Prev: ctensor,  Up: Top

29 Pacote atensor
*****************

* Menu:

* Introdução ao Pacote atensor::
* Definições para o Pacote atensor::


File: maxima.info,  Node: Introdução ao Pacote atensor,  Next: Definições para o Pacote atensor,  Prev: Pacote atensor,  Up: Pacote atensor

29.1 Introdução ao Pacote atensor
=================================

'atensor' é um pacote de manipulção de tensores algébricos.  Para usar
'atensor', digite 'load(atensor)', seguido por uma chamada à função
'init_atensor'.

A essência de 'atensor' é um conjunto de regras de simplificação para o
operador de produto (ponto) não comutativo ("'.'").  'atensor' reconhece
muitos tipos de álgebra; as regras de simplificação correspondentes são
activadas quando a função 'init_atensor' é chamada.

A compatibilidade de 'atensor' pode ser demonstrada pela definição da
álgebra de quaterniões como uma álgebra de Clifford Cl(0,2) com dois
vectores fundamentais.  As três unidades quaterniónicas imaginárias
fundamentais são então os dois vectores base e seu produto, i.e.:

         i = v     j = v     k = v  .  v
              1         2         1    2

Embora o pacote 'atensor' tenha uma definição interna para a álgebra dos
quaterniões, isso não foi usado nesse exemplo, no qual nós nos
esforçamos para construir a tabela de multiplicação dos quaterniões como
uma matriz:


     (%i1) load(atensor);
     (%o1)       /share/tensor/atensor.mac
     (%i2) init_atensor(clifford,0,0,2);
     (%o2)                                done
     (%i3) atensimp(v[1].v[1]);
     (%o3)                                 - 1
     (%i4) atensimp((v[1].v[2]).(v[1].v[2]));
     (%o4)                                 - 1
     (%i5) q:zeromatrix(4,4);
                                     [ 0  0  0  0 ]
                                     [            ]
                                     [ 0  0  0  0 ]
     (%o5)                           [            ]
                                     [ 0  0  0  0 ]
                                     [            ]
                                     [ 0  0  0  0 ]
     (%i6) q[1,1]:1;
     (%o6)                                  1
     (%i7) for i thru adim do q[1,i+1]:q[i+1,1]:v[i];
     (%o7)                                done
     (%i8) q[1,4]:q[4,1]:v[1].v[2];
     (%o8)                               v  .  v
                                          1    2
     (%i9) for i from 2 thru 4 do for j from 2 thru 4 do
           q[i,j]:atensimp(q[i,1].q[1,j]);
     (%o9)                                done
     (%i10) q;
                        [    1        v         v      v  .  v  ]
                        [              1         2      1    2 ]
                        [                                      ]
                        [   v         - 1     v  .  v    - v    ]
                        [    1                 1    2      2   ]
     (%o10)             [                                      ]
                        [   v      - v  .  v     - 1      v     ]
                        [    2        1    2              1    ]
                        [                                      ]
                        [ v  .  v      v        - v       - 1   ]
                        [  1    2      2          1            ]

'atensor' reconhece como bases vectoriais símbolos indexados, onde o
símbolo é aquele armazenado em 'asymbol' e o iíndice está entre 1 e
'adim'.  Para símbolos indexado, e somente para símbolos indexados, as
formas bilineares 'sf', 'af', e 'av' são avaliadas.  A avaliação
substitui os valores de 'aform[i,j]' em lugar de 'fun(v[i],v[j])' onde
'v' representa o valor de 'asymbol' e 'fun' é ainda 'af' ou 'sf'; ou,
isso substitui 'v[aform[i,j]]' em lugar de 'av(v[i],v[j])'.

Desnecessário dizer, as funções 'sf', 'af' e 'av' podem ser redefinidas.

Quando o pacote 'atensor' é chamado, os seguintes sinalizadores são
configurados:

     dotscrules:true;
     dotdistrib:true;
     dotexptsimp:false;

Se quiser experimentar com uma álgebra não associativa, pode também
considerar a configuração de 'dotassoc' para 'false'.  Nesse caso,
todavia, 'atensimp' não stará sempre habilitado a obter as
simplificações desejadas.


File: maxima.info,  Node: Definições para o Pacote atensor,  Prev: Introdução ao Pacote atensor,  Up: Pacote atensor

29.2 Definições para o Pacote atensor
=====================================

 -- Função: init_atensor (<alg_type>, <opt_dims>)
 -- Função: init_atensor (<alg_type>)

     Inicializa o pacote 'atensor' com o tipo especificado de álgebra.
     <alg_type> pode ser um dos seguintes:

     'universal': A álgebra universal tendo regras não comutativas.

     'grassmann': A álgebra de Grassman é definida pela relação de
     comutação 'u.v+v.u=0'.

     'clifford': A álgebra de Clifford é definida pela relação de
     comutação 'u.v+v.u=-2*sf(u,v)' onde 'sf' é a função valor-escalar
     simétrico.  Para essa álgebra, <opt_dims> pode ser acima de três
     inteiros não negativos, representando o número de dimensões
     positivas, dimensões degeneradas, e dimensões negativas da álgebra,
     respectivamente.  Se quaisquer valores <opt_dims> são fornecidos,
     'atensor' irá configurar os valores de 'adim' e 'aform'
     apropriadamente.  Caso contrário, 'adim' irá por padrão para 0 e
     'aform' não será definida.

     'symmetric': A álgebra simétrica é definida pela relação de
     comutação 'u.v-v.u=0'.

     'symplectic': A álgebra simplética é definida pela relação de
     comutação 'u.v-v.u=2*af(u,v)' onde 'af' é uma função valor-escalar
     antisimétrica.  Para a álgebra simplética, <opt_dims> pode mais de
     dois inteiros não negativos, representando a dimensão não
     degenerada e e a dimensão degenerada, respectivamente.  Se
     quaisquer valores <opt_dims> são fornecidos, 'atensor' irá
     configurar os valores de 'adim' e 'aform' apropriadamente.  Caso
     contrário, 'adim' irá por padrão para 0 e 'aform' não será
     definida.

     'lie_envelop': O invólucro da álgebra de Lie é definido pela
     relação de comutação 'u.v-v.u=2*av(u,v)' onde 'av' é uma função
     antisimétrica.

     A função 'init_atensor' também reconhece muitos tipos pré-definidos
     de álgebra:

     'complex' implementa a álgebra de números complexos como a álgebra
     de Clifford Cl(0,1).  A chamada 'init_atensor(complex)' é
     equivalente a 'init_atensor(clifford,0,0,1)'.

     'quaternion' implementa a álgebra de quaterniões.  A chamada
     'init_atensor(quaternion)' é equivalente a
     'init_atensor(clifford,0,0,2)'.

     'pauli' implementa a álgebra de spinores de Pauli como a álgebra de
     Clifford Cl(3,0).  Uma chamada a 'init_atensor(pauli)' é
     equivalente a 'init_atensor(clifford,3)'.

     'dirac' implementa a álgebra de spinores de Dirac como a álgebra de
     Clifford Cl(3,1).  Uma chamada a 'init_atensor(dirac)' é
     equivalente a 'init_atensor(clifford,3,0,1)'.

 -- Função: atensimp (<expr>)

     Simplifica a expressão algébrica de tensores <expr> conforme as
     regras configuradas por uma chamada a 'init_atensor'.
     Simplificações incluem aplicação recursiva de relações comutativas
     e resoluções de chamadas a 'sf', 'af', e 'av' onde for aplicável.
     Uma salvaguarda é usada para garantir que a função sempre termine,
     mesmo para expressões complexas.

 -- Função: alg_type

     O tipo de álgebra.  Valores válidos sáo 'universal', 'grassmann',
     'clifford', 'symmetric', 'symplectic' e 'lie_envelop'.

 -- Variável: adim

     A dimensionalidade da álgebra.  'atensor' usa o valor de 'adim'
     para determinar se um objecto indexado é uma base vectorial válida.
     Veja 'abasep'.

 -- Variável: aform

     Valor por omissão para as formas bilineares 'sf', 'af', e 'av'.  O
     padrão é a matriz identidade 'ident(3)'.

 -- Variável: asymbol

     O símbolo para bases vectoriais.

 -- Função: sf (<u>, <v>)

     É uma função escalar simétrica que é usada em relações comutativas.
     A implementação padrão verifica se ambos os argumentos são bases
     vectoriais usando 'abasep' e se esse for o caso, substitui o valor
     correspondente da matriz 'aform'.

 -- Função: af (<u>, <v>)

     É uma função escalar antisimétrica que é usada em relações
     comutativas.  A implementação padrão verifica se ambos os
     argumentos são bases vectoriais usando 'abasep' e se esse for o
     caso, substitui o valor correspondente da matriz 'aform'.

 -- Função: av (<u>, <v>)

     É uma função antisimétrica que é usada em relações comutativas.  A
     implementação padrão verifica se ambos os argumentos são bases
     vectoriais usando 'abasep' e se esse for o caso, substitui o valor
     correspondente da matriz 'aform'.

     Por exemplo:

          (%i1) load(atensor);
          (%o1)       /share/tensor/atensor.mac
          (%i2) adim:3;
          (%o2)                                  3
          (%i3) aform:matrix([0,3,-2],[-3,0,1],[2,-1,0]);
                                         [  0    3   - 2 ]
                                         [               ]
          (%o3)                          [ - 3   0    1  ]
                                         [               ]
                                         [  2   - 1   0  ]
          (%i4) asymbol:x;
          (%o4)                                  x
          (%i5) av(x[1],x[2]);
          (%o5)                                 x
                                                 3

 -- Função: abasep (<v>)

     Verifica se esse argumento é uma base vectorial 'atensor' .

     E será, se ele for um símbolo indexado, com o símbolo sendo o mesmo
     que o valor de 'asymbol', e o índice tiver o mesmo valor numérico
     entre 1 e 'adim'.


File: maxima.info,  Node: Séries,  Next: Teoria dos Números,  Prev: Pacote atensor,  Up: Top

30 Séries
*********

* Menu:

* Introdução a Séries::      
* Definições para Séries::      


File: maxima.info,  Node: Introdução a Séries,  Next: Definições para Séries,  Prev: Séries,  Up: Séries

30.1 Introdução a Séries
========================

Maxima contém funções 'taylor' e 'powerseries' (séries de potência) para
encontrar as séries de funções diferenciáveis.  Maxima também tem
ferramentas tais como 'nusum' capazes de encontrar a forma fechada de
algumas séries.  Operações tais como adição e multiplicação travalham da
forma usual sobre séries.  Essa secção apresenta as variáveis globais
que controlam a expansão.


File: maxima.info,  Node: Definições para Séries,  Prev: Introdução a Séries,  Up: Séries

30.2 Definições para Séries
===========================

 -- Variável de opção: cauchysum
     Valor por omissão: 'false'

     Quando multiplicando adições jutas com 'inf' como seus limites
     superiores, se 'sumexpand' for 'true' e 'cauchysum' for 'true'
     então o produto de Cauchy será usado em lugar do produto usual.  No
     produto de Cauchy o índice do somatório interno é uma função do
     índice do externo em lugar de variar independentemente.

     Exemplo:

          (%i1) sumexpand: false$
          (%i2) cauchysum: false$
          (%i3) s: sum (f(i), i, 0, inf) * sum (g(j), j, 0, inf);
                                inf         inf
                                ====        ====
                                \           \
          (%o3)                ( >    f(i))  >    g(j)
                                /           /
                                ====        ====
                                i = 0       j = 0
          (%i4) sumexpand: true$
          (%i5) cauchysum: true$
          (%i6) ''s;
                           inf     i1
                           ====   ====
                           \      \
          (%o6)             >      >     g(i1 - i2) f(i2)
                           /      /
                           ====   ====
                           i1 = 0 i2 = 0

 -- Função: deftaylor (<f_1>(<x_1>), <expr_1>, ..., <f_n>(<x_n>),
          <expr_n>)
     Para cada função <f_i> de uma variável <x_i>, 'deftaylor' define
     <expr_i> como a séries de Taylor sobre zero.  <expr_i> é
     tipicamente um polinómio em <x_i> ou um somatório; expressões mais
     gerais são aceitas por 'deftaylor' sem reclamações.

     'powerseries (<f_i>(<x_i>), <x_i>, 0)' retorna as séries definidas
     por 'deftaylor'.

     'deftaylor' retorna uma lista das funções <f_1>, ..., <f_n>.
     'deftaylor' avalia seus argumentos.

     Exemplo:

          (%i1) deftaylor (f(x), x^2 + sum(x^i/(2^i*i!^2), i, 4, inf));
          (%o1)                          [f]
          (%i2) powerseries (f(x), x, 0);
                                inf
                                ====      i1
                                \        x         2
          (%o2)                  >     -------- + x
                                /       i1    2
                                ====   2   i1!
                                i1 = 4
          (%i3) taylor (exp (sqrt (f(x))), x, 0, 4);
                                2         3          4
                               x    3073 x    12817 x
          (%o3)/T/     1 + x + -- + ------- + -------- + . . .
                               2     18432     307200

 -- Variável de opção: maxtayorder
     Valor por omissão: 'true'

     Quando 'maxtayorder' for 'true', durante a manipulação algébrica de
     séries (truncadas) de Taylor, 'taylor' tenta reter tantos termos
     quantos forem conhecidos serem correctos.

 -- Função: niceindices (<expr>)
     Renomeia os índices de adições e produtos em <expr>.  'niceindices'
     tenta renomear cada índice para o valor de 'niceindicespref[1]', a
     menos que o nome apareça nas parcelas do somatório ou produtório,
     nesses casos 'niceindices' tenta os elementos seguintes de
     'niceindicespref' por sua vez, até que uma varável não usada unused
     variable seja encontrada.  Se a lista inteira for exaurida, índices
     adicionais são constrídos através da anexaao de inteiros ao valor
     de 'niceindicespref[1]', e.g., 'i0', 'i1', 'i2', ....

     'niceindices' retorna uma expressão.  'niceindices' avalia seu
     argumento.

     Exemplo:

          (%i1) niceindicespref;
          (%o1)                  [i, j, k, l, m, n]
          (%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o2)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i3) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o3)                ! !   >    f(i j l + k)
                               ! !  /
                              l = 1 ====
                                    k = 1

 -- Variável de opção: niceindicespref
     Valor por omissão: '[i, j, k, l, m, n]'

     'niceindicespref' é a lista da qual 'niceindices' obtém os nomes
     dos índices de adições e produtos products.

     Os elementos de 'niceindicespref' são tipicamente nomes de
     variáveis, embora que não seja imposto por 'niceindices'.

     Exemplo:

          (%i1) niceindicespref: [p, q, r, s, t, u]$
          (%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o2)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i3) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o3)                ! !   >    f(i j q + p)
                               ! !  /
                              q = 1 ====
                                    p = 1

 -- Função: nusum (<expr>, <x>, <i_0>, <i_1>)
     Realiza o somatório hipergeométrico indefinido de <expr> com
     relação a <x> usando um procedimento de decisão devido a R.W.
     Gosper.  <expr> e o resultado deve ser expressável como produtos de
     expoentes inteiros, factoriais, binomios, e funções recionais.

     Os termos "definido" and "e somatório indefinido" são usados
     analogamente a "definida" and "integração indefinida".  Adicionar
     indefinidamente significa dar um resultado simólico para a adição
     sobre intervalos de comprimentos de variáveis, não apenas e.g.  0 a
     infinito.  Dessa forma, uma vez que não existe fórmula para a
     adição parcial geral de séries binomiais, 'nusum' não pode fazer
     isso.

     'nusum' e 'unsum' conhecem um porco sobre adições e subtrações de
     produtos finitos.  Veja também 'unsum'.

     Exemplos:

          (%i1) nusum (n*n!, n, 0, n);

          Dependent equations eliminated:  (1)
          (%o1)                     (n + 1)! - 1
          (%i2) nusum (n^4*4^n/binomial(2*n,n), n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o2) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i3) unsum (%, n);
                                        4  n
                                       n  4
          (%o3)                   ----------------
                                  binomial(2 n, n)
          (%i4) unsum (prod (i^2, i, 1, n), n);
                              n - 1
                              /===\
                               ! !   2
          (%o4)              ( ! !  i ) (n - 1) (n + 1)
                               ! !
                              i = 1
          (%i5) nusum (%, n, 1, n);

          Dependent equations eliminated:  (2 3)
                                      n
                                    /===\
                                     ! !   2
          (%o5)                      ! !  i  - 1
                                     ! !
                                    i = 1

 -- Função: pade (<taylor_series>, <numer_deg_bound>, <denom_deg_bound>)
     Retorna uma lista de todas as funções racionais que possuem a dada
     expansão da séries de Taylor onde a adição dos graus do numerador e
     do denominador é menor que ou igual ao nível de truncação das
     séries de potência, i.e.  são "melhores" aproximações, e que
     adicionalmente satisfazem o grau especificado associado.

     <taylor_series> é uma séries de Taylor de uma variável.
     <numer_deg_bound> e <denom_deg_bound> são inteiros positivos
     especificando o grau associado sobre o numerador e o denominador.

     <taylor_series> podem também ser séries de Laurent, e o grau
     associado pode ser 'inf' que acarreta todas funções racionais cujo
     grau total for menor que ou igual ao comprimento das séries de
     potências a serem retornadas.  O grau total é definido como
     '<numer_deg_bound> + <denom_deg_bound>'.  O comprimento de séries
     de potência é definido como '"nível de trncação" + 1 - min(0,
     "ordem das séries")'.

          (%i1) taylor (1 + x + x^2 + x^3, x, 0, 3);
                                        2    3
          (%o1)/T/             1 + x + x  + x  + . . .
          (%i2) pade (%, 1, 1);
                                           1
          (%o2)                       [- -----]
                                         x - 1
          (%i3) t: taylor(-(83787*x^10 - 45552*x^9 - 187296*x^8
                             + 387072*x^7 + 86016*x^6 - 1507328*x^5
                             + 1966080*x^4 + 4194304*x^3 - 25165824*x^2
                             + 67108864*x - 134217728)
                 /134217728, x, 0, 10);
                              2    3       4       5       6        7
                       x   3 x    x    15 x    23 x    21 x    189 x
          (%o3)/T/ 1 - - + ---- - -- - ----- + ----- - ----- - ------
                       2    16    32   1024    2048    32768   65536

                                            8         9          10
                                      5853 x    2847 x    83787 x
                                    + ------- + ------- - --------- + . . .
                                      4194304   8388608   134217728
          (%i4) pade (t, 4, 4);
          (%o4)                          []

     Não existe função racional de grau 4 numerador/denominador, com
     essa expansão de série de potência.  Você obrigatoriamente em geral
     tem grau do numerador e grau do denominador adicionando para cima
     ao menor grau das séries de potência, com o objectivo de ter
     disponível coeficientes desconhecidos para resolver.

          (%i5) pade (t, 5, 5);
                               5                4                 3
          (%o5) [- (520256329 x  - 96719020632 x  - 489651410240 x

                            2
           - 1619100813312 x  - 2176885157888 x - 2386516803584)

                         5                 4                  3
          /(47041365435 x  + 381702613848 x  + 1360678489152 x

                            2
           + 2856700692480 x  + 3370143559680 x + 2386516803584)]

 -- Variável de opção: powerdisp
     Valor por omissão: 'false'

     Quando 'powerdisp' for 'true', uma adição é mostrada com seus
     termos em ordem do crescimento do expoente.  Dessa forma um
     polinómio é mostrado como séries de potências truncadas, com o
     termo constante primeiro e o maior expoente por último.

     Por padão, termos de uma adição são mostrados em ordem do expoente
     decrescente.

 -- Função: powerseries (<expr>, <x>, <a>)
     Retorna a forma geral expansão de séries de potência para <expr> na
     variável <x> sobre o ponto <a> (o qual pode ser 'inf' para
     infinito).

     Se 'powerseries' incapaz de expandir <expr>, 'taylor' pode dar os
     primeiros muitos termos de séries.

     Quando 'verbose' for 'true', 'powerseries' mostra mensagens de
     progresso.

          (%i1) verbose: true$
          (%i2) powerseries (log(sin(x)/x), x, 0);
          can't expand
                                           log(sin(x))
          so we'll try again after applying the rule:
                                                  d
                                                / -- (sin(x))
                                                [ dx
                                  log(sin(x)) = i ----------- dx
                                                ]   sin(x)
                                                /
          in the first simplification we have returned:
                                       /
                                       [
                                       i cot(x) dx - log(x)
                                       ]
                                       /
                              inf
                              ====        i1  2 i1             2 i1
                              \      (- 1)   2     bern(2 i1) x
                               >     ------------------------------
                              /                i1 (2 i1)!
                              ====
                              i1 = 1
          (%o2)                -------------------------------------
                                                2

 -- Variável de opção: psexpand
     Valor por omissão: 'false'

     Quando 'psexpand' for 'true', uma expressão função racional
     extendida é mostrada completamente expandida.  O comutador
     'ratexpand' tem o mesmo efeito.

     Quando 'psexpand' for 'false', uma expressão de várias variáveis é
     mostrada apenas como no pacote de função racional.

     Quando 'psexpand' for 'multi', então termos com o mesmo grau total
     nas variáveis são agrupados juntos.

 -- Função: revert (<expr>, <x>)
 -- Função: revert2 (<expr>, <x>, <n>)
     Essas funções retornam a reversão de <expr>, uma série de Taylor
     sobre zero na variável <x>.  'revert' retorna um polinómio de grau
     igual ao maior expoente em <expr>.  'revert2' retorna um polinómio
     de grau <n>, o qual pode ser maior que, igual a, ou menor que o
     grau de <expr>.

     'load ("revert")' chama essas funções.

     Exemplos:

          (%i1) load ("revert")$
          (%i2) t: taylor (exp(x) - 1, x, 0, 6);
                             2    3    4    5     6
                            x    x    x    x     x
          (%o2)/T/      x + -- + -- + -- + --- + --- + . . .
                            2    6    24   120   720
          (%i3) revert (t, x);
                         6       5       4       3       2
                     10 x  - 12 x  + 15 x  - 20 x  + 30 x  - 60 x
          (%o3)/R/ - --------------------------------------------
                                          60
          (%i4) ratexpand (%);
                               6    5    4    3    2
                              x    x    x    x    x
          (%o4)             - -- + -- - -- + -- - -- + x
                              6    5    4    3    2
          (%i5) taylor (log(x+1), x, 0, 6);
                              2    3    4    5    6
                             x    x    x    x    x
          (%o5)/T/       x - -- + -- - -- + -- - -- + . . .
                             2    3    4    5    6
          (%i6) ratsimp (revert (t, x) - taylor (log(x+1), x, 0, 6));
          (%o6)                           0
          (%i7) revert2 (t, x, 4);
                                    4    3    2
                                   x    x    x
          (%o7)                  - -- + -- - -- + x
                                   4    3    2

 -- Função: taylor (<expr>, <x>, <a>, <n>)
 -- Função: taylor (<expr>, [<x_1>, <x_2>, ...], <a>, <n>)
 -- Função: taylor (<expr>, [<x>, <a>, <n>, 'asymp])
 -- Função: taylor (<expr>, [<x_1>, <x_2>, ...], [<a_1>, <a_2>, ...],
          [<n_1>, <n_2>, ...])
 -- Função: taylor (<expr>, [<x_1>, <a_1>, <n_1>], [<x_2>, <a_2>,
          <n_2>], ...)
     'taylor (<expr>, <x>, <a>, <n>)' expande a expressão <expr> em uma
     série truncada de Taylor ou de Laurent na variável <x> em torno do
     ponto <a>, contendo termos até '(<x> - <a>)^<n>'.

     Se <expr> é da forma '<f>(<x>)/<g>(<x>)' e '<g>(<x>)' não possui de
     grau acima do grau <n> então 'taylor' tenta expandir '<g>(<x>)'
     acima do gau '2 <n>'.  Se existe ainda termos não zero, 'taylor'
     dobra o grau de expansão de '<g>(<x>)' contanto que o grau da
     expansão o grau da expansão seja menor que ou igual a '<n>
     2^taylordepth'.

     'taylor (<expr>, [<x_1>, <x_2>, ...], <a>, <n>)' retorna uma série
     de potência truncada de grau <n> em todas as variáveis <x_1>,
     <x_2>, ...  sobre o ponto '(<a>, <a>, ...)'.

     'taylor (<expr>, [<x_1>, <a_1>, <n_1>], [<x_2>, <a_2>, <n_2>],
     ...)' retorna uma série de potência truncada nas variáveis <x_1>,
     <x_2>, ...  sobre o ponto '(<a_1>, <a_2>, ...)', truncada em <n_1>,
     <n_2>, ....

     'taylor (<expr>, [<x_1>, <x_2>, ...], [<a_1>, <a_2>, ...], [<n_1>,
     <n_2>, ...])' retorna uma série de potência truncada nas variáveis
     <x_1>, <x_2>, ...  sobre o ponto '(<a_1>, <a_2>, ...)', truncada em
     <n_1>, <n_2>, ....

     'taylor (<expr>, [<x>, <a>, <n>, 'asymp])' retorna uma expansão de
     <expr> em expoentes negativos de '<x> - <a>'.  O termo de maior
     ordem é '(<x> - <a>)^<-n>'.

     Quando 'maxtayorder' for 'true', então durante maniplulação
     algébrica da séries de Taylor (truncada), 'taylor' tenta reter
     tantos termos quantos forem conhecidos serem correctos.

     Quando 'psexpand' for 'true', uma expressão de função racional
     extendida é mostrada completamente expandida.  O comutador
     'ratexpand' tem o mesmo efeito.  Quando 'psexpand' for 'false', uma
     expressão de várias variáveis é mostrada apenas como no pacote de
     função racional.  Quando 'psexpand' for 'multi', então os termos
     com o mesmo grau total nas variáveis são agrupados juntos.

     Veja também o comutador 'taylor_logexpand' para controlar a
     expansão.

     Exemplos:

          (%i1) taylor (sqrt (sin(x) + a*x + 1), x, 0, 3);
                                     2             2
                       (a + 1) x   (a  + 2 a + 1) x
          (%o1)/T/ 1 + --------- - -----------------
                           2               8

                                             3      2             3
                                         (3 a  + 9 a  + 9 a - 1) x
                                       + -------------------------- + . . .
                                                     48
          (%i2) %^2;
                                              3
                                             x
          (%o2)/T/           1 + (a + 1) x - -- + . . .
                                             6
          (%i3) taylor (sqrt (x + 1), x, 0, 5);
                                 2    3      4      5
                            x   x    x    5 x    7 x
          (%o3)/T/      1 + - - -- + -- - ---- + ---- + . . .
                            2   8    16   128    256
          (%i4) %^2;
          (%o4)/T/                  1 + x + . . .
          (%i5) product ((1 + x^i)^2.5, i, 1, inf)/(1 + x^2);
                                   inf
                                  /===\
                                   ! !    i     2.5
                                   ! !  (x  + 1)
                                   ! !
                                  i = 1
          (%o5)                   -----------------
                                        2
                                       x  + 1
          (%i6) ev (taylor(%, x,  0, 3), keepfloat);
                                         2           3
          (%o6)/T/    1 + 2.5 x + 3.375 x  + 6.5625 x  + . . .
          (%i7) taylor (1/log (x + 1), x, 0, 3);
                                         2       3
                           1   1   x    x    19 x
          (%o7)/T/         - + - - -- + -- - ----- + . . .
                           x   2   12   24    720
          (%i8) taylor (cos(x) - sec(x), x, 0, 5);
                                          4
                                     2   x
          (%o8)/T/                - x  - -- + . . .
                                         6
          (%i9) taylor ((cos(x) - sec(x))^3, x, 0, 5);
          (%o9)/T/                    0 + . . .
          (%i10) taylor (1/(cos(x) - sec(x))^3, x, 0, 5);
                                                         2          4
                      1     1       11      347    6767 x    15377 x
          (%o10)/T/ - -- + ---- + ------ - ----- - ------- - --------
                       6      4        2   15120   604800    7983360
                      x    2 x    120 x

                                                                    + . . .
          (%i11) taylor (sqrt (1 - k^2*sin(x)^2), x, 0, 6);
                         2  2       4      2   4
                        k  x    (3 k  - 4 k ) x
          (%o11)/T/ 1 - ----- - ----------------
                          2            24

                                              6       4       2   6
                                         (45 k  - 60 k  + 16 k ) x
                                       - -------------------------- + . . .
                                                    720
          (%i12) taylor ((x + 1)^n, x, 0, 4);
                                2       2     3      2         3
                              (n  - n) x    (n  - 3 n  + 2 n) x
          (%o12)/T/ 1 + n x + ----------- + --------------------
                                   2                 6

                                         4      3       2         4
                                       (n  - 6 n  + 11 n  - 6 n) x
                                     + ---------------------------- + . . .
                                                    24
          (%i13) taylor (sin (y + x), x, 0, 3, y, 0, 3);
                         3                 2
                        y                 y
          (%o13)/T/ y - -- + . . . + (1 - -- + . . .) x
                        6                 2

                              3                       2
                         y   y            2      1   y            3
                    + (- - + -- + . . .) x  + (- - + -- + . . .) x  + . . .
                         2   12                  6   12
          (%i14) taylor (sin (y + x), [x, y], 0, 3);
                               3        2      2      3
                              x  + 3 y x  + 3 y  x + y
          (%o14)/T/   y + x - ------------------------- + . . .
                                          6
          (%i15) taylor (1/sin (y + x), x, 0, 3, y, 0, 3);
                    1   y              1    1               1            2
          (%o15)/T/ - + - + . . . + (- -- + - + . . .) x + (-- + . . .) x
                    y   6               2   6                3
                                       y                    y

                                                     1            3
                                                + (- -- + . . .) x  + . . .
                                                      4
                                                     y
          (%i16) taylor (1/sin (y + x), [x, y], 0, 3);
                                       3         2       2        3
                      1     x + y   7 x  + 21 y x  + 21 y  x + 7 y
          (%o16)/T/ ----- + ----- + ------------------------------- + . . .
                    x + y     6                   360

 -- Variável de opção: taylordepth
     Valor por omissão: 3

     Se existem ainda termos não zero, 'taylor' dobra o grau da expansão
     de '<g>(<x>)' contanto que o grau da expansão seja menor que ou
     igual a '<n> 2^taylordepth'.

 -- Função: taylorinfo (<expr>)
     Retorna information about the séries de Taylor <expr>.  O valor de
     retorno é uma lista de listas.  Cada lista compreende o nome de uma
     variável, o ponto de expansão, e o grau da expansão.

     'taylorinfo' retorna 'false' se <expr> não for uma séries de
     Taylor.

     Exemplo:

          (%i1) taylor ((1 - y^2)/(1 - x), x, 0, 3, [y, a, inf]);
                            2                       2
          (%o1)/T/ - (y - a)  - 2 a (y - a) + (1 - a )

                   2                        2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   3
           + (1 - a  - 2 a (y - a) - (y - a) ) x  + . . .
          (%i2) taylorinfo(%);
          (%o2)               [[y, a, inf], [x, 0, 3]]

 -- Função: taylorp (<expr>)
     Retorna 'true' se <expr> for uma séries de Taylor, e 'false' de
     outra forma.

 -- Variável de opção: taylor_logexpand
     Valor por omissão: 'true'

     'taylor_logexpand' controla expansão de logaritmos em séries de
     'taylor'.

     Quando 'taylor_logexpand' for 'true', todos logaritmos são
     expandidos completamente dessa forma problemas de reconhecimento de
     zero envolvendo envolvendo identidades logarítmicas não atrapalham
     o processo de expansão.  Todavia, esse esquema não é sempre
     matematicamente correcto uma vez que isso ignora informações de
     ramo.

     Quando 'taylor_logexpand' for escolhida para 'false', então a
     expansão logarítmica que ocorre é somente aquela que for necessária
     para obter uma séries de potência formal.

 -- Variável de opção: taylor_order_coefficients
     Valor por omissão: 'true'

     'taylor_order_coefficients' controla a ordenação dos coeficientes
     em uma série de Taylor.

     Quando 'taylor_order_coefficients' for 'true', coeficientes da
     séries de Taylor são ordenados canonicamente.

 -- Função: taylor_simplifier (<expr>)
     Simplifica coeficientes da séries de potência <expr>.  'taylor'
     chama essa função.

 -- Variável de opção: taylor_truncate_polynomials
     Valor por omissão: 'true'

     Quando 'taylor_truncate_polynomials' for 'true', polinómios são
     truncados baseados sobre a entrada de níveis de truncação.

     De outra forma, entrada de polinómios para 'taylor' são
     consideradas terem precisão infinita.

 -- Função: taytorat (<expr>)
     Converte <expr> da forma 'taylor' para a forma de expressão
     racional canónica (CRE). O efeito é o mesmo que 'rat (ratdisrep
     (<expr>))', mas mais rápido.

 -- Função: trunc (<expr>)
     Coloca notas na representação interna da expressão geral <expr> de
     modo que isso é mostrado como se suas adições forem séries de
     Taylor truncadas.  <expr> is not otherwise modified.

     Exemplo:

          (%i1) expr: x^2 + x + 1;
                                      2
          (%o1)                      x  + x + 1
          (%i2) trunc (expr);
                                          2
          (%o2)                  1 + x + x  + . . .
          (%i3) is (expr = trunc (expr));
          (%o3)                         true

 -- Função: unsum (<f>, <n>)
     Retorna a primeira diferençã de trás para frente '<f>(<n>) -
     <f>(<n> - 1)'.  Dessa forma 'unsum' logicamente é a inversa de
     'sum'.

     Veja também 'nusum'.

     Exemplos:

          (%i1) g(p) := p*4^n/binomial(2*n,n);
                                               n
                                            p 4
          (%o1)               g(p) := ----------------
                                      binomial(2 n, n)
          (%i2) g(n^4);
                                        4  n
                                       n  4
          (%o2)                   ----------------
                                  binomial(2 n, n)
          (%i3) nusum (%, n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o3) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i4) unsum (%, n);
                                        4  n
                                       n  4
          (%o4)                   ----------------
                                  binomial(2 n, n)

 -- Variável de opção: verbose
     Valor por omissão: 'false'

     Quando 'verbose' for 'true', 'powerseries' mostra mensagens de
     progresso.


File: maxima.info,  Node: Teoria dos Números,  Next: Simetrias,  Prev: Séries,  Up: Top

31 Teoria dos Números
*********************

* Menu:

* Definições para Teoria dos Números::  


File: maxima.info,  Node: Definições para Teoria dos Números,  Prev: Teoria dos Números,  Up: Teoria dos Números

31.1 Definições para Teoria dos Números
=======================================

 -- Função: bern (<n>)
     Retorna o <n>'ésimo número de Bernoulli para o inteiro <n>.
     Números de Bernoulli iguais a zero são suprimidos se 'zerobern' for
     'false'.

     Veja também 'burn'.

          (%i1) zerobern: true$
          (%i2) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                            1  1       1      1        1
          (%o2)       [1, - -, -, 0, - --, 0, --, 0, - --]
                            2  6       30     42       30
          (%i3) zerobern: false$
          (%i4) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                      1  1    1   5     691   7    3617  43867
          (%o4) [1, - -, -, - --, --, - ----, -, - ----, -----]
                      2  6    30  66    2730  6    510    798

 -- Função: bernpoly (<x>, <n>)
     Retorna o <n>'ésimo polinómio de Bernoulli na variável <x>.

 -- Função: bfzeta (<s>, <n>)
     Retorna a função zeta de Riemann para o argumento <s>.  O valor de
     retorno é um grande inteiro em ponto flutuante (bfloat); <n> é o
     número de dígitos no valor de retorno.

     'load ("bffac")' chama essa função.

 -- Função: bfhzeta (<s>, <h>, <n>)
     Retorna a função zeta de Hurwitz para os argumentos <s> e <h>.  O
     valor de retorno é um grande inteiro em ponto flutuante (bfloat);
     <n> é o números de dígitos no valor de retorno.

     A função zeta de Hurwitz é definida como

          sum ((k+h)^-s, k, 0, inf)

     'load ("bffac")' chama essa função.

 -- Função: binomial (<x>, <y>)
     O coeficiente binomial '<x>!/(<y>! (<x> - <y>)!)'.  Se <x> e <y>
     forem inteiros, então o valor numérico do coeficiente binomial é
     calculado.  Se <y>, ou <x - y>, for um inteiro, o the coeficiente
     binomial é expresso como um polinómio.

     Exemplos:

          (%i1) binomial (11, 7);
          (%o1)                          330
          (%i2) 11! / 7! / (11 - 7)!;
          (%o2)                          330
          (%i3) binomial (x, 7);
                  (x - 6) (x - 5) (x - 4) (x - 3) (x - 2) (x - 1) x
          (%o3)   -------------------------------------------------
                                        5040
          (%i4) binomial (x + 7, x);
                (x + 1) (x + 2) (x + 3) (x + 4) (x + 5) (x + 6) (x + 7)
          (%o4) -------------------------------------------------------
                                         5040
          (%i5) binomial (11, y);
          (%o5)                    binomial(11, y)

 -- Função: burn (<n>)
     Retorna o <n>'ésimo número de Bernoulli para o inteiro <n>.  'burn'
     pode ser mais eficitente que 'bern' para valores grandes e isolados
     de <n> (talvez <n> maior que 105 ou algo parecido), como 'bern'
     calcula todos os números de Bernoulli até o índice <n> antes de
     retornar.

     'burn' explora a observação que números de Bernoulli (racionais)
     podem ser aproximados através de zetas (transcendentes) com
     eficiência tolerável.

     'load ("bffac")' chama essa função.

 -- Função: cf (<expr>)
     Converte <expr> em uma fração contínua.  <expr> é uma expressão
     compreendendo frações contínuas e raízes quadradas de inteiros.
     Operandos na expressão podem ser combinados com operadores
     aritméticos.  Com excessão de frações contínuas e raízes quadradas,
     factores na expressão devem ser números inteiros ou racionais.
     Maxima não conhece operações sobre frações contínuas fora de 'cf'.

     'cf' avalia seus argumentos após associar 'listarith' a 'false'.
     'cf' retorna uma fração contínua, representada como uma lista.

     Uma fração contínua 'a + 1/(b + 1/(c + ...))' é representada
     através da lista '[a, b, c, ...]'.  Os elementos da lista 'a', 'b',
     'c', ...  devem avaliar para inteiros.  <expr> pode também conter
     'sqrt (n)' onde 'n' é um inteiro.  Nesse caso 'cf' fornecerá tantos
     termos de fração contínua quantos forem o valor da variável
     'cflength' vezes o período.

     Uma fração contínua pode ser avaliada para um número através de
     avaliação da representação aritmética retornada por 'cfdisrep'.
     Veja também 'cfexpand' para outro caminho para avaliar uma fração
     contínua.

     Veja também 'cfdisrep', 'cfexpand', e 'cflength'.

     Exemplos:

        * <expr> é uma expressão compreendendo frações contínuas e
          raízes quadradas de inteiros.

               (%i1) cf ([5, 3, 1]*[11, 9, 7] + [3, 7]/[4, 3, 2]);
               (%o1)               [59, 17, 2, 1, 1, 1, 27]
               (%i2) cf ((3/17)*[1, -2, 5]/sqrt(11) + (8/13));
               (%o2)        [0, 1, 1, 1, 3, 2, 1, 4, 1, 9, 1, 9, 2]

        * 'cflength' controla quantos períodos de fração contínua são
          computados para números algébricos, números irracionais.

               (%i1) cflength: 1$
               (%i2) cf ((1 + sqrt(5))/2);
               (%o2)                    [1, 1, 1, 1, 2]
               (%i3) cflength: 2$
               (%i4) cf ((1 + sqrt(5))/2);
               (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
               (%i5) cflength: 3$
               (%i6) cf ((1 + sqrt(5))/2);
               (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]

        * Um fração contínua pode ser avaliado através da avaliação da
          representação aritmética retornada por 'cfdisrep'.

               (%i1) cflength: 3$
               (%i2) cfdisrep (cf (sqrt (3)))$
               (%i3) ev (%, numer);
               (%o3)                   1.731707317073171

        * Maxima não conhece operações sobre frações contínuas fora de
          'cf'.

               (%i1) cf ([1,1,1,1,1,2] * 3);
               (%o1)                     [4, 1, 5, 2]
               (%i2) cf ([1,1,1,1,1,2]) * 3;
               (%o2)                  [3, 3, 3, 3, 3, 6]

 -- Função: cfdisrep (<list>)
     Constrói e retorna uma expressão aritmética comum da forma 'a +
     1/(b + 1/(c + ...))' a partir da representação lista de uma fração
     contínua '[a, b, c, ...]'.

          (%i1) cf ([1, 2, -3] + [1, -2, 1]);
          (%o1)                     [1, 1, 1, 2]
          (%i2) cfdisrep (%);
                                            1
          (%o2)                     1 + ---------
                                              1
                                        1 + -----
                                                1
                                            1 + -
                                                2

 -- Função: cfexpand (<x>)
     Retorna uma matriz de numeradores e denominadores dos último
     (columa 1) e penúltimo (columa 2) convergentes da fração contínua
     <x>.

          (%i1) cf (rat (ev (%pi, numer)));

          `rat' replaced 3.141592653589793 by 103993/33102 = 3.141592653011902
          (%o1)                  [3, 7, 15, 1, 292]
          (%i2) cfexpand (%);
                                   [ 103993  355 ]
          (%o2)                    [             ]
                                   [ 33102   113 ]
          (%i3) %[1,1]/%[2,1], numer;
          (%o3)                   3.141592653011902

 -- Variável de opção: cflength
     Valor por omissão: 1

     'cflength' controla o número de termos da fração contínua que a
     função 'cf' fornecerá, como o valor de 'cflength' vezes o período.
     Dessa forma o padrão é fornecer um período.

          (%i1) cflength: 1$
          (%i2) cf ((1 + sqrt(5))/2);
          (%o2)                    [1, 1, 1, 1, 2]
          (%i3) cflength: 2$
          (%i4) cf ((1 + sqrt(5))/2);
          (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
          (%i5) cflength: 3$
          (%i6) cf ((1 + sqrt(5))/2);
          (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]

 -- Função: divsum (<n>, <k>)
 -- Função: divsum (<n>)

     'divsum (<n>, <k>)' retorna a adição dos divisores de <n> elevados
     à <k>'ésima potência.

     'divsum (<n>)' retorna a adição dos divisores de <n>.

          (%i1) divsum (12);
          (%o1)                          28
          (%i2) 1 + 2 + 3 + 4 + 6 + 12;
          (%o2)                          28
          (%i3) divsum (12, 2);
          (%o3)                          210
          (%i4) 1^2 + 2^2 + 3^2 + 4^2 + 6^2 + 12^2;
          (%o4)                          210

 -- Função: euler (<n>)
     Retorna o <n>'ésimo número de Euler para o inteiro <n> não
     negativo.

     Para a constante de Euler-Mascheroni, veja '%gamma'.

          (%i1) map (euler, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o1)    [1, 0, - 1, 0, 5, 0, - 61, 0, 1385, 0, - 50521]

 -- Constante: %gamma
     A constante de Euler-Mascheroni, 0.5772156649015329 ....

 -- Função: factorial (<x>)
     Representa a função factorial.  Maxima trata 'factorial (<x>)' da
     mesma forma que '<x>!'.  Veja '!'.

 -- Função: fib (<n>)
     Retorna o <n>'ésimo número de Fibonacci.  'fib(0)' igual a 0 e
     'fib(1)' igual a 1, e 'fib (-<n>)' igual a '(-1)^(<n> + 1) *
     fib(<n>)'.

     Após chamar 'fib', 'prevfib' é iguala 'fib (<x> - 1)', o número de
     Fibonacci anterior ao último calculado.

          (%i1) map (fib, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o1)         [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]

 -- Função: fibtophi (<expr>)
     Expressa números de Fibonacci que aparecem em <expr> em termos da
     constante '%phi', que é '(1 + sqrt(5))/2', aproximadamente
     1.61803399.

     Exemplos:

          (%i1) fibtophi (fib (n));
                                     n             n
                                 %phi  - (1 - %phi)
          (%o1)                  -------------------
                                     2 %phi - 1
          (%i2) fib (n-1) + fib (n) - fib (n+1);
          (%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
          (%i3) fibtophi (%);
                      n + 1             n + 1       n             n
                  %phi      - (1 - %phi)        %phi  - (1 - %phi)
          (%o3) - --------------------------- + -------------------
                          2 %phi - 1                2 %phi - 1
                                                    n - 1             n - 1
                                                %phi      - (1 - %phi)
                                              + ---------------------------
                                                        2 %phi - 1
          (%i4) ratsimp (%);
          (%o4)                           0

 -- Função: ifactors (<n>)
     Para um inteiro positivo <n> retorna a factoração de <n>.  Se
     'n=p1^e1..pk^nk' for a decomposição de <n> em factores primos,
     'ifactors' retorna '[[p1, e1], ... , [pk, ek]]'.

     Os métodos de factoração usados são divisões triviais por primos
     até 9973, o método rho de Pollard e o método da curva elíptica.

          (%i1) ifactors(51575319651600);
          (%o1)     [[2, 4], [3, 2], [5, 2], [1583, 1], [9050207, 1]]
          (%i2) apply("*", map(lambda([u], u[1]^u[2]), %));
          (%o2)                        51575319651600

 -- Função: inrt (<x>, <n>)
     Retorna a parte inteira da <n>'ésima raíz do valor absoluto de <x>.

          (%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
          (%i2) map (lambda ([a], inrt (10^a, 3)), l);
          (%o2) [2, 4, 10, 21, 46, 100, 215, 464, 1000, 2154, 4641, 10000]

 -- Função: inv_mod (<n>, <m>)
     Calcula o inverso de <n> módulo <m>.  'inv_mod (n,m)' retorna
     'false', se <n> modulo <m> for zero.

          (%i1) inv_mod(3, 41);
          (%o1)                           14
          (%i2) ratsimp(3^-1), modulus=41;
          (%o2)                           14
          (%i3) inv_mod(3, 42);
          (%o3)                          false

 -- Função: jacobi (<p>, <q>)
     Retorna símbolo de Jacobi de <p> e <q>.

          (%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
          (%i2) map (lambda ([a], jacobi (a, 9)), l);
          (%o2)         [1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0]

 -- Função: lcm (<expr_1>, ..., <expr_n>)
     Retorna o menor múltiplo comum entre seus argumentos.  Os
     argumentos podem ser expressões gerais também inteiras.

     'load ("functs")' chama essa função.

 -- Função: minfactorial (<expr>)
     Examina <expr> procurando por ocorrências de dois factoriais que
     diferem por um inteiro.  'minfactorial' então converte um em um
     polinómio vezes o outro.

          (%i1) n!/(n+2)!;
                                         n!
          (%o1)                       --------
                                      (n + 2)!
          (%i2) minfactorial (%);
                                          1
          (%o2)                    ---------------
                                   (n + 1) (n + 2)

 -- Função: next_prime (<n>)
     Retorna o menor primo maior que <n>.

          (%i1) next_prime(27);
          (%o1)                       29

 -- Função: partfrac (<expr>, <var>)
     Expande a expressão <expr> em frações parciais com relação à
     variável principal <var>.  'partfrac' faz uma decomposição completa
     de fração parcial.  O algoritmo utilizado é baseado no facto que os
     denominadores de uma expansão de fração parcial (os factores do
     denominador original) são relativamente primos.  Os numeradores
     podem ser escritos como combinação linear dos denominadores, e a
     expansão acontece.

          (%i1) 1/(1+x)^2 - 2/(1+x) + 2/(2+x);
                                2       2        1
          (%o1)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)
          (%i2) ratsimp (%);
                                           x
          (%o2)                 - -------------------
                                   3      2
                                  x  + 4 x  + 5 x + 2
          (%i3) partfrac (%, x);
                                2       2        1
          (%o3)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)

 -- Função: power_mod (<a>, <n>, <m>)
     Usa um algoritmo modular para calcular 'a^n mod m' onde <a> e <n>
     são inteiros e <m> é um inteiro positivo.  Se <n> for negativo,
     'inv_mod' é usada para encontrar o inverso modular.

          (%i1) power_mod(3, 15, 5);
          (%o1)                          2
          (%i2) mod(3^15,5);
          (%o2)                          2
          (%i3) power_mod(2, -1, 5);
          (%o3)                          3
          (%i4) inv_mod(2,5);
          (%o4)                          3

 -- Função: primep (<n>)
     Teste de primalidade.  Se 'primep (n)' retornar 'false', <n> é um
     número compostro e se esse teste retornar 'true', <n> é um número
     primo com grande probabilidade.

     Para <n> menor que 341550071728321 uma versão deterministra do
     teste de Miller-Rabin é usada.  Se 'primep (n)' retornar 'true',
     então <n> é um número primo.

     Para <n> maior que 34155071728321 'primep' usa
     'primep_number_of_tests' que é os testes de pseudo-primalidade de
     Miller-Rabin e um teste de pseudo-primalidade de Lucas.  A
     probabilidade que <n> irá passar por um teste de Miller-Rabin é
     menor que 1/4.  Usando o valor padrão 25 para
     'primep_number_of_tests', a probabilidade de <n> passar no teste
     sendo composto é muito menor que 10^-15.

 -- Variável de opção: primep_number_of_tests
     Valor por omissão: 25

     Número de testes de Miller-Rabin usados em 'primep'.

 -- Função: prev_prime (<n>)
     Retorna o maior primo menor que <n>.

          (%i1) prev_prime(27);
          (%o1)                       23

 -- Função: qunit (<n>)
     Retorna a principal unidade do campo dos números quadráticos reais
     'sqrt (<n>)' onde <n> é um inteiro, i.e., o elemento cuja norma é
     unidade.  Isso é importante para resolver a equação de Pell 'a^2 -
     <n> b^2 = 1'.

          (%i1) qunit (17);
          (%o1)                     sqrt(17) + 4
          (%i2) expand (% * (sqrt(17) - 4));
          (%o2)                           1

 -- Função: totient (<n>)
     Retorna o número de inteiros menores que ou iguais a <n> que são
     relativamente primos com <n>.

 -- Variável de opção: zerobern
     Valor por omissão: 'true'

     Quando 'zerobern' for 'false', 'bern' exclui os números de
     Bernoulli que forem iguais a zero.  Veja 'bern'.

 -- Função: zeta (<n>)
     Retorna a função zeta de Riemann se <x> for um inteiro negativo, 0,
     1, ou número par positivo, e retorna uma forma substantiva 'zeta
     (<n>)' para todos os outros argumentos, incluindo não inteiros
     racionais, ponto flutuante, e argumentos complexos.

     Veja também 'bfzeta' e 'zeta%pi'.

          (%i1) map (zeta, [-4, -3, -2, -1, 0, 1, 2, 3, 4, 5]);
                                               2              4
                     1        1     1       %pi            %pi
          (%o1) [0, ---, 0, - --, - -, inf, ----, zeta(3), ----, zeta(5)]
                    120       12    2        6              90

 -- Variável de opção: zeta%pi
     Valor por omissão: 'true'

     Quando 'zeta%pi' for 'true', 'zeta' retorna uma expressão
     proporcional a '%pi^n' para inteiro par 'n'.  De outra forma,
     'zeta' retorna uma forma substantiva 'zeta (n)' para inteiro par
     'n'.

          (%i1) zeta%pi: true$
          (%i2) zeta (4);
                                           4
                                        %pi
          (%o2)                         ----
                                         90
          (%i3) zeta%pi: false$
          (%i4) zeta (4);
          (%o4)                        zeta(4)


File: maxima.info,  Node: Simetrias,  Next: Grupos,  Prev: Teoria dos Números,  Up: Top

32 Simetrias
************

* Menu:

* Definições para Simetrias::  


File: maxima.info,  Node: Definições para Simetrias,  Prev: Simetrias,  Up: Simetrias

32.1 Definições para Simetrias
==============================

32.1.1 Mudando a base do sistema de numeração
---------------------------------------------

 -- Função: comp2pui (<n>, <L>)
     implementa a passagem das funções simétricas completamente
     simétricas fornecidas na lista <L> para as funções simétricas
     elementares de 0 a <n>.  Se a lista <L> contiver menos que <n+1>
     elementos, será completada com valores formais do tipo <h1>, <h2>,
     etc.  Se o primeiro elemento da lista <L> existir, ele é
     interpretado como sendo o tamanho do alfabeto, de outra forma o
     tamanho é escolhido para <n>.

          (%i1) comp2pui (3, [4, g]);
                                  2                    2
          (%o1)    [4, g, 2 h2 - g , 3 h3 - g h2 + g (g  - 2 h2)]

 -- Função: ele2pui (<m>, <L>)
     vai de funções simétricas elementares para as funções completas.
     Similar a 'comp2ele' e 'comp2pui'.

     Outras funções para mudanças de base: 'comp2ele'.

 -- Função: ele2comp (<m>, <L>)
     Vai de funções simétricas elementares para funções completas.
     Similar a 'comp2ele' e a 'comp2pui'.

     Outras funções para mudanças de base: 'comp2ele'.

 -- Função: elem (<ele>, <sym>, <lvar>)
     ddecompões o polinómio simétrico <sym>, nas variáveis contidas na
     lista <lvar>, em termos de funções elementares simétricas
     fornecidas na lista <ele>.  Se o primeiro elemento de <ele> for
     fornecido, esse primeiro elemento será o tamanho do alfabeto, de
     outra forma o tamanho será o grau do polinómio <sym>.  Se valores
     forem omitidos na lista <ele>, valores formais do tipo <e1>, <e2>,
     etc.  serão adicionados.  O polinómio <sym> pode ser fornecido de
     três diferentes formas: contraída ('elem' pode então ser 1, seu
     valor padrão), particionada ('elem' pode ser 3), ou extendida (i.e.
     o polinómio completo, e 'elem' pode então ser 2).  A função 'pui' é
     usada então da mesma forma.

     sobre um alfabeto de tamanho 3 com <e1>, a primeira funçào
     elementar simétrica, com valor 7, o polinómio simétrico em 3
     variáveis cuja forma contraída (que aqui depende de duas de suas
     variáveis) é <x^4-2*x*y> decomposto como segue em funções
     elementares simétricas:

          (%i1) elem ([3, 7], x^4 - 2*x*y, [x, y]);
          (%o1) 7 (e3 - 7 e2 + 7 (49 - e2)) + 21 e3

                                                   + (- 2 (49 - e2) - 2) e2
          (%i2) ratsimp (%);
                                        2
          (%o2)             28 e3 + 2 e2  - 198 e2 + 2401

     Outras funções para mudanças de base: 'comp2ele'.

 -- Function: mon2schur (<L>)
     a lsita <L> representa a função de Schur S_L: temos L = [i_1, i_2,
     ..., i_q], com i_1 <= i_2 <= ... <= i_q.  A função de Schur S_[i_1,
     i_2, ..., i_q] é a menor da matriz infinita h_[i-j], i <= 1, j <=
     1, consistindo das q primeiras linhas e as colunas 1 + i_1, +2 +
     i_2, ..., q + i_q.

     Essa função de Schur pode ser escrita em termos de monômios usando
     'treinat' e 'kostka'.  A forma retornada é um polinómio simétrico
     na representação contraída nas variáveis x_1,x_2,\ldots.

          (%i1) mon2schur ([1, 1, 1]);
          (%o1)                       x1 x2 x3
          (%i2) mon2schur ([3]);
                                            2        3
          (%o2)                x1 x2 x3 + x1  x2 + x1
          (%i3) mon2schur ([1, 2]);
                                                2
          (%o3)                  2 x1 x2 x3 + x1  x2

     o qual significa que para 3 variáveis fornece:

             2 x1 x2 x3 + x1^2 x2 + x2^2 x1 + x1^2 x3 + x3^2 x1
              + x2^2 x3 + x3^2 x2
     Outras funções para mudanças de base: 'comp2ele'.

 -- Função: multi_elem (<l_elem>, <multi_pc>, <l_var>)
     decompões um polinómio multi-simétrico na forma multi-contraída
     <multi_pc> nos grupos de variáveis contidas na lista de listas
     <l_var> en termos de funções elementares simétricas contidas em
     <l_elem>.

          (%i1) multi_elem ([[2, e1, e2], [2, f1, f2]], a*x + a^2 + x^3, [[x, y], [a, b]]);
                                                            3
          (%o1)         - 2 f2 + f1 (f1 + e1) - 3 e1 e2 + e1
          (%i2) ratsimp (%);
                                   2                       3
          (%o2)         - 2 f2 + f1  + e1 f1 - 3 e1 e2 + e1

     Outras funções para mudanças de base: 'comp2ele'.

 -- Função: multi_pui
     é para a função 'pui' o que a função 'multi_elem' é para a função
     'elem'.

          (%i1) multi_pui ([[2, p1, p2], [2, t1, t2]], a*x + a^2 + x^3, [[x, y], [a, b]]);
                                                      3
                                          3 p1 p2   p1
          (%o1)              t2 + p1 t1 + ------- - ---
                                             2       2

 -- Função: pui (<L>, <sym>, <lvar>)
     decompõe o polinómio simétrico <sym>, nas variáveis na lista
     <lvar>, em termos de funções exponenciais na lista <L>.  Se o
     primeiro elemento de <L> for fornecido, esse primeiro elemento será
     o tamanho do alfabeto, de outra forma o tamanho será o grau do
     polinómio <sym>.  Se valores forem omitidos na lista <L>, valores
     formais do tipo <p1>, <p2> , etc.  serão adicionados.  O polinómio
     <sym> pode ser fornecido de três diferentes formas: contraída
     ('elem' pode então ser 1, seu valor padrão), particionada ('elem'
     pode ser 3), ou extendida (i.e.  o polinómio completo, e 'elem'
     pode então ser 2).  A função 'pui' é usada da mesma forma.

          (%i1) pui;
          (%o1)                           1
          (%i2) pui ([3, a, b], u*x*y*z, [x, y, z]);
                                 2
                             a (a  - b) u   (a b - p3) u
          (%o2)              ------------ - ------------
                                  6              3
          (%i3) ratsimp (%);
                                                 3
                                (2 p3 - 3 a b + a ) u
          (%o3)                 ---------------------
                                          6
     Outras funções para mudanças de base: 'comp2ele'.

 -- Função: pui2comp (<n>, <lpui>)
     converte a dista das primeiras <n> funções completas (com o
     comprimento em primeiro lugar) em termos de funções exponenciais
     fornecidas na lista <lpui>.  se a lista <lpui> for vazia, o
     cardinal é <n>, de outra forma o cardinal será seu primeiro
     elemento (como em 'comp2ele' e em 'comp2pui').

          (%i1) pui2comp (2, []);
                                                 2
                                          p2 + p1
          (%o1)                   [2, p1, --------]
                                             2
          (%i2) pui2comp (3, [2, a1]);
                                                      2
                                           a1 (p2 + a1 )
                                   2  p3 + ------------- + a1 p2
                            p2 + a1              2
          (%o2)     [2, a1, --------, --------------------------]
                               2                  3
          (%i3) ratsimp (%);
                                      2                     3
                               p2 + a1   2 p3 + 3 a1 p2 + a1
          (%o3)        [2, a1, --------, --------------------]
                                  2               6
     Outras funções para mudanças de base: 'comp2ele'.

 -- Função: pui2ele (<n>, <lpui>)
     efectiva a passagem de funções exponenciais para as funções
     elementares simétricas.  Se o sinalizador 'pui2ele' for 'girard',
     'pui2ele' irá retornar a lista de funções elementares simétricas de
     1 a <n>, e se o sinalizador for 'close', 'pui2ele' retornará a
     <n>-ésima função simétrica elementar.

     Outras funções para mudanças de base: 'comp2ele'.

 -- Função: puireduc (<n>, <lpui>)
     <lpui> é uma lista cujo primeiro elemento é um inteiro <m>.
     'puireduc' fornece as primeiras <n> funções exponenciais em termos
     das primeiras <m> funções.

          (%i1) puireduc (3, [2]);
                                                   2
                                             p1 (p1  - p2)
          (%o1)          [2, p1, p2, p1 p2 - -------------]
                                                   2
          (%i2) ratsimp (%);
                                                     3
                                         3 p1 p2 - p1
          (%o2)              [2, p1, p2, -------------]
                                               2

 -- Função: schur2comp (<P>, <l_var>)
     <P> é um polinómio nas variáveis da lista <l_var>.  Cada uma dessas
     variáveis represetna uma função simétrica completa.  Na lista
     <l_var> o <i>-ésima função simétrica completa é representada
     através da concatenação da letra 'h' com o inteiro <i>: 'h<i>'.
     Essa função expressa <P> em termos de funções de Schur.

          (%i1) schur2comp (h1*h2 - h3, [h1, h2, h3]);
          (%o1)                         s
                                         1, 2
          (%i2) schur2comp (a*h3, [h3]);
          (%o2)                         s  a
                                         3

32.1.2 Modificando represetnações
---------------------------------

 -- Função: cont2part (<pc>, <lvar>)
     Retorna o polinómio particionado associado à forma contraída <pc>
     cujas variáveis estão em <lvar>.

          (%i1) pc: 2*a^3*b*x^4*y + x^5;
                                     3    4      5
          (%o1)                   2 a  b x  y + x
          (%i2) cont2part (pc, [x, y]);
                                             3
          (%o2)              [[1, 5, 0], [2 a  b, 4, 1]]

 -- Função: contract (<psym>, <lvar>)
     retorna uma forma contraída (i.e.  um monômio de grupo ssimétrico)
     do polinómio <psym> nas variáveis contidas na lista <lvar>.  A
     função 'explose' executa a operação inversa.  A função 'tcontract'
     testa a simétria do polinómio.

          (%i1) psym: explose (2*a^3*b*x^4*y, [x, y, z]);
                   3      4      3      4      3    4        3    4
          (%o1) 2 a  b y z  + 2 a  b x z  + 2 a  b y  z + 2 a  b x  z

                                                     3      4      3    4
                                                + 2 a  b x y  + 2 a  b x  y
          (%i2) contract (psym, [x, y, z]);
                                        3    4
          (%o2)                      2 a  b x  y

 -- Função: explose (<pc>, <lvar>)
     retorna o polinómio simétrico associado com a forma contraída <pc>.
     A lista <lvar> conté as variáveis.

          (%i1) explose (a*x + 1, [x, y, z]);
          (%o1)                  a z + a y + a x + 1

 -- Função: part2cont (<ppart>, <lvar>)
     vai da forma particionada para a forma contraída de um polinómio
     simétrico.  A forma contraída é convertida com as variáveis em
     <lvar>.

          (%i1) part2cont ([[2*a^3*b, 4, 1]], [x, y]);
                                        3    4
          (%o1)                      2 a  b x  y

 -- Função: partpol (<psym>, <lvar>)
     <psym> é um polinómio simétrico nas variáveis da lista <lvar>.
     Essa função retorna sua represetnação particionada.

          (%i1) partpol (-a*(x + y) + 3*x*y, [x, y]);
          (%o1)               [[3, 1, 1], [- a, 1, 0]]

 -- Função: tcontract (<pol>, <lvar>)
     testa se o polinómio <pol> é simétrico nas variáveis da lista
     <lvar>.  Se for, 'tcontract' retorna uma representação contraída
     como o faz a função 'contract'.

 -- Função: tpartpol (<pol>, <lvar>)
     testa se o polinómio <pol> é simétrico nas variáveis da lista
     <lvar>.  Se for, 'tpartpol' retorna sua represetnação particionada
     como o faz a função 'partpol'.

 -- Função: direct ([<p_1>, ..., <p_n>], <y>, <f>, [<lvar_1>, ...,
          <lvar_n>])
     calcula a imagem directa (see M. Giusti, D. Lazard et A. Valibouze,
     ISSAC 1988, Rome) associada à função <f>, na lista de variáveis
     <lvar_1>, ..., <lvar_n>, e nos polinómios <p_1>, ..., <p_n> na
     variável <y>.  A quantidade de argumetnos que a funçào <f> pode
     receber é importante para o cálculo.  Dessa forma, se a expressão
     para <f> não depende de alguma variável, é inútil incluir essa
     variável, e não incluir essa variável irá também reduzir
     consideravelmente o montante cálculos efetuados.

          (%i1) direct ([z^2  - e1* z + e2, z^2  - f1* z + f2],
                        z, b*v + a*u, [[u, v], [a, b]]);
                 2
          (%o1) y  - e1 f1 y

                                           2            2             2   2
                            - 4 e2 f2 - (e1  - 2 e2) (f1  - 2 f2) + e1  f1
                          + -----------------------------------------------
                                                   2
          (%i2) ratsimp (%);
                        2                2                   2
          (%o2)        y  - e1 f1 y + (e1  - 4 e2) f2 + e2 f1
          (%i3) ratsimp (direct ([z^3-e1*z^2+e2*z-e3,z^2  - f1* z + f2],
                        z, b*v + a*u, [[u, v], [a, b]]));
                 6            5         2                        2    2   4
          (%o3) y  - 2 e1 f1 y  + ((2 e1  - 6 e2) f2 + (2 e2 + e1 ) f1 ) y

                                    3                               3   3
           + ((9 e3 + 5 e1 e2 - 2 e1 ) f1 f2 + (- 2 e3 - 2 e1 e2) f1 ) y

                   2       2        4    2
           + ((9 e2  - 6 e1  e2 + e1 ) f2

                              2       2       2                   2    4
           + (- 9 e1 e3 - 6 e2  + 3 e1  e2) f1  f2 + (2 e1 e3 + e2 ) f1 )

            2          2                      2     3          2
           y  + (((9 e1  - 27 e2) e3 + 3 e1 e2  - e1  e2) f1 f2

                           2            2    3                5
           + ((15 e2 - 2 e1 ) e3 - e1 e2 ) f1  f2 - 2 e2 e3 f1 ) y

                     2                   3           3     2   2    3
           + (- 27 e3  + (18 e1 e2 - 4 e1 ) e3 - 4 e2  + e1  e2 ) f2

                   2      3                   3    2   2
           + (27 e3  + (e1  - 9 e1 e2) e3 + e2 ) f1  f2

                             2    4        2   6
           + (e1 e2 e3 - 9 e3 ) f1  f2 + e3  f1

     Encontrando um polinómio cujas raízes são somatórios a+u onde a é
     uma raíz de z^2 - e_1 z + e_2 e u é uma raíz de z^2 - +f_1 z + f_2.

          (%i1) ratsimp (direct ([z^2 - e1* z + e2, z^2 - f1* z + f2],
                                    z, a + u, [[u], [a]]));
                 4                    3             2
          (%o1) y  + (- 2 f1 - 2 e1) y  + (2 f2 + f1  + 3 e1 f1 + 2 e2

               2   2                              2               2
           + e1 ) y  + ((- 2 f1 - 2 e1) f2 - e1 f1  + (- 2 e2 - e1 ) f1

                            2                     2            2
           - 2 e1 e2) y + f2  + (e1 f1 - 2 e2 + e1 ) f2 + e2 f1  + e1 e2 f1

               2
           + e2

     'direct' aceita dois sinalizadores: 'elementaires' (elementares) e
     'puissances' (exponenciais - valor padrão) que permitem a
     decomposição de polinómios simétricos que aparecerem nesses
     cálculos em funções simétricas elementares ou em funções
     exponenciais respectivamente.

     Funções de 'sym' utilizadas nesta função :

     'multi_orbit' (portanto 'orbit'), 'pui_direct', 'multi_elem'
     (portanto 'elem'), 'multi_pui' (portanto 'pui'), 'pui2ele',
     'ele2pui' (se o sinalizador 'direct' for escolhido para
     'puissances').

 -- Função: multi_orbit (<P>, [<lvar_1>, <lvar_2>,..., <lvar_p>])

     <P> é um polinómio no conjunto de variáveis contidas nas lista
     <lvar_1>, <lvar_2>, ..., <lvar_p>.  Essa função retorna a órbita do
     polinómio <P> sob a ação do produto dos grupos simétricos dos
     conjuntos de variáveis represetnadas nas <p> listas.

          (%i1) multi_orbit (a*x + b*y, [[x, y], [a, b]]);
          (%o1)                [b y + a x, a y + b x]
          (%i2) multi_orbit (x + y + 2*a, [[x, y], [a, b, c]]);
          (%o2)        [y + x + 2 c, y + x + 2 b, y + x + 2 a]
     Veja também: 'orbit' para a ação de um grupo simétrico simples.

 -- Função: multsym (<ppart_1>, <ppart_2>, <n>)
     retorna oproduto de dois polinómios simétricos em <n> varieis
     trabalhando somente módulo a ação do grupo simétrico de ordem <n>.
     O polinómios estão em sua forma particionada.

     Dados 2 polinómio simétricos em <x>, <y>: '3*(x + y) + 2*x*y' e
     '5*(x^2 + y^2)' cujas formas particionadas são '[[3, 1], [2, 1,
     1]]' e '[[5, 2]]', seu produto irá ser

          (%i1) multsym ([[3, 1], [2, 1, 1]], [[5, 2]], 2);
          (%o1)         [[10, 3, 1], [15, 3, 0], [15, 2, 1]]
     isso é '10*(x^3*y + y^3*x) + 15*(x^2*y + y^2*x) + 15*(x^3 + y^3)'.

     Funções para mudar as representacões de um polinómio simétrico:

     'contract', 'cont2part', 'explose', 'part2cont', 'partpol',
     'tcontract', 'tpartpol'.

 -- Função: orbit (<P>, <lvar>)
     calcula a órbita do polinómio <P> nas variáveis na lista <lvar> sob
     a ação do grupo simétrico do conjunto das variáveis na lista
     <lvar>.

          (%i1) orbit (a*x + b*y, [x, y]);
          (%o1)                [a y + b x, b y + a x]
          (%i2) orbit (2*x + x^2, [x, y]);
                                  2         2
          (%o2)                 [y  + 2 y, x  + 2 x]
     Veja também 'multi_orbit' para a ação de um produto de grupos
     simétricos sobre um polinómio.

 -- Função: pui_direct (<orbite>, [<lvar_1>, ..., <lvar_n>], [<d_1>,
          <d_2>, ..., <d_n>])

     Tomemos <f> para ser um polinómio em <n> blocos de variáveis
     <lvar_1>, ..., <lvar_n>.  Façamos <c_i> ser o n;umero de variáveis
     em <lvar_i>, e <SC> ser o produto de <n> grupos simétricos de grau
     <c_1>, ..., <c_n>.  Essas ações dos grupos naturalmente sobre <f>.
     A lista <orbite> é a órbita, denotada '<SC>(<f>)', da função <f>
     sob a ação de <SC>.  (Essa lista pode ser obtida através da função
     'multi_orbit'.)  Os <di> são inteiros de forma que c_1 \le d_1, c_2
     \le d_2, \ldots, c_n \le d_n.

     Tomemos <SD> para ser o produto dos grupos simétricos S_[d_1] x
     S_[d_2] x ... x S_[d_n].  A função 'pui_direct' retorna as
     primeiras <n> funções exponenciais de '<SD>(<f>)' deduzidas das
     funções exponenciais de '<SC>(<f>)', onde <n> é o tamanho de
     '<SD>(<f>)'.

     O resultado está na multi-forma contraída com relação a <SD>, i.e.
     somente um elemento é mantido por órbita, sob a ação de <SD>.

          (%i1) l: [[x, y], [a, b]];
          (%o1)                   [[x, y], [a, b]]
          (%i2) pui_direct (multi_orbit (a*x + b*y, l), l, [2, 2]);
                                                 2  2
          (%o2)               [a x, 4 a b x y + a  x ]
          (%i3) pui_direct (multi_orbit (a*x + b*y, l), l, [3, 2]);
                                       2  2     2    2        3  3
          (%o3) [2 a x, 4 a b x y + 2 a  x , 3 a  b x  y + 2 a  x ,

              2  2  2  2      3    3        4  4
          12 a  b  x  y  + 4 a  b x  y + 2 a  x ,

              3  2  3  2      4    4        5  5
          10 a  b  x  y  + 5 a  b x  y + 2 a  x ,

              3  3  3  3       4  2  4  2      5    5        6  6
          40 a  b  x  y  + 15 a  b  x  y  + 6 a  b x  y + 2 a  x ]
          (%i4) pui_direct ([y + x + 2*c, y + x + 2*b, y + x + 2*a], [[x, y], [a, b, c]], [2, 3]);
                                       2              2
          (%o4) [3 x + 2 a, 6 x y + 3 x  + 4 a x + 4 a ,

                           2                   3        2       2        3
                        9 x  y + 12 a x y + 3 x  + 6 a x  + 12 a  x + 8 a ]

32.1.3 Partições
----------------

 -- Função: kostka (<part_1>, <part_2>)
     escrita por P. Esperet, calcula o número de Kostka da partição
     <part_1> e <part_2>.

          (%i1) kostka ([3, 3, 3], [2, 2, 2, 1, 1, 1]);
          (%o1)                           6

 -- Função: lgtreillis (<n>, <m>)
     retorna a lista de partições de peso <n> e comprimento <m>.

          (%i1) lgtreillis (4, 2);
          (%o1)                   [[3, 1], [2, 2]]
     Veja também: 'ltreillis', 'treillis' e 'treinat'.

 -- Função: ltreillis (<n>, <m>)
     retorna a lista de partições de peso <n> e comprimento menor que ou
     igual a <m>.

          (%i1) ltreillis (4, 2);
          (%o1)               [[4, 0], [3, 1], [2, 2]]

     Veja também: 'lgtreillis', 'treillis' e 'treinat'.

 -- Função: treillis (<n>)
     retorna todas as partições de peso <n>.

          (%i1) treillis (4);
          (%o1)    [[4], [3, 1], [2, 2], [2, 1, 1], [1, 1, 1, 1]]

     Veja também: 'lgtreillis', 'ltreillis' e 'treinat'.

 -- Função: treinat (<part>)
     retorna a lista de partições inferiores à partiçào <part> com
     relação à ordem natural.

          (%i1) treinat ([5]);
          (%o1)                         [[5]]
          (%i2) treinat ([1, 1, 1, 1, 1]);
          (%o2) [[5], [4, 1], [3, 2], [3, 1, 1], [2, 2, 1], [2, 1, 1, 1],

                                                           [1, 1, 1, 1, 1]]
          (%i3) treinat ([3, 2]);
          (%o3)                 [[5], [4, 1], [3, 2]]

     Outras funções de mudança de representação :

     Veja também: 'lgtreillis', 'ltreillis' e 'treillis'.

32.1.4 Polinómios e suas raízes
-------------------------------

 -- Função: ele2polynome (<L>, <z>)
     retorna o polinómio em <z> de forma que as funções elementares
     simétricas de suas raízes estejam na lista '<L> = [<n>, <e_1>, ...,
     <e_n>]', onde <n> é o grau dos polinómios e <e_i> é a <i>-ésima
     função simétrica elementar.

          (%i1) ele2polynome ([2, e1, e2], z);
                                    2
          (%o1)                    z  - e1 z + e2
          (%i2) polynome2ele (x^7 - 14*x^5 + 56*x^3  - 56*x + 22, x);
          (%o2)          [7, 0, - 14, 0, 56, 0, - 56, - 22]
          (%i3) ele2polynome ([7, 0, -14, 0, 56, 0, -56, -22], x);
                            7       5       3
          (%o3)            x  - 14 x  + 56 x  - 56 x + 22
     o inverso: 'polynome2ele (<P>, <z>)'.

     Veja também: 'polynome2ele', 'pui2polynome'.

 -- Função: polynome2ele (<P>, <x>)
     fornece a lista '<l> = [<n>, <e_1>, ..., <e_n>]' onde <n> é o grau
     do polinómio <P> na variável <x> e <e_i> é a <i>-ésima função
     simétrica elementar das raízes de <P>.

          (%i1) polynome2ele (x^7 - 14*x^5 + 56*x^3 - 56*x + 22, x);
          (%o1)          [7, 0, - 14, 0, 56, 0, - 56, - 22]
          (%i2) ele2polynome ([7, 0, -14, 0, 56, 0, -56, -22], x);
                            7       5       3
          (%o2)            x  - 14 x  + 56 x  - 56 x + 22
     A inversa: 'ele2polynome (<l>, <x>)'

 -- Função: prodrac (<L>, <k>)
     <L> é uma lista contendo as funções simétricas elementares sobre um
     conjunto <A>.  'prodrac' retorna o polinómio cujas raízes são os
     produtos <k> por <k> dos elementos de <A>.

     Veja também 'somrac'.

 -- Função: pui2polynome (<x>, <lpui>)
     calcula o polinómio em <x> cujas funções exponenciais das raízes
     são dadas na lista <lpui>.

          (%i1) pui;
          (%o1)                           1
          (%i2) kill(labels);
          (%o0)                         done
          (%i1) polynome2ele (x^3 - 4*x^2 + 5*x - 1, x);
          (%o1)                     [3, 4, 5, 1]
          (%i2) ele2pui (3, %);
          (%o2)                     [3, 4, 6, 7]
          (%i3) pui2polynome (x, %);
                                  3      2
          (%o3)                  x  - 4 x  + 5 x - 1
     Veja também: 'polynome2ele', 'ele2polynome'.

 -- Função: somrac (<L>, <k>)
     A lista <L> contains função simétrica elementars de um polynomial
     <P> .  The function computes the polinómio whose roots are the <k>
     by <k> distinct sums of the roots of <P>.

     Also see 'prodrac'.

32.1.5 Resolvents
-----------------

 -- Função: resolvante (<P>, <x>, <f>, [<x_1>,..., <x_d>])
     calculates the resolvent of the polinómio <P> in <x> of degree <n>
     >= <d> by the function <f> expressed nas variáveis <x_1>, ...,
     <x_d>.  For efficiency of computation it is important to not
     include in the list '[<x_1>, ..., <x_d>]' variables which do not
     appear in the transformation function <f>.

     Para melhorar a eficiência do cálculo se pode escolher
     sinalizadores em 'resolvante' de fora a usar os algoritmos
     apropriados:

     Se a função <f> for unitária :
        * um polinómio em uma variável simples,
        * linear ,
        * alternado,
        * um somatório,
        * simétrico,
        * um produto,
        * a função da resolvente de Cayley (utilisável de grau 5 em
          diante)

               (x1*x2 + x2*x3 + x3*x4 + x4*x5 + x5*x1 -
                    (x1*x3 + x3*x5 + x5*x2 + x2*x4 + x4*x1))^2

          geral,
     o sinalizador da 'resolvante' poderá ser respectivamente :
        * unitaire,
        * lineaire,
        * alternee,
        * somme,
        * produit,
        * cayley,
        * generale.

          (%i1) resolvante: unitaire$
          (%i2) resolvante (x^7 - 14*x^5 + 56*x^3 - 56*x + 22, x, x^3 - 1, [x]);

          " resolvante unitaire " [7, 0, 28, 0, 168, 0, 1120, - 154, 7840, - 2772, 56448, - 33880,

          413952, - 352352, 3076668, - 3363360, 23114112, - 30494464,

          175230832, - 267412992, 1338886528, - 2292126760]
            3       6      3       9      6      3
          [x  - 1, x  - 2 x  + 1, x  - 3 x  + 3 x  - 1,

           12      9      6      3       15      12       9       6      3
          x   - 4 x  + 6 x  - 4 x  + 1, x   - 5 x   + 10 x  - 10 x  + 5 x

                 18      15       12       9       6      3
           - 1, x   - 6 x   + 15 x   - 20 x  + 15 x  - 6 x  + 1,

           21      18       15       12       9       6      3
          x   - 7 x   + 21 x   - 35 x   + 35 x  - 21 x  + 7 x  - 1]
          [- 7, 1127, - 6139, 431767, - 5472047, 201692519, - 3603982011]
                 7      6        5         4          3           2
          (%o2) y  + 7 y  - 539 y  - 1841 y  + 51443 y  + 315133 y

                                                        + 376999 y + 125253
          (%i3) resolvante: lineaire$
          (%i4) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3]);

          " resolvante lineaire "
                 24       20         16            12             8
          (%o4) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i5) resolvante: general$
          (%i6) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3]);

          " resolvante generale "
                 24       20         16            12             8
          (%o6) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i7) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3, x4]);

          " resolvante generale "
                 24       20         16            12             8
          (%o7) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i8) direct ([x^4 - 1], x, x1 + 2*x2 + 3*x3, [[x1, x2, x3]]);
                 24       20         16            12             8
          (%o8) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i9) resolvante :lineaire$
          (%i10) resolvante (x^4 - 1, x, x1 + x2 + x3, [x1, x2, x3]);

          " resolvante lineaire "
                                        4
          (%o10)                       y  - 1
          (%i11) resolvante: symetrique$
          (%i12) resolvante (x^4 - 1, x, x1 + x2 + x3, [x1, x2, x3]);

          " resolvante symetrique "
                                        4
          (%o12)                       y  - 1
          (%i13) resolvante (x^4 + x + 1, x, x1 - x2, [x1, x2]);

          " resolvante symetrique "
                                     6      2
          (%o13)                    y  - 4 y  - 1
          (%i14) resolvante: alternee$
          (%i15) resolvante (x^4 + x + 1, x, x1 - x2, [x1, x2]);

          " resolvante alternee "
                      12      8       6        4        2
          (%o15)     y   + 8 y  + 26 y  - 112 y  + 216 y  + 229
          (%i16) resolvante: produit$
          (%i17) resolvante (x^7 - 7*x + 3, x, x1*x2*x3, [x1, x2, x3]);

          " resolvante produit "
                  35      33         29        28         27        26
          (%o17) y   - 7 y   - 1029 y   + 135 y   + 7203 y   - 756 y

                   24           23          22            21           20
           + 1323 y   + 352947 y   - 46305 y   - 2463339 y   + 324135 y

                    19           18             17              15
           - 30618 y   - 453789 y   - 40246444 y   + 282225202 y

                       14              12             11            10
           - 44274492 y   + 155098503 y   + 12252303 y   + 2893401 y

                        9            8            7             6
           - 171532242 y  + 6751269 y  + 2657205 y  - 94517766 y

                      5             3
           - 3720087 y  + 26040609 y  + 14348907
          (%i18) resolvante: symetrique$
          (%i19) resolvante (x^7 - 7*x + 3, x, x1*x2*x3, [x1, x2, x3]);

          " resolvante symetrique "
                  35      33         29        28         27        26
          (%o19) y   - 7 y   - 1029 y   + 135 y   + 7203 y   - 756 y

                   24           23          22            21           20
           + 1323 y   + 352947 y   - 46305 y   - 2463339 y   + 324135 y

                    19           18             17              15
           - 30618 y   - 453789 y   - 40246444 y   + 282225202 y

                       14              12             11            10
           - 44274492 y   + 155098503 y   + 12252303 y   + 2893401 y

                        9            8            7             6
           - 171532242 y  + 6751269 y  + 2657205 y  - 94517766 y

                      5             3
           - 3720087 y  + 26040609 y  + 14348907
          (%i20) resolvante: cayley$
          (%i21) resolvante (x^5 - 4*x^2 + x + 1, x, a, []);

          " resolvente de Cayley "
                  6       5         4          3            2
          (%o21) x  - 40 x  + 4080 x  - 92928 x  + 3772160 x  + 37880832 x

                                                                 + 93392896

     Para a resolvente de Cayley, os 2 últimos argumentos são neutros e
     o polinómio fornecido na entrada deve ser necessáriamente de grau
     5.

     Veja também :

     'resolvante_bipartite', 'resolvante_produit_sym',
     'resolvante_unitaire', 'resolvante_alternee1', 'resolvante_klein',
     'resolvante_klein3', 'resolvante_vierer', 'resolvante_diedrale'.

 -- Função: resolvante_alternee1 (<P>, <x>)
     calcula a transformação de '<P>(<x>)' de grau <n> pela função
     $\prod_{1\leq i<j\leq n-1} (x_i-x_j)$.  product(x_i - x_j, 1 <= i <
     j <= n - 1).

     Veja também :

     'resolvante_produit_sym', 'resolvante_unitaire', 'resolvante' ,
     'resolvante_klein', 'resolvante_klein3', 'resolvante_vierer',
     'resolvante_diedrale', 'resolvante_bipartite'.

 -- Função: resolvante_bipartite (<P>, <x>)
     calcula a trasformação de '<P>(<x>)' de mesmo grau <n> através da
     função x_1 x_2 ... x_[n/2] + x_[n/2 + 1] ... x_n.

     Veja também :

     'resolvante_produit_sym', 'resolvante_unitaire', 'resolvante' ,
     'resolvante_klein', 'resolvante_klein3', 'resolvante_vierer',
     'resolvante_diedrale', 'resolvante_alternee1'.

          (%i1) resolvante_bipartite (x^6 + 108, x);
                        10        8           6             4
          (%o1)        y   - 972 y  + 314928 y  - 34012224 y

     Veja também :

     'resolvante_produit_sym', 'resolvante_unitaire', 'resolvante',
     'resolvante_klein', 'resolvante_klein3', 'resolvante_vierer',
     'resolvante_diedrale', 'resolvante_alternee1'.

 -- Função: resolvante_diedrale (<P>, <x>)
     +calculates the transformation of '<P>(<x>)' by the function
     +'<x_1> <x_2> + <x_3> <x_4>'.

          (%i1) resolvante_diedrale (x^5 - 3*x^4 + 1, x);
                 15       12       11       10        9         8         7
          (%o1) x   - 21 x   - 81 x   - 21 x   + 207 x  + 1134 x  + 2331 x

                  6         5          4          3          2
           - 945 x  - 4970 x  - 18333 x  - 29079 x  - 20745 x  - 25326 x

           - 697

     Veja também :

     'resolvante_produit_sym', 'resolvante_unitaire',
     'resolvante_alternee1', 'resolvante_klein', 'resolvante_klein3',
     'resolvante_vierer', 'resolvante'.

 -- Função: resolvante_klein (<P>, <x>)
     +calculates the transformation of '<P>(<x>)' by the function
     +'<x_1> <x_2> <x_4> + <x_4>'.

     Veja também :

     'resolvante_produit_sym', 'resolvante_unitaire',
     'resolvante_alternee1', 'resolvante', 'resolvante_klein3',
     'resolvante_vierer', 'resolvante_diedrale'.

 -- Função: resolvante_klein3 (<P>, <x>)
     calcula a transformação de '<P>(<x>)' através da função '<x_1>
     <x_2> <x_4> + <x_4>'.

     Veja também :

     'resolvante_produit_sym', 'resolvante_unitaire',
     'resolvante_alternee1', 'resolvante_klein', 'resolvante',
     'resolvante_vierer', 'resolvante_diedrale'.

 -- Função: resolvante_produit_sym (<P>, <x>)
     calcula a lista de todas as resolventes de produto do polinómio
     '<P>(<x>)'.

          (%i1) resolvante_produit_sym (x^5 + 3*x^4 + 2*x - 1, x);
                  5      4             10      8       7       6       5
          (%o1) [y  + 3 y  + 2 y - 1, y   - 2 y  - 21 y  - 31 y  - 14 y

              4       3      2       10      8       7    6       5       4
           - y  + 14 y  + 3 y  + 1, y   + 3 y  + 14 y  - y  - 14 y  - 31 y

                 3      2       5      4
           - 21 y  - 2 y  + 1, y  - 2 y  - 3 y - 1, y - 1]
          (%i2) resolvante: produit$
          (%i3) resolvante (x^5 + 3*x^4 + 2*x - 1, x, a*b*c, [a, b, c]);

          " resolvente produto "
                 10      8       7    6        5       4       3     2
          (%o3) y   + 3 y  + 14 y  - y  - 14 y  - 31 y  - 21 y  - 2 y  + 1

     Veja também :

     'resolvante', 'resolvante_unitaire', 'resolvante_alternee1',
     'resolvante_klein', 'resolvante_klein3', 'resolvante_vierer',
     'resolvante_diedrale'.

 -- Função: resolvante_unitaire (<P>, <Q>, <x>)
     +computes the resolvent of the polinómio '<P>(<x>)' by the
     +polynomial '<Q>(<x>)'.

     Veja também :

     'resolvante_produit_sym', 'resolvante', 'resolvante_alternee1',
     'resolvante_klein', 'resolvante_klein3', 'resolvante_vierer',
     'resolvante_diedrale'.

 -- Função: resolvante_vierer (<P>, <x>)
     calcula a transformação de '<P>(<x>)' pela função '<x_1> <x_2> -
     <x_3> <x_4>'.

     Veja também :

     'resolvante_produit_sym', 'resolvante_unitaire',
     'resolvante_alternee1', 'resolvante_klein', 'resolvante_klein3',
     'resolvante', 'resolvante_diedrale'.

 -- Função: multinomial (<r>, <part>)
     onde <r> é o peso da partição <part>.  Essa função retorna o
     coefinciente multinomial associado: se as partes de <part> forem
     <i_1>, <i_2>, ..., <i_k>, o resultado é '<r>!/(<i_1>! <i_2>! ...
     <i_k>!)'.

 -- Função: permut (<L>)
     retorna a lista de permutações da lista <L>.

 -- Função: tcontract (<pol>, <lvar>)
     testa se o polinómio <pol> é simétrico nas variáveis contidas na
     lista <lvar>.  se for é rtornado uma forma contraída da forma
     retornada pela função 'contract'.

     Outras funções de mudança de representação :

     'contract', 'cont2part', 'explose', 'part2cont', 'partpol',
     'tpartpol'.

 -- Função: tpartpol (<pol>, <lvar>)
     testa se o polinómio <pol> é simétrico nas variáveis contidas na
     lista <lvar>.  Se for simétrico 'tpartpol' produz a forma
     particionada como a função 'partpol'.

     Outras funções de mudança de representação :

     'contract', 'cont2part', 'explose', 'part2cont', 'partpol',
     'tcontract'.

 -- Função: treillis (<n>)
     retorna todas as partições de peso <n>.

          (%i1) treillis (4);
          (%o1)    [[4], [3, 1], [2, 2], [2, 1, 1], [1, 1, 1, 1]]

     Veja também : 'lgtreillis', 'ltreillis' e 'treinat'.

 -- Função: treinat (<part>)
     retorna a lista das partições inferiores à partição <part> pela
     ordem natural.

          (%i1) treinat ([5]);
          (%o1)                         [[5]]
          (%i2) treinat ([1, 1, 1, 1, 1]);
          (%o2) [[5], [4, 1], [3, 2], [3, 1, 1], [2, 2, 1], [2, 1, 1, 1],

                                                           [1, 1, 1, 1, 1]]
          (%i3) treinat ([3, 2]);
          (%o3)                 [[5], [4, 1], [3, 2]]

     Veja também : 'lgtreillis', 'ltreillis' e 'treillis'.

