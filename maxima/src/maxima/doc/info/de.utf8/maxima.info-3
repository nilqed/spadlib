This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.


File: maxima.info,  Node: Funktionen und Variablen für die TeX-Ausgabe,  Next: Funktionen und Variablen für die Fortran-Ausgabe,  Prev: Funktionen und Variablen für die Eingabe und Ausgabe,  Up: Eingabe und Ausgabe

13.4 Funktionen und Variablen für die TeX-Ausgabe
=================================================

 -- Function: tex (<expr>)
 -- Function: tex (<expr>, <destination>)
 -- Function: tex (<expr>, false)
 -- Function: tex (<label>)
 -- Function: tex (<label>, <destination>)
 -- Function: tex (<label>, false)

     Prints a representation of an expression suitable for the TeX
     document preparation system.  The result is a fragment of a
     document, which can be copied into a larger document but not
     processed by itself.

     'tex (<expr>)' prints a TeX representation of <expr> on the
     console.

     'tex (<label>)' prints a TeX representation of the expression named
     by <label> and assigns it an equation label (to be displayed to the
     left of the expression).  The TeX equation label is the same as the
     Maxima label.

     <destination> may be an output stream or file name.  When
     <destination> is a file name, 'tex' appends its output to the file.
     The functions 'openw' and 'opena' create output streams.

     'tex (<expr>, false)' and 'tex (<label>, false)' return their TeX
     output as a string.

     'tex' evaluates its first argument after testing it to see if it is
     a label.  Quote-quote '''' forces evaluation of the argument,
     thereby defeating the test and preventing the label.

     See also 'texput'.

     Examples:

          (%i1) integrate (1/(1+x^3), x);
                                              2 x - 1
                            2            atan(-------)
                       log(x  - x + 1)        sqrt(3)    log(x + 1)
          (%o1)      - --------------- + ------------- + ----------
                              6             sqrt(3)          3
          (%i2) tex (%o1);
          $$-{{\log \left(x^2-x+1\right)}\over{6}}+{{\arctan \left({{2\,x-1
           }\over{\sqrt{3}}}\right)}\over{\sqrt{3}}}+{{\log \left(x+1\right)
           }\over{3}}\leqno{\tt (\%o1)}$$
          (%o2)                          (\%o1)
          (%i3) tex (integrate (sin(x), x));
          $$-\cos x$$
          (%o3)                           false
          (%i4) tex (%o1, "foo.tex");
          (%o4)                          (\%o1)

     'tex (<expr>, false)' returns its TeX output as a string.

          (%i1) S : tex (x * y * z, false);
          (%o1) $$x\,y\,z$$
          (%i2) S;
          (%o2) $$x\,y\,z$$

 -- Function: tex1 (<e>)

     Returns a string which represents the TeX output for the
     expressions <e>.  The TeX output is not enclosed in delimiters for
     an equation or any other environment.

     Examples:

          (%i1) tex1 (sin(x) + cos(x));
          (%o1)                     \sin x+\cos x

 -- Function: texput (<a>, <s>)
 -- Function: texput (<a>, <f>)
 -- Function: texput (<a>, <s>, <operator_type>)
 -- Function: texput (<a>, [<s_1>, <s_2>], matchfix)
 -- Function: texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)

     Assign the TeX output for the atom <a>, which can be a symbol or
     the name of an operator.

     'texput (<a>, <s>)' causes the 'tex' function to interpolate the
     string <s> into the TeX output in place of <a>.

     'texput (<a>, <f>)' causes the 'tex' function to call the function
     <f> to generate TeX output.  <f> must accept one argument, which is
     an expression which has operator <a>, and must return a string (the
     TeX output).  <f> may call 'tex1' to generate TeX output for the
     arguments of the input expression.

     'texput (<a>, <s>, <operator_type>)', where <operator_type> is
     'prefix', 'infix', 'postfix', 'nary', or 'nofix', causes the 'tex'
     function to interpolate <s> into the TeX output in place of <a>,
     and to place the interpolated text in the appropriate position.

     'texput (<a>, [<s_1>, <s_2>], matchfix)' causes the 'tex' function
     to interpolate <s_1> and <s_2> into the TeX output on either side
     of the arguments of <a>.  The arguments (if more than one) are
     separated by commas.

     'texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)' causes the 'tex'
     function to interpolate <s_1> and <s_2> into the TeX output on
     either side of the arguments of <a>, with <s_3> separating the
     arguments.

     Examples:

     Assign TeX output for a variable.

          (%i1) texput (me,"\\mu_e");
          (%o1)                         \mu_e
          (%i2) tex (me);
          $$\mu_e$$
          (%o2)                         false

     Assign TeX output for an ordinary function (not an operator).

          (%i1) texput (lcm, "\\mathrm{lcm}");
          (%o1)                     \mathrm{lcm}
          (%i2) tex (lcm (a, b));
          $$\mathrm{lcm}\left(a , b\right)$$
          (%o2)                         false

     Call a function to generate TeX output.

          (%i1) texfoo (e) := block ([a, b], [a, b] : args (e),
            concat ("\\left[\\stackrel{", tex1 (b),
                    "}{", tex1 (a), "}\\right]"))$
          (%i2) texput (foo, texfoo);
          (%o2)                        texfoo
          (%i3) tex (foo (2^x, %pi));
          $$\left[\stackrel{\pi}{2^{x}}\right]$$
          (%o3)                         false

     Assign TeX output for a prefix operator.

          (%i1) prefix ("grad");
          (%o1)                         grad
          (%i2) texput ("grad", " \\nabla ", prefix);
          (%o2)                        \nabla
          (%i3) tex (grad f);
          $$ \nabla f$$
          (%o3)                         false

     Assign TeX output for an infix operator.

          (%i1) infix ("~");
          (%o1)                           ~
          (%i2) texput ("~", " \\times ", infix);
          (%o2)                        \times
          (%i3) tex (a ~ b);
          $$a \times b$$
          (%o3)                         false

     Assign TeX output for a postfix operator.

          (%i1) postfix ("##");
          (%o1)                          ##
          (%i2) texput ("##", "!!", postfix);
          (%o2)                          !!
          (%i3) tex (x ##);
          $$x!!$$
          (%o3)                         false

     Assign TeX output for a nary operator.

          (%i1) nary ("@@");
          (%o1)                          @@
          (%i2) texput ("@@", " \\circ ", nary);
          (%o2)                         \circ
          (%i3) tex (a @@ b @@ c @@ d);
          $$a \circ b \circ c \circ d$$
          (%o3)                         false

     Assign TeX output for a nofix operator.

          (%i1) nofix ("foo");
          (%o1)                          foo
          (%i2) texput ("foo", "\\mathsc{foo}", nofix);
          (%o2)                     \mathsc{foo}
          (%i3) tex (foo);
          $$\mathsc{foo}$$
          (%o3)                         false

     Assign TeX output for a matchfix operator.

          (%i1) matchfix ("<<", ">>");
          (%o1)                          <<
          (%i2) texput ("<<", [" \\langle ", " \\rangle "], matchfix);
          (%o2)                [ \langle ,  \rangle ]
          (%i3) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o3)                         false
          (%i4) tex (<<a, b>>);
          $$ \langle a , b \rangle $$
          (%o4)                         false
          (%i5) texput ("<<", [" \\langle ", " \\rangle ", " \\, | \\,"],
                matchfix);
          (%o5)           [ \langle ,  \rangle ,  \, | \,]
          (%i6) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o6)                         false
          (%i7) tex (<<a, b>>);
          $$ \langle a \, | \,b \rangle $$
          (%o7)                         false

 -- Function: get_tex_environment (<op>)
 -- Function: set_tex_environment (<op>, <before>, <after>)

     Customize the TeX environment output by 'tex'.  As maintained by
     these functions, the TeX environment comprises two strings: one is
     printed before any other TeX output, and the other is printed
     after.

     Only the TeX environment of the top-level operator in an expression
     is output; TeX environments associated with other operators are
     ignored.

     'get_tex_environment' returns the TeX enviroment which is applied
     to the operator <op>; returns the default if no other environment
     has been assigned.

     'set_tex_environment' assigns the TeX environment for the operator
     <op>.

     Examples:

          (%i1) get_tex_environment (":=");
          (%o1) [
          \begin{verbatim}
          , ;
          \end{verbatim}
          ]
          (%i2) tex (f (x) := 1 - x);

          \begin{verbatim}
          f(x):=1-x;
          \end{verbatim}

          (%o2)                         false
          (%i3) set_tex_environment (":=", "$$", "$$");
          (%o3)                       [$$, $$]
          (%i4) tex (f (x) := 1 - x);
          $$f(x):=1-x$$
          (%o4)                         false

 -- Function: get_tex_environment_default ()
 -- Function: set_tex_environment_default (<before>, <after>)

     Customize the TeX environment output by 'tex'.  As maintained by
     these functions, the TeX environment comprises two strings: one is
     printed before any other TeX output, and the other is printed
     after.

     'get_tex_environment_default' returns the TeX environment which is
     applied to expressions for which the top-level operator has no
     specific TeX environment (as assigned by 'set_tex_environment').

     'set_tex_environment_default' assigns the default TeX environment.

     Examples:

          (%i1) get_tex_environment_default ();
          (%o1)                       [$$, $$]
          (%i2) tex (f(x) + g(x));
          $$g\left(x\right)+f\left(x\right)$$
          (%o2)                         false
          (%i3) set_tex_environment_default ("\\begin{equation}
          ", "
          \\end{equation}");
          (%o3) [\begin{equation}
          ,
          \end{equation}]
          (%i4) tex (f(x) + g(x));
          \begin{equation}
          g\left(x\right)+f\left(x\right)
          \end{equation}
          (%o4)                         false


File: maxima.info,  Node: Funktionen und Variablen für die Fortran-Ausgabe,  Prev: Funktionen und Variablen für die TeX-Ausgabe,  Up: Eingabe und Ausgabe

13.5 Funktionen und Variablen für die Fortran-Ausgabe
=====================================================

 -- Option variable: fortindent
     Default value: '0'

     'fortindent' controls the left margin indentation of expressions
     printed out by the 'fortran' command.  '0' gives normal printout
     (i.e., 6 spaces), and positive values will causes the expressions
     to be printed farther to the right.

 -- Function: fortran (<expr>)

     Prints <expr> as a Fortran statement.  The output line is indented
     with spaces.  If the line is too long, 'fortran' prints
     continuation lines.  'fortran' prints the exponentiation operator
     '^' as '**', and prints a complex number 'a + b %i' in the form
     '(a,b)'.

     <expr> may be an equation.  If so, 'fortran' prints an assignment
     statement, assigning the right-hand side of the equation to the
     left-hand side.  In particular, if the right-hand side of <expr> is
     the name of a matrix, then 'fortran' prints an assignment statement
     for each element of the matrix.

     If <expr> is not something recognized by 'fortran', the expression
     is printed in 'grind' format without complaint.  'fortran' does not
     know about lists, arrays, or functions.

     'fortindent' controls the left margin of the printed lines.  '0' is
     the normal margin (i.e., indented 6 spaces).  Increasing
     'fortindent' causes expressions to be printed further to the right.

     When 'fortspaces' is 'true', 'fortran' fills out each printed line
     with spaces to 80 columns.

     'fortran' evaluates its arguments; quoting an argument defeats
     evaluation.  'fortran' always returns 'done'.

     See also the function 'f90' for printing one or more expressions as
     a Fortran 90 program.

     Examples:

     (%i1) expr: (a + b)^12$
     (%i2) fortran (expr);
           (b+a)**12
     (%o2)                         done
     (%i3) fortran ('x=expr);
           x = (b+a)**12
     (%o3)                         done
     (%i4) fortran ('x=expand (expr));
           x = b**12+12*a*b**11+66*a**2*b**10+220*a**3*b**9+495*a**4*b**8+792
          1   *a**5*b**7+924*a**6*b**6+792*a**7*b**5+495*a**8*b**4+220*a**9*b
          2   **3+66*a**10*b**2+12*a**11*b+a**12
     (%o4)                         done
     (%i5) fortran ('x=7+5*%i);
           x = (7,5)
     (%o5)                         done
     (%i6) fortran ('x=[1,2,3,4]);
           x = [1,2,3,4]
     (%o6)                         done
     (%i7) f(x) := x^2$
     (%i8) fortran (f);
           f
     (%o8)                         done

 -- Option variable: fortspaces
     Default value: 'false'

     When 'fortspaces' is 'true', 'fortran' fills out each printed line
     with spaces to 80 columns.


File: maxima.info,  Node: Mengen,  Next: Summen Produkte und Reihen,  Prev: Eingabe und Ausgabe,  Up: Top

14 Mengen
*********

* Menu:

* Einführung in Mengen::
* Funktionen und Variablen für Mengen::


File: maxima.info,  Node: Einführung in Mengen,  Next: Funktionen und Variablen für Mengen,  Prev: Mengen,  Up: Mengen

14.1 Einführung in Mengen
=========================

Maxima hat Funktionen wie den Schnitt und die Vereinigung von endlichen
Mengen, die durch eine explizite Aufzählung definiert werden können.
Listen und Mengen sind in Maxima unterschiedliche Objekte und können
selbst Elemente von Mengen sein.  Siehe auch *note Listen::.

Neben den Funktionen für Mengen, enthält dieses Kapitel weitere
Funktionen der Kombinatorik.  Darunter die Stirling-Zahlen der ersten
und zweiten Art, die Bellschen Zahlen, Multinomialverteilungen,
Partitionsfunktionen oder die Kronecker-Delta-Funktion.

14.1.1 Anwendung
----------------

Mit 'set(a_1, ..., a_n)' oder '{a_1, ..., a_n}' wird eine Menge mit den
Elementen 'a_1, ..., a_n' konstruiert.  Die leere Menge wird mit 'set()'
oder '{}' angegeben.  Mengen werden immer mit geschweiften Klammern
angezeigt.  Werden Elemente mehrmals angegeben, werden die doppelten
Elemente aus der Menge entfernt.

Beispiele:

     (%i1) set();
     (%o1)                          {}
     (%i2) set(a, b, a);
     (%o2)                        {a, b}
     (%i3) set(a, set(b));
     (%o3)                       {a, {b}}
     (%i4) set(a, [b]);
     (%o4)                       {a, [b]}
     (%i5) {};
     (%o5)                          {}
     (%i6) {a, b, a};
     (%o6)                        {a, b}
     (%i7) {a, {b}};
     (%o7)                       {a, {b}}
     (%i8) {a, [b]};
     (%o8)                       {a, [b]}

Zwei Elemente <x> und <y> werden als gleich angesehen, wenn 'is(<x> =
<y>)' das Ergebnis 'true' hat.  Die Elemente sind dann syntaktisch
gleich.  Es ist zu beachten, dass 'is(equal(<x>, <y>))' das Ergebnis
'true' haben kann, jedoch der Ausdruck 'is(<x> = <y>)' das Ergebnis
'false' liefert.

     (%i1) x: a/c + b/c;
                                   b   a
     (%o1)                         - + -
                                   c   c
     (%i2) y: a/c + b/c;
                                   b   a
     (%o2)                         - + -
                                   c   c
     (%i3) z: (a + b)/c;
                                   b + a
     (%o3)                         -----
                                     c
     (%i4) is (x = y);
     (%o4)                         true
     (%i5) is (y = z);
     (%o5)                         false
     (%i6) is (equal (y, z));
     (%o6)                         true
     (%i7) y - z;
                                b + a   b   a
     (%o7)                    - ----- + - + -
                                  c     c   c
     (%i8) ratsimp (%);
     (%o8)                           0
     (%i9) {x, y, z};
                               b + a  b   a
     (%o9)                    {-----, - + -}
                                 c    c   c

Mit der Funktion 'setify' kann eine Menge aus einer Liste konstruiert
werden.

     (%i1) setify ([b, a]);
     (%o1)                        {a, b}

Die Elemente 'x' und 'y' einer Menge sind gleich, wenn der Ausdruck
'is(x = y)' das Ergebnis 'true' hat.  Daher werden zum Beispiel 'rat(x)'
und 'x' als gleich betrachtet.

     (%i1) {x, rat(x)};
     (%o1)                          {x}

Da der Ausdruck 'is((x - 1)*(x + 1) = x^2 - 1)' das Ergebnis 'false'
hat, werden '(x - 1)*(x + 1)' und 'x^2 - 1' als verschiedene Elemente
angenommen.

     (%i1) {(x - 1)*(x + 1), x^2 - 1};
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}

Um die Menge des letzten Beispiels auf ein Element zu reduzieren, kann
die Funktion 'rat' auf die Elemente der Menge angewendet werden.

     (%i1) {(x - 1)*(x + 1), x^2 - 1};
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}
     (%i2) map (rat, %);
                                   2
     (%o2)/R/                    {x  - 1}

Um redundante Elemente von Mengen zu entfernen, können Funktionen für
die Vereinfachung von Ausdrücken angewendet werden.  In diesem Beispiel
wird die Funktion 'trigsimp' auf die Elemente der Menge angewendet.

     (%i1) {1, cos(x)^2 + sin(x)^2};
                                 2         2
     (%o1)                {1, sin (x) + cos (x)}
     (%i2) map (trigsimp, %);
     (%o2)                          {1}

Hat eine Menge redundante Elemente, wird sie vereinfacht und sortiert.
Die Ordnung der Elemente wird von der Funktion 'orderlessp' bestimmt.
Einige Operationen auf Mengen, wie zum Beispiel Substitutionen erzwingen
die Vereinfachung von Mengen.

     (%i1) s: {a, b, c}$
     (%i2) subst (c=a, s);
     (%o2)                        {a, b}
     (%i3) subst ([a=x, b=x, c=x], s);
     (%o3)                          {x}
     (%i4) map (lambda ([x], x^2), set (-1, 0, 1));
     (%o4)                        {0, 1}

Maxima behandelt Listen und Mengen als verschiedene Objekte.  Funktionen
wie 'union' oder 'intersection' geben eine Fehlermeldung, wenn die
Argumente keine Mengen sind.  Um eine Funktion für Mengen auf eine Liste
anzuwenden, kann diese mit der Funktion 'setify' in eine Menge
umgewandelt werden.

     (%i1) union ([1, 2], {a, b});
     Function union expects a set, instead found [1,2]
      -- an error.  Quitting.  To debug this try debugmode(true);
     (%i2) union (setify ([1, 2]), {a, b});
     (%o2)                     {1, 2, a, b}

Mit der Funktion 'subset' kann eine Teilmenge ermittelt werden, deren
Elemente für eine Aussagefunktion das Ergebnis 'true' haben.  Um die
Gleichungen einer Menge zu finden, die nicht von der Variablen 'z'
abhängen, wird im Folgenden die Aussagefunktion 'freeof' verwendet.

     (%i1) subset ({x + y + z, x - y + 4, x + y - 5},
                                         lambda ([e], freeof (z, e)));
     (%o1)               {- y + x + 4, y + x - 5}

In *note Funktionen und Variablen für Mengen:: sind die Funktionen
dokumentiert, die Maxima für Mengen kennt.

14.1.2 Iteration über Mengen
----------------------------

Es gibt zwei Möglichkeiten, über die Elemente einer Menge zu iterieren.
Im ersten Fall wird die Funktion 'map' genutzt.

     (%i1) map (f, {a, b, c});
     (%o1)                  {f(a), f(b), f(c)}

Eine weitere Möglichkeit ist, eine 'for'-Schleife einzusetzen.

     (%i1) s: {a, b, c};
     (%o1)                       {a, b, c}
     (%i2) for si in s do print (concat (si, 1));
     a1
     b1
     c1
     (%o2)                         done

Die Funktionen 'first' und 'rest' funktionieren auch für Mengen.  Wird
die Funktion 'first' auf eine Menge angewendet, ist das Ergebnis das
erste Element, wie es in der Anzeige erscheint.  Ist 's' eine Menge,
dann ist der Ausdruck 'rest(s)' äquivalent zu 'disjoin(first(s), s)'.
Siehe die Funktion 'disjoin'.

14.1.3 Programmfehler
---------------------

Die Möglichkeit mit den Funktionen 'orderless' und 'ordergreat' eine
neue Ordnung für Variablen zu definieren, ist nicht kompatibel mit den
Funktionen für Mengen.  Wird eine der Funktionen 'orderless' oder
'ordergreat' benötigt, sollten diese vor der Konstruktion der ersten
Menge ausgeführt werden.  Die Funktion 'unorder' sollte nicht ausgeführt
werden.

14.1.4 Autoren
--------------

Stavros Macrakis aus Cambridge, Massachusetts und Barton Willis von der
Universität Nebraska in Kearney (UNK) haben die Funktionen und die
Dokumentation für Mengen geschrieben.


File: maxima.info,  Node: Funktionen und Variablen für Mengen,  Prev: Einführung in Mengen,  Up: Mengen

14.2 Funktionen und Variablen für Mengen
========================================

 -- Funktion: adjoin (<x>, <a>)

     Vereinigt die Menge <a> mit '{<x>}' und gibt die vereinigte Menge
     als Ergebnis zurück.

     'adjoin' gibt eine Fehlermeldung, wenn das Argument <a> keine Menge
     ist.

     'adjoin(<x>, <a>)' und 'union(set(<x>), <a>)' sind äquivalent.  Die
     Funktion 'adjoin' kann etwas schneller als die Funktion 'union'
     sein.

     Siehe auch die Funktion 'disjoin'.

     Beispiele:

          (%i1) adjoin (c, {a, b});
          (%o1)                       {a, b, c}
          (%i2) adjoin (a, {a, b});
          (%o2)                        {a, b}

 -- Funktion: belln (<n>)

     Repräsentiert die n-te Bellsche Zahl.

     Ist das Argument <n> eine nicht-negative ganze Zahl, vereinfacht
     'belln(<n>)' zu der n-ten Bellschen Zahl.  Für andere Argumente
     vereinfacht die Funktion 'belln' nicht.

     Ist das Argument der Funktion 'belln' eine Liste, Menge, Matrix
     oder eine Gleichung, wird die Funktion auf die Elemente oder beide
     Seiten der Gleichung angewendet.

     Beispiele:

     Anwendung der Funktion 'belln' auf nicht-negative ganze Zahlen.

          (%i1) makelist (belln (i), i, 0, 6);
          (%o1)               [1, 1, 2, 5, 15, 52, 203]
          (%i2) is (cardinality (set_partitions ({})) = belln (0));
          (%o2)                         true
          (%i3) is (cardinality (set_partitions ({1, 2, 3, 4, 5, 6})) =
                                 belln (6));
          (%o3)                         true

     Anwendung der Funktion 'belln' auf andere Argumente als
     nicht-negative ganze Zahlen.

          (%i1) [belln (x), belln (sqrt(3)), belln (-9)];
          (%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]

 -- Funktion: cardinality (<a>)

     Gibt die Mächtigkeit (Kardinalität) einer Menge zurück.  Für
     endliche Mengen ist die Mächtigkeit die Anzahl der Elemente der
     Menge.

     Die Funktion 'cardinality' ignoriert redundante Elemente einer
     Menge auch dann, wenn die Vereinfachung abgeschaltet ist.

     Beispiele:

          (%i1) cardinality ({});
          (%o1)                           0
          (%i2) cardinality ({a, a, b, c});
          (%o2)                           3
          (%i3) simp : false;
          (%o3)                         false
          (%i4) cardinality ({a, a, b, c});
          (%o4)                           3

 -- Funktion: cartesian_product (<b_1>, ..., <b_n>)

     Gibt das kartesische Produkt der Mengen <b_1>, ..., <b_n> zurück.
     Das kartesische Produkt ist die Menge der geordneten Paare.

     Das Ergebnis ist eine Menge mit Listen der Form '[<x_1>, ...,
     <x_n>]', wobei <x_1>, ..., <x_n> die Elemente der Mengen <b_1>,
     ..., <b_n> sind.

     Die Funktion 'cartesian_product' gibt eine Fehlermeldung, wenn
     eines der Argumente keine Menge ist.

     Beispiele:

          (%i1) cartesian_product ({0, 1});
          (%o1)                      {[0], [1]}
          (%i2) cartesian_product ({0, 1}, {0, 1});
          (%o2)           {[0, 0], [0, 1], [1, 0], [1, 1]}
          (%i3) cartesian_product ({x}, {y}, {z});
          (%o3)                      {[x, y, z]}
          (%i4) cartesian_product ({x}, {-1, 0, 1});
          (%o4)              {[x, - 1], [x, 0], [x, 1]}

 -- Funktion: disjoin (<x>, <a>)

     Entfernt das Element <x> aus der Menge <a> und gibt das Ergebnis
     zurück.

     'disjoin' gibt eine Fehlermeldung, wenn das Argument <a> keine
     Menge ist.

     Die Ausdrücke 'disjoin(<x>, <a>)', 'delete(<x>, <a>)' und
     'setdifference(<a>, set(<x>))' sind äquivalent.  Von diesen
     Möglichkeiten ist im Allgemeinen die Funktion 'disjoin' am
     schnellsten.

     Siehe auch die Funktion 'adjoin' sowie die Funktionen 'delete' und
     'setdifference'.

     Beispiele:

          (%i1) disjoin (a, {a, b, c, d});
          (%o1)                       {b, c, d}
          (%i2) disjoin (a + b, {5, z, a + b, %pi});
          (%o2)                      {5, %pi, z}
          (%i3) disjoin (a - b, {5, z, a + b, %pi});
          (%o3)                  {5, %pi, b + a, z}

 -- Funktion: disjointp (<a>, <b>)

     'disjointp' hat das Ergebnis 'true', wenn die Mengen <a> und <b>
     disjunkt sind.  Zwei Mengen sind disjunkt, wenn sie kein
     gemeinsames Element besitzen.

     'disjointp' gibt eine Fehlermeldung, wenn eines der Argumente keine
     Menge ist.

     Beispiele:

          (%i1) disjointp ({a, b, c}, {1, 2, 3});
          (%o1)                         true
          (%i2) disjointp ({a, b, 3}, {1, 2, 3});
          (%o2)                         false

 -- Funktion: divisors (<n>)

     Gibt die Menge der Teiler der Zahl <n> zurück.

     Ist das Argument <n> eine von Null verschiedene ganze Zahl,
     vereinfacht 'divisors(<n>)' zu einer Menge mit ganzen Zahlen, die
     Teiler des Argumentes <n> sind.  Ist das Argument <n> eine negative
     Zahl wird der Betrag des Argumentes genommen.  Das Ergebnis enthält
     die Elemente <1> und <n>.

     Ist das Argument der Funktion 'divisors' eine Liste, Menge, Matrix
     oder eine Gleichung, wird die Funktion auf die Elemente oder beide
     Seiten der Gleichung angewendet.

     Beispiele:

     Das Beispiel zeigt, dass 28 eine perfekte Zahl ist, die gleich die
     Summe ihrer Teiler außer sich selbst ist.

          (%i1) s: divisors(28);
          (%o1)                 {1, 2, 4, 7, 14, 28}
          (%i2) lreduce ("+", args(s)) - 28;
          (%o2)                          28

     'divisors' ist eine vereinfachende Funktion.  In diesem Beispiel
     braucht daher der Ausdruck nach der Substitution nicht erneut
     ausgewertet werden.

          (%i1) divisors (a);
          (%o1)                      divisors(a)
          (%i2) subst (8, a, %);
          (%o2)                     {1, 2, 4, 8}

     Anwendung der Funktion 'divisors' auf Gleichungen, Listen, Matrizen
     oder Mengen.

          (%i1) divisors (a = b);
          (%o1)               divisors(a) = divisors(b)
          (%i2) divisors ([a, b, c]);
          (%o2)        [divisors(a), divisors(b), divisors(c)]
          (%i3) divisors (matrix ([a, b], [c, d]));
                            [ divisors(a)  divisors(b) ]
          (%o3)             [                          ]
                            [ divisors(c)  divisors(d) ]
          (%i4) divisors ({a, b, c});
          (%o4)        {divisors(a), divisors(b), divisors(c)}

 -- Funktion: elementp (<x>, <a>)

     Gibt 'true' zurück, wenn das Argument <x> Element der Menge <a>
     ist.

     'elementp' gibt eine Fehlermeldung, wenn das Argument <a> keine
     Menge ist.

     Beispiele:

          (%i1) elementp (sin(1), {sin(1), sin(2), sin(3)});
          (%o1)                         true
          (%i2) elementp (sin(1), {cos(1), cos(2), cos(3)});
          (%o2)                         false

 -- Funktion: emptyp (<a>)

     Gibt 'true' zurück, wenn das Argument <a> die leere Menge oder eine
     leere Liste ist.

     Beispiele:

          (%i1) map (emptyp, [{}, []]);
          (%o1)                     [true, true]
          (%i2) map (emptyp, [a + b, {{}}, %pi]);
          (%o2)                 [false, false, false]

 -- Funktion: equiv_classes (<s>, <F>)

     Gibt die Menge der Äquivalenzklassen der Menge <s> für die
     Äquivalenzrelation 'F' zurück.

     Die Äquivalenzrelation 'F' ist eine Funktion mit zwei Argumenten
     definiert auf dem Kartesischen Produkt der Menge <s> mit <s>.  Die
     Rückgabe der Funktion 'F' ist 'true' oder 'false' oder ein Ausdruck
     <expr>, so dass 'is(<expr>)' das Ergebnis 'true' oder 'false' hat.

     Ist <F> keine Äquivalenzrelation, wird die Funktion von
     'equiv_classes' ohne Fehlermeldung akzeptiert.  Das Ergebnis ist
     jedoch im Allgemeinen nicht korrekt.

     Beispiele:

     Die Äquivalenzrelation ist ein Lambda-Ausdruck mit den Ergebnissen
     'true' oder 'false'.

          (%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0},
                                  lambda ([x, y], is (equal (x, y))));
          (%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}

     Die Äquivalenzrelation ist der Name einer relationalen Funktion,
     die von 'is' zu 'true' oder 'false' ausgewertet wird.

          (%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, equal);
          (%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}

     Die Äquivalenzklassen sind Mengen mit Zahlen, die sich um ein
     Vielfaches von 3 voneinander unterscheiden.

          (%i1) equiv_classes ({1, 2, 3, 4, 5, 6, 7},
                               lambda ([x, y], remainder (x - y, 3) = 0));
          (%o1)              {{1, 4, 7}, {2, 5}, {3, 6}}

 -- Funktion: every (<f>, <s>)
 -- Funktion: every (<f>, <L_1>, ..., <L_n>)

     Gibt das Ergebnis 'true' zurück, wenn die Aussage 'f' das Ergebnis
     'true' für alle Elemente der Menge <s> hat.

     Ist das zweite Argument eine Menge, dann gibt 'every(<f>, <s>)' den
     Wert 'true' zurück, wenn 'is(<f>(<a_i>))' das Ergebnis 'true' für
     alle Elemente <a_i> der Menge <s> hat.  'every' wertet <f> nicht
     notwendigerweise für alle Elemente <a_i> aus, wenn das Ergebnis
     bereits feststeht.  Da Mengen nicht geordnet sind, kann die
     Funktion 'every' die Ausdrücke '<f>(<a_i>)' in irgendeiner
     Reihenfolge auswerten.

     Sind die Argumente eine oder mehrere Listen, dann gibt 'every(<f>,
     <L_1>, ..., <L_n>)' den Wert 'true' zurück, wenn 'is(<f>(<x_1>,
     ..., <x_n>))' das Ergebnis 'true' für alle <x_1>, ..., <x_n> der
     Listen <L_1>, ..., <L_n> hat.  'every' wertet <f> wird nicht
     notwendigerweise für alle Kombinationen <x_1>, ..., <x_n> aus, wenn
     das Ergebnis bereits feststeht.  'every' wertet die Listen in der
     Reihenfolge des steigenden Index aus.

     Ist die leere Menge oder leere Liste ein Argument der Funktion
     'every', dann ist das Ergebnis immer 'false'.

     Hat die Optionsvariable 'maperror' den Wert 'true', müssen alle
     Listen <L_1>, ..., <L_n> die gleiche Länge haben.  Hat die
     Optionsvariable 'maperror' den Wert 'false', werden die Listen auf
     die Länge der kürzesten Liste abgeschnitten.

     Kann die Aussagefunktion <f> von der Funktion 'is' nicht zu 'true'
     oder 'false' ausgewertet werden, hängt das Ergebnis von der
     Optionsvariablen 'prederror' ab.  Hat die Optionsvariable
     'prederror' den Wert 'true', werden solche Werte als 'false'
     behandelt und die Funktion 'every' hat das Ergebnis 'false'.  Hat
     'prederror' den Wert 'false', werden solche Werte als 'unknown'
     behandelt und die Funktion 'every' hat das Ergebnis 'unknown'.

     Beispiele:

     'every' angewendet auf eine Menge.  Die Aussagefunktion hat ein
     Argument.

          (%i1) every (integerp, {1, 2, 3, 4, 5, 6});
          (%o1)                         true
          (%i2) every (atom, {1, 2, sin(3), 4, 5 + y, 6});
          (%o2)                         false

     'every' angewendet auf zwei Listen.  Die Aussagefunktion hat zwei
     Argumente entsprechend der Anzahl der Listen.

          (%i1) every ("=", [a, b, c], [a, b, c]);
          (%o1)                         true
          (%i2) every ("#", [a, b, c], [a, b, c]);
          (%o2)                         false

     Kann die Aussagefunktion <f> nicht zu 'true' oder 'false'
     ausgewertet werden, hängt das Ergebnis von 'every' von der
     Optionsvariablen 'prederror' ab.

          (%i1) prederror : false;
          (%o1)                         false
          (%i2) map (lambda ([a, b], is (a < b)), [x, y, z],
                             [x^2, y^2, z^2]);
          (%o2)              [unknown, unknown, unknown]
          (%i3) every ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o3)                        unknown
          (%i4) prederror : true;
          (%o4)                         true
          (%i5) every ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o5)                         false

 -- Funktion: extremal_subset (<s>, <f>, max)
 -- Funktion: extremal_subset (<s>, <f>, min)

     Gibt die Teilmenge von <s> zurück, für die die Funktion <f>
     maximale oder minimale Ergebnisse hat.

     'extremal_subset(<s>, <f>, max)' gibt die Teilmenge der Liste oder
     Menge <s> zurück, für die die Funktion <f> ihre maximalen Werte
     annimmt.

     'extremal_subset(<s>, <f>, min)' gibt die Teilmenge der Liste oder
     Menge <s> zurück, für die die Funktion <f> ihre minimalen Werte
     annimmt.

     Beispiele:

          (%i1) extremal_subset ({-2, -1, 0, 1, 2}, abs, max);
          (%o1)                       {- 2, 2}
          (%i2) extremal_subset ({sqrt(2), 1.57, %pi/2}, sin, min);
          (%o2)                       {sqrt(2)}

 -- Funktion: flatten (<expr>)

     Sammelt die Argumente von allen Teilausdrücken, die denselben
     Operator wie der Ausdruck <expr> haben und konstruiert einen
     Ausdruck mit dem Operator des Ausdrucks <expr> und den Argumenten.
     Ein einfaches Beispiel ist eine verschachtelte Liste.  'flatten'
     konstruiert in diesem Fall eine Liste aus den Elementen aller
     Teillisten.

     Teilausdrücke, deren Operator sich von dem Hauptoperator des
     Ausdrucks <expr> unterscheidet, werden als ein Argument betrachtet,
     auch wenn der Teilausdrück wiederum Teilausdrücke des
     Hauptoperators enthält.

     Es ist möglich, dass 'flatten' Ausdrücke konstruiert, in denen die
     Anzahl der Argumente nicht der erforderlichen Anzahl an Argumenten
     des Operators entspricht.  Dies kann zu Fehlermeldungen bei der
     Auswertung oder Vereinfachung führen.  'flatten' kontrolliert
     nicht, ob die konstruierten Ausdrücke gültig sind.

     Ausdrücke mit speziellen Darstellungen, wie zum Beispiel
     CRE-Ausdrücke, können von 'flatten' nicht verarbeitet werden.  In
     diesem Fällen gibt 'flatten' das Argument unverändert zurück.

     Beispiele:

     Wird 'flatten' auf eine Liste angewendet, werden die Elemente aller
     Teillisten zu einer Liste zusammengefügt.

          (%i1) flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
          (%o1)            [a, b, c, d, e, f, g, h, i, j]

     Wird 'flatten' auf eine Menge angewendet, werden die Elemente aller
     Teilmengen zu einer Menge zusammengefügt.

          (%i1) flatten ({a, {b}, {{c}}});
          (%o1)                       {a, b, c}
          (%i2) flatten ({a, {[a], {a}}});
          (%o2)                       {a, [a]}

     Die Funktionsweise von 'flatten' ist vergleichbar mit der
     Deklaration eines Operators als ein N-ary-Operator.  Im Unterschied
     zu einer Deklaration hat 'flatten' keinen Einfluss auf
     Teilausdrücke, die einen vom Hauptoperator verschiedenen Operator
     haben.

          (%i1) expr: flatten (f (g (f (f (x)))));
          (%o1)                     f(g(f(f(x))))
          (%i2) declare (f, nary);
          (%o2)                         done
          (%i3) ev (expr);
          (%o3)                      f(g(f(x)))

     'flatten' kann Ausdrücke mit indizierte Funktionen vereinfachen.

          (%i1) flatten (f[5] (f[5] (x, y), z));
          (%o1)                      f (x, y, z)
                                      5

     Es ist möglich, dass 'flatten' einen Ausdruck konstruiert, der
     nicht die korrekte Anzahl an Argumenten eines Operators enthält.

          (%i1) 'mod (5, 'mod (7, 4));
          (%o1)                   mod(5, mod(7, 4))
          (%i2) flatten (%);
          (%o2)                     mod(5, 7, 4)
          (%i3) ''%, nouns;
          Wrong number of arguments to mod
           -- an error.  Quitting.  To debug this try debugmode(true);

 -- Funktion: full_listify (<a>)

     Ersetzt jedes Auftreten des Operators für Mengen in dem Ausdruck
     <a> durch den Operator für Listen.  Die Ersetzung wird auch in
     verschachtelten Teilausdrücken ausgeführt, deren Operator nicht der
     Operator für Mengen ist.

     Die Funktion 'listify' ersetzt nur den Hauptoperator eines
     Ausdrucks.

     Beispiele:

          (%i1) full_listify ({a, b, {c, {d, e, f}, g}});
          (%o1)               [a, b, [c, [d, e, f], g]]
          (%i2) full_listify (F (G ({a, b, H({c, d, e})})));
          (%o2)              F(G([a, b, H([c, d, e])]))

 -- Funktion: fullsetify (<a>)

     Ist <a> eine Liste, wird der Operator für Listen durch den Operator
     für Mengen ersetzt.  Dann wird 'fullsetify' auf alle Argumente der
     Liste angewendet.  Ist ein Argument keine Liste, wenn das Argument
     unverändert zurückgegeben.

     Die Funktion 'setify' ersetzt nur den Hauptoperator eines
     Ausdrucks.

     Beispiele:

     Im zweiten Beispiel wird das Argument der Funktion 'f' nicht in
     eine Menge konvertiert, da der Operator des Teilausdrucks keine
     Liste ist.

          (%i1) fullsetify ([a, [a]]);
          (%o1)                       {a, {a}}
          (%i2) fullsetify ([a, f([b])]);
          (%o2)                      {a, f([b])}

 -- Funktion: identity (<x>)

     Gibt für jedes Argument <x> das Argument selbst zurück.

     Beispiele:

     'identity' kann als eine Aussagefunktion genutzt werden, wenn die
     Argumente boolesche Werte sind.

          (%i1) every (identity, [true, true]);
          (%o1)                         true

 -- Funktion: integer_partitions (<n>)
 -- Funktion: integer_partitions (<n>, <len>)

     Ermittelt die Zerlegung einer ganzen Zahl <n> in ganze Zahlen, die
     <n> als Summe haben.

     'integer_partitions(<n>)' gibt eine Menge aller Zerlegungen der
     ganzen Zahl <n> zurück.  Jede Zerlegung ist eine Liste mit den
     ganzen Zahlen, die <n> als Summe haben.  Die Listen sind nach der
     Größe sortiert.

     'integer_partitions(<n>, <len>)' gibt eine Menge aller Zerlegungen
     der ganzen Zahl <n> zurück, deren Listen 'len' oder weniger
     Elemente haben.  Listen die weniger als 'len' Elemente haben,
     werden mit Nullen aufgefüllt.

     Siehe auch die Funktionen 'num_partitions' und
     'num_distinct_partitions'.

     Beispiele:

          (%i1) integer_partitions (3);
          (%o1)               {[1, 1, 1], [2, 1], [3]}
          (%i2) s: integer_partitions (25)$
          (%i3) cardinality (s);
          (%o3)                         1958
          (%i4) map (lambda ([x], apply ("+", x)), s);
          (%o4)                         {25}
          (%i5) integer_partitions (5, 3);
          (%o5) {[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]}
          (%i6) integer_partitions (5, 2);
          (%o6)               {[3, 2], [4, 1], [5, 0]}

     Um alle Zerlegungen zu finden, die eine Bedingung erfüllen, kann
     die Funktion 'subset' genutzt werden.  In diesem Beispiel werden
     alle Zerlegungen der Zahl 10 ermittelt, die nur Primzahlen
     enthalten.

          (%i1) s: integer_partitions (10)$
          (%i2) cardinality (s);
          (%o2)                          42
          (%i3) xprimep(x) := integerp(x) and (x > 1) and primep(x)$
          (%i4) subset (s, lambda ([x], every (xprimep, x)));
          (%o4) {[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]}

 -- Funktion: intersect (<a_1>, ..., <a_n>)

     'intersect' ist identisch mit der Funktion 'intersection'.

 -- Funktion: intersection (<a_1>, ..., <a_n>)

     Gibt die Schnittmenge der Mengen <a_1>, ..., <a_n> zurück.  Die
     Schnittmenge enthält die Elemente, die den Mengen gemeinsam sind.

     'intersection' gibt eine Fehlermeldung, wenn eines der Argumente
     keine Menge ist.

     Beispiele:

          (%i1) S_1 : {a, b, c, d};
          (%o1)                     {a, b, c, d}
          (%i2) S_2 : {d, e, f, g};
          (%o2)                     {d, e, f, g}
          (%i3) S_3 : {c, d, e, f};
          (%o3)                     {c, d, e, f}
          (%i4) S_4 : {u, v, w};
          (%o4)                       {u, v, w}
          (%i5) intersection (S_1, S_2);
          (%o5)                          {d}
          (%i6) intersection (S_2, S_3);
          (%o6)                       {d, e, f}
          (%i7) intersection (S_1, S_2, S_3);
          (%o7)                          {d}
          (%i8) intersection (S_1, S_2, S_3, S_4);
          (%o8)                          {}

 -- Funktion: kron_delta (<x_1>, <x_2>, ..., <x_p>)

     Ist die Kronecker-Delta-Funktion.

     'kron_delta' vereinfacht zu '1', wenn die Argumente <x_i> und <y_i>
     für alle Paare gleich sind, und zu '0', wenn <x_i> und <y_i> nicht
     gleich sind für irgendein Paar der Argumente.  Die Gleichheit wird
     festgestellt mit 'is(equal(xi,xj))' und die Ungleichheit mit
     'is(notequal(xi,xj))'.  Wird nur ein Argument angegeben,
     signalisiert die Funktion 'kron_delta' einen Fehler.

     Beispiele:

          (%i1) kron_delta(a,a);
          (%o1)                                  1
          (%i2) kron_delta(a,b,a,b);
          (%o2)                          kron_delta(a, b)
          (%i3) kron_delta(a,a,b,a+1);
          (%o3)                                  0
          (%i4) assume(equal(x,y));
          (%o4)                            [equal(x, y)]
          (%i5) kron_delta(x,y);
          (%o5)                                  1

 -- Funktion: listify (<a>)

     Ist das Argument <a> eine Menge, werden die Elemente der Menge als
     eine Liste zurückgegeben.  Ansonsten wird <a> zurückgegeben.

     Siehe die Funktion 'full_listify', um auch Mengen in Teilausdrücken
     von <a> durch Listen zu ersetzen.

     Beispiele:

          (%i1) listify ({a, b, c, d});
          (%o1)                     [a, b, c, d]
          (%i2) listify (F ({a, b, c, d}));
          (%o2)                    F({a, b, c, d})

 -- Funktion: lreduce (<F>, <s>)
 -- Funktion: lreduce (<F>, <s>, <s_0>)

     Wendet eine Funktion <F>, die zwei Argumente hat, auf die Elemente
     einer Liste <s> an, indem die Funktionsaufrufe verkettet werden.

     Das Kommando 'lreduce(<F>, <s>)' bildet den Ausdruck 'F(...
     F(F(s_1, s_2), s_3), ... s_n)'.  Ist das optionale Argument <s_0>
     vorhanden, dann ist das Ergebnis äquivalent zu 'lreduce(<F>,
     cons(<s_0>, <s>))'.

     Siehe auch 'rreduce', 'xreduce' und 'tree_reduce'.

     Beispiele:

     'lreduce' ohne das optionale Argument.

          (%i1) lreduce (f, [1, 2, 3]);
          (%o1)                     f(f(1, 2), 3)
          (%i2) lreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(f(f(1, 2), 3), 4)

     'lreduce' mit dem optionalen Argument.

          (%i1) lreduce (f, [1, 2, 3], 4);
          (%o1)                  f(f(f(4, 1), 2), 3)

     'lreduce' mit den binären Operatoren der Exponentiation "^" und der
     Division "/".

          (%i1) lreduce ("^", args ({a, b, c, d}));
                                         b c d
          (%o1)                       ((a ) )
          (%i2) lreduce ("/", args ({a, b, c, d}));
                                          a
          (%o2)                         -----
                                        b c d

 -- Funktion: makeset (<expr>, <x>, <s>)

     Generiert eine Menge, indem der Ausdruck <expr> ausgewertet wird,
     wobei das Argument <x> eine Liste mit Variablen des Ausdrucks und
     <s> eine Menge oder eine Liste mit Listen ist.  Ein Element der
     Menge wird generiert, indem die Variablen in <x> nacheinander an
     die Elemente in <s> gebunden werden.

     Jedes Element des Argumentes <s> muss dieselbe Länge wie <x> haben.
     Die Liste der Variablen <x> muss eine List mit Symbolen sein.
     Indizierte Variablen sind nicht möglich.  Auch wenn nur eine
     Variable angegeben wird, muss diese Element einer Liste sein und
     jedes Element von <s> muss eine Liste mit einem Element sein.

     Siehe auch die Funktion 'makelist', um eine Liste zu generieren.

     Beispiele:

          (%i1) makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
                                     1  2  3  4
          (%o1)                     {-, -, -, -}
                                     a  b  c  d
          (%i2) S : {x, y, z}$
          (%i3) S3 : cartesian_product (S, S, S);
          (%o3) {[x, x, x], [x, x, y], [x, x, z], [x, y, x], [x, y, y],
          [x, y, z], [x, z, x], [x, z, y], [x, z, z], [y, x, x],
          [y, x, y], [y, x, z], [y, y, x], [y, y, y], [y, y, z],
          [y, z, x], [y, z, y], [y, z, z], [z, x, x], [z, x, y],
          [z, x, z], [z, y, x], [z, y, y], [z, y, z], [z, z, x],
          [z, z, y], [z, z, z]}
          (%i4) makeset (i + j + k, [i, j, k], S3);
          (%o4) {3 x, 3 y, y + 2 x, 2 y + x, 3 z, z + 2 x, z + y + x,
                                                 z + 2 y, 2 z + x, 2 z + y}
          (%i5) makeset (sin(x), [x], {[1], [2], [3]});
          (%o5)               {sin(1), sin(2), sin(3)}

 -- Funktion: moebius (<n>)

     Ist die Möbiusfunktion.

     Ist die natürliche Zahl <n> quadratfrei, dann vereinfacht die
     Möbiusfunktion zu '-1^k', wobei <k> die Anzahl der Primfaktoren der
     Zahl <n> ist.  Eine Zahl ist quadratfrei, wenn sie nur voneinander
     verschiedene Primfaktoren hat.  Für '<n> = 1' vereinfacht die
     Möbiusfunktion zu '1' und für alle anderen positiven ganzen Zahlen
     zum Wert '0'.  Für andere Argumente wird eine Substantivform als
     Ergebnis zurückgegeben.

     Ist das Argument der Funktion 'moebius' eine Liste, Menge, Matrix
     oder eine Gleichung, wird die Funktion auf die Elemente oder beide
     Seiten der Gleichung angewendet.

     Beispiele:

          (%i1) moebius (1);
          (%o1)                           1
          (%i2) moebius (2 * 3 * 5);
          (%o2)                          - 1
          (%i3) moebius (11 * 17 * 29 * 31);
          (%o3)                           1
          (%i4) moebius (2^32);
          (%o4)                           0
          (%i5) moebius (n);
          (%o5)                      moebius(n)
          (%i6) moebius (n = 12);
          (%o6)                    moebius(n) = 0
          (%i7) moebius ([11, 11 * 13, 11 * 13 * 15]);
          (%o7)                      [- 1, 1, 1]
          (%i8) moebius (matrix ([11, 12], [13, 14]));
                                     [ - 1  0 ]
          (%o8)                      [        ]
                                     [ - 1  1 ]
          (%i9) moebius ({21, 22, 23, 24});
          (%o9)                      {- 1, 0, 1}

 -- Funktion: multinomial_coeff (<a_1>, ..., <a_n>)
 -- Funktion: multinomial_coeff ()

     Gibt den Multinomialkoeffizienten zurück.  Im Spezialfall '<k> = 2'
     ergibt sich die Binomialverteilung.  Siehe 'binomial'.

     Enthält das Ergebnis Fakultäten, kann das Ergebnis möglicherweise
     mit der Funktion 'minfactorial' weiter vereinfacht werden.

     Beispiele:

          (%i1) multinomial_coeff (1, 2, x);
                                      (x + 3)!
          (%o1)                       --------
                                        2 x!
          (%i2) minfactorial (%);
                               (x + 1) (x + 2) (x + 3)
          (%o2)                -----------------------
                                          2
          (%i3) multinomial_coeff (-6, 2);
                                       (- 4)!
          (%o3)                       --------
                                      2 (- 6)!
          (%i4) minfactorial (%);
          (%o4)                          10

 -- Funktion: num_distinct_partitions (<n>)
 -- Funktion: num_distinct_partitions (<n>, list)

     Gibt die Anzahl der Möglichkeiten an, eine natürliche Zahl <n> in
     Summanden zu zerlegen, wobei jeder Summand nur einmal vorkommt.
     Ist <n> keine natürliche Zahl wird eine Substantivform als Ergebnis
     zurückgegeben.

     'num_distinct_partitions(<n>, list)' gibt eine Liste mit der Anzahl
     der voneinander verschiedenen Partitionen der natürlichen Zahlen 1,
     2, 3, ..., <n> zurück.

     Siehe auch die Funktionen 'num_partitions' und
     'integer_partitions'.

     Beispiele:

          (%i1) num_distinct_partitions (12);
          (%o1)                          15
          (%i2) num_distinct_partitions (12, list);
          (%o2)      [1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 12, 15]
          (%i3) num_distinct_partitions (n);
          (%o3)              num_distinct_partitions(n)

 -- Funktion: num_partitions (<n>)
 -- Funktion: num_partitions (<n>, list)

     Gibt die Anzahl der Möglichkeiten an, eine natürliche Zahl <n> in
     Summanden zu zerlegen.  Ist <n> keine natürliche Zahl wird eine
     Substantivform als Ergebnis zurückgegeben.

     'num_partitions(<n>, list)' gibt eine Liste mit der Anzahl der
     Partitionen der natürlichen Zahlen 1, 2, 3, ..., <n> zurück.

     Das Kommando 'num_partitions(<n>)' ist für eine natürliche Zahl <n>
     äquivalent zu 'cardinality(integer_partitions(<n>))'.  Da die
     Funktion 'num_partitions' die Menge nicht konstruiert, ist diese
     Funktion deutlich schneller.

     Siehe auch die Funktionen 'num_distinct_partitions' und
     'integer_partitions'.

     Beispiele:

          (%i1) num_partitions (5) = cardinality (integer_partitions (5));
          (%o1)                         7 = 7
          (%i2) num_partitions (8, list);
          (%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
          (%i3) num_partitions (n);
          (%o3)                   num_partitions(n)

 -- Funktion: partition_set (<a>, <f>)

     Zerlegt eine Menge <a> mit der Aussagefunktion <f>.

     'partition_set' gibt eine Liste mit zwei Elementen zurück.  Das
     erste Element ist die Menge der Elemente, für die die
     Aussagefunktion <f> zu 'false' ausgewertet wird.  Das zweite
     Element ist die Menge aller anderen Elemente.  'partition_set'
     wendet nicht die Funktion 'is' auf das Ergebnis der Aussagefunktion
     <f> an.

     'partition_set' gibt eine Fehlermeldung, wenn <a> keine Menge ist.

     Siehe auch die Funktion 'subset'.

     Beispiele:

          (%i1) partition_set ({2, 7, 1, 8, 2, 8}, evenp);
          (%o1)                   [{1, 7}, {2, 8}]
          (%i2) partition_set ({x, rat(y), rat(y) + z, 1},
                               lambda ([x], ratp(x)));
          (%o2)/R/              [{1, x}, {y, y + z}]

 -- Funktion: permutations (<a>)

     Gibt eine Menge mit allen voneinander verschiedenen Permutationen
     der Elemente der Liste oder Menge <a> zurück.  Die Permutationen
     sind Listen.

     Ist das Argument <a> eine Liste, werden auch doppelte Elemente in
     die möglichen Permutationen eingeschlossen.

     'permutations' gibt eine Fehlermeldung, wenn <a> keine Liste oder
     Menge ist.

     Siehe auch die Funktion 'random_permutation'.

     Beispiele:

          (%i1) permutations ([a, a]);
          (%o1)                       {[a, a]}
          (%i2) permutations ([a, a, b]);
          (%o2)           {[a, a, b], [a, b, a], [b, a, a]}

 -- Funktion: powerset (<a>)
 -- Funktion: powerset (<a>, <n>)

     Gibt die Menge aller Teilmengen der Menge <a> oder eine Teilmenge
     dieser Menge zurück.

     'powerset(<a>)' gibt die Menge aller Teilmengen der Menge <a>
     zurück.  Die Ergebnismenge hat '2^cardinality(<a>)' Elemente.

     'powerset(<a>, <n>)' gibt die Menge aller Teilmengen der Menge <a>
     zurück, die die Mächtigkeit <n> haben.

     'powerset' gibt eine Fehlermeldung, wenn <a> keine Menge oder <n>
     keine natürliche Zahl ist.

     Beispiele:

          (%i1) powerset ({a, b, c});
          (%o1) {{}, {a}, {a, b}, {a, b, c}, {a, c}, {b}, {b, c}, {c}}
          (%i2) powerset ({w, x, y, z}, 4);
          (%o2)                    {{w, x, y, z}}
          (%i3) powerset ({w, x, y, z}, 3);
          (%o3)     {{w, x, y}, {w, x, z}, {w, y, z}, {x, y, z}}
          (%i4) powerset ({w, x, y, z}, 2);
          (%o4)   {{w, x}, {w, y}, {w, z}, {x, y}, {x, z}, {y, z}}
          (%i5) powerset ({w, x, y, z}, 1);
          (%o5)                 {{w}, {x}, {y}, {z}}
          (%i6) powerset ({w, x, y, z}, 0);
          (%o6)                         {{}}

 -- Funktion: random_permutation (<a>)

     Gibt eine zufällige Permutation der Menge oder Liste <a> zurück,
     die mit dem Knuth-Misch-Algorithmus generiert wird.

     Die Rückgabe ist eine neue Liste, die verschieden vom Argument <a>.
     Jedoch werden nicht die Elemente kopiert.

     Beispiele:

          (%i1) random_permutation ([a, b, c, 1, 2, 3]);
          (%o1)                  [c, 1, 2, 3, a, b]
          (%i2) random_permutation ([a, b, c, 1, 2, 3]);
          (%o2)                  [b, 3, 1, c, a, 2]
          (%i3) random_permutation ({x + 1, y + 2, z + 3});
          (%o3)                 [y + 2, z + 3, x + 1]
          (%i4) random_permutation ({x + 1, y + 2, z + 3});
          (%o4)                 [x + 1, y + 2, z + 3]

 -- Funktion: rreduce (<F>, <s>)
 -- Funktion: rreduce (<F>, <s>, <s_{n + 1}>)

     Wendet eine Funktion <F>, die zwei Argumente hat, auf die Elemente
     einer Liste <s> an, indem die Funktionsaufrufe verkettet werden.

     Das Kommando 'rreduce(<F>, <s>)' bildet den Ausdruck 'F(s_1, ...
     F(s_{n - 2}, F(s_{n - 1}, s_n)))'.  Ist das optionale Argument
     <s_0> vorhanden, dann ist das Ergebnis äquivalent zu 'rreduce(<F>,
     endcons(<s_{n + 1}>, <s>))'.

     Siehe auch 'lreduce', 'xreduce' und 'tree_reduce'.

     Beispiele:

     'rreduce' ohne das optionale Argument.

          (%i1) rreduce (f, [1, 2, 3]);
          (%o1)                     f(1, f(2, 3))
          (%i2) rreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(1, f(2, f(3, 4)))

     'rreduce' mit dem optionalen Argument.

          (%i1) rreduce (f, [1, 2, 3], 4);
          (%o1)                  f(1, f(2, f(3, 4)))

     'rreduce' mit den binären Operatoren der Exponentiation "^" und der
     Division "/".

          (%i1) rreduce ("^", args ({a, b, c, d}));
                                           d
                                          c
                                         b
          (%o1)                         a
          (%i2) rreduce ("/", args ({a, b, c, d}));
                                         a c
          (%o2)                          ---
                                         b d

 -- Funktion: setdifference (<a>, <b>)

     Gibt eine Menge mit den Elementen zurück, die in der Menge <a>,
     aber nicht in der Menge <b> enthalten sind.

     'setdifference' gibt eine Fehlermeldung, wenn die Argumente <a>
     oder <b> keine Mengen sind.

     Beispiele:

          (%i1) S_1 : {a, b, c, x, y, z};
          (%o1)                  {a, b, c, x, y, z}
          (%i2) S_2 : {aa, bb, c, x, y, zz};
          (%o2)                 {aa, bb, c, x, y, zz}
          (%i3) setdifference (S_1, S_2);
          (%o3)                       {a, b, z}
          (%i4) setdifference (S_2, S_1);
          (%o4)                     {aa, bb, zz}
          (%i5) setdifference (S_1, S_1);
          (%o5)                          {}
          (%i6) setdifference (S_1, {});
          (%o6)                  {a, b, c, x, y, z}
          (%i7) setdifference ({}, S_1);
          (%o7)                          {}

 -- Funktion: setequalp (<a>, <b>)

     Gibt das Ergebnis 'true' zurück, wenn die Mengen <a> und <b>
     dieselbe Anzahl an Elementen haben und der Ausdruck 'is(<x> = <y>)'
     das Ergebnis 'true' für alle Elemente <x> der Menge <a> und <y> der
     Menge <b> hat.  Dabei haben die Elemente eine Ordnung wie sie von
     der Funktion 'listify' generiert wird.  Ansonsten ist das Ergebnis
     'false'.

     Beispiele:

          (%i1) setequalp ({1, 2, 3}, {1, 2, 3});
          (%o1)                         true
          (%i2) setequalp ({a, b, c}, {1, 2, 3});
          (%o2)                         false
          (%i3) setequalp ({x^2 - y^2}, {(x + y) * (x - y)});
          (%o3)                         false

 -- Funktion: setify (<a>)

     Konstruiert eine Menge aus den Elementen der Liste <a>.  Doppelte
     Elemente der Liste <a> werden entfernt und die Elemente werden mit
     der Aussagefunktion 'orderlessp' sortiert.

     'setify' gibt eine Fehlermeldung, wenn <a> keine Liste ist.

     Beispiele:

          (%i1) setify ([1, 2, 3, a, b, c]);
          (%o1)                  {1, 2, 3, a, b, c}
          (%i2) setify ([a, b, c, a, b, c]);
          (%o2)                       {a, b, c}
          (%i3) setify ([7, 13, 11, 1, 3, 9, 5]);
          (%o3)                {1, 3, 5, 7, 9, 11, 13}

 -- Funktion: setp (<a>)

     Gibt das Ergebnis 'true' zurück, wenn das Argument <a> eine Menge
     ist.

     'setp' gibt 'true' auch für Mengen zurück, die noch nicht
     vereinfacht sind, also möglicherweise doppelte Elemente enthalten.

     'setp' ist äquivalent zu dem Kommando 'setp(a) := not atom(a) and
     op(a) = 'set'.

     Beispiele:

          (%i1) simp : false;
          (%o1)                         false
          (%i2) {a, a, a};
          (%o2)                       {a, a, a}
          (%i3) setp (%);
          (%o3)                         true

 -- Funktion: set_partitions (<a>)
 -- Funktion: set_partitions (<a>, <n>)

     Gibt die Menge aller Partitionen der Menge <a> oder eine Teilmenge
     dieser Menge zurück.

     'set_partitions(<a>, <n>)' gibt eine Menge aller Zerlegungen der
     Menge <a> in <n> nicht-leere voneinander disjunkte Teilmengen
     zurück.

     'set_partitions(<a>)' gibt die Menge aller Zerlegungen zurück.

     'stirling2' gibt die Mächtigkeit einer Menge zurück, die alle
     Zerlegungen einer Menge enthält.

     Eine Menge mit Zerlegungen P ist eine Zerlegung der Menge S, wenn

       1. jedes Elemente der Menge P eine nicht-leere Menge ist,
       2. verschiedene Elemente der Menge P voneinander disjunkt sind,
       3. die Vereinigung von Elementen der Menge P gleich der Menge S
          ist.

     Beispiele:

     Die leere Menge ist eine Zerlegung von sich selbst.

          (%i1) set_partitions ({});
          (%o1)                         {{}}

     Die Mächtigkeit der Menge der Zerlegungen einer Menge kann mit der
     Funktion 'stirling2' ermittelt werden.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) cardinality(p) = stirling2 (6, 3);
          (%o3)                        90 = 90

     Jedes Element der Menge 'p' hat 3 Elemente.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) map (cardinality, p);
          (%o3)                          {3}

     Für jedes Element der Menge 'p', ist die Vereinigung ihrer Elemente
     gleich der Menge 's'.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) map (lambda ([x], apply (union, listify (x))), p);
          (%o3)                 {{0, 1, 2, 3, 4, 5}}

 -- Funktion: some (<f>, <a>)
 -- Funktion: some (<f>, <L_1>, ..., <L_n>)

     Gibt das Ergebnis 'true' zurück, wenn die Aussage <f> das Ergebnis
     'true' für eines oder mehrere Argumente hat.

     Ist eine Menge <a> als Argument gegeben, gibt 'some(<f>, <s>)' das
     Ergebnis 'true' zurück, wenn 'is(<f>(<a_i>))' das Ergebnis 'true'
     für eines oder mehrere Elemente <a_i> der Menge <a> hat.  'some'
     wertet <f> nicht notwendigerweise für alle Elemente <a_i> aus, wenn
     das Ergebnis bereits feststeht.  Da Mengen nicht geordnet sind,
     kann die Funktion 'some' die Ausdrücke '<f>(<a_i>)' in irgendeiner
     Reihenfolge auswerten.

     Sind die Argumente eine oder mehrere Listen, dann gibt 'some(<f>,
     <L_1>, ..., <L_n>)' den Wert 'true' zurück, wenn 'is(<f>(<x_1>,
     ..., <x_n>))' das Ergebnis 'true' für eines oder mehrere Elemente
     <x_1>, ..., <x_n> der Listen <L_1>, ..., <L_n> hat.  'some' wertet
     <f> wird nicht notwendigerweise für alle Kombinationen <x_1>, ...,
     <x_n> aus, wenn das Ergebnis bereits feststeht.  'some' wertet die
     Listen in der Reihenfolge des steigenden Index aus.

     Ist die leere Menge '{}' oder die leere Liste '[]' unter den
     Argumenten, ist das Ergebnis immer 'false'.

     Hat die Optionsvariable 'maperror' den Wert 'true', müssen alle
     Listen <L_1>, ..., <L_n> die gleiche Länge haben.  Hat die
     Optionsvariable 'maperror' den Wert 'false', werden Listen auf die
     Länge der kürzesten Liste abgeschnitten.

     Kann die Aussagefunktion <f> von der Funktion 'is' nicht zu 'true'
     oder 'false' ausgewertet werden, hängt das Ergebnis von der
     Optionsvariablen 'prederror' ab.  Hat die Optionsvariable
     'prederror' den Wert 'true', werden solche Werte als 'false'
     behandelt.  Hat 'prederror' den Wert 'false', werden solche Werte
     als 'unknown' behandelt.

     Beispiele:

     'some' für eine Menge als Argument.  Die Aussage ist eine Funktion
     mit einem Argument.

          (%i1) some (integerp, {1, 2, 3, 4, 5, 6});
          (%o1)                         true
          (%i2) some (atom, {1, 2, sin(3), 4, 5 + y, 6});
          (%o2)                         true

     'some' angewendet auf zwei Listen.  Die Aussage ist eine Funktion
     mit zwei Argumenten.

          (%i1) some ("=", [a, b, c], [a, b, c]);
          (%o1)                         true
          (%i2) some ("#", [a, b, c], [a, b, c]);
          (%o2)                         false

     Ergebnisse der Aussage <f>, die zu einem Ergebnis verschieden von
     'true' oder 'false' auswerten, werden von der Optionsvariablen
     'prederror' kontrolliert.

          (%i1) prederror : false;
          (%o1)                         false
          (%i2) map (lambda ([a, b], is (a < b)), [x, y, z],
                     [x^2, y^2, z^2]);
          (%o2)              [unknown, unknown, unknown]
          (%i3) some ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o3)                        unknown
          (%i4) some ("<", [x, y, z], [x^2, y^2, z + 1]);
          (%o4)                         true
          (%i5) prederror : true;
          (%o5)                         true
          (%i6) some ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o6)                         false
          (%i7) some ("<", [x, y, z], [x^2, y^2, z + 1]);
          (%o7)                         true

 -- Funktion: stirling1 (<n>, <m>)

     Berechnet Stirling-Zahlen der ersten Art.

     Sind die Argumente <n> und <m> natürliche Zahlen, ist der Wert von
     'stirling1(<n>, <m>)' die Anzahl der Permutationen einer Menge mit
     <n> Elementen, die <m> Zyklen hat.  Für Details siehe Graham, Knuth
     und Patashnik in Conrecte Mathematics.  Maxima nutzt eine
     Rekursion, um 'stirling1(<n>, <m>)' für <m> kleiner als '0' zu
     berechnen.  Die Funktion ist nicht definiert für 'n' kleiner als
     '0' und für Argumente die keine ganze Zahlen sind.

     'stirling1' ist eine vereinfachende Funktion.  Maxima kennt die
     folgenden Beziehungen (siehe [1]).

        * 'stirling1(0, n) = kron_delta(0, n)'
        * 'stirling1(n, n) = 1'
        * 'stirling1(n, n - 1) = binomial(n, 2)'
        * 'stirling1(n + 1, 0) = 0'
        * 'stirling1(n + 1, 1) = n!'
        * 'stirling1(n + 1, 2) = 2^n - 1'

     Diese Beziehungen werden angewendet, wenn die Argumente ganze
     Zahlen oder Symbole sind, die als ganze Zahlen deklariert sind, und
     das erste Argument keine negative Zahl ist.  'stirling1'
     vereinfacht nicht für Argumente, die keine ganzen Zahlen sind.

     Referenz:

     [1] Donald Knuth, The Art of Computer Programming, third edition,
     Volume 1, Section 1.2.6, Equations 48, 49, and 50.

     Beispiele:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n, n);
          (%o3)                           1

     'stirling1' vereinfacht nicht für Argumente, die keine ganzen
     Zahlen sind.

          (%i1) stirling1 (sqrt(2), sqrt(2));
          (%o1)              stirling1(sqrt(2), sqrt(2))

     Maxima kennt Vereinfachungen der Funktion 'stirling1'.

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n + 1, n);
                                      n (n + 1)
          (%o3)                       ---------
                                          2
          (%i4) stirling1 (n + 1, 1);
          (%o4)                          n!

 -- Funktion: stirling2 (<n>, <m>)

     Berechnet Stirling-Zahlen der zweiten Art.

     Sind die Argumente <n> und <m> natürliche Zahlen, ist der Wert von
     'stirling2(<n>, <m>)' die Anzahl der Möglichkeiten, mit der eine
     Menge der Mächtigkeit <n> in <m> disjunkte Mengen zerlegt werden
     kann.  Maxima nutzt eine Rekursion, um 'stirling2(<n>, <m>)' für
     <m> kleiner als '0' zu berechnen.  Die Funktion ist nicht definiert
     für 'n' kleiner als '0' und für Argumente, die keine ganze Zahlen
     sind.

     'stirling2' ist eine vereinfachende Funktion.  Maxima kennt die
     folgenden Beziehungen (siehe [1], [2], [3]).

        * 'stirling2(0, n) = kron_delta(0, n)'
        * 'stirling2(n, n) = 1'
        * 'stirling2(n, n - 1) = binomial(n, 2)'
        * 'stirling2(n + 1, 1) = 1'
        * 'stirling2(n + 1, 2) = 2^n - 1'
        * 'stirling2(n, 0) = kron_delta(n, 0)'
        * 'stirling2(n, m) = 0' für 'm > n'
        * 'stirling2(n, m) = sum((-1)^(m - k) binomial(m k) k^n,i,1,m) /
          m!', wenn m und n ganze Zahlen und n eine natürliche Zahl ist.

     Diese Beziehungen werden angewendet, wenn die Argumente ganze
     Zahlen oder Symbole sind, die als ganze Zahlen deklariert sind, und
     das erste Argument keine negative Zahl ist.  'stirling2'
     vereinfacht nicht für Argumente, die keine ganzen Zahlen sind.

     Referenzen:

     [1] Donald Knuth.  The Art of Computer Programming, third edition,
     Volume 1, Section 1.2.6, Equations 48, 49, and 50.

     [2] Graham, Knuth, and Patashnik.  Concrete Mathematics, Table 264.

     [3] Abramowitz and Stegun.  Handbook of Mathematical Functions,
     Section 24.1.4.

     Beispiele:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n, n);
          (%o3)                           1

     'stirling2' vereinfacht nicht, wenn die Argumente keine ganze
     Zahlen sind.

          (%i1) stirling2 (%pi, %pi);
          (%o1)                  stirling2(%pi, %pi)

     Maxima kennt Vereinfachungen der Funktion 'stirling2'.

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n + 9, n + 8);
                                   (n + 8) (n + 9)
          (%o3)                    ---------------
                                          2
          (%i4) stirling2 (n + 1, 2);
                                        n
          (%o4)                        2  - 1

 -- Funktion: subset (<a>, <f>)

     Gibt eine Teilmenge der Menge <a> zurück, deren Elemente der
     Bedingung <f> genügen.

     'subset' gibt eine Menge zurück, die alle Elemente der Menge <a>
     enthält, die für die Bedingung <f> ein von 'false' verschiedenes
     Ergebnis haben.  'subset' wendet nicht die Funktion 'is' auf das
     Ergebnis der Bedingung 'f' an.

     'subset' gibt eine Fehlermeldung, wenn das Argument <a> keine Menge
     ist.

     Siehe auch die Funktion 'partition_set'.

     Beispiele:

          (%i1) subset ({1, 2, x, x + y, z, x + y + z}, atom);
          (%o1)                     {1, 2, x, z}
          (%i2) subset ({1, 2, 7, 8, 9, 14}, evenp);
          (%o2)                      {2, 8, 14}

 -- Funktion: subsetp (<a>, <b>)

     Gibt das Ergebnis 'true' zurück, wenn die Menge <a> einer Teilmenge
     der Menge <b> ist.

     'subsetp' gibt eine Fehlermeldung, wenn eines der Argumente keine
     Menge ist.

     Beispiele:

          (%i1) subsetp ({1, 2, 3}, {a, 1, b, 2, c, 3});
          (%o1)                         true
          (%i2) subsetp ({a, 1, b, 2, c, 3}, {1, 2, 3});
          (%o2)                         false

 -- Funktion: symmdifference (<a_1>, ..., <a_n>)

     Gibt die symmetrische Differenz der Mengen '<a_1>, ..., <a_n>'
     zurück.  Für zwei Argumente ist die symmetrische Differenz
     äquivalent zu 'union(setdifference(<a>, <b>), setdifference(<b>,
     <a>))'.

     'symmdifference' gibt eine Fehlermeldung, wenn eines der Argumente
     keine Menge ist.

     Beispiele:

          (%i1) S_1 : {a, b, c};
          (%o1)                       {a, b, c}
          (%i2) S_2 : {1, b, c};
          (%o2)                       {1, b, c}
          (%i3) S_3 : {a, b, z};
          (%o3)                       {a, b, z}
          (%i4) symmdifference ();
          (%o4)                          {}
          (%i5) symmdifference (S_1);
          (%o5)                       {a, b, c}
          (%i6) symmdifference (S_1, S_2);
          (%o6)                        {1, a}
          (%i7) symmdifference (S_1, S_2, S_3);
          (%o7)                        {1, b, z}
          (%i8) symmdifference ({}, S_1, S_2, S_3);
          (%o8)                        {1,b, z}

 -- Funktion: tree_reduce (<F>, <s>)
 -- Funktion: tree_reduce (<F>, <s>, <s_0>)

     Wendet eine Funktion <F>, die zwei Argumente hat, auf die Elemente
     einer Liste oder Menge <s> an, indem die Funktionsaufrufe verkettet
     werden.

     'tree_reduce' führt folgende Operationen aus: Die Funktion <F> wird
     auf Paare von Elementen der Liste <s> angewendet, wodurch die neue
     Liste '[<F>(<s_1>, <s_2>), <F>(<s_3>, <s_4>), ...]' entsteht.  Hat
     die Liste eine ungerade Anzahl an Elementen, bleibt das letzte
     Element unverändert.  Dann wird das Verfahren solange wiederholt,
     bis nur noch ein einziges Element übrig ist.  Dieses wird als
     Ergebnis zurückgegeben.

     Ist das optionale Argument <s_0> vorhanden, dann ist das Ergebnis
     äquivalent zu 'tree_reduce(<F>, cons(<s_0>, <s>)'.

     Werden Gleitkommazahlen addiert, dann kann 'tree_reduce' ein
     Ergebnis mit einem kleineren Rundungsfehler als 'lreduce' oder
     'rreduce' liefern.

     Siehe auch 'lreduce', 'rreduce' und 'xreduce'.

     Beispiele:

     'tree_reduce' angewendet auf eine Liste mit einer geraden Anzahl an
     Elementen.

          (%i1) tree_reduce (f, [a, b, c, d]);
          (%o1)                  f(f(a, b), f(c, d))

     'tree_reduce' angewendet auf eine List mit einer ungeraden Anzahl
     an Elementen.

          (%i1) tree_reduce (f, [a, b, c, d, e]);
          (%o1)               f(f(f(a, b), f(c, d)), e)

 -- Funktion: union (<a_1>, ..., <a_n>)

     Gibt die Vereinigung der Mengen <a_1>, ..., <a_n> zurück.  Wird
     'union' ohne ein Argument aufgerufen, wird die leere Menge
     zurückgegeben.

     'union' gibt eine Fehlermeldung, wenn eines der Argumente keine
     Menge ist.

     Beispiele:

          (%i1) S_1 : {a, b, c + d, %e};
          (%o1)                   {%e, a, b, d + c}
          (%i2) S_2 : {%pi, %i, %e, c + d};
          (%o2)                 {%e, %i, %pi, d + c}
          (%i3) S_3 : {17, 29, 1729, %pi, %i};
          (%o3)                {17, 29, 1729, %i, %pi}
          (%i4) union ();
          (%o4)                          {}
          (%i5) union (S_1);
          (%o5)                   {%e, a, b, d + c}
          (%i6) union (S_1, S_2);
          (%o6)              {%e, %i, %pi, a, b, d + c}
          (%i7) union (S_1, S_2, S_3);
          (%o7)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}
          (%i8) union ({}, S_1, S_2, S_3);
          (%o8)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}

 -- Funktion: xreduce (<F>, <s>)
 -- Funktion: xreduce (<F>, <s>, <s_0>)

     Wendet eine Funktion <F>, die zwei Argumente hat, auf die Elemente
     einer Liste oder Menge <s> an, indem die Funktionsaufrufe verkettet
     werden.  Ist die Funktion eine N-ary-Funktion wird die Funktion <F>
     auf die Liste angewendet.  Ist die Funktion <F> keine
     N-ary_Funktion ist 'xreduce' äquivalent zu 'lreduce'.

     Folgende N-ary-Funktionen und Operatoren kennt 'xreduce': Addition
     '"+"', Multiplikation '"*"', 'and', 'or', 'max', 'min' und
     'append'.  Funktionen und Operatoren können mit der Funktion
     'declare' als 'nary' deklariert werden.  Für diese Funktionen ist
     'xreduce' schneller als 'lreduce' oder 'rreduce'.

     Ist das optionale Argument <s_0> vorhanden, dann ist das Ergebnis
     äquivalent zu 'xreduce(<s>, cons(<s_0>, <s>))'.

     Siehe auch 'lreduce', 'rreduce' und 'tree_reduce'.

     Beispiele:

     'xreduce' angewendet mit einer N-ary-Funktion.  'F' wird einmal mit
     allen Argumenten aufgerufen.

          (%i1) declare (F, nary);
          (%o1)                         done
          (%i2) F ([L]) := L;
          (%o2)                      F([L]) := L
          (%i3) xreduce (F, [a, b, c, d, e]);
          (%o3)         [[[[[("[", simp), a], b], c], d], e]

     'xreduce' angewendet mit einer Funktion, die nicht die Eigenschaft
     'nary' hat.

          (%i1) G ([L]) := L;
          (%o1)                      G([L]) := L
          (%i2) xreduce (G, [a, b, c, d, e]);
          (%o2)         [[[[[("[", simp), a], b], c], d], e]
          (%i3) lreduce (G, [a, b, c, d, e]);
          (%o3)                 [[[[a, b], c], d], e]


File: maxima.info,  Node: Summen Produkte und Reihen,  Next: Analysis,  Prev: Mengen,  Up: Top

15 Summen, Produkte und Reihen
******************************

* Menu:

* Summen und Produkte::
* Einführung in Reihen::
* Funktionen und Variablen für Reihen::
* Poisson Reihen::
* Kettenbrüche::


File: maxima.info,  Node: Summen und Produkte,  Next: Einführung in Reihen,  Prev: Summen Produkte und Reihen,  Up: Summen Produkte und Reihen

15.1 Summen und Produkte
========================

 -- Funktion: bashindices (<expr>)

     Transformiert einen Ausdruck <expr>, der mehrere Summen oder
     Produkte enthält so, dass alle Summen und Produkte einen
     unterschiedlichen Index haben.  Dies erleichtert zum Beispiel
     Substitutionen mit der Funktion 'changevar'.  Die neuen Indizes
     werden mit 'j<nummer>' bezeichnet, wobei die Zahl <nummer> der Wert
     der Optionsvariablen 'gensumnum' ist.

     Beispiel:

          (%i1) sum(1/k^2,k,0,inf)+sum(1/k,k,0,inf);
                                 inf       inf
                                 ====      ====
                                 \     1   \     1
          (%o1)                   >    - +  >    --
                                 /     k   /      2
                                 ====      ====  k
                                 k = 0     k = 0
          (%i2) bashindices(%);
                               inf         inf
                               ====        ====
                               \      1    \       1
          (%o2)                 >     -- +  >     ---
                               /      j2   /        2
                               ====        ====   j1
                               j2 = 0      j1 = 0

 -- Optionsvariable: cauchysum
     Standardwert: 'false'

     Werden zwei Reihen miteinander multipliziert und die
     Optionsvariablen 'sumexpand' sowie 'cauchysum' haben beide den Wert
     'true', dann wird die Cauchy-Produktformel angewendet.

     Beispiele:

          (%i1) sumexpand: false$
          (%i2) cauchysum: false$
          (%i3) s: sum (f(i), i, 0, inf) * sum (g(j), j, 0, inf);
                                inf         inf
                                ====        ====
                                \           \
          (%o3)                ( >    f(i))  >    g(j)
                                /           /
                                ====        ====
                                i = 0       j = 0
          (%i4) sumexpand: true$
          (%i5) cauchysum: true$
          (%i6) ''s;
                           inf     i1
                           ====   ====
                           \      \
          (%o6)             >      >     g(i1 - i2) f(i2)
                           /      /
                           ====   ====
                           i1 = 0 i2 = 0

 -- Optionsvariable: genindex
     Standardwert: 'i'

     'genindex' enthält das Zeichen für den Präfix, der verwendet wird,
     um einen neuen Index für eine Summe oder ein Produkt zu generieren.
     Siehe auch 'gensumnum'.

 -- Optionsvariable: gensumnum
     Standardwert: 0

     'gensumnum' enthält die Nummer, die an den Präfix 'genindex'
     angehängt wird, um den nächsten Index für eine Summe oder ein
     Produkt zu generieren.  Hat 'gensumnum' den Wert 'false', wird der
     Index nur aus dem Zeichen 'genindex' gebildet.  Siehe auch
     'genindex'.

 -- Funktion: intosum (<expr>)

     Multipliziert Faktoren in eine Summe herein.  Tritt der Index der
     Summe als ein Faktor außerhalb der Summe auf, wird von der Funktion
     'intosum' ein neuer Index gebildet.  Summen haben die Eigenschaft
     'outative', so dass Faktoren bei der Vereinfachung aus der Summe
     herausgezogen werden.  Mit der Funktion 'intosum' wird diese
     Vereinfachung rückgängig gemacht.

     Beispiel:

          (%i1) sum(2*x^2*n^k, k , 0, inf);
                                         inf
                                         ====
                                       2 \      k
          (%o1)                     2 x   >    n
                                         /
                                         ====
                                         k = 0
          (%i2) intosum(%);
                                    inf
                                    ====
                                    \        k  2
          (%o2)                      >    2 n  x
                                    /
                                    ====
                                    k = 0

 -- Funktion: lsum (<expr>, <i>, <L>)

     Bildet die Summe für den Ausdruck <expr> zum Index <i> für alle
     Elemente der Liste <L>.  Kann das Argument <L> nicht zu einer Liste
     ausgewertet werden, wird eine Substantivform zurückgegeben.  Siehe
     auch 'sum'.

     Beispiele:

          (%i1) lsum (x^i, i, [1, 2, 7]);
                                      7    2
          (%o1)                      x  + x  + x
          (%i2) lsum (i^2, i, rootsof (x^3 - 1, x));
                               ====
                               \      2
          (%o2)                 >    i
                               /
                               ====
                                             3
                               i in rootsof(x  - 1, x)

 -- Funktion: niceindices (<expr>)

     Gibt den Indizes von Summen und Produkten im Ausdruck <expr> einen
     neuen Namen.  'niceindices' benennt die Indizes nacheinander mit
     den Namen, die in der Liste der Optionsvariablen 'niceindicespref'
     enthalten sind.  Die Standardnamen sind '[i, j, k, l, m, n]'.  Sind
     nicht genügend Namen in der Liste vorhanden, werden weitere Indizes
     durch das Anhängen einer Nummer gebildet.

     'niceindices' wertet das Argument aus.

     Beispiele:

          (%i1) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o1)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i2) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o2)                ! !   >    f(i j l + k)
                               ! !  /
                              l = 1 ====
                                    k = 1

 -- Optionsvariable: niceindicespref
     Standardwert: '[i, j, k, l, m, n]'

     'niceindicespref' ist die Liste mit den Namen, die die Funktion
     'niceindices' nutzt, um die Indizes von Summen und Produkte
     umzubenennen.

     Beispiele:

          (%i1) niceindicespref: [p, q, r, s, t, u]$
          (%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o2)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i3) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o3)                ! !   >    f(i j q + p)
                               ! !  /
                              q = 1 ====
                                    p = 1

 -- Funktion: nusum (<expr>, <i>, <i_0>, <i_1>)

     Wendet den Gosper-Algorithmus der unbestimmten Summation für den
     Ausdruck <expr> und dem Index <i> an.  Der Index <i> läuft von
     <i_0> bis <i_1>.  Der Ausdruck <expr> und das Ergebnis der
     Summation müssen als Produkte von ganzzahligen Exponentiationen,
     Fakultäten, Binomialen und rationalen Funktionen darstellbar sein.

     Die Funktionen 'nusum' und 'unsum' wenden einige Regeln für die
     Vereinfachung von Summen und Differenzen von endlichen Produkten
     an.  Siehe auch 'unsum'.

     Beispiele:

          (%i1) nusum (n*n!, n, 0, n);

          Dependent equations eliminated:  (1)
          (%o1)                     (n + 1)! - 1
          (%i2) nusum (n^4*4^n/binomial(2*n,n), n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o2) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i3) unsum (%, n);
                                        4  n
                                       n  4
          (%o3)                   ----------------
                                  binomial(2 n, n)
          (%i4) unsum (prod (i^2, i, 1, n), n);
                              n - 1
                              /===\
                               ! !   2
          (%o4)              ( ! !  i ) (n - 1) (n + 1)
                               ! !
                              i = 1
          (%i5) nusum (%, n, 1, n);

          Dependent equations eliminated:  (2 3)
                                      n
                                    /===\
                                     ! !   2
          (%o5)                      ! !  i  - 1
                                     ! !
                                    i = 1

 -- Funktion: product (<expr>, <i>, <i_0>, <i_1>)

     Bildet das Produkt des Ausdrucks <expr> zum Index <i> in den
     Grenzen <i_0> bis <i_1>.  'product' wertet <expr> sowie die untere
     Grenze <i_0> und obere Grenze <i_1> aus.  Der Index <i> wird nicht
     ausgewertet.

     Ist die Differenz der oberen und unteren Grenze eine ganze Zahl,
     wird <expr> für jeden Wert des Index <i> ausgewertet.  Das Ergebnis
     ist ein explizites Produkt.  Andernfalls ist der Bereich des Index
     unbestimmt.  Maxima wendet einige einfache Regeln an, um das
     Produkt zu vereinfachen.  Hat die Optionsvariable 'simpproduct' den
     Wert 'true', wendet Maxima weitere Regeln an, um Produkte zu
     vereinfachen.

     Siehe auch 'nouns' und 'evflag' für die Auswertung von Ausdrücken,
     die die Substantivform eines Produktes enthalten.

     Beispiele:

          (%i1) product (x + i*(i+1)/2, i, 1, 4);
          (%o1)           (x + 1) (x + 3) (x + 6) (x + 10)
          (%i2) product (i^2, i, 1, 7);
          (%o2)                       25401600
          (%i3) product (a[i], i, 1, 7);
          (%o3)                 a  a  a  a  a  a  a
                                 1  2  3  4  5  6  7
          (%i4) product (a(i), i, 1, 7);
          (%o4)          a(1) a(2) a(3) a(4) a(5) a(6) a(7)
          (%i5) product (a(i), i, 1, n);
                                       n
                                     /===\
                                      ! !
          (%o5)                       ! !  a(i)
                                      ! !
                                     i = 1
          (%i6) product (k, k, 1, n);
                                         n
                                       /===\
                                        ! !
          (%o6)                         ! !  k
                                        ! !
                                       k = 1
          (%i7) product (k, k, 1, n), simpproduct;
          (%o7)                          n!
          (%i8) product (integrate (x^k, x, 0, 1), k, 1, n);
                                       n
                                     /===\
                                      ! !    1
          (%o8)                       ! !  -----
                                      ! !  k + 1
                                     k = 1
          (%i9) product (if k <= 5 then a^k else b^k, k, 1, 10);
                                        15  40
          (%o9)                        a   b

 -- Optionsvariable: simpproduct
     Standardwert: 'false'

     Hat 'simpproduct' den Wert 'true', versucht Maxima ein Produkt
     weiter zu vereinfachen.  Die Vereinfachung kann eine geschlossene
     Form liefern.  Hat 'simpproduct' den Wert 'false' oder wird das
     Produkt als Substantivform ''product' definiert, werden nur einige
     einfache Regeln von Maxima für die Vereinfachung angewendet.
     'simpproduct' ist auch ein Auswertungsschalter.  Siehe 'evflag'.

     Siehe auch 'product' für ein Beispiel.

 -- Optionsvariable: simpsum
     Standardwert: 'false'

     Hat 'simpsum' den Wert 'true', versucht Maxima eine Summe oder
     Reihe weiter zu vereinfachen.  Die Vereinfachung kann eine
     geschlossene Form liefern.  Hat 'simpsum' den Wert 'false' oder die
     Summe oder Reihe liegt als Substantivform ''sum' vor, werden nur
     einige einfache Regeln von Maxima für die Vereinfachung angewendet.
     'simpsum' ist auch ein Auswertungsschalter.  Siehe 'evflag'.

     Siehe auch 'sum' für ein Beispiel.

 -- Funktion: sum (<expr>, <i>, <i_0>, <i_1>)

     Bildet die Summe des Ausdrucks <expr> zum Index <i> in den Grenzen
     <i_0> bis <i_1>.  Die Funktion 'sum' wertet <expr> sowie die untere
     Grenze <i_0> und obere Grenze <i_1> aus.  Der Index <i> wird nicht
     ausgewertet.

     Ist die Differenz der oberen und unteren Grenze eine ganze Zahl,
     wird <expr> für jeden Wert des Index <i> ausgewertet.  Das Ergebnis
     ist eine explizite Summe.  Andernfalls ist der Bereich des Index
     unbestimmt.  Maxima wendet einige einfache Regeln an, um die Summe
     zu vereinfachen.  Hat die Optionsvariable 'simpsum' den Wert
     'true', wendet Maxima weitere Regeln an, um Summen zu vereinfachen.

     Werden zwei unendliche Reihen miteinander multipliziert und die
     Optionsvariablen 'sumexpand' sowie 'cauchysum' haben beide den Wert
     'true', dann wird die Cauchy-Produktformel angewendet.

     Die Optionsvariable 'genindex' enthält das Zeichen, das der Präfix
     eines automatisch generierten Index ist.  'gensumnum' enthält eine
     ganze Zahl, die an den Präfix 'genindex' angehängt wird, um einen
     automatischen Index zu generieren.  'gensumnum' wird von Maxima
     automatisch erhöht.  Hat 'gensumnum' den Wert 'false', wird keine
     Zahl an den Präfix angehängt.

     Das Paket 'simplify_sum' enthält die Funktion 'simplify_sum', mit
     der Summen zu einer geschlossenen Form vereinfacht werden können.

     Siehe auch 'sumcontract', 'sumexpand', 'intosum', 'bashindices',
     'niceindices', 'cauchysum' und 'zeilberger'.

     Beispiele:

          (%i1) sum (i^2, i, 1, 7);
          (%o1)                          140
          (%i2) sum (a[i], i, 1, 7);
          (%o2)           a  + a  + a  + a  + a  + a  + a
                           7    6    5    4    3    2    1
          (%i3) sum (a(i), i, 1, 7);
          (%o3)    a(7) + a(6) + a(5) + a(4) + a(3) + a(2) + a(1)
          (%i4) sum (a(i), i, 1, n);
                                      n
                                     ====
                                     \
          (%o4)                       >    a(i)
                                     /
                                     ====
                                     i = 1
          (%i5) sum (2^i + i^2, i, 0, n);
                                    n
                                   ====
                                   \       i    2
          (%o5)                     >    (2  + i )
                                   /
                                   ====
                                   i = 0
          (%i6) sum (2^i + i^2, i, 0, n), simpsum;
                                        3      2
                             n + 1   2 n  + 3 n  + n
          (%o6)             2      + --------------- - 1
                                            6
          (%i7) sum (1/3^i, i, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o7)                        >    --
                                      /      i
                                      ====  3
                                      i = 1
          (%i8) sum (1/3^i, i, 1, inf), simpsum;
                                          1
          (%o8)                           -
                                          2
          (%i9) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
                                        inf
                                        ====
                                        \     1
          (%o9)                      30  >    --
                                        /      2
                                        ====  i
                                        i = 1
          (%i10) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
                                            2
          (%o10)                       5 %pi
          (%i11) sum (integrate (x^k, x, 0, 1), k, 1, n);
                                      n
                                     ====
                                     \       1
          (%o11)                      >    -----
                                     /     k + 1
                                     ====
                                     k = 1
          (%i12) sum (if k <= 5 then a^k else b^k, k, 1, 10);
                    10    9    8    7    6    5    4    3    2
          (%o12)   b   + b  + b  + b  + b  + a  + a  + a  + a  + a

 -- Funktion: sumcontract (<expr>)

     Fasst alle Summen in dem Ausdruck <expr> zusammen, die sich in
     ihrem oberen und unterem Index nur um eine Konstante voneinander
     unterscheiden.  Das Ergebnis ist eine Ausdruck mit einer Summe, für
     die Summen, die zusammengefasst werden können und weiteren Termen,
     die hinzu addiert werden müssen, um einen äquivalenten Ausdruck zu
     erhalten.

     Es kann notwendig sein zunächst das Kommando 'intosum(<expr>)'
     auszuführen.  Siehe 'intosum'.

     Beispiel:

          (%i1) 'sum(1/l,l,1,n)+'sum(k,k,1,n+2);
                                   n        n + 2
                                  ====      ====
                                  \     1   \
          (%o1)                    >    - +  >    k
                                  /     l   /
                                  ====      ====
                                  l = 1     k = 1
          (%i2) sumcontract(%);
                                      n
                                     ====
                                     \          1
          (%o2)                2 n +  >    (l + -) + 3
                                     /          l
                                     ====
                                     l = 1

 -- Optionsvariable: sumexpand
     Standardwert: 'false'

     Hat die Optionsvariable 'sumexpand' den Wert 'true', werden
     Produkte von Summen und Potenzen von Summen zu verschachtelten
     Summen vereinfacht.  Siehe auch 'cauchysum'.

     Beispiele:

          (%i1) sumexpand: true$
          (%i2) sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
                               m      n
                              ====   ====
                              \      \
          (%o2)                >      >     f(i1) g(i2)
                              /      /
                              ====   ====
                              i1 = 0 i2 = 0
          (%i3) sum (f (i), i, 0, m)^2;
                               m      m
                              ====   ====
                              \      \
          (%o3)                >      >     f(i3) f(i4)
                              /      /
                              ====   ====
                              i3 = 0 i4 = 0

 -- Funktion: unsum (<f>, <n>)

     Gibt die erste Rückwärtsdifferenz '<f>(<n>) - <f>(<n>-1)' zurück.
     Siehe auch 'nusum'.

     Beispiele:

          (%i1) g(p) := p*4^n/binomial(2*n,n);
                                               n
                                            p 4
          (%o1)               g(p) := ----------------
                                      binomial(2 n, n)
          (%i2) g(n^4);
                                        4  n
                                       n  4
          (%o2)                   ----------------
                                  binomial(2 n, n)
          (%i3) nusum (%, n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o3) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i4) unsum (%, n);
                                        4  n
                                       n  4
          (%o4)                   ----------------
                                  binomial(2 n, n)


File: maxima.info,  Node: Einführung in Reihen,  Next: Funktionen und Variablen für Reihen,  Prev: Summen und Produkte,  Up: Summen Produkte und Reihen

15.2 Einführung in Reihen
=========================

Maxima kennt die Funktionen 'taylor' und 'powerseries', um die
Reihenentwicklung von differenzierbaren Funktionen zu finden.  Maxima
hat weiterhin Funktionen wie 'nusum', um geschlossene Formen von Reihen
zu finden.  Operationen wie die Addition und Multiplikation arbeiten wie
gewohnt für Reihen.  Das folgende Kapitel beschreibt die Variablen und
Funktionen für eine Reihenentwicklung.


File: maxima.info,  Node: Funktionen und Variablen für Reihen,  Next: Poisson Reihen,  Prev: Einführung in Reihen,  Up: Summen Produkte und Reihen

15.3 Funktionen und Variablen für Reihen
========================================

 -- Funktion: deftaylor (<f_1>(<x_1>), <expr_1>, ..., <f_n>(<x_n>),
          <expr_n>)

     Für eine Funktion <f_i> einer Variablen <x_i> definiert 'deftaylor'
     den Ausdruck <expr_i> als die Taylorreihe um den Nullpunkt.
     <expr_i> ist typischerweise ein Polynom in der Variablen <x_i> oder
     eine Summe.  'deftaylor' akzeptiert aber auch allgemeinere
     Ausdrücke.

     'powerseries(<f_i>(<x_i>), <x_i>, 0)' gibt die Reihe zurück, die
     mit 'deftaylor' definiert wurde.

     'deftaylor' gibt eine Liste der Funktionen <f_1>, ..., <f_n>
     zurück.  'deftaylor' wertet die Argumente aus.

     Siehe auch 'taylor' und 'powerseries'.

     Beispiele:

          (%i1) deftaylor (f(x), x^2 + sum(x^i/(2^i*i!^2), i, 4, inf));
          (%o1)                          [f]
          (%i2) powerseries (f(x), x, 0);
                                inf
                                ====      i1
                                \        x         2
          (%o2)                  >     -------- + x
                                /       i1    2
                                ====   2   i1!
                                i1 = 4
          (%i3) taylor (exp (sqrt (f(x))), x, 0, 4);
                                2         3          4
                               x    3073 x    12817 x
          (%o3)/T/     1 + x + -- + ------- + -------- + . . .
                               2     18432     307200

 -- Optionsvariable: maxtayorder
     Standardwert: 'true'

     Hat 'maxtayorder' den Wert 'true', werden bei der algebraischen
     Manipulation von Taylor-Reihen, von der Funktion 'taylor' so viele
     Terme wie möglich mitgeführt.

 -- Funktion: pade (<taylor_series>, <numer_deg_bound>,
          <denom_deg_bound>)

     Gibt eine Liste aller rationalen Funktionen zurück, die die
     angegebene Taylor-Reihenentwicklung haben und deren Summe des
     Nennergrads und des Zählergrads kleiner oder gleich des Grads der
     Reihenentwicklung ist.

     Das Argument <taylor_series> ist eine Taylor-Reihe in einer
     Variablen.  Die Argumente <numer_deg_bound> und <denom_deg_bound>
     sind positive ganze Zahlen, die eine Grenze für den Nennergrad und
     den Zählergrad der rationalen Funktion angeben.

     Die Taylor-Reihe kann auch eine Laurent-Reihe sein und die Grenzen
     für den Grad können 'inf' sein.

     Siehe auch 'taylor'.

     Beispiele:

          (%i1) taylor (1 + x + x^2 + x^3, x, 0, 3);
                                        2    3
          (%o1)/T/             1 + x + x  + x  + . . .
          (%i2) pade (%, 1, 1);
                                           1
          (%o2)                       [- -----]
                                         x - 1
          (%i3) t: taylor(-(83787*x^10 - 45552*x^9 - 187296*x^8
                             + 387072*x^7 + 86016*x^6 - 1507328*x^5
                             + 1966080*x^4 + 4194304*x^3 - 25165824*x^2
                             + 67108864*x - 134217728)
                   /134217728, x, 0, 10);
                              2    3       4       5       6        7
                       x   3 x    x    15 x    23 x    21 x    189 x
          (%o3)/T/ 1 - - + ---- - -- - ----- + ----- - ----- - ------
                       2    16    32   1024    2048    32768   65536

                                            8         9          10
                                      5853 x    2847 x    83787 x
                                    + ------- + ------- - --------- + . . .
                                      4194304   8388608   134217728
          (%i4) pade (t, 4, 4);
          (%o4)                          []

     Es gibt keine rationale Funktion des Grads 4 im Zähler und Nenner
     für die oben angegebene Taylor-Reihenentwicklung.  Die Summe des
     Zählergrads und des Nennergrads müssen mindestens gleich dem Grad
     der Reihenentwicklung sein.  In diesem Fall ist der Grad der
     Taylor-Reihenentwicklung '10'.

          (%i5) pade (t, 5, 5);
                               5                4                 3
          (%o5) [- (520256329 x  - 96719020632 x  - 489651410240 x

                            2
           - 1619100813312 x  - 2176885157888 x - 2386516803584)

                         5                 4                  3
          /(47041365435 x  + 381702613848 x  + 1360678489152 x

                            2
           + 2856700692480 x  + 3370143559680 x + 2386516803584)]

 -- Funktion: powerseries (<expr>, <x>, <a>)

     Gibt eine geschlossene Form für die Reihenentwicklung des Ausdrucks
     <expr> in der Variablen <x> um den Punkt <a> zurück.  Das Argument
     <a> kann die Werte 'inf' oder 'infinity' haben.  Die
     Reihenentwicklung für eine Funktion 'f(x)' hat die allgemeine Form:
                            inf
                            ====
                            \               n
                 f(x) =      >    b  (x - a)
                            /      n
                            ====
                            n = 0

     Mit den Koeffzienten:
                               !
                      d        !
                      -- (f(x))!
                      dn       !
                               !x = a
                 b  = ---------------
                  n         n!

     Kann die Funktion 'powerseries' keine Reihenentwicklung für den
     Ausdruck <expr> finden, können möglicherweise mit der Funktion
     'taylor' die ersten Terme der Reihenentwicklung berechnet werden.

     Hat die Optionsvariable 'verbose' den Wert 'true', werden Meldungen
     zu den verwendeten Algorithmen von der Funktion 'powerseries'
     angezeigt.

     Beispiel:

          (%i1) verbose: true$

          (%i2) powerseries (log(sin(x)/x), x, 0);
          trigreduce: can't expand
                           log(sin(x))

          trigreduce: try again after applying the rule:
                                           d
                                         / -- (sin(x))
                                         [ dx
                           log(sin(x)) = I ----------- dx
                                         ]   sin(x)
                                         /


          powerseries: first simplification returned
                                          /
                                          [
                               - log(x) + I cot(x) dx
                                          ]
                                          /

                     inf
                     ====        i1  - 1 + 2 i1             2 i1
                     \      (- 1)   2           bern(2 i1) x
          (%o2)       >     ------------------------------------
                     /                   i1 (2 i1)!
                     ====
                     i1 = 1

 -- Option variable: psexpand
     Default value: 'false'

     When 'psexpand' is 'true', an extended rational function expression
     is displayed fully expanded.  The switch 'ratexpand' has the same
     effect.

     When 'psexpand' is 'false', a multivariate expression is displayed
     just as in the rational function package.

     When 'psexpand' is 'multi', then terms with the same total degree
     in the variables are grouped together.

 -- Funktion: revert (<expr>, <x>)
 -- Funktion: revert2 (<expr>, <x>, <n>)

     Die Funktion 'revert' berechnet eine Taylorreihe in der Variablen
     <x> um den Entwicklungspunkt Null, die der Taylorreihe der inversen
     Funktion entspricht, die von der Taylorreihe <expr> repräsentiert
     wird.  Das Ergebnis ist ein Polynom in einer CRE-Darstellung mit
     dem Grad der höchsten Potenz im Ausdruck <expr>.

     Die Funktion 'revert2' entspricht der Funktion 'revert' mit dem
     Unterschied, dass mit dem dritten Argument <n> der Grad der neuen
     Taylorreihe explizit angegeben werden kann.  Dieser kann kleiner
     oder größer als der Grad der Taylorreihe <expr> sein.

     Mit dem Kommando 'load(revert)' werden die Funktionen geladen.

     Siehe auch die Funktion 'taylor'.

     Beispiel:

     Die Inverse der Funktion 'exp(x) - 1' ist die Funktion 'log(x+1)'.
     Mit dem Kommando 'revert(taylor(exp(x) - 1, x, 0, 6), x)' wird die
     Taylorreihe der Inversen 'log(x+1)' berechnet.

          (%i1) load (revert)$
          (%i2) t: taylor (exp(x) - 1, x, 0, 6);
                             2    3    4    5     6
                            x    x    x    x     x
          (%o2)/T/      x + -- + -- + -- + --- + --- + . . .
                            2    6    24   120   720
          (%i3) revert (t, x);
                         6       5       4       3       2
                     10 x  - 12 x  + 15 x  - 20 x  + 30 x  - 60 x
          (%o3)/R/ - --------------------------------------------
                                          60
          (%i4) ratexpand (%);
                               6    5    4    3    2
                              x    x    x    x    x
          (%o4)             - -- + -- - -- + -- - -- + x
                              6    5    4    3    2
          (%i5) taylor (log(x+1), x, 0, 6);
                              2    3    4    5    6
                             x    x    x    x    x
          (%o5)/T/       x - -- + -- - -- + -- - -- + . . .
                             2    3    4    5    6
          (%i6) ratsimp (revert (t, x) - taylor (log(x+1), x, 0, 6));
          (%o6)                           0
          (%i7) revert2 (t, x, 4);
                                    4    3    2
                                   x    x    x
          (%o7)                  - -- + -- - -- + x
                                   4    3    2

 -- Funktion: taylor (<expr>, <x>, <a>, <n>)
 -- Funktion: taylor (<expr>, [<x_1>, <x_2>, ...], <a>, <n>)
 -- Funktion: taylor (<expr>, [<x>, <a>, <n>, 'asymp])
 -- Funktion: taylor (<expr>, [<x_1>, <x_2>, ...], [<a_1>, <a_2>, ...],
          [<n_1>, <n_2>, ...])
 -- Funktion: taylor (<expr>, [<x_1>, <a_1>, <n_1>], [<x_2>, <a_2>,
          <n_2>], ...)

     'taylor(<expr>, <x>, <a>, <n>)' entwickelt den Ausdruck <expr> in
     eine Taylor- oder Laurent-Reihenwicklung in der Variablen <x> um
     den Punkt <a>, die die Terme bis zur Ordnung '(<x> - <a>)^<n>'
     enthält.

     Hat der Ausdruck <expr> die Form '<f>(<x>)/<g>(<x>)' und hat
     '<g>(<x>)' keine Terme bis zur Ordnung <n>, dann versucht 'taylor'
     den Ausdruck '<g>(<x>)' bis zur Ordnung '2 <n>' zu entwickeln.
     Treten in der Entwicklung weiterhin keine von Null verschiedenen
     Terme auf, verdoppelt 'taylor' die Ordnung der Entwicklung für
     '<g>(<x>)' so lange, wie die Ordnung kleiner oder gleich '<n>
     2^taylordepth' ist.  Siehe auch 'taylordepth'.

     'taylor(<expr>, [<x_1>, <x_2>, ...], <a>, <n>)' gibt die
     Reihenentwicklung der Ordnung <n> in allen Variablen <x_1>, <x_2>,
     ... um den Punkt <a> zurück.

     Die beiden folgenden äquivalenten Kommandos 'taylor(<expr>, [<x_1>,
     <a_1>, <n_1>], [<x_2>, <a_2>, <n_2>], ...)' und 'taylor(<expr>,
     [<x_1>, <x_2>, ...], [<a_1>, <a_2>, ...], [<n_1>, <n_2>, ...])'
     geben eine Reihenentwicklung für die Variablen <x_1>, <x_2>, ... um
     den Punkt '(<a_1>, <a_2>, ...)' mit den Ordnungen <n_1>, <n_2>, ...
     zurück.

     'taylor(<expr>, [<x>, <a>, <n>, 'asymp])' entwickelt den Ausdruck
     <expr> in negativen Potenzen von '<x> - <a>'.  Der Term mit der
     größten Ordnung ist '(<x> - <a>)^<-n>'.

     Folgende Optionsvariablen kontrollieren die Berechnung einer
     Taylorreihe:

     'maxtayorder'
          Hat 'maxtayorder' den Wert 'true', werden bei der
          algebraischen Manipulation von Taylor-Reihen, von der Funktion
          'taylor' so viele Terme wie möglich mitgeführt.

     'taylordepth'
          Findet 'taylor' keine von Null verschiedenen Terme in der
          Reihenentwicklung, wird die Ordnung der Entwicklung solange
          erhöht wie sie kleiner oder gleich '2^taylordepth' ist.

     'taylor_logexpand'
          Die Optionsvariable 'taylor_logexpand' kontrolliert die
          Entwicklung von Logarithmusfunktionen, die bei der
          Reihenentwicklung auftreten.  Der Standardwert ist 'true' und
          die Logarithmusfunktionen in einer Reihenentwicklung werden
          vollständig entwickelt.

     'taylor_order_coefficients'
          Die Optionsvariable 'taylor_order_coefficients' kontrolliert
          die Anordung von Termen in einer Reihenentwicklung.  Der
          Standardwert ist 'true' und die Anordung entspricht der
          kanonischen Darstellung eines Ausdrucks.

     'taylor_truncate_polynomials'
          Hat die Optionsvariable 'taylor_truncate_polynomials' den Wert
          'false', wird das Ergebnis der Reihenentwicklung eines
          Polynoms als exakt angenommen.

     'taylor_simplifier'
          Die Funktion zur Vereinfachung der Koeffizienten einer
          Entwicklung ist in der Optionsvariablen 'taylor_simplifier'
          enthalten.  Der Standardwert ist 'simplify'.  Der Variablen
          kann eine nutzerdefinierte Funktion zugewiesen werden.

     Mit der Funktion 'taylorp' kann getestet werden, ob ein Ausdruck
     eine Taylorreihe repräsentiert.  Die Funktion 'taylorinfo' gibt
     Informationen zu einer Taylorreihe aus.  Die spezielle CRE-Form
     einer Taylorreihe wird mit der Funktion 'taytorat' in eine
     Standardform gebracht.  Mit den Funktionen 'revert' und 'revert2'
     kann die Taylorreihe einer inversen Funktion berechnet werden.

     Beispiele:

          (%i1) taylor (sqrt (sin(x) + a*x + 1), x, 0, 3);
                                     2             2
                       (a + 1) x   (a  + 2 a + 1) x
          (%o1)/T/ 1 + --------- - -----------------
                           2               8

                                             3      2             3
                                         (3 a  + 9 a  + 9 a - 1) x
                                       + -------------------------- + . . .
                                                     48
          (%i2) %^2;
                                              3
                                             x
          (%o2)/T/           1 + (a + 1) x - -- + . . .
                                             6
          (%i3) taylor (sqrt (x + 1), x, 0, 5);
                                 2    3      4      5
                            x   x    x    5 x    7 x
          (%o3)/T/      1 + - - -- + -- - ---- + ---- + . . .
                            2   8    16   128    256
          (%i4) %^2;
          (%o4)/T/                  1 + x + . . .
          (%i5) product ((1 + x^i)^2.5, i, 1, inf)/(1 + x^2);
                                   inf
                                  /===\
                                   ! !    i     2.5
                                   ! !  (x  + 1)
                                   ! !
                                  i = 1
          (%o5)                   -----------------
                                        2
                                       x  + 1
          (%i6) ev (taylor(%, x,  0, 3), keepfloat);
                                         2           3
          (%o6)/T/    1 + 2.5 x + 3.375 x  + 6.5625 x  + . . .
          (%i7) taylor (1/log (x + 1), x, 0, 3);
                                         2       3
                           1   1   x    x    19 x
          (%o7)/T/         - + - - -- + -- - ----- + . . .
                           x   2   12   24    720
          (%i8) taylor (cos(x) - sec(x), x, 0, 5);
                                          4
                                     2   x
          (%o8)/T/                - x  - -- + . . .
                                         6
          (%i9) taylor ((cos(x) - sec(x))^3, x, 0, 5);
          (%o9)/T/                    0 + . . .
          (%i10) taylor (1/(cos(x) - sec(x))^3, x, 0, 5);
                                                         2          4
                      1     1       11      347    6767 x    15377 x
          (%o10)/T/ - -- + ---- + ------ - ----- - ------- - --------
                       6      4        2   15120   604800    7983360
                      x    2 x    120 x

                                                                    + . . .
          (%i11) taylor (sqrt (1 - k^2*sin(x)^2), x, 0, 6);
                         2  2       4      2   4
                        k  x    (3 k  - 4 k ) x
          (%o11)/T/ 1 - ----- - ----------------
                          2            24

                                              6       4       2   6
                                         (45 k  - 60 k  + 16 k ) x
                                       - -------------------------- + . . .
                                                    720
          (%i12) taylor ((x + 1)^n, x, 0, 4);
                                2       2     3      2         3
                              (n  - n) x    (n  - 3 n  + 2 n) x
          (%o12)/T/ 1 + n x + ----------- + --------------------
                                   2                 6

                                         4      3       2         4
                                       (n  - 6 n  + 11 n  - 6 n) x
                                     + ---------------------------- + . . .
                                                    24
          (%i13) taylor (sin (y + x), x, 0, 3, y, 0, 3);
                         3                 2
                        y                 y
          (%o13)/T/ y - -- + . . . + (1 - -- + . . .) x
                        6                 2

                              3                       2
                         y   y            2      1   y            3
                    + (- - + -- + . . .) x  + (- - + -- + . . .) x  + . . .
                         2   12                  6   12
          (%i14) taylor (sin (y + x), [x, y], 0, 3);
                               3        2      2      3
                              x  + 3 y x  + 3 y  x + y
          (%o14)/T/   y + x - ------------------------- + . . .
                                          6
          (%i15) taylor (1/sin (y + x), x, 0, 3, y, 0, 3);
                    1   y              1    1               1            2
          (%o15)/T/ - + - + . . . + (- -- + - + . . .) x + (-- + . . .) x
                    y   6               2   6                3
                                       y                    y

                                                     1            3
                                                + (- -- + . . .) x  + . . .
                                                      4
                                                     y
          (%i16) taylor (1/sin (y + x), [x, y], 0, 3);
                                       3         2       2        3
                      1     x + y   7 x  + 21 y x  + 21 y  x + 7 y
          (%o16)/T/ ----- + ----- + ------------------------------- + . . .
                    x + y     6                   360

 -- Optionsvariable: taylordepth
     Standardwert: 3

     Findet die Funktion 'taylor' keine von Null verschiedenen Terme in
     der Reihenentwicklung, wird die Ordnung der Entwicklung solange
     erhöht wie sie kleiner oder gleich '2^taylordepth' ist.

     Siehe auch 'taylor'.

 -- Funktion: taylorinfo (<expr>)

     Gibt Informationen über die Taylorreihe <expr> zurück.  Die
     Rückgabe ist eine Liste, die Listen mit den Namen der Variablen,
     den Entwicklungspunkten und den Ordnungen der Entwicklung
     enthalten.

     Ist <expr> keine Taylorreihe, ist die Rückgabe 'false'.

     Beispiele:

          (%i1) taylor ((1 - y^2)/(1 - x), x, 0, 3, [y, a, inf]);
                            2                       2
          (%o1)/T/ - (y - a)  - 2 a (y - a) + (1 - a )

                   2                        2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   3
           + (1 - a  - 2 a (y - a) - (y - a) ) x  + . . .
          (%i2) taylorinfo(%);
          (%o2)               [[y, a, inf], [x, 0, 3]]

 -- Funktion: taylorp (<expr>)

     Hat den Rückgabewert 'true', wenn das Argument <expr> eine
     Taylorreihe ist.  Ansonsten ist der Rückgabewert 'false'.

 -- Optionsvariable: taylor_logexpand
     Standardwert: 'true'

     'taylor_logexpand' kontrolliert die Entwicklung von Logarithmen in
     einer Taylorreihe.  Der Standardwert ist 'true' und die
     Logarithmusfunktionen in einer Reihenentwicklung werden vollständig
     entwickelt.  Ansonsten werden Logarithmusfunktionen so weit
     entwickelt, wie es notwendig ist, um eine formale Reihenentwicklung
     zu erhalten.

 -- Optionsvariable: taylor_order_coefficients
     Standardwert: 'true'

     Die Optionsvariable 'taylor_order_coefficients' kontrolliert die
     Ordnung der Koeffizienten einer Taylorreihenentwicklung.  Hat
     'taylor_order_coefficients' den Wert 'true', werden die
     Koeffizienten kanonisch angeordnet.

 -- Optionsvariable: taylor_simplifier
     Standardwert: 'SIMPLIFY'

     Die Optionsvariable 'taylor_simplifier' enthält den Namen der
     Funktion, die für die Vereinfachung der Koeffizienten einer
     Taylorreihenentwicklung von 'taylor' aufgerufen wird.  Der
     Standardwert ist die Lisp-Funktion 'SIMPLIFY'.

 -- Optionsvariable: taylor_truncate_polynomials
     Standardwert: 'true'

     Hat die Optionsvariable 'taylor_truncate_polynomials' den Wert
     'false', wird das Ergebnis der Reihenentwicklung eines Polynoms als
     exakt angenommen.

     Beispiel:

          (%i1) taylor(x^6+x^4+x^2,x,0,4),taylor_truncate_polynomials:true;
                                    2    4
          (%o1)/T/                 x  + x  + . . .
          (%i2) taylor(x^6+x^4+x^2,x,0,4),taylor_truncate_polynomials:false;
                                        2    4
          (%o2)/T/                     x  + x

 -- Funktion: taytorat (<expr>)

     Konvertiert den Ausdruck <expr> von der speziellen Darstellung
     einer Taylorreihenentwicklung in eine CRE-Form.

     Beispiel:

          (%i1) taylor(atan(x),x,0,5);
                                      3    5
                                     x    x
          (%o1)/T/               x - -- + -- + . . .
                                     3    5
          (%i2) taytorat(%);
                                    5      3
                                 3 x  - 5 x  + 15 x
          (%o2)/R/               ------------------
                                         15

 -- Funktion: trunc (<expr>)

     Die Rückgabe der Funktion 'trunc' ist ein Ausdruck, der das
     Argument <expr> in der Ausgabe wie eine Taylorreihenentwicklung
     anzeigt.  Der Ausdruck <expr> wird ansonsten nicht modifiziert.

     Beispiel:

          (%i1) expr: x^2 + x + 1;
                                      2
          (%o1)                      x  + x + 1
          (%i2) trunc (expr);
                                          2
          (%o2)                  1 + x + x  + . . .
          (%i3) is (expr = trunc (expr));
          (%o3)                         true

 -- Optionsvariable: verbose
     Standardwert: 'false'

     Hat die Optionsvariable 'verbose' den Wert 'true', werden von der
     Funktion 'powerseries' Meldungen über die verwendeten Algorithmen
     ausgegeben.


File: maxima.info,  Node: Poisson Reihen,  Next: Kettenbrüche,  Prev: Funktionen und Variablen für Reihen,  Up: Summen Produkte und Reihen

15.4 Poisson Reihen
===================

 -- Function: intopois (<a>)

     Converts <a> into a Poisson encoding.

 -- Function: outofpois (<a>)

     Converts <a> from Poisson encoding to general representation.  If
     <a> is not in Poisson form, 'outofpois' carries out the conversion,
     i.e., the return value is 'outofpois (intopois (<a>))'.  This
     function is thus a canonical simplifier for sums of powers of sine
     and cosine terms of a particular type.

 -- Function: poisdiff (<a>, <b>)

     Differentiates <a> with respect to <b>.  <b> must occur only in the
     trig arguments or only in the coefficients.

 -- Function: poisexpt (<a>, <b>)

     Functionally identical to 'intopois (<a>^<b>)'.  <b> must be a
     positive integer.

 -- Function: poisint (<a>, <b>)

     Integrates in a similarly restricted sense (to 'poisdiff').
     Non-periodic terms in <b> are dropped if <b> is in the trig
     arguments.

 -- Option variable: poislim
     Default value: 5

     'poislim' determines the domain of the coefficients in the
     arguments of the trig functions.  The initial value of 5
     corresponds to the interval [-2^(5-1)+1,2^(5-1)], or [-15,16], but
     it can be set to [-2^(n-1)+1, 2^(n-1)].

 -- Function: poismap (<series>, <sinfn>, <cosfn>)

     will map the functions <sinfn> on the sine terms and <cosfn> on the
     cosine terms of the Poisson series given.  <sinfn> and <cosfn> are
     functions of two arguments which are a coefficient and a
     trigonometric part of a term in series respectively.

 -- Function: poisplus (<a>, <b>)

     Is functionally identical to 'intopois (a + b)'.

 -- Function: poissimp (<a>)

     Converts <a> into a Poisson series for <a> in general
     representation.

 -- Special symbol: poisson

     The symbol '/P/' follows the line label of Poisson series
     expressions.

 -- Function: poissubst (<a>, <b>, <c>)

     Substitutes <a> for <b> in <c>.  <c> is a Poisson series.

     (1) Where <B> is a variable <u>, <v>, <w>, <x>, <y>, or <z>, then
     <a> must be an expression linear in those variables (e.g., '6*u +
     4*v').

     (2) Where <b> is other than those variables, then <a> must also be
     free of those variables, and furthermore, free of sines or cosines.

     'poissubst (<a>, <b>, <c>, <d>, <n>)' is a special type of
     substitution which operates on <a> and <b> as in type (1) above,
     but where <d> is a Poisson series, expands 'cos(<d>)' and
     'sin(<d>)' to order <n> so as to provide the result of substituting
     '<a> + <d>' for <b> in <c>.  The idea is that <d> is an expansion
     in terms of a small parameter.  For example, 'poissubst (u, v,
     cos(v), %e, 3)' yields 'cos(u)*(1 - %e^2/2) - sin(u)*(%e -
     %e^3/6)'.

 -- Function: poistimes (<a>, <b>)

     Is functionally identical to 'intopois (<a>*<b>)'.

 -- Function: poistrim ()

     is a reserved function name which (if the user has defined it) gets
     applied during Poisson multiplication.  It is a predicate function
     of 6 arguments which are the coefficients of the <u>, <v>, ..., <z>
     in a term.  Terms for which 'poistrim' is 'true' (for the
     coefficients of that term) are eliminated during multiplication.

 -- Function: printpois (<a>)

     Prints a Poisson series in a readable format.  In common with
     'outofpois', it will convert <a> into a Poisson encoding first, if
     necessary.


File: maxima.info,  Node: Kettenbrüche,  Prev: Poisson Reihen,  Up: Summen Produkte und Reihen

15.5 Kettenbrüche
=================

 -- Function: cf (<expr>)

     Converts <expr> into a continued fraction.  <expr> is an expression
     comprising continued fractions and square roots of integers.
     Operands in the expression may be combined with arithmetic
     operators.  Aside from continued fractions and square roots,
     factors in the expression must be integer or rational numbers.
     Maxima does not know about operations on continued fractions
     outside of 'cf'.

     'cf' evaluates its arguments after binding 'listarith' to 'false'.
     'cf' returns a continued fraction, represented as a list.

     A continued fraction 'a + 1/(b + 1/(c + ...))' is represented by
     the list '[a, b, c, ...]'.  The list elements 'a', 'b', 'c', ...
     must evaluate to integers.  <expr> may also contain 'sqrt (n)'
     where 'n' is an integer.  In this case 'cf' will give as many terms
     of the continued fraction as the value of the variable 'cflength'
     times the period.

     A continued fraction can be evaluated to a number by evaluating the
     arithmetic representation returned by 'cfdisrep'.  See also
     'cfexpand' for another way to evaluate a continued fraction.

     See also 'cfdisrep', 'cfexpand', and 'cflength'.

     Examples:

        * <expr> is an expression comprising continued fractions and
          square roots of integers.

               (%i1) cf ([5, 3, 1]*[11, 9, 7] + [3, 7]/[4, 3, 2]);
               (%o1)               [59, 17, 2, 1, 1, 1, 27]
               (%i2) cf ((3/17)*[1, -2, 5]/sqrt(11) + (8/13));
               (%o2)        [0, 1, 1, 1, 3, 2, 1, 4, 1, 9, 1, 9, 2]

        * 'cflength' controls how many periods of the continued fraction
          are computed for algebraic, irrational numbers.

               (%i1) cflength: 1$
               (%i2) cf ((1 + sqrt(5))/2);
               (%o2)                    [1, 1, 1, 1, 2]
               (%i3) cflength: 2$
               (%i4) cf ((1 + sqrt(5))/2);
               (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
               (%i5) cflength: 3$
               (%i6) cf ((1 + sqrt(5))/2);
               (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]

        * A continued fraction can be evaluated by evaluating the
          arithmetic representation returned by 'cfdisrep'.

               (%i1) cflength: 3$
               (%i2) cfdisrep (cf (sqrt (3)))$
               (%i3) ev (%, numer);
               (%o3)                   1.731707317073171

        * Maxima does not know about operations on continued fractions
          outside of 'cf'.

               (%i1) cf ([1,1,1,1,1,2] * 3);
               (%o1)                     [4, 1, 5, 2]
               (%i2) cf ([1,1,1,1,1,2]) * 3;
               (%o2)                  [3, 3, 3, 3, 3, 6]

 -- Function: cfdisrep (<list>)

     Constructs and returns an ordinary arithmetic expression of the
     form 'a + 1/(b + 1/(c + ...))' from the list representation of a
     continued fraction '[a, b, c, ...]'.

          (%i1) cf ([1, 2, -3] + [1, -2, 1]);
          (%o1)                     [1, 1, 1, 2]
          (%i2) cfdisrep (%);
                                            1
          (%o2)                     1 + ---------
                                              1
                                        1 + -----
                                                1
                                            1 + -
                                                2

 -- Function: cfexpand (<x>)

     Returns a matrix of the numerators and denominators of the last
     (column 1) and next-to-last (column 2) convergents of the continued
     fraction <x>.

          (%i1) cf (rat (ev (%pi, numer)));

          `rat' replaced 3.141592653589793 by 103993/33102 =3.141592653011902
          (%o1)                  [3, 7, 15, 1, 292]
          (%i2) cfexpand (%);
                                   [ 103993  355 ]
          (%o2)                    [             ]
                                   [ 33102   113 ]
          (%i3) %[1,1]/%[2,1], numer;
          (%o3)                   3.141592653011902

 -- Option variable: cflength
     Default value: 1

     'cflength' controls the number of terms of the continued fraction
     the function 'cf' will give, as the value 'cflength' times the
     period.  Thus the default is to give one period.

          (%i1) cflength: 1$
          (%i2) cf ((1 + sqrt(5))/2);
          (%o2)                    [1, 1, 1, 1, 2]
          (%i3) cflength: 2$
          (%i4) cf ((1 + sqrt(5))/2);
          (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
          (%i5) cflength: 3$
          (%i6) cf ((1 + sqrt(5))/2);
          (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]


File: maxima.info,  Node: Analysis,  Next: Polynome,  Prev: Summen Produkte und Reihen,  Up: Top

16 Analysis
***********

* Menu:

* Funktionen und Variablen für Grenzwerte::
* Funktionen und Variablen der Differentiation::
* Integration::
* Differentialgleichungen::


File: maxima.info,  Node: Funktionen und Variablen für Grenzwerte,  Next: Funktionen und Variablen der Differentiation,  Prev: Analysis,  Up: Analysis

16.1 Funktionen und Variablen für Grenzwerte
============================================

 -- Optionsvariable: lhospitallim
     Standardwert: 4

     Die Optionsvariable 'lhospitallim' enthält die maximale Zahl an
     Iterationen, für die die L'Hospitalsche Regel von der Funktion
     'limit' angewendet wird.  Damit wird verhindert, dass die Funktion
     'limit' in eine unendliche Schleife gerät.

 -- Funktion: limit (<expr>, <x>, <val>, <dir>)
 -- Funktion: limit (<expr>, <x>, <val>)
 -- Funktion: limit (<expr>)

     Berechnet den Grenzwert des Ausdrucks <expr>, wenn die reelle
     Variable <x> gegen den Wert <val> in Richtung <dir> geht.  Die
     Richtung <dir> kann die Werte <plus> für einen Grenzwert von oben
     und <minus> für einen Grenzwert von unten haben.  Für einen
     zweiseitigen Grenzwert wird die Richtung <dir> nicht angegeben.

     Maxima verwendet die folgenden Symbole für unendliche und
     infinitesimale Größen sowie undefinierte und unbestimmte Größen,
     die als Ergebnis eines Grenzwertes oder als Wert für die Bestimmung
     eines Grenzwertes auftreten können:

     'inf'
          positiv unendlich
     'minf'
          negativ unendlich
     'infinity'
          komplex unendlich
     'zeroa'
          positiv unendlich klein
     'zerob'
          negativ unendlich klein
     'und'
          ein nicht definiertes Ergebnis
     'ind'
          ein unbestimmtes Ergebnis

     Die Optionsvariable 'lhospitallim' enthält die maximale Zahl an
     Iterationen, für die die L'Hospitalsche Regel von der Funktion
     'limit' angewendet wird.

     Hat 'tlimswitch' den Wert 'true', nutzt die Funktion 'limit' eine
     Taylor-Reihenentwicklung, wenn der Grenzwert nicht mit anderen
     Methoden bestimmt werden kann.

     Hat die Optionsvariable 'limsubst' den Wert 'false', wird die
     Ersetzung von 'limit(f(g(x)),x,x0)' durch 'f(limit(g(x),x,x0))' für
     eine unbekannte Funktion 'f' verhindert.  Siehe auch 'limsubst'.

     'limit' kann mit einem Argument aufgerufen werden, um Ausdrücke zu
     vereinfachen, die unendliche oder infinitesimale Größen enthalten.
     Zum Beispiel wird 'limit(inf-1)' zu 'inf' vereinfacht.

     Der Algorithmus ist in der folgenden Arbeit beschrieben: Wang, P.,
     "Evaluation of Definite Integrals by Symbolic Manipulation", Ph.D.
     thesis, MAC TR-92, October 1971.

     Beispiele:

          (%i1) limit(x*log(x),x,0,plus)
          (%o1)                           0
          (%i2) limit((x+1)^(1/x),x,0)
          (%o2)                          %e
          (%i3) limit(%e^x/x,x,inf)
          (%o3)                          inf
          (%i4) limit(sin(1/x),x,0)
          (%o4)                          ind

 -- Optionsvariable: limsubst
     Standardwert: 'false'

     Ist eine Funktion 'f' teil eines Ausdrucks für den Maxima den
     Grenzwert sucht, dann wird folgende Ersetzung ausgeführt:

             limit   f(g(x)) = f(limit   g(x))
             x -> x0             x -> x0

     Hat die Optionsvariable 'limsubst' den Wert 'false', führt 'limit'
     die oben gezeigte Ersetzung nicht für unbekannte Funktionen 'f'
     aus.  Dies vermeidet Fehler wie zum Beispiel ein Ergebnis von 1 für
     den Grenzwert 'limit (f(n)/f(n+1), n, inf)'.  Hat 'limsubst' den
     Wert 'true', führt Maxima die oben gezeigte Ersetzung auch für
     unbekannte Funktionen 'f' aus.

     Beispiele:

     Die Funktion 'f' ist nicht definiert.  Maxima gibt im ersten Fall
     eine Substantivform zurück.  Im zweiten Fall nimmt Maxima den
     Grenzwert für die unbekannte Funktion als 'f(10)' an.

          (%i1) limit(f(x),x,10),limsubst:false;
          (%o1)                     limit   f(x)
                                    x -> 10
          (%i2) limit(f(x),x,10),limsubst:true;
          (%o2)                         f(10)

 -- Funktion: tlimit (<expr>, <x>, <val>, <dir>)
 -- Funktion: tlimit (<expr>, <x>, <val>)
 -- Funktion: tlimit (<expr>)

     Bestimmt den Grenzwert mit Hilfe der Taylor-Reihenwicklung des
     Ausdrucks 'expr', wenn die Variable <x> gegen den Wert 'val' aus
     der Richtung <dir> geht.  Diese Methode wird von 'limit'
     angewendet, wenn die Optionsvariable 'tlimswitch' den Wert 'true'
     ist.  Das ist der Standardwert.

 -- Optionsvariable: tlimswitch
     Standardwert: 'true'

     Hat 'tlimswitch' den Wert 'true', nutzt die Funktion 'limit' eine
     Taylor-Reihenentwicklung, wenn der Grenzwert nicht mit anderen
     Methoden bestimmt werden kann.


File: maxima.info,  Node: Funktionen und Variablen der Differentiation,  Next: Integration,  Prev: Funktionen und Variablen für Grenzwerte,  Up: Analysis

16.2 Funktionen und Variablen der Differentiation
=================================================

 -- Funktion: at (<expr>, [<eqn_1>, ..., <eqn_n>])
 -- Funktion: at (<expr>, <eqn>)

     Wertet den Ausdruck <expr> aus, wobei dessen Variablen die Werte
     annehmen, die in der Liste der Gleichungen '[<eqn_1>, ...,
     <eqn_n>]' oder in der einzelnen Gleichung <eqn> angegeben sind.

     Wenn ein Teilausdruck von einer Variablen abhängt, für die ein Wert
     angegeben ist, aber kein 'atvalue', und er auch sonst nicht
     ausgewertet werden kann, dann wird von 'at' eine Substantivform
     zurückgegeben.

     'at' führt mehrfache Ersetzungen parallel aus.

     Siehe auch 'atvalue'.  Für andere Funktionen, die Ersetzungen
     ausführen, siehe weiterhin 'subst' und 'ev'.

     Beispiele:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x, y)^2 - u(x, y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1

 -- Funktion: antid (<expr>, <x>, <u(x)>)

     Gibt eine Liste mit zwei Elementen zurück aus denen die
     Stammfunktion des Ausdrucks <expr> mit der Variablen <x>
     konstruiert werden kann.  Der Ausdruck <expr> kann eine unbekannte
     Funktion <u> und deren Ableitungen enthalten.  Ist <L> das Ergebnis
     der Funktion 'antid', dann ist der Ausdruck '<L>[1]+
     'integrate(<L>[2], <x>)' die gesuchte Stammfunktion des Ausdrucks
     <expr> mit der Variablen <x>.

     Kann 'antid' die Stammfunktion vollständig bestimmen, ist das
     zweite Element der Liste Null.  Hat 'antid' keinerlei Erfolg, ist
     das erste Element der Liste Null.  In anderen Fällen enthält das
     erste Elemente den integrierbaren Anteil des Ausdrucks <expr> und
     das zweite Element den nicht integrierbaren Anteil des Ausdrucks.

     Mit dem Kommando 'load(antid)' wird die Funktion geladen.

     'antid' steht in folgender Beziehung zur Funktion 'antidiff'.  Ist
     <L> die Liste mit den Ergebnissen der Funktion 'antid', dann hat
     die Funktion 'antidiff' das Ergebnis '<L>[1] + 'integrate(<L>[2],
     <x>)' mit <x> als der Variablen des Ausdrucks <expr>.

     Beispiele:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /

 -- Funktion: antidiff (<expr>, <x>, <u>(<x>))

     Gibt die Stammfunktion des Ausdrucks <expr> mit der Variablen <x>
     zurück.  Der Ausdruck <expr> kann eine unbekannte Funktion <u> und
     deren Ableitungen enthalten.

     Kann 'antidiff' die Stammfunktion nicht oder nur teilweise
     bestimmen, enthält das Ergebnis das Integral des nicht bestimmbaren
     Anteils.

     Mit dem Kommando 'load(antid)' wird die Funktion geladen.

     'antidiff' steht in folgender Beziehung zur Funktion 'antid'.  Ist
     <L> die Liste mit den Ergebnissen der Funktion 'antid', dann hat
     die Funktion 'antidiff' das Ergebnis '<L>[1] + 'integrate(<L>[2],
     <x>)' mit <x> als der Variablen des Ausdrucks <expr>.

     Für Beispiele und weitere Ausführungen siehe die Funktion 'antid'.

 -- Eigenschaft: atomgrad

     Wird für ein Symbol eine Ableitung mit der Funktion 'gradef'
     definiert, dann erhält das Symbol die Eigenschaft 'atomgrad'.

 -- Funktion: atvalue (<expr>, [<x_1> = <a_1>, ..., <x_m> = <a_m>], <c>)
 -- Funktion: atvalue (<expr>, <x_1> = <a_1>, <c>)

     Dem Ausdruck <expr> wird der Wert <c> am Punkt '<x> = <a>'
     zugewiesen.  Typischerweise werden Randwerte mit der Funktion
     'atvalue' definiert.

     Der Ausdruck <expr> ist entweder eine Funktion '<f>(<x_1>, ...,
     <x_m>)' oder die Ableitung einer Funktion 'diff(<f>(<x_1>, ...,
     <x_m>), <x_1>, <n_1>, ..., <x_n>, <n_m>)'.  Die Argumente müssen
     explizit auftreten.  <n_i> ist die Ordnung der Ableitung bezüglich
     der Variablen <x_i>.

     Die Randwerte werden durch die Liste '[<x_1> = <a_1>, ..., <x_m> =
     <a_m>]' definiert.  Eine einzelne Gleichung muss nicht als Liste
     angegeben werden.

     'printprops([<f_1>, <f_2>, ...], atvalue)' zeigt die Randwerte der
     Funktionen '<f_1>, <f_2>, ...' wie sie mit der Funktion 'atvalue'
     definiert wurden.  'printprops (<f>, atvalue)' zeigt nur die
     Randwerte für die Funktion <f>.  'printprops (all, atvalue)' zeigt
     die Randwerte aller Funktionen.

     Die Symbole '@1', '@2', ... repräsentieren die Variablen <x_1>,
     <x_2>, ..., wenn die Randwerte angezeigt werden.

     'atvalue' wertet die Argumente aus.  'atvalue' gibt den Randwert
     <c> zurück.

     Beispiele:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x,y)^2 - u(x,y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1

 -- Paket: cartan

     The exterior calculus of differential forms is a basic tool of
     differential geometry developed by Elie Cartan and has important
     applications in the theory of partial differential equations.  The
     'cartan' package implements the functions 'ext_diff' and
     'lie_diff', along with the operators '~' (wedge product) and '|'
     (contraction of a form with a vector.)  Type 'demo (tensor)' to see
     a brief description of these commands along with examples.

     'cartan' was implemented by F.B. Estabrook and H.D. Wahlquist.

 -- Funktion: del (<x>)

     'del(<x>)' repräsentiert das Differential der Variablen <x>.

     'diff' gibt Ausdrücke zurück, die Differentiale enthalten, wenn
     keine Variablen angegeben sind, nach denen abgeleitet werden soll.
     In diesem Fall gibt 'diff' das totale Differential zurück.

     Beispiele:

          (%i1) diff (log (x));
                                       del(x)
          (%o1)                        ------
                                         x
          (%i2) diff (exp (x*y));
                               x y              x y
          (%o2)            x %e    del(y) + y %e    del(x)
          (%i3) diff (x*y*z);
          (%o3)         x y del(z) + x z del(y) + y z del(x)

 -- Funktion: delta (<t>)

     Die Diracsche Delta-Funktion.

     Maxima kennt die Delta-Funktion nur im Zusammenhang mit
     Laplace-Transformationen.  Siehe 'laplace'.

     Beispiel:

          (%i1) laplace (delta (t - a) * sin(b*t), t, s);
          Is  a  positive, negative, or zero?

          p;
                                             - a s
          (%o1)                   sin(a b) %e

 -- Systemvariable: dependencies
     Standardwert: '[]'

     'dependencies' ist eine Liste der Symbole, für die eine
     Abhängigkeit mit den Funktionen 'depends' oder 'gradef' definiert
     wurde.  Siehe 'depends' und 'gradef'.

 -- Funktion: depends (<f_1>, <x_1>, ..., <f_n>, <x_n>)

     Definiert die Abhängigkeit einer Funktion <f> von einer Variablen
     <x>.  Ist keine Abhängigkeit definiert, dann hat die Ableitung
     'diff(f, x)' das Ergebnis Null.  Wird mit dem Kommando 'depends(f,
     x)' definiert, dass die Funktion <f> von der Variablen <x> abhängt,
     dann ist das Ergebnis der Ableitung die Substantivform
     ''diff(f,x,1)'.

     Jedes Argument <f_1>, <x_1>, ... kann der Name einer Variablen,
     eines Arrays oder eine Liste mit Namen sein.  Jedes Symbol <f_i>
     hängt ab von den Symbolen der Liste <x_i>.  Ist eines der Symbole
     <f_i> der Name eines Arrays, dann hängen alle Elemente des Arrays
     von <x_i> ab.

     'diff' erkennt indirekte Abhängigkeiten und wendet für diesen Fall
     die Kettenregel an.

     'remove(<f>, dependency)' entfernt alle Abhängigkeiten, die für <f>
     definiert wurden.

     'depends' gibt eine Liste der Abhängigkeiten zurück.  Die
     Abhängigkeiten werden in die Informationsliste 'dependencies'
     eingetragen.  'depends' wertet die Argumente aus.

     Die Funktion 'diff' ist die einzige Maxima-Funktion, die
     Abhängigkeiten erkennt, die mit 'depends' definiert wurden.  Andere
     Funktionen wie 'integrate' oder 'laplace' erkennen keine
     Abhängigkeiten, die mit der 'depends' definiert wurden.  Für diese
     Funktionen müssen die Abhängigkeiten explizit angegeben werden, zum
     Beispiel als 'integrate(f(x), x)'.

     Beispiele:

          (%i1) depends ([f, g], x);
          (%o1)                     [f(x), g(x)]
          (%i2) depends ([r, s], [u, v, w]);
          (%o2)               [r(u, v, w), s(u, v, w)]
          (%i3) depends (u, t);
          (%o3)                        [u(t)]
          (%i4) dependencies;
          (%o4)      [f(x), g(x), r(u, v, w), s(u, v, w), u(t)]
          (%i5) diff (r.s, u);
                                   dr           ds
          (%o5)                    -- . s + r . --
                                   du           du

          (%i6) diff (r.s, t);
                                dr du           ds du
          (%o6)                 -- -- . s + r . -- --
                                du dt           du dt

          (%i7) remove (r, dependency);
          (%o7)                         done
          (%i8) diff (r.s, t);
                                          ds du
          (%o8)                       r . -- --
                                          du dt

 -- Optionsvariable: derivabbrev
     Standardwert: 'false'

     Hat 'derivabbrev' den Wert 'true', werden symbolische Ableitungen
     mit einem tiefgestellten Index angezeigt.  Ansonsten werden
     Ableitungen als 'dy/dx' angezeigt.

     Beispiel:

          (%i1) derivabbrev:false$

          (%i2) 'diff(y,x);
                                         dy
          (%o2)                          --
                                         dx
          (%i3) derivabbrev:true$

          (%i4) 'diff(y,x);
          (%o4)                          y
                                          x

 -- Funktion: derivdegree (<expr>, <y>, <x>)

     Gibt die höchste Ableitung des Arguments <y> in Bezug auf die
     Variable <x> zurück, die in dem Ausdruck <expr> enthalten ist.

     Beispiel:

          (%i1) 'diff (y, x, 2) + 'diff (y, z, 3) + 'diff (y, x) * x^2;
                                   3     2
                                  d y   d y    2 dy
          (%o1)                   --- + --- + x  --
                                    3     2      dx
                                  dz    dx
          (%i2) derivdegree (%, y, x);
          (%o2)                           2

 -- Auswertungsschalter: derivlist (<var_1>, ..., <var_k>)

     'derivlist' ist ein Auswertungsschalter für die Funktion 'ev'.
     'ev' führt nur die Ableitungen in Bezug auf die angegebenen
     Variablen <var_1>, ..., <var_k> aus.  Siehe auch 'ev'.

 -- Optionsvariable: derivsubst
     Standardwert: 'false'

     Hat 'derivsubst' den Wert 'true', werden Substitutionen auch in
     Ausdrücke mit Ableitungen ausgeführt.  Zum Beispiel hat dann
     'subst(x, 'diff(y, t), 'diff(y, t, 2))' das Ergebnis ''diff(x, t)'.

 -- Funktion: diff (<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)
 -- Funktion: diff (<expr>, <x>, <n>)
 -- Funktion: diff (<expr>, <x>)
 -- Funktion: diff (<expr>)
 -- Auswertungsschalter: diff

     Gibt die Ableitungen oder Differentiale des Ausdrucks <expr> in
     Bezug auf alle oder einige der Variablen des Ausdrucks zurück.

     'diff(<expr>, <x>, <n>)' gibt die n-te Ableitung des Ausdrucks
     <expr> in Bezug auf die Variable <x> zurück.

     'diff(<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)' gibt die partielle
     Ableitung des Ausdrucks <expr> in Bezug auf die Variablen <x_1>,
     ..., <x_m> zurück.  Dies ist äquivalent zu 'diff(... (diff(<expr>,
     <x_m>, <n_m>) ...), <x_1>, <n_1>)'.

     'diff(<expr>, <x>)' gibt die erste Ableitung des Ausdrucks <expr>
     in Bezug auf die Variable <x> zurück.

     'diff(<expr>)' gibt das totale Differential des Ausdrucks <expr>
     zurück.  Siehe auch 'del'.

     Wenn die Ableitungen nicht ausgeführt werden sollen, kann der
     'Quote-Operator' ''' verwendet werden, um eine Substantivform der
     Ableitung zu erhalten.

     Hat 'derivabbrev' den Wert 'true', werden symbolische Ableitungen
     mit einem tiefgestelltem Index angezeigt.  Ansonsten werden
     Ableitungen als 'dy/dy' angezeigt.

     'diff' ist auch ein Auswertungsschalter für die Funktion 'ev'.  Das
     Kommando 'ev(expr), diff' bewirkt, dass alle Ableitungen ausgeführt
     werden, die im Ausdruck <expr> enthalten sind.  Siehe auch die
     Funktion 'ev'.

     'derivative' ist ein Alias-Name der Funktion 'diff'.

     Beispiele:

          (%i1) diff (exp (f(x)), x, 2);
                               2
                        f(x)  d               f(x)  d         2
          (%o1)       %e     (--- (f(x))) + %e     (-- (f(x)))
                                2                   dx
                              dx
          (%i2) derivabbrev: true$
          (%i3) 'integrate (f(x, y), y, g(x), h(x));
                                   h(x)
                                  /
                                  [
          (%o3)                   I     f(x, y) dy
                                  ]
                                  /
                                   g(x)
          (%i4) diff (%, x);
                 h(x)
                /
                [
          (%o4) I     f(x, y)  dy + f(x, h(x)) h(x)  - f(x, g(x)) g(x)
                ]            x                     x                  x
                /
                 g(x)

     For the tensor package, the following modifications have been
     incorporated:

       1. The derivatives of any indexed objects in <expr> will have the
          variables <x_i> appended as additional arguments.  Then all
          the derivative indices will be sorted.

       2. The <x_i> may be integers from 1 up to the value of the
          variable 'dimension' [default value: 4].  This will cause the
          differentiation to be carried out with respect to the <x_i>'th
          member of the list 'coordinates' which should be set to a list
          of the names of the coordinates, e.g., '[x, y, z, t]'.  If
          'coordinates' is bound to an atomic variable, then that
          variable subscripted by <x_i> will be used for the variable of
          differentiation.  This permits an array of coordinate names or
          subscripted names like 'X[1]', 'X[2]', ... to be used.  If
          'coordinates' has not been assigned a value, then the
          variables will be treated as in (1) above.

 -- Funktion: gradef (<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)
 -- Funktion: gradef (<a>, <x>, <expr>)

     Definiert eine partielle Ableitung der Funktion <f> oder Variablen
     <a>.

     Das Kommando 'gradef(<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)'
     definiert die partielle Ableitung 'd<f>/d<x_i>' als <g_i>.  <g_i>
     ist ein Ausdruck.  <g_i> kann ein Funktionsaufruf sein, aber nicht
     der Name einer Funktion.  Die Anzahl der partiellen Ableitungen <m>
     kann kleiner als die Anzahl der Argumente <n> sein.

     'gradef(<a>, <x>, <expr>)' definiert die Ableitung der Variablen
     <a> in Bezug auf die Variable <x> als <expr>.  Wie mit der Funktion
     'depends' wird <a> als abhängig von <x> deklariert.  Die
     Abhängigkeit wird in die Liste 'dependencies' eingetragen.  Siehe
     auch 'depends'.

     Bis auf das erste Argument werden die Argumente der Funktion
     'gradef' ausgewertet.  'gradef' gibt die Funktion oder Variable
     zurück, für die eine partielle Ableitung definiert wurde.

     'gradef' kann die Ableitungen von vorhandenen Maxima-Funktionen neu
     definieren.  Zum Beispiel definiert 'gradef(sin(x), sqrt (1 -
     sin(x)^2))' eine neue Ableitung der Sinusfunktion.

     'gradef' kann keine partiellen Ableitungen für indizierte
     Funktionen definieren.

     'printprops([<f_1>, ..., <f_n>], gradef)' zeigt die mit 'gradef'
     definierten partiellen Ableitungen der Funktionen <f_1>, ..., <f_n>
     an und 'printprops([<a_n>, ..., <a_n>], atomgrad)' zeigt die mit
     'gradef' definierten partiellen Ableitungen der Variablen <a_n>,
     ..., <a_n> an.  Siehe 'printprops'.

     'gradefs' ist eine Informationsliste, die die Funktionen enthält,
     für die mit 'gradef' eine Ableitung definierte wurde.  Die Liste
     enthält keine Variablen, für die Ableitungen definiert wurden.

 -- Systemvariable: gradefs
     Standardwert: '[]'

     'gradefs' ist eine Liste der Funktionen, für die eine Ableitung mit
     der Funktion 'gradef' definiert wurde.


File: maxima.info,  Node: Integration,  Next: Differentialgleichungen,  Prev: Funktionen und Variablen der Differentiation,  Up: Analysis

16.3 Integration
================

* Menu:

* Einführung in die Integration::
* Funktionen und Variablen der Integration::
* Einführung in QUADPACK::
* Funktionen und Variablen für QUADPACK::


File: maxima.info,  Node: Einführung in die Integration,  Next: Funktionen und Variablen der Integration,  Prev: Integration,  Up: Integration

16.3.1 Einführung in die Integration
------------------------------------

Maxima hat verschiedene Algorithmen, um Integrale zu behandeln.  Die
Funktion 'integrate' nutzt diese.  Maxima hat ein Paket 'antid', welches
Integrale mit einer unbekannten Funktion, deren Ableitung bekannt ist,
integrieren kann.  Für die numerische Berechnung von Integralen hat
Maxima das Paket 'QUADPACK' mit Funktionen wie 'quad_qag' oder
'quad_qags'.  Die Funktionen 'laplace' und 'specint' finden die
Laplacetransformation.  Wird das Paket 'abs_integrate' geladen, kann
Maxima weitere Integrale lösen.  Dazu gehören insbesondere Integrale mit
der Betragsfunktion 'abs' und der Signum-Funktion 'signum'.  Siehe auch
*note abs_integrate::.


File: maxima.info,  Node: Funktionen und Variablen der Integration,  Next: Einführung in QUADPACK,  Prev: Einführung in die Integration,  Up: Integration

16.3.2 Funktionen und Variablen der Integration
-----------------------------------------------

 -- Funktion: changevar (<expr>, <f(x,y)>, <y>, <x>)

     Führt eine Substitution der Integrationsvariablen, die als
     <f(x,y)=0> angegeben wird, für die Variable <x> in allen Integralen
     durch, die in <expr> enthalten sind.  Die neue Variable ist <y>.

          (%i1) assume(a > 0)$
          (%i2) 'integrate (%e**sqrt(a*y), y, 0, 4);
                                4
                               /
                               [    sqrt(a) sqrt(y)
          (%o2)                I  %e                dy
                               ]
                               /
                                0
          (%i3) changevar (%, y-z^2/a, z, y);
                                0
                               /
                               [                abs(z)
                             2 I            z %e       dz
                               ]
                               /
                                - 2 sqrt(a)
          (%o3)            - ----------------------------
                                          a

     Ein Ausdruck mit einem Integral in einer Substantivform
     ''integrate' wie im obigen Beispiel kann mit der Funktion 'ev' und
     dem Auswertungsschalter 'nouns' ausgewertet werden.  Das Beispiel
     von oben kann zum Beispiel mit 'ev(%o3, nouns)' ausgewertet werden.

     Mit 'changevar' können auch die Indizes einer Summe oder eines
     Produktes substituiert werden.  Dabei muss beachtet werden, dass
     nur lineare Verschiebungen, wie zum Beispiel 'i = j + ...', eine
     korrekte Substitution für Summen und Produkte sind.

          (%i4) sum (a[i]*x^(i-2), i, 0, inf);
                                   inf
                                   ====
                                   \         i - 2
          (%o4)                     >    a  x
                                   /      i
                                   ====
                                   i = 0
          (%i5) changevar (%, i-2-n, n, i);
                                  inf
                                  ====
                                  \               n
          (%o5)                    >      a      x
                                  /        n + 2
                                  ====
                                  n = - 2

 -- Funktion: dblint (<f>, <r>, <s>, <a>, <b>)

     Eine Routine, um ein bestimmtes doppeltes Integral mit der
     Simpsonschen Regel numerisch zu berechnen.

                b  s(x)
               /  /
               [  [
               I  I     f(x, y) dy dx
               ]  ]
               /  /
                a  r(x)

     Die Funktion <f> muss eine Funktion von zwei Variablen sein.  <r>
     und <s> müssen Funktionen einer Variablen sein.  <a> und <b> sind
     Gleitkommazahlen.  Die Optionsvariablen 'dblint_x' und 'dblint_y'
     kontrollieren die Anzahl der Unterteilungen des
     Integrationsintervalls für den Simpsonschen Algorithmus.  Der
     Standardwert ist jeweils 10.

     Das Kommando 'demo(dblint)' zeigt ein Beispiel.

     Die numerischen Funktionen des Pakets 'QUADPACK' sind gegenüber
     'dblint' zu bevorzugen.

 -- Funktion: defint (<expr>, <x>, <a>, <b>)

     Sucht das bestimmte Integral eines Ausdrucks <expr> für die
     Integrationsvariable <x> in den Grenzen <a> und <b>.  Diese
     Funktion wird ausgeführt, wenn ein bestimmtes Integral mit der
     Funktion 'integrate' gesucht wird.

     'defint' gibt einen symbolischen Ausdruck als Ergebnis zurück.  Ist
     das Integral divergent, generiert Maxima eine Fehlermeldung.  Kann
     'defint' keine Lösung finden, wird eine Substantivform
     zurückgegeben.

 -- Optionsvariable: erfflag
     Standardwert: 'true'

     Hat 'erfflag' den Wert 'false', wird von der Funktion 'risch' die
     Fehlerfunktion 'erf' nicht in die Lösung eingeführt.

 -- Funktion: ilt (<expr>, <s>, <t>)

     Berechnet die Inverse Laplace-Transformation des Ausdrucks <expr>
     für die Variable <s> und den Parameter <t>.  <expr> muss eine
     rationale Funktion sein, in deren Nenner nur lineare und
     quadratische Faktoren auftreten.  Mit den Funktionen 'laplace' und
     'ilt' sowie den Funktionen 'solve' oder 'linsolve' können lineare
     Differentialgleichungen oder Systeme von linearen
     Differentialgleichungen gelöst werden.

          (%i1) 'integrate (sinh(a*x)*f(t-x), x, 0, t) + b*f(t) = t**2;
                        t
                       /
                       [                                    2
          (%o1)        I  f(t - x) sinh(a x) dx + b f(t) = t
                       ]
                       /
                        0
          (%i2) laplace (%, t, s);
                                         a laplace(f(t), t, s)   2
          (%o2)  b laplace(f(t), t, s) + --------------------- = --
                                                 2    2           3
                                                s  - a           s
          (%i3) linsolve ([%], ['laplace(f(t), t, s)]);
                                                  2      2
                                               2 s  - 2 a
          (%o3)     [laplace(f(t), t, s) = --------------------]
                                              5         2     3
                                           b s  + (a - a  b) s
          (%i4) ilt (rhs (first (%)), s, t);
          Is  a b (a b - 1)  positive, negative, or zero?

          pos;
                         sqrt(a b (a b - 1)) t
                  2 cosh(---------------------)       2
                                   b               a t
          (%o4) - ----------------------------- + -------
                        3  2      2               a b - 1
                       a  b  - 2 a  b + a

                                                                 2
                                                       + ------------------
                                                          3  2      2
                                                         a  b  - 2 a  b + a

 -- Optionsvariable: intanalysis
     Standardwert: 'true'

     Hat 'intanalysis' den Wert 'true', sucht Maxima nach Polen in einem
     Integranden.  Existieren solche, wird der Cauchysche Hauptwert des
     Integrals bestimmt.  Hat 'intanalysis' den Wert 'false', wird die
     Integration unter der Annahme ausgeführt, dass das Integral keine
     Pole im Integrationsbereich hat.

     Siehe auch 'ldefint'.

     Beispiele:

     Maxima kann das folgende Integral lösen, wenn 'intanalysis' den
     Wert 'false' hat.

          (%i1) integrate(1/(sqrt(x)+1),x,0,1);
                                          1
                                         /
                                         [       1
          (%o1)                          I  ----------- dx
                                         ]  sqrt(x) + 1
                                         /
                                          0

          (%i2) integrate(1/(sqrt(x)+1),x,0,1),intanalysis:false;
          (%o2)                            2 - 2 log(2)

          (%i3) integrate(cos(a)/sqrt((tan(a))^2 +1),a,-%pi/2,%pi/2);
          The number 1 isn't in the domain of atanh
           -- an error. To debug this try: debugmode(true);

          (%i4) intanalysis:false$
          (%i5) integrate(cos(a)/sqrt((tan(a))^2+1),a,-%pi/2,%pi/2);
                                                %pi
          (%o5)                                 ---
                                                 2

 -- Funktion: integrate (<expr>, <x>)
 -- Funktion: integrate (<expr>, <x>, <a>, <b>)

     Sucht die symbolische Lösung des Integrals für den Ausdruck <expr>
     und der Integrationsvariablen <x>.  'integrate(<expr>, <x>)' löst
     das unbestimmte Integral.

     'integrate(<expr>, <x>, <a>, <b>)' sucht die Lösung des bestimmten
     Integrals in den Integrationsgrenzen <a> und <b>.  Die
     Integrationsgrenzen dürfen die Integrationsvariable <x> nicht
     enthalten.  Für die Integrationsgrenzen muss nicht gelten <a> <
     <b>.  Sind die Integrationsgrenzen gleich, dann ist das Ergebnis
     der Integration Null.

     Für die numerische Lösung von Integralen siehe die Funktion
     'quad_qag' und verwandte Funktionen.  Residuen eines Integranden
     können mit der Funktion 'residue' berechnet werden.  Einen
     alternativen Algorithmus für das Lösen von Integralen, die im
     Integranden eine unbekannte Funktion und deren Ableitung enthalten,
     bieten die Funktionen 'antid' und 'antidiff'.

     Findet 'integrate' keine Lösung wird eine Substantivform oder ein
     Ausdruck mit einer oder mehreren Substantivformen zurückgegeben.

     Soll das Integral nicht sofort berechnet werden, kann die
     Substantivform des Integrals angegeben werden, zum Beispiel
     ''integrate(<expr>, <x>)'.  Die Berechnung des Integrals ist dann
     mit Funktion 'ev' und dem Auswertungsschalter 'nouns' möglich.

     Die Abhängigkeit der Funktionen im Integranden von Variablen muss
     explizit zum Beispiel mit 'f(x)' angegeben werden.  'integrate'
     beachtet keine Abhängigkeit die mit der Funktion 'depends'
     definiert werden.

     Benötigt 'integrate' Informationen zu einem Parameter, die nicht
     aus dem aktuellen Kontext abgeleitet werden können, wird der Nutzer
     nach den fehlenden Informationen gefragt.

     'integrate' ist standardmäßig nicht als linear deklariert.  Siehe
     'declare' und 'linear'.

     Nur in einigen speziellen Fällen wendet 'integrate' die Methode der
     partiellen Integration an.

     Beispiele:

     Elementare unbestimmte und bestimme Integrale.

          (%i1) integrate (sin(x)^3, x);
                                     3
                                  cos (x)
          (%o1)                   ------- - cos(x)
                                     3
          (%i2) integrate (x/ sqrt (b^2 - x^2), x);
                                           2    2
          (%o2)                    - sqrt(b  - x )
          (%i3) integrate (cos(x)^2 * exp(x), x, 0, %pi);
                                         %pi
                                     3 %e      3
          (%o3)                      ------- - -
                                        5      5
          (%i4) integrate (x^2 * exp(-x^2), x, minf, inf);
                                      sqrt(%pi)
          (%o4)                       ---------
                                          2

     Gebrauch von 'assume' und interaktive Fragen.

          (%i1) assume (a > 1)$
          (%i2) integrate (x**a/(x+1)**(5/2), x, 0, inf);
              2 a + 2
          Is  -------  an integer?
                 5

          no;
          Is  2 a - 3  positive, negative, or zero?

          neg;
                                             3
          (%o2)                  beta(a + 1, - - a)
                                             2

     Substitution der Integrationsvariablen.  In diesem Beispiel werden
     zwei verschiedene Substitutionen vorgenommen.  Zuerst wird eine
     Ableitung der Funktion mit der Funktion 'gradef' definiert.  Die
     andere nutzt die Ableitung 'diff(r(x))' einer unbekannten Funktion
     'r(x)'.

          (%i3) gradef (q(x), sin(x^2));
          (%o3)                         q(x)
          (%i4) diff (log (q (r (x))), x);
                                d               2
                               (-- (r(x))) sin(r (x))
                                dx
          (%o4)                ----------------------
                                      q(r(x))
          (%i5) integrate (%, x);
          (%o5)                     log(q(r(x)))

     Die Lösung enthält eine Substantivform für das Integral einer
     rationalen Funktion.  Siehe auch 'integrate_use_rootsof' für
     Informationen zu Integralen von rationalen Funktionen.

          (%i1) expand ((x-4) * (x^3+2*x+1));
                              4      3      2
          (%o1)              x  - 4 x  + 2 x  - 7 x - 4
          (%i2) integrate (1/%, x);
                                        /  2
                                        [ x  + 4 x + 18
                                        I ------------- dx
                                        ]  3
                           log(x - 4)   / x  + 2 x + 1
          (%o2)            ---------- - ------------------
                               73               73

     Definition einer Funktion als ein Integral.  Die rechte Seite einer
     Funktionsdefinition wird nicht ausgewertet.  Daher enthält die
     Funktionsdefinition das Integral in einer Substantivform.  Der
     'Quote-Quote-Operator' '''' erzwingt die Auswertung der
     Substantivform.

          (%i1) f_1(a) := integrate (x^3, x, 1, a);
                                               3
          (%o1)           f_1(a) := integrate(x , x, 1, a)
          (%i2) ev(f_1 (7), nouns);
          (%o2)                          600
          (%i3) /* Note parentheses around integrate(...) here */
                f_2(a) := ''(integrate (x^3, x, 1, a));
                                             4
                                            a    1
          (%o3)                   f_2(a) := -- - -
                                            4    4
          (%i4) f_2(7);
          (%o4)                          600

 -- Optionsvariable: integration_constant
     Standardwert: '%c'

     Wird eine symbolische Integrationskonstante für die Lösung eines
     Integrals benötigt, erzeugt Maxima diese durch Verkettung des
     Symbols 'integration_constant' mit einer laufenden Nummer, die der
     Wert der Optionsvariablen 'integration_constant_counter' ist.

     Der Optionsvariablen 'integration_constant' kann ein beliebiges
     Symbol zugewiesen werden.

     Beispiele:

          (%i1) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o1)                     -- = x + %c1
                                    3
          (%i2) integration_constant : 'k;
          (%o2)                           k
          (%i3) integrate (x^2 = 1, x);
                                      3
                                     x
          (%o3)                      -- = x + k2
                                     3

 -- Systemvariable: integration_constant_counter
     Standardwert: 0

     Wird eine symbolische Integrationskonstante für die Lösung eines
     Integrals benötigt, erzeugt Maxima diese durch Verkettung des
     Symbols 'integration_constant' mit einer laufenden Nummer, die der
     Wert der Optionsvariablen 'integration_constant_counter' ist.

     Der Wert der Systemvariablen 'integration_constant_counter' wird
     vor der Erzeugung der Integrationskonstanten erhöht.

     Beispiele:

          (%i1) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o1)                     -- = x + %c1
                                    3
          (%i2) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o2)                     -- = x + %c2
                                    3
          (%i3) reset (integration_constant_counter);
          (%o3)            [integration_constant_counter]
          (%i4) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o4)                     -- = x + %c1
                                    3

 -- Optionsvariable: integrate_use_rootsof
     Standardwert: 'false'

     Hat 'integrate_use_rootsof' den Wert 'true' und der Nenner einer
     rationalen Funktion kann nicht faktorisiert werden, dann gibt
     'integrate' ein Integral zurück, das eine Summe über die
     unbekannten Wurzeln des Nenners enthält.

     Hat zum Beispiel 'integrate_use_rootsof' den Wert 'false', gibt
     'integrate' im Folgenden ein Lösung zurück, die eine Substantivform
     enthält.

          (%i1) integrate_use_rootsof: false$
          (%i2) integrate (1/(1+x+x^5), x);
                  /  2
                  [ x  - 4 x + 5
                  I ------------ dx                            2 x + 1
                  ]  3    2                2            5 atan(-------)
                  / x  - x  + 1       log(x  + x + 1)          sqrt(3)
          (%o2)   ----------------- - --------------- + ---------------
                          7                 14             7 sqrt(3)

     Mit dem Wert 'true' für die Optionsvariable 'integrate_use_rootsof'
     wird das ungelöste Integral als eine Summe über die Wurzeln des
     Nenners der rationalen Funktion zurückgegeben.

          (%i3) integrate_use_rootsof: true$
          (%i4) integrate (1/(1+x+x^5), x);
                ====        2
                \       (%r4  - 4 %r4 + 5) log(x - %r4)
                 >      -------------------------------
                /                    2
                ====            3 %r4  - 2 %r4
                                3    2
                %r4 in rootsof(x  - x  + 1)
          (%o4) ----------------------------------------------------------
                         7

                                                                2 x + 1
                                            2            5 atan(-------)
                                       log(x  + x + 1)          sqrt(3)
                                     - --------------- + ---------------
                                             14             7 sqrt(3)

     Alternativ kann der Nutzer die Wurzeln des Nenners separat
     berechnen und den Integranden mit Hilfe der Wurzeln ausdrücken.
     Zum Beispiel als '1/((x - a)*(x - b)*(x - c))' oder
     '1/((x^2-(a+b)*x + a*b)*(x - c))' für ein kubisches Polynom mit
     drei Nullstellen im Nenner.  Auf diese Weise kann Maxima in einigen
     Fällen eine Lösung für ein Integral finden.

 -- Funktion: laplace (<expr>, <t>, <s>)

     Sucht die Laplace-Transformation des Ausdrucks <expr> für die
     Integrationsvariable <x> und den Parameter <s>.

     'laplace' findet die Laplace-Transformation für Ausdrücke, die die
     Funktionen 'delta', 'exp', 'log', 'sin', 'cos', 'sinh', 'cosh' und
     'erf' sowie Ausdrücke mit 'derivative', 'integrate', 'sum' und
     'ilt' enthalten.

     Kann 'laplace' die Laplace-Transformation nicht finden, wird die
     Funktion 'specint' aufgerufen.  'specint' kann die
     Laplace-Transformation für eine Vielzahl von speziellen Funktionen
     im Integranden berechnen.  Findet auch 'specint' keine Lösung ist
     das Ergebnis eine Substantivform.

     'laplace' erkennt die Faltung von Funktionen der Form 'integrate
     (f(x) * g(t - x), x, 0, t)'.  Andere Faltungen werden nicht
     erkannt.

     Funktionale Abhängigkeiten von Variablen müssen explizit angegeben
     werden.  'laplace' erkennt keine Abhängigkeiten, die mit der
     Funktion 'depends' definiert wurden.  Eine Funktion die von den
     Variablen <x> abhängt, muss als 'f(x)' im Ausdruck <expr>
     auftreten.

     Siehe auch 'ilt' für die Inverse Laplace-Transformation.

     Beispiele:

          (%i1) laplace (exp (2*t + a) * sin(t) * t, t, s);
                                      a
                                    %e  (2 s - 4)
          (%o1)                    ---------------
                                     2           2
                                   (s  - 4 s + 5)
          (%i2) laplace ('diff (f (x), x), x, s);
          (%o2)             s laplace(f(x), x, s) - f(0)
          (%i3) diff (diff (delta (t), t), t);
                                    2
                                   d
          (%o3)                    --- (delta(t))
                                     2
                                   dt
          (%i4) laplace (%, t, s);
                                      !
                         d            !         2
          (%o4)        - -- (delta(t))!      + s  - delta(0) s
                         dt           !
                                      !t = 0
          (%i5) assume(a>0)$
          (%i6) laplace(gamma_incomplete(a,t),t,s),gamma_expand:true;
                                                        - a - 1
                                   gamma(a)   gamma(a) s
          (%o6)                    -------- - -----------------
                                      s            1     a
                                                  (- + 1)
                                                   s
          (%i7) factor(laplace(gamma_incomplete(1/2,t),t,s));
                                                        s + 1
                                sqrt(%pi) (sqrt(s) sqrt(-----) - 1)
                                                          s
          (%o7)                 -----------------------------------
                                          3/2      s + 1
                                         s    sqrt(-----)
                                                     s
          (%i8) assume(exp(%pi*s)>1)$
          (%i9) laplace(sum((-1)^n*unit_step(t-n*%pi)*sin(t),n,0,inf),t,s)
                  ,simpsum;
                                   %i                         %i
                        ------------------------ - ------------------------
                                        - %pi s                    - %pi s
                        (s + %i) (1 - %e       )   (s - %i) (1 - %e       )
          (%o9)         ---------------------------------------------------
                                                 2
          (%i9) factor(%);
                                                %pi s
                                              %e
          (%o9)                   -------------------------------
                                                       %pi s
                                  (s - %i) (s + %i) (%e      - 1)

 -- Funktion: ldefint (<expr>, <x>, <a>, <b>)

     Sucht die Lösung des bestimmten Integrals für den Integranden
     <expr>.  'ldefint' bestimmt die Stammfunktion und sucht die
     Grenzwerte mit der Funktion 'limit' an den Integrationsgrenzen <a>
     und <b>.  Kann ein Grenzwert nicht ermittelt werden, enthält das
     Ergebnis die Substantivform des Grenzwertes.

     'ldefint' wird nicht von der Funktion 'integrate' aufgerufen.
     Daher kann 'ldefint' ein von 'integrate' verschiedenes Ergebnis
     haben.  'ldefint' verwendet immer denselben Algorithmus, um eine
     Lösung zu finden.  Dagegen wendet 'integrate' verschiedene
     Algorithmen an, um nach einer Lösung zu suchen.

 -- Funktion: residue (<expr>, <z>, <z_0>)

     Berechnet das Residuum für den Ausdruck <expr>, wenn die Variable
     <z> gegen den Wert <z_0> geht.

     Beispiele:

          (%i1) residue (s/(s**2+a**2), s, a*%i);
                                          1
          (%o1)                           -
                                          2
          (%i2) residue (sin(a*x)/x**4, x, 0);
                                           3
                                          a
          (%o2)                         - --
                                          6

 -- Funktion: risch (<expr>, <x>)

     Nutzt den transzendenten Risch-Algorithmus für die Integration des
     Ausdruck <expr> und der Integrationsvariable <x>.  Der algebraische
     Risch-Algorithmus ist nicht implementiert.  Der transzendente
     Risch-Algorithmus behandelt Integranden mit Exponential- und
     Logarithmusfunktionen.  Der Risch-Algorithmus wird von 'integrate'
     aufgerufen, wenn 'integrate' keine Stammfunktion finden kann.

     Hat 'erfflag' den Wert 'false', werden von der Funktion 'risch'
     keine Fehlerfunktionen 'erf' in die Lösung eingeführt.

     Beispiele:

          (%i1) risch (x^2*erf(x), x);
                                                                  2
                       3                      2                - x
                  %pi x  erf(x) + (sqrt(%pi) x  + sqrt(%pi)) %e
          (%o1)   -------------------------------------------------
                                        3 %pi
          (%i2) diff(%, x), ratsimp;
                                       2
          (%o2)                       x  erf(x)

 -- Funktion: tldefint (<expr>, <x>, <a>, <b>)

     Entspricht der Funktion 'ldefint' mit dem Wert 'true' für die
     Optionsvariable 'tlimswitch'.


File: maxima.info,  Node: Einführung in QUADPACK,  Next: Funktionen und Variablen für QUADPACK,  Prev: Funktionen und Variablen der Integration,  Up: Integration

16.3.3 Einführung in QUADPACK
-----------------------------

QUADPACK ist eine Sammlung von Funktionen für die numerische Berechnung
von eindimensionalen bestimmten Integralen.  QUADPACK hat den Ursprung
in einem Projekt von R. Piessens (1), E. de Doncker (2), C. Ueberhuber
(3), und D. Kahaner (4).

Die QUADPACK-Bibliothek, die in Maxima enthalten ist, ist eine
automatische Übersetzung des Fortran Quellcodes mit dem Programm 'f2cl'
wie er in der SLATEC Common Mathematical Library, Version 4.1 (5)
vorliegt.  Die SLATEC Bibliothek datiert auf Juli 1993.  Die QUADPACK
Funktionen wurden bereits einige Jahre früher programmiert.  Es gibt
eine weitere Version von QUADPACK bei Netlib (6).  Es ist jedoch unklar
worin sich diese von der SLATEC Version unterscheidet.

Alle QUADPACK-Funktionen versuchen automatisch, ein bestimmtes Integral
numerisch innerhalb eine spezifizierten Genauigkeit zu berechnen.  Die
Übersetzung nach Lisp enthält einige weitere nicht-automatische
Funktionen, die jedoch nicht als Maxima Funktionen zur Verfügung stehen.

Weitere Informationen über das QUADPACK-Paket sind in dem QUADPACK-Buch
(7) enthalten.

Übersicht über die Integrationsroutinen
.......................................

'quad_qag'
     Integration einer allgemeinen Funktion über ein endliches
     Intervall.  'quad_qag' implementiert einen globalen adaptiven
     Integrator auf Grundlage der Strategie von Aind (Piessens, 1973).
     Es kann aus 6 verschiedenen Paaren von
     Gauß-Kronrad-Quadraturformeln ausgewählt werden.  Die Formeln
     höheren Grades sind für stark oszillierende Integranden geeignet.

'quad_qags'
     Integration einer allgemeinen Funktion über ein endliches
     Intervall.  Die Funktion 'quad_qags' implementiert die Strategie
     einer globalen adaptiven Unterteilung des Integrationsintervalls
     mit Extrapolation (de Doncker, 1978).  Zusätzlich wird versucht,
     die Konvergenz der Integralapproximation mit Hilfe des
     Epsilon-Algorithmus (Wynn, 1956) zu beschleunigen.  Dies führt zum
     Beispiel bei Integranden mit Singularitäten, deren Lage und Typ
     unbekannt sind, zu einer Effizienzsteigerung.

'quad_qagi'
     Die Funktion 'quad_qagi' führt die Integration einer allgemeinen
     Funktion über ein unendliches oder halb-unendliches Intervall aus.
     Das Intervall wird auf ein endliches Intervall transformiert.  Das
     transformierte Integrationsproblem wird dann mit einer geringfügig
     modifizierten Algorithmus wie in 'quad_qags' gelöst.

'quad_qawo'
     Berechnung von Integralen mit den trigonometrischen
     Gewichtsfunktionen cos(omega x) f(x) oder sin(omega x) f(x) über
     ein endliches Intervall, wobei omega eine Konstante ist.  Der
     Algorithmus der Funktion 'quad_qawo' zur basiert auf eine
     modifizierte Clenshaw-Curtis-Technik.  'quad_qawo' wendet eine
     adaptive Unterteilung des Integrationsintervalls mit Extrapolation
     an, die vergleichbar mit dem Algorithmus von 'quad_qags' ist.
     Zusätzlich wird versucht, die Konvergenz der Integralapproximation
     mit Hilfe des Epsilon-Algorithmus (Wynn, 1956) zu beschleunigen.

'quad_qawf'
     Die Funktion 'quad_qawf' berechnet die Sinus- oder
     Kosinus-Fouriertransformation über ein halb-unendliches Intervall.
     Dabei wird die global adaptive Routine 'quad_qawo' sukzessive auf
     endliche Teilintervalle angewendet.  Zur Konvergenzbeschleunigung
     der resultierenden alternierenden Reihe wird der
     Epsilon-Algorithmus (Wynn, 1956) verwendet.

'quad_qaws'
     Integration von w(x) f(x) über ein endliches Intervall [a, b],
     wobei w eine Funktion der Form (x - a)^alpha (b - x)^beta v(x) ist
     und v(x) ist 1 oder log(x - a) oder log(b - x) oder log(x - a)
     log(b - x), und alpha > -1 und beta > -1.  'quad_qaws' ist speziell
     für die effiziente Berechnung von Integralen über endliche
     Intervalle mit algebraischen oder algebraisch-logarithmischen
     Endpunktsingularitäten konzipiert.  Eine globale adaptive Strategie
     mit Unterteilung des Integrationsintervalls wird angewendet.  Auf
     Teilintervalle die keinen Endpunkt des Integrationsintervalls
     enthalten, kommt ein Gauß-Kronrod-Formelpaar und auf
     Randintervallen kommen modifizierte Clenshaw-Curtis-Formeln zur
     Anwendung.

'quad_qawc'
     Die Funktion 'quad_qawc' berechnet den Cauchyschen Hauptwert von
     f(x)(x - c) über ein endliches Intervall (a, b) und dem Wert c.  Es
     wird eine modifizierte Clenshaw-Curtis-Formel angewendet, wenn c im
     Teilbereich enthalten ist.  Andernfalls wird eine globale adaptive
     Strategie mit einem Gauß-Kronrod-Formelpaar angewendet.

'quad_qagp'
     Basically the same as 'quad_qags' but points of singularity or
     discontinuity of the integrand must be supplied.  This makes it
     easier for the integrator to produce a good solution.

   ---------- Footnotes ----------

   (1) Applied Mathematics and Programming Division, K.U. Leuven

   (2) Applied Mathematics and Programming Division, K.U. Leuven

   (3) Institut für Mathematik, T.U. Wien

   (4) National Bureau of Standards, Washington, D.C., U.S.A

   (5) <http://www.netlib.org/slatec>

   (6) <http://www.netlib.org/quadpack>

   (7) R. Piessens, E. de Doncker-Kapenga, C.W. Uberhuber, and D.K.
Berlin: Springer-Verlag, 1983, ISBN 0387125531.


File: maxima.info,  Node: Funktionen und Variablen für QUADPACK,  Prev: Einführung in QUADPACK,  Up: Integration

16.3.4 Funktionen und Variablen für QUADPACK
--------------------------------------------

 -- Funktion: quad_qag (<f(x)>, <x>, <a>, <b>, <key>, [<epsrel>,
          <epsabs>, <limit>])
 -- Funktion: quad_qag (<f>, <x>, <a>, <b>, <key>, [<epsrel>, <epsabs>,
          <limit>])

     Die Funktion 'quad_qag' berechnet das folgende Integral über ein
     endliches Intervall.

                b
               /
               [
               I  f(x) dx
               ]
               /
                a

     'quad_qag' implementiert einen globalen adaptiven Integrator auf
     Grundlage der Strategie von Aind (Piessens, 1973).  Es kann aus 6
     verschiedenen Paaren von Gauß-Kronrad-Quadraturformeln ausgewählt
     werden.  Die Formeln höheren Grades sind für stark oszillierende
     Integranden geeignet.

     Die Funktion <f(x)> mit der abhängigen Variablen <x> wird im
     Integrationsintervall <a> und <b> integriert.  <key> wählt den Grad
     der Gauß-Kronrod-Quadraturformel aus und kann Werte von 1 bis 6
     annehmen.  Ein größerer Grad ist geeignet für stark oszillierende
     Integranden.

     Der Integrand kann eine Maxima-Funktion, eine Lisp-Funktion, ein
     Operator, ein Maxima-Lambda-Ausdruck oder ein allgemeiner
     Maxima-Ausdruck sein.

     Die numerische Integration wird adaptiv ausgeführt.  Der
     Integrationsbereich wird solange geteilt, bis die gewünschte
     Genauigkeit erreicht wird.

     Die Schlüsselwortargumente sind optional und können in beliebiger
     Reihenfolge angegeben werden.  Sie haben die Form 'key=val'.  Die
     Schlüsselwortargumente sind:

     'epsrel'
          Gewünschter relativer Fehler der Approximation.  Der
          Standardwert ist '1.0e-8'.
     'epsabs'
          Gewünschter absoluter Fehler der Approximation.  Der
          Standardwert ist '0'.
     'limit'
          Die maximale Zahl an Teilintervallen des adaptiven
          Algorithmus.  Der Standardwert ist '200'.

     'quad_qag' gibt eine Liste mit vier Elementen zurück:

        * eine numerische Näherung des Integrals,
        * geschätzer absoluter Fehler der Näherung,
        * Anzahl der Auswertungen des Integranden,
        * ein Fehlercode.

     Der Fehlercode kann die folgenden Werte annehmen:

        * '0', wenn kein Fehler aufgetreten ist,
        * '1', wenn zu viele Teilintervalle notwendig wurden,
        * '2', wenn übemäßiger Rundungsfehler aufgetreten sind,
        * '3', wenn ein extrem schlechtes Verhalten des Integranden
          vorliegt,
        * '6', wenn die Eingabe ungültig ist.

     Beispiele:

          (%i1) quad_qag (x^(1/2)*log(1/x), x, 0, 1, 3, 'epsrel=5d-8);
          (%o1)    [.4444444444492108, 3.1700968502883E-9, 961, 0]
          (%i2) integrate (x^(1/2)*log(1/x), x, 0, 1);
                                          4
          (%o2)                           -
                                          9

 -- Funktion: quad_qags (<f(x)>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
 -- Funktion: quad_qags (<f>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])

     Die Funktion 'quad_qags' berechnet das folgende Integral über ein
     endliches Intervall.

                b
               /
               [
               I  f(x) dx
               ]
               /
                a

     'quad_qags' implementiert die Strategie einer globalen adaptiven
     Unterteilung des Integrationsintervalls mit Extrapolation (de
     Doncker, 1978).  Zusätzlich wird versucht, die Konvergenz der
     Integralapproximation mit Hilfe des Epsilon-Algorithmus (Wynn,
     1956) zu beschleunigen.  Dies führt zum Beispiel bei Integranden
     mit Singularitäten, deren Lage und Typ unbekannt sind, zu einer
     Effizienzsteigerung.

     Die Funktion <f(x)> mit der abhängigen Variablen <x> wird im
     Integrationsintervall <a> und <b> integriert.

     Der Integrand kann eine Maxima-Funktion, eine Lisp-Funktion, ein
     Operator, ein Maxima-Lambda-Ausdruck oder ein allgemeiner
     Maxima-Ausdruck sein.

     Die Schlüsselwortargumente sind optional und können in beliebiger
     Reihenfolge angegeben werden.  Sie haben die Form 'key=val'.  Die
     Schlüsselwortargumente sind:

     'epsrel'
          Gewünschter relativer Fehler der Approximation.  Der
          Standardwert ist '1.0e-8'.
     'epsabs'
          Gewünschter absoluter Fehler der Approximation.  Der
          Standardwert ist '0'.
     'limit'
          Die maximale Zahl an Teilintervallen des adaptiven
          Algorithmus.  Der Standardwert ist '200'.

     'quad_qag' gibt eine Liste mit vier Elementen zurück:

        * eine numerische Näherung des Integrals,
        * geschätzer absoluter Fehler der Näherung,
        * Anzahl der Auswertungen des Integranden,
        * ein Fehlercode.

     Der Fehlercode kann die folgenden Werte annehmen:

        * '0', wenn kein Fehler aufgetreten ist,
        * '1', wenn zu viele Teilintervalle notwendig wurden,
        * '2', wenn übemäßiger Rundungsfehler aufgetreten sind,
        * '3', wenn ein extrem schlechtes Verhalten des Integranden
          vorliegt,
        * '6', wenn die Eingabe ungültig ist.

     Beispiele:

     'quad_qags' ist genauer und effizienter als 'quad_qag' für das
     folgende Beispiel.

          (%i1) quad_qags (x^(1/2)*log(1/x), x, 0, 1, 'epsrel=1d-10);
          (%o1)   [.4444444444444448, 1.11022302462516E-15, 315, 0]

 -- Funktion: quad_qagi (<f(x)>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
 -- Funktion: quad_qagi (<f>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])

     Die Funktion 'quad_qagi' berechnet die folgenden Integrale über ein
     unendliches oder halb-unendliches Intervall.

                inf
               /
               [
               I    f(x) dx
               ]
               /
                a

                a
               /
               [
               I     f(x) dx
               ]
               /
                minf

                inf
               /
               [
               I     f(x) dx
               ]
               /
                minf

     Das Intervall wird auf ein endliches Intervall transformiert.  Das
     transformierte Integrationsproblem wird dann mit einem geringfügig
     modifizierten Algorithmus wie in 'quad_qags' gelöst.

     Die Funktion <f(x)> mit der abhängigen Variablen <x> wird über
     einen unendlichen Bereich integriert.

     Der Integrand kann eine Maxima-Funktion, eine Lisp-Funktion, ein
     Operator, ein Maxima-Lambda-Ausdruck oder ein allgemeiner
     Maxima-Ausdruck sein.

     Eine der Grenzen des Integrationsbereiches kann unendlich sein.
     Ist dies nicht der Fall gibt 'quad_qagi' eine Substantivform
     zurück.

     Die Schlüsselwortargumente sind optional und können in beliebiger
     Reihenfolge angegeben werden.  Sie haben die Form 'key=val'.  Die
     Schlüsselwortargumente sind:

     'epsrel'
          Gewünschter relativer Fehler der Approximation.  Der
          Standardwert ist '1.0e-8'.
     'epsabs'
          Gewünschter absoluter Fehler der Approximation.  Der
          Standardwert ist '0'.
     'limit'
          Die maximale Zahl an Teilintervallen des adaptiven
          Algorithmus.  Der Standardwert ist '200'.

     'quad_qag' gibt eine Liste mit vier Elementen zurück:

        * eine numerische Näherung des Integrals,
        * geschätzer absoluter Fehler der Näherung,
        * Anzahl der Auswertungen des Integranden,
        * ein Fehlercode.

     Der Fehlercode kann die folgenden Werte annehmen:

        * '0', wenn kein Fehler aufgetreten ist,
        * '1', wenn zu viele Teilintervalle notwendig wurden,
        * '2', wenn übemäßiger Rundungsfehler aufgetreten sind,
        * '3', wenn ein extrem schlechtes Verhalten des Integranden
          vorliegt,
        * '6', wenn die Eingabe ungültig ist.

     Beispiele:

          (%i1) quad_qagi (x^2*exp(-4*x), x, 0, inf, 'epsrel=1d-8);
          (%o1)        [0.03125, 2.95916102995002E-11, 105, 0]
          (%i2) integrate (x^2*exp(-4*x), x, 0, inf);
                                         1
          (%o2)                          --
                                         32

 -- Funktion: quad_qawc (<f(x)>, <x>, <c>, <a>, <b>, [<epsrel>,
          <epsabs>, <limit>])
 -- Funktion: quad_qawc (<f>, <x>, <c>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])

     Die Funktion 'quad_qawc' berechnet den Cauchyschen Hauptwert von
     f(x)(x - c) über ein endliches Intervall (a, b) und dem Wert c.

                b
               /
               [  f(x)
               I  ----- dx
               ]  x - c
               /
                a

     Es wird eine modifizierte Clenshaw-Curtis-Formel angewendet, wenn c
     im Teilbereich enthalten ist, andernfalls wird eine globale
     adaptive Strategie mit einem Gauß-Kronrod-Formelpaar angewendet.

     Die Funktion '<f(x)>/(<x> - <c>)', die von der Variablen <x>
     abhängt, wird in den Grenzen <a> und <b> integriert.

     Der Integrand kann eine Maxima-Funktion, eine Lisp-Funktion, ein
     Operator, ein Maxima-Lambda-Ausdruck oder ein allgemeiner
     Maxima-Ausdruck sein.

     Die Schlüsselwortargumente sind optional und können in beliebiger
     Reihenfolge angegeben werden.  Sie haben die Form 'key=val'.  Die
     Schlüsselwortargumente sind:

     'epsrel'
          Gewünschter relativer Fehler der Approximation.  Der
          Standardwert ist '1.0e-8'.
     'epsabs'
          Gewünschter absoluter Fehler der Approximation.  Der
          Standardwert ist '0'.
     'limit'
          Die maximale Zahl an Teilintervallen des adaptiven
          Algorithmus.  Der Standardwert ist '200'.

     'quad_qag' gibt eine Liste mit vier Elementen zurück:

        * eine numerische Näherung des Integrals,
        * geschätzer absoluter Fehler der Näherung,
        * Anzahl der Auswertungen des Integranden,
        * ein Fehlercode.

     Der Fehlercode kann die folgenden Werte annehmen:

        * '0', wenn kein Fehler aufgetreten ist,
        * '1', wenn zu viele Teilintervalle notwendig wurden,
        * '2', wenn übemäßiger Rundungsfehler aufgetreten sind,
        * '3', wenn ein extrem schlechtes Verhalten des Integranden
          vorliegt,
        * '6', wenn die Eingabe ungültig ist.

     Beispiele:

          (%i1) quad_qawc (2^(-5)*((x-1)^2+4^(-5))^(-1), x, 2, 0, 5,
                           'epsrel=1d-7);
          (%o1)    [- 3.130120337415925, 1.306830140249558E-8, 495, 0]
          (%i2) integrate (2^(-alpha)*(((x-1)^2 + 4^(-alpha))*(x-2))^(-1),
                           x, 0, 5);
          Principal Value
                                 alpha
                  alpha       9 4                 9
                 4      log(------------- + -------------)
                                alpha           alpha
                            64 4      + 4   64 4      + 4
          (%o2) (-----------------------------------------
                                  alpha
                               2 4      + 2

                 3 alpha                       3 alpha
                 -------                       -------
                    2            alpha/2          2          alpha/2
              2 4        atan(4 4       )   2 4        atan(4       )   alpha
            - --------------------------- - -------------------------)/2
                        alpha                        alpha
                     2 4      + 2                 2 4      + 2
          (%i3) ev (%, alpha=5, numer);
          (%o3)                    - 3.130120337415917

 -- Funktion: quad_qawf (<f(x)>, <x>, <a>, <omega>, <trig>, [<epsabs>,
          <limit>, <maxp1>, <limlst>])
 -- Funktion: quad_qawf (<f>, <x>, <a>, <omega>, <trig>, [<epsabs>,
          <limit>, <maxp1>, <limlst>])

     Die Funktion 'quad_qawf' berechnet die Sinus- oder
     Kosinus-Fouriertransformation mit der Gewichtsfunktion w über ein
     halb-unendliches Intervall.

                inf
               /
               [
               I    f(x) w(x) dx
               ]
               /
                a

     Zur Berechnung des Integrals wird die global adaptive Routine
     'quad_qawo' sukzessive auf endliche Teilintervalle angewendet.  Zur
     Konvergenzbeschleunigung der resultierenden alternierenden Reihe
     wird der Epsilon-Algorithmus (Wynn, 1956) verwendet.

     Die Gewichtsfunktion w wird mit dem Schlüsselwort <trig>
     ausgewählt:

     'cos'
          w(x) = cos (omega x)
     'sin'
          w(x) = sin (omega x)

     Der Integrand kann eine Maxima-Funktion, eine Lisp-Funktion, ein
     Operator, ein Maxima-Lambda-Ausdruck oder ein allgemeiner
     Maxima-Ausdruck sein.

     Die Schlüsselwortargumente sind optional und können in beliebiger
     Reihenfolge angegeben werden.  Sie haben die Form 'key=val'.  Die
     Schlüsselwortargumente sind:

     'epsabs'
          Gewünschter absoluter Fehler der Näherung.  Der Standardwert
          ist '1.0e-10'.
     'limit'
          '(<limit> - <limlst>)/2' ist die maximale Zahl an
          Teilintervallen des adaptiven Algorithmus.  Der Standardwert
          ist '200'.
     'maxp1'
          Die maximale Anzahl an Chebyshev-Gewichten.  Der Wert muss
          größer als 0 sein.  Der Standardwert ist '100'.
     'limlst'
          Obere Grenze für die Anzahl an Zyklen.  Der Wert muss größer
          oder gleich 3 sein.  Der Standardwert ist 10.

     'quad_qawf' gibt eine Liste mit vier Elementen zurück:

        * eine numerische Näherung des Integrals,
        * geschätzer absoluter Fehler der Näherung,
        * Anzahl der Auswertungen des Integranden,
        * ein Fehlercode.

     Der Fehlercode kann die folgenden Werte annehmen:

        * '0', wenn kein Fehler aufgetreten ist,
        * '1', wenn zu viele Teilintervalle notwendig wurden,
        * '2', wenn übemäßiger Rundungsfehler aufgetreten sind,
        * '3', wenn ein extrem schlechtes Verhalten des Integranden
          vorliegt,
        * '6', wenn die Eingabe ungültig ist.

     Beispiele:

          (%i1) quad_qawf (exp(-x^2), x, 0, 1, 'cos, 'epsabs=1d-9);
          (%o1)   [.6901942235215714, 2.84846300257552E-11, 215, 0]
          (%i2) integrate (exp(-x^2)*cos(x), x, 0, inf);
                                    - 1/4
                                  %e      sqrt(%pi)
          (%o2)                   -----------------
                                          2
          (%i3) ev (%, numer);
          (%o3)                   .6901942235215714

 -- Funktion: quad_qawo (<f(x)>, <x>, <a>, <b>, <omega>, <trig>,
          [<epsrel>, <epsabs>, <limit>, <maxp1>, <limlst>])
 -- Funktion: quad_qawo (<f>, <x>, <a>, <b>, <omega>, <trig>, [<epsrel>,
          <epsabs>, <limit>, <maxp1>, <limlst>])

     Die Funktion 'quad_qawo' berechnet das folgende Integral mit den
     trigonometrischen Gewichtsfunktionen cos(omega x) f(x) oder
     sin(omega x) f(x) über ein endliches Intervall, wobei omega eine
     Konstante ist.

                b
               /
               [
               I  f(x) w(x) dx
               ]
               /
                a

     Der Algorithmus basiert auf eine modifizierte
     Clenshaw-Curtis-Technik.  'quad_qawo' wendet eine adaptive
     Unterteilung des Integrationsintervalls mit Extrapolation an, die
     vergleichbar mit dem Algorithmus von 'quad_qags' ist.  Zusätzlich
     wird versucht, die Konvergenz der Integralapproximation mit Hilfe
     des Epsilon-Algorithmus zu beschleunigen.

     Die Gewichtsfunktion w wird mit dem Schlüsselwort <trig>
     ausgewählt:

     'cos'
          w(x) = cos (omega x)
     'sin'
          w(x) = sin (omega x)

     Der Integrand kann eine Maxima-Funktion, eine Lisp-Funktion, ein
     Operator, ein Maxima-Lambda-Ausdruck oder ein allgemeiner
     Maxima-Ausdruck sein.

     Die Schlüsselwortargumente sind optional und können in beliebiger
     Reihenfolge angegeben werden.  Sie haben die Form 'key=val'.  Die
     Schlüsselwortargumente sind:

     'epsrel'
          Gewünschter relativer Fehler der Näherung.  Der Standardwert
          ist '1.0e-8'
     'epsabs'
          Gewünschter absoluter Fehler der Näherung.  Der Standardwert
          ist '0'.
     'limit'
          '<limit>/2' ist die maximale Zahl an Teilintervallen des
          adaptiven Algorithmus.  Der Standardwert ist '200'.
     'maxp1'
          Die maximale Anzahl an Chebyshev-Gewichten.  Der Wert muss
          größer als 0 sein.  Der Standardwert ist '100'.
     'limlst'
          Obere Grenze für die Anzahl an Zyklen.  Der Wert muss größer
          oder gleich 3 sein.  Der Standardwert ist 10.

     'quad_qawo' gibt eine Liste mit vier Elementen zurück:

        * eine numerische Näherung des Integrals,
        * geschätzer absoluter Fehler der Näherung,
        * Anzahl der Auswertungen des Integranden,
        * ein Fehlercode.

     Der Fehlercode kann die folgenden Werte annehmen:

        * '0', wenn kein Fehler aufgetreten ist,
        * '1', wenn zu viele Teilintervalle notwendig wurden,
        * '2', wenn übemäßiger Rundungsfehler aufgetreten sind,
        * '3', wenn ein extrem schlechtes Verhalten des Integranden
          vorliegt,
        * '6', wenn die Eingabe ungültig ist.

     Beispiele:

          (%i1) quad_qawo (x^(-1/2)*exp(-2^(-2)*x), x, 1d-8, 20*2^2, 1, cos);
          (%o1)     [1.376043389877692, 4.72710759424899E-11, 765, 0]
          (%i2) rectform (integrate (x^(-1/2)*exp(-2^(-alpha)*x) * cos(x),
                          x, 0, inf));
                             alpha/2 - 1/2            2 alpha
                  sqrt(%pi) 2              sqrt(sqrt(2        + 1) + 1)
          (%o2)   -----------------------------------------------------
                                         2 alpha
                                   sqrt(2        + 1)
          (%i3) ev (%, alpha=2, numer);
          (%o3)                     1.376043390090716

 -- Funktion: quad_qaws (<f(x)>, <x>, <a>, <b>, <alpha>, <beta>, <wfun>,
          [<epsrel>, <epsabs>, <limit>])
 -- Funktion: quad_qaws (<f>, <x>, <a>, <b>, <alpha>, <beta>, <wfun>,
          [<epsrel>, <epsabs>, <limit>])

     Die Funktion 'quad_qaws' berechnet das Integral von w(x) f(x) über
     ein endliches Intervall [a, b], wobei w eine Funktion der Form (x -
     a)^alpha (b - x)^beta v(x) ist und v(x) ist 1 oder log(x - a) oder
     log(b - x) oder log(x - a) log(b - x), und alpha > -1 und beta >
     -1.

                b
               /
               [
               I  f(x) w(x) dx
               ]
               /
                a

     'quad_qaws' ist speziell für die effiziente Berechnung von
     Integralen über endliche Intervalle mit algebraischen oder
     algebraisch-logarithmischen Endpunktsingularität konzipiert.  Eine
     globale adaptive Strategie mit Unterteilung des
     Integrationsintervalls wird angewendet.  Auf Teilintervalle, die
     keinen Endpunkt des Integrationsintervalls enthalten, kommt ein
     Gauß-Kronrod-Formelpaar und auf Randintervallen kommen modifizierte
     Clenshaw-Curtis-Formeln zur Anwendung.

     Die Gewichtsfunktion wird mit dem Schlüsselwort <wfun> ausgewählt:

     '1'
          w(x) = (x - a)^alpha (b - x)^beta
     '2'
          w(x) = (x - a)^alpha (b - x)^beta log(x - a)
     '3'
          w(x) = (x - a)^alpha (b - x)^beta log(b - x)
     '4'
          w(x) = (x - a)^alpha (b - x)^beta log(x - a) log(b - x)

     Der Integrand kann eine Maxima-Funktion, eine Lisp-Funktion, ein
     Operator, ein Maxima-Lambda-Ausdruck oder ein allgemeiner
     Maxima-Ausdruck sein.

     Die Schlüsselwortargumente sind optional und können in beliebiger
     Reihenfolge angegeben werden.  Sie haben die Form 'key=val'.  Die
     Schlüsselwortargumente sind:

     'epsrel'
          Gewünschter relativer Fehler der Näherung.  Der Standardwert
          ist '1.0e-8'
     'epsabs'
          Gewünschter absoluter Fehler der Näherung.  Der Standardwert
          ist '0'.
     'limit'
          Maximale Anzahl der Teilintervalle des adaptiven Algorithmus.
          Der Standardwert ist '200'.

     'quad_qaws' gibt eine Liste mit vier Elementen zurück:

        * eine numerische Näherung des Integrals,
        * geschätzer absoluter Fehler der Näherung,
        * Anzahl der Auswertungen des Integranden,
        * ein Fehlercode.

     Der Fehlercode kann die folgenden Werte annehmen:

        * '0', wenn kein Fehler aufgetreten ist,
        * '1', wenn zu viele Teilintervalle notwendig wurden,
        * '2', wenn übemäßiger Rundungsfehler aufgetreten sind,
        * '3', wenn ein extrem schlechtes Verhalten des Integranden
          vorliegt,
        * '6', wenn die Eingabe ungültig ist.

     Beispiele:

          (%i1) quad_qaws (1/(x+1+2^(-4)), x, -1, 1, -0.5, -0.5, 1,
                           'epsabs=1d-9);
          (%o1)     [8.750097361672832, 1.24321522715422E-10, 170, 0]
          (%i2) integrate ((1-x*x)^(-1/2)/(x+1+2^(-alpha)), x, -1, 1);
                 alpha
          Is  4 2      - 1  positive, negative, or zero?

          pos;
                                    alpha         alpha
                             2 %pi 2      sqrt(2 2      + 1)
          (%o2)              -------------------------------
                                         alpha
                                      4 2      + 2
          (%i3) ev (%, alpha=4, numer);
          (%o3)                     8.750097361672829

 -- Function: quad_qagp (<f(x)>, <x>, <a>, <b>, <points>, [<epsrel>,
          <epsabs>, <limit>])
 -- Function: quad_qagp (<f>, <x>, <a>, <b>, <points>, [<epsrel>,
          <epsabs>, <limit>])

     Integration of a general function over a finite interval.
     'quad_qagp' implements globally adaptive interval subdivision with
     extrapolation (de Doncker, 1978) by the Epsilon algorithm (Wynn,
     1956).

     'quad_qagp' computes the integral

     integrate (f(x), x, a, b)

     The function to be integrated is <f(x)>, with dependent variable
     <x>, and the function is to be integrated between the limits <a>
     and <b>.

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     To help the integrator, the user must supply a list of points where
     the integrand is singular or discontinous.

     The keyword arguments are optional and may be specified in any
     order.  They all take the form 'key=val'.  The keyword arguments
     are:

     'epsrel'
          Desired relative error of approximation.  Default is 1d-8.
     'epsabs'
          Desired absolute error of approximation.  Default is 0.
     'limit'
          Size of internal work array.  <limit> is the maximum number of
          subintervals to use.  Default is 200.

     'quad_qagp' returns a list of four elements:

        * an approximation to the integral,
        * the estimated absolute error of the approximation,
        * the number integrand evaluations,
        * an error code.

     The error code (fourth element of the return value) can have the
     values:

     '0'
          no problems were encountered;
     '1'
          too many sub-intervals were done;
     '2'
          excessive roundoff error is detected;
     '3'
          extremely bad integrand behavior occurs;
     '4'
          failed to converge
     '5'
          integral is probably divergent or slowly convergent
     '6'
          if the input is invalid.

     Examples:

          (%i1) quad_qagp(x^3*log(abs((x^2-1)*(x^2-2))),x,0,3,[1,sqrt(2)]);
          (%o1)   [52.74074838347143, 2.6247632689546663e-7, 1029, 0]
          (%i2) quad_qags(x^3*log(abs((x^2-1)*(x^2-2))), x, 0, 3);
          (%o2)   [52.74074847951494, 4.088443219529836e-7, 1869, 0]

     The integrand has singularities at 1 and sqrt(2) so we supply these
     points to 'quad_qagp'.  We also note that 'quad_qagp' is more
     accurate and more efficient that 'quad_qags'.

 -- Function: quad_control (<parameter>, [<value>])

     Control error handling for quadpack.  The parameter should be one
     of the following symbols:

     'current_error'
          The current error number
     'control'
          Controls if messages are printed or not.  If it is set to zero
          or less, messages are suppressed.
     'max_message'
          The maximum number of times any message is to be printed.

     If <value> is not given, then the current value of the <parameter>
     is returned.  If <value> is given, the value of <parameter> is set
     to the given value.


File: maxima.info,  Node: Differentialgleichungen,  Next: Einführung in Differentialgleichungen,  Prev: Integration,  Up: Analysis

16.4 Differentialgleichungen
============================

* Menu:

* Einführung in Differentialgleichungen::  
* Funktionen und Variablen für Differentialgleichungen::  


File: maxima.info,  Node: Einführung in Differentialgleichungen,  Next: Funktionen und Variablen für Differentialgleichungen,  Prev: Differentialgleichungen,  Up: Differentialgleichungen

16.4.1 Einführung in Differentialgleichungen
--------------------------------------------

Dieses Kapitel beschreibt die Funktionen, die in Maxima verfügbar sind,
um analytische Lösungen für verschiedene Typen von
Differentialgleichungen der 1.  und 2.  Ordnung zu erhalten.  Eine
numerische Lösung kann mit den Funktionen in *note dynamics:: berechnet
werden.  Für die graphische Darstellung von Differentialgleichungen
siehe das Paket in *note plotdf::.


File: maxima.info,  Node: Funktionen und Variablen für Differentialgleichungen,  Prev: Einführung in Differentialgleichungen,  Up: Differentialgleichungen

16.4.2 Funktionen und Variablen für Differentialgleichungen
-----------------------------------------------------------

 -- Funktion: bc2 (<solution>, <xval1>, <yval1>, <xval2>, <yval2>)

     Löst das Randwertproblem einer Differentialgleichung 2. Ordnung.
     Das Argument <solution> ist eine allgemeine Lösung, wie sie von der
     Funktion 'ode2' zurückgegeben wird.  <xval1> gibt den Wert der
     unabhängigen Variablen im ersten Randpunkt an.  Der Randwert wird
     als ein Ausdruck '<x> = <x1>' angegeben.  Das Argument <yval1> gibt
     den Wert der abhängigen Variablen in diesem Punkt an.  Der Randwert
     wird als '<y> = <y1>' angegeben.  Mit den Argumenten <xval2> und
     <yval2> werden die entsprechenden Werte an einem zweiten Randpunkt
     angegeben.

     Siehe die Funktion 'ode2' für Beispiele.

 -- Funktion: desolve (<eqn>, <x>)
 -- Funktion: desolve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])

     Die Funktion 'desolve' löst lineare Systeme gewöhnlicher
     Differentialgleichungen mit Hilfe der Methode der
     Laplacetransformation.  Die Argumente <eqn_i> sind die
     Differentialgleichungen mit den abhängigen Variablen <x_1>, ...,
     <x_n>.  Die funktionale Abhängigkeit der Variablen <x_1>, ...,
     <x_n> zum Beispiel von einer Variablen <x> muss explizit für die
     Variablen und ihrer Ableitungen angegeben werden.  Zum Beispiel ist
     sind die folgenden zwei Gleichungen keine korrekte Definition:

          eqn_1: 'diff(f,x,2) = sin(x) + 'diff(g,x);
          eqn_2: 'diff(f,x) + x^2 - f = 2*'diff(g,x,2);

     Eine korrekte Definition der zwei Gleichungen ist

          eqn_1: 'diff(f(x),x,2) = sin(x) + 'diff(g(x),x);
          eqn_2: 'diff(f(x),x) + x^2 - f(x) = 2*'diff(g(x),x,2);

     Die Funktion 'desolve' wird dann folgendermaßen aufgerufen

          desolve([eqn_1, eqn_2], [f(x),g(x)]);

     Sind Anfangswerte für 'x=0' bekannt, können diese mit der Funktion
     'atvalue' vor dem Aufruf der Funktion 'desolve' angegeben werden.

          (%i1) 'diff(f(x),x)='diff(g(x),x)+sin(x);
                           d           d
          (%o1)            -- (f(x)) = -- (g(x)) + sin(x)
                           dx          dx
          (%i2) 'diff(g(x),x,2)='diff(f(x),x)-cos(x);
                            2
                           d            d
          (%o2)            --- (g(x)) = -- (f(x)) - cos(x)
                             2          dx
                           dx
          (%i3) atvalue('diff(g(x),x),x=0,a);
          (%o3)                           a
          (%i4) atvalue(f(x),x=0,1);
          (%o4)                           1
          (%i5) desolve([%o1,%o2],[f(x),g(x)]);
                            x
          (%o5) [f(x) = a %e  - a + 1, g(x) =
                                                          x
                                             cos(x) + a %e  - a + g(0) - 1]
          (%i6) [%o1,%o2],%o5,diff;
                       x       x      x                x
          (%o6)   [a %e  = a %e , a %e  - cos(x) = a %e  - cos(x)]

     Kann 'desolve' keine Lösung finden, ist die Rückgabe 'false'.

 -- Funktion: ic1 (<solution>, <xval>, <yval>)

     Löst das Anfangswertproblem für eine Differentialgleichung 1.
     Ordnung.  Das Argument <solution> ist eine allgemeine Lösung der
     Differentialgleichung, wie sie von der Funktion 'ode2'
     zurückgegeben wird.  Mit dem Argument <xval> wird der Anfangswert
     der unabhängigen Variablen in der Form '<x> = <x0>' angegeben.  Mit
     dem Argument <yval> wird der Anfangswert der unabhängigen Variablen
     in der Form '<y> = <y0>' angegeben.

     Siehe die Funktion 'ode2' für ein Beispiel.

 -- Funktion: ic2 (<solution>, <xval>, <yval>, <dval>)

     Löst das Anfangswertproblem für eine Differentialgleichung 2.
     Ordnung.  Das Argument <solution> ist eine allgemeine Lösung der
     Differentialgleichung, wie sie von der Funktion 'ode2'
     zurückgegeben wird.  Mit dem Argument <xval> wird der Anfangswert
     der unabhängigen Variablen in der Form '<x> = <x0>' angegeben.  Mit
     dem Argument <yval> wird der Anfangswert der abhängigen Variablen
     in der Form '<y> = <y0>' angegeben.  Mit dem Argument <dval> wird
     der Anfangswert der ersten Ableitung der abhängigen Variablen nach
     der unabhängigen Variablen in der Form 'diff(<y>,<x>) = <dy0>'
     angegeben.  Dem Symbol 'diff' muss kein 'Quote-Operator' '''
     vorangestellt werden.

     Siehe auch 'ode2' für ein Beispiel.

 -- Funktion: ode2 (<eqn>, <dvar>, <ivar>)

     Die Funktion 'ode2' löst eine gewöhnliche Differentialgleichung der
     ersten oder zweiten Ordnung.  Die Funktion hat drei Argumente: die
     Differentialgleichung <eqn>, die abhängige Variable 'dvar' und die
     unabhängige Variable 'ivar'.  Ist die Funktion 'ode2' erfolgreich
     wird eine explizite oder implizite Lösung für die abhängige
     Variable zurückgegeben.  Im Fall einer Differentialgleichung 1.
     Ordnung wird die Integrationskonstante mit '%c' bezeichnet.  Für
     eine Differentialgleichung 2. Ordnung werden die
     Integrationskonstanten mit '%k1' und '%k2' bezeichnet.  Die
     Abhängigkeit der abhängigen Variable von der unabhängigen Variablen
     muss nicht explizit, wie im Fall von 'desolve' angegeben werden.

     Kann 'ode2' keine Lösung finden, ist die Rückgabe 'false'.
     Gegebenenfalls wird eine Fehlermeldung ausgegeben.  Folgende
     Methoden werden für das Lösen einer Differentialgleichung 1.
     Ordnung nacheinander angewendet: linear, separierbar, exakt - wenn
     notwendig unter Zuhilfenahme eines Integrationsfaktors, homogen,
     bernoullische Differentialgleichung und eine Methode für
     verallgemeinerte homogene Gleichungen.  Für eine
     Differentialgleichung 2. Ordnung kommen die folgenden Methoden zur
     Anwendung: konstante Koeffizienten, exakt, linear homogen mit
     nicht-konstanten Koeffizienten, die zu konstanten Koeffizienten
     transformiert werden können, eulersche Differentialgleichung,
     Variation der Parameter, Reduktion auf eine Differentialgleichung
     1. Ordnung, wenn die Differentialgleichung entweder frei von der
     unabhängigen oder der abhängigen Variablen ist.

     Im Laufe des Lösungsverfahrens werden zur Information des Nutzers
     globale Variablen gesetzt: 'method' bezeichnet die Methode, die von
     'ode2' zum Auffinden der Lösung verwendet wurde.  'intfactor'
     bezeichnet einen verwendeten Integrationsfaktor.  'odeindex'
     bezeichnet den Index der bernoullischen Gleichung oder der
     verallgemeinerte Methode für eine homogene Differentialgleichung.
     'yp' bezeichnet eine partikuläre Lösung, wenn die Variation der
     Parameter angewendet wird.

     Für das Lösen von Anfangswertproblemen einer Differentialgleichung
     1. oder 2. Ordnung können die Funktionen 'ic1' und 'ic2' verwendet
     werden.  Ein Randwertproblem für eine Differentialgleichung 2.
     Ordnung kann mit der Funktion 'bc2' gelöst werden.

     Beispiele:

          (%i1) x^2*'diff(y,x) + 3*y*x = sin(x)/x;
                                2 dy           sin(x)
          (%o1)                x  -- + 3 x y = ------
                                  dx             x
          (%i2) ode2(%,y,x);
                                       %c - cos(x)
          (%o2)                    y = -----------
                                            3
                                           x
          (%i3) ic1(%o2,x=%pi,y=0);
                                        cos(x) + 1
          (%o3)                   y = - ----------
                                             3
                                            x
          (%i4) 'diff(y,x,2) + y*'diff(y,x)^3 = 0;
                                   2
                                  d y      dy 3
          (%o4)                   --- + y (--)  = 0
                                    2      dx
                                  dx
          (%i5) ode2(%,y,x);
                                3
                               y  + 6 %k1 y
          (%o5)                ------------ = x + %k2
                                    6
          (%i6) ratsimp(ic2(%o5,x=0,y=0,'diff(y,x)=2));
                                       3
                                    2 y  - 3 y
          (%o6)                   - ---------- = x
                                        6
          (%i7) bc2(%o5,x=0,y=1,x=1,y=3);
                                   3
                                  y  - 10 y       3
          (%o7)                   --------- = x - -
                                      6           2


File: maxima.info,  Node: Polynome,  Next: Gleichungen,  Prev: Analysis,  Up: Top

17 Polynome
***********

* Menu:

* Einführung in Polynome::
* Funktionen und Variablen für Polynome::


File: maxima.info,  Node: Einführung in Polynome,  Next: Funktionen und Variablen für Polynome,  Prev: Polynome,  Up: Polynome

17.1 Einführung in Polynome
===========================

Polynome werden in einer allgemeinen Darstellung oder in einer
kanonischen Darstellung (CRE - Cannonical Rational Expressions)
gespeichert.  Die CRE-Darstellung ist die Standardform für Operationen
mit Polynomen und wird intern von Funktionen wie 'factor' oder 'ratsimp'
verwendet.

Ausdrücke in einer CRE-Form sind besonders für die Darstellung von
Polynomen und rationalen Funktionen geeignet.  Die CRE-Form nimmt eine
Ordnung der Variablen an.  Polynome werden rekursiv als eine Liste
definiert, die als ersten Eintrag den Namen der Variablen und als
nächste Einträge die Exponenten und Koeffizienten der Variablen
enthalten.  Der Koeffizient kann eine Zahl oder wiederum ein Polynom
sein.  Zum Beispiel hat das Polynom '3*x^2-1' die Darstellung '(X 2 3 0
-1)' und das Polynom '2*x*y+x-3' die Darstellung '(Y 1 (X 1 2) 0 (X 1 1
0 -3))', wenn 'y' die Hauptvariable des Polynoms ist.  Ist <x> die
Hauptvariable des Polynoms, dann ist die Darstellung '(X 1 (Y 1 2 0 1) 0
-3)'.

Die Ordnung der Variablen ist in der Regel umgekehrt alphabetisch.  Die
Variablen müssen keine Atome sein.  Alle Ausdrücke, die nicht die
Operatoren '+', '-', '*', '/' oder '^' enthalten, werden in einer
CRE-Darstellung als "Variable" angenommen.  Zum Beispiel sind 'x',
'sqrt(x)' und 'sin(x+1)' die CRE-Variablen des Ausdrucks
'x+sin(x+1)+2*SQRT(x)+1'.  Wird vom Nutzer keine abweichende Ordnung der
Variablen mit der Funktion 'ratvars' definiert, nimmt Maxima eine
alphabetische Ordnung der Variablen an.

Im Allgemeinen werden rationale Funktionen in einer CRE-Form
dargestellt, die keinen gemeinsamen Faktor im Zähler und Nenner haben.
Die interne Darstellung ist ein Paar von Polynomen, die jeweils den
Zähler und den Nenner darstellen.  Diesem Paar geht eine Liste mit der
Ordnung der Variablen im Ausdruck voraus.  Ein Ausdruck in einer
CRE-Form oder der CRE-Formen enthält, wird in der Ausgabe mit dem Symbol
'/R/' gekennzeichnet.  Mit der Funktion 'rat' können allgemeine
Ausdrücke in eine CRE-Form transformiert werden.  Umgekehrt wird ein
Ausdruck in einer CRE-Form mit der Funktion 'ratdisrep' in eine
allgemeine Form transformiert.

Für die Darstellung von Taylor-Polynomen der Funktion 'taylor' wird eine
erweiterte CRE-Form verwendet.  In dieser Darstellung können die
Exponenten von Polynomen auch rationale Zahlen sein.  Weiterhin können
die Koeffizienten rationale Funktionen sein.  Die erweiterte CRE-Form
enthält auch Informationen über den Grad des Polynoms.  In der Ausgabe
wird die erweiterte CRE-Form mit dem Symbol '/T/' bezeichnet.


File: maxima.info,  Node: Funktionen und Variablen für Polynome,  Prev: Einführung in Polynome,  Up: Polynome

17.2 Funktionen und Variablen für Polynome
==========================================

 -- Optionsvariable: algebraic
     Standardwert: 'false'

     Hat die Optionsvariable 'algebraic' den Wert 'true', wird beim
     Umwandeln von Ausdrücken in die CRE-Form und beim Rechnen mit
     Ausdrücken in einer CRE-Form der Ausdruck so vereinfacht, dass der
     Nenner frei von algebraischen Zahlen (das sind Wurzeln von ganzen
     Zahlen) ist.

     Beispiele:

     Im zweiten Beispiel wird der Ausdruck automatisch mit 'sqrt(2)'
     erweitert, um den Nenner frei von der algebraischen Zahl 'sqrt(2)'
     zu machen.

          (%i1) algebraic:false;
          (%o1)                         false
          (%i2) rat(x^2+x)/sqrt(2);
                                        2
                                       x  + x
          (%o2)/R/                     -------
                                       sqrt(2)
          (%i3) algebraic:true;
          (%o3)                         true
          (%i4) rat(x^2+x)/sqrt(2);
                                        2
                               sqrt(2) x  + sqrt(2) x
          (%o4)/R/             ----------------------
                                         2

 -- Optionsvariable: berlefact
     Standardwert: 'true'

     Hat die Optionsvariable 'berlefact' den Wert 'false', dann wird der
     Kronecker-Algorithmus von der Funktion 'factor' für die
     Faktorisierung genutzt.  Ansonsten wird der Berlekamp-Algorithmus
     genutzt.  Der Standardwert ist 'true'.

 -- Funktion: bezout (<p1>, <p2>, <x>)

     Die Rückgabe ist die Sylvestermatrix der zwei Polynome <p1> und
     <p2> mit der unabhängigen Variablen <x>.  Die Determinante der
     Sylvestermatrix ist die Resultante der Polynome.  Die Resultante
     kann auch sofort mit der Funktion 'resultant' berechnet werden.

     Beispiele:

          (%i1) bezout(a*x+b, c*x^2+d, x);
                                   [ b c  - a d ]
          (%o1)                    [            ]
                                   [  a     b   ]
          (%i2) determinant(%);
                                      2      2
          (%o2)                      a  d + b  c
          (%i3) resultant(a*x+b, c*x^2+d, x);
                                      2      2
          (%o3)                      a  d + b  c

 -- Funktion: bothcoef (<expr>, <x>)

     Gibt eine Liste zurück, deren erstes Element der Koeffizient der
     Variablen <x> im Ausdruck <expr> und deren zweites Element der
     verbleibende Teil des Ausdrucks <expr> ist.  Das Ergebnis ist also
     '[A,B]' und es gilt '<expr> = A * <x> + B'.

     Die Funktion 'bothcoef' hat den Alias-Namen 'bothcoeff'.

     Siehe auch die Funktion 'coeff'.

     Beispiele:

          (%i1) bothcoeff(a*x+2, x);
          (%o1)                        [a, 2]
          (%i2) bothcoeff(x^2+a*x+2, x);
                                          2
          (%o2)                      [a, x  + 2]

     Definition einer Funktion 'islinear', die die Funktion 'bothcoeff'
     nutzt, um den linearen Anteil eines Ausdrucks zu ermitteln.

          (%i1) islinear (expr, x) :=
                   block ([c],
                      c: bothcoef (rat (expr, x), x),
                      is (freeof (x, c) and c[1] # 0))$
          (%i2) islinear ((r^2 - (x - r)^2)/x, x);
          (%o2)                         true

 -- Funktion: coeff (<expr>, <x>, <n>)
 -- Funktion: coeff (<expr>, <x>)

     Gibt den Koeffizienten von '<x>^<n>' des Ausdrucks <expr> zurück.
     Das Argument <expr> ist ein Polynom in der Variablen <x>.

     Das Kommando 'coeff(<expr>, <x>^<n>)' ist äquivalent zu
     'coeff(<expr>, <x>, <n>)'.  Das Kommando 'coeff(<expr>, <x>, 0)'
     gibt den Teil des Ausdrucks <expr> zurück, der frei von der
     Variablen <x> ist.  Wenn nicht angegeben, wird das Argument <n> als
     '1' angenommen.

     Das Argument <x> kann auch eine indizierte Variable oder ein
     Teilausdruck von <expr> sein.

     'coeff' wendet weder die Funktion 'expand' noch die Funktion
     'factor' an, um einen Ausdruck zu expandieren oder zu
     faktorisieren.  Daher kann es zu anderen Ergebnissen kommen, wenn
     zuvor diese Funktionen angewendet werden.

     Wird 'coeff' auf Listen, Matrizen oder Gleichungen angewendet, wird
     die Funktion auf die Elemente oder beide Seiten der Gleichung
     angewendet.

     Siehe auch die Funktion 'bothcoef'.

     Beispiele:

     'coeff' gibt den Koeffizienten von '<x>^<n>' des Ausdrucks <expr>
     zurück.

          (%i1) coeff(b^3*a^3 + b^2*a^2 + b*a + 1, a^3);
                                          3
          (%o1)                          b

     'coeff(<expr>, <x>^<n>)' ist äquivalent zu 'coeff(<expr>, <x>,
     <n>)'.

          (%i1) coeff(c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z, 3);
          (%o1)                         - c
                                           3
          (%i2) coeff(c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z^3);
          (%o2)                         - c
                                           3

     'coeff(<expr>, <x>, 0)' gibt den Teil des Ausdrucks <expr> zurück,
     der frei von der Variablen <x> ist.

          (%i1) coeff(a*u + b^2*u^2 + c^3*u^3, b, 0);
                                      3  3
          (%o1)                      c  u  + a u

     <x> kann eine einfache Variable, eine indizierte Variable oder ein
     Teilausdruck des Ausdrucks <expr> sein.

          (%i1) coeff(h^4 - 2*%pi*h^2 + 1, h, 2);
          (%o1)                        - 2 %pi
          (%i2) coeff(v[1]^4 - 2*%pi*v[1]^2 + 1, v[1], 2);
          (%o2)                        - 2 %pi
          (%i3) coeff (sin(1+x)*sin(x) + sin(1+x)^3*sin(x)^3, sin(1+x)^3);
                                          3
          (%o3)                        sin (x)
          (%i4) coeff((d - a)^2*(b + c)^3 + (a + b)^4*(c - d), a + b, 4);
          (%o4)                         c - d

     'coeff' wendet die Funktionen 'expand' und 'factor' nicht an.

          (%i1) coeff(c*(a + b)^3, a);
          (%o1)                           0
          (%i2) expand(c*(a + b)^3);
                           3          2        2        3
          (%o2)           b  c + 3 a b  c + 3 a  b c + a  c
          (%i3) coeff(%, a);
                                          2
          (%o3)                        3 b  c
          (%i4) coeff(b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c, (a + b)^3);
          (%o4)                           0
          (%i5) factor(b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c);
                                            3
          (%o5)                      (b + a)  c
          (%i6) coeff(%, (a + b)^3);
          (%o6)                           c

     'coeff' wird bei Listen und Matrizen auf die Elemente und bei
     Gleichungen auf die beiden Seiten angewendet.

          (%i1) coeff([4*a, -3*a, 2*a], a);
          (%o1)                      [4, - 3, 2]
          (%i2) coeff(matrix ([a*x, b*x], [-c*x, -d*x]), x);
                                    [  a    b  ]
          (%o2)                     [          ]
                                    [ - c  - d ]
          (%i3) coeff(a*u - b*v = 7*u + 3*v, u);
          (%o3)                         a = 7

     Die folgende Definition der Funktion 'coeff_list' liefert eine
     Liste mit den Koeffizienten, die in einem Polynom auftreten.  Neben
     der Funktion 'coeff' kommt hier die Funktion 'hipow' zum Einsatz,
     um den höchsten Exponenten zu ermitteln.  'rat' und 'ratdisrep'
     werden verwendet, um das Polynom zwischenzeitlich in die kanonische
     Form (CRE) zu bringen.

          (%i1) b : (x-y)^2;
                                                 2
          (%o1)                           (x - y)
          (%i2) coeff_list(a, x) := (
             a : rat(a),
             reverse( makelist(ratdisrep(coeff(a, x, i)), i,0, hipow(a, x)) ))$

          (%i3) coeff_list(b, x);
                                                   2
          (%o3)                        [1, - 2 y, y ]

 -- Funktion: content (<p>, <x_1>, ..., <x_n>)

     Gibt eine Liste zurück, deren erstes Element der größte gemeinsame
     Teiler der Koeffizienten des Polynoms <p> in der Variablen <x_n>
     ist und dessen zweites Element das durch den größten gemeinsamen
     Teiler dividierte Polynom ist.  Die anderen Argumente <x_1>, ...,
     <x_n-1> haben dieselbe Bedeutung wie für die Funktion 'ratvars'.

     Beispiel:

          (%i1) content(2*x*y + 4*x^2*y^2, y);
                                             2
          (%o1)                   [2 x, 2 x y  + y]

 -- Funktion: denom (<expr>)

     Gibt den Nenner des Ausdrucks <expr> zurück, wenn dieser ein
     Quotient ist.  Ist der Ausdruck <expr> kein Quotient wird <expr>
     zurückgegeben.

     Die Funktion 'denom' wertet das Argument aus.  Siehe auch die
     Funktion 'num'.

     Beispiel:

          (%i1) denom(x^2/(x+1));
          (%o1)                         x + 1

 -- Funktion: divide (<p_1>, <p_2>, <x_1>, ..., <x_n>)

     Berechnet den Quotienten und den Rest der Division des Polynom
     <p_1> durch das Polynom <p_2> für die Variable <x_n>.  Die anderen
     Argumente <x_1>, ..., <x_n-1> haben dieselbe Bedeutung wie für die
     Funktion 'ratvars'.  Das Ergebnis ist eine Liste, wobei das erste
     Element der Quotient und das zweite Element der Rest ist.

     Die Argumente der Funktion 'divide' können auch ganze Zahlen sein.

     Siehe auch die Funktionen 'quotient' und 'remainder', die jeweils
     den Quotienten und den Rest der Polynomdivision zurückgegeben.

     Beispiele:

     Im zweiten Beispiel ist 'y' die Hauptvariable des Ausdrucks.

          (%i1) divide (x + y, x - y, x);
          (%o1)                       [1, 2 y]
          (%i2) divide (x + y, x - y);
          (%o2)                      [- 1, 2 x]

     Ein Beispiel für zwei Polynome in zwei Variablen.

          (%i1) poly1 : sum(x^k*y^(6-k), k, 1, 5);
                            5    2  4    3  3    4  2    5
          (%o1)          x y  + x  y  + x  y  + x  y  + x  y
          (%i2) poly2 : sum(2*k*x^k*y^(3-k), k, 1, 3);
                                    2      2        3
          (%o2)                2 x y  + 4 x  y + 6 x
          (%i3) divide(poly1, poly2, x);
                        3        2      2          5       2  4
                     4 y  + 3 x y  + 9 x  y  23 x y  + 16 x  y
          (%o3)     [----------------------, ------------------]
                               54                    27
          (%i4) expand(first(%)*poly2 + second(%));
                            5    2  4    3  3    4  2    5
          (%o4)          x y  + x  y  + x  y  + x  y  + x  y

 -- Optionsvariable: dontfactor
     Standardwert: '[]'

     Der Optionsvariablen 'dontfactor' kann eine Liste mit den Variablen
     zugewiesen werden, bezüglich der ein Ausdruck nicht faktorisiert
     werden soll.  Weiterhin wird nicht bezüglich von Variablen
     faktorisiert, die gemäß der kanonischen Ordnung der Variablen von
     geringerer Bedeutung sind als die Variablen in der Liste
     'dontfactor'.

     Beispiel:

     Im zweiten Fall wird das Polynom nicht bezüglich der Variablen <x>
     faktorisiert.

          (%i1) expr:expand((x+1)^3*(y+2)^2);
                 3  2      2  2        2    2      3         2
          (%o1) x  y  + 3 x  y  + 3 x y  + y  + 4 x  y + 12 x  y + 12 x y
                                                       3       2
                                            + 4 y + 4 x  + 12 x  + 12 x + 4
          (%i2) factor(expr);
                                         3        2
          (%o2)                   (x + 1)  (y + 2)
          (%i3) dontfactor:[x];
          (%o3)                          [x]
          (%i4) factor(expr);
                             3      2                   2
          (%o4)            (x  + 3 x  + 3 x + 1) (y + 2)

 -- Funktion: eliminate ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_k>])

     Wendet ein Subresultanten-Verfahren an, um die Variablen <x_1>,
     ..., <x_k> aus den Gleichungen <eqn_1>, ..., <eqn_n> zu
     eliminieren.  Die Rückgabe ist ein Gleichungssystem mit '<n> - <k>'
     Gleichungen, wobei die <k>-Variablen <x_1>, ..., <x_k> eliminiert
     sind.

     Beispiel:

          (%i1) eqn1: 2*x^2 + y*x + z;
                                                2
          (%o1)                    z + x y + 2 x
          (%i2) eqn2: 3*x + 5*y - z - 1;
          (%o2)                  - z + 5 y + 3 x - 1
          (%i3) eqn3: z^2 + x - y^2 + 5;
                                    2    2
          (%o3)                    z  - y  + x + 5
          (%i4) eliminate([eqn1, eqn2, eqn3], [y,z]);
                        2      4      3       2
          (%o4)       [x  (45 x  + 3 x  + 11 x  + 81 x + 124)]

 -- Funktion: ezgcd (<p_1>, <p_2>, <p_3>, ...)

     Gibt eine Liste zurück, deren erstes Element der größte gemeinsame
     Teiler der Polynome <p_1>, ..., <p_n> ist und deren weitere
     Elemente die durch den größten gemeinsamen Teiler dividierten
     Polynome sind.  Der größte gemeinsame Teiler wird immer mit dem
     'ezgcd'-Algorithmus bestimmt.

     Siehe auch die Funktionen 'gcd', 'gcdex' 'gcdivide' und 'poly_gcd'.

     Beispiel:

     Die drei Polynome haben den größten gemeinsamen Teiler '2*x-3'.
     Der größte gemeinsame Teiler wird zuerst mit der Funktion 'gcd'
     berechnet.  Dann wird das Ergebnis der Funktion 'ezgcd' gezeigt.

          (%i1) p1 : 6*x^3-17*x^2+14*x-3;
                                  3       2
          (%o1)                6 x  - 17 x  + 14 x - 3
          (%i2) p2 : 4*x^4-14*x^3+12*x^2+2*x-3;
                              4       3       2
          (%o2)            4 x  - 14 x  + 12 x  + 2 x - 3
          (%i3) p3 : -8*x^3+14*x^2-x-3;
                                    3       2
          (%o3)                - 8 x  + 14 x  - x - 3

          (%i4) gcd(p1, gcd(p2, p3));
          (%o4)                        2 x - 3

          (%i5) ezgcd(p1, p2, p3);
                             2               3      2           2
          (%o5) [2 x - 3, 3 x  - 4 x + 1, 2 x  - 4 x  + 1, - 4 x  + x + 1]

 -- Optionsvariable: facexpand
     Standardwert: 'true'

     Die Optionsvariable 'facexpand' kontrolliert, ob die irreduziblen
     Faktoren der Faktorisierung mit 'factor' in einer expandierten oder
     in einer rekursiven (CRE-Form) vorliegen.  Der Standard ist, dass
     die Faktoren expandiert werden.

 -- Funktion: factor (<expr>)
 -- Funktion: factor (<expr>, <p>)

     Faktorisiert den Ausdruck <expr>, der eine beliebige Zahl an
     Variablen oder Funktionen enthalten kann, in irreduzible Faktoren
     über die ganzen Zahlen.  'factor(<expr>, <p>' faktorisiert <expr>
     über den Körper der rationalen Zahlen, der um die Nullstellen des
     minimalen Polynoms <p> erweitert ist.

     'factor' ruft die Funktion 'ifactors' auf, um ganze Zahlen zu
     faktorisieren.

     Hat die Optionsvariable 'factorflag' den Wert 'false', wird die
     Faktorisierung von ganzen Zahlen unterdrückt, die im Nenner einer
     rationalen Funktion auftreten.

     Der Optionsvariablen 'dontfactor' kann eine Liste mit den Variablen
     zugewiesen werden, bezüglich der ein Ausdruck nicht faktorisiert
     werden soll.  Weiterhin wird nicht bezüglich von Variablen
     faktorisiert, die gemäß der kanonischen Ordnung der Variablen von
     geringerer Bedeutung sind als die Variablen in der Liste
     'dontfactor'.

     Hat die Optionsvariable 'savefactors' den Wert 'true', versuchen
     einige Funktionen bei der Vereinfachung eine bereits vorhandene
     Faktorisierung zu erhalten, um weitere Vereinfachungen zu
     beschleunigen.

     Hat die Optionsvariable 'berlefact' den Wert 'false', dann wird der
     Kronecker-Algorithmus für die Faktorisierung genutzt.  Ansonsten
     wird der Berlekamp-Algorithmus genutzt.  Der Standardwert ist
     'true'.

     Hat die Optionsvariable 'intfaclim' den Wert 'true', gibt Maxima
     die Faktorisierung von ganzen Zahlen auf, wenn keine Faktorisierung
     durch Anwendung der Methode der Probedivision und der
     Pollard-Rho-Methode gefunden werden konnten.  Hat 'intfaclim' den
     Wert 'false', versucht Maxima eine ganze Zahl vollständig zu
     faktorisieren.  Der Wert der Optionsvariablen 'intfaclim' wird von
     der Funktion 'factor' beachtet.  Mit dem Setzen von 'intfaclim'
     kann der Nutzer verhindern, dass Maxima beim Versuch sehr große
     ganze Zahlen zu faktorisieren, unnötig viel Zeit verbraucht.

     Beispiele:

          (%i1) factor (2^63 - 1);
                              2
          (%o1)              7  73 127 337 92737 649657
          (%i2) factor (-8*y - 4*x + z^2*(2*y + x));
          (%o2)               (2 y + x) (z - 2) (z + 2)
          (%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                          2  2        2    2    2
          (%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
          (%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                                 2
                               (x  + 2 x + 1) (y - 1)
          (%o4)                ----------------------
                                     36 (y + 1)
          (%i5) factor (1 + %e^(3*x));
                                x         2 x     x
          (%o5)              (%e  + 1) (%e    - %e  + 1)
          (%i6) factor (1 + x^4, a^2 - 2);
                              2              2
          (%o6)             (x  - a x + 1) (x  + a x + 1)
          (%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                                 2
          (%o7)              - (y  + x) (z - x) (z + x)
          (%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                                       x + 2
          (%o8)               ------------------------
                                                     2
                              (x + 3) (x + b) (x + c)
          (%i9) ratsimp (%);
                          4                  3
          (%o9) (x + 2)/(x  + (2 c + b + 3) x

               2                       2             2                   2
           + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
          (%i10) partfrac (%, x);
                     2                   4                3
          (%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

               2              2         2                2
           + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                           c - 2
           - ---------------------------------
               2                             2
             (c  + (- b - 3) c + 3 b) (x + c)

                                   b - 2
           + -------------------------------------------------
                       2             2       3      2
             ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                                   1
           - ----------------------------------------------
                       2
             ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
          (%i11) map ('factor, %);
                        2
                       c  - 4 c - b + 6                 c - 2
          (%o11) - ------------------------- - ------------------------
                          2        2                                  2
                   (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                                 b - 2                        1
                      + ------------------------ - ------------------------
                                       2                          2
                        (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
          (%i12) ratsimp ((x^5 - 1)/(x - 1));
                                 4    3    2
          (%o12)                x  + x  + x  + x + 1
          (%i13) subst (a, x, %);
                                 4    3    2
          (%o13)                a  + a  + a  + a + 1
          (%i14) factor (%th(2), %);
                                 2        3        3    2
          (%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
          (%i15) factor (1 + x^12);
                                 4        8    4
          (%o15)               (x  + 1) (x  - x  + 1)
          (%i16) factor (1 + x^99);
                           2            6    3
          (%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

             10    9    8    7    6    5    4    3    2
           (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

             20    19    17    16    14    13    11    10    9    7    6
           (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

              4    3            60    57    51    48    42    39    33
           - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

              30    27    21    18    12    9    3
           - x   - x   + x   + x   - x   - x  + x  + 1)

     Das Polynom 'x^4+1' lässt sich nicht über den Körper der ganzen
     Zahlen faktorisieren.  Wird der Körper um das minimale Polynom
     'a^2+1' erweitert, ist die Faktorisierung möglich.  Die Nullstellen
     des minimalen Polynoms sind die imaginäre Einheit '%i' und '-%i'.
     Das Ergebnis entspricht der Faktorisierung mit der Funktion
     'gfactor'.

          (%i1) factor(x^4+1);
                                        4
          (%o1)                        x  + 1
          (%i2) factor(x^4+1, a^2+1);
                                    2        2
          (%o2)                   (x  - a) (x  + a)
          (%i3) gfactor(x^4+1);
                                   2         2
          (%o3)                  (x  - %i) (x  + %i)

 -- Optionsvariable: factorflag
     Standardwert: 'false'

     Hat die Optionsvariable 'factorflag' den Wert 'false', wird die
     Faktorisierung von ganzen Zahlen unterdrückt, die im Nenner einer
     rationalen Funktion auftreten.

     Beispiel:

          (%i1) factorflag:false;
          (%o1)                         false
          (%i2) factor(1/6*(x^2+2*x+1));
                                             2
                                      (x + 1)
          (%o2)                       --------
                                         6
          (%i3) factorflag:true;
          (%o3)                         true
          (%i4) factor(1/6*(x^2+2*x+1));
                                             2
                                      (x + 1)
          (%o4)                       --------
                                        2 3

 -- Funktion: factorout (<expr>, <x_1>, <x_2>, ...)

     Gruppiert eine Summe <expr> in eine Summe mit Termen der Form
     'f(<x_1>, <x_2>, ...) * g', wobei 'g' ein gemeinsamer Faktor des
     Polynoms 'f' ist.

     Beispiele:

     Das Polynom wird zuerst nach der Variablen <x>, dann nach <y> und
     zuletzt nach beiden Variablen faktorisiert.

          (%i1) factorout(2*a*x^2+a*x+a+a*y, x);
                                           2
          (%o1)                a y + a (2 x  + x + 1)
          (%i2) factorout(2*a*x^2+a*x+a+a*y, y);
                                               2
          (%o2)               a (y + 1) + 2 a x  + a x
          (%i3) factorout(2*a*x^2+a*x+a+a*y, y, x);
                                          2
          (%o3)                 a (y + 2 x  + x + 1)

 -- Funktion: factorsum (<expr>)

     Versucht Terme in <expr> so zu gruppieren, dass die Teilsummen
     faktorisierbar sind.  'factorsum' kann zum Beispiel das expandierte
     Polynom 'expand ((x + y)^2 + (z + w)^2)' wieder herstellen, nicht
     jedoch das expandierte Polynom 'expand ((x + 1)^2 + (x + y)^2)', da
     die Terme gemeinsame Variablen enthalten.

     Beispiele:

          (%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
                     2      2                            2      2
          (%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                               2        2    2            2
                                  + 2 u v x + u  x + a w  + v  + 2 u v + u
          (%i2) factorsum(%);
                                             2          2
          (%o2)            (x + 1) (a (z + w)  + (v + u) )

 -- Funktion: fasttimes (<p_1>, <p_2>)

     Führt eine schnelle Multiplikation der Polynome <p_1> und <p_2> aus
     und gibt das Ergebnis zurück.  Der Algorithmus ist von Vorteil,
     wenn die Polynome mehrere Variablen haben und die Koeffizienten
     dicht besetzt sind.  Sind 'n_1' und 'n_2' jeweils der Grad der
     Polynome <p_1> und <p_2>, dann benötigt die schnelle Multiplikation
     'max(n_1, n_2)^1.585' Multiplikationen.

 -- Funktion: fullratsimp (<expr>)
 -- Funktion: fullratsimp (<expr>, <x_1>, ..., <x_n>)

     Die Funktion 'fullratsimp' wendet die Funktion 'ratsimp' auf das
     Argument <expr> solange wiederholt an, bis sich das Ergebnis nicht
     mehr ändert.  Nach jeder Anwendung von 'ratsimp' wird der Ausdruck
     zusätzlich vereinfacht.

     Sind nicht-rationale Ausdrücke in einem Ausdruck enthalten, kann
     der Ausdruck möglicherweise mit einem Aufruf von 'ratsimp' nicht
     vollständig vereinfacht werden.  Dann kann der mehrfache Aufruf von
     'ratsimp' zu einem besser vereinfachten Resultat führen.  Die
     Funktion 'fullratsimp' ist für solche Falle gedacht.

     Die weiteren Argumente <x_1>, ..., <x_n> entsprechen denen der
     Funktionen 'ratsimp' und 'rat'.

     Beispiele:

          (%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                                 a/2     2   a/2     2
                               (x    - 1)  (x    + 1)
          (%o1)                -----------------------
                                        a
                                       x  - 1
          (%i2) ratsimp (expr);
                                    2 a      a
                                   x    - 2 x  + 1
          (%o2)                    ---------------
                                        a
                                       x  - 1
          (%i3) fullratsimp (expr);
                                        a
          (%o3)                        x  - 1
          (%i4) rat (expr);
                                 a/2 4       a/2 2
                               (x   )  - 2 (x   )  + 1
          (%o4)/R/             -----------------------
                                        a
                                       x  - 1

 -- Funktion: fullratsubst (<a>, <b>, <c>)

     Entspricht der Funktion 'ratsubst' mit dem Unterschied, dass die
     Funktion solange rekursiv ausgeführt wird, bis sich das Ergebnis
     nicht mehr ändert.  Diese Funktion kann nützlich sein, wenn der
     Ausdruck, der eingesetzt wird, und der zu ersetzende Ausdruck
     mehrere Variablen gemeinsam haben.

     'fullratsubst' akzeptiert auch Argumente im Format der Funktion
     'lratsubst'.  Das erste Argument kann also auch eine einzelne oder
     eine Liste von Gleichungen sein.  Das zweite Argument ist in diesem
     Fall der Ausdruck in dem die Ersetzungen durchgeführt werden.

     Mit dem Kommando 'load(lrats)' werden die Funktionen 'fullratsubst'
     und 'lratsubst' geladen.

     Beispiele:

          (%i1) load ("lrats")$

     'subst' kann mehrfache Substitutionen ausführen.  Die Funktion
     'lratsubst' funktioniert analog zu der Funktion 'subst'.

          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c

     Ist nur eine Substitution auszuführen, kann diese als eine einzelne
     Gleichung angegeben werden.

          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b

     'fullratsubst' ist äquivalent zur Funktion 'ratsubst' mit dem
     Unterschied, dass die Funktion solange rekursiv angewendet wird,
     bis sich das Ergebnis nicht mehr ändert.

          (%i5) ratsubst (b*a, a^2, a^3);
                                         2
          (%o5)                         a  b
          (%i6) fullratsubst (b*a, a^2, a^3);
                                           2
          (%o6)                         a b

     'fullratsubst' akzeptiert auch eine Liste mit Gleichungen oder eine
     Gleichung als erstes Argument.

          (%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
          (%o7)                           b
          (%i8) fullratsubst (a^2 = b*a, a^3);
                                           2
          (%o8)                         a b

     'fullratsubst' kann zu einer unendlichen Rekursion führen.

          (%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

          *** - Lisp stack overflow. RESET

 -- Funktion: gcd (<p_1>, <p_2>, <x_1>, ...)
 -- Optionsvariable: gcd

     Gibt den größten gemeinsamen Teiler der Polynome <p_1> und <p_2>
     zurück.  Die Argumente <x_1>, ... sind optional und haben dieselbe
     Bedeutung wie für die Funktion 'ratvars'.  Die Optionsvariable
     'gcd' kontrolliert, welcher Algorithmus verwendet wird und kann die
     folgenden Werte annehmen:

     'ez'
          ezgcd-Alogrithmus
     'subres'
          Subresultanten-Algorithmus
     'red'
          Reduzierter modularer Algorithmus
     'spmod'
          Modularer Algorithmus
     'false'
          kein Algorithmus, die Rückgabe ist immer 1

     Siehe auch die 'ezgcd', 'gcdex', 'gcdivide', und 'poly_gcd'.

     Beispiele:

          (%i1) p1:6*x^3+19*x^2+19*x+6;
                                  3       2
          (%o1)                6 x  + 19 x  + 19 x + 6
          (%i2) p2:6*x^5+13*x^4+12*x^3+13*x^2+6*x;
                            5       4       3       2
          (%o2)          6 x  + 13 x  + 12 x  + 13 x  + 6 x
          (%i3) gcd(p1, p2);
                                      2
          (%o3)                    6 x  + 13 x + 6
          (%i4) p1/gcd(p1, p2), ratsimp;
          (%o4)                         x + 1
          (%i5) p2/gcd(p1, p2), ratsimp;
                                        3
          (%o5)                        x  + x

     Die Funktion 'ezgcd' gibt als Ergebnis eine Liste zurück, die als
     erstes Element den größten gemeinsamen Teiler und als weitere
     Elemente die durch den größten gemeinsamen Teiler dividierten
     Polynome enthält.

          (%i6) ezgcd(p1, p2);
                              2                     3
          (%o6)           [6 x  + 13 x + 6, x + 1, x  + x]

 -- Funktion: gcdex (<p_1>, <p_2>)
 -- Funktion: gcdex (<p_1>, <p_2>, <x>)

     Wendet den erweiterten Euklidischen Algorithmus für die beiden
     Polynome <p_1> und <p_2> an und gibt eine Liste '[s, t, u]' mit den
     Parametern <u>, <s> und <t> als Ergebnis zurück.  Der Parameter <u>
     ist der größte gemeinsame Teiler der Polynome.  Die Parameter <s>
     und <t> sind die Bezoutkoeffizienten, so dass gilt 'u = s * p_1 + t
     * p_2'.

     Die Rückgabe der Funktion 'gcdex' ist in der CRE-Form.

     Siehe auch die Funktionen 'ezgcd', 'gcd' und 'gcdivide'.

     Die Argumente <f> und <g> können ganze Zahlen sein.  In diesem
     Falle wird die Funktion 'igcdex' von der Funktion 'gcdex'
     aufgerufen.

     Siehe auch die Funktionen 'ezgcd', 'gcd', 'gcdivide' und
     'poly_gcd'.

     Beispiel:

          (%i1) gcdex (x^2 + 1, x^3 + 4);
                                 2
                                x  + 4 x - 1  x + 4
          (%o1)/R/           [- ------------, -----, 1]
                                     17        17
          (%i2) % . [x^2 + 1, x^3 + 4, -1];
          (%o2)/R/                        0

     Im folgenden Beispiel ist die unabhängige Variable explizit als <x>
     angegeben.  Ohne diese Angabe ist <y> die unabhängige Variable.

          (%i1) gcdex (x*(y + 1), y^2 - 1, x);
                                         1
          (%o1)/R/                 [0, ------, 1]
                                        2
                                       y  - 1

 -- Funktion: gcfactor (<g>)

     Faktorisiert die Gaußsche Zahl <g> über die Gaußsche Zahlen.  Eine
     Gaußsche Zahl 'g' ist durch 'g = a + b*%i' gegeben, wobei 'a' und
     'b' ganze Zahlen sind.  Die Faktoren werden so normalisiert, dass
     <a> und <b> nicht negativ sind.

     Beispiele:

          (%i1) gcfactor(5);
          (%o1)               - %i (1 + 2 %i) (2 + %i)
          (%i2) expand(%);
          (%o2)                           5
          (%i3) gcfactor(5+%i);
          (%o3)               - %i (1 + %i) (2 + 3 %i)
          (%i4) expand(%);
          (%o4)                        %i + 5

 -- Funktion: gfactor (<expr>)

     Faktorisiert das Polynom <expr> über die Gaußschen Zahlen.  Das ist
     die Faktorisierung über den Körper der ganzen Zahlen, der um das
     Element <%i> erweitert ist.

     Die Faktorisierung der Funktion 'gfactor' ist äquivalent zu
     'factor(<expr>), <a>^2+1)' mit dem minimalen Polynom '<a>^2+1', das
     die Nullstelle '%i' hat.  Siehe auch 'factor'.

     Beispiel:

          (%i1) gfactor(x^4 - 1);
          (%o1)           (x - 1) (x + 1) (x - %i) (x + %i)
          (%i2) factor(x^4 - 1, a^2+1);
          (%o2)            (x - 1) (x + 1) (x - a) (x + a)

 -- Funktion: gfactorsum (<expr>)

     Entspricht der Funktion 'factorsum' mit den Unterschied, dass
     anstatt der Funktion 'factor' die Funktion 'gfactor' angewendet
     wird, um den Ausdruck <expr> zu faktorisieren.

 -- Funktion: hipow (<expr>, <x>)

     Gibt den größten Exponenten des Arguments <x> zurück, der im
     Ausdruck <expr> auftritt.  Treten symbolische Exponenten auf, wird
     ein Ausdruck mit 'max' zurückgegeben.  Ist das Argument <x> nicht
     im Ausdruck vorhanden, ist die Rückgabe '0'.

     Die Funktion 'hipow' betrachtet keine äquivalenten Ausdrücke.
     Daher können die Ausdrücke 'expand(<expr>)' und <expr> ein
     verschiedenes Ergebnis haben.

     Siehe auch die Funktionen 'lopow' und 'coeff'.

     Beispiele:

          (%i1) hipow (y^3 * x^2 + x * y^4, x);
          (%o1)                           2
          (%i2) hipow ((x + y)^5, x);
          (%o2)                           1
          (%i3) hipow (expand ((x + y)^5), x);
          (%o3)                           5
          (%i4) hipow ((x + y)^5, x + y);
          (%o4)                           5
          (%i5) hipow (expand ((x + y)^5), x + y);
          (%o5)                           0
          (%i1) hipow ((x+y)^2 + (x+y)^a, x+y);
          (%o1)                       max(2, a)

 -- Optionsvariable: intfaclim
     Standardwert: 'true'

     Hat die Optionsvariable 'intfaclim' den Wert 'true', gibt Maxima
     die Faktorisierung von ganzen Zahlen auf, wenn keine Faktorisierung
     durch Anwendung der Methode der Probedivision und der
     Pollard-Rho-Methode gefunden werden konnten.

     Hat 'intfaclim' den Wert 'false', versucht Maxima eine ganze Zahl
     vollständig zu faktorisieren.  'intfaclim' wird von den Funktionen
     'divisors', 'divsum' und 'totient' auf den Wert 'false' gesetzt.

     Der Wert der Optionsvariablen 'intfaclim' wird von der Funktion
     'factor' beachtet.  Mit dem Setzen von 'intfaclim' kann der Nutzer
     verhindern, dass Maxima beim Versuch sehr große ganze Zahlen zu
     faktorisieren, unnötig viel Zeit verbraucht.

 -- Optionsvariable: keepfloat
     Standardwert: 'false'

     Hat die Optionsvariable 'keepfloat' den Wert 'true', werden
     Gleitkommazahlen nicht in rationale Zahlen umgewandelt, wenn
     Ausdrücke mit Gleitkommazahlen in eine CRE-Form umgewandelt werden.

     Die Funktion 'solve' und Funktionen, die 'solve' aufrufen, beachten
     den Wert von 'keepfloat' nicht.

     Beispiele:

          (%i1) rat(x/2.0);

          rat: replaced 0.5 by 1/2 = 0.5
                                          x
          (%o1)/R/                        -
                                          2
          (%i2) rat(x/2.0), keepfloat;
          (%o2)/R/                      0.5 x

     Die Funktion 'solve' ignoriert den Wert der Optionsvariablen
     'keepfloat'.

          (%i3) solve(1.0-x,x), keepfloat;

          rat: replaced 1.0 by 1/1 = 1.0
          (%o3)                        [x = 1]

 -- Funktion: lopow (<expr>, <x>)

     Gibt den kleinsten Exponenten von <x> zurück, der im Ausdruck
     <expr> auftritt.  Treten symbolische Exponententen auf, wird ein
     Ausdruck mit 'min' zurückgegeben.  Ist das Argument <x> nicht im
     Ausdruck enthalten, ist die Rückgabe 0.

     Die Funktion 'lopow' betrachtet keine äquivalenten Ausdrücke.
     Daher können die Ausdrücke 'expand(<expr>)' und <expr> ein
     verschiedenes Ergebnis haben.

     Siehe auch die Funktionen 'hipow' und 'coeff'.

     Beispiele:

          (%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
          (%o1)                       min(a, 2)

 -- Funktion: lratsubst (<L>, <expr>)

     Ist analog zum Kommando 'subst (<L>, <expr>)' mit dem Unterschied,
     dass anstatt der Funktion 'subst' die Funktion 'ratsubst' genutzt
     wird.

     Das erste Argument der Funktion 'lratsubst' ist eine Gleichung oder
     eine Liste mit Gleichungen, die dem Format der Funktion 'subst'
     entsprechen.  Die Substitutionen werden in der Reihenfolge der
     Gleichungen der Liste von links nach rechts ausgeführt.

     Mit dem Kommando 'lrats' werden die Funktionen 'fullratsubst' und
     'lratsubst' geladen.  Siehe auch die Funktion 'fullratsubst'.

     Beispiele:

          (%i1) load (lrats)$

     'subst' kann mehrfache Substitutionen ausführen.  'lratsubst' ist
     analog zu 'subst'.

          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c

     Soll nur eine Substitution ausgeführt werden, kann eine einzelne
     Gleichung als erstes Argument angegeben werden.

          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b

 -- Optionsvariable: modulus
     Standardwert: 'false'

     Hat die Optionsvariable 'modulus' eine positive Zahl <p> als Wert,
     werden Operationen für rationale Zahlen, wie von der Funktion 'rat'
     und verwandte Funktionen, modulo <p> ausgeführt.

     '<n>' mod <p> ist definiert als eine ganze Zahl, die für ungerade
     <p> die Werte '[-(<p>-1)/2, ..., 0, ..., (<p>-1)/2]' annimmt und
     für gerade <p> die Werte '[-(<p>/2 - 1), ..., 0, ...., <p>/2]', so
     dass '<a> <p> + <k>' gleich <n> ist für eine ganze Zahl <a>.

     Liegt ein Ausdruck <expr> bereits in einer CRE-Form vor und wird
     der Wert der Optionsvariable 'modulus' geändert, dann sollte der
     Ausdruck zum Beispiel mit dem Kommando 'expr: rat (ratdisrep
     (expr))' zunächst in die Standardform gebracht werden, um dann
     erneut in die CRE-Form umgewandelt zu werden, um korrekte
     Ergebnisse zu erzielen.

     Typischerweise erhält die Optionsvariable 'modulus' eine Primzahl
     als Wert.  Erhält 'modulus' eine positive ganze Zahl als Wert, die
     nicht eine Primzahl ist, wird die Zuweisung akzeptiert, jedoch eine
     Warnung ausgegeben.  Wird Null oder eine negative Zahl zugewiesen
     signalisiert Maxima einen Fehler.

     Beispiele:

          (%i1) modulus:7;
          (%o1)                           7
          (%i2) polymod([0,1,2,3,4,5,6,7]);
          (%o2)            [0, 1, 2, 3, - 3, - 2, - 1, 0]
          (%i3) modulus:false;
          (%o3)                         false
          (%i4) poly:x^6+x^2+1;
                                      6    2
          (%o4)                      x  + x  + 1
          (%i5) factor(poly);
                                      6    2
          (%o5)                      x  + x  + 1
          (%i6) modulus:13;
          (%o6)                          13
          (%i7) factor(poly);
                                2        4      2
          (%o7)               (x  + 6) (x  - 6 x  - 2)
          (%i8) polymod(%);
                                      6    2
          (%o8)                      x  + x  + 1

 -- Funktion: num (<expr>)

     Gibt den Zähler des Ausdrucks <expr> zurück, wenn dieser ein
     Quotient ist.  Ist der Ausdruck <expr> kein Quotient wird <expr>
     zurückgegeben.

     Die Funktion 'num' wertet das Argument aus.  Siehe auch die
     Funktion 'denom'.

     Beispiel:

          (%i1) num(x^2/(x+1));
                                          2
          (%o1)                          x

 -- Funktion: partfrac (<expr>, <var>)

     Führt für den Ausdruck <expr> eine vollständige
     Partialbruchzerlegung aus.

          (%i1) 1/(1+x)^2 - 2/(1+x) + 2/(2+x);
                                2       2        1
          (%o1)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)
          (%i2) ratsimp (%);
                                           x
          (%o2)                 - -------------------
                                   3      2
                                  x  + 4 x  + 5 x + 2
          (%i3) partfrac (%, x);
                                2       2        1
          (%o3)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)

 -- Funktion: polydecomp (<p>, <x>)

     Zerlegt das Polynom <p> in der Variablen <x> in Polynome, die
     miteinander verkettet das ursprüngliche Polynom ergeben.
     'polydecomp' gibt eine Liste '[<p_1>, ..., <p_n>]' zurück, so dass
     der folgende Ausdruck gleich dem Polynom <p> ist:

          lambda ([x], p_1) (lambda ([x], p_2) (... (lambda ([x], p_n) (x))
            ...))

     Der Grad des Polynoms <p_i> ist größer als 1 für <i> kleiner als
     <n>.

     Eine solche Zerlegung ist nicht eindeutig.

     Beispiele:

          (%i1) polydecomp (x^210, x);
                                    7   5   3   2
          (%o1)                   [x , x , x , x ]
          (%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                          6      4      3    2
          (%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
          (%i3) polydecomp (p, x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     Die folgende Funktion verkettet die Elemente der Liste 'L = [e_1,
     ..., e_n]' zu einer Funktion in der Variablen <x>.  Diese Funktion
     ist die Inverse Operation zu der Funktion 'polydecomp'.

          compose (L, x) :=
            block ([r : x], for e in L do r : subst (e, x, r), r) $

     Anwendung der Funktionen 'compose' und 'polydecomp'.

          (%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     Während 'compose (polydecomp (<p>, <x>), <x>)' immer das Polynom
     <p> als Ergebnis hat, hat 'polydecomp (compose ([<p_1>, ...,
     <p_n>], <x>), <x>)' nicht notwendigerweise das Ergebnis '[<p_1>,
     ..., <p_n>]'.

          (%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                                    2       2
          (%o4)                   [x  + 2, x  + 1]
          (%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
                                2       2
                               x  + 3  x  + 5
          (%o5)               [------, ------, 2 x + 1]
                                 4       2

 -- Funktion: polymod (<p>)
 -- Funktion: polymod (<p>, <m>)

     Konvertiert das Polynom <p> in eine modulare Darstellung bezüglich
     dem aktuellen Modul.  Das Modul ist der Wert der Variablen
     'modulus'.

     'polymod(<p>, <m>' konvertiert das Polynom bezüglich dem Modul <m>,
     anstatt dem aktuellen Modul 'modulus'.

     Siehe auch 'modulus'.

 -- Funktion: powers (<expr>, <x>)

     Gibt eine Liste mit den Potenzen der Variablen <x> zurück, die im
     Ausdruck <expr> auftreten.

     Mit dem Kommando 'load(powers)' wird die Funktion geladen.

 -- Funktion: quotient (<p_1>, <p_2>)
 -- Funktion: quotient (<p_1>, <p_2>, <x_1>, ..., <x_n>)

     Berechnet den Quotienten der Polynome <p_1> und <p_2> für die
     Variable <x_n>.  Die anderen Variablen <x_1>, ..., <x_n-1> haben
     dieselbe Bedeutung wie für die Funktion 'ratvars'.

     'quotient' gibt das erste Element des Ergebnisses der Funktion
     'divide' zurück.

     Siehe auch die Funktion 'remainder'.

     Beispiel:

          (%i1) poly1 : x^3-2*x^2-5*x+7;
                                  3      2
          (%o1)                  x  - 2 x  - 5 x + 7
          (%i2) poly2 : x-1;
          (%o2)                         x - 1
          (%i3) quotient(poly1, poly2, x);
                                      2
          (%o3)                      x  - x - 6

 -- Funktion: rat (<expr>)
 -- Funktion: rat (<expr>, <x_1>, ..., <x_n>)

     Konvertiert einen Ausdruck <expr> in die CRE-Form.  Der Ausdruck
     wird so expandiert und gruppiert, dass alle Terme einen gemeinsamen
     Nenner haben und der größte gemeinsame Teiler gekürzt ist.
     Weiterhin werden Gleitkommazahlen in rationale Zahlungen
     umgewandelt.  Die Toleranz der Umwandlung wird von der
     Optionsvariablen 'ratepsilon' kontrolliert.  Die Variablen im
     Ausdruck werden entsprechend der Funktion 'ratvars' gemäß der
     angegebenen Argumente <x_1>, ..., <x_n> angeordnet.

     'rat' vereinfacht im Allgemeinen keine Ausdrücke bis auf die
     Addition '+', Subtraktion '-', Multiplikation '*', Division '/' und
     die Exponentiation '^' mit einer ganzen Zahl.  Dagegen führt die
     Funktion 'ratsimp' auch weitere Vereinfachungen aus.  Variablen und
     Zahlen in einer CRE-Form sind nicht identisch mit denen in der
     Standardform.  Zum Beispiel hat 'rat(x)- x' das Ergebnis 'rat(0)',
     welches eine andere interne Darstellung als '0' hat.

     Hat die Optionsvariable 'ratfac' den Wert 'true', wird ein Ausdruck
     von der Funktion 'rat' nur teilweise faktorisiert.  Bei der
     Ausführung von Operationen wird bleibt der Ausdruck so vollständig
     als möglich in seiner faktorisierten Form, ohne dass eine
     Faktorisierung ausgeführt wird.  Damit kann Rechenzeit eingespart
     werden.

     Hat die Optionsvariable 'ratprint' den Wert 'false', werden
     Meldungen unterdrückt, wenn eine Gleitkommazahl in eine rationale
     umgewandelt wird.

     Hat die Optionsvariable 'keepfloat' den Wert 'true', werden
     Gleitkommazahlen nicht in rationale Zahlen umgewandelt.

     Siehe auch die Funktionen 'ratexpand' und 'ratsimp', um Ausdrücke
     zu vereinfachen, sowie die Funktion 'ratdisrep', um einen Ausdruck
     von einer CRE-Form in eine allgemeine Form zu transformieren.

     Beispiele:

          (%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /
                (4*y^2 + x^2);
                                                     4
                                            (x - 2 y)
                        (y + a) (2 y + x) (------------ + 1)
                                             2      2 2
                                           (x  - 4 y )
          (%o1)         ------------------------------------
                                        2    2
                                     4 y  + x
          (%i2) rat (%, y, a, x);
                                      2 a + 2 y
          (%o2)/R/                    ---------
                                       x + 2 y

 -- Optionsvariable: ratalgdenom
     Standardwert: 'true'

     Hat die Optionsvariable 'ratalgdenom' den Wert 'true', versucht
     Maxima den Nenner beim Auftreten von Wurzeln rational zu machen.
     'ratalgdenom' wirkt sich nur aus, wenn die Optionsvariable
     'algebraic' den Wert 'true' hat und der Ausdruck in einer CRE-Form
     vorliegt.

     Beispiele:

          (%i1) algebraic:true$

          (%i2) ratalgdenom:false$

          (%i3) rat(sqrt(3)/sqrt(2));
                                       sqrt(3)
          (%o3)/R/                     -------
                                       sqrt(2)
          (%i4) ratalgdenom:true$

          (%i5) rat(sqrt(3)/sqrt(2));
                                   sqrt(2) sqrt(3)
          (%o5)/R/                 ---------------
                                          2
          (%i6) algebraic:false$

          (%i7) rat(sqrt(3)/sqrt(2));
                                       sqrt(3)
          (%o7)/R/                     -------
                                       sqrt(2)

 -- Funktion: ratcoef (<expr>, <x>, <n>)
 -- Funktion: ratcoef (<expr>, <x>)

     Gibt den Koeffizienten des Ausdrucks '<x>^<n>' in dem Argument
     <expr> zurück.  Wenn das Argument <n> nicht angegeben ist, wird der
     Wert zu '1' angenommen.

     Die Rückgabe ist frei von der Variablen <x>.  Existiert kein
     Koeffizient '<x>^<n>' dann ist die Rückgabe '0'.

     'ratcoef' expandiert und vereinfacht das Argument <expr>.  Daher
     kann 'ratcoef' ein anderes Ergebnis als die Funktion 'coeff' haben,
     die keine Vereinfachungen ausführt.  Daher 'ratcoef((x + 1)/y + x,
     x)' das Ergebnis '(y + 1)/y' und nicht das Ergebnis '1' wie es von
     der Funktion 'coeff' zurückgegeben wird.

     'ratcoef(<expr>, <x>, 0)' gibt eine Summe der Terme zurück, die die
     Variable <x> nicht enthalten.

     Beispiele:

          (%i1) s: a*x + b*x + 5$
          (%i2) ratcoef (s, a + b);
          (%o2)                           x

 -- Funktion: ratdenom (<expr>)

     Gibt den Nenner des Argumentes <expr> zurück.  'ratdenom' wandelt
     den Ausdruck zuerst in eine CRE-Form um und gibt das Ergebnis in
     einer CRE-Form zurück.

     Das Argument <expr> wird von der Funktion 'rat' in eine CRE-Form
     gebracht, falls <expr> nicht bereits in einer CRE-Form vorliegt.
     Diese Transformation kann den Ausdruck <expr> verändern, da alle
     Terme über einen gemeinsamen Nenner zusammengefasst werden.

     Die Funktion 'denom' ist vergleichbar.  'denom' wandelt den
     Ausdruck jedoch nicht eine CRE-Form um und hat als Ergebnis einen
     Ausdruck in der Standardform.  Daher können sich die Ergebnisse von
     'ratdenom' und 'denom' voneinander unterscheiden.

     Beispiel:

          (%i1) expr: expand((x^2+2*x+3)/(x-1));
                                  2
                                 x       2 x      3
          (%o1)                 ----- + ----- + -----
                                x - 1   x - 1   x - 1
          (%i2) ratdenom(expr);
          (%o2)/R/                      x - 1
          (%i3) denom(expr);
          (%o3)                           1

 -- Optionsvariable: ratdenomdivide
     Standardwert: 'true'

     Hat die Optionsvariable 'ratdenomdivide' den Wert 'true',
     expandiert die Funktion 'ratexpand' einen Quotienten der im Zähler
     eine Summe hat, in eine Summe der Quotienten.  Ansonsten werden die
     Terme über einen gemeinsamen Nenner zusammengefasst.

     Beispiele:

          (%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                                      2
                                     x  + x + 1
          (%o1)                      ----------
                                        2
                                       y  + 7
          (%i2) ratdenomdivide: true$
          (%i3) ratexpand (expr);
                                 2
                                x        x        1
          (%o3)               ------ + ------ + ------
                               2        2        2
                              y  + 7   y  + 7   y  + 7
          (%i4) ratdenomdivide: false$
          (%i5) ratexpand (expr);
                                      2
                                     x  + x + 1
          (%o5)                      ----------
                                        2
                                       y  + 7
          (%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
                                               2
                                     b        a
          (%o6)                    ------ + ------
                                    2        2
                                   b  + 3   b  + 3
          (%i7) ratexpand (expr2);
                                            2
                                       b + a
          (%o7)                        ------
                                        2
                                       b  + 3

 -- Funktion: ratdiff (<expr>, <x>)

     Differenziert einen rationalen Ausdruck <expr> nach der Variablen
     <x>.  <expr> muss eine rationale Funktion oder ein Polynom in der
     Variablen <x> sein.  Das Argument <x> kann ein Teilausdruck des
     Argumentes <expr> sein.

     Das Ergebnis ist äquivalent zum Ergebnis der Funktion 'diff', kann
     aber eine andere Form haben.  Für rationale Funktionen kann die
     Funktion 'ratdiff' schneller sein.

     'ratdiff' gibt das Ergebnis in einer CRE-Form zurück, wenn das
     Argument in einer CRE-Form vorliegt.  Ansonsten ist das Ergebnis in
     der Standardform.

     'ratdiff' beachtet nur die Abhängigkeit des Ausdrucks von der
     Variablen <x>.  Abhängigkeiten die mit der Funktion 'depends'
     definiert werden, werden von der Funktion 'ratdiff' ignoriert.

     Beispiele:

          (%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                                     3
                                  4 x  + 10 x - 11
          (%o1)                   ----------------
                                        5
                                       x  + 5
          (%i2) ratdiff (expr, x);
                              7       5       4       2
                           8 x  + 40 x  - 55 x  - 60 x  - 50
          (%o2)          - ---------------------------------
                                    10       5
                                   x   + 10 x  + 25
          (%i3) expr: f(x)^3 - f(x)^2 + 7;
                                   3       2
          (%o3)                   f (x) - f (x) + 7
          (%i4) ratdiff (expr, f(x));
                                     2
          (%o4)                   3 f (x) - 2 f(x)
          (%i5) expr: (a + b)^3 + (a + b)^2;
                                        3          2
          (%o5)                  (b + a)  + (b + a)
          (%i6) ratdiff (expr, a + b);
                              2                    2
          (%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a

 -- Funktion: ratdisrep (<expr>)

     Gibt das Argument <expr> als einen allgemeinen Ausdruck zurück.
     Ist <expr> bereits ein allgemeiner Ausdruck, wird dieser
     unverändert zurückgegeben.

     Im Allgemeinen wird die Funktion 'ratdisrep' aufgerufen, um einen
     Ausdruck von der CRE-Form in einen allgemeinen Ausdruck
     umzuwandeln.

     Siehe auch die Funktion 'totaldisrep'.

 -- Funktion: ratexpand (<expr>)
 -- Optionsvariable: ratexpand

     Expandiert das Argument <expr> indem Produkte und Potenzen von
     Summen ausmultipliziert, Brüche über einen gemeinsamen Nenner
     dargestellt werden und der größte gemeinsamen Teiler heraus gekürzt
     wird.  Ist der Zähler eine Summe, wird er in seine Terme
     aufgespalten, die jeweils durch den Nenner dividiert werden.

     Die Rückgabe der Funktion 'ratexpand' ist ein allgemeiner Ausdruck,
     auch wenn das Argument <expr> ein Ausdruck in der CRE-Form ist.

     Die Optionsvariable 'ratexpand' kontrolliert die Vereinfachung der
     Funktion 'ratsimp'.  Hat 'ratexpand' den Wert 'true', wird ein
     Ausdruck vollständig ausmultipliziert.  Ist der Wert 'false', wird
     der Ausdruck nur bezüglich der Hauptvariablen ausmultipliziert.
     Zum Beispiel hat 'ratsimp((x+1)*(y+1))' das Ergebnis 'x y + y + x +
     1', wenn 'ratexpand' den Wert 'true' hat, ansonsten ist das
     Ergebnis '(x + 1) y + x + 1'.  Siehe auch die Funktion 'ratsimp'.

     Hat die Optionsvariable 'ratdenomdivide' den Wert 'true',
     expandiert die Funktion 'ratexpand' einen Quotienten der im Zähler
     eine Summe hat, in eine Summe der Quotienten.  Ansonsten werden die
     Terme über einen gemeinsamen Nenner zusammengefasst.

     Hat die Optionsvariable 'keepfloat' den Wert 'true', werden
     Gleitkommazahlen im Argument <expr> nicht in rationale Zahlen
     umgewandelt, wenn der Ausdruck in eine CRE-Form umgewandelt wird.

     Beispiele:

          (%i1) ratexpand ((2*x - 3*y)^3);
                               3         2       2        3
          (%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
          (%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                                   x - 1       1
          (%o2)                   -------- + -----
                                         2   x - 1
                                  (x + 1)
          (%i3) expand (expr);
                              x              1           1
          (%o3)          ------------ - ------------ + -----
                          2              2             x - 1
                         x  + 2 x + 1   x  + 2 x + 1
          (%i4) ratexpand (expr);
                                  2
                               2 x                 2
          (%o4)           --------------- + ---------------
                           3    2            3    2
                          x  + x  - x - 1   x  + x  - x - 1

 -- Optionsvariable: ratfac
     Standardwert: 'false'

     Hat die Optionsvariable 'ratfac' den Wert 'true', werden Ausdrücke
     in einer CRE-Form nur teilweise faktorisiert.  Bei der Ausführung
     von Operationen bleibt der Ausdruck so vollständig als möglich in
     seiner faktorisierten Form, ohne dass eine Faktorisierung mit der
     Funktion 'factor' ausgeführt wird.  Auf diese Weise kann Rechenzeit
     eingespart werden.

     Der 'ratweight'-Mechanismus ist nicht kompatibel mit dem Setzen der
     Variablen 'ratfac'.

 -- Funktion: ratnumer (<expr>)

     Gibt den Zähler des Argumentes <expr> zurück.  'ratnumer' wandelt
     den Ausdruck zuerst in eine CRE-Form um und gibt das Ergebnis in
     einer CRE-Form zurück.

     Das Argument <expr> wird von der Funktion 'rat' in eine CRE-Form
     gebracht, falls <expr> nicht bereits in einer CRE-Form vorliegt.
     Diese Transformation kann den Ausdruck <expr> verändern, da alle
     Terme über einen gemeinsamen Nenner zusammengefasst werden.

     Die Funktion 'num' ist vergleichbar.  'num' wandelt den Ausdruck
     jedoch nicht eine CRE-Form um und hat als Ergebnis einen Ausdruck
     in der Standardform.  Daher können sich die Ergebnisse von
     'ratnumer' und 'num' voneinander unterscheiden.

 -- Funktion: ratp (<expr>)

     Gibt das Ergebnis 'true' zurück, wenn das Argument <expr> in einer
     CRE-Form oder einer erweiterten CRE-Form vorliegt.

     CRE-Formen werden von der Funktion 'rat' und verwandten Funktionen
     erzeugt.  Erweiterte CRE-Formen werden von der Funktion 'taylor'
     und verwandten Funktionen erzeugt.

 -- Optionsvariable: ratprint
     Standardwert: 'true'

     Hat die Optionsvariable 'ratprint' den Wert 'true', gibt Maxima
     eine Meldung aus, wenn eine Gleitkommazahl in eine rationale Zahl
     umgewandelt wird.

     Beispiel:

          (%i1) ratprint:true;
          (%o1)                         true
          (%i2) rat(0.75*x);

          rat: replaced 0.75 by 3/4 = 0.75
                                         3 x
          (%o2)/R/                       ---
                                          4
          (%i3) ratprint:false;
          (%o3)                         false
          (%i4) rat(0.75*x);
                                         3 x
          (%o4)/R/                       ---
                                          4

 -- Funktion: ratsimp (<expr>)
 -- Funktion: ratsimp (<expr>, <x_1>, ..., <x_n>)

     Vereinfacht den Ausdruck <expr> und alle Teilausdrücke,
     einschließlich der nicht rationalen Anteile.  Das Ergebnis ist ein
     Quotient aus zwei Polynomen in einer rekursiven Form.  In der
     rekursiven Form ist das Polynom nach der Hauptvariablen vollständig
     ausmultipliziert und ein Polynom in allen anderen Variablen.
     Variable können auch nicht-rationale Ausdrücke wie 'sin(x^2 + 1)'
     sein.

     'ratsimp(<expr>, <x_1>, ..., <x_n>)' vereinfacht einen Ausdruck mit
     einer Ordnung der Variablen wie sie von der Funktion 'ratvars'
     definiert wird.

     Hat die Optionsvariable 'ratsimpexpons' den Wert 'true', wird
     'ratsimp' auch auf die Exponenten von Ausdrücke angewendet.

     Siehe auch die Funktion 'ratexpand'.  Die Funktion 'ratsimp' wird
     auch von einigen Schaltern kontrolliert, die Einfluss auf
     'ratexpand' haben.

     Beispiele:

          (%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                                   2      2
                             x         (log(x) + 1)  - log (x)
          (%o1)        sin(------) = %e
                            2
                           x  + x
          (%i2) ratsimp (%);
                                       1          2
          (%o2)                  sin(-----) = %e x
                                     x + 1
          (%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                                 3/2
                          (x - 1)    - sqrt(x - 1) (x + 1)
          (%o3)           --------------------------------
                               sqrt((x - 1) (x + 1))
          (%i4) ratsimp (%);
                                     2 sqrt(x - 1)
          (%o4)                    - -------------
                                           2
                                     sqrt(x  - 1)
          (%i5) x^(a + 1/a), ratsimpexpons: true;
                                         2
                                        a  + 1
                                        ------
                                          a
          (%o5)                        x

 -- Optionsvariable: ratsimpexpons
     Standardwert: 'false'

     Hat die Optionsvariable 'ratsimpexpons' den Wert 'true', wird
     'ratsimp' auch auf die Exponenten von Ausdrücke angewendet.

     Beispiel:

          (%i1) expr: x^(a+1/a);
                                       a + 1/a
          (%o1)                       x
          (%i2) ratsimpexpons: false;
          (%o2)                         false
          (%i3) ratsimp(expr);
                                       a + 1/a
          (%o3)                       x
          (%i4) ratsimpexpons: true;
          (%o4)                         true
          (%i5) ratsimp(expr);
                                         2
                                        a  + 1
                                        ------
                                          a
          (%o5)                        x

 -- Optionsvariable: radsubstflag
     Standardwert: 'false'

     Hat 'radsubstflag' den Wert 'true', werden Wurzeln von der Funktion
     'ratsubst' auch dann substituiert, wenn diese nicht explizit im
     Ausdruck enthalten sind.

     Beispiel:

          (%i1) radsubstflag: false$
          (%i2) ratsubst (u, sqrt(x), x);
          (%o2)                           x
          (%i3) radsubstflag: true$
          (%i4) ratsubst (u, sqrt(x), x);
                                          2
          (%o4)                          u

 -- Funktion: ratsubst (<a>, <b>, <c>)

     Substituiert <a> für <b> in den Ausdruck <c> und gibt das Ergebnis
     der Substitution zurück.

     Im Unterschied zu 'subst' kann 'ratsubst' auch Teilausdrücke im
     Ausdruck <c> substituieren.  So hat 'subst(a, x + y, x + y + z)'
     das Ergebnis 'x + y + z' und 'ratsubst' das Ergebnis 'z + a'.

     Hat 'radsubstflag' den Wert 'true', werden Wurzeln von der Funktion
     'ratsubst' auch dann substituiert, wenn diese nicht explizit im
     Ausdruck enthalten sind.

     Beispiel:

          (%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                                        3      4
          (%o1)                      a x  y + a
          (%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
                         4         3         2
          (%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
          (%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
                      4           2                     2
          (%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
          (%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                                  4           2
          (%o4)                cos (x) - 2 cos (x) + 1
          (%i5) radsubstflag: false$
          (%i6) ratsubst (u, sqrt(x), x);
          (%o6)                           x
          (%i7) radsubstflag: true$
          (%i8) ratsubst (u, sqrt(x), x);
                                          2
          (%o8)                          u

 -- Funktion: ratvars (<x_1>, ..., <x_n>)
 -- Funktion: ratvars ()
 -- Systemvariable: ratvars

     Deklariert die Variablen <x_1>, ..., <x_n> zu Hauptvariablen einer
     rationalen Funktion.  Ist die Variable <x_n> in einem Ausdruck
     vorhanden, wird diese zur Hauptvariablen.  Ist <x_n> nicht im
     Ausdruck vorhanden, wird einer der vorhergehenden Variablen <x_i>
     zur Hauptvariablen.

     Eine Variable einer rationalen Funktion, die nicht unter den <x_1>,
     ..., <x_n> ist, erhält eine geringe Priorität als <x_1>.

     Die Argumente der Funktion 'ratvars' können auch nicht-rationale
     Ausdrücke wie 'sin(x)' sein.

     Die Systemvariable 'ratvars' enthält die Liste der zuletzt mit der
     Funktion 'ratvars' zu Hauptvariablen erklärten Variablen.  Jeder
     Aufruf der Funktion 'ratvars' setzt diese Liste zurück.  Der Aufruf
     ohne Argumente 'ratvars()' löscht die Systemvariable 'ratvars'.

 -- Funktion: ratweight (<x_1>, <w_1>, ..., <x_n>, <w_n>)
 -- Funktion: ratweight ()

     Weist der Variablen <x_i> ein Gewicht <w_i> zu.  Hat ein Term einer
     rationalen Funktion ein größeres Gewicht als der Wert der Variablen
     'ratwtlvl' wird der Term durch '0' ersetzt.  Das Gewicht eines
     Terms wird anhand der mit 'ratweight' den Variablen zugewiesenen
     Gewichte ermittelt.  Die Gewichte der Variablen in einem Term
     werden mit der Potenz der Variablen multipliziert und dann addiert.
     Zum Beispiel hat der Term '3 x_1^2 x_2' das Gewicht '2 w_1 + w_2'.
     Terme die den Wert von 'ratwtlvl' übersteigen, werden nur dann
     entfernt, wenn rationale Funktionen in einer CRE-Form multipliziert
     oder potenziert werden.

     'ratweight()' gibt die Liste der zugewiesenen Gewichte zurück.

     Der 'ratweight'-Mechanismus ist nicht kompatibel mit dem Setzen der
     Variablen 'ratfac'.

     Beispiele:

          (%i1) ratweight (a, 1, b, 1);
          (%o1)                     [a, 1, b, 1]
          (%i2) expr1: rat(a + b + 1)$
          (%i3) expr1^2;
                            2                  2
          (%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
          (%i4) ratwtlvl: 1$
          (%i5) expr1^2;
          (%o5)/R/                  2 b + 2 a + 1

 -- System variable: ratweights
     Standardwert: '[]'

     Die Systemvariable 'ratweights' enthält die Liste der Gewichte die
     Variablen mit der Funktion 'ratweights' zugewiesen sind.

     Die Gewichte können mit dem Kommando 'kill(ratweights)' gelöscht
     werden.

 -- Optionsvariable: ratwtlvl
     Standardwert: 'false'

     Die Optionsvariable wird im Zusammenhang mit den
     'ratweight'-Mechanismus genutzt und kontrolliert das Entfernen von
     Termen einer rationalen Funktion in einer CRE-Form, wenn deren
     Gewicht den Wert von 'ratwtlvl' übersteigt.  Mit dem Standardwert
     'false' werden keine Terme entfernt.

 -- Funktion: remainder (<p_1>, <p_2>)
 -- Funktion: remainder (<p_1>, <p_2>, <x_1>, ..., <x_n>)

     Berechnet den Rest der Polynomdivision von <p_1> und <p_2> für die
     Variable <x_n>.  Die anderen Variablen <x_1>, ..., <x_n-1> haben
     dieselbe Bedeutung wie für die Funktion 'ratvars'.

     'remainder' gibt das zweite Element des Ergebnisses der Funktion
     'divide' zurück.

     Siehe auch die Funktion 'quotient'.

     Beispiel:

          (%i1) poly1 : x^3-2*x^2-5*x+7;
                                  3      2
          (%o1)                  x  - 2 x  - 5 x + 7
          (%i2) poly2 : x^2+1;
                                        2
          (%o2)                        x  + 1
          (%i3) remainder(poly1, poly2, x);
          (%o3)                        9 - 6 x

 -- Funktion: resultant (<p_1>, <p_2>, <x>)

     Berechnet die Resultante der Polynome <p_1> und <p_2> und
     eliminiert die unabhängige Variable <x>.  Die Resultante ist die
     Determinante der Sylvestermatrix für die beiden Polynome.  Das
     Ergebnis ist Null, wenn die beiden Polynome <p_1> und <p_2> einen
     gemeinsamen Faktor haben.

     Können die Polynome <p_1> oder <p_2> faktorisiert werden, kann es
     von Vorteil sein, die Faktorisierung zuvor auszuführen.

     Die Optionsvariable 'resultant' kontrolliert, welcher Algorithmus
     für die Berechnung der Resultante von Maxima genutzt wird.  Siehe
     die Optionsvariable 'resultant'.

     Die Funktion 'bezout' berechnet die Sylvestermatrix der Polynome
     <p_1> und <p_2>.  Die Determinante der Sylvestermatrix ist die
     Resultante.

     Beispiele:

          (%i1) resultant(2*x^2+3*x+1, 2*x^2+x+1, x);
          (%o1)                           8
          (%i2) resultant(x+1, x+1, x);
          (%o2)                           0
          (%i3) resultant((x+1)*x, (x+1), x);
          (%o3)                           0
          (%i4) resultant(a*x^2+b*x+1, c*x + 2, x);
                                   2
          (%o4)                   c  - 2 b c + 4 a

          (%i5) bezout(a*x^2+b*x+1, c*x+2, x);
                                  [ 2 a  2 b - c ]
          (%o5)                   [              ]
                                  [  c      2    ]
          (%i6) determinant(%);
          (%o6)                   4 a - (2 b - c) c

 -- Optionsvariable: resultant
     Standardwert: 'subres'

     Die Optionsvariable 'resultant' kontrolliert, welcher Algorithmus
     für die Berechnung der Resultante mit der Funktion 'resultant' von
     Maxima genutzt wird.  Die möglichen Werte sind:

     'subres'
          Subresultanten-Algorithmus
     'mod'
          Modularer Resultanten-Algorithmus
     'red'
          Reduzierter Subresultanten-Algorithmus

     Der Standwert 'subres' ist für die meisten Probleme geeignet.  Für
     große Polynome in einer oder zwei Variablen kann 'mod' besser sein.

 -- Optionsvariable: savefactors
     Standardwert: 'false'

     Hat die Optionsvariable 'savefactors' den Wert 'true', versuchen
     einige Funktionen bei der Vereinfachung eine bereits vorhandene
     Faktorisierung zu erhalten, um weitere Vereinfachungen zu
     beschleunigen.

 -- Funktion: showratvars (<expr>)

     Gibt eine Liste mit den Variablen des Ausdrucks <expr> zurück.  Der
     Ausdruck liegt in einer CRE-Form vor.

     Siehe auch die Funktion 'ratvars'.

 -- Funktion: sqfr (<expr>)

     Entspricht der Funktion 'factor' mit dem Unterschied, dass
     faktorisierte Polynome quadratfrei sind.

     Beispiel:

          (%i1) sqfr (4*x^4 + 4*x^3 - 3*x^2 - 4*x - 1);
                                          2   2
          (%o1)                  (2 x + 1)  (x  - 1)

 -- Funktion: tellrat (<p_1>, ..., <p_n>)
 -- Funktion: tellrat ()

     Fügt dem Ring der ganzen Zahlen, die algebraische Zahlen hinzu, die
     Lösungen der minimalen Polynome <p_1>, ..., <p_n> sind.  Jedes
     Argument <p_i> ist ein Polynom, dessen Koeffizienten ganze Zahlen
     sind.

     'tellrat(<x>)' bedeutet, dass in einer rationalen Funktion die
     Variable <x> mit dem Wert '0' substituiert wird.

     'tellrat()' gibt eine Liste der minimalen Polynome zurück.

     Die Optionsvariable 'algebraic' muss den Wert 'true' haben, damit
     die Vereinfachungen von algebraischen Zahlen ausgeführt wird.

     Maxima kennt bereits die Erweiterungen um die Imaginäre Einheit
     '%i' und die Wurzeln der ganzen Zahlen.

     Die Funktion 'untellrat' entfernt die Eigenschaften, die mit der
     Funktion 'tellrat' definiert wurden.

     Hat ein minimales Polynom mehrere Variablen, wie zum Beispiel in
     'tellrat(x^2 - y^2)', dann entsteht eine Mehrdeutigkeit, da Maxima
     nicht ermitteln kann, ob <x^2> für <y^2> zu ersetzten ist, oder
     umgekehrt.  In diesem Fall kann die Syntax 'tellrat (y^2 = x^2)'
     genutzt werden, die besagt, dass <y^2> durch <x^2> zu ersetzen ist.

     Beispiele:

          (%i1) 10*(%i + 1)/(%i + 3^(1/3));
                                     10 (%i + 1)
          (%o1)                      -----------
                                            1/3
                                      %i + 3
          (%i2) ev (ratdisrep (rat(%)), algebraic);
                       2/3      1/3              2/3      1/3
          (%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
          (%i3) tellrat (1 + a + a^2);
                                      2
          (%o3)                     [a  + a + 1]
          (%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                                1                 a
          (%o4)           ------------- + -----------------
                          sqrt(2) a - 1   sqrt(3) + sqrt(2)
          (%i5) ev (ratdisrep (rat(%)), algebraic);
                   (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
          (%o5)    ----------------------------------------------
                                         7
          (%i6) tellrat (y^2 = x^2);
                                  2    2   2
          (%o6)                 [y  - x , a  + a + 1]

 -- Funktion: totaldisrep (<expr>)

     Konvertiert alle Teilausdrücke im Ausdruck <expr> von der CRE-Form
     in die allgemeine Form und gibt das Ergebnis zurück.  Ist <expr>
     selbst eine CRE-Form, dann entspricht 'totaldisrep' der Funktion
     'ratdisrep'.

     'totaldisrep' ist insbesondere hilfreich, wenn Gleichungen, Listen
     oder Matrizen in eine allgemeine Form zu konvertieren sind.

 -- Funktion: untellrat (<x_1>, ..., <x_n>)

     Entfernt Eigenschaften von den Symbolen <x_1>, ..., <x_n>, die mit
     der Funktion 'tellrat' zugewiesen wurden.

