This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.


File: maxima.info,  Node: lbfgs,  Next: lindstedt,  Prev: lapack,  Up: Top

56 lbfgs
********

* Menu:

* Introduction to lbfgs::
* Functions and Variables for lbfgs::


File: maxima.info,  Node: Introduction to lbfgs,  Next: Functions and Variables for lbfgs,  Prev: Top,  Up: Top

56.1 Introduction to lbfgs
==========================

'lbfgs' is an implementation of the L-BFGS algorithm [1] to solve
unconstrained minimization problems via a limited-memory quasi-Newton
(BFGS) algorithm.  It is called a limited-memory method because a
low-rank approximation of the Hessian matrix inverse is stored instead
of the entire Hessian inverse.  The program was originally written in
Fortran [2] by Jorge Nocedal, incorporating some functions originally
written by Jorge J. Moré and David J. Thuente, and translated into Lisp
automatically via the program 'f2cl'.  The Maxima package 'lbfgs'
comprises the translated code plus an interface function which manages
some details.

References:

[1] D. Liu and J. Nocedal.  "On the limited memory BFGS method for large
scale optimization".  Mathematical Programming B 45:503-528 (1989)

[2] <http://netlib.org/opt/lbfgs_um.shar>


File: maxima.info,  Node: Functions and Variables for lbfgs,  Prev: Introduction to lbfgs,  Up: Top

56.2 Functions and Variables for lbfgs
======================================

 -- Function: lbfgs (<FOM>, <X>, <X0>, <epsilon>, <iprint>)
 -- Function: lbfgs ([<FOM>, <grad>] <X>, <X0>, <epsilon>, <iprint>)

     Finds an approximate solution of the unconstrained minimization of
     the figure of merit <FOM> over the list of variables <X>, starting
     from initial estimates <X0>, such that norm(grad(FOM)) <
     epsilon*max(1, norm(X)).

     <grad>, if present, is the gradient of <FOM> with respect to the
     variables <X>.  <grad> is a list, with one element for each element
     of <X>.  If not present, the gradient is computed automatically by
     symbolic differentiation.

     The algorithm applied is a limited-memory quasi-Newton (BFGS)
     algorithm [1].  It is called a limited-memory method because a
     low-rank approximation of the Hessian matrix inverse is stored
     instead of the entire Hessian inverse.  Each iteration of the
     algorithm is a line search, that is, a search along a ray in the
     variables <X>, with the search direction computed from the
     approximate Hessian inverse.  The FOM is always decreased by a
     successful line search.  Usually (but not always) the norm of the
     gradient of FOM also decreases.

     <iprint> controls progress messages printed by 'lbfgs'.

     'iprint[1]'
          '<iprint>[1]' controls the frequency of progress messages.
          'iprint[1] < 0'
               No progress messages.
          'iprint[1] = 0'
               Messages at the first and last iterations.
          'iprint[1] > 0'
               Print a message every '<iprint>[1]' iterations.
     'iprint[2]'
          '<iprint>[2]' controls the verbosity of progress messages.
          'iprint[2] = 0'
               Print out iteration count, number of evaluations of
               <FOM>, value of <FOM>, norm of the gradient of <FOM>, and
               step length.
          'iprint[2] = 1'
               Same as '<iprint>[2] = 0', plus <X0> and the gradient of
               <FOM> evaluated at <X0>.
          'iprint[2] = 2'
               Same as '<iprint>[2] = 1', plus values of <X> at each
               iteration.
          'iprint[2] = 3'
               Same as '<iprint>[2] = 2', plus the gradient of <FOM> at
               each iteration.

     The columns printed by 'lbfgs' are the following.

     'I'
          Number of iterations.  It is incremented for each line search.
     'NFN'
          Number of evaluations of the figure of merit.
     'FUNC'
          Value of the figure of merit at the end of the most recent
          line search.
     'GNORM'
          Norm of the gradient of the figure of merit at the end of the
          most recent line search.
     'STEPLENGTH'
          An internal parameter of the search algorithm.

     Additional information concerning details of the algorithm are
     found in the comments of the original Fortran code [2].

     See also 'lbfgs_nfeval_max' and 'lbfgs_ncorrections'.

     References:

     [1] D. Liu and J. Nocedal.  "On the limited memory BFGS method for
     large scale optimization".  Mathematical Programming B 45:503-528
     (1989)

     [2] <http://netlib.org/opt/lbfgs_um.shar>

     Examples:

     The same FOM as computed by FGCOMPUTE in the program sdrive.f in
     the LBFGS package from Netlib.  Note that the variables in question
     are subscripted variables.  The FOM has an exact minimum equal to
     zero at u[k] = 1 for k = 1, ..., 8.

          (%i1) load (lbfgs);
          (%o1)   /usr/share/maxima/5.10.0cvs/share/lbfgs/lbfgs.mac
          (%i2) t1[j] := 1 - u[j];
          (%o2)                     t1  := 1 - u
                                      j         j
          (%i3) t2[j] := 10*(u[j + 1] - u[j]^2);
                                                    2
          (%o3)                t2  := 10 (u      - u )
                                 j         j + 1    j
          (%i4) n : 8;
          (%o4)                           8
          (%i5) FOM : sum (t1[2*j - 1]^2 + t2[2*j - 1]^2, j, 1, n/2);
                           2 2           2              2 2           2
          (%o5) 100 (u  - u )  + (1 - u )  + 100 (u  - u )  + (1 - u )
                      8    7           7           6    5           5
                               2 2           2              2 2           2
                  + 100 (u  - u )  + (1 - u )  + 100 (u  - u )  + (1 - u )
                          4    3           3           2    1           1
          (%i6) lbfgs (FOM, '[u[1],u[2],u[3],u[4],u[5],u[6],u[7],u[8]],
                 [-1.2, 1, -1.2, 1, -1.2, 1, -1.2, 1], 1e-3, [1, 0]);
          *************************************************
            N=    8   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  9.680000000000000D+01   GNORM=  4.657353755084532D+02
          *************************************************
           I NFN   FUNC                    GNORM                   STEPLENGTH

           1   3   1.651479526340304D+01   4.324359291335977D+00   7.926153934390631D-04
           2   4   1.650209316638371D+01   3.575788161060007D+00   1.000000000000000D+00
           3   5   1.645461701312851D+01   6.230869903601577D+00   1.000000000000000D+00
           4   6   1.636867301275588D+01   1.177589920974980D+01   1.000000000000000D+00
           5   7   1.612153014409201D+01   2.292797147151288D+01   1.000000000000000D+00
           6   8   1.569118407390628D+01   3.687447158775571D+01   1.000000000000000D+00
           7   9   1.510361958398942D+01   4.501931728123680D+01   1.000000000000000D+00
           8  10   1.391077875774294D+01   4.526061463810632D+01   1.000000000000000D+00
           9  11   1.165625686278198D+01   2.748348965356917D+01   1.000000000000000D+00
          10  12   9.859422687859137D+00   2.111494974231644D+01   1.000000000000000D+00
          11  13   7.815442521732281D+00   6.110762325766556D+00   1.000000000000000D+00
          12  15   7.346380905773160D+00   2.165281166714631D+01   1.285316401779533D-01
          13  16   6.330460634066370D+00   1.401220851762050D+01   1.000000000000000D+00
          14  17   5.238763939851439D+00   1.702473787613255D+01   1.000000000000000D+00
          15  18   3.754016790406701D+00   7.981845727704576D+00   1.000000000000000D+00
          16  20   3.001238402309352D+00   3.925482944716691D+00   2.333129631296807D-01
          17  22   2.794390709718290D+00   8.243329982546473D+00   2.503577283782332D-01
          18  23   2.563783562918759D+00   1.035413426521790D+01   1.000000000000000D+00
          19  24   2.019429976377856D+00   1.065187312346769D+01   1.000000000000000D+00
          20  25   1.428003167670903D+00   2.475962450826961D+00   1.000000000000000D+00
          21  27   1.197874264861340D+00   8.441707983493810D+00   4.303451060808756D-01
          22  28   9.023848941942773D-01   1.113189216635162D+01   1.000000000000000D+00
          23  29   5.508226405863770D-01   2.380830600326308D+00   1.000000000000000D+00
          24  31   3.902893258815567D-01   5.625595816584421D+00   4.834988416524465D-01
          25  32   3.207542206990315D-01   1.149444645416472D+01   1.000000000000000D+00
          26  33   1.874468266362791D-01   3.632482152880997D+00   1.000000000000000D+00
          27  34   9.575763380706598D-02   4.816497446154354D+00   1.000000000000000D+00
          28  35   4.085145107543406D-02   2.087009350166495D+00   1.000000000000000D+00
          29  36   1.931106001379290D-02   3.886818608498966D+00   1.000000000000000D+00
          30  37   6.894000721499670D-03   3.198505796342214D+00   1.000000000000000D+00
          31  38   1.443296033051864D-03   1.590265471025043D+00   1.000000000000000D+00
          32  39   1.571766603154336D-04   3.098257063980634D-01   1.000000000000000D+00
          33  40   1.288011776581970D-05   1.207784183577257D-02   1.000000000000000D+00
          34  41   1.806140173752971D-06   4.587890233385193D-02   1.000000000000000D+00
          35  42   1.769004645459358D-07   1.790537375052208D-02   1.000000000000000D+00
          36  43   3.312164100763217D-10   6.782068426119681D-04   1.000000000000000D+00

           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o6) [u  = 1.000005339815974, u  = 1.000009942839805,
                  1                       2
          u  = 1.000005339815974, u  = 1.000009942839805,
           3                       4
          u  = 1.000005339815974, u  = 1.000009942839805,
           5                       6
          u  = 1.000005339815974, u  = 1.000009942839805]
           7                       8

     A regression problem.  The FOM is the mean square difference
     between the predicted value F(X[i]) and the observed value Y[i].
     The function F is a bounded monotone function (a so-called
     "sigmoidal" function).  In this example, 'lbfgs' computes
     approximate values for the parameters of F and 'plot2d' displays a
     comparison of F with the observed data.

          (%i1) load (lbfgs);
          (%o1)   /usr/share/maxima/5.10.0cvs/share/lbfgs/lbfgs.mac
          (%i2) FOM : '((1/length(X))*sum((F(X[i]) - Y[i])^2, i, 1,
                                                          length(X)));
                                         2
                         sum((F(X ) - Y ) , i, 1, length(X))
                                 i     i
          (%o2)          -----------------------------------
                                      length(X)
          (%i3) X : [1, 2, 3, 4, 5];
          (%o3)                    [1, 2, 3, 4, 5]
          (%i4) Y : [0, 0.5, 1, 1.25, 1.5];
          (%o4)                [0, 0.5, 1, 1.25, 1.5]
          (%i5) F(x) := A/(1 + exp(-B*(x - C)));
                                             A
          (%o5)            F(x) := ----------------------
                                   1 + exp((- B) (x - C))
          (%i6) ''FOM;
                          A               2            A                2
          (%o6) ((----------------- - 1.5)  + (----------------- - 1.25)
                    - B (5 - C)                  - B (4 - C)
                  %e            + 1            %e            + 1
                      A             2            A               2
           + (----------------- - 1)  + (----------------- - 0.5)
                - B (3 - C)                - B (2 - C)
              %e            + 1          %e            + 1
                       2
                      A
           + --------------------)/5
                - B (1 - C)     2
             (%e            + 1)
          (%i7) estimates : lbfgs (FOM, '[A, B, C], [1, 1, 1], 1e-4, [1, 0]);
          *************************************************
            N=    3   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  1.348738534246918D-01   GNORM=  2.000215531936760D-01
          *************************************************

          I  NFN  FUNC                    GNORM                   STEPLENGTH
          1    3  1.177820636622582D-01   9.893138394953992D-02   8.554435968992371D-01
          2    6  2.302653892214013D-02   1.180098521565904D-01   2.100000000000000D+01
          3    8  1.496348495303005D-02   9.611201567691633D-02   5.257340567840707D-01
          4    9  7.900460841091139D-03   1.325041647391314D-02   1.000000000000000D+00
          5   10  7.314495451266917D-03   1.510670810312237D-02   1.000000000000000D+00
          6   11  6.750147275936680D-03   1.914964958023047D-02   1.000000000000000D+00
          7   12  5.850716021108205D-03   1.028089194579363D-02   1.000000000000000D+00
          8   13  5.778664230657791D-03   3.676866074530332D-04   1.000000000000000D+00
          9   14  5.777818823650782D-03   3.010740179797255D-04   1.000000000000000D+00

           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o7) [A = 1.461933911464101, B = 1.601593973254802,
                                                     C = 2.528933072164854]
          (%i8) plot2d ([F(x), [discrete, X, Y]], [x, -1, 6]), ''estimates;
          (%o8)

     Gradient of FOM is specified (instead of computing it
     automatically).

          (%i1) load (lbfgs)$
          (%i2) F(a, b, c) := (a - 5)^2 + (b - 3)^4 + (c - 2)^6;
                                         2          4          6
          (%o2)     F(a, b, c) := (a - 5)  + (b - 3)  + (c - 2)
          (%i3) F_grad : map (lambda ([x], diff (F(a, b, c), x)), [a, b, c]);
                                              3           5
          (%o3)          [2 (a - 5), 4 (b - 3) , 6 (c - 2) ]
          (%i4) estimates : lbfgs ([F(a, b, c), F_grad],
                                   [a, b, c], [0, 0, 0], 1e-4, [1, 0]);
          *************************************************
            N=    3   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  1.700000000000000D+02   GNORM=  2.205175729958953D+02
          *************************************************

             I  NFN     FUNC                    GNORM                   STEPLENGTH

             1    2     6.632967565917638D+01   6.498411132518770D+01   4.534785987412505D-03
             2    3     4.368890936228036D+01   3.784147651974131D+01   1.000000000000000D+00
             3    4     2.685298972775190D+01   1.640262125898521D+01   1.000000000000000D+00
             4    5     1.909064767659852D+01   9.733664001790506D+00   1.000000000000000D+00
             5    6     1.006493272061515D+01   6.344808151880209D+00   1.000000000000000D+00
             6    7     1.215263596054294D+00   2.204727876126879D+00   1.000000000000000D+00
             7    8     1.080252896385334D-02   1.431637116951849D-01   1.000000000000000D+00
             8    9     8.407195124830908D-03   1.126344579730013D-01   1.000000000000000D+00
             9   10     5.022091686198527D-03   7.750731829225274D-02   1.000000000000000D+00
            10   11     2.277152808939775D-03   5.032810859286795D-02   1.000000000000000D+00
            11   12     6.489384688303218D-04   1.932007150271008D-02   1.000000000000000D+00
            12   13     2.075791943844548D-04   6.964319310814364D-03   1.000000000000000D+00
            13   14     7.349472666162257D-05   4.017449067849554D-03   1.000000000000000D+00
            14   15     2.293617477985237D-05   1.334590390856715D-03   1.000000000000000D+00
            15   16     7.683645404048675D-06   6.011057038099201D-04   1.000000000000000D+00

           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o4) [a = 5.000086823042934, b = 3.05239542970518,
                                                     c = 1.927980629919583]

 -- Variable: lbfgs_nfeval_max
     Default value: 100

     'lbfgs_nfeval_max' is the maximum number of evaluations of the
     figure of merit (FOM) in 'lbfgs'.  When 'lbfgs_nfeval_max' is
     reached, 'lbfgs' returns the result of the last successful line
     search.

 -- Variable: lbfgs_ncorrections
     Default value: 25

     'lbfgs_ncorrections' is the number of corrections applied to the
     approximate inverse Hessian matrix which is maintained by 'lbfgs'.


File: maxima.info,  Node: lindstedt,  Next: linearalgebra,  Prev: lbfgs,  Up: Top

57 lindstedt
************

* Menu:

* Functions and Variables for lindstedt::


File: maxima.info,  Node: Functions and Variables for lindstedt,  Prev: lindstedt,  Up: lindstedt

57.1 Functions and Variables for lindstedt
==========================================

 -- Function: Lindstedt (<eq>,<pvar>,<torder>,<ic>)

     This is a first pass at a Lindstedt code.  It can solve problems
     with initial conditions entered, which can be arbitrary constants,
     (just not <%k1> and <%k2>) where the initial conditions on the
     perturbation equations are z[i]=0, z'[i]=0 for i>0.  <ic> is the
     list of initial conditions.

     Problems occur when initial conditions are not given, as the
     constants in the perturbation equations are the same as the zero
     order equation solution.  Also, problems occur when the initial
     conditions for the perturbation equations are not z[i]=0, z'[i]=0
     for i>0, such as the Van der Pol equation.

     Example:

          (%i1) load("makeOrders")$

          (%i2) load("lindstedt")$

          (%i3) Lindstedt('diff(x,t,2)+x-(e*x^3)/6,e,2,[1,0]);
                    2
                   e  (cos(5 T) - 24 cos(3 T) + 23 cos(T))
          (%o3) [[[---------------------------------------
                                    36864
             e (cos(3 T) - cos(T))
           - --------------------- + cos(T)],
                      192
                    2
                 7 e    e
          T = (- ---- - -- + 1) t]]
                 3072   16

     To use this function write first 'load("makeOrders")' and
     'load("lindstedt")'.


File: maxima.info,  Node: linearalgebra,  Next: lsquares,  Prev: lindstedt,  Up: Top

58 linearalgebra
****************

* Menu:

* Introduction to linearalgebra::
* Functions and Variables for linearalgebra::


File: maxima.info,  Node: Introduction to linearalgebra,  Next: Functions and Variables for linearalgebra,  Prev: linearalgebra,  Up: linearalgebra

58.1 Introduction to linearalgebra
==================================

'linearalgebra' is a collection of functions for linear algebra.

Example:

     (%i1) M : matrix ([1, 2], [1, 2]);
                                 [ 1  2 ]
     (%o1)                       [      ]
                                 [ 1  2 ]
     (%i2) nullspace (M);
                                    [  1  ]
                                    [     ]
     (%o2)                     span([   1 ])
                                    [ - - ]
                                    [   2 ]
     (%i3) columnspace (M);
                                     [ 1 ]
     (%o3)                      span([   ])
                                     [ 1 ]
     (%i4) ptriangularize (M - z*ident(2), z);
                              [ 1   2 - z   ]
     (%o4)                    [             ]
                              [           2 ]
                              [ 0  3 z - z  ]
     (%i5) M : matrix ([1, 2, 3], [4, 5, 6], [7, 8, 9]) - z*ident(3);
                          [ 1 - z    2      3   ]
                          [                     ]
     (%o5)                [   4    5 - z    6   ]
                          [                     ]
                          [   7      8    9 - z ]
     (%i6) MM : ptriangularize (M, z);
                   [ 4  5 - z            6            ]
                   [                                  ]
                   [                2                 ]
                   [     66        z    102 z   132   ]
                   [ 0   --      - -- + ----- + ---   ]
     (%o6)         [     49        7     49     49    ]
                   [                                  ]
                   [               3        2         ]
                   [           49 z    245 z    147 z ]
                   [ 0    0    ----- - ------ - ----- ]
                   [            264      88      44   ]
     (%i7) algebraic : true;
     (%o7)                         true
     (%i8) tellrat (MM [3, 3]);
                              3       2
     (%o8)                  [z  - 15 z  - 18 z]
     (%i9) MM : ratsimp (MM);
                    [ 4  5 - z           6           ]
                    [                                ]
                    [                2               ]
     (%o9)          [     66      7 z  - 102 z - 132 ]
                    [ 0   --    - ------------------ ]
                    [     49              49         ]
                    [                                ]
                    [ 0    0             0           ]
     (%i10) nullspace (MM);
                             [        1         ]
                             [                  ]
                             [   2              ]
                             [  z  - 14 z - 16  ]
                             [  --------------  ]
     (%o10)             span([        8         ])
                             [                  ]
                             [    2             ]
                             [   z  - 18 z - 12 ]
                             [ - -------------- ]
                             [         12       ]
     (%i11) M : matrix ([1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12],
                        [13, 14, 15, 16]);
                            [ 1   2   3   4  ]
                            [                ]
                            [ 5   6   7   8  ]
     (%o11)                 [                ]
                            [ 9   10  11  12 ]
                            [                ]
                            [ 13  14  15  16 ]
     (%i12) columnspace (M);
                                [ 1  ]  [ 2  ]
                                [    ]  [    ]
                                [ 5  ]  [ 6  ]
     (%o12)                span([    ], [    ])
                                [ 9  ]  [ 10 ]
                                [    ]  [    ]
                                [ 13 ]  [ 14 ]
     (%i13) apply ('orthogonal_complement, args (nullspace (transpose (M))));
                                [ 0 ]  [  1  ]
                                [   ]  [     ]
                                [ 1 ]  [  0  ]
     (%o13)                span([   ], [     ])
                                [ 2 ]  [ - 1 ]
                                [   ]  [     ]
                                [ 3 ]  [ - 2 ]


File: maxima.info,  Node: Functions and Variables for linearalgebra,  Prev: Introduction to linearalgebra,  Up: linearalgebra

58.2 Functions and Variables for linearalgebra
==============================================

 -- Function: addmatrices (<f>, <M_1>, ..., <M_n>)

     Using the function <f> as the addition function, return the sum of
     the matrices <M_1>, ..., <M_n>.  The function <f> must accept any
     number of arguments (a Maxima nary function).

     Examples:

          (%i1) m1 : matrix([1,2],[3,4])$
          (%i2) m2 : matrix([7,8],[9,10])$
          (%i3) addmatrices('max,m1,m2);
          (%o3) matrix([7,8],[9,10])
          (%i4) addmatrices('max,m1,m2,5*m1);
          (%o4) matrix([7,10],[15,20])

 -- Function: blockmatrixp (<M>)

     Return true if and only if <M> is a matrix and every entry of <M>
     is a matrix.

 -- Function: columnop (<M>, <i>, <j>, <theta>)

     If <M> is a matrix, return the matrix that results from doing the
     column operation 'C_i <- C_i - <theta> * C_j'.  If <M> doesn't have
     a row <i> or <j>, signal an error.

 -- Function: columnswap (<M>, <i>, <j>)

     If <M> is a matrix, swap columns <i> and <j>.  If <M> doesn't have
     a column <i> or <j>, signal an error.

 -- Function: columnspace (<M>)

     If <M> is a matrix, return 'span (v_1, ..., v_n)', where the set
     '{v_1, ..., v_n}' is a basis for the column space of <M>.  The span
     of the empty set is '{0}'.  Thus, when the column space has only
     one member, return 'span ()'.

 -- Function: copy (<e>)

     Return a copy of the Maxima expression <e>.  Although <e> can be
     any Maxima expression, the copy function is the most useful when
     <e> is either a list or a matrix; consider:

          (%i1) m : [1,[2,3]]$
          (%i2) mm : m$
          (%i3) mm[2][1] : x$
          (%i4) m;
          (%o4)                      [1,[x,3]]
          (%i5) mm;
          (%o5)                      [1,[x,3]]

     Let's try the same experiment, but this time let <mm> be a copy of
     <m>

          (%i6) m : [1,[2,3]]$
          (%i7) mm : copy(m)$
          (%i8) mm[2][1] : x$
          (%i9) m;
          (%o9)                     [1,[2,3]]
          (%i10) mm;
          (%o10)                    [1,[x,3]]
     This time, the assignment to <mm> does not change the value of <m>.

 -- Function: cholesky (<M>)
 -- Function: cholesky (<M>, <field>)

     Return the Cholesky factorization of the matrix selfadjoint (or
     hermitian) matrix <M>.  The second argument defaults to
     'generalring.'  For a description of the possible values for
     <field>, see 'lu_factor'.

 -- Function: ctranspose (<M>)

     Return the complex conjugate transpose of the matrix <M>.  The
     function 'ctranspose' uses 'matrix_element_transpose' to transpose
     each matrix element.

 -- Function: diag_matrix (<d_1>, <d_2>,...,<d_n>)

     Return a diagonal matrix with diagonal entries <d_1>, <d_2>, ...,
     <d_n>.  When the diagonal entries are matrices, the zero entries of
     the returned matrix are zero matrices of the appropriate size; for
     example:

          (%i1) diag_matrix(diag_matrix(1,2),diag_matrix(3,4));

                                      [ [ 1  0 ]  [ 0  0 ] ]
                                      [ [      ]  [      ] ]
                                      [ [ 0  2 ]  [ 0  0 ] ]
          (%o1)                       [                    ]
                                      [ [ 0  0 ]  [ 3  0 ] ]
                                      [ [      ]  [      ] ]
                                      [ [ 0  0 ]  [ 0  4 ] ]
          (%i2) diag_matrix(p,q);

                                             [ p  0 ]
          (%o2)                              [      ]
                                             [ 0  q ]

 -- Function: dotproduct (<u>, <v>)

     Return the dotproduct of vectors <u> and <v>.  This is the same as
     'conjugate (transpose (<u>)) . <v>'.  The arguments <u> and <v>
     must be column vectors.

 -- Function: eigens_by_jacobi (<A>)
 -- Function: eigens_by_jacobi (<A>, <field_type>)

     Computes the eigenvalues and eigenvectors of <A> by the method of
     Jacobi rotations.  <A> must be a symmetric matrix (but it need not
     be positive definite nor positive semidefinite).  <field_type>
     indicates the computational field, either 'floatfield' or
     'bigfloatfield'.  If <field_type> is not specified, it defaults to
     'floatfield'.

     The elements of <A> must be numbers or expressions which evaluate
     to numbers via 'float' or 'bfloat' (depending on <field_type>).

     Examples:

          (%i1) S: matrix([1/sqrt(2), 1/sqrt(2)],[-1/sqrt(2), 1/sqrt(2)]);
                               [     1         1    ]
                               [  -------   ------- ]
                               [  sqrt(2)   sqrt(2) ]
          (%o1)                [                    ]
                               [      1        1    ]
                               [ - -------  ------- ]
                               [   sqrt(2)  sqrt(2) ]
          (%i2) L : matrix ([sqrt(3), 0], [0, sqrt(5)]);
                                [ sqrt(3)     0    ]
          (%o2)                 [                  ]
                                [    0     sqrt(5) ]
          (%i3) M : S . L . transpose (S);
                      [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
                      [ ------- + -------  ------- - ------- ]
                      [    2         2        2         2    ]
          (%o3)       [                                      ]
                      [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
                      [ ------- - -------  ------- + ------- ]
                      [    2         2        2         2    ]
          (%i4) eigens_by_jacobi (M);
          The largest percent change was 0.1454972243679
          The largest percent change was 0.0
          number of sweeps: 2
          number of rotations: 1
          (%o4) [[1.732050807568877, 2.23606797749979],
                                  [  0.70710678118655   0.70710678118655 ]
                                  [                                      ]]
                                  [ - 0.70710678118655  0.70710678118655 ]
          (%i5) float ([[sqrt(3), sqrt(5)], S]);
          (%o5) [[1.732050807568877, 2.23606797749979],
                                  [  0.70710678118655   0.70710678118655 ]
                                  [                                      ]]
                                  [ - 0.70710678118655  0.70710678118655 ]
          (%i6) eigens_by_jacobi (M, bigfloatfield);
          The largest percent change was 1.454972243679028b-1
          The largest percent change was 0.0b0
          number of sweeps: 2
          number of rotations: 1
          (%o6) [[1.732050807568877b0, 2.23606797749979b0],
                          [  7.071067811865475b-1   7.071067811865475b-1 ]
                          [                                              ]]
                          [ - 7.071067811865475b-1  7.071067811865475b-1 ]

 -- Function: get_lu_factors (<x>)

     When '<x> = lu_factor (<A>)', then 'get_lu_factors' returns a list
     of the form '[P, L, U]', where <P> is a permutation matrix, <L> is
     lower triangular with ones on the diagonal, and <U> is upper
     triangular, and '<A> = <P> <L> <U>'.

 -- Function: hankel (<col>)
 -- Function: hankel (<col>, <row>)

     Return a Hankel matrix <H>.  The first column of <H> is <col>;
     except for the first entry, the last row of <H> is <row>.  The
     default for <row> is the zero vector with the same length as <col>.

 -- Function: hessian (<f>, <x>)

     Returns the Hessian matrix of <f> with respect to the list of
     variables <x>.  The '(i, j)'-th element of the Hessian matrix is
     'diff(<f>, <x>[i], 1, <x>[j], 1)'.

     Examples:

          (%i1) hessian (x * sin (y), [x, y]);
                               [   0       cos(y)   ]
          (%o1)                [                    ]
                               [ cos(y)  - x sin(y) ]
          (%i2) depends (F, [a, b]);
          (%o2)                       [F(a, b)]
          (%i3) hessian (F, [a, b]);
                                  [   2      2   ]
                                  [  d F    d F  ]
                                  [  ---   ----- ]
                                  [    2   da db ]
                                  [  da          ]
          (%o3)                   [              ]
                                  [   2      2   ]
                                  [  d F    d F  ]
                                  [ -----   ---  ]
                                  [ da db     2  ]
                                  [         db   ]

 -- Function: hilbert_matrix (<n>)

     Return the <n> by <n> Hilbert matrix.  When <n> isn't a positive
     integer, signal an error.

 -- Function: identfor (<M>)
 -- Function: identfor (<M>, <fld>)

     Return an identity matrix that has the same shape as the matrix
     <M>.  The diagonal entries of the identity matrix are the
     multiplicative identity of the field <fld>; the default for <fld>
     is <generalring>.

     The first argument <M> should be a square matrix or a non-matrix.
     When <M> is a matrix, each entry of <M> can be a square matrix -
     thus <M> can be a blocked Maxima matrix.  The matrix can be blocked
     to any (finite) depth.

     See also 'zerofor'

 -- Function: invert_by_lu (<M>, <(rng generalring)>)

     Invert a matrix <M> by using the LU factorization.  The LU
     factorization is done using the ring <rng>.

 -- Function: jacobian (<f>, <x>)

     Returns the Jacobian matrix of the list of functions <f> with
     respect to the list of variables <x>.  The '(i, j)'-th element of
     the Jacobian matrix is 'diff(<f>[i], <x>[j])'.

     Examples:

          (%i1) jacobian ([sin (u - v), sin (u * v)], [u, v]);
                            [ cos(v - u)  - cos(v - u) ]
          (%o1)             [                          ]
                            [ v cos(u v)   u cos(u v)  ]
          (%i2) depends ([F, G], [y, z]);
          (%o2)                  [F(y, z), G(y, z)]
          (%i3) jacobian ([F, G], [y, z]);
                                     [ dF  dF ]
                                     [ --  -- ]
                                     [ dy  dz ]
          (%o3)                      [        ]
                                     [ dG  dG ]
                                     [ --  -- ]
                                     [ dy  dz ]

 -- Function: kronecker_product (<A>, <B>)

     Return the Kronecker product of the matrices <A> and <B>.

 -- Function: listp (<e>, <p>)
 -- Function: listp (<e>)

     Given an optional argument <p>, return 'true' if <e> is a Maxima
     list and <p> evaluates to 'true' for every list element.  When
     'listp' is not given the optional argument, return 'true' if <e> is
     a Maxima list.  In all other cases, return 'false'.

 -- Function: locate_matrix_entry (<M>, <r_1>, <c_1>, <r_2>, <c_2>, <f>,
          <rel>)

     The first argument must be a matrix; the arguments <r_1> through
     <c_2> determine a sub-matrix of <M> that consists of rows <r_1>
     through <r_2> and columns <c_1> through <c_2>.

     Find an entry in the sub-matrix <M> that satisfies some property.
     Three cases:

     (1) '<rel> = 'bool' and <f> a predicate:

     Scan the sub-matrix from left to right then top to bottom, and
     return the index of the first entry that satisfies the predicate
     <f>.  If no matrix entry satisfies <f>, return 'false'.

     (2) '<rel> = 'max' and <f> real-valued:

     Scan the sub-matrix looking for an entry that maximizes <f>.
     Return the index of a maximizing entry.

     (3) '<rel> = 'min' and <f> real-valued:

     Scan the sub-matrix looking for an entry that minimizes <f>.
     Return the index of a minimizing entry.

 -- Function: lu_backsub (<M>, <b>)

     When '<M> = lu_factor (<A>, <field>)', then 'lu_backsub (<M>, <b>)'
     solves the linear system '<A> <x> = <b>'.

 -- Function: lu_factor (<M>, <field>)

     Return a list of the form '[<LU>, <perm>, <fld>]', or '[<LU>,
     <perm>, <fld>, <lower-cnd> <upper-cnd>]', where

     (1) The matrix <LU> contains the factorization of <M> in a packed
     form.  Packed form means three things: First, the rows of <LU> are
     permuted according to the list <perm>.  If, for example, <perm> is
     the list '[3,2,1]', the actual first row of the <LU> factorization
     is the third row of the matrix <LU>. Second, the lower triangular
     factor of m is the lower triangular part of <LU> with the diagonal
     entries replaced by all ones.  Third, the upper triangular factor
     of <M> is the upper triangular part of <LU>.

     (2) When the field is either 'floatfield' or 'complexfield', the
     numbers <lower-cnd> and <upper-cnd> are lower and upper bounds for
     the infinity norm condition number of <M>.  For all fields, the
     condition number might not be estimated; for such fields,
     'lu_factor' returns a two item list.  Both the lower and upper
     bounds can differ from their true values by arbitrarily large
     factors. (See also 'mat_cond'.)

     The argument <M> must be a square matrix.

     The optional argument <fld> must be a symbol that determines a ring
     or field.  The pre-defined fields and rings are:

     (a) 'generalring' - the ring of Maxima expressions, (b)
     'floatfield' - the field of floating point numbers of the type
     double, (c) 'complexfield' - the field of complex floating point
     numbers of the type double, (d) 'crering' - the ring of Maxima CRE
     expressions, (e) 'rationalfield' - the field of rational numbers,
     (f) 'runningerror' - track the all floating point rounding errors,
     (g) 'noncommutingring' - the ring of Maxima expressions where
     multiplication is the non-commutative dot operator.

     When the field is 'floatfield', 'complexfield', or 'runningerror',
     the algorithm uses partial pivoting; for all other fields, rows are
     switched only when needed to avoid a zero pivot.

     Floating point addition arithmetic isn't associative, so the
     meaning of 'field' differs from the mathematical definition.

     A member of the field 'runningerror' is a two member Maxima list of
     the form '[x,n]',where <x> is a floating point number and 'n' is an
     integer.  The relative difference between the 'true' value of 'x'
     and 'x' is approximately bounded by the machine epsilon times 'n'.
     The running error bound drops some terms that of the order the
     square of the machine epsilon.

     There is no user-interface for defining a new field.  A user that
     is familiar with Common Lisp should be able to define a new field.
     To do this, a user must define functions for the arithmetic
     operations and functions for converting from the field
     representation to Maxima and back.  Additionally, for ordered
     fields (where partial pivoting will be used), a user must define
     functions for the magnitude and for comparing field members.  After
     that all that remains is to define a Common Lisp structure 'mring'.
     The file 'mring' has many examples.

     To compute the factorization, the first task is to convert each
     matrix entry to a member of the indicated field.  When conversion
     isn't possible, the factorization halts with an error message.
     Members of the field needn't be Maxima expressions.  Members of the
     'complexfield', for example, are Common Lisp complex numbers.  Thus
     after computing the factorization, the matrix entries must be
     converted to Maxima expressions.

     See also 'get_lu_factors'.

     Examples:

          (%i1) w[i,j] := random (1.0) + %i * random (1.0);
          (%o1)          w     := random(1.) + %i random(1.)
                          i, j
          (%i2) showtime : true$
          Evaluation took 0.00 seconds (0.00 elapsed)
          (%i3) M : genmatrix (w, 100, 100)$
          Evaluation took 7.40 seconds (8.23 elapsed)
          (%i4) lu_factor (M, complexfield)$
          Evaluation took 28.71 seconds (35.00 elapsed)
          (%i5) lu_factor (M, generalring)$
          Evaluation took 109.24 seconds (152.10 elapsed)
          (%i6) showtime : false$

          (%i7) M : matrix ([1 - z, 3], [3, 8 - z]);
                                  [ 1 - z    3   ]
          (%o7)                   [              ]
                                  [   3    8 - z ]
          (%i8) lu_factor (M, generalring);
                    [ 1 - z         3        ]
                    [                        ]
          (%o8)    [[   3            9       ], [1, 2], generalring]
                    [ -----  - z - ----- + 8 ]
                    [ 1 - z        1 - z     ]
          (%i9) get_lu_factors (%);
                            [   1    0 ]  [ 1 - z         3        ]
                  [ 1  0 ]  [          ]  [                        ]
          (%o9)  [[      ], [   3      ], [                9       ]]
                  [ 0  1 ]  [ -----  1 ]  [   0    - z - ----- + 8 ]
                            [ 1 - z    ]  [              1 - z     ]
          (%i10) %[1] . %[2] . %[3];
                                  [ 1 - z    3   ]
          (%o10)                  [              ]
                                  [   3    8 - z ]

 -- Function: mat_cond (<M>, 1)
 -- Function: mat_cond (<M>, inf)

     Return the <p>-norm matrix condition number of the matrix <m>.  The
     allowed values for <p> are 1 and <inf>.  This function uses the LU
     factorization to invert the matrix <m>.  Thus the running time for
     'mat_cond' is proportional to the cube of the matrix size;
     'lu_factor' determines lower and upper bounds for the infinity norm
     condition number in time proportional to the square of the matrix
     size.

 -- Function: mat_norm (<M>, 1)
 -- Function: mat_norm (<M>, inf)
 -- Function: mat_norm (<M>, frobenius)

     Return the matrix <p>-norm of the matrix <M>.  The allowed values
     for <p> are 1, 'inf', and 'frobenius' (the Frobenius matrix norm).
     The matrix <M> should be an unblocked matrix.

 -- Function: matrixp (<e>, <p>)
 -- Function: matrixp (<e>)

     Given an optional argument <p>, return 'true' if <e> is a matrix
     and <p> evaluates to 'true' for every matrix element.  When
     'matrixp' is not given an optional argument, return 'true' if 'e'
     is a matrix.  In all other cases, return 'false'.

     See also 'blockmatrixp'

 -- Function: matrix_size (<M>)

     Return a two member list that gives the number of rows and columns,
     respectively of the matrix <M>.

 -- Function: mat_fullunblocker (<M>)

     If <M> is a block matrix, unblock the matrix to all levels.  If <M>
     is a matrix, return <M>; otherwise, signal an error.

 -- Function: mat_trace (<M>)

     Return the trace of the matrix <M>.  If <M> isn't a matrix, return
     a noun form.  When <M> is a block matrix, 'mat_trace(M)' returns
     the same value as does 'mat_trace(mat_unblocker(m))'.

 -- Function: mat_unblocker (<M>)

     If <M> is a block matrix, unblock <M> one level.  If <M> is a
     matrix, 'mat_unblocker (M)' returns <M>; otherwise, signal an
     error.

     Thus if each entry of <M> is matrix, 'mat_unblocker (M)' returns an
     unblocked matrix, but if each entry of <M> is a block matrix,
     'mat_unblocker (M)' returns a block matrix with one less level of
     blocking.

     If you use block matrices, most likely you'll want to set
     'matrix_element_mult' to '"."' and 'matrix_element_transpose' to
     ''transpose'.  See also 'mat_fullunblocker'.

     Example:

          (%i1) A : matrix ([1, 2], [3, 4]);
                                      [ 1  2 ]
          (%o1)                       [      ]
                                      [ 3  4 ]
          (%i2) B : matrix ([7, 8], [9, 10]);
                                      [ 7  8  ]
          (%o2)                       [       ]
                                      [ 9  10 ]
          (%i3) matrix ([A, B]);
                               [ [ 1  2 ]  [ 7  8  ] ]
          (%o3)                [ [      ]  [       ] ]
                               [ [ 3  4 ]  [ 9  10 ] ]
          (%i4) mat_unblocker (%);
                                   [ 1  2  7  8  ]
          (%o4)                    [             ]
                                   [ 3  4  9  10 ]

 -- Function: nullspace (<M>)

     If <M> is a matrix, return 'span (v_1, ..., v_n)', where the set
     '{v_1, ..., v_n}' is a basis for the nullspace of <M>.  The span of
     the empty set is '{0}'.  Thus, when the nullspace has only one
     member, return 'span ()'.

 -- Function: nullity (<M>)

     If <M> is a matrix, return the dimension of the nullspace of <M>.

 -- Function: orthogonal_complement (<v_1>, ..., <v_n>)

     Return 'span (u_1, ..., u_m)', where the set '{u_1, ..., u_m}' is a
     basis for the orthogonal complement of the set '(v_1, ..., v_n)'.

     Each vector <v_1> through <v_n> must be a column vector.

 -- Function: polynomialp (<p>, <L>, <coeffp>, <exponp>)
 -- Function: polynomialp (<p>, <L>, <coeffp>)
 -- Function: polynomialp (<p>, <L>)

     Return 'true' if <p> is a polynomial in the variables in the list
     <L>.  The predicate <coeffp> must evaluate to 'true' for each
     coefficient, and the predicate <exponp> must evaluate to 'true' for
     all exponents of the variables in <L>.  If you want to use a
     non-default value for <exponp>, you must supply <coeffp> with a
     value even if you want to use the default for <coeffp>.

     The command 'polynomialp (<p>, <L>, <coeffp>)' is equivalent to
     'polynomialp (<p>, <L>, <coeffp>, 'nonnegintegerp)' and
     'polynomialp (<p>, <L>)' is equivalent to 'polynomialp (<p>, L<,>
     'constantp, 'nonnegintegerp)'.

     The polynomial needn't be expanded:

          (%i1) polynomialp ((x + 1)*(x + 2), [x]);
          (%o1)                         true
          (%i2) polynomialp ((x + 1)*(x + 2)^a, [x]);
          (%o2)                         false

     An example using non-default values for coeffp and exponp:

          (%i1) polynomialp ((x + 1)*(x + 2)^(3/2), [x], numberp, numberp);
          (%o1)                         true
          (%i2) polynomialp ((x^(1/2) + 1)*(x + 2)^(3/2), [x], numberp,
                                                                  numberp);
          (%o2)                         true

     Polynomials with two variables:

          (%i1) polynomialp (x^2 + 5*x*y + y^2, [x]);
          (%o1)                         false
          (%i2) polynomialp (x^2 + 5*x*y + y^2, [x, y]);
          (%o2)                         true

 -- Function: polytocompanion (<p>, <x>)

     If <p> is a polynomial in <x>, return the companion matrix of <p>.
     For a monic polynomial <p> of degree <n>, we have '<p> = (-1)^<n>
     charpoly (polytocompanion (<p>, <x>))'.

     When <p> isn't a polynomial in <x>, signal an error.

 -- Function: ptriangularize (<M>, <v>)

     If <M> is a matrix with each entry a polynomial in <v>, return a
     matrix <M2> such that

     (1) <M2> is upper triangular,

     (2) '<M2> = <E_n> ... <E_1> <M>', where <E_1> through <E_n> are
     elementary matrices whose entries are polynomials in <v>,

     (3) '|det (<M>)| = |det (<M2>)|',

     Note: This function doesn't check that every entry is a polynomial
     in <v>.

 -- Function: rowop (<M>, <i>, <j>, <theta>)

     If <M> is a matrix, return the matrix that results from doing the
     row operation 'R_i <- R_i - theta * R_j'.  If <M> doesn't have a
     row <i> or <j>, signal an error.

 -- Function: rank (<M>)

     Return the rank of that matrix <M>.  The rank is the dimension of
     the column space.

     Example:

          (%i1) rank(matrix([1,2],[2,4]));
          (%o1)                                  1
          (%i2) rank(matrix([1,b],[c,d]));
          Proviso:  {d - b c # 0}
          (%o2)                                  2

 -- Function: rowswap (<M>, <i>, <j>)

     If <M> is a matrix, swap rows <i> and <j>.  If <M> doesn't have a
     row <i> or <j>, signal an error.

 -- Function: toeplitz (<col>)
 -- Function: toeplitz (<col>, <row>)

     Return a Toeplitz matrix <T>.  The first first column of <T> is
     <col>; except for the first entry, the first row of <T> is <row>.
     The default for <row> is complex conjugate of <col>.

     Example:

          (%i1)  toeplitz([1,2,3],[x,y,z]);

                                            [ 1  y  z ]
                                            [         ]
          (%o1)                             [ 2  1  y ]
                                            [         ]
                                            [ 3  2  1 ]
          (%i2)  toeplitz([1,1+%i]);

                                        [   1     1 - %I ]
          (%o2)                         [                ]
                                        [ %I + 1    1    ]

 -- Function: vandermonde_matrix ([<x_1>, ..., <x_n>])

     Return a <n> by <n> matrix whose <i>-th row is '[1, <x_i>, <x_i>^2,
     ... <x_i>^(<n>-1)]'.

 -- Function: zerofor (<M>)
 -- Function: zerofor (<M>, <fld>)

     Return a zero matrix that has the same shape as the matrix <M>.
     Every entry of the zero matrix is the additive identity of the
     field <fld>; the default for <fld> is <generalring>.

     The first argument <M> should be a square matrix or a non-matrix.
     When <M> is a matrix, each entry of <M> can be a square matrix -
     thus <M> can be a blocked Maxima matrix.  The matrix can be blocked
     to any (finite) depth.

     See also 'identfor'

 -- Function: zeromatrixp (<M>)

     If <M> is not a block matrix, return 'true' if 'is (equal (<e>,
     0))' is true for each element <e> of the matrix <M>.  If <M> is a
     block matrix, return 'true' if 'zeromatrixp' evaluates to 'true'
     for each element of <e>.


File: maxima.info,  Node: lsquares,  Next: makeOrders,  Prev: linearalgebra,  Up: Top

59 lsquares
***********

* Menu:

* Introduction to lsquares::
* Functions and Variables for lsquares::


File: maxima.info,  Node: Introduction to lsquares,  Next: Functions and Variables for lsquares,  Prev: lsquares,  Up: lsquares

59.1 Introduction to lsquares
=============================

'lsquares' is a collection of functions to implement the method of least
squares to estimate parameters for a model from numerical data.


File: maxima.info,  Node: Functions and Variables for lsquares,  Prev: Introduction to lsquares,  Up: lsquares

59.2 Functions and Variables for lsquares
=========================================

 -- Function: lsquares_estimates (<D>, <x>, <e>, <a>)
 -- Function: lsquares_estimates (<D>, <x>, <e>, <a>, initial = <L>, tol
          = <t>)

     Estimate parameters <a> to best fit the equation <e> in the
     variables <x> and <a> to the data <D>, as determined by the method
     of least squares.  'lsquares_estimates' first seeks an exact
     solution, and if that fails, then seeks an approximate solution.

     The return value is a list of lists of equations of the form '[a =
     ..., b = ..., c = ...]'.  Each element of the list is a distinct,
     equivalent minimum of the mean square error.

     The data <D> must be a matrix.  Each row is one datum (which may be
     called a 'record' or 'case' in some contexts), and each column
     contains the values of one variable across all data.  The list of
     variables <x> gives a name for each column of <D>, even the columns
     which do not enter the analysis.  The list of parameters <a> gives
     the names of the parameters for which estimates are sought.  The
     equation <e> is an expression or equation in the variables <x> and
     <a>; if <e> is not an equation, it is treated the same as '<e> =
     0'.

     Additional arguments to 'lsquares_estimates' are specified as
     equations and passed on verbatim to the function 'lbfgs' which is
     called to find estimates by a numerical method when an exact result
     is not found.

     If some exact solution can be found (via 'solve'), the data <D> may
     contain non-numeric values.  However, if no exact solution is
     found, each element of <D> must have a numeric value.  This
     includes numeric constants such as '%pi' and '%e' as well as
     literal numbers (integers, rationals, ordinary floats, and
     bigfloats).  Numerical calculations are carried out with ordinary
     floating-point arithmetic, so all other kinds of numbers are
     converted to ordinary floats for calculations.

     'load(lsquares)' loads this function.

     See also
     'lsquares_estimates_exact', 'lsquares_estimates_approximate',
     'lsquares_mse', 'lsquares_residuals', and 'lsquares_residual_mse'.

     Examples:

     A problem for which an exact solution is found.

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                  [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                            [ 1  1  1 ]
                                            [         ]
                                            [ 3       ]
                                            [ -  1  2 ]
                                            [ 2       ]
                                            [         ]
          (%o2)                             [ 9       ]
                                            [ -  2  1 ]
                                            [ 4       ]
                                            [         ]
                                            [ 3  2  2 ]
                                            [         ]
                                            [ 2  2  1 ]
          (%i3) lsquares_estimates (
                   M, [z,x,y], (z+D)^2 = A*x+B*y+C, [A,B,C,D]);
                                   59        27      10921        107
          (%o3)            [[A = - --, B = - --, C = -----, D = - ---]]
                                   16        16      1024         32

     A problem for which no exact solution is found, so
     'lsquares_estimates' resorts to numerical approximation.

          (%i1) load (lsquares)$
          (%i2) M : matrix ([1, 1], [2, 7/4], [3, 11/4], [4, 13/4]);
                                             [ 1  1  ]
                                             [       ]
                                             [    7  ]
                                             [ 2  -  ]
                                             [    4  ]
                                             [       ]
          (%o2)                              [    11 ]
                                             [ 3  -- ]
                                             [    4  ]
                                             [       ]
                                             [    13 ]
                                             [ 4  -- ]
                                             [    4  ]
          (%i3) lsquares_estimates (
            M, [x,y], y=a*x^b+c, [a,b,c], initial=[3,3,3], iprint=[-1,0]);
          (%o3) [[a = 1.387365874920637, b = .7110956639593767,
                                                  c = - .4142705622439105]]

 -- Function: lsquares_estimates_exact (<MSE>, <a>)

     Estimate parameters <a> to minimize the mean square error <MSE>, by
     constructing a system of equations and attempting to solve them
     symbolically via 'solve'.  The mean square error is an expression
     in the parameters <a>, such as that returned by 'lsquares_mse'.

     The return value is a list of lists of equations of the form '[a =
     ..., b = ..., c = ...]'.  The return value may contain zero, one,
     or two or more elements.  If two or more elements are returned,
     each represents a distinct, equivalent minimum of the mean square
     error.

     See also 'lsquares_estimates', 'lsquares_estimates_approximate',
     'lsquares_mse', 'lsquares_residuals', and 'lsquares_residual_mse'.

     Example:

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) mse : lsquares_mse (M, [z, x, y], (z + D)^2 = A*x + B*y + C);
                     5
                    ====
                    \                 2                         2
                     >    ((D + M    )  - C - M     B - M     A)
                    /            i, 1          i, 3      i, 2
                    ====
                    i = 1
          (%o3)     ---------------------------------------------
                                          5
          (%i4) lsquares_estimates_exact (mse, [A, B, C, D]);
                            59        27      10921        107
          (%o4)     [[A = - --, B = - --, C = -----, D = - ---]]
                            16        16      1024         32

 -- Function: lsquares_estimates_approximate (<MSE>, <a>, initial = <L>,
          tol = <t>)

     Estimate parameters <a> to minimize the mean square error <MSE>,
     via the numerical minimization function 'lbfgs'.  The mean square
     error is an expression in the parameters <a>, such as that returned
     by 'lsquares_mse'.

     The solution returned by 'lsquares_estimates_approximate' is a
     local (perhaps global) minimum of the mean square error.  For
     consistency with 'lsquares_estimates_exact', the return value is a
     nested list which contains one element, namely a list of equations
     of the form '[a = ..., b = ..., c = ...]'.

     Additional arguments to 'lsquares_estimates_approximate' are
     specified as equations and passed on verbatim to the function
     'lbfgs'.

     <MSE> must evaluate to a number when the parameters are assigned
     numeric values.  This requires that the data from which <MSE> was
     constructed comprise only numeric constants such as '%pi' and '%e'
     and literal numbers (integers, rationals, ordinary floats, and
     bigfloats).  Numerical calculations are carried out with ordinary
     floating-point arithmetic, so all other kinds of numbers are
     converted to ordinary floats for calculations.

     'load(lsquares)' loads this function.

     See also
     'lsquares_estimates', 'lsquares_estimates_exact',
     'lsquares_mse', 'lsquares_residuals', and 'lsquares_residual_mse'.

     Example:

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) mse : lsquares_mse (M, [z, x, y], (z + D)^2 = A*x + B*y + C);
                     5
                    ====
                    \                 2                         2
                     >    ((D + M    )  - C - M     B - M     A)
                    /            i, 1          i, 3      i, 2
                    ====
                    i = 1
          (%o3)     ---------------------------------------------
                                          5
          (%i4) lsquares_estimates_approximate (
                        mse, [A, B, C, D], iprint = [-1, 0]);
          (%o4) [[A = - 3.67850494740174, B = - 1.683070351177813,
                           C = 10.63469950148635, D = - 3.340357993175206]]

 -- Function: lsquares_mse (<D>, <x>, <e>)

     Returns the mean square error (MSE), a summation expression, for
     the equation <e> in the variables <x>, with data <D>.

     The MSE is defined as:

                              n
                             ====
                         1   \                        2
                         -    >    (lhs(e ) - rhs(e ))
                         n   /           i         i
                             ====
                             i = 1

     where <n> is the number of data and '<e>[i]' is the equation <e>
     evaluated with the variables in <x> assigned values from the 'i'-th
     datum, '<D>[i]'.

     'load(lsquares)' loads this function.

     Example:

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) mse : lsquares_mse (M, [z, x, y], (z + D)^2 = A*x + B*y + C);
                     5
                    ====
                    \                 2                         2
                     >    ((D + M    )  - C - M     B - M     A)
                    /            i, 1          i, 3      i, 2
                    ====
                    i = 1
          (%o3)     ---------------------------------------------
                                          5
          (%i4) diff (mse, D);
                   5
                  ====
                  \                             2
                4  >    (D + M    ) ((D + M    )  - C - M     B - M     A)
                  /           i, 1         i, 1          i, 3      i, 2
                  ====
                  i = 1
          (%o4) ----------------------------------------------------------
                                            5
          (%i5) ''mse, nouns;
                         2                 2         9 2               2
          (%o5) (((D + 3)  - C - 2 B - 2 A)  + ((D + -)  - C - B - 2 A)
                                                     4
                     2               2         3 2               2
           + ((D + 2)  - C - B - 2 A)  + ((D + -)  - C - 2 B - A)
                                               2
                     2             2
           + ((D + 1)  - C - B - A) )/5

 -- Function: lsquares_residuals (<D>, <x>, <e>, <a>)

     Returns the residuals for the equation <e> with specified
     parameters <a> and data <D>.

     <D> is a matrix, <x> is a list of variables, <e> is an equation or
     general expression; if not an equation, <e> is treated as if it
     were '<e> = 0'.  <a> is a list of equations which specify values
     for any free parameters in <e> aside from <x>.

     The residuals are defined as:

                                  lhs(e ) - rhs(e )
                                       i         i

     where '<e>[i]' is the equation <e> evaluated with the variables in
     <x> assigned values from the 'i'-th datum, '<D>[i]', and assigning
     any remaining free variables from <a>.

     'load(lsquares)' loads this function.

     Example:

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                            [ 1  1  1 ]
                                            [         ]
                                            [ 3       ]
                                            [ -  1  2 ]
                                            [ 2       ]
                                            [         ]
          (%o2)                             [ 9       ]
                                            [ -  2  1 ]
                                            [ 4       ]
                                            [         ]
                                            [ 3  2  2 ]
                                            [         ]
                                            [ 2  2  1 ]
          (%i3) a : lsquares_estimates (
                    M, [z,x,y], (z+D)^2 = A*x+B*y+C, [A,B,C,D]);
                                   59        27      10921        107
          (%o3)            [[A = - --, B = - --, C = -----, D = - ---]]
                                   16        16      1024         32
          (%i4) lsquares_residuals (
                    M, [z,x,y], (z+D)^2 = A*x+B*y+C, first(a));
                                      13    13    13  13  13
          (%o4)                      [--, - --, - --, --, --]
                                      64    64    32  64  64

 -- Function: lsquares_residual_mse (<D>, <x>, <e>, <a>)

     Returns the residual mean square error (MSE) for the equation <e>
     with specified parameters <a> and data <D>.

     The residual MSE is defined as:

                              n
                             ====
                         1   \                        2
                         -    >    (lhs(e ) - rhs(e ))
                         n   /           i         i
                             ====
                             i = 1

     where '<e>[i]' is the equation <e> evaluated with the variables in
     <x> assigned values from the 'i'-th datum, '<D>[i]', and assigning
     any remaining free variables from <a>.

     'load(lsquares)' loads this function.

     Example:

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) a : lsquares_estimates (
                       M, [z,x,y], (z+D)^2 = A*x+B*y+C, [A,B,C,D]);

                            59        27      10921        107
          (%o3)     [[A = - --, B = - --, C = -----, D = - ---]]
                            16        16      1024         32
          (%i4) lsquares_residual_mse (
                       M, [z,x,y], (z + D)^2 = A*x + B*y + C, first (a));
                                        169
          (%o4)                         ----
                                        2560

 -- Function: plsquares (<Mat>,<VarList>,<depvars>)
 -- Function: plsquares (<Mat>,<VarList>,<depvars>,<maxexpon>)
 -- Function: plsquares
          (<Mat>,<VarList>,<depvars>,<maxexpon>,<maxdegree>)
     Multivariable polynomial adjustment of a data table by the "least
     squares" method.  <Mat> is a matrix containing the data, <VarList>
     is a list of variable names (one for each Mat column, but use "-"
     instead of varnames to ignore Mat columns), <depvars> is the name
     of a dependent variable or a list with one or more names of
     dependent variables (which names should be in <VarList>),
     <maxexpon> is the optional maximum exponent for each independent
     variable (1 by default), and <maxdegree> is the optional maximum
     polynomial degree (<maxexpon> by default); note that the sum of
     exponents of each term must be equal or smaller than <maxdegree>,
     and if 'maxdgree = 0' then no limit is applied.

     If <depvars> is the name of a dependent variable (not in a list),
     'plsquares' returns the adjusted polynomial.  If <depvars> is a
     list of one or more dependent variables, 'plsquares' returns a list
     with the adjusted polynomial(s).  The Coefficients of Determination
     are displayed in order to inform about the goodness of fit, which
     ranges from 0 (no correlation) to 1 (exact correlation).  These
     values are also stored in the global variable <DETCOEF> (a list if
     <depvars> is a list).

     A simple example of multivariable linear adjustment:
          (%i1) load("plsquares")$

          (%i2) plsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                          [x,y,z],z);
               Determination Coefficient for z = .9897039897039897
                                 11 y - 9 x - 14
          (%o2)              z = ---------------
                                        3

     The same example without degree restrictions:
          (%i3) plsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                          [x,y,z],z,1,0);
               Determination Coefficient for z = 1.0
                              x y + 23 y - 29 x - 19
          (%o3)           z = ----------------------
                                        6

     How many diagonals does a N-sides polygon have?  What polynomial
     degree should be used?
          (%i4) plsquares(matrix([3,0],[4,2],[5,5],[6,9],[7,14],[8,20]),
                          [N,diagonals],diagonals,5);
               Determination Coefficient for diagonals = 1.0
                                          2
                                         N  - 3 N
          (%o4)              diagonals = --------
                                            2
          (%i5) ev(%, N=9);   /* Testing for a 9 sides polygon */
          (%o5)                 diagonals = 27

     How many ways do we have to put two queens without they are
     threatened into a n x n chessboard?
          (%i6) plsquares(matrix([0,0],[1,0],[2,0],[3,8],[4,44]),
                          [n,positions],[positions],4);
               Determination Coefficient for [positions] = [1.0]
                                   4       3      2
                                3 n  - 10 n  + 9 n  - 2 n
          (%o6)    [positions = -------------------------]
                                            6
          (%i7) ev(%[1], n=8); /* Testing for a (8 x 8) chessboard */
          (%o7)                positions = 1288

     An example with six dependent variables:
          (%i8) mtrx:matrix([0,0,0,0,0,1,1,1],[0,1,0,1,1,1,0,0],
                            [1,0,0,1,1,1,0,0],[1,1,1,1,0,0,0,1])$
          (%i8) plsquares(mtrx,[a,b,_And,_Or,_Xor,_Nand,_Nor,_Nxor],
                               [_And,_Or,_Xor,_Nand,_Nor,_Nxor],1,0);
                Determination Coefficient for
          [_And, _Or, _Xor, _Nand, _Nor, _Nxor] =
          [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
          (%o2) [_And = a b, _Or = - a b + b + a,
          _Xor = - 2 a b + b + a, _Nand = 1 - a b,
          _Nor = a b - b - a + 1, _Nxor = 2 a b - b - a + 1]

     To use this function write first 'load("lsquares")'.


File: maxima.info,  Node: makeOrders,  Next: minpack,  Prev: lsquares,  Up: Top

60 makeOrders
*************

* Menu:

* Functions and Variables for makeOrders::


File: maxima.info,  Node: Functions and Variables for makeOrders,  Prev: makeOrders,  Up: makeOrders

60.1 Functions and Variables for makeOrders
===========================================

 -- Function: makeOrders (<indvarlist>, <orderlist>)

     Returns a list of all powers for a polynomial up to and including
     the arguments.

          (%i1) load("makeOrders")$

          (%i2) makeOrders([a,b],[2,3]);
          (%o2) [[0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 1],
                      [1, 2], [1, 3], [2, 0], [2, 1], [2, 2], [2, 3]]
          (%i3) expand((1+a+a^2)*(1+b+b^2+b^3));
                 2  3      3    3    2  2      2    2    2
          (%o3) a  b  + a b  + b  + a  b  + a b  + b  + a  b + a b
                                                            2
                                                     + b + a  + a + 1

     where '[0, 1]' is associated with the term b and '[2, 3]' with a^2
     b^3.

     To use this function write first 'load("makeOrders")'.


File: maxima.info,  Node: minpack,  Next: mnewton,  Prev: makeOrders,  Up: Top

61 minpack
**********

* Menu:

* Introduction to minpack::
* Functions and Variables for minpack::


File: maxima.info,  Node: Introduction to minpack

61.1 Introduction to minpack
============================

'Minpack' is a Common Lisp translation (via 'f2cl') of the Fortran
library MINPACK, as obtained from Netlib.


File: maxima.info,  Node: Functions and Variables for minpack

61.2 Functions and Variables for minpack
========================================

 -- Function: minpack_lsquares (<flist>, <varlist>, <guess> [,
          <tolerance>, <jacobian>])

     Compute the point that minimizes the sum of the squares of the
     functions in the list <flist>.  The variables are in the list
     <varlist>.  An initial guess of the optimum point must be provided
     in <guess>.

     The optional keyword arguments, <tolerance> and <jacobian> provide
     some control over the algorithm.  <tolerance> is the estimated
     relative error desired in the sum of squares.  <jacobian> can be
     used to specify the Jacobian.  If <jacobian> is not given or is
     'true' (the default), the Jacobian is computed from <flist>.  If
     <jacobian> is 'false', a numerical approximation is used.

     'minpack_lsquares' returns a list.  The first item is the estimated
     solution; the second is the sum of squares, and the third indicates
     the success of the algorithm.  The possible values are

     '0'
          improper input parameters.
     '1'
          algorithm estimates that the relative error in the sum of
          squares is at most 'tolerance'.
     '2'
          algorithm estimates that the relative error between x and the
          solution is at most 'tolerance'.
     '3'
          conditions for info = 1 and info = 2 both hold.
     '4'
          fvec is orthogonal to the columns of the jacobian to machine
          precision.
     '5'
          number of calls to fcn with iflag = 1 has reached 100*(n+1).
     '6'
          tol is too small.  no further reduction in the sum of squares
          is possible.
     '7'
          tol is too small.  no further improvement in the approximate
          solution x is possible.

          /* Problem 6: Powell singular function */
          (%i1) powell(x1,x2,x3,x4) :=
                   [x1+10*x2, sqrt(5)*(x3-x4), (x2-2*x3)^2,
                        sqrt(10)*(x1-x4)^2]$
          (%i2) minpack_lsquares(powell(x1,x2,x3,x4), [x1,x2,x3,x4],
                                 [3,-1,0,1]);
          (%o2) [[1.652117596168394e-17, - 1.652117596168393e-18,
                  2.643388153869468e-18, 2.643388153869468e-18],
                 6.109327859207777e-34, 4]

          /* Same problem but use numerical approximation to Jacobian */
          (%i3) minpack_lsquares(powell(x1,x2,x3,x4), [x1,x2,x3,x4],
                                 [3,-1,0,1], jacobian = false);
          (%o3) [[5.060282149485331e-11, - 5.060282149491206e-12,
                  2.179447843547218e-11, 2.179447843547218e-11],
                 3.534491794847031e-21, 5]

 -- Function: minpack_solve (<flist>, <varlist>, <guess> [, <tolerance>,
          <jacobian>])

     Solve a system of 'n' equations in 'n' unknowns.  The 'n' equations
     are given in the list <flist>, and the unknowns are in <varlist>.
     An initial guess of the solution must be provided in <guess>.

     The optional keyword arguments, <tolerance> and <jacobian> provide
     some control over the algorithm.  <tolerance> is the estimated
     relative error desired in the sum of squares.  <jacobian> can be
     used to specify the Jacobian.  If <jacobian> is not given or is
     'true' (the default), the Jacobian is computed from <flist>.  If
     <jacobian> is 'false', a numerical approximation is used.

     'minpack_solve' returns a list.  The first item is the estimated
     solution; the second is the sum of squares, and the third indicates
     the success of the algorithm.  The possible values are

     '0'
          improper input parameters.
     '1'
          algorithm estimates that the relative error in the solution is
          at most 'tolerance'.
     '2'
          number of calls to fcn with iflag = 1 has reached 100*(n+1).
     '3'
          tol is too small.  no further reduction in the sum of squares
          is possible.
     '4'
          Iteration is not making good progress.


File: maxima.info,  Node: mnewton,  Next: numericalio,  Prev: minpack,  Up: Top

62 mnewton
**********

* Menu:

* Einführung in mnewton::
* Funktionen und Variablen für mnewton::


File: maxima.info,  Node: Einführung in mnewton,  Next: Funktionen und Variablen für mnewton,  Prev: mnewton,  Up: mnewton

62.1 Einführung in mnewton
==========================

Das Paket mnewton implementiert das Newton-Verfahren mit der Funktion
'mnewton' für das numerische Lösen nichtlinear Gleichungen in einer oder
mehrerer Variablen.  Die Funktion 'newton' ist eine weitere
Implementierung, die im Paket newton1 enthalten ist.


File: maxima.info,  Node: Funktionen und Variablen für mnewton,  Prev: Einführung in mnewton,  Up: mnewton

62.2 Funktionen und Variablen für mnewton
=========================================

 -- Optionsvariable: newtonepsilon
     Standardwert: '1.0e-8'

     Genauigkeit mit der getestet wird, wie gut die Funktion 'mnewton'
     sich der Lösung angenähert hat.  Unterschreitet die Änderung der
     Approximation den Wert 'newtonepsilon', bricht der Algorithmus ab
     und gibt das Ergebnis zurück.

 -- Optionsvariable: newtonmaxiter
     Standardwert: '50'

     Obere Grenze für die Anzahl an Iterationen, falls die Funktion
     'mnewton' nicht oder sehr langsam konvergiert.

 -- Funktion: mnewton (<FuncList>, <VarList>, <GuessList>)

     Implementation des Newton-Verfahrens für das numerische Lösen von
     Gleichungen in mehreren Variablen.  Das Argument <FuncList> ist die
     Liste der Gleichungen, für die eine numerische Lösung gesucht wird.
     Das Argument <VarList> ist eine Liste der Variablen und das
     Argument <GuessList> ist eine Liste mit den Startwerten des
     Newton-Verfahrens.

     Die Lösungen werden als eine Liste zurückgegeben.  Kann keine
     Lösung gefunden werden, ist die Rückgabe eine leere Liste '[]'.

     'mnewton' wird von den Funktionen 'newtonepsilon' und
     'newtonmaxiter' kontrolliert.

     Die Funktion wird mit dem Kommando 'load(mnewton)' geladen.  Siehe
     die Funktion 'newton' für eine alternative Implementierung des
     Newton-Verfahrens.

     Beispiele:

          (%i1) load(mnewton)$

          (%i2) mnewton([x1+3*log(x1)-x2^2, 2*x1^2-x1*x2-5*x1+1],
                        [x1, x2], [5, 5]);
          (%o2) [[x1 = 3.756834008012769, x2 = 2.779849592817897]]
          (%i3) mnewton([2*a^a-5],[a],[1]);
          (%o3)             [[a = 1.70927556786144]]
          (%i4) mnewton([2*3^u-v/u-5, u+2^v-4], [u, v], [2, 2]);
          (%o4) [[u = 1.066618389595407, v = 1.552564766841786]]

     Die Optionsvariable 'newtonepsilon' kontrolliert die Genauigkeit
     der Approximation.  Weiterhin kontrolliert die Optionsvariable, ob
     die Berechnung mit Gleitkommazahlen in doppelter oder großer
     Genauigkeit durchgeführt wird.

          (%i1) load(mnewton)$

          (%i2) (fpprec : 25, newtonepsilon : bfloat(10^(-fpprec+5)))$

          (%i3) mnewton([2*3^u-v/u-5, u+2^v-4], [u, v], [2, 2]);
          (%o3) [[u = 1.066618389595406772591173b0,
                                         v = 1.552564766841786450100418b0]]

 -- Funktion: newton (<expr>, <x>, <x_0>, <eps>)

     Die Funktion 'newton' gibt eine Näherungslösung der Gleichung
     '<expr> = 0' zurück, die mit dem Newton-Verfahren berechnet wird.
     Der Ausdruck <expr> ist eine Funktion einer Variablen <x>.  Der
     Anfangswert ist ' <x> = <x_0>'.  Der Algorithmus bricht ab, wenn
     'abs(<expr>) < <eps>', wobei der Ausdruck <expr> für den aktuellen
     Näherungswert <x> ausgewertet wird.

     'newton' erlaubt symbolische Variablen im Ausdruck <expr>, wenn der
     Ausdruck 'abs(<expr>) < <eps>' zu 'true' oder 'false' ausgewertet
     werden kann.  Daher ist es nicht notwendig, dass der Ausdruck
     <expr> zu einer Zahl ausgewertet werden kann.

     Das Kommando 'load(newton1)' lädt die Funktion.

     Siehe auch die Funktionen 'realroots', 'allroots' und 'find_root',
     um numerische Lösungen von Gleichungen zu finden.  Das Paket
     mnewton enthält mit der Funktion 'mnewton' eine weitere
     Implementation des Newton-Verfahrens.

     Achtung: Auch mit 'load(newton)' wird eine Funktion mit dem Namen
     'newton' geladen, die sich jedoch in ihrer Syntax von der hier
     beschriebenen Funktion unterscheidet und auch nicht dokumentiert
     ist.

     Beispiele:

          (%i1) load (newton1);
          (%o1) /usr/share/maxima/5.10.0cvs/share/numeric/newton1.mac
          (%i2) newton (cos (u), u, 1, 1/100);
          (%o2)                   1.570675277161251
          (%i3) ev (cos (u), u = %);
          (%o3)                 1.2104963335033528E-4
          (%i4) assume (a > 0);
          (%o4)                        [a > 0]
          (%i5) newton (x^2 - a^2, x, a/2, a^2/100);
          (%o5)                  1.00030487804878 a
          (%i6) ev (x^2 - a^2, x = %);
                                                     2
          (%o6)                6.098490481853958E-4 a


File: maxima.info,  Node: numericalio,  Next: opsubst,  Prev: mnewton,  Up: Top

63 numericalio
**************

* Menu:

* Introduction to numericalio::
* Functions and Variables for plain-text input and output::
* Functions and Variables for binary input and output::


File: maxima.info,  Node: Introduction to numericalio,  Next: Functions and Variables for plain-text input and output,  Prev: numericalio,  Up: numericalio

63.1 Introduction to numericalio
================================

'numericalio' is a collection of functions to read and write files and
streams.  Functions for plain-text input and output can read and write
numbers (integer, float, or bigfloat), symbols, and strings.  Functions
for binary input and output can read and write only floating-point
numbers.

If there already exists a list, matrix, or array object to store input
data, 'numericalio' input functions can write data into that object.
Otherwise, 'numericalio' can guess, to some degree, the structure of an
object to store the data, and return that object.

63.1.1 Plain-text input and output
----------------------------------

In plain-text input and output, it is assumed that each item to read or
write is an atom: an integer, float, bigfloat, string, or symbol, and
not a rational or complex number or any other kind of nonatomic
expression.  The 'numericalio' functions may attempt to do something
sensible faced with nonatomic expressions, but the results are not
specified here and subject to change.

Atoms in both input and output files have the same format as in Maxima
batch files or the interactive console.  In particular, strings are
enclosed in double quotes, backslash '\' prevents any special
interpretation of the next character, and the question mark '?' is
recognized at the beginning of a symbol to mean a Lisp symbol (as
opposed to a Maxima symbol).  No continuation character (to join broken
lines) is recognized.

63.1.2 Separator flag values for input
--------------------------------------

The functions for plain-text input and output take an optional argument,
<separator_flag>, that tells what character separates data.

For plain-text input, these values of <separator_flag> are recognized:
'comma' for comma separated values, 'pipe' for values separated by the
vertical bar character '|', 'semicolon' for values separated by
semicolon ';', and 'space' for values separated by space or tab
characters.  If the file name ends in '.csv' and <separator_flag> is not
specified, 'comma' is assumed.  If the file name ends in something other
than '.csv' and 'separator_flag' is not specified, 'space' is assumed.

In plain-text input, multiple successive space and tab characters count
as a single separator.  However, multiple comma, pipe, or semicolon
characters are significant.  Successive comma, pipe, or semicolon
characters (with or without intervening spaces or tabs) are considered
to have 'false' between the separators.  For example, '1234,,Foo' is
treated the same as '1234,false,Foo'.

63.1.3 Separator flag values for output
---------------------------------------

For plain-text output, 'tab', for values separated by the tab character,
is recognized as a value of <separator_flag>, as well as 'comma',
'pipe', 'semicolon', and 'space'.

In plain-text output, 'false' atoms are written as such; a list '[1234,
false, Foo]' is written '1234,false,Foo', and there is no attempt to
collapse the output to '1234,,Foo'.

63.1.4 Binary floating-point input and output
---------------------------------------------

'numericalio' functions can read and write 8-byte IEEE 754
floating-point numbers.  These numbers can be stored either least
significant byte first or most significant byte first, according to the
global flag set by 'assume_external_byte_order'.  If not specified,
'numericalio' assumes the external byte order is most-significant byte
first.

Other kinds of numbers are coerced to 8-byte floats; 'numericalio'
cannot read or write binary non-numeric data.

Some Lisp implementations do not recognize IEEE 754 special values
(positive and negative infinity, not-a-number values, denormalized
values).  The effect of reading such values with 'numericalio' is
undefined.

'numericalio' includes functions to open a stream for reading or writing
a stream of bytes.


File: maxima.info,  Node: Functions and Variables for plain-text input and output,  Next: Functions and Variables for binary input and output,  Prev: Introduction to numericalio,  Up: numericalio

63.2 Functions and Variables for plain-text input and output
============================================================

 -- Function: read_matrix (<S>)
 -- Function: read_matrix (<S>, <M>)
 -- Function: read_matrix (<S>, <separator_flag>)
 -- Function: read_matrix (<S>, <M>, <separator_flag>)

     'read_matrix(<S>)' reads the source <S> and returns its entire
     content as a matrix.  The size of the matrix is inferred from the
     input data; each line of the file becomes one row of the matrix.
     If some lines have different lengths, 'read_matrix' complains.

     'read_matrix(<S>, <M>)' read the source <S> into the matrix <M>,
     until <M> is full or the source is exhausted.  Input data are read
     into the matrix in row-major order; the input need not have the
     same number of rows and columns as <M>.

     The source <S> may be a file name or a stream.

     The recognized values of <separator_flag> are 'comma', 'pipe',
     'semicolon', and 'space'.  If <separator_flag> is not specified,
     the file is assumed space-delimited.

 -- Function: read_array (<S>, <A>)
 -- Function: read_array (<S>, <A>, <separator_flag>)

     Reads the source <S> into the array <A>, until <A> is full or the
     source is exhausted.  Input data are read into the array in
     row-major order; the input need not conform to the dimensions of
     <A>.

     The source <S> may be a file name or a stream.

     The recognized values of <separator_flag> are 'comma', 'pipe',
     'semicolon', and 'space'.  If <separator_flag> is not specified,
     the file is assumed space-delimited.

 -- Function: read_hashed_array (<S>, <A>)
 -- Function: read_hashed_array (<S>, <A>, <separator_flag>)

     Reads the source <S> and returns its entire content as a hashed
     array.  The source <S> may be a file name or a stream.

     'read_hashed_array' treats the first item on each line as a hash
     key, and associates the remainder of the line (as a list) with the
     key.  For example, the line '567 12 17 32 55' is equivalent to
     'A[567]: [12, 17, 32, 55]$'.  Lines need not have the same numbers
     of elements.

     The recognized values of <separator_flag> are 'comma', 'pipe',
     'semicolon', and 'space'.  If <separator_flag> is not specified,
     the file is assumed space-delimited.

 -- Function: read_nested_list (<S>)
 -- Function: read_nested_list (<S>, <separator_flag>)

     Reads the source <S> and returns its entire content as a nested
     list.  The source <S> may be a file name or a stream.

     'read_nested_list' returns a list which has a sublist for each line
     of input.  Lines need not have the same numbers of elements.  Empty
     lines are not ignored: an empty line yields an empty sublist.

     The recognized values of <separator_flag> are 'comma', 'pipe',
     'semicolon', and 'space'.  If <separator_flag> is not specified,
     the file is assumed space-delimited.

 -- Function: read_list (<S>)
 -- Function: read_list (<S>, <L>)
 -- Function: read_list (<S>, <separator_flag>)
 -- Function: read_list (<S>, <L>, <separator_flag>)

     'read_list(<S>)' reads the source <S> and returns its entire
     content as a flat list.

     'read_list(<S>, <L>)' reads the source <S> into the list <L>, until
     <L> is full or the source is exhausted.

     The source <S> may be a file name or a stream.

     The recognized values of <separator_flag> are 'comma', 'pipe',
     'semicolon', and 'space'.  If <separator_flag> is not specified,
     the file is assumed space-delimited.

 -- Function: write_data (<X>, <D>)
 -- Function: write_data (<X>, <D>, <separator_flag>)

     Writes the object <X> to the destination <D>.

     'write_data' writes a matrix in row-major order, with one line per
     row.

     'write_data' writes an array created by 'array' or 'make_array' in
     row-major order, with a new line at the end of every slab.
     Higher-dimensional slabs are separated by additional new lines.

     'write_data' writes a hashed array with each key followed by its
     associated list on one line.

     'write_data' writes a nested list with each sublist on one line.

     'write_data' writes a flat list all on one line.

     The destination <D> may be a file name or a stream.  When the
     destination is a file name, the global variable
     'file_output_append' governs whether the output file is appended or
     truncated.  When the destination is a stream, no special action is
     taken by 'write_data' after all the data are written; in
     particular, the stream remains open.

     The recognized values of <separator_flag> are 'comma', 'pipe',
     'semicolon', 'space', and 'tab'.  If <separator_flag> is not
     specified, the file is assumed space-delimited.


File: maxima.info,  Node: Functions and Variables for binary input and output,  Prev: Functions and Variables for plain-text input and output,  Up: numericalio

63.3 Functions and Variables for binary input and output
========================================================

 -- Function: assume_external_byte_order (<byte_order_flag>)
     Tells 'numericalio' the byte order for reading and writing binary
     data.  Two values of <byte_order_flag> are recognized: 'lsb' which
     indicates least-significant byte first, also called little-endian
     byte order; and 'msb' which indicates most-significant byte first,
     also called big-endian byte order.

     If not specified, 'numericalio' assumes the external byte order is
     most-significant byte first.

 -- Function: openr_binary (<file_name>)
     Returns an input stream of 8-bit unsigned bytes to read the file
     named by <file_name>.

 -- Function: openw_binary (<file_name>)
     Returns an output stream of 8-bit unsigned bytes to write the file
     named by <file_name>.

 -- Function: opena_binary (<file_name>)
     Returns an output stream of 8-bit unsigned bytes to append the file
     named by <file_name>.

 -- Function: read_binary_matrix (<S>, <M>)
     Reads binary 8-byte floating point numbers from the source <S> into
     the matrix <M> until <M> is full, or the source is exhausted.
     Elements of <M> are read in row-major order.

     The source <S> may be a file name or a stream.

     The byte order in elements of the source is specified by
     'assume_external_byte_order'.

 -- Function: read_binary_array (<S>, <A>)
     Reads binary 8-byte floating point numbers from the source <S> into
     the array <A> until <A> is full, or the source is exhausted.  <A>
     must be an array created by 'array' or 'make_array'.  Elements of
     <A> are read in row-major order.

     The source <S> may be a file name or a stream.

     The byte order in elements of the source is specified by
     'assume_external_byte_order'.

 -- Function: read_binary_list (<S>)
 -- Function: read_binary_list (<S>, <L>)
     'read_binary_list(<S>)' reads the entire content of the source <S>
     as a sequence of binary 8-byte floating point numbers, and returns
     it as a list.  The source <S> may be a file name or a stream.

     'read_binary_list(<S>, <L>)' reads 8-byte binary floating point
     numbers from the source <S> until the list <L> is full, or the
     source is exhausted.

     The byte order in elements of the source is specified by
     'assume_external_byte_order'.

 -- Function: write_binary_data (<X>, <D>)

     Writes the object <X>, comprising binary 8-byte IEEE 754
     floating-point numbers, to the destination <D>.  Other kinds of
     numbers are coerced to 8-byte floats.  'write_binary_data' cannot
     write non-numeric data.

     The object <X> may be a list, a nested list, a matrix, or an array
     created by 'array' or 'make_array'; <X> cannot be an undeclared
     array or any other type of object.  'write_binary_data' writes
     nested lists, matrices, and arrays in row-major order.

     The destination <D> may be a file name or a stream.  When the
     destination is a file name, the global variable
     'file_output_append' governs whether the output file is appended or
     truncated.  When the destination is a stream, no special action is
     taken by 'write_binary_data' after all the data are written; in
     particular, the stream remains open.

     The byte order in elements of the destination is specified by
     'assume_external_byte_order'.


File: maxima.info,  Node: opsubst,  Next: orthopoly,  Prev: numericalio,  Up: Top

64 opsubst
**********

* Menu:

* Functions and Variables for opsubst::


File: maxima.info,  Node: Functions and Variables for opsubst,  Prev: opsubst,  Up: opsubst

64.1 Functions and Variables for opsubst
========================================

 -- Function: opsubst (<f>, <g>, <e>)
 -- Function: opsubst (<g> = <f>, <e>)
 -- Function: opsubst ([<g1> = <f1>, <g2> = <f2>, ..., <gn> = <fn>],
          <e>)

     The function 'opsubst' is similar to the function 'subst', except
     that 'opsubst' only makes substitutions for the operators in an
     expression.  In general, when <f> is an operator in the expression
     <e>, substitute <g> for <f> in the expression <e>.

     To determine the operator, 'opsubst' sets 'inflag' to true.  This
     means 'opsubst' substitutes for the internal, not the displayed,
     operator in the expression.

     To use this function write first 'load("opsubst")'.

     Examples:

          (%i1) load("opsubst")$

          (%i2) opsubst(f, g, g(g(x)));
          (%o2)                     f(f(x))
          (%i3) opsubst(f, g, g(g));
          (%o3)                       f(g)
          (%i4) opsubst(f, g[x], g[x](z));
          (%o4)                       f(z)
          (%i5) opsubst(g[x], f, f(z));
          (%o5)                      g (z)
                                      x
          (%i6) opsubst(tan, sin, sin(sin));
          (%o6)                     tan(sin)
          (%i7) opsubst([f=g, g=h], f(x));
          (%o7)                       h(x)

     Internally, Maxima does not use the unary negation, division, or
     the subtraction operators; thus:

          (%i8) opsubst("+", "-", a-b);
          (%o8)                     a - b
          (%i9) opsubst("f", "-", -a);
          (%o9)                      - a
          (%i10) opsubst("^^", "/", a/b);
                                       a
          (%o10)                       -
                                       b

     The internal representation of '-a*b' is '*(-1,a,b)'; thus

          (%i11) opsubst("[", "*", -a*b);
          (%o11)                  [- 1, a, b]

     When either operator isn't a Maxima symbol, generally some other
     function will signal an error:

          (%i12) opsubst(a+b, f, f(x));

          Improper name or value in functional position:
          b + a
           -- an error.  Quitting.  To debug this try debugmode(true);

     However, subscripted operators are allowed:

          (%i13) opsubst(g[5], f, f(x));
          (%o13)                     g (x)
                                      5


File: maxima.info,  Node: orthopoly,  Next: plotdf,  Prev: opsubst,  Up: Top

65 orthopoly
************

* Menu:

* Introduction to orthogonal polynomials::
* Functions and Variables for orthogonal polynomials::


File: maxima.info,  Node: Introduction to orthogonal polynomials,  Next: Functions and Variables for orthogonal polynomials,  Prev: orthopoly,  Up: orthopoly

65.1 Introduction to orthogonal polynomials
===========================================

'orthopoly' is a package for symbolic and numerical evaluation of
several kinds of orthogonal polynomials, including Chebyshev, Laguerre,
Hermite, Jacobi, Legendre, and ultraspherical (Gegenbauer) polynomials.
Additionally, 'orthopoly' includes support for the spherical Bessel,
spherical Hankel, and spherical harmonic functions.

For the most part, 'orthopoly' follows the conventions of Abramowitz and
Stegun Handbook of Mathematical Functions, Chapter 22 (10th printing,
December 1972); additionally, we use Gradshteyn and Ryzhik, Table of
Integrals, Series, and Products (1980 corrected and enlarged edition),
and Eugen Merzbacher Quantum Mechanics (2nd edition, 1970).

Barton Willis of the University of Nebraska at Kearney (UNK) wrote the
'orthopoly' package and its documentation.  The package is released
under the GNU General Public License (GPL).

65.1.1 Getting Started with orthopoly
-------------------------------------

'load (orthopoly)' loads the 'orthopoly' package.

To find the third-order Legendre polynomial,

     (%i1) legendre_p (3, x);
                           3             2
                  5 (1 - x)    15 (1 - x)
     (%o1)      - ---------- + ----------- - 6 (1 - x) + 1
                      2             2

To express this as a sum of powers of <x>, apply 'ratsimp' or 'rat' to
the result.

     (%i2) [ratsimp (%), rat (%)];
                             3           3
                          5 x  - 3 x  5 x  - 3 x
     (%o2)/R/            [----------, ----------]
                              2           2

Alternatively, make the second argument to 'legendre_p' (its "main"
variable) a canonical rational expression (CRE).

     (%i1) legendre_p (3, rat (x));
                                   3
                                5 x  - 3 x
     (%o1)/R/                   ----------
                                    2

For floating point evaluation, 'orthopoly' uses a running error analysis
to estimate an upper bound for the error.  For example,

     (%i1) jacobi_p (150, 2, 3, 0.2);
     (%o1) interval(- 0.062017037936715, 1.533267919277521E-11)

Intervals have the form 'interval (<c>, <r>)', where <c> is the center
and <r> is the radius of the interval.  Since Maxima does not support
arithmetic on intervals, in some situations, such as graphics, you want
to suppress the error and output only the center of the interval.  To do
this, set the option variable 'orthopoly_returns_intervals' to 'false'.

     (%i1) orthopoly_returns_intervals : false;
     (%o1)                         false
     (%i2) jacobi_p (150, 2, 3, 0.2);
     (%o2)                  - 0.062017037936715

Refer to the section *note Floating point Evaluation:: for more
information.

Most functions in 'orthopoly' have a 'gradef' property; thus

     (%i1) diff (hermite (n, x), x);
     (%o1)                     2 n H     (x)
                                    n - 1
     (%i2) diff (gen_laguerre (n, a, x), x);
                   (a)               (a)
                n L   (x) - (n + a) L     (x) unit_step(n)
                   n                 n - 1
     (%o2)      ------------------------------------------
                                    x

The unit step function in the second example prevents an error that
would otherwise arise by evaluating with <n> equal to 0.

     (%i3) ev (%, n = 0);
     (%o3)                           0

The 'gradef' property only applies to the "main" variable; derivatives
with respect other arguments usually result in an error message; for
example

     (%i1) diff (hermite (n, x), x);
     (%o1)                     2 n H     (x)
                                    n - 1
     (%i2) diff (hermite (n, x), n);

     Maxima doesn't know the derivative of hermite with respect the first
     argument
      -- an error.  Quitting.  To debug this try debugmode(true);

Generally, functions in 'orthopoly' map over lists and matrices.  For
the mapping to fully evaluate, the option variables 'doallmxops' and
'listarith' must both be 'true' (the defaults).  To illustrate the
mapping over matrices, consider

     (%i1) hermite (2, x);
                                          2
     (%o1)                    - 2 (1 - 2 x )
     (%i2) m : matrix ([0, x], [y, 0]);
                                 [ 0  x ]
     (%o2)                       [      ]
                                 [ y  0 ]
     (%i3) hermite (2, m);
                    [                             2  ]
                    [      - 2        - 2 (1 - 2 x ) ]
     (%o3)          [                                ]
                    [             2                  ]
                    [ - 2 (1 - 2 y )       - 2       ]

In the second example, the 'i, j' element of the value is 'hermite (2,
m[i,j])'; this is not the same as computing '-2 + 4 m . m', as seen in
the next example.

     (%i4) -2 * matrix ([1, 0], [0, 1]) + 4 * m . m;
                         [ 4 x y - 2      0     ]
     (%o4)               [                      ]
                         [     0      4 x y - 2 ]

If you evaluate a function at a point outside its domain, generally
'orthopoly' returns the function unevaluated.  For example,

     (%i1) legendre_p (2/3, x);
     (%o1)                        P   (x)
                                   2/3

'orthopoly' supports translation into TeX; it also does two-dimensional
output on a terminal.

     (%i1) spherical_harmonic (l, m, theta, phi);
                               m
     (%o1)                    Y (theta, phi)
                               l
     (%i2) tex (%);
     $$Y_{l}^{m}\left(\vartheta,\varphi\right)$$
     (%o2)                         false
     (%i3) jacobi_p (n, a, a - b, x/2);
                               (a, a - b) x
     (%o3)                    P          (-)
                               n          2
     (%i4) tex (%);
     $$P_{n}^{\left(a,a-b\right)}\left({{x}\over{2}}\right)$$
     (%o4)                         false

65.1.2 Limitations
------------------

When an expression involves several orthogonal polynomials with symbolic
orders, it's possible that the expression actually vanishes, yet Maxima
is unable to simplify it to zero.  If you divide by such a quantity,
you'll be in trouble.  For example, the following expression vanishes
for integers <n> greater than 1, yet Maxima is unable to simplify it to
zero.

     (%i1) (2*n - 1) * legendre_p (n - 1, x) * x - n * legendre_p (n, x)
           + (1 - n) * legendre_p (n - 2, x);
     (%o1)  (2 n - 1) P     (x) x - n P (x) + (1 - n) P     (x)
                       n - 1           n               n - 2

For a specific <n>, we can reduce the expression to zero.

     (%i2) ev (% ,n = 10, ratsimp);
     (%o2)                           0

Generally, the polynomial form of an orthogonal polynomial is ill-suited
for floating point evaluation.  Here's an example.

     (%i1) p : jacobi_p (100, 2, 3, x)$

     (%i2) subst (0.2, x, p);
     (%o2)                3.4442767023833592E+35
     (%i3) jacobi_p (100, 2, 3, 0.2);
     (%o3)  interval(0.18413609135169, 6.8990300925815987E-12)
     (%i4) float(jacobi_p (100, 2, 3, 2/10));
     (%o4)                   0.18413609135169

The true value is about 0.184; this calculation suffers from extreme
subtractive cancellation error.  Expanding the polynomial and then
evaluating, gives a better result.

     (%i5) p : expand(p)$
     (%i6) subst (0.2, x, p);
     (%o6) 0.18413609766122982

This isn't a general rule; expanding the polynomial does not always
result in an expression that is better suited for numerical evaluation.
By far, the best way to do numerical evaluation is to make one or more
of the function arguments floating point numbers.  By doing that,
specialized floating point algorithms are used for evaluation.

Maxima's 'float' function is somewhat indiscriminate; if you apply
'float' to an expression involving an orthogonal polynomial with a
symbolic degree or order parameter, these parameters may be converted
into floats; after that, the expression will not evaluate fully.
Consider

     (%i1) assoc_legendre_p (n, 1, x);
                                    1
     (%o1)                         P (x)
                                    n
     (%i2) float (%);
                                   1.0
     (%o2)                        P   (x)
                                   n
     (%i3) ev (%, n=2, x=0.9);
                                  1.0
     (%o3)                       P   (0.9)
                                  2

The expression in (%o3) will not evaluate to a float; 'orthopoly'
doesn't recognize floating point values where it requires an integer.
Similarly, numerical evaluation of the 'pochhammer' function for orders
that exceed 'pochhammer_max_index' can be troublesome; consider

     (%i1) x :  pochhammer (1, 10), pochhammer_max_index : 5;
     (%o1)                         (1)
                                      10

Applying 'float' doesn't evaluate <x> to a float

     (%i2) float (x);
     (%o2)                       (1.0)
                                      10.0

To evaluate <x> to a float, you'll need to bind 'pochhammer_max_index'
to 11 or greater and apply 'float' to <x>.

     (%i3) float (x), pochhammer_max_index : 11;
     (%o3)                       3628800.0

The default value of 'pochhammer_max_index' is 100; change its value
after loading 'orthopoly'.

Finally, be aware that reference books vary on the definitions of the
orthogonal polynomials; we've generally used the conventions of
conventions of Abramowitz and Stegun.

Before you suspect a bug in orthopoly, check some special cases to
determine if your definitions match those used by 'orthopoly'.
Definitions often differ by a normalization; occasionally, authors use
"shifted" versions of the functions that makes the family orthogonal on
an interval other than (-1, 1).  To define, for example, a Legendre
polynomial that is orthogonal on (0, 1), define

     (%i1) shifted_legendre_p (n, x) := legendre_p (n, 2*x - 1)$

     (%i2) shifted_legendre_p (2, rat (x));
                                 2
     (%o2)/R/                 6 x  - 6 x + 1
     (%i3) legendre_p (2, rat (x));
                                    2
                                 3 x  - 1
     (%o3)/R/                    --------
                                    2

65.1.3 Floating point Evaluation
--------------------------------

Most functions in 'orthopoly' use a running error analysis to estimate
the error in floating point evaluation; the exceptions are the spherical
Bessel functions and the associated Legendre polynomials of the second
kind.  For numerical evaluation, the spherical Bessel functions call
SLATEC functions.  No specialized method is used for numerical
evaluation of the associated Legendre polynomials of the second kind.

The running error analysis ignores errors that are second or higher
order in the machine epsilon (also known as unit roundoff).  It also
ignores a few other errors.  It's possible (although unlikely) that the
actual error exceeds the estimate.

Intervals have the form 'interval (<c>, <r>)', where <c> is the center
of the interval and <r> is its radius.  The center of an interval can be
a complex number, and the radius is always a positive real number.

Here is an example.

     (%i1) fpprec : 50$

     (%i2) y0 : jacobi_p (100, 2, 3, 0.2);
     (%o2) interval(0.1841360913516871, 6.8990300925815987E-12)
     (%i3) y1 : bfloat (jacobi_p (100, 2, 3, 1/5));
     (%o3) 1.8413609135168563091370224958913493690868904463668b-1

Let's test that the actual error is smaller than the error estimate

     (%i4) is (abs (part (y0, 1) - y1) < part (y0, 2));
     (%o4)                         true

Indeed, for this example the error estimate is an upper bound for the
true error.

Maxima does not support arithmetic on intervals.

     (%i1) legendre_p (7, 0.1) + legendre_p (8, 0.1);
     (%o1) interval(0.18032072148437508, 3.1477135311021797E-15)
             + interval(- 0.19949294375000004, 3.3769353084291579E-15)

A user could define arithmetic operators that do interval math.  To
define interval addition, we can define

     (%i1) infix ("@+")$

     (%i2) "@+"(x,y) := interval (part (x, 1) + part (y, 1), part (x, 2)
           + part (y, 2))$

     (%i3) legendre_p (7, 0.1) @+ legendre_p (8, 0.1);
     (%o3) interval(- 0.019172222265624955, 6.5246488395313372E-15)

The special floating point routines get called when the arguments are
complex.  For example,

     (%i1) legendre_p (10, 2 + 3.0*%i);
     (%o1) interval(- 3.876378825E+7 %i - 6.0787748E+7,
                                                1.2089173052721777E-6)

Let's compare this to the true value.

     (%i1) float (expand (legendre_p (10, 2 + 3*%i)));
     (%o1)          - 3.876378825E+7 %i - 6.0787748E+7

Additionally, when the arguments are big floats, the special floating
point routines get called; however, the big floats are converted into
double floats and the final result is a double.

     (%i1) ultraspherical (150, 0.5b0, 0.9b0);
     (%o1) interval(- 0.043009481257265, 3.3750051301228864E-14)

65.1.4 Graphics and 'orthopoly'
-------------------------------

To plot expressions that involve the orthogonal polynomials, you must do
two things:
  1. Set the option variable 'orthopoly_returns_intervals' to 'false',
  2. Quote any calls to 'orthopoly' functions.

If function calls aren't quoted, Maxima evaluates them to polynomials
before plotting; consequently, the specialized floating point code
doesn't get called.  Here is an example of how to plot an expression
that involves a Legendre polynomial.

     (%i1) plot2d ('(legendre_p (5, x)), [x, 0, 1]),
                             orthopoly_returns_intervals : false;
     (%o1)

The entire expression 'legendre_p (5, x)' is quoted; this is different
than just quoting the function name using ''legendre_p (5, <x>)'.

65.1.5 Miscellaneous Functions
------------------------------

The 'orthopoly' package defines the Pochhammer symbol and a unit step
function.  'orthopoly' uses the Kronecker delta function and the unit
step function in 'gradef' statements.

To convert Pochhammer symbols into quotients of gamma functions, use
'makegamma'.

     (%i1) makegamma (pochhammer (x, n));
                               gamma(x + n)
     (%o1)                     ------------
                                 gamma(x)
     (%i2) makegamma (pochhammer (1/2, 1/2));
                                     1
     (%o2)                       ---------
                                 sqrt(%pi)

Derivatives of the Pochhammer symbol are given in terms of the 'psi'
function.

     (%i1) diff (pochhammer (x, n), x);
     (%o1)             (x)  (psi (x + n) - psi (x))
                          n     0             0
     (%i2) diff (pochhammer (x, n), n);
     (%o2)                   (x)  psi (x + n)
                                n    0

You need to be careful with the expression in (%o1); the difference of
the 'psi' functions has polynomials when '<x> = -1, -2, .., -<n>'.
These polynomials cancel with factors in 'pochhammer (<x>, <n>)' making
the derivative a degree '<n> - 1' polynomial when <n> is a positive
integer.

The Pochhammer symbol is defined for negative orders through its
representation as a quotient of gamma functions.  Consider

     (%i1) q : makegamma (pochhammer (x, n));
                               gamma(x + n)
     (%o1)                     ------------
                                 gamma(x)
     (%i2) sublis ([x=11/3, n= -6], q);
                                    729
     (%o2)                        - ----
                                    2240

Alternatively, we can get this result directly.

     (%i1) pochhammer (11/3, -6);
                                    729
     (%o1)                        - ----
                                    2240

The unit step function is left-continuous; thus

     (%i1) [unit_step (-1/10), unit_step (0), unit_step (1/10)];
     (%o1)                       [0, 0, 1]

If you need a unit step function that is neither left or right
continuous at zero, define your own using 'signum', for example,

     (%i1) xunit_step (x) := (1 + signum (x))/2$

     (%i2) [xunit_step (-1/10), xunit_step (0), xunit_step (1/10)];
                                     1
     (%o2)                       [0, -, 1]
                                     2

Do not redefine 'unit_step' itself; some code in 'orthopoly' requires
that the unit step function be left-continuous.

65.1.6 Algorithms
-----------------

Generally, 'orthopoly' does symbolic evaluation by using a hypergeometic
representation of the orthogonal polynomials.  The hypergeometic
functions are evaluated using the (undocumented) functions 'hypergeo11'
and 'hypergeo21'.  The exceptions are the half-integer Bessel functions
and the associated Legendre function of the second kind.  The
half-integer Bessel functions are evaluated using an explicit
representation, and the associated Legendre function of the second kind
is evaluated using recursion.

For floating point evaluation, we again convert most functions into a
hypergeometic form; we evaluate the hypergeometic functions using
forward recursion.  Again, the exceptions are the half-integer Bessel
functions and the associated Legendre function of the second kind.
Numerically, the half-integer Bessel functions are evaluated using the
SLATEC code.


File: maxima.info,  Node: Functions and Variables for orthogonal polynomials,  Prev: Introduction to orthogonal polynomials,  Up: orthopoly

65.2 Functions and Variables for orthogonal polynomials
=======================================================

 -- Function: assoc_legendre_p (<n>, <m>, <x>)

     The associated Legendre function of the first kind of degree <n>
     and order <m>.

     Reference: Abramowitz and Stegun, equations 22.5.37, page 779,
     8.6.6 (second equation), page 334, and 8.2.5, page 333.

 -- Function: assoc_legendre_q (<n>, <m>, <x>)

     The associated Legendre function of the second kind of degree <n>
     and order <m>.

     Reference: Abramowitz and Stegun, equation 8.5.3 and 8.1.8.

 -- Function: chebyshev_t (<n>, <x>)

     The Chebyshev function of the first kind.

     Reference: Abramowitz and Stegun, equation 22.5.47, page 779.

 -- Function: chebyshev_u (<n>, <x>)

     The Chebyshev function of the second kind.

     Reference: Abramowitz and Stegun, equation 22.5.48, page 779.

 -- Function: gen_laguerre (<n>, <a>, <x>)

     The generalized Laguerre polynomial of degree <n>.

     Reference: Abramowitz and Stegun, equation 22.5.54, page 780.

 -- Function: hermite (<n>, <x>)

     The Hermite polynomial.

     Reference: Abramowitz and Stegun, equation 22.5.55, page 780.

 -- Function: intervalp (<e>)

     Return 'true' if the input is an interval and return false if it
     isn't.

 -- Function: jacobi_p (<n>, <a>, <b>, <x>)

     The Jacobi polynomial.

     The Jacobi polynomials are actually defined for all <a> and <b>;
     however, the Jacobi polynomial weight '(1 - <x>)^<a> (1 + <x>)^<b>'
     isn't integrable for '<a> <= -1' or '<b> <= -1'.

     Reference: Abramowitz and Stegun, equation 22.5.42, page 779.

 -- Function: laguerre (<n>, <x>)

     The Laguerre polynomial.

     Reference: Abramowitz and Stegun, equations 22.5.16 and 22.5.54,
     page 780.

 -- Function: legendre_p (<n>, <x>)

     The Legendre polynomial of the first kind.

     Reference: Abramowitz and Stegun, equations 22.5.50 and 22.5.51,
     page 779.

 -- Function: legendre_q (<n>, <x>)

     The Legendre polynomial of the first kind.

     Reference: Abramowitz and Stegun, equations 8.5.3 and 8.1.8.

 -- Function: orthopoly_recur (<f>, <args>)

     Returns a recursion relation for the orthogonal function family <f>
     with arguments <args>.  The recursion is with respect to the
     polynomial degree.

          (%i1) orthopoly_recur (legendre_p, [n, x]);
                          (2 n - 1) P     (x) x + (1 - n) P     (x)
                                     n - 1                 n - 2
          (%o1)   P (x) = -----------------------------------------
                   n                          n

     The second argument to 'orthopoly_recur' must be a list with the
     correct number of arguments for the function <f>; if it isn't,
     Maxima signals an error.

          (%i1) orthopoly_recur (jacobi_p, [n, x]);

          Function jacobi_p needs 4 arguments, instead it received 2
           -- an error.  Quitting.  To debug this try debugmode(true);

     Additionally, when <f> isn't the name of one of the families of
     orthogonal polynomials, an error is signalled.

          (%i1) orthopoly_recur (foo, [n, x]);

          A recursion relation for foo isn't known to Maxima
           -- an error.  Quitting.  To debug this try debugmode(true);

 -- Variable: orthopoly_returns_intervals
     Default value: 'true'

     When 'orthopoly_returns_intervals' is 'true', floating point
     results are returned in the form 'interval (<c>, <r>)', where <c>
     is the center of an interval and <r> is its radius.  The center can
     be a complex number; in that case, the interval is a disk in the
     complex plane.

 -- Function: orthopoly_weight (<f>, <args>)

     Returns a three element list; the first element is the formula of
     the weight for the orthogonal polynomial family <f> with arguments
     given by the list <args>; the second and third elements give the
     lower and upper endpoints of the interval of orthogonality.  For
     example,

          (%i1) w : orthopoly_weight (hermite, [n, x]);
                                      2
                                   - x
          (%o1)                 [%e    , - inf, inf]
          (%i2) integrate(w[1]*hermite(3, x)*hermite(2, x), x, w[2], w[3]);
          (%o2)                           0

     The main variable of <f> must be a symbol; if it isn't, Maxima
     signals an error.

 -- Function: pochhammer (<n>, <x>)

     The Pochhammer symbol.  For nonnegative integers <n> with '<n> <=
     pochhammer_max_index', the expression 'pochhammer (<x>, <n>)'
     evaluates to the product '<x> (<x> + 1) (<x> + 2) ... (<x> + n -
     1)' when '<n> > 0' and to 1 when '<n> = 0'.  For negative <n>,
     'pochhammer (<x>, <n>)' is defined as '(-1)^<n> / pochhammer (1 -
     <x>, -<n>)'.  Thus

          (%i1) pochhammer (x, 3);
          (%o1)                   x (x + 1) (x + 2)
          (%i2) pochhammer (x, -3);
                                           1
          (%o2)               - -----------------------
                                (1 - x) (2 - x) (3 - x)

     To convert a Pochhammer symbol into a quotient of gamma functions,
     (see Abramowitz and Stegun, equation 6.1.22) use 'makegamma', for
     example

          (%i1) makegamma (pochhammer (x, n));
                                    gamma(x + n)
          (%o1)                     ------------
                                      gamma(x)

     When <n> exceeds 'pochhammer_max_index' or when <n> is symbolic,
     'pochhammer' returns a noun form.

          (%i1) pochhammer (x, n);
          (%o1)                         (x)
                                           n

 -- Variable: pochhammer_max_index
     Default value: 100

     'pochhammer (<n>, <x>)' expands to a product if and only if '<n> <=
     pochhammer_max_index'.

     Examples:

          (%i1) pochhammer (x, 3), pochhammer_max_index : 3;
          (%o1)                   x (x + 1) (x + 2)
          (%i2) pochhammer (x, 4), pochhammer_max_index : 3;
          (%o2)                         (x)
                                           4

     Reference: Abramowitz and Stegun, equation 6.1.16, page 256.

 -- Function: spherical_bessel_j (<n>, <x>)

     The spherical Bessel function of the first kind.

     Reference: Abramowitz and Stegun, equations 10.1.8, page 437 and
     10.1.15, page 439.

 -- Function: spherical_bessel_y (<n>, <x>)

     The spherical Bessel function of the second kind.

     Reference: Abramowitz and Stegun, equations 10.1.9, page 437 and
     10.1.15, page 439.

 -- Function: spherical_hankel1 (<n>, <x>)

     The spherical Hankel function of the first kind.

     Reference: Abramowitz and Stegun, equation 10.1.36, page 439.

 -- Function: spherical_hankel2 (<n>, <x>)

     The spherical Hankel function of the second kind.

     Reference: Abramowitz and Stegun, equation 10.1.17, page 439.

 -- Function: spherical_harmonic (<n>, <m>, <x>, <y>)

     The spherical harmonic function.

     Reference: Merzbacher 9.64.

 -- Function: unit_step (<x>)

     The left-continuous unit step function; thus 'unit_step (<x>)'
     vanishes for '<x> <= 0' and equals 1 for '<x> > 0'.

     If you want a unit step function that takes on the value 1/2 at
     zero, use '(1 + signum (<x>))/2'.

 -- Function: ultraspherical (<n>, <a>, <x>)

     The ultraspherical polynomial (also known as the Gegenbauer
     polynomial).

     Reference: Abramowitz and Stegun, equation 22.5.46, page 779.


File: maxima.info,  Node: plotdf,  Next: romberg,  Prev: orthopoly,  Up: Top

66 plotdf
*********

* Menu:

* Introduction to plotdf::
* Functions and Variables for plotdf::


File: maxima.info,  Node: Introduction to plotdf,  Next: Functions and Variables for plotdf,  Prev: plotdf,  Up: plotdf

66.1 Introduction to plotdf
===========================

The function 'plotdf' creates a plot of the direction field (also called
slope field) for a first-order Ordinary Differential Equation (ODE) or a
system of two autonomous first-order ODE's.

Plotdf requires Xmaxima.  It can be used from the console or any other
interface to Maxima, but the resulting file will be sent to Xmaxima for
plotting.  Please make sure you have installed Xmaxima before trying to
use plotdf.

To plot the direction field of a single ODE, the ODE must be written in
the form:

            dy
            -- = F(x,y)
            dx

and the function <F> should be given as the argument for 'plotdf'.  If
the independent and dependent variables are not <x>, and <y>, as in the
equation above, then those two variables should be named explicitly in a
list given as an argument to the plotdf command (see the examples).

To plot the direction field of a set of two autonomous ODE's, they must
be written in the form

            dx             dy
            -- = G(x,y)    -- = F(x,y)
            dt             dt

and the argument for 'plotdf' should be a list with the two functions
<G> and <F>, in that order; namely, the first expression in the list
will be taken to be the time derivative of the variable represented on
the horizontal axis, and the second expression will be the time
derivative of the variable represented on the vertical axis.  Those two
variables do not have to be <x> and <y>, but if they are not, then the
second argument given to plotdf must be another list naming the two
variables, first the one on the horizontal axis and then the one on the
vertical axis.

If only one ODE is given, 'plotdf' will implicitly admit 'x=t', and
'G(x,y)=1', transforming the non-autonomous equation into a system of
two autonomous equations.


File: maxima.info,  Node: Functions and Variables for plotdf,  Prev: Introduction to plotdf,  Up: plotdf

66.2 Functions and Variables for plotdf
=======================================

 -- Function: plotdf (<dydx>, ... options ...)
 -- Function: plotdf (<dvdu>, '['<u>,<v>']', ... options ...)
 -- Function: plotdf ('['<dxdt>, <dydt>']', ... options ...)
 -- Function: plotdf ('['<dudt>, <dvdt>']', '['<u>, <v>']', ... options
          ...)

     Displays a direction field in two dimensions <x> and <y>.

     <dydx>, <dxdt> and <dydt> are expressions that depend on <x> and
     <y>.  <dvdu>, <dudt> and <dvdt> are expressions that depend on <u>
     and <v>.  In addition to those two variables, the expressions can
     also depend on a set of parameters, with numerical values given
     with the 'parameters' option (the option syntax is given below), or
     with a range of allowed values specified by a <sliders> option.

     Several other options can be given within the command, or selected
     in the menu.  Integral curves can be obtained by clicking on the
     plot, or with the option 'trajectory_at'.  The direction of the
     integration can be controlled with the 'direction' option, which
     can have values of _forward_, _backward_ or _both_.  The number of
     integration steps is given by 'nsteps' and the time interval
     between them is set up with the 'tstep' option.  The Adams Moulton
     method is used for the integration; it is also possible to switch
     to an adaptive Runge-Kutta 4th order method.

     Plot window menu:

     The menu in the plot window has the following options: _Zoom_, will
     change the behavior of the mouse so that it will allow you to zoom
     in on a region of the plot by clicking with the left button.  Each
     click near a point magnifies the plot, keeping the center at the
     point where you clicked.  Holding the <Shift> key while clicking,
     zooms out to the previous magnification.  To resume computing
     trajectories when you click on a point, select _Integrate_ from the
     menu.

     The option _Config_ in the menu can be used to change the ODE(s) in
     use and various other settings.  After configuration changes are
     made, the menu option _Replot_ should be selected, to activate the
     new settings.  If a pair of coordinates are entered in the field
     _Trajectory at_ in the _Config_ dialog menu, and the <enter> key is
     pressed, a new integral curve will be shown, in addition to the
     ones already shown.  When _Replot_ is selected, only the last
     integral curve entered will be shown.

     Holding the right mouse button down while the cursor is moved, can
     be used to drag the plot sideways or up and down.  Additional
     parameters such as the number of steps, the initial value of <t>
     and the x and y centers and radii, may be set in the Config menu.

     A copy of the plot can be saved as a postscript file, using the
     menu option _Save_.

     Plot options:

     The 'plotdf' command may include several commands, each command is
     a list of two or more items.  The first item is the name of the
     option, and the remainder comprises the value or values assigned to
     the option.

     The options which are recognized by 'plotdf' are the following:

        * "tstep" defines the length of the increments on the
          independent variable <t>, used to compute an integral curve.
          If only one expression <dydx> is given to 'plotdf', the <x>
          variable will be directly proportional to <t>.  The default
          value is 0.1.

        * "nsteps" defines the number of steps of length 'tstep' that
          will be used for the independent variable, to compute an
          integral curve.  The default value is 100.

        * "direction" defines the direction of the independent variable
          that will be followed to compute an integral curve.  Possible
          values are 'forward', to make the independent variable
          increase 'nsteps' times, with increments 'tstep', 'backward',
          to make the independent variable decrease, or 'both' that will
          lead to an integral curve that extends 'nsteps' forward, and
          'nsteps' backward.  The keywords 'right' and 'left' can be
          used as synonyms for 'forward' and 'backward'.  The default
          value is 'both'.

        * "tinitial" defines the initial value of variable <t> used to
          compute integral curves.  Since the differential equations are
          autonomous, that setting will only appear in the plot of the
          curves as functions of <t>.  The default value is 0.

        * "versus_t" is used to create a second plot window, with a plot
          of an integral curve, as two functions <x>, <y>, of the
          independent variable <t>.  If 'versus_t' is given any value
          different from 0, the second plot window will be displayed.
          The second plot window includes another menu, similar to the
          menu of the main plot window.  The default value is 0.

        * "trajectory_at" defines the coordinates <xinitial> and
          <yinitial> for the starting point of an integral curve.  The
          option is empty by default.

        * "parameters" defines a list of parameters, and their numerical
          values, used in the definition of the differential equations.
          The name and values of the parameters must be given in a
          string with a comma-separated sequence of pairs 'name=value'.

        * "sliders" defines a list of parameters that will be changed
          interactively using slider buttons, and the range of variation
          of those parameters.  The names and ranges of the parameters
          must be given in a string with a comma-separated sequence of
          elements 'name=min:max'

        * "xfun" defines a string with semi-colon-separated sequence of
          functions of <x> to be displayed, on top of the direction
          field.  Those functions will be parsed by Tcl and not by
          Maxima.

        * "x" should be followed by two numbers, which will set up the
          minimum and maximum values shown on the horizontal axis.  If
          the variable on the horizontal axis is not <x>, then this
          option should have the name of the variable on the horizontal
          axis.  The default horizontal range is from -10 to 10.

        * "y" should be followed by two numbers, which will set up the
          minimum and maximum values shown on the vertical axis.  If the
          variable on the vertical axis is not <y>, then this option
          should have the name of the variable on the vertical axis.
          The default vertical range is from -10 to 10.

     Examples:

        * To show the direction field of the differential equation y' =
          exp(-x) + y and the solution that goes through (2, -0.1):

               (%i1) plotdf(exp(-x)+y,[trajectory_at,2,-0.1])$

        * To obtain the direction field for the equation diff(y,x) = x -
          y^2 and the solution with initial condition y(-1) = 3, we can
          use the command:

               (%i1) plotdf(x-y^2,[xfun,"sqrt(x);-sqrt(x)"],
                        [trajectory_at,-1,3], [direction,forward],
                        [y,-5,5], [x,-4,16])$

          The graph also shows the function y = sqrt(x).

        * The following example shows the direction field of a harmonic
          oscillator, defined by the two equations dz/dt = v and dv/dt =
          -k*z/m, and the integral curve through (z,v) = (6,0), with a
          slider that will allow you to change the value of m
          interactively (k is fixed at 2):

               (%i1) plotdf([v,-k*z/m], [z,v], [parameters,"m=2,k=2"],
                          [sliders,"m=1:5"], [trajectory_at,6,0])$

        * To plot the direction field of the Duffing equation,
          m*x''+c*x'+k*x+b*x^3 = 0, we introduce the variable y=x' and
          use:

               (%i1) plotdf([y,-(k*x + c*y + b*x^3)/m],
                            [parameters,"k=-1,m=1.0,c=0,b=1"],
                            [sliders,"k=-2:2,m=-1:1"],[tstep,0.1])$

        * The direction field for a damped pendulum, including the
          solution for the given initial conditions, with a slider that
          can be used to change the value of the mass m, and with a plot
          of the two state variables as a function of time:

               (%i1) plotdf([w,-g*sin(a)/l - b*w/m/l], [a,w],
                       [parameters,"g=9.8,l=0.5,m=0.3,b=0.05"],
                       [trajectory_at,1.05,-9],[tstep,0.01],
                       [a,-10,2], [w,-14,14], [direction,forward],
                       [nsteps,300], [sliders,"m=0.1:1"], [versus_t,1])$


File: maxima.info,  Node: romberg,  Next: simplex,  Prev: plotdf,  Up: Top

67 romberg
**********

* Menu:

* Functions and Variables for romberg::


File: maxima.info,  Node: Functions and Variables for romberg,  Prev: Top,  Up: Top

67.1 Functions and Variables for romberg
========================================

 -- Function: romberg (<expr>, <x>, <a>, <b>)
 -- Function: romberg (<F>, <a>, <b>)

     Computes a numerical integration by Romberg's method.

     'romberg(<expr>, <x>, <a>, <b>)' returns an estimate of the
     integral 'integrate(<expr>, <x>, <a>, <b>)'.  <expr> must be an
     expression which evaluates to a floating point value when <x> is
     bound to a floating point value.

     'romberg(<F>, <a>, <b>)' returns an estimate of the integral
     'integrate(<F>(x), x, <a>, <b>)' where 'x' represents the unnamed,
     sole argument of <F>; the actual argument is not named 'x'.  <F>
     must be a Maxima or Lisp function which returns a floating point
     value when the argument is a floating point value.  <F> may name a
     translated or compiled Maxima function.

     The accuracy of 'romberg' is governed by the global variables
     'rombergabs' and 'rombergtol'.  'romberg' terminates successfully
     when the absolute difference between successive approximations is
     less than 'rombergabs', or the relative difference in successive
     approximations is less than 'rombergtol'.  Thus when 'rombergabs'
     is '0.0' (the default) only the relative error test has any effect
     on 'romberg'.

     'romberg' halves the stepsize at most 'rombergit' times before it
     gives up; the maximum number of function evaluations is therefore
     '2^rombergit'.  If the error criterion established by 'rombergabs'
     and 'rombergtol' is not satisfied, 'romberg' prints an error
     message.  'romberg' always makes at least 'rombergmin' iterations;
     this is a heuristic intended to prevent spurious termination when
     the integrand is oscillatory.

     'romberg' repeatedly evaluates the integrand after binding the
     variable of integration to a specific value (and not before).  This
     evaluation policy makes it possible to nest calls to 'romberg', to
     compute multidimensional integrals.  However, the error
     calculations do not take the errors of nested integrations into
     account, so errors may be underestimated.  Also, methods devised
     especially for multidimensional problems may yield the same
     accuracy with fewer function evaluations.

     'load(romberg)' loads this function.

     See also *note Einführung in QUADPACK::, a collection of numerical
     integration functions.

     Examples:

     A 1-dimensional integration.

          (%i1) load (romberg);
          (%o1)    /usr/share/maxima/5.11.0/share/numeric/romberg.lisp
          (%i2) f(x) := 1/((x - 1)^2 + 1/100) + 1/((x - 2)^2 + 1/1000)
                        + 1/((x - 3)^2 + 1/200);
                              1                 1                1
          (%o2) f(x) := -------------- + --------------- + --------------
                               2    1           2    1            2    1
                        (x - 1)  + ---   (x - 2)  + ----   (x - 3)  + ---
                                   100              1000              200
          (%i3) rombergtol : 1e-6;
          (%o3)                 9.9999999999999995E-7
          (%i4) rombergit : 15;
          (%o4)                          15
          (%i5) estimate : romberg (f(x), x, -5, 5);
          (%o5)                   173.6730736617464
          (%i6) exact : integrate (f(x), x, -5, 5);
          (%o6) 10 sqrt(10) atan(70 sqrt(10))
           + 10 sqrt(10) atan(30 sqrt(10)) + 10 sqrt(2) atan(80 sqrt(2))
           + 10 sqrt(2) atan(20 sqrt(2)) + 10 atan(60) + 10 atan(40)
          (%i7) abs (estimate - exact) / exact, numer;
          (%o7)                7.5527060865060088E-11

     A 2-dimensional integration, implemented by nested calls to
     'romberg'.

          (%i1) load (romberg);
          (%o1)    /usr/share/maxima/5.11.0/share/numeric/romberg.lisp
          (%i2) g(x, y) := x*y / (x + y);
                                              x y
          (%o2)                   g(x, y) := -----
                                             x + y
          (%i3) rombergtol : 1e-6;
          (%o3)                 9.9999999999999995E-7
          (%i4) estimate : romberg (romberg (g(x, y), y, 0, x/2), x, 1, 3);
          (%o4)                   0.81930239628356
          (%i5) assume (x > 0);
          (%o5)                        [x > 0]
          (%i6) integrate (integrate (g(x, y), y, 0, x/2), x, 1, 3);
                                                    3
                                              2 log(-) - 1
                              9                     2        9
          (%o6)       - 9 log(-) + 9 log(3) + ------------ + -
                              2                    6         2
          (%i7) exact : radcan (%);
                              26 log(3) - 26 log(2) - 13
          (%o7)             - --------------------------
                                          3
          (%i8) abs (estimate - exact) / exact, numer;
          (%o8)                1.3711979871851024E-10

 -- Option variable: rombergabs
     Default value: '0.0'

     The accuracy of 'romberg' is governed by the global variables
     'rombergabs' and 'rombergtol'.  'romberg' terminates successfully
     when the absolute difference between successive approximations is
     less than 'rombergabs', or the relative difference in successive
     approximations is less than 'rombergtol'.  Thus when 'rombergabs'
     is '0.0' (the default) only the relative error test has any effect
     on 'romberg'.

     See also 'rombergit' and 'rombergmin'.

 -- Option variable: rombergit
     Default value: '11'

     'romberg' halves the stepsize at most 'rombergit' times before it
     gives up; the maximum number of function evaluations is therefore
     '2^rombergit'.  'romberg' always makes at least 'rombergmin'
     iterations; this is a heuristic intended to prevent spurious
     termination when the integrand is oscillatory.

     See also 'rombergabs' and 'rombergtol'.

 -- Option variable: rombergmin
     Default value: '0'

     'romberg' always makes at least 'rombergmin' iterations; this is a
     heuristic intended to prevent spurious termination when the
     integrand is oscillatory.

     See also 'rombergit', 'rombergabs', and 'rombergtol'.

 -- Option variable: rombergtol
     Default value: '1e-4'

     The accuracy of 'romberg' is governed by the global variables
     'rombergabs' and 'rombergtol'.  'romberg' terminates successfully
     when the absolute difference between successive approximations is
     less than 'rombergabs', or the relative difference in successive
     approximations is less than 'rombergtol'.  Thus when 'rombergabs'
     is '0.0' (the default) only the relative error test has any effect
     on 'romberg'.

     See also 'rombergit' and 'rombergmin'.


File: maxima.info,  Node: simplex,  Next: simplification,  Prev: romberg,  Up: Top

68 simplex
**********

* Menu:

* Introduction to simplex::
* Functions and Variables for simplex::


File: maxima.info,  Node: Introduction to simplex,  Next: Functions and Variables for simplex,  Prev: simplex,  Up: simplex

68.1 Introduction to simplex
============================

'simplex' is a package for linear optimization using the simplex
algorithm.

Example:

     (%i1) load("simplex")$
     (%i2) minimize_lp(x+y, [3*x+2*y>2, x+4*y>3]);
                       9        7       1
     (%o2)            [--, [y = --, x = -]]
                       10       10      5


File: maxima.info,  Node: Functions and Variables for simplex,  Prev: Introduction to simplex,  Up: simplex

68.2 Functions and Variables for simplex
========================================

 -- Option variable: epsilon_lp
     Default value: '10^-8'

     Epsilon used for numerical computations in 'linear_program'.

     See also: 'linear_program'.

 -- Function: linear_program (<A>, <b>, <c>)

     'linear_program' is an implementation of the simplex algorithm.
     'linear_program(A, b, c)' computes a vector <x> for which 'c.x' is
     minimum possible among vectors for which 'A.x = b' and 'x >= 0'.
     Argument <A> is a matrix and arguments <b> and <c> are lists.

     'linear_program' returns a list which contains the minimizing
     vector <x> and the minimum value 'c.x'.  If the problem is not
     bounded, it returns "Problem not bounded!"  and if the problem is
     not feasible, it returns "Problem not feasible!".

     To use this function first load the 'simplex' package with
     'load(simplex);'.

     Example:

          (%i2) A: matrix([1,1,-1,0], [2,-3,0,-1], [4,-5,0,0])$
          (%i3) b: [1,1,6]$
          (%i4) c: [1,-2,0,0]$
          (%i5) linear_program(A, b, c);
                             13     19        3
          (%o5)            [[--, 4, --, 0], - -]
                             2      2         2

     See also: 'minimize_lp', 'scale_lp', and 'epsilon_lp'.

 -- Function: maximize_lp (<obj>, <cond>, [<pos>])

     Maximizes linear objective function <obj> subject to some linear
     constraints <cond>.  See 'minimize_lp' for detailed description of
     arguments and return value.

     See also: 'minimize_lp'.

 -- Function: minimize_lp (<obj>, <cond>, [<pos>])

     Minimizes a linear objective function <obj> subject to some linear
     constraints <cond>.  <cond> a list of linear equations or
     inequalities.  In strict inequalities '>' is replaced by '>=' and
     '<' by '<='.  The optional argument <pos> is a list of decision
     variables which are assumed to be positive.

     If the minimum exists, 'minimize_lp' returns a list which contains
     the minimum value of the objective function and a list of decision
     variable values for which the minimum is attained.  If the problem
     is not bounded, 'minimize_lp' returns "Problem not bounded!"  and
     if the problem is not feasible, it returns "Ploblem not feasible!".

     The decision variables are not assumed to be nonegative by default.
     If all decision variables are nonegative, set 'nonegative_lp' to
     'true'.  If only some of decision variables are positive, list them
     in the optional argument <pos> (note that this is more efficient
     than adding constraints).

     'minimize_lp' uses the simplex algorithm which is implemented in
     maxima 'linear_program' function.

     To use this function first load the 'simplex' package with
     'load(simplex);'.

     Examples:

          (%i1) minimize_lp(x+y, [3*x+y=0, x+2*y>2]);
                                4       6        2
          (%o1)                [-, [y = -, x = - -]]
                                5       5        5
          (%i2) minimize_lp(x+y, [3*x+y>0, x+2*y>2]), nonegative_lp=true;
          (%o2)                [1, [y = 1, x = 0]]
          (%i3) minimize_lp(x+y, [3*x+y=0, x+2*y>2]), nonegative_lp=true;
          (%o3)                Problem not feasible!
          (%i4) minimize_lp(x+y, [3*x+y>0]);
          (%o4)                Problem not bounded!

     See also: 'maximize_lp', 'nonegative_lp', 'epsilon_lp'.

 -- Option variable: nonegative_lp
     Default value: 'false'

     If 'nonegative_lp' is true all decision variables to 'minimize_lp'
     and 'maximize_lp' are assumed to be positive.

     See also: 'minimize_lp'.


File: maxima.info,  Node: simplification,  Next: solve_rec,  Prev: simplex,  Up: Top

69 simplification
*****************

* Menu:

* Introduction to simplification::
* Package absimp::
* Package facexp::
* Package functs::
* Package ineq::
* Package rducon::
* Package scifac::
* Package sqdnst::


File: maxima.info,  Node: Introduction to simplification,  Next: Package absimp,  Prev: simplification,  Up: simplification

69.1 Introduction to simplification
===================================

The directory 'maxima/share/simplification' contains several scripts
which implement simplification rules and functions, and also some
functions not related to simplification.


File: maxima.info,  Node: Package absimp,  Next: Package facexp,  Prev: Introduction to simplification,  Up: simplification

69.2 Package absimp
===================

The 'absimp' package contains pattern-matching rules that extend the
built-in simplification rules for the 'abs' and 'signum' functions.
'absimp' respects relations established with the built-in 'assume'
function and by declarations such as 'modedeclare (m, even, n, odd)' for
even or odd integers.

'absimp' defines 'unitramp' and 'unitstep' functions in terms of 'abs'
and 'signum'.

'load(absimp)' loads this package.  'demo(absimp)' shows a demonstration
of this package.

Examples:

     (%i1) load (absimp)$
     (%i2) (abs (x))^2;
                                            2
     (%o2)                                 x
     (%i3) diff (abs (x), x);
                                           x
     (%o3)                               ------
                                         abs(x)
     (%i4) cosh (abs (x));
     (%o4)                               cosh(x)


File: maxima.info,  Node: Package facexp,  Next: Package functs,  Prev: Package absimp,  Up: simplification

69.3 Package facexp
===================

The 'facexp' package contains several related functions that provide the
user with the ability to structure expressions by controlled expansion.
This capability is especially useful when the expression contains
variables that have physical meaning, because it is often true that the
most economical form of such an expression can be obtained by fully
expanding the expression with respect to those variables, and then
factoring their coefficients.  While it is true that this procedure is
not difficult to carry out using standard Maxima functions, additional
fine-tuning may also be desirable, and these finishing touches can be
more difficult to apply.

The function 'facsum' and its related forms provide a convenient means
for controlling the structure of expressions in this way.  Another
function, 'collectterms', can be used to add two or more expressions
that have already been simplified to this form, without resimplifying
the whole expression again.  This function may be useful when the
expressions are very large.

'load(facexp)' loads this package.  'demo(facexp)' shows a demonstration
of this package.

 -- Function: facsum (<expr>, <arg_1>, ..., <arg_n>)

     Returns a form of <expr> which depends on the arguments <arg_1>,
     ..., <arg_n>.  The arguments can be any form suitable for
     'ratvars', or they can be lists of such forms.  If the arguments
     are not lists, then the form returned is fully expanded with
     respect to the arguments, and the coefficients of the arguments are
     factored.  These coefficients are free of the arguments, except
     perhaps in a non-rational sense.

     If any of the arguments are lists, then all such lists are combined
     into a single list, and instead of calling 'factor' on the
     coefficients of the arguments, 'facsum' calls itself on these
     coefficients, using this newly constructed single list as the new
     argument list for this recursive call.  This process can be
     repeated to arbitrary depth by nesting the desired elements in
     lists.

     It is possible that one may wish to 'facsum' with respect to more
     complicated subexpressions, such as 'log(x + y)'.  Such arguments
     are also permissible.

     Occasionally the user may wish to obtain any of the above forms for
     expressions which are specified only by their leading operators.
     For example, one may wish to 'facsum' with respect to all 'log''s.
     In this situation, one may include among the arguments either the
     specific 'log''s which are to be treated in this way, or
     alternatively, either the expression 'operator (log)' or ''operator
     (log)'.  If one wished to 'facsum' the expression <expr> with
     respect to the operators <op_1>, ..., <op_n>, one would evaluate
     'facsum (<expr>, operator (<op_1>, ..., <op_n>))'.  The 'operator'
     form may also appear inside list arguments.

     In addition, the setting of the switches 'facsum_combine' and
     'nextlayerfactor' may affect the result of 'facsum'.

 -- Global variable: nextlayerfactor
     Default value: 'false'

     When 'nextlayerfactor' is 'true', recursive calls of 'facsum' are
     applied to the factors of the factored form of the coefficients of
     the arguments.

     When 'false', 'facsum' is applied to each coefficient as a whole
     whenever recusive calls to 'facsum' occur.

     Inclusion of the atom 'nextlayerfactor' in the argument list of
     'facsum' has the effect of 'nextlayerfactor: true', but for the
     next level of the expression only.  Since 'nextlayerfactor' is
     always bound to either 'true' or 'false', it must be presented
     single-quoted whenever it appears in the argument list of 'facsum'.

 -- Global variable: facsum_combine
     Default value: 'true'

     'facsum_combine' controls the form of the final result returned by
     'facsum' when its argument is a quotient of polynomials.  If
     'facsum_combine' is 'false' then the form will be returned as a
     fully expanded sum as described above, but if 'true', then the
     expression returned is a ratio of polynomials, with each polynomial
     in the form described above.

     The 'true' setting of this switch is useful when one wants to
     'facsum' both the numerator and denominator of a rational
     expression, but does not want the denominator to be multiplied
     through the terms of the numerator.

 -- Function: factorfacsum (<expr>, <arg_1>, ... <arg_n>)

     Returns a form of <expr> which is obtained by calling 'facsum' on
     the factors of <expr> with <arg_1>, ... <arg_n> as arguments.  If
     any of the factors of <expr> is raised to a power, both the factor
     and the exponent will be processed in this way.

 -- Function: collectterms (<expr>, <arg_1>, ..., <arg_n>)

     If several expressions have been simplified with the following
     functions: 'facsum', 'factorfacsum', 'factenexpand', 'facexpten' or
     'factorfacexpten', and they are to be added together, it may be
     desirable to combine them using the function 'collecterms'.
     'collecterms' can take as arguments all of the arguments that can
     be given to these other associated functions with the exception of
     'nextlayerfactor', which has no effect on 'collectterms'.  The
     advantage of 'collectterms' is that it returns a form similar to
     'facsum', but since it is adding forms that have already been
     processed by 'facsum', it does not need to repeat that effort.
     This capability is especially useful when the expressions to be
     summed are very large.


File: maxima.info,  Node: Package functs,  Next: Package ineq,  Prev: Package facexp,  Up: simplification

69.4 Package functs
===================

 -- Function: rempart (<expr>, <n>)

     Removes part <n> from the expression <expr>.

     If <n> is a list of the form '[<l>, <m>]' then parts <l> thru <m>
     are removed.

     To use this function write first 'load(functs)'.

 -- Function: wronskian ([<f_1>, ..., <f_n>], <x>)

     Returns the Wronskian matrix of the list of expressions [<f_1>,
     ..., <f_n>] in the variable <x>.  The determinant of the Wronskian
     matrix is the Wronskian determinant of the list of expressions.

     To use 'wronskian', first 'load(functs)'.  Example:

          (%i1) load(functs)$
          (%i2) wronskian([f(x), g(x)],x);
          (%o2) matrix([f(x),g(x)],['diff(f(x),x,1),'diff(g(x),x,1)])

 -- Function: tracematrix (<M>)

     Returns the trace (sum of the diagonal elements) of matrix <M>.

     To use this function write first 'load(functs)'.

 -- Function: rational ('z')

     Multiplies numerator and denominator of <z> by the complex
     conjugate of denominator, thus rationalizing the denominator.
     Returns canonical rational expression (CRE) form if given one, else
     returns general form.

     To use this function write first 'load(functs)'.

 -- Function: nonzeroandfreeof (<x>, <expr>)

     Returns 'true' if <expr> is nonzero and 'freeof (<x>, <expr>)'
     returns 'true'.  Returns 'false' otherwise.

     To use this function write first 'load(functs)'.

 -- Function: linear (<expr>, <x>)

     When <expr> is an expression linear in variable <x>, 'linear'
     returns '<a>*<x> + <b>' where <a> is nonzero, and <a> and <b> are
     free of <x>.  Otherwise, 'linear' returns <expr>.

     To use this function write first 'load(functs)'.

 -- Function: gcdivide (<p>, <q>)

     When the option variable 'takegcd' is 'true' which is the default,
     'gcdivide' divides the polynomials <p> and <q> by their greatest
     common divisor and returns the ratio of the results.  'gcdivde'
     calls the function 'ezgcd' to divide the polynomials by the
     greatest common divisor.

     When 'takegcd' is 'false', 'gcdivide' returns the ratio '<p>/<q>'.

     To use this function write first 'load(functs)'.

     See also 'ezgcd', 'gcd', 'gcdex', and 'poly_gcd'.

     Example:

          (%i1) load(functs)$

          (%i2) p1:6*x^3+19*x^2+19*x+6;
                                  3       2
          (%o2)                6 x  + 19 x  + 19 x + 6
          (%i3) p2:6*x^5+13*x^4+12*x^3+13*x^2+6*x;
                            5       4       3       2
          (%o3)          6 x  + 13 x  + 12 x  + 13 x  + 6 x
          (%i4) gcdivide(p1, p2);
                                       x + 1
          (%o4)                        ------
                                        3
                                       x  + x
          (%i5) takegcd:false;
          (%o5)                         false
          (%i6) gcdivide(p1, p2);
                                 3       2
                              6 x  + 19 x  + 19 x + 6
          (%o6)          ----------------------------------
                            5       4       3       2
                         6 x  + 13 x  + 12 x  + 13 x  + 6 x
          (%i7) ratsimp(%);
                                       x + 1
          (%o7)                        ------
                                        3
                                       x  + x

 -- Function: arithmetic (<a>, <d>, <n>)

     Returns the <n>-th term of the arithmetic series '<a>, <a> + <d>,
     <a> + 2*<d>, ..., <a> + (<n> - 1)*<d>'.

     To use this function write first 'load(functs)'.

 -- Function: geometric (<a>, <r>, <n>)

     Returns the <n>-th term of the geometric series '<a>, <a>*<r>,
     <a>*<r>^2, ..., <a>*<r>^(<n> - 1)'.

     To use this function write first 'load(functs)'.

 -- Function: harmonic (<a>, <b>, <c>, <n>)

     Returns the <n>-th term of the harmonic series '<a>/<b>, <a>/(<b> +
     <c>), <a>/(<b> + 2*<c>), ..., <a>/(<b> + (<n> - 1)*<c>)'.

     To use this function write first 'load(functs)'.

 -- Function: arithsum (<a>, <d>, <n>)

     Returns the sum of the arithmetic series from 1 to <n>.

     To use this function write first 'load(functs)'.

 -- Function: geosum (<a>, <r>, <n>)

     Returns the sum of the geometric series from 1 to <n>.  If <n> is
     infinity ('inf') then a sum is finite only if the absolute value of
     <r> is less than 1.

     To use this function write first 'load(functs)'.

 -- Function: gaussprob (<x>)

     Returns the Gaussian probability function '%e^(-<x>^2/2) /
     sqrt(2*%pi)'.

     To use this function write first 'load(functs)'.

 -- Function: gd (<x>)

     Returns the Gudermannian function '2*atan(%e^x)-%pi/2'.

     To use this function write first 'load(functs)'.

 -- Function: agd (<x>)

     Returns the inverse Gudermannian function 'log (tan (%pi/4 +
     x/2)))'.

     To use this function write first 'load(functs)'.

 -- Function: vers (<x>)

     Returns the versed sine '1 - cos (x)'.

     To use this function write first 'load(functs)'.

 -- Function: covers (<x>)

     Returns the coversed sine '1 - sin (<x>)'.

     To use this function write first 'load(functs)'.

 -- Function: exsec (<x>)

     Returns the exsecant 'sec (<x>) - 1'.

     To use this function write first 'load(functs)'.

 -- Function: hav (<x>)

     Returns the haversine '(1 - cos(x))/2'.

     To use this function write first 'load(functs)'.

 -- Function: combination (<n>, <r>)

     Returns the number of combinations of <n> objects taken <r> at a
     time.

     To use this function write first 'load(functs)'.

 -- Function: permutation (<n>, <r>)

     Returns the number of permutations of <r> objects selected from a
     set of <n> objects.

     To use this function write first 'load(functs)'.


File: maxima.info,  Node: Package ineq,  Next: Package rducon,  Prev: Package functs,  Up: simplification

69.5 Package ineq
=================

The 'ineq' package contains simplification rules for inequalities.

Example session:

     (%i1) load(ineq)$
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     (%i2) a>=4;  /* a sample inequality */
     (%o2)                               a >= 4
     (%i3) (b>c)+%; /* add a second, strict inequality */
     (%o3)                            b + a > c + 4
     (%i4) 7*(x<y); /* multiply by a positive number */
     (%o4)                              7 x < 7 y
     (%i5) -2*(x>=3*z); /* multiply by a negative number */
     (%o5)                           - 2 x <= - 6 z
     (%i6) (1+a^2)*(1/(1+a^2)<=1); /* Maxima knows that 1+a^2 > 0 */
                                             2
     (%o6)                             1 <= a  + 1
     (%i7) assume(x>0)$ x*(2<3); /* assuming x>0 */
     (%o7)                              2 x < 3 x
     (%i8) a>=b; /* another inequality */
     (%o8)                               a >= b
     (%i9) 3+%; /* add something */
     (%o9)                           a + 3 >= b + 3
     (%i10) %-3; /* subtract it out */
     (%o10)                              a >= b
     (%i11) a>=c-b; /* yet another inequality */
     (%o11)                            a >= c - b
     (%i12) b+%; /* add b to both sides */
     (%o12)                            b + a >= c
     (%i13) %-c; /* subtract c from both sides */
     (%o13)                         - c + b + a >= 0
     (%i14) -%;  /* multiply by -1 */
     (%o14)                          c - b - a <= 0
     (%i15) (z-1)^2>-2*z; /* determining truth of assertion */
                                           2
     (%o15)                         (z - 1)  > - 2 z
     (%i16) expand(%)+2*z; /* expand this and add 2*z to both sides */
                                        2
     (%o16)                            z  + 1 > 0
     (%i17) %,pred;
     (%o17)                               true

Be careful about using parentheses around the inequalities: when the
user types in '(A > B) + (C = 5)' the result is 'A + C > B + 5', but 'A
> B + C = 5' is a syntax error, and '(A > B + C) = 5' is something else
entirely.

Do 'disprule (all)' to see a complete listing of the rule definitions.

The user will be queried if Maxima is unable to decide the sign of a
quantity multiplying an inequality.

The most common mis-feature is illustrated by:

     (%i1) eq: a > b;
     (%o1)                              a > b
     (%i2) 2*eq;
     (%o2)                            2 (a > b)
     (%i3) % - eq;
     (%o3)                              a > b

Another problem is 0 times an inequality; the default to have this turn
into 0 has been left alone.  However, if you type 'X*<some_inequality>'
and Maxima asks about the sign of 'X' and you respond 'zero' (or 'z'),
the program returns 'X*<some_inequality>' and not use the information
that 'X' is 0.  You should do 'ev (%, x: 0)' in such a case, as the
database will only be used for comparison purposes in decisions, and not
for the purpose of evaluating 'X'.

The user may note a slower response when this package is loaded, as the
simplifier is forced to examine more rules than without the package, so
you might wish to remove the rules after making use of them.  Do 'kill
(rules)' to eliminate all of the rules (including any that you might
have defined); or you may be more selective by killing only some of
them; or use 'remrule' on a specific rule.

Note that if you load this package after defining your own rules you
will clobber your rules that have the same name.  The rules in this
package are: '*rule1', ..., '*rule8', '+rule1', ..., '+rule18', and you
must enclose the rulename in quotes to refer to it, as in 'remrule ("+",
"+rule1")' to specifically remove the first rule on '"+"' or 'disprule
("*rule2")' to display the definition of the second multiplicative rule.


File: maxima.info,  Node: Package rducon,  Next: Package scifac,  Prev: Package ineq,  Up: simplification

69.6 Package rducon
===================

 -- Function: reduce_consts (<expr>)

     Replaces constant subexpressions of <expr> with constructed
     constant atoms, saving the definition of all these constructed
     constants in the list of equations 'const_eqns', and returning the
     modified <expr>.  Those parts of <expr> are constant which return
     'true' when operated on by the function 'constantp'.  Hence, before
     invoking 'reduce_consts', one should do

          declare ([<objects to be given the constant property>], constant)$

     to set up a database of the constant quantities occurring in your
     expressions.

     If you are planning to generate Fortran output after these symbolic
     calculations, one of the first code sections should be the
     calculation of all constants.  To generate this code segment, do

          map ('fortran, const_eqns)$

     Variables besides 'const_eqns' which affect 'reduce_consts' are:

     'const_prefix' (default value: 'xx') is the string of characters
     used to prefix all symbols generated by 'reduce_consts' to
     represent constant subexpressions.

     'const_counter' (default value: 1) is the integer index used to
     generate unique symbols to represent each constant subexpression
     found by 'reduce_consts'.

     'load(rducon)' loads this function.  'demo(rducon)' shows a
     demonstration of this function.


File: maxima.info,  Node: Package scifac,  Next: Package sqdnst,  Prev: Package rducon,  Up: simplification

69.7 Package scifac
===================

 -- Function: gcfac (<expr>)

     'gcfac' is a factoring function that attempts to apply the same
     heuristics which scientists apply in trying to make expressions
     simpler.  'gcfac' is limited to monomial-type factoring.  For a
     sum, 'gcfac' does the following:

       1. Factors over the integers.
       2. Factors out the largest powers of terms occurring as
          coefficients, regardless of the complexity of the terms.
       3. Uses (1) and (2) in factoring adjacent pairs of terms.
       4. Repeatedly and recursively applies these techniques until the
          expression no longer changes.

     Item (3) does not necessarily do an optimal job of pairwise
     factoring because of the combinatorially-difficult nature of
     finding which of all possible rearrangements of the pairs yields
     the most compact pair-factored result.

     'load(scifac)' loads this function.  'demo(scifac)' shows a
     demonstration of this function.


File: maxima.info,  Node: Package sqdnst,  Prev: Package scifac,  Up: simplification

69.8 Package sqdnst
===================

 -- Function: sqrtdenest (<expr>)

     Denests 'sqrt' of simple, numerical, binomial surds, where
     possible.  E.g.

          (%i1) load (sqdnst)$
          (%i2) sqrt(sqrt(3)/2+1)/sqrt(11*sqrt(2)-12);
                                              sqrt(3)
                                         sqrt(------- + 1)
                                                 2
          (%o2)                        ---------------------
                                       sqrt(11 sqrt(2) - 12)
          (%i3) sqrtdenest(%);
                                            sqrt(3)   1
                                            ------- + -
                                               2      2
          (%o3)                            -------------
                                              1/4    3/4
                                           3 2    - 2

     Sometimes it helps to apply 'sqrtdenest' more than once, on such as
     '(19601-13860 sqrt(2))^(7/4)'.

     'load(sqdnst)' loads this function.


File: maxima.info,  Node: solve_rec,  Next: stats,  Prev: simplification,  Up: Top

70 solve_rec
************

* Menu:

* Introduction to solve_rec::
* Functions and Variables for solve_rec::


File: maxima.info,  Node: Introduction to solve_rec,  Next: Functions and Variables for solve_rec,  Prev: solve_rec,  Up: solve_rec

70.1 Introduction to solve_rec
==============================

'solve_rec' is a package for solving linear recurrences with polynomial
coefficients.

A demo is available with 'demo(solve_rec)'.

Example:

     (%i1) load("solve_rec")$
     (%i2) solve_rec((n+4)*s[n+2] + s[n+1] - (n+1)*s[n], s[n]);
                                         n
                      %k  (2 n + 3) (- 1)          %k
                        1                            2
     (%o2)       s  = -------------------- + ---------------
                  n     (n + 1) (n + 2)      (n + 1) (n + 2)


File: maxima.info,  Node: Functions and Variables for solve_rec,  Prev: Introduction to solve_rec,  Up: solve_rec

70.2 Functions and Variables for solve_rec
==========================================

 -- Function: reduce_order (<rec>, <sol>, <var>)

     Reduces the order of linear recurrence <rec> when a particular
     solution <sol> is known.  The reduced reccurence can be used to get
     other solutions.

     Example:

          (%i3) rec: x[n+2] = x[n+1] + x[n]/n;
                                                x
                                                 n
          (%o3)               x      = x      + --
                               n + 2    n + 1   n
          (%i4) solve_rec(rec, x[n]);
          WARNING: found some hypergeometrical solutions!
          (%o4)                    x  = %k  n
                                    n     1
          (%i5) reduce_order(rec, n, x[n]);
          (%t5)                    x  = n %z
                                    n       n

                                     n - 1
                                     ====
                                     \
          (%t6)                %z  =  >     %u
                                 n   /        %j
                                     ====
                                     %j = 0

          (%o6)             (- n - 2) %u     - %u
                                        n + 1     n
          (%i6) solve_rec((n+2)*%u[n+1] + %u[n], %u[n]);
                                               n
                                      %k  (- 1)
                                        1
          (%o6)                 %u  = ----------
                                  n    (n + 1)!

          So the general solution is

                       n - 1
                       ====        j
                       \      (- 1)
                 %k  n  >    -------- + %k  n
                   2   /     (j + 1)!     1
                       ====
                       j = 0

 -- Option variable: simplify_products
     Default value: 'true'

     If 'simplify_products' is 'true', 'solve_rec' will try to simplify
     products in result.

     See also: 'solve_rec'.

 -- Function: simplify_sum (<expr>)

     Tries to simplify all sums appearing in <expr> to a closed form.

     To use this function first load the 'simplify_sum' package with
     'load(simplify_sum)'.

     Example:

          (%i1) load("simplify_sum")$
          (%i2) sum(binom(n+k,k)/2^k, k, 0, n)
                                       + sum(binom(2*n, 2*k), k, 0, n);
                   n                            n
                  ====                         ====
                  \      binomial(n + k, k)    \
          (%o2)    >     ------------------ +   >    binomial(2 n, 2 k)
                  /               k            /
                  ====           2             ====
                  k = 0                        k = 0
          (%i3) simplify_sum(%);
                                         n
                                        4     n
          (%o3)                         -- + 2
                                        2

 -- Function: solve_rec (<eqn>, <var>, [<init>])

     Solves for hypergeometrical solutions to linear recurrence <eqn>
     with polynomials coefficient in variable <var>.  Optional arguments
     <init> are initial conditions.

     'solve_rec' can solve linear recurrences with constant
     coefficients, finds hypergeometrical solutions to homogeneous
     linear recurrences with polynomial coefficients, rational solutions
     to linear recurrences with polynomial coefficients and can solve
     Ricatti type recurrences.

     Note that the running time of the algorithm used to find
     hypergeometrical solutions is exponential in the degree of the
     leading and trailing coefficient.

     To use this function first load the 'solve_rec' package with
     'load(solve_rec);'.

     Example of linear recurrence with constant coefficients:

          (%i2) solve_rec(a[n]=a[n-1]+a[n-2]+n/2^n, a[n]);
                                  n          n
                     (sqrt(5) - 1)  %k  (- 1)
                                      1           n
          (%o2) a  = ------------------------- - ----
                 n               n                  n
                                2                5 2
                                                          n
                                             (sqrt(5) + 1)  %k
                                                              2    2
                                           + ------------------ - ----
                                                      n              n
                                                     2            5 2

     Example of linear recurrence with polynomial coefficients:

          (%i7) 2*x*(x+1)*y[x] - (x^2+3*x-2)*y[x+1] + (x-1)*y[x+2];
                                   2
          (%o7) (x - 1) y      - (x  + 3 x - 2) y      + 2 x (x + 1) y
                         x + 2                   x + 1                x
          (%i8) solve_rec(%, y[x], y[1]=1, y[3]=3);
                                        x
                                     3 2    x!
          (%o9)                 y  = ---- - --
                                 x    4     2

     Example of Ricatti type recurrence:

          (%i2) x*y[x+1]*y[x] - y[x+1]/(x+2) + y[x]/(x-1) = 0;
                                      y         y
                                       x + 1     x
          (%o2)         x y  y      - ------ + ----- = 0
                           x  x + 1   x + 2    x - 1
          (%i3) solve_rec(%, y[x], y[3]=5)$
          (%i4) ratsimp(minfactorial(factcomb(%)));
                                             3
                                         30 x  - 30 x
          (%o4) y  = - -------------------------------------------------
                 x        6      5       4       3       2
                       5 x  - 3 x  - 25 x  + 15 x  + 20 x  - 12 x - 1584

     See also: 'solve_rec_rat', 'simplify_products', and
     'product_use_gamma'.

 -- Function: solve_rec_rat (<eqn>, <var>, [<init>])

     Solves for rational solutions to linear recurrences.  See solve_rec
     for description of arguments.

     To use this function first load the 'solve_rec' package with
     'load(solve_rec);'.

     Example:

          (%i1) (x+4)*a[x+3] + (x+3)*a[x+2] - x*a[x+1] + (x^2-1)*a[x];
          (%o1)  (x + 4) a      + (x + 3) a      - x a
                          x + 3            x + 2      x + 1
                                                             2
                                                         + (x  - 1) a
                                                                      x
          (%i2) solve_rec_rat(% = (x+2)/(x+1), a[x]);
                                 1
          (%o2)      a  = ---------------
                      x   (x - 1) (x + 1)

     See also: 'solve_rec'.

 -- Option variable: product_use_gamma
     Default value: 'true'

     When simplifying products, 'solve_rec' introduces gamma function
     into the expression if 'product_use_gamma' is 'true'.

     See also: 'simplify_products', 'solve_rec'.

 -- Function: summand_to_rec (<summand>, <k>, <n>)
 -- Function: summand_to_rec (<summand>, [<k>, <lo>, <hi>], <n>)

     Returns the recurrence sattisfied by the sum

               hi
              ====
              \
               >     summand
              /
              ====
            k = lo

     where summand is hypergeometrical in <k> and <n>.  If <lo> and <hi>
     are omited, they are assumed to be 'lo = -inf' and 'hi = inf'.

     To use this function first load the 'simplify_sum' package with
     'load(simplify_sum)'.

     Example:

          (%i1) load("simplify_sum")$
          (%i2) summand: binom(n,k);
          (%o2)                           binomial(n, k)
          (%i3) summand_to_rec(summand,k,n);
          (%o3)                      2 sm  - sm      = 0
                                         n     n + 1
          (%i7) summand: binom(n, k)/(k+1);
                                          binomial(n, k)
          (%o7)                           --------------
                                              k + 1
          (%i8) summand_to_rec(summand, [k, 0, n], n);
          (%o8)               2 (n + 1) sm  - (n + 2) sm      = - 1
                                          n             n + 1


File: maxima.info,  Node: stats,  Next: stirling,  Prev: solve_rec,  Up: Top

71 stats
********

* Menu:

* Introduction to stats::
* Functions and Variables for inference_result::
* Functions and Variables for stats::
* Functions and Variables for special distributions::


File: maxima.info,  Node: Introduction to stats,  Next: Functions and Variables for inference_result,  Prev: Top,  Up: Top

71.1 Introduction to stats
==========================

Package 'stats' contains a set of classical statistical inference and
hypothesis testing procedures.

All these functions return an 'inference_result' Maxima object which
contains the necessary results for population inferences and decision
making.

Global variable 'stats_numer' controls whether results are given in
floating point or symbolic and rational format; its default value is
'true' and results are returned in floating point format.

Package 'descriptive' contains some utilities to manipulate data
structures (lists and matrices); for example, to extract subsamples.  It
also contains some examples on how to use package 'numericalio' to read
data from plain text files.  See 'descriptive' and 'numericalio' for
more details.

Package 'stats' loads packages 'descriptive', 'distrib' and
'inference_result'.

For comments, bugs or suggestions, please contact the author at

<'mario AT edu DOT xunta DOT es'>.


File: maxima.info,  Node: Functions and Variables for inference_result,  Next: Functions and Variables for stats,  Prev: Introduction to stats,  Up: Top

71.2 Functions and Variables for inference_result
=================================================

 -- Function: inference_result (<title>, <values>, <numbers>)

     Constructs an 'inference_result' object of the type returned by the
     stats functions.  Argument <title> is a string with the name of the
     procedure; <values> is a list with elements of the form 'symbol =
     value' and <numbers> is a list with positive integer numbers
     ranging from one to 'length(<values>)', indicating which values
     will be shown by default.

     Example:

     This is a simple example showing results concerning a rectangle.
     The title of this object is the string '"Rectangle"', it stores
     five results, named ''base', ''height', ''diagonal', ''area', and
     ''perimeter', but only the first, second, fifth, and fourth will be
     displayed.  The ''diagonal' is stored in this object, but it is not
     displayed; to access its value, make use of function
     'take_inference'.

          (%i1) load(inference_result)$
          (%i2) b: 3$ h: 2$
          (%i3) inference_result("Rectangle",
                                  ['base=b,
                                   'height=h,
                                   'diagonal=sqrt(b^2+h^2),
                                   'area=b*h,
                                   'perimeter=2*(b+h)],
                                  [1,2,5,4] );
                                  |   Rectangle
                                  |
                                  |    base = 3
                                  |
          (%o3)                   |   height = 2
                                  |
                                  | perimeter = 10
                                  |
                                  |    area = 6
          (%i4) take_inference('diagonal,%);
          (%o4)                        sqrt(13)

     See also 'take_inference'.

 -- Function: inferencep (<obj>)

     Returns 'true' or 'false', depending on whether <obj> is an
     'inference_result' object or not.

 -- Function: items_inference (<obj>)

     Returns a list with the names of the items stored in <obj>, which
     must be an 'inference_result' object.

     Example:

     The 'inference_result' object stores two values, named ''pi' and
     ''e', but only the second is displayed.  The 'items_inference'
     function returns the names of all items, no matter they are
     displayed or not.

          (%i1) load(inference_result)$
          (%i2) inference_result("Hi", ['pi=%pi,'e=%e],[2]);
                                      |   Hi
          (%o2)                       |
                                      | e = %e
          (%i3) items_inference(%);
          (%o3)                        [pi, e]

 -- Function: take_inference (<n>, <obj>)
 -- Function: take_inference (<name>, <obj>)
 -- Function: take_inference (<list>, <obj>)

     Returns the <n>-th value stored in <obj> if <n> is a positive
     integer, or the item named <name> if this is the name of an item.
     If the first argument is a list of numbers and/or symbols, function
     'take_inference' returns a list with the corresponding results.

     Example:

     Given an 'inference_result' object, function 'take_inference' is
     called in order to extract some information stored in it.

          (%i1) load(inference_result)$
          (%i2) b: 3$ h: 2$
          (%i3) sol: inference_result("Rectangle",
                                      ['base=b,
                                       'height=h,
                                       'diagonal=sqrt(b^2+h^2),
                                       'area=b*h,
                                       'perimeter=2*(b+h)],
                                      [1,2,5,4] );
                                  |   Rectangle
                                  |
                                  |    base = 3
                                  |
          (%o3)                   |   height = 2
                                  |
                                  | perimeter = 10
                                  |
                                  |    area = 6
          (%i4) take_inference('base,sol);
          (%o4)                           3
          (%i5) take_inference(5,sol);
          (%o5)                          10
          (%i6) take_inference([1,'diagonal],sol);
          (%o6)                     [3, sqrt(13)]
          (%i7) take_inference(items_inference(sol),sol);
          (%o7)                [3, 2, sqrt(13), 6, 10]

     See also 'inference_result' and 'take_inference'.


File: maxima.info,  Node: Functions and Variables for stats,  Next: Functions and Variables for special distributions,  Prev: Functions and Variables for inference_result,  Up: Top

71.3 Functions and Variables for stats
======================================

 -- Option variable: stats_numer
     Default value: 'true'

     If 'stats_numer' is 'true', inference statistical functions return
     their results in floating point numbers.  If it is 'false', results
     are given in symbolic and rational format.

 -- Function: test_mean (<x>)
 -- Function: test_mean (<x>, <options> ...)

     This is the mean <t>-test.  Argument <x> is a list or a column
     matrix containing an one dimensional sample.  It also performs an
     asymptotic test based on the Central Limit Theorem if option
     ''asymptotic' is 'true'.

     Options:

        * ''mean', default '0', is the mean value to be checked.

        * ''alternative', default ''twosided', is the alternative
          hypothesis; valid values are: ''twosided', ''greater' and
          ''less'.

        * ''dev', default ''unknown', this is the value of the standard
          deviation when it is known; valid values are: ''unknown' or a
          positive expression.

        * ''conflevel', default '95/100', confidence level for the
          confidence interval; it must be an expression which takes a
          value in (0,1).

        * ''asymptotic', default 'false', indicates whether it performs
          an exact <t>-test or an asymptotic one based on the Central
          Limit Theorem; valid values are 'true' and 'false'.

     The output of function 'test_mean' is an 'inference_result' Maxima
     object showing the following results:

       1. ''mean_estimate': the sample mean.

       2. ''conf_level': confidence level selected by the user.

       3. ''conf_interval': confidence interval for the population mean.

       4. ''method': inference procedure.

       5. ''hypotheses': null and alternative hypotheses to be tested.

       6. ''statistic': value of the sample statistic used for testing
          the null hypothesis.

       7. ''distribution': distribution of the sample statistic,
          together with its parameter(s).

       8. ''p_value': p-value of the test.

     Examples:

     Performs an exact <t>-test with unknown variance.  The null
     hypothesis is H_0: mean=50 against the one sided alternative H_1:
     mean<50; according to the results, the p-value is too great, there
     are no evidence for rejecting H_0.

          (%i1) load("stats")$
          (%i2) data: [78,64,35,45,45,75,43,74,42,42]$
          (%i3) test_mean(data,'conflevel=0.9,'alternative='less,'mean=50);
                    |                 MEAN TEST
                    |
                    |            mean_estimate = 54.3
                    |
                    |              conf_level = 0.9
                    |
                    | conf_interval = [minf, 61.51314273502712]
                    |
          (%o3)     |  method = Exact t-test. Unknown variance.
                    |
                    | hypotheses = H0: mean = 50 , H1: mean < 50
                    |
                    |       statistic = .8244705235071678
                    |
                    |       distribution = [student_t, 9]
                    |
                    |        p_value = .7845100411786889

     This time Maxima performs an asymptotic test, based on the Central
     Limit Theorem.  The null hypothesis is H_0: equal(mean, 50) against
     the two sided alternative H_1: not equal(mean, 50); according to
     the results, the p-value is very small, H_0 should be rejected in
     favor of the alternative H_1.  Note that, as indicated by the
     'Method' component, this procedure should be applied to large
     samples.

          (%i1) load("stats")$
          (%i2) test_mean([36,118,52,87,35,256,56,178,57,57,89,34,25,98,35,
                        98,41,45,198,54,79,63,35,45,44,75,42,75,45,45,
                        45,51,123,54,151],
                        'asymptotic=true,'mean=50);
                    |                       MEAN TEST
                    |
                    |           mean_estimate = 74.88571428571429
                    |
                    |                   conf_level = 0.95
                    |
                    | conf_interval = [57.72848600856194, 92.04294256286663]
                    |
          (%o2)     |    method = Large sample z-test. Unknown variance.
                    |
                    |       hypotheses = H0: mean = 50 , H1: mean # 50
                    |
                    |             statistic = 2.842831192874313
                    |
                    |             distribution = [normal, 0, 1]
                    |
                    |             p_value = .004471474652002261

 -- Function: test_means_difference (<x1>, <x2>)
 -- Function: test_means_difference (<x1>, <x2>, <options> ...)

     This is the difference of means <t>-test for two samples.
     Arguments <x1> and <x2> are lists or column matrices containing two
     independent samples.  In case of different unknown variances (see
     options ''dev1', ''dev2' and ''varequal' bellow), the degrees of
     freedom are computed by means of the Welch approximation.  It also
     performs an asymptotic test based on the Central Limit Theorem if
     option ''asymptotic' is set to 'true'.

     Options:

        * 
        * ''alternative', default ''twosided', is the alternative
          hypothesis; valid values are: ''twosided', ''greater' and
          ''less'.

        * ''dev1', default ''unknown', this is the value of the standard
          deviation of the <x1> sample when it is known; valid values
          are: ''unknown' or a positive expression.

        * ''dev2', default ''unknown', this is the value of the standard
          deviation of the <x2> sample when it is known; valid values
          are: ''unknown' or a positive expression.

        * ''varequal', default 'false', whether variances should be
          considered to be equal or not; this option takes effect only
          when ''dev1' and/or ''dev2' are ''unknown'.

        * ''conflevel', default '95/100', confidence level for the
          confidence interval; it must be an expression which takes a
          value in (0,1).

        * ''asymptotic', default 'false', indicates whether it performs
          an exact <t>-test or an asymptotic one based on the Central
          Limit Theorem; valid values are 'true' and 'false'.

     The output of function 'test_means_difference' is an
     'inference_result' Maxima object showing the following results:

       1. ''diff_estimate': the difference of means estimate.

       2. ''conf_level': confidence level selected by the user.

       3. ''conf_interval': confidence interval for the difference of
          means.

       4. ''method': inference procedure.

       5. ''hypotheses': null and alternative hypotheses to be tested.

       6. ''statistic': value of the sample statistic used for testing
          the null hypothesis.

       7. ''distribution': distribution of the sample statistic,
          together with its parameter(s).

       8. ''p_value': p-value of the test.

     Examples:

     The equality of means is tested with two small samples <x> and <y>,
     against the alternative H_1: m_1>m_2, being m_1 and m_2 the
     populations means; variances are unknown and supposed to be
     different.

          (%i1) load("stats")$
          (%i2) x: [20.4,62.5,61.3,44.2,11.1,23.7]$
          (%i3) y: [1.2,6.9,38.7,20.4,17.2]$
          (%i4) test_means_difference(x,y,'alternative='greater);
                      |              DIFFERENCE OF MEANS TEST
                      |
                      |         diff_estimate = 20.31999999999999
                      |
                      |                 conf_level = 0.95
                      |
                      |    conf_interval = [- .04597417812882298, inf]
                      |
          (%o4)       |        method = Exact t-test. Welch approx.
                      |
                      | hypotheses = H0: mean1 = mean2 , H1: mean1 > mean2
                      |
                      |           statistic = 1.838004300728477
                      |
                      |    distribution = [student_t, 8.62758740184604]
                      |
                      |            p_value = .05032746527991905

     The same test as before, but now variances are supposed to be
     equal.

          (%i1) load("stats")$
          (%i2) x: [20.4,62.5,61.3,44.2,11.1,23.7]$
          (%i3) y: matrix([1.2],[6.9],[38.7],[20.4],[17.2])$
          (%i4) test_means_difference(x,y,'alternative='greater,
                                                           'varequal=true);
                      |              DIFFERENCE OF MEANS TEST
                      |
                      |         diff_estimate = 20.31999999999999
                      |
                      |                 conf_level = 0.95
                      |
                      |     conf_interval = [- .7722627696897568, inf]
                      |
          (%o4)       |   method = Exact t-test. Unknown equal variances
                      |
                      | hypotheses = H0: mean1 = mean2 , H1: mean1 > mean2
                      |
                      |           statistic = 1.765996124515009
                      |
                      |           distribution = [student_t, 9]
                      |
                      |            p_value = .05560320992529344

 -- Function: test_variance (<x>)
 -- Function: test_variance (<x>, <options>, ...)

     This is the variance <chi^2>-test.  Argument <x> is a list or a
     column matrix containing an one dimensional sample taken from a
     normal population.

     Options:

        * ''mean', default ''unknown', is the population's mean, when it
          is known.

        * ''alternative', default ''twosided', is the alternative
          hypothesis; valid values are: ''twosided', ''greater' and
          ''less'.

        * ''variance', default '1', this is the variance value
          (positive) to be checked.

        * ''conflevel', default '95/100', confidence level for the
          confidence interval; it must be an expression which takes a
          value in (0,1).

     The output of function 'test_variance' is an 'inference_result'
     Maxima object showing the following results:

       1. ''var_estimate': the sample variance.

       2. ''conf_level': confidence level selected by the user.

       3. ''conf_interval': confidence interval for the population
          variance.

       4. ''method': inference procedure.

       5. ''hypotheses': null and alternative hypotheses to be tested.

       6. ''statistic': value of the sample statistic used for testing
          the null hypothesis.

       7. ''distribution': distribution of the sample statistic,
          together with its parameter.

       8. ''p_value': p-value of the test.

     Examples:

     It is tested whether the variance of a population with unknown mean
     is equal to or greater than 200.

          (%i1) load("stats")$
          (%i2) x: [203,229,215,220,223,233,208,228,209]$
          (%i3) test_variance(x,'alternative='greater,'variance=200);
                       |                  VARIANCE TEST
                       |
                       |              var_estimate = 110.75
                       |
                       |                conf_level = 0.95
                       |
                       |     conf_interval = [57.13433376937479, inf]
                       |
          (%o3)        | method = Variance Chi-square test. Unknown mean.
                       |
                       |    hypotheses = H0: var = 200 , H1: var > 200
                       |
                       |                 statistic = 4.43
                       |
                       |             distribution = [chi2, 8]
                       |
                       |           p_value = .8163948512777689

 -- Function: test_variance_ratio (<x1>, <x2>)
 -- Function: test_variance_ratio (<x1>, <x2>, <options> ...)

     This is the variance ratio <F>-test for two normal populations.
     Arguments <x1> and <x2> are lists or column matrices containing two
     independent samples.

     Options:

        * ''alternative', default ''twosided', is the alternative
          hypothesis; valid values are: ''twosided', ''greater' and
          ''less'.

        * ''mean1', default ''unknown', when it is known, this is the
          mean of the population from which <x1> was taken.

        * ''mean2', default ''unknown', when it is known, this is the
          mean of the population from which <x2> was taken.

        * ''conflevel', default '95/100', confidence level for the
          confidence interval of the ratio; it must be an expression
          which takes a value in (0,1).

     The output of function 'test_variance_ratio' is an
     'inference_result' Maxima object showing the following results:

       1. ''ratio_estimate': the sample variance ratio.

       2. ''conf_level': confidence level selected by the user.

       3. ''conf_interval': confidence interval for the variance ratio.

       4. ''method': inference procedure.

       5. ''hypotheses': null and alternative hypotheses to be tested.

       6. ''statistic': value of the sample statistic used for testing
          the null hypothesis.

       7. ''distribution': distribution of the sample statistic,
          together with its parameters.

       8. ''p_value': p-value of the test.

     Examples:

     The equality of the variances of two normal populations is checked
     against the alternative that the first is greater than the second.

          (%i1) load("stats")$
          (%i2) x: [20.4,62.5,61.3,44.2,11.1,23.7]$
          (%i3) y: [1.2,6.9,38.7,20.4,17.2]$
          (%i4) test_variance_ratio(x,y,'alternative='greater);
                        |              VARIANCE RATIO TEST
                        |
                        |       ratio_estimate = 2.316933391522034
                        |
                        |               conf_level = 0.95
                        |
                        |    conf_interval = [.3703504689507268, inf]
                        |
          (%o4)         | method = Variance ratio F-test. Unknown means.
                        |
                        | hypotheses = H0: var1 = var2 , H1: var1 > var2
                        |
                        |         statistic = 2.316933391522034
                        |
                        |            distribution = [f, 5, 4]
                        |
                        |          p_value = .2179269692254457

 -- Function: test_proportion (<x>, <n>)
 -- Function: test_proportion (<x>, <n>, <options> ...)

     Inferences on a proportion.  Argument <x> is the number of
     successes in <n> trials in a Bernoulli experiment with unknown
     probability.

     Options:

        * ''proportion', default '1/2', is the value of the proportion
          to be checked.

        * ''alternative', default ''twosided', is the alternative
          hypothesis; valid values are: ''twosided', ''greater' and
          ''less'.

        * ''conflevel', default '95/100', confidence level for the
          confidence interval; it must be an expression which takes a
          value in (0,1).

        * ''asymptotic', default 'false', indicates whether it performs
          an exact test based on the binomial distribution, or an
          asymptotic one based on the Central Limit Theorem; valid
          values are 'true' and 'false'.

        * ''correct', default 'true', indicates whether Yates correction
          is applied or not.

     The output of function 'test_proportion' is an 'inference_result'
     Maxima object showing the following results:

       1. ''sample_proportion': the sample proportion.

       2. ''conf_level': confidence level selected by the user.

       3. ''conf_interval': Wilson confidence interval for the
          proportion.

       4. ''method': inference procedure.

       5. ''hypotheses': null and alternative hypotheses to be tested.

       6. ''statistic': value of the sample statistic used for testing
          the null hypothesis.

       7. ''distribution': distribution of the sample statistic,
          together with its parameters.

       8. ''p_value': p-value of the test.

     Examples:

     Performs an exact test.  The null hypothesis is H_0: p=1/2 against
     the one sided alternative H_1: p<1/2.

          (%i1) load("stats")$
          (%i2) test_proportion(45, 103, alternative = less);
                   |            PROPORTION TEST
                   |
                   | sample_proportion = .4368932038834951
                   |
                   |           conf_level = 0.95
                   |
                   | conf_interval = [0, 0.522714149150231]
                   |
          (%o2)    |     method = Exact binomial test.
                   |
                   | hypotheses = H0: p = 0.5 , H1: p < 0.5
                   |
                   |             statistic = 45
                   |
                   |  distribution = [binomial, 103, 0.5]
                   |
                   |      p_value = .1184509388901454

     A two sided asymptotic test.  Confidence level is 99/100.

          (%i1) load("stats")$
          (%i2) fpprintprec:7$
          (%i3) test_proportion(45, 103,
                            conflevel = 99/100, asymptotic=true);
                |                 PROPORTION TEST
                |
                |           sample_proportion = .43689
                |
                |                conf_level = 0.99
                |
                |        conf_interval = [.31422, .56749]
                |
          (%o3) | method = Asympthotic test with Yates correction.
                |
                |     hypotheses = H0: p = 0.5 , H1: p # 0.5
                |
                |               statistic = .43689
                |
                |      distribution = [normal, 0.5, .048872]
                |
                |                p_value = .19662

 -- Function: test_proportions_difference (<x1>, <n1>, <x2>, <n2>)
 -- Function: test_proportions_difference (<x1>, <n1>, <x2>, <n2>,
          <options> ...)

     Inferences on the difference of two proportions.  Argument <x1> is
     the number of successes in <n1> trials in a Bernoulli experiment in
     the first population, and <x2> and <n2> are the corresponding
     values in the second population.  Samples are independent and the
     test is asymptotic.

     Options:

        * ''alternative', default ''twosided', is the alternative
          hypothesis; valid values are: ''twosided' ('p1 # p2'),
          ''greater' ('p1 > p2') and ''less' ('p1 < p2').

        * ''conflevel', default '95/100', confidence level for the
          confidence interval; it must be an expression which takes a
          value in (0,1).

        * ''correct', default 'true', indicates whether Yates correction
          is applied or not.

     The output of function 'test_proportions_difference' is an
     'inference_result' Maxima object showing the following results:

       1. ''proportions': list with the two sample proportions.

       2. ''conf_level': confidence level selected by the user.

       3. ''conf_interval': Confidence interval for the difference of
          proportions 'p1 - p2'.

       4. ''method': inference procedure and warning message in case of
          any of the samples sizes is less than 10.

       5. ''hypotheses': null and alternative hypotheses to be tested.

       6. ''statistic': value of the sample statistic used for testing
          the null hypothesis.

       7. ''distribution': distribution of the sample statistic,
          together with its parameters.

       8. ''p_value': p-value of the test.

     Examples:

     A machine produced 10 defective articles in a batch of 250.  After
     some maintenance work, it produces 4 defective in a batch of 150.
     In order to know if the machine has improved, we test the null
     hypothesis 'H0:p1=p2', against the alternative 'H0:p1>p2', where
     'p1' and 'p2' are the probabilities for one produced article to be
     defective before and after maintenance.  According to the p value,
     there is not enough evidence to accept the alternative.

          (%i1) load("stats")$
          (%i2) fpprintprec:7$
          (%i3) test_proportions_difference(10, 250, 4, 150,
                                          alternative = greater);
                |       DIFFERENCE OF PROPORTIONS TEST
                |
                |       proportions = [0.04, .02666667]
                |
                |              conf_level = 0.95
                |
                |      conf_interval = [- .02172761, 1]
                |
          (%o3) | method = Asymptotic test. Yates correction.
                |
                |   hypotheses = H0: p1 = p2 , H1: p1 > p2
                |
                |            statistic = .01333333
                |
                |    distribution = [normal, 0, .01898069]
                |
                |             p_value = .2411936

     Exact standard deviation of the asymptotic normal distribution when
     the data are unknown.

          (%i1) load("stats")$
          (%i2) stats_numer: false$
          (%i3) sol: test_proportions_difference(x1,n1,x2,n2)$
          (%i4) last(take_inference('distribution,sol));
                         1    1                  x2 + x1
                        (-- + --) (x2 + x1) (1 - -------)
                         n2   n1                 n2 + n1
          (%o4)    sqrt(---------------------------------)
                                     n2 + n1

 -- Function: test_sign (<x>)
 -- Function: test_sign (<x>, <options> ...)

     This is the non parametric sign test for the median of a continuous
     population.  Argument <x> is a list or a column matrix containing
     an one dimensional sample.

     Options:

        * ''alternative', default ''twosided', is the alternative
          hypothesis; valid values are: ''twosided', ''greater' and
          ''less'.

        * ''median', default '0', is the median value to be checked.

     The output of function 'test_sign' is an 'inference_result' Maxima
     object showing the following results:

       1. ''med_estimate': the sample median.

       2. ''method': inference procedure.

       3. ''hypotheses': null and alternative hypotheses to be tested.

       4. ''statistic': value of the sample statistic used for testing
          the null hypothesis.

       5. ''distribution': distribution of the sample statistic,
          together with its parameter(s).

       6. ''p_value': p-value of the test.

     Examples:

     Checks whether the population from which the sample was taken has
     median 6, against the alternative H_1: median > 6.

          (%i1) load("stats")$
          (%i2) x: [2,0.1,7,1.8,4,2.3,5.6,7.4,5.1,6.1,6]$
          (%i3) test_sign(x,'median=6,'alternative='greater);
                         |                  SIGN TEST
                         |
                         |              med_estimate = 5.1
                         |
                         |      method = Non parametric sign test.
                         |
          (%o3)          | hypotheses = H0: median = 6 , H1: median > 6
                         |
                         |                statistic = 7
                         |
                         |      distribution = [binomial, 10, 0.5]
                         |
                         |         p_value = .05468749999999989

 -- Function: test_signed_rank (<x>)
 -- Function: test_signed_rank (<x>, <options> ...)

     This is the Wilcoxon signed rank test to make inferences about the
     median of a continuous population.  Argument <x> is a list or a
     column matrix containing an one dimensional sample.  Performs
     normal approximation if the sample size is greater than 20, or if
     there are zeroes or ties.

     See also 'pdf_rank_test' and 'cdf_rank_test'.

     Options:

        * ''median', default '0', is the median value to be checked.

        * ''alternative', default ''twosided', is the alternative
          hypothesis; valid values are: ''twosided', ''greater' and
          ''less'.

     The output of function 'test_signed_rank' is an 'inference_result'
     Maxima object with the following results:

       1. ''med_estimate': the sample median.

       2. ''method': inference procedure.

       3. ''hypotheses': null and alternative hypotheses to be tested.

       4. ''statistic': value of the sample statistic used for testing
          the null hypothesis.

       5. ''distribution': distribution of the sample statistic,
          together with its parameter(s).

       6. ''p_value': p-value of the test.

     Examples:

     Checks the null hypothesis H_0: median = 15 against the alternative
     H_1: median > 15.  This is an exact test, since there are no ties.

          (%i1) load("stats")$
          (%i2) x: [17.1,15.9,13.7,13.4,15.5,17.6]$
          (%i3) test_signed_rank(x,median=15,alternative=greater);
                           |             SIGNED RANK TEST
                           |
                           |           med_estimate = 15.7
                           |
                           |           method = Exact test
                           |
          (%o3)            | hypotheses = H0: med = 15 , H1: med > 15
                           |
                           |              statistic = 14
                           |
                           |     distribution = [signed_rank, 6]
                           |
                           |            p_value = 0.28125

     Checks the null hypothesis H_0: equal(median, 2.5) against the
     alternative H_1: not equal(median, 2.5).  This is an approximated
     test, since there are ties.

          (%i1) load("stats")$
          (%i2) y:[1.9,2.3,2.6,1.9,1.6,3.3,4.2,4,2.4,2.9,1.5,3,2.9,4.2,3.1]$
          (%i3) test_signed_rank(y,median=2.5);
                       |                 SIGNED RANK TEST
                       |
                       |                med_estimate = 2.9
                       |
                       |          method = Asymptotic test. Ties
                       |
          (%o3)        |    hypotheses = H0: med = 2.5 , H1: med # 2.5
                       |
                       |                 statistic = 76.5
                       |
                       | distribution = [normal, 60.5, 17.58195097251724]
                       |
                       |           p_value = .3628097734643669

 -- Function: test_rank_sum (<x1>, <x2>)
 -- Function: test_rank_sum (<x1>, <x2>, <option>)

     This is the Wilcoxon-Mann-Whitney test for comparing the medians of
     two continuous populations.  The first two arguments <x1> and <x2>
     are lists or column matrices with the data of two independent
     samples.  Performs normal approximation if any of the sample sizes
     is greater than 10, or if there are ties.

     Option:

        * ''alternative', default ''twosided', is the alternative
          hypothesis; valid values are: ''twosided', ''greater' and
          ''less'.

     The output of function 'test_rank_sum' is an 'inference_result'
     Maxima object with the following results:

       1. ''method': inference procedure.

       2. ''hypotheses': null and alternative hypotheses to be tested.

       3. ''statistic': value of the sample statistic used for testing
          the null hypothesis.

       4. ''distribution': distribution of the sample statistic,
          together with its parameters.

       5. ''p_value': p-value of the test.

     Examples:

     Checks whether populations have similar medians.  Samples sizes are
     small and an exact test is made.

          (%i1) load("stats")$
          (%i2) x:[12,15,17,38,42,10,23,35,28]$
          (%i3) y:[21,18,25,14,52,65,40,43]$
          (%i4) test_rank_sum(x,y);
                        |                 RANK SUM TEST
                        |
                        |              method = Exact test
                        |
                        | hypotheses = H0: med1 = med2 , H1: med1 # med2
          (%o4)         |
                        |                 statistic = 22
                        |
                        |        distribution = [rank_sum, 9, 8]
                        |
                        |          p_value = .1995886466474702

     Now, with greater samples and ties, the procedure makes normal
     approximation.  The alternative hypothesis is H_1: median1 <
     median2.

          (%i1) load("stats")$
          (%i2) x: [39,42,35,13,10,23,15,20,17,27]$
          (%i3) y: [20,52,66,19,41,32,44,25,14,39,43,35,19,56,27,15]$
          (%i4) test_rank_sum(x,y,'alternative='less);
                       |                  RANK SUM TEST
                       |
                       |          method = Asymptotic test. Ties
                       |
                       |  hypotheses = H0: med1 = med2 , H1: med1 < med2
          (%o4)        |
                       |                 statistic = 48.5
                       |
                       | distribution = [normal, 79.5, 18.95419580097078]
                       |
                       |           p_value = .05096985666598441

 -- Function: test_normality (<x>)

     Shapiro-Wilk test for normality.  Argument <x> is a list of
     numbers, and sample size must be greater than 2 and less or equal
     than 5000, otherwise, function 'test_normality' signals an error
     message.

     Reference:

     [1] Algorithm AS R94, Applied Statistics (1995), vol.44, no.4,
     547-551

     The output of function 'test_normality' is an 'inference_result'
     Maxima object with the following results:

       1. ''statistic': value of the <W> statistic.

       2. ''p_value': p-value under normal assumption.

     Examples:

     Checks for the normality of a population, based on a sample of size
     9.

          (%i1) load("stats")$
          (%i2) x:[12,15,17,38,42,10,23,35,28]$
          (%i3) test_normality(x);
                                 |      SHAPIRO - WILK TEST
                                 |
          (%o3)                  | statistic = .9251055695162436
                                 |
                                 |  p_value = .4361763918860381

 -- Function: simple_linear_regression (<x>)
 -- Function: simple_linear_regression (<x> <option>)

     Simple linear regression, y_i=a+b x_i+e_i, where e_i are N(0,sigma)
     independent random variables.  Argument <x> must be a two column
     matrix or a list of pairs.

     Options:

        * ''conflevel', default '95/100', confidence level for the
          confidence interval; it must be an expression which takes a
          value in (0,1).

        * ''regressor', default ''x', name of the independent variable.

     The output of function 'simple_linear_regression' is an
     'inference_result' Maxima object with the following results:

       1. ''model': the fitted equation.  Useful to make new
          predictions.  See examples bellow.

       2. ''means': bivariate mean.

       3. ''variances': variances of both variables.

       4. ''correlation': correlation coefficient.

       5. ''adc': adjusted determination coefficient.

       6. ''a_estimation': estimation of parameter <a>.

       7. ''a_conf_int': confidence interval of parameter <a>.

       8. ''b_estimation': estimation of parameter <b>.

       9. ''b_conf_int': confidence interval of parameter <b>.

       10. ''hypotheses': null and alternative hypotheses about
          parameter <b>.

       11. ''statistic': value of the sample statistic used for testing
          the null hypothesis.

       12. ''distribution': distribution of the sample statistic,
          together with its parameter.

       13. ''p_value': p-value of the test about <b>.

       14. ''v_estimation': unbiased variance estimation, or residual
          variance.

       15. ''v_conf_int': variance confidence interval.

       16. ''cond_mean_conf_int': confidence interval for the
          conditioned mean.  See examples bellow.

       17. ''new_pred_conf_int': confidence interval for a new
          prediction.  See examples bellow.

       18. ''residuals': list of pairs (prediction, residual), ordered
          with respect to predictions.  This is useful for goodness of
          fit analysis.  See examples bellow.

     Only items 1, 4, 14, 9, 10, 11, 12, and 13 above, in this order,
     are shown by default.  The rest remain hidden until the user makes
     use of functions 'items_inference' and 'take_inference'.

     Example:

     Fitting a linear model to a bivariate sample.  Input '%i4' plots
     the sample together with the regression line; input '%i5' computes
     'y' given 'x=113'; the means and the confidence interval for a new
     prediction when 'x=113' are also calculated.

          (%i1) load("stats")$
          (%i2) s:[[125,140.7], [130,155.1], [135,160.3], [140,167.2],
                                                          [145,169.8]]$
          (%i3) z:simple_linear_regression(s,conflevel=0.99);
                     |               SIMPLE LINEAR REGRESSION
                     |
                     |   model = 1.405999999999985 x - 31.18999999999804
                     |
                     |           correlation = .9611685255255155
                     |
                     |           v_estimation = 13.57966666666665
                     |
          (%o3)      | b_conf_int = [.04469633662525263, 2.767303663374718]
                     |
                     |          hypotheses = H0: b = 0 ,H1: b # 0
                     |
                     |            statistic = 6.032686683658114
                     |
                     |            distribution = [student_t, 3]
                     |
                     |             p_value = 0.0038059549413203
          (%i4) plot2d([[discrete, s], take_inference(model,z)],
                  [x,120,150],
                  [gnuplot_curve_styles, ["with points","with lines"]] )$
          (%i5) take_inference(model,z), x=133;
          (%o5)                         155.808
          (%i6) take_inference(means,z);
          (%o6)                     [135.0, 158.62]
          (%i7) take_inference(new_pred_conf_int,z), x=133;
          (%o7)              [132.0728595995113, 179.5431404004887]


File: maxima.info,  Node: Functions and Variables for special distributions,  Prev: Functions and Variables for stats,  Up: Top

71.4 Functions and Variables for special distributions
======================================================

 -- Function: pdf_signed_rank (<x>, <n>)
     Probability density function of the exact distribution of the
     signed rank statistic.  Argument <x> is a real number and <n> a
     positive integer.

     See also 'test_signed_rank'.

 -- Function: cdf_signed_rank (<x>, <n>)
     Cumulative density function of the exact distribution of the signed
     rank statistic.  Argument <x> is a real number and <n> a positive
     integer.

     See also 'test_signed_rank'.

 -- Function: pdf_rank_sum (<x>, <n>, <m>)
     Probability density function of the exact distribution of the rank
     sum statistic.  Argument <x> is a real number and <n> and <m> are
     both positive integers.

     See also 'test_rank_sum'.

 -- Function: cdf_rank_sum (<x>, <n>, <m>)
     Cumulative density function of the exact distribution of the rank
     sum statistic.  Argument <x> is a real number and <n> and <m> are
     both positive integers.

     See also 'test_rank_sum'.


File: maxima.info,  Node: stirling,  Next: stringproc,  Prev: stats,  Up: Top

72 stirling
***********

* Menu:

* Functions and Variables for stirling::


File: maxima.info,  Node: Functions and Variables for stirling,  Prev: stirling,  Up: stirling

72.1 Functions and Variables for stirling
=========================================

 -- Function: stirling (<z>, <n>)
 -- Function: stirling (<z>, <n>, <pred>)

     Replace 'gamma(x)' with the O(1/x^(2n-1)) Stirling formula.  When
     <n> isn't a nonnegative integer, signal an error.  With the
     optional third argument 'pred', the Stirling formula is applied
     only when 'pred' is true.

     To use this function write first 'load(stirling)'.

     Reference: Abramowitz & Stegun, "Handbook of mathematical
     functions", 6.1.40.

     Examples:

          (%i1) load (stirling)$

          (%i2) stirling(gamma(%alpha+x)/gamma(x),1);
                 1/2 - x             x + %alpha - 1/2
          (%o2) x        (x + %alpha)
                                             1           1
                                      --------------- - ---- - %alpha
                                      12 (x + %alpha)   12 x
                                    %e
          (%i3) taylor(%,x,inf,1);
                              %alpha       2    %alpha
                    %alpha   x       %alpha  - x       %alpha
          (%o3)/T/ x       + -------------------------------- + . . .
                                           2 x
          (%i4) map('factor,%);
                                                 %alpha - 1
                   %alpha   (%alpha - 1) %alpha x
          (%o4)   x       + -------------------------------
                                            2

     The function 'stirling' knows the difference between the variable
     'gamma' and the function gamma:

          (%i5) stirling(gamma + gamma(x),0);
                                              x - 1/2   - x
          (%o5)    gamma + sqrt(2) sqrt(%pi) x        %e
          (%i6) stirling(gamma(y) + gamma(x),0);
                                   y - 1/2   - y
          (%o6) sqrt(2) sqrt(%pi) y        %e
                                                        x - 1/2   - x
                                   + sqrt(2) sqrt(%pi) x        %e

     To apply the Stirling formula only to terms that involve the
     variable 'k', use an optional third argument; for example

          (%i7) makegamma(pochhammer(a,k)/pochhammer(b,k));
                                gamma(b) gamma(k + a)
          (%o7)                 ---------------------
                                gamma(a) gamma(k + b)

          (%i8) stirling(%,1, lambda([s], not(freeof(k,s))));
                  b - a                 k + a - 1/2        - k - b + 1/2
                %e      gamma(b) (k + a)            (k + b)
          (%o8) --------------------------------------------------------
                                        gamma(a)

     The terms 'gamma(a)' and 'gamma(b)' are free of 'k', so the
     Stirling formula was not applied to these two terms.


File: maxima.info,  Node: stringproc,  Next: symmetries,  Prev: stirling,  Up: Top

73 stringproc
*************

* Menu:

* Einführung in die Verarbeitung von Zeichenketten::
* Ein- und Ausgabe::
* Schriftzeichen::
* Verarbeitung von Zeichenketten::
* Oktette und Werkzeuge für die Kryptographie::


File: maxima.info,  Node: Einführung in die Verarbeitung von Zeichenketten,  Next: Ein- und Ausgabe,  Prev: stringproc,  Up: stringproc

73.1 Einführung in die Verarbeitung von Zeichenketten
=====================================================

Das Paket 'stringproc' enthält Funktionen für die Verarbeitung von
Zeichen und Zeichenketten, was Formatierung, Zeichenkodierung und die
Behandlung von Datenströmen mit einschließt.  Abgerundet wird dieses
Paket durch Werkzeuge für die Kryptographie, wie z.B. Base64 und
Hashfunktionen.

Das Paket kann explizit durch 'load(stringproc)' geladen werden oder
automatisch durch die Verwendung einer der enthaltenden Funktionen.

Fragen und Fehlerberichte senden Sie bitte direkt an den Autor, dessen
e-Mail-Adresse durch den folgenden Befehl ausgegeben wird.

'printf(true, "~{~a~}@gmail.com", split(sdowncase("Volker van Nek")))$'

Eine Zeichenkette wird durch die Eingabe von z.B. '"Text"' erzeugt.  Ist
die Optionsvariable 'stringdisp' auf 'false' gesetzt, was standardmäßig
der Fall ist, werden die (doppelten) Anführungszeichen nicht mit
ausgegeben.  *note stringp:: ist ein Test, ob ein Objekt eine
Zeichenkette ist.

     (%i1) str: "Text";
     (%o1)                         Text
     (%i2) stringp(str);
     (%o2)                         true

Schriftzeichen werden in Maxima durch Zeichenketten der Länge 1
dargestellt.  *note charp:: ist hier der entsprechende Test.

     (%i1) char: "e";
     (%o1)                           e
     (%i2) charp(char);
     (%o2)                         true

Positionsindizes in Zeichenketten sind in Maxima genau so wie in Listen
1-indiziert, wodurch die folgende Übereinstimmung entsteht.

     (%i1) is(charat("Lisp",1) = charlist("Lisp")[1]);
     (%o1)                         true

Eine Zeichenkette kann Ausdrücke enthalten, die Maxima versteht.  Diese
können mit *note parse_string:: heraus gelöst werden.

     (%i1) map(parse_string, ["42" ,"sqrt(2)", "%pi"]);
     (%o1)                   [42, sqrt(2), %pi]
     (%i2) map('float, %);
     (%o2)        [42.0, 1.414213562373095, 3.141592653589793]

Zeichenketten können als Schriftzeichen und binär als Oktette
verarbeitet werden.  *note string_to_octets:: bzw.  *note
octets_to_string:: dienen hierbei zur Umrechnung.  Die verwendbaren
Kodierungen sind dabei von der Plattform, der Anwendung und vom unter
Maxima liegenden Lisp abhängig.  (Folgend Maxima in GNU/Linux,
kompiliert mit SBCL.)

     (%i1) obase: 16.$
     (%i2) string_to_octets("$£Euro", "cp1252");
     (%o2)                     [24, 0A3, 80]
     (%i3) string_to_octets("$£Euro", "utf-8");
     (%o3)               [24, 0C2, 0A3, 0E2, 82, 0AC]

Dem entsprechend können Zeichenketten an Datenströme für Schriftzeichen
und als Oktette an binäre Ströme weiter gegeben werden.  Das folgende
Beispiel zeigt das Schreiben und Lesen von Schriftzeichen in bzw.  aus
einer Datei.

*note openw:: gibt dabei einen Ausgabestrom in eine Datei zurück, mit
*note printf:: wird formatiert in diesen Strom geschrieben und mit z.B.
*note close:: werden die im Strom enthaltenden Zeichen in die Datei
geschrieben.

     (%i1) s: openw("file.txt");
     (%o1)                #<output stream file.txt>
     (%i2) printf(s, "~%~d ~f ~a ~a ~f ~e ~a~%",
     42, 1.234, sqrt(2), %pi, 1.0e-2, 1.0e-2, 1.0b-2)$
     (%i3) close(s)$

*note openr:: gibt folgend einen Eingabestrom aus der obigen Datei
zurück und *note readline:: die gelesene Zeile als Zeichenkette.  Mit
z.B. *note split:: oder *note tokens:: kann die Zeichenkette
anschließend in seine Bestandteile zerlegt werden.  *note parse_string::
verwandelt diese dann in auswertbare Ausdrücke.

     (%i4) s: openr("file.txt");
     (%o4)                 #<input stream file.txt>
     (%i5) readline(s);
     (%o5)          42 1.234 sqrt(2) %pi 0.01 1.0E-2 1.0b-2
     (%i6) map(parse_string, split(%));
     (%o6)       [42, 1.234, sqrt(2), %pi, 0.01, 0.01, 1.0b-2]
     (%i7) close(s)$


File: maxima.info,  Node: Ein- und Ausgabe,  Next: Schriftzeichen,  Prev: Einführung in die Verarbeitung von Zeichenketten,  Up: stringproc

73.2 Ein- und Ausgabe
=====================

Beispiel: Formatiertes Schreiben in eine Datei mit anschließendem Lesen.

     (%i1) s: openw("file.txt");
     (%o1)                      #<output stream file.txt>
     (%i2) control:
     "~2tAn atom: ~20t~a~%~2tand a list: ~20t~{~r ~}~%~2t\
     and an integer: ~20t~d~%"$
     (%i3) printf(s, control, 'true,[1,2,3],42)$
     (%o3)                                false
     (%i4) close(s);
     (%o4)                                true
     (%i5) s: openr("file.txt");
     (%o5)                      #<input stream file.txt>
     (%i6) while stringp(tmp:readline(s)) do print(tmp)$
       An atom:          true
       and a list:       one two three
       and an integer:   42
     (%i7) close(s)$

Beispiel: Lesen aus einer binären Datei.  Siehe *note readbyte::.

 -- Funktion: close (<stream>)

     Schließt den Datenstrom <stream> und gibt 'true' zurück, wenn
     <stream> noch geöffnet war.

 -- Funktion: flength (<stream>)

     <stream> muss ein geöffneter Datenstrom in eine oder aus einer
     Datei sein.  'flength' gibt dann die Anzahl der Bytes zurück, die
     sich momentan in dieser Datei befinden.

     Beispiel: Siehe *note writebyte:: .

 -- Funktion: flush_output (<stream>)

     Leert den Inhalt des Dateiausgabestroms <stream> in die Datei.

     Beispiel: Siehe *note writebyte:: .

 -- Function: fposition (<stream>)
 -- Function: fposition (<stream>, <pos>)

     Ohne das optionale Argument <pos> gibt 'fposition' die aktuelle
     Position in dem Datenstrom <stream> zurück.  Wird <pos> verwendet,
     legt 'fposition' diesen Wert als aktuelle Position in <stream>
     fest.  <pos> muss eine positive Zahl sein.

     Die Positionen in Datenströmen sind wie in Zeichenketten und Listen
     1-indiziert, d.h.  das erste Element in <stream> hat die Position
     1.

 -- Function: freshline ()
 -- Function: freshline (<stream>)

     Schreibt einen Zeilenumbruch in den Standardausgabestrom, falls die
     aktuelle Ausgabeposition nicht gerade der Anfang einer Zeile ist
     und gibt 'true' zurück.  Bei der Verwendung des optionalen
     Arguments <stream> wird der Umbruch in diesen Datenstrom
     geschrieben.

     Es gibt Situationen, in denen 'freshline()' nicht wie erwartet
     funktioniert.

     Siehe auch *note newline::.

 -- Funktion: get_output_stream_string (<stream>)

     Gibt Schriftzeichen, die aktuell in dem geöffneten Datenstrom
     <stream> enthalten sind, in einer Zeichenkette zurück.  Die zurück
     gegebenen Zeichen werden dabei aus dem Datenstrom entfernt.
     <stream> muss durch 'make_string_output_stream' erzeugt worden
     sein.

     Beispiel: Siehe *note make_string_output_stream:: .

 -- Funktion: make_string_input_stream (<string>)
 -- Funktion: make_string_input_stream (<string>, <start>)
 -- Funktion: make_string_input_stream (<string>, <start>, <end>)

     Gibt einen Datenstrom zurück, der Teile der Zeichenkette <string>
     und ein Dateiende enthält.  Ohne optionale Argumente enthält der
     Strom die gesamte Zeichenkette und ist vor dem ersten Zeichen
     positioniert.  Mit den optionalen Argumenten <start> und <end>
     lässt sich der Abschnitt der Zeichenkette festlegen, den der
     Datenstrom enthält.  Das erste Zeichen befindet sich dabei an der
     Position 1.

          (%i1) istream : make_string_input_stream("text", 1, 4);
          (%o1)              #<string-input stream from "text">
          (%i2) (while (c : readchar(istream)) # false do sprint(c), newline())$
          t e x
          (%i3) close(istream)$

 -- Funktion: make_string_output_stream ()

     Gibt einen Datenstrom zurück, der Schriftzeichen aufnehmen kann.
     Die aktuell im Strom enthaltenden Zeichen können mit *note
     get_output_stream_string:: entnommen werden.

          (%i1) ostream : make_string_output_stream();
          (%o1)               #<string-output stream 09622ea0>
          (%i2) printf(ostream, "foo")$

          (%i3) printf(ostream, "bar")$

          (%i4) string : get_output_stream_string(ostream);
          (%o4)                            foobar
          (%i5) printf(ostream, "baz")$

          (%i6) string : get_output_stream_string(ostream);
          (%o6)                              baz
          (%i7) close(ostream)$

 -- Funktion: newline ()
 -- Funktion: newline (<stream>)

     Schreibt einen Zeilenumbruch in den Standardausgabestrom und gibt
     'false' zurück.  Bei der Verwendung des optionalen Arguments
     <stream> wird der Umbruch in diesen Datenstrom geschrieben.  Es
     gibt Situationen, in denen 'newline()' nicht wie erwartet
     funktioniert.

     Beispiel: Siehe *note sprint::.

 -- Funktion: opena (<file>)

     Gibt einen Dateiausgabestrom für Schriftzeichen zurück.  Sollte die
     Textdatei <file> nicht existieren, wird sie erzeugt.  Wird eine
     bereits vorhandene Datei geöffnet, werden alle Ausgaben in die
     Datei am Ende hinzugefügt.

     *note opena_binary: Functions and Variables for binary input and
     output. ist die entsprechende Funktion für die Ausgabe in eine
     Binärdatei.

 -- Funktion: openr (<file>)

     Gibt einen Dateieingabestrom für Schriftzeichen aus einer Textdatei
     zurück.  Voraussetzung ist, dass die Datei <file> bereits
     existiert.

     *note openr_binary: Functions and Variables for binary input and
     output. ist die entsprechende Funktion für die Eingabe aus einer
     Binärdatei.

 -- Funktion: openw (<file>)

     Gibt einen Dateiausgabestrom für Schriftzeichen zurück.  Sollte die
     Textdatei <file> nicht existieren, wird sie erzeugt.  Wird eine
     bereits vorhandene Datei geöffnet, wird sie destruktiv verändert.

     *note openw_binary: Functions and Variables for binary input and
     output. ist die entsprechende Funktion für die Ausgabe in eine
     Binärdatei.

 -- Function: printf (<dest>, <string>)
 -- Function: printf (<dest>, <string>, <expr_1>, ..., <expr_n>)

     Erzeugt eine formatierte Ausgabe.  Der Zielparameter <dest> gibt
     an, wo die Ausgabe erfolgen soll.  Möglich sind hier ein
     Ausgabestrom oder die globalen Variablen 'true' und 'false'.
     'true' bewirkt eine Ausgabe im Terminal.  Der Rückgabewert von
     'printf' ist in diesem Fall 'false'.  'false' als Zielparameter
     bewirkt die Ausgabe im Rückgabewert.

     Die Zeichen des Kontrollparameters <string> werden der Reihe nach
     ausgegeben, wobei jedoch eine Tilde eine Direktive einleitet.  Die
     Direktiven verwenden dann im Allgemeinen die nachstehenden
     Parameter <expr_1>, ..., <expr_n>, um die Ausgabe zu erzeugen.  Das
     Zeichen nach der Tilde gibt dabei an, welche Art der Formatierung
     gewünscht ist.

     'printf' stellt die Common Lisp Funktion 'format' in Maxima zur
     Verfügung.  Das folgende Beispiel zeigt die grundsätzliche
     Beziehung zwischen diesen beiden Funktionen.

          (%i1) printf(true, "R~dD~d~%", 2, 2);
          R2D2
          (%o1)                                false
          (%i2) :lisp (format t "R~dD~d~%" 2 2)
          R2D2
          NIL

     Die folgende Beschreibung und die Beispiele beschränken sich auf
     eine grobe Skizze der Verwendungsmöglichkeiten von 'printf'.  Die
     Lisp Funktion 'format' ist in vielen Referenzbüchern ausführlich
     beschrieben.  Eine hilfreiche Quelle ist z.B. das frei verfügbare
     Online-Manual "Common Lisp the Language" von Guy L. Steele.  Siehe
     dort das Kapitel 22.3.3.

             ~%       new line
             ~&       fresh line
             ~t       tab
             ~$       monetary
             ~d       decimal integer
             ~b       binary integer
             ~o       octal integer
             ~x       hexadecimal integer
             ~br      base-b integer
             ~r       spell an integer
             ~p       plural
             ~f       floating point
             ~e       scientific notation
             ~g       ~f or ~e, depending upon magnitude
             ~h       bigfloat
             ~a       uses Maxima function string
             ~s       like ~a, but output enclosed in "double quotes"
             ~~       ~
             ~<       justification, ~> terminates
             ~(       case conversion, ~) terminates
             ~[       selection, ~] terminates
             ~{       iteration, ~} terminates

     Die Direktive ~h für Gleitkommazahlen mit beliebiger Genauigkeit
     entspricht nicht dem Lisp-Standard und wird daher unten näher
     beschrieben.

     Die Direktive ~* wird nicht unterstützt.

     Ist <dest> ein Datenstrom oder 'true', gibt 'printf' 'false'
     zurück.  Andernfalls ist der Rückgabewert eine Zeichenkette.

          (%i1) printf( false, "~a ~a ~4f ~a ~@r",
                        "String",sym,bound,sqrt(12),144), bound = 1.234;
          (%o1)                 String sym 1.23 2*sqrt(3) CXLIV
          (%i2) printf( false,"~{~a ~}",["one",2,"THREE"] );
          (%o2)                          one 2 THREE
          (%i3) printf( true,"~{~{~9,1f ~}~%~}",mat ),
                    mat = args(matrix([1.1,2,3.33],[4,5,6],[7,8.88,9]))$
                1.1       2.0       3.3
                4.0       5.0       6.0
                7.0       8.9       9.0
          (%i4) control: "~:(~r~) bird~p ~[is~;are~] singing."$
          (%i5) printf( false, control, n,n, if n = 1 then 1 else 2 ), n = 2;
          (%o5)                    Two birds are singing.

     Die Direktive ~h wurde für Gleitkommazahlen mit beliebiger
     Genauigkeit eingeführt.

          ~w,d,e,x,o,p@H
           w : width
           d : decimal digits behind floating point
           e : minimal exponent digits
           x : preferred exponent
           o : overflow character
           p : padding character
           @ : display sign for positive numbers

          (%i1) fpprec : 1000$
          (%i2) printf(true, "|~h|~%", 2.b0^-64)$
          |0.0000000000000000000542101086242752217003726400434970855712890625|
          (%i3) fpprec : 26$
          (%i4) printf(true, "|~h|~%", sqrt(2))$
          |1.4142135623730950488016887|
          (%i5) fpprec : 24$
          (%i6) printf(true, "|~h|~%", sqrt(2))$
          |1.41421356237309504880169|
          (%i7) printf(true, "|~28h|~%", sqrt(2))$
          |   1.41421356237309504880169|
          (%i8) printf(true, "|~28,,,,,'*h|~%", sqrt(2))$
          |***1.41421356237309504880169|
          (%i9) printf(true, "|~,18h|~%", sqrt(2))$
          |1.414213562373095049|
          (%i10) printf(true, "|~,,,-3h|~%", sqrt(2))$
          |1414.21356237309504880169b-3|
          (%i11) printf(true, "|~,,2,-3h|~%", sqrt(2))$
          |1414.21356237309504880169b-03|
          (%i12) printf(true, "|~20h|~%", sqrt(2))$
          |1.41421356237309504880169|
          (%i13) printf(true, "|~20,,,,'+h|~%", sqrt(2))$
          |++++++++++++++++++++|

 -- Funktion: readbyte (<stream>)

     Entfernt das erste Byte aus dem binären Eingabestrom <stream> und
     gibt es zurück.  Ist das Ende der Datei (EOF) erreicht, wird
     'false' zurück gegeben.

     Beispiel: Die ersten 16 Byte aus einer mit AES in OpenSSL
     verschlüsselten Datei werden gelesen und ausgewertet.

          (%i1) ibase: obase: 16.$

          (%i2) in: openr_binary("msg.bin");
          (%o2)                       #<input stream msg.bin>
          (%i3) (L:[],  thru 16. do push(readbyte(in), L),  L:reverse(L));
          (%o3) [53, 61, 6C, 74, 65, 64, 5F, 5F, 88, 56, 0DE, 8A, 74, 0FD, 0AD, 0F0]
          (%i4) close(in);
          (%o4)                                true
          (%i5) map(ascii, rest(L,-8));
          (%o5)                      [S, a, l, t, e, d, _, _]
          (%i6) salt: octets_to_number(rest(L,8));
          (%o6)                          8856de8a74fdadf0

 -- Funktion: readchar (<stream>)

     Entfernt und gibt das erste Schriftzeichen in <stream> zurück.
     Falls das Ende des Streams erreicht sein sollte, gibt 'readchar'
     'false' zurück.

     Beispiel: Siehe *note make_string_input_stream::.

 -- Function: readline (<stream>)

     Gibt die Zeichenkette zurück, die sämtliche Zeichen von der
     aktuellen Position in <stream> bis zum Ende der Zeile enthält oder
     'false', falls das Ende der Datei erreicht wurde.

 -- Funktion: sprint (<expr_1>, ..., <expr_n>)

     Wertet ihre Argumente der Reihe nach von links nach rechts aus und
     gibt sie dann auf einer Linie aus.  Zeilenbegrenzungen werden dabei
     außer Acht gelassen.  An die ausgegebenen Ausdrücke wird jeweils
     rechts ein Leerzeichen angefügt.

     Beispiel: Sequentielle Ausgabe mit 'sprint'.  Zeilenumbrüche werden
     hier mit 'newline()' erzeugt.

          (%i1) for n:0 thru 19 do sprint(fib(n))$
          0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181
          (%i2) for n:0 thru 22 do (
                   sprint(fib(n)),
                   if mod(n,10) = 9 then newline() )$
          0 1 1 2 3 5 8 13 21 34
          55 89 144 233 377 610 987 1597 2584 4181
          6765 10946 17711

 -- Funktion: writebyte (<byte>, <stream>)

     Schreibt das Byte <byte> in den binären Ausgabestrom <stream>.
     'writebyte' gibt 'byte' zurück.

     Beispiel: Es werden Bytes in eine Binärdatei geschrieben.  In
     diesem Beispiel entsprechen sämtliche Bytes druckbaren Zeichen, die
     mit Hilfe von 'printfile' ausgegeben werden können.  Die Bytes
     verbleiben so lange im Datenstrom, bis die Funktionen
     'flush_output' oder 'close' aufgerufen werden.

          (%i1) ibase: obase: 16.$

          (%i2) bytes: string_to_octets("GNU/Linux");
          (%o2)                [47, 4E, 55, 2F, 4C, 69, 6E, 75, 78]
          (%i3) out: openw_binary("test.bin");
          (%o3)                      #<output stream test.bin>
          (%i4) for i thru 3 do writebyte(bytes[i], out);
          (%o4)                                done
          (%i5) printfile("test.bin")$

          (%i6) flength(out);
          (%o6)                                  0
          (%i7) flush_output(out);
          (%o7)                                true
          (%i8) flength(out);
          (%o8)                                  3
          (%i9) printfile("test.bin")$
          GNU
          (%i0A) for b in rest(bytes,3) do writebyte(b, out);
          (%o0A)                               done
          (%i0B) close(out);
          (%o0B)                               true
          (%i0C) printfile("test.bin")$
          GNU/Linux


File: maxima.info,  Node: Schriftzeichen,  Next: Verarbeitung von Zeichenketten,  Prev: Ein- und Ausgabe,  Up: stringproc

73.3 Schriftzeichen
===================

In Maxima sind Schriftzeichen Zeichenketten der Länge 1.

 -- Function: adjust_external_format ()

     Gibt Informationen zum aktuellen externen Format des Lisp Lesers
     aus und in dem Fall, dass die Kodierung des externen Formats nicht
     mit der Kodierung der Anwendung, in der Maxima läuft,
     übereinstimmt, versucht 'adjust_external_format', die Kodierung
     anzupassen oder gibt entsprechende Hilfen oder Anleitungen aus.
     'adjust_external_format' gibt 'true' zurück, wenn das externe
     Format geändert wurde und 'false', wenn nicht.

     Funktionen wie *note cint::, *note unicode::, *note
     octets_to_string:: und *note string_to_octets:: benötigen UTF-8 als
     das externe Format des Lisp Lesers, um über dem vollständigen
     Bereich der Unicode-Zeichen korrekt arbeiten zu können.

     Beispiele (Maxima in Windows, März 2016): Die Verwendung von
     'adjust_external_format' in dem Fall, dass das externe Format nicht
     mit der Kodierung der Anwendung, in der Maxima läuft,
     übereinstimmt.

     1.  Maxima in der Kommandozeile

     Für die Sitzung in einem Terminal wird empfohlen, ein mit SBCL
     kompiliertes Maxima zu verwenden.  Unicode wird hier standardmäßig
     unterstützt und ein Aufruf von 'adjust_external_format' ist nicht
     notwendig.

     Falls Maxima mit CLISP oder GCL kompiliert wurde, wird empfohlen,
     die Kodierung des Terminals von CP850 in CP1252 abzuändern.
     'adjust_external_format' gibt eine entsprechende Hilfe aus.

     CCL liest UTF-8, obwohl der Input vom Terminal standardmäßig in
     CP850 kodiert ist.  CP1252 wird jedoch von CCL nicht unterstützt.
     'adjust_external_format' gibt deshalb eine Anleitung aus, wie die
     Kodierung des Terminals und die des externen Formats beide auf
     ISO-8859-1 abgeändert werden können.

     2.  wxMaxima

     In wxMaxima liest SBCL standardmäßig CP1252.  Der Input von der
     Anwendung (wxMaxima) ist jedoch UTF-8-kodiert.  Hier ist eine
     Anpassung erforderlich.

     Ein Aufruf von 'adjust_external_format' und ein Neustart von Maxima
     ändern das standardmäßige externe Format auf UTF-8.

          (%i1)adjust_external_format();
          The line
          (setf sb-impl::*default-external-format* :utf-8)
          has been appended to the init file
          C:/Users/Username/.sbclrc
          Please restart Maxima to set the external format to UTF-8.
          (%i1) false

     Maxima wird neu gestartet.

          (%i1) adjust_external_format();
          The external format is currently UTF-8
          and has not been changed.
          (%i1) false

 -- Function: alphacharp (<char>)

     Gibt 'true' zurück, falls <char> ein Buchstabe eines Alphabets ist.

     Um ein Nicht-US-ASCII-Zeichen als Buchstaben eines Alphabets
     erkennen zu können, muss das unter Maxima liegende Lisp Unicode
     voll unterstützen.  So wird z.B. ein Umlaut mit SBCL in GNU/Linux
     als Buchstabe erkannt, mit GCL jedoch nicht.  (In Windows muss ein
     mit SBCL kompiliertes Maxima auf UTF-8 umgestellt worden sein.
     Siehe hierzu *note adjust_external_format::.)

     Beispiele:

     Das unter Maxima liegende Lisp (SBCL, GNU/Linux) kann das
     eingegebene Zeichen in ein Lisp-Schriftzeichen umwandeln und
     untersuchen.

          (%i1) alphacharp("ü");
          (%o1)                          true

     Mit GCL ist dies nicht möglich.  Es kommt zu einem Fehlerabbruch.

          (%i1) alphacharp("u");
          (%o1)                          true
          (%i2) alphacharp("ü");

          package stringproc: ü cannot be converted into a Lisp character.
           -- an error.

 -- Function: alphanumericp (<char>)

     Gibt 'true' zurück, falls <char> ein Buchstabe eines Alphabets oder
     ein Zahlzeichen ist (als Zahlzeichen werden hier nur entprechende
     US-ASCII-Zeichen betrachtet).

     Hinweis: Siehe Bemerkungen zu *note alphacharp::.

 -- Funktion: ascii (<int>)

     Gibt das US-ASCII-Zeichen zurück, das der Ganzzahl <int>
     entspricht.  <int> muss dabei kleiner als '128' sein.

     Siehe *note unicode:: für die Umwandlung von Codepunkten größer
     '127'.

     Beispiele:

          (%i1) for n from 0 thru 127 do (
                  ch: ascii(n),
                  if alphacharp(ch) then sprint(ch),
                  if n = 96 then newline() )$
          A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
          a b c d e f g h i j k l m n o p q r s t u v w x y z

 -- Function: cequal (<char_1>, <char_2>)

     Gibt 'true' zurück, falls <char_1> und <char_2> ein und das selbe
     Schriftzeichen sind.

 -- Function: cequalignore (<char_1>, <char_2>)

     Arbeitet wie *note cequal::, ignoriert jedoch die Groß- und
     Kleinschreibung, was für Nicht-US-ASCII-Zeichen nur möglich ist,
     wenn das unter Maxima liegende Lisp einen Buchstaben auch als
     Buchstaben eines Alphabets erkennen kann.  Siehe hierzu die
     Bemerkungen zu *note alphacharp::.

 -- Function: cgreaterp (<char_1>, <char_2>)

     Gibt 'true' zurück, wenn der Codepunkt des Zeichens <char_1> größer
     ist als der des Zeichens <char_2>.

 -- Funktion: cgreaterpignore (<char_1>, <char_2>)

     Arbeitet wie *note cgreaterp::, ignoriert jedoch die Groß- und
     Kleinschreibung, was für Nicht-US-ASCII-Zeichen nur möglich ist,
     wenn das unter Maxima liegende Lisp einen Buchstaben auch als
     Buchstaben eines Alphabets erkennen kann.  Siehe hierzu die
     Bemerkungen zu *note alphacharp::.

 -- Funktion: charp (<obj>)

     Gibt 'true' zurück, wenn <obj> ein Schriftzeichen ist.

     Beispiel: Siehe Einführung.

 -- Funktion: cint (<char>)

     Gibt den Unicode Codepunkt des Arguments <char> zurück, das ein
     Schriftzeichen sein muss, d.h.  eine Zeichenkette der Länge '1'.

     Beispiele: Der hexadedimale Codepunkt von Schriftzeichen (Maxima
     kompiliert mit SBCL in GNU/Linux).

          (%i1) obase: 16.$
          (%i2) map(cint, ["$","£","Euro"]);
          (%o2)                           [24, 0A3, 20AC]

     Warnung: In Windows ist es nicht möglich, Schriftzeichen, die
     Codepunkten größer 16 Bit entsprechen, in wxMaxima einzugeben, wenn
     Maxima mit SBCL kompiliert wurde und das aktuelle externe Format
     nicht UTF-8 ist.  Siehe *note adjust_external_format:: für weitere
     Informationen.

     CMUCL verarbeitet solche Zeichen nicht als ein einziges Zeichen und
     'cint' gibt dann 'false' zurück.  Als Ausweg kann hier die
     Umwandlung von Schriftzeichen in Codepunkte über UTF-8-Oktette
     dienen:
     'utf8_to_unicode(string_to_octets(character));'

     Siehe *note utf8_to_unicode::, *note string_to_octets::.

 -- Function: clessp (<char_1>, <char_2>)

     Gibt 'true' zurück, wenn der Codepunkt des Zeichens <char_1>
     kleiner ist als der des Zeichens <char_2>.

 -- Funktion: clesspignore (<char_1>, <char_2>)

     Arbeitet wie *note clessp::, ignoriert jedoch die Groß- und
     Kleinschreibung, was für Nicht-US-ASCII-Zeichen nur möglich ist,
     wenn das unter Maxima liegende Lisp einen Buchstaben auch als
     Buchstaben eines Alphabets erkennen kann.  Siehe hierzu die
     Bemerkungen zu *note alphacharp::.

 -- Funktion: constituent (<char>)

     Gibt 'true' zurück, wenn <char> ein graphisches Schriftzeichen,
     aber kein Leerzeichen ist.  Ein graphisches Schriftzeichen ist ein
     Leerzeichen oder ein Zeichen, das man sehen kann.  ('constituent'
     wurde definiert von Paul Graham.  Siehe Paul Graham, ANSI Common
     Lisp, 1996, Seite 67.)

     Beispiel:

          (%i1) for n from 0 thru 255 do (
          tmp: ascii(n), if constituent(tmp) then sprint(tmp) )$
          ! " #  %  ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B
          C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c
          d e f g h i j k l m n o p q r s t u v w x y z { | } ~

     Hinweis: Siehe Bemerkungen zu *note alphacharp::.

 -- Funktion: digitcharp (<char>)

     Gibt 'true' zurück, wenn <char> ein Zahlzeichen ist, wobei als
     Zahlzeichen hier nur entsprechende US-ASCII-Zeichen betrachtet
     werden.

 -- Funktion: lowercasep (<char>)

     Gibt 'true' zurück, wenn <char> ein Kleinbuchstabe ist.

     Hinweis: Siehe Bemerkungen zu *note alphacharp::.

 -- Variable: newline

     Das Steuerzeichen für den Zeilenvorschub (ASCII-Zeichen 10).

 -- Variable: space

     Das Leerzeichen.

 -- Variable: tab

     Das Tabulatorzeichen.

 -- Funktion: unicode (<arg>)

     Gibt das durch <arg> definierte Schriftzeichen zurück.  <arg> kann
     ein Unicode Codepunkt oder auch eine Zeichenkette mit einem Namen
     sein, falls das unter Maxima liegende Lisp Unicode vollständig
     unterstützt.

     Beispiel: Durch hexadezimale Codepunkte definierte Schriftzeichen
     (Maxima kompiliert mit SBCL in GNU/Linux).

          (%i1) ibase: 16.$
          (%i2) map(unicode, [24, 0A3, 20AC]);
          (%o2)                            [$, £, Euro]

     Warnung: In wxMaxima in Windows ist es nicht möglich, Codepunkte
     größer 16 Bit in Schriftzeichen umzuwandeln, wenn Maxima mit SBCL
     kompiliert wurde und das aktuelle externe Format nicht UTF-8 ist.
     Siehe *note adjust_external_format:: für weitere Informationen.

     CMUCL verarbeitet keine Codepunkte größer 16 Bit.  'unicode' gibt
     dann 'false' zurück.  Als Ausweg kann hier die Umwandlung der
     Codepunkte in Schriftzeichen über UTF-8-Oktette dienen:

     'octets_to_string(unicode_to_utf8(code_point));'

     Siehe *note octets_to_string::, *note unicode_to_utf8::.

     Falls das unter Maxima liegende Lisp Unicode vollständig
     unterstützt, kann ein Schriftzeichen durch seinen Namen angegeben
     werden.

     Das folgende Beispiel ist mit ECL, CLISP und SBCL möglich, wobei
     mit SBCL in wxMaxima in Windows das externe Format auf UTF-8
     gesetzt werden muss.  'unicode(name)' wird auch von CMUCL
     unterstützt, jedoch wieder beschränkt auf 16-Bit-Zeichen.

     Die Zeichenkette als Argument für 'unicode' muss prinzipiell die
     sein, die 'printf' mit der Spezifikation "~@c" zurück gibt, jedoch,
     wie unten gezeigt, ohne den Präfix "#\".  Unterstriche können durch
     Leerzeichen und Groß- durch Kleinbuchstaben ersetzt werden.

     Beispiel (fortgesetzt): Ein Schriftzeichen ist durch seinen Namen
     gegeben (Maxima kompiliert mit SBCL in GNU/Linux).

          (%i3) printf(false, "~@c", unicode(0DF));
          (%o3)                    #\LATIN_SMALL_LETTER_SHARP_S
          (%i4) unicode("LATIN_SMALL_LETTER_SHARP_S");
          (%o4)                                  ß
          (%i5) unicode("Latin small letter sharp S");
          (%o5)                                  ß

 -- Funktion: unicode_to_utf8 (<code_point>)

     Gibt eine Liste mit UTF-8-Code zurück, der dem Unicode <code_point>
     entspricht.

     Beispiel: Umwandlung von Unicode Codepunkten in UTF-8 und
     umgekehrt.

          (%i1) ibase: obase: 16.$
          (%i2) map(cint, ["$","£","Euro"]);
          (%o2)                           [24, 0A3, 20AC]
          (%i3) map(unicode_to_utf8, %);
          (%o3)                 [[24], [0C2, 0A3], [0E2, 82, 0AC]]
          (%i4) map(utf8_to_unicode, %);
          (%o4)                           [24, 0A3, 20AC]

 -- Funktion: uppercasep (<char>)

     Gibt 'true' zurück, wenn <char> ein Großbuchstabe ist.

     Hinweis: Siehe Bemerkungen zu *note alphacharp::.

 -- Variable: us_ascii_only

     Diese Optionsvariable beeinflusst Maxima, wenn die Zeichenkodierung
     der Anwendung, in der Maxima läuft, UTF-8 ist, das externe Format
     des Lisp Readers jedoch nicht.

     In GNU/Linux trifft dies zu, wenn Maxima mit GCL kompiliert wurde
     und in Windows in wxMaxima in GCL- und SBCL-Versionen.  Es wird
     empfohlen, in der SBCL-Version das externe Format in UTF-8
     abzuändern.  Eine Festlegung von 'us_ascii_only' wird damit
     unnötig.  Siehe *note adjust_external_format:: für Details.

     'us_ascii_only' ist standardmäßig 'false'.  Maxima analysiert dann
     (d.h.  in der oben beschriebenen Situation) selbst die
     UTF-8-Kodierung.

     Wurde 'us_ascii_only' auf 'true' gesetzt, wird angenommen, dass
     alle Zeichenketten, die als Argumente für Funktionen des Pakets
     'stringproc' verwendet werden, nur ausschließlich US-ASCII-Zeichen
     enthalten.  Durch diese Vereinbarung wird die UTF-8-Analyse des
     Inputs überflüssig und Zeichenketten können effizienter verarbeitet
     werden.

 -- Function: utf8_to_unicode (<list>)

     Gibt den Unicode Codepunkt zurück, der der Liste <list> entspricht,
     die die UTF-8-Kodierung eines einzelnen Schriftzeichens enthalten
     muss.

     Beispiel: Siehe *note unicode_to_utf8::.


File: maxima.info,  Node: Verarbeitung von Zeichenketten,  Next: Oktette und Werkzeuge für die Kryptographie,  Prev: Schriftzeichen,  Up: stringproc

73.4 Verarbeitung von Zeichenketten
===================================

Positionsindizes in Strings sind in Maxima genau so wie Listen
1-indiziert.  Siehe hierzu das Beispiel in *note charat::.

 -- Funktion: charat (<string>, <n>)

     Gibt das <n>-te Schriftzeichen in <string> zurück.  Das erste
     Zeichen in <string> erhält man mit <n> = 1.

     Beispiel:

          (%i1) charat("Lisp",1);
          (%o1)                           L
          (%i2) charlist("Lisp")[1];
          (%o2)                           L

 -- Funktion: charlist (<string>)

     Gibt eine Liste mit allen Schriftzeichen in <string> zurück.

     Beispiel:

          (%i1) charlist("Lisp");
          (%o1)                     [L, i, s, p]

 -- Function: eval_string (<str>)

     Parse the string <str> as a Maxima expression and evaluate it.  The
     string <str> may or may not have a terminator (dollar sign '$' or
     semicolon ';').  Only the first expression is parsed and evaluated,
     if there is more than one.

     Complain if <str> is not a string.

     See also *note parse_string::.

     Examples:

          (%i1) eval_string ("foo: 42; bar: foo^2 + baz");
          (%o1)                       42
          (%i2) eval_string ("(foo: 42, bar: foo^2 + baz)");
          (%o2)                   baz + 1764

 -- Function: parse_string (<str>)

     Parse the string <str> as a Maxima expression (do not evaluate it).
     The string <str> may or may not have a terminator (dollar sign '$'
     or semicolon ';').  Only the first expression is parsed, if there
     is more than one.

     Complain if <str> is not a string.

     See also *note eval_string::.

     Examples:

          (%i1) parse_string ("foo: 42; bar: foo^2 + baz");
          (%o1)                    foo : 42
          (%i2) parse_string ("(foo: 42, bar: foo^2 + baz)");
                                             2
          (%o2)          (foo : 42, bar : foo  + baz)

 -- Funktion: scopy (<string>)

     Gibt eine Kopie der Zeichenkette <string> als neue Zeichenkette
     zurück.

 -- Funktion: sdowncase (<string>)
 -- Funktion: sdowncase (<string>, <start>)
 -- Funktion: sdowncase (<string>, <start>, <end>)

     Arbeitet wie *note supcase::, jedoch werden Groß- in
     Kleinbuchstaben umgewandelt.

 -- Funktion: sequal (<string_1>, <string_2>)

     Gibt 'true' zurück, wenn <string_1> und <string_2> die selbe
     Zeichensequenz enthalten.

 -- Funktion: sequalignore (<string_1>, <string_2>)

     Arbeitet wie *note sequal::, ignoriert jedoch die Groß- und
     Kleinschreibung, was für Nicht-US-ASCII-Zeichen nur möglich ist,
     wenn das unter Maxima liegende Lisp einen Buchstaben auch als
     Buchstaben eines Alphabets erkennen kann.  Siehe hierzu die
     Bemerkungen zu *note alphacharp::.

 -- Funktion: sexplode (<string>)

     'sexplode' ist ein Alias für die Funktion *note charlist::.

 -- Function: simplode (<list>)
 -- Function: simplode (<list>, <delim>)

     'simplode' takes a list of expressions and concatenates them into a
     string.  If no delimiter <delim> is specified, 'simplode' uses no
     delimiter.  <delim> can be any string.

     Examples:

          (%i1) simplode(["xx[",3,"]:",expand((x+y)^3)]);
          (%o1)             xx[3]:y^3+3*x*y^2+3*x^2*y+x^3
          (%i2) simplode( sexplode("stars")," * " );
          (%o2)                   s * t * a * r * s
          (%i3) simplode( ["One","more","coffee."]," " );
          (%o3)                   One more coffee.

 -- Function: sinsert (<seq>, <string>, <pos>)

     Returns a string that is a concatenation of 'substring (<string>,
     1, <pos> - 1)', the string <seq> and 'substring (<string>, <pos>)'.
     Note that the first character in <string> is in position 1.

     Examples:

          (%i1) s: "A submarine."$
          (%i2) concat( substring(s,1,3),"yellow ",substring(s,3) );
          (%o2)                  A yellow submarine.
          (%i3) sinsert("hollow ",s,3);
          (%o3)                  A hollow submarine.

 -- Function: sinvertcase (<string>)
 -- Function: sinvertcase (<string>, <start>)
 -- Function: sinvertcase (<string>, <start>, <end>)

     Returns <string> except that each character from position <start>
     to <end> is inverted.  If <end> is not given, all characters from
     <start> to the end of <string> are replaced.

     Examples:

          (%i1) sinvertcase("sInvertCase");
          (%o1)                      SiNVERTcASE

 -- Funktion: slength (<string>)

     Gibt die Anzahl der Zeichen in der Zeichenkette <string> zurück.

 -- Funktion: smake (<num>, <char>)

     Gibt eine neue Zeichenkette mit <num> Zeichen <char> zurück.

     Beispiel:

          (%i1) smake(3,"w");
          (%o1)                          www

 -- Function: smismatch (<string_1>, <string_2>)
 -- Function: smismatch (<string_1>, <string_2>, <test>)

     Returns the position of the first character of <string_1> at which
     <string_1> and <string_2> differ or 'false'.  Default test function
     for matching is *note sequal::.  If 'smismatch' should ignore case,
     use *note sequalignore:: as test.

     Example:

          (%i1) smismatch("seven","seventh");
          (%o1)                           6

 -- Function: split (<string>)
 -- Function: split (<string>, <delim>)
 -- Function: split (<string>, <delim>, <multiple>)

     Returns the list of all tokens in <string>.  Each token is an
     unparsed string.  'split' uses <delim> as delimiter.  If <delim> is
     not given, the space character is the default delimiter.
     <multiple> is a boolean variable with 'true' by default.  Multiple
     delimiters are read as one.  This is useful if tabs are saved as
     multiple space characters.  If <multiple> is set to 'false', each
     delimiter is noted.

     Examples:

          (%i1) split("1.2   2.3   3.4   4.5");
          (%o1)                 [1.2, 2.3, 3.4, 4.5]
          (%i2) split("first;;third;fourth",";",false);
          (%o2)               [first, , third, fourth]

 -- Function: sposition (<char>, <string>)

     Returns the position of the first character in <string> which
     matches <char>.  The first character in <string> is in position 1.
     For matching characters ignoring case see *note ssearch::.

 -- Function: sremove (<seq>, <string>)
 -- Function: sremove (<seq>, <string>, <test>)
 -- Function: sremove (<seq>, <string>, <test>, <start>)
 -- Function: sremove (<seq>, <string>, <test>, <start>, <end>)

     Returns a string like <string> but without all substrings matching
     <seq>.  Default test function for matching is *note sequal::.  If
     'sremove' should ignore case while searching for <seq>, use *note
     sequalignore:: as test.  Use <start> and <end> to limit searching.
     Note that the first character in <string> is in position 1.

     Examples:

          (%i1) sremove("n't","I don't like coffee.");
          (%o1)                   I do like coffee.
          (%i2) sremove ("DO ",%,'sequalignore);
          (%o2)                    I like coffee.

 -- Function: sremovefirst (<seq>, <string>)
 -- Function: sremovefirst (<seq>, <string>, <test>)
 -- Function: sremovefirst (<seq>, <string>, <test>, <start>)
 -- Function: sremovefirst (<seq>, <string>, <test>, <start>, <end>)

     Like 'sremove' except that only the first substring that matches
     'seq' is removed.

 -- Funktion: sreverse (<string>)

     Gibt eine Zeichenkette mit allen Zeichen von <string> in
     umgekehrter Reihenfolge zurück.

 -- Function: ssearch (<seq>, <string>)
 -- Function: ssearch (<seq>, <string>, <test>)
 -- Function: ssearch (<seq>, <string>, <test>, <start>)
 -- Function: ssearch (<seq>, <string>, <test>, <start>, <end>)

     Returns the position of the first substring of <string> that
     matches the string <seq>.  Default test function for matching is
     *note sequal::.  If 'ssearch' should ignore case, use *note
     sequalignore:: as test.  Use <start> and <end> to limit searching.
     Note that the first character in <string> is in position 1.

          (%i1) ssearch("~s","~{~S ~}~%",'sequalignore);
          (%o1)                                  4

 -- Function: ssort (<string>)
 -- Function: ssort (<string>, <test>)

     Returns a string that contains all characters from <string> in an
     order such there are no two successive characters <c> and <d> such
     that 'test (<c>, <d>)' is 'false' and 'test (<d>, <c>)' is 'true'.
     Default test function for sorting is *note clessp::.  The set of
     test functions is '{*note clessp::, *note clesspignore::, *note
     cgreaterp::, *note cgreaterpignore::, *note cequal::, *note
     cequalignore::}'.

          (%i1) ssort("I don't like Mondays.");
          (%o1)                    '.IMaddeiklnnoosty
          (%i2) ssort("I don't like Mondays.",'cgreaterpignore);
          (%o2)                 ytsoonnMlkIiedda.'

 -- Function: ssubst (<new>, <old>, <string>)
 -- Function: ssubst (<new>, <old>, <string>, <test>)
 -- Function: ssubst (<new>, <old>, <string>, <test>, <start>)
 -- Function: ssubst (<new>, <old>, <string>, <test>, <start>, <end>)

     Returns a string like <string> except that all substrings matching
     <old> are replaced by <new>.  <old> and <new> need not to be of the
     same length.  Default test function for matching is *note sequal::.
     If 'ssubst' should ignore case while searching for old, use *note
     sequalignore:: as test.  Use <start> and <end> to limit searching.
     Note that the first character in <string> is in position 1.

          (%i1) ssubst("like","hate","I hate Thai food. I hate green tea.");
          (%o1)          I like Thai food. I like green tea.
          (%i2) ssubst("Indian","thai",%,'sequalignore,8,12);
          (%o2)         I like Indian food. I like green tea.

 -- Function: ssubstfirst (<new>, <old>, <string>)
 -- Function: ssubstfirst (<new>, <old>, <string>, <test>)
 -- Function: ssubstfirst (<new>, <old>, <string>, <test>, <start>)
 -- Function: ssubstfirst (<new>, <old>, <string>, <test>, <start>,
          <end>)

     Like *note subst:: except that only the first substring that
     matches <old> is replaced.

 -- Function: strim (<seq>,<string>)

     Returns a string like <string>, but with all characters that appear
     in <seq> removed from both ends.

          (%i1) "/* comment */"$
          (%i2) strim(" /*",%);
          (%o2)                        comment
          (%i3) slength(%);
          (%o3)                           7

 -- Function: striml (<seq>, <string>)

     Like *note strim:: except that only the left end of <string> is
     trimmed.

 -- Function: strimr (<seq>, <string>)

     Like *note strim:: except that only the right end of string is
     trimmed.

 -- Funktion: stringp (<obj>)

     Gibt 'true' zurück, wenn <obj> eine Zeichenkette ist.

     Beispiel: Siehe Einführung.

 -- Function: substring (<string>, <start>)
 -- Function: substring (<string>, <start>, <end>)

     Returns the substring of <string> beginning at position <start> and
     ending at position <end>.  The character at position <end> is not
     included.  If <end> is not given, the substring contains the rest
     of the string.  Note that the first character in <string> is in
     position 1.

          (%i1) substring("substring",4);
          (%o1)                        string
          (%i2) substring(%,4,6);
          (%o2)                          in

 -- Function: supcase (<string>)
 -- Function: supcase (<string>, <start>)
 -- Function: supcase (<string>, <start>, <end>)

     Returns <string> except that lowercase characters from position
     <start> to <end> are replaced by the corresponding uppercase ones.
     If <end> is not given, all lowercase characters from <start> to the
     end of <string> are replaced.

          (%i1) supcase("english",1,2);
          (%o1)                        English

 -- Function: tokens (<string>)
 -- Function: tokens (<string>, <test>)

     Returns a list of tokens, which have been extracted from <string>.
     The tokens are substrings whose characters satisfy a certain test
     function.  If <test> is not given, <constituent> is used as the
     default test.  '{constituent, alphacharp, digitcharp, lowercasep,
     uppercasep, charp, characterp, alphanumericp}' is the set of test
     functions.  (The Lisp-version of 'tokens' is written by Paul
     Graham.  ANSI Common Lisp, 1996, page 67.)

          (%i1) tokens("24 October 2005");
          (%o1)                  [24, October, 2005]
          (%i2) tokens("05-10-24",'digitcharp);
          (%o2)                     [05, 10, 24]
          (%i3) map(parse_string,%);
          (%o3)                      [5, 10, 24]


File: maxima.info,  Node: Oktette und Werkzeuge für die Kryptographie,  Prev: Verarbeitung von Zeichenketten,  Up: stringproc

73.5 Oktette und Werkzeuge für die Kryptographie
================================================

 -- Funktion: base64 (<arg>)

     Gibt eine Base64-Darstellung von <arg> zurück.  Das Argument <arg>
     kann eine Zeichenkette, eine nicht-negative Ganzzahl oder eine
     Liste von Oktetten sein.

     Beispiel:

          (%i1) base64: base64("foo bar baz");
          (%o1)                          Zm9vIGJhciBiYXo=
          (%i2) string: base64_decode(base64);
          (%o2)                            foo bar baz
          (%i3) obase: 16.$
          (%i4) integer: base64_decode(base64, 'number);
          (%o4)                       666f6f206261722062617a
          (%i5) octets: base64_decode(base64, 'list);
          (%o5)            [66, 6F, 6F, 20, 62, 61, 72, 20, 62, 61, 7A]
          (%i6) ibase: 16.$
          (%i7) base64(octets);
          (%o7)                          Zm9vIGJhciBiYXo=

     Sind in <arg> Umlaute oder Eszett enthalten (bzw.  Oktette größer
     als 127), ist das Ergebnis von der verwendeten Plattform abhängig.
     Es wird aber durch eine Anwendung von *note base64_decode:: in
     jedem Fall wieder in die ursprüngliche Zeichenkette zurück
     verwandelt.

 -- Funktion: base64_decode (<base64-string>)
 -- Funktion: base64_decode (<base64-string>, <return-type>)

     Dekodiert die Base64-kodierte Zeichenkette <base64-string>
     standardmäßig wieder zurück in die ursprüngliche Zeichenkette.

     Das optionale Argument <return-type> erlaubt es 'base64_decode',
     alternativ hierzu auch die entsprechende Ganzzahl oder Liste von
     Oktetten zurück zu geben.  <return-type> kann 'string', 'number'
     oder 'list' sein.

     Beispiel: Siehe *note base64::.

 -- Funktion: crc24sum (<octets>)
 -- Funktion: crc24sum (<octets>, <return-type>)

     Gibt standardmäßig die 'CRC24'-Prüfsumme einer Oktett-Liste als
     Zeichenkette zurück.

     Das optionale Argument <return-type> erlaubt es 'crc24sum',
     alternativ hierzu auch die entsprechende Ganzzahl oder Liste von
     Oktetten zurück zu geben.  <return-type> kann 'string', 'number'
     oder 'list' sein.

     Beispiel:
          -----BEGIN PGP SIGNATURE-----
          Version: GnuPG v2.0.22 (GNU/Linux)

          iQEcBAEBAgAGBQJVdCTzAAoJEG/1Mgf2DWAqCSYH/AhVFwhu1D89C3/QFcgVvZTM
          wnOYzBUURJAL/cT+IngkLEpp3hEbREcugWp+Tm6aw3R4CdJ7G3FLxExBH/5KnDHi
          rBQu+I7+3ySK2hpryQ6Wx5J9uZSa4YmfsNteR8up0zGkaulJeWkS4pjiRM+auWVe
          vajlKZCIK52P080DG7Q2dpshh4fgTeNwqCuCiBhQ73t8g1IaLdhDN6EzJVjGIzam
          /spqT/sTo6sw8yDOJjvU+Qvn6/mSMjC/YxjhRMaQt9EMrR1AZ4ukBF5uG1S7mXOH
          WdiwkSPZ3gnIBhM9SuC076gLWZUNs6NqTeE3UzMjDAFhH3jYk1T7mysCvdtIkms=
          =WmeC
          -----END PGP SIGNATURE-----

          (%i1) ibase : obase : 16.$
          (%i2) sig64 : sconcat(
           "iQEcBAEBAgAGBQJVdCTzAAoJEG/1Mgf2DWAqCSYH/AhVFwhu1D89C3/QFcgVvZTM",
           "wnOYzBUURJAL/cT+IngkLEpp3hEbREcugWp+Tm6aw3R4CdJ7G3FLxExBH/5KnDHi",
           "rBQu+I7+3ySK2hpryQ6Wx5J9uZSa4YmfsNteR8up0zGkaulJeWkS4pjiRM+auWVe",
           "vajlKZCIK52P080DG7Q2dpshh4fgTeNwqCuCiBhQ73t8g1IaLdhDN6EzJVjGIzam",
           "/spqT/sTo6sw8yDOJjvU+Qvn6/mSMjC/YxjhRMaQt9EMrR1AZ4ukBF5uG1S7mXOH",
           "WdiwkSPZ3gnIBhM9SuC076gLWZUNs6NqTeE3UzMjDAFhH3jYk1T7mysCvdtIkms=" )$
          (%i3) octets: base64_decode(sig64, 'list)$
          (%i4) crc24: crc24sum(octets, 'list);
          (%o4)                          [5A, 67, 82]
          (%i5) base64(crc24);
          (%o5)                              WmeC

 -- Funktion: md5sum (<arg>)
 -- Funktion: md5sum (<arg>, <return-type>)

     Gibt die 'md5'-Prüfsumme einer Zeichenkette, einer nicht-negativen
     Ganzzahl oder einer Liste von Oktetten zurück.  Der standardmäßige
     Rückgabewert ist eine Zeichenkette mit 32 hexadezimalen Zeichen.

     Das optionale Argument <return-type> erlaubt es 'md5sum',
     alternativ hierzu auch die entsprechende Ganzzahl oder Liste von
     Oktetten zurück zu geben.  <return-type> kann 'string', 'number'
     oder 'list' sein.

     Beispiel:

          (%i1) ibase: obase: 16.$
          (%i2) msg: "foo bar baz"$
          (%i3) string: md5sum(msg);
          (%o3)                  ab07acbb1e496801937adfa772424bf7
          (%i4) integer: md5sum(msg, 'number);
          (%o4)                 0ab07acbb1e496801937adfa772424bf7
          (%i5) octets: md5sum(msg, 'list);
          (%o5)        [0AB,7,0AC,0BB,1E,49,68,1,93,7A,0DF,0A7,72,42,4B,0F7]
          (%i6) sdowncase( printf(false, "~{~2,'0x~^:~}", octets) );
          (%o6)           ab:07:ac:bb:1e:49:68:01:93:7a:df:a7:72:42:4b:f7

     Sind in <arg> Umlaute oder andere Nicht-US-ASCII-Zeichen enthalten
     (bzw.  Oktette größer als 127), ist das Ergebnis von der
     verwendeten Plattform abhängig.

 -- Funktion: mgf1_sha1 (<seed>, <len>)
 -- Funktion: mgf1_sha1 (<seed>, <len>, <return-type>)

     Gibt eine Pseudozufallszahl variabler Länge zurück.  Standardmäßig
     ist dies eine Zahl mit einer Länge von <len> Oktetten.

     Das optionale Argument <return-type> erlaubt es 'mgf1_sha1',
     alternativ hierzu die Liste mit den <len> entsprechenden Oktetten
     zurück zu geben.  <return-type> kann 'number' oder 'list' sein.

     Die Berechnung des Rückgabewerts wird in der 'RFC 3447' im Anhang
     'B.2.1 MGF1' beschrieben.  Verwendet wird dabei 'SHA1' als
     Hashfunktion, d.h.  die Zufälligkeit der berechneten Zahl beruht
     auf der Zufälligkeit von 'SHA1'-Hashwerten.

     Beispiel:

          (%i1) ibase: obase: 16.$
          (%i2) number: mgf1_sha1(4711., 8);
          (%o2)                        0e0252e5a2a42fea1
          (%i3) octets: mgf1_sha1(4711., 8, 'list);
          (%o3)                  [0E0,25,2E,5A,2A,42,0FE,0A1]

 -- Funktion: number_to_octets (<number>)

     Gibt eine Oktett-Darstellung der nicht-negativen Ganzzahl <number>
     in Form einer Liste zurück.

     Beispiel:

          (%i1) ibase : obase : 16.$
          (%i2) octets: [0ca,0fe,0ba,0be]$
          (%i3) number: octets_to_number(octets);
          (%o3)                            0cafebabe
          (%i4) number_to_octets(number);
          (%o4)                      [0CA, 0FE, 0BA, 0BE]

 -- Funktion: octets_to_number (<octets>)

     Fügt die in der Liste <octets> enthaltenden Oktette zu einer Zahl
     zusammen und gibt diese zurück.

     Beispiel: Siehe *note number_to_octets::.

 -- Funktion: octets_to_oid (<octets>)

     Berechnet eine Objektkennung (OID) aus einer Liste von Oktetten.

     Beispiel: RSA encryption OID

          (%i1) ibase : obase : 16.$
          (%i2) oid: octets_to_oid([2A,86,48,86,0F7,0D,1,1,1]);
          (%o2)                      1.2.840.113549.1.1.1
          (%i3) oid_to_octets(oid);
          (%o3)               [2A, 86, 48, 86, 0F7, 0D, 1, 1, 1]

 -- Funktion: octets_to_string (<octets>)
 -- Funktion: octets_to_string (<octets>, <encoding>)

     Dekodiert den aktuellen Systemstandards entsprechend die Liste
     <octets> in eine Zeichenkette.  Bei der Dekodierung von Oktetten,
     die nicht ausschließlich US-ASCII-Zeichen entsprechen, ist das
     Ergebnis abhängig von der Plattform, der Anwendung und vom unter
     Maxima liegenden Lisp.

     Beispiel: Die Verwendung des Systemstandards (Maxima kompiliert mit
     GCL, das keine Format-Definition verwendet und die vom GNU/Linux
     Terminal kodierten UTF-8-Oktette ungeändert an Maxima weitergibt).

          (%i1) octets: string_to_octets("abc");
          (%o1)                            [61, 62, 63]
          (%i2) octets_to_string(octets);
          (%o2)                                 abc
          (%i3) ibase: obase: 16.$
          (%i4) unicode(20AC);
          (%o4)                                  Euro
          (%i5) octets: string_to_octets(%);
          (%o5)                           [0E2, 82, 0AC]
          (%i6) octets_to_string(octets);
          (%o6)                                  Euro
          (%i7) utf8_to_unicode(octets);
          (%o7)                                20AC

     In dem Fall, dass UTF-8 das externe Format des Lisp Readers ist,
     kann das optionale Argument <encoding> genutzt werden, um für die
     Oktett-String-Umwandlung eine gewÃ¼nschte Kodierung auszuwählen.
     Siehe *note adjust_external_format::, falls es notwendig sein
     sollte, hierfür das externe Format zu ändern.

     Die Namen einiger unterstützter Kodierungen (weitere siehe das
     entsprechende Lisp Manual):
     CCL, CLISP, SBCL: 'utf-8, ucs-2be, ucs-4be, iso-8859-1, cp1252,
     cp850'
     CMUCL: 'utf-8, utf-16-be, utf-32-be, iso8859-1, cp1252'
     ECL: 'utf-8, ucs-2be, ucs-4be, iso-8859-1, windows-cp1252,
     dos-cp850'

     Beispiel (fortgesetzt): Die Verwendung des optionalen Arguments
     (Maxima kompiliert mit SBCL, GNU/Linux Terminal).

          (%i8) string_to_octets("Euro", "ucs-2be");
          (%o8)                              [20, 0AC]

 -- Funktion: oid_to_octets (<oid-string>)

     Verwandelt eine Objektkennung (OID) in eine Liste von Oktetten.

     Beispiel: Siehe *note octets_to_oid::.

 -- Funktion: sha1sum (<arg>)
 -- Funktion: sha1sum (<arg>, <return-type>)

     Gibt den 'SHA1'-Fingerabdruck einer Zeichenkette, einer
     nicht-negativen Ganzzahl oder einer Liste von Oktetten zurück.  Der
     standardmäßige Rückgabewert ist eine Zeichenkette mit 40
     hexadezimalen Zeichen.

     Das optionale Argument <return-type> erlaubt es 'sha1sum',
     alternativ hierzu auch die entsprechende Ganzzahl oder Liste von
     Oktetten zurück zu geben.  <return-type> kann 'string', 'number'
     oder 'list' sein.

     Beispiel:

          (%i1) ibase: obase: 16.$
          (%i2) msg: "foo bar baz"$
          (%i3) string: sha1sum(msg);
          (%o3)              c7567e8b39e2428e38bf9c9226ac68de4c67dc39
          (%i4) integer: sha1sum(msg, 'number);
          (%o4)             0c7567e8b39e2428e38bf9c9226ac68de4c67dc39
          (%i5) octets: sha1sum(msg, 'list);
          (%o5)  [0C7,56,7E,8B,39,0E2,42,8E,38,0BF,9C,92,26,0AC,68,0DE,4C,67,0DC,39]
          (%i6) sdowncase( printf(false, "~{~2,'0x~^:~}", octets) );
          (%o6)     c7:56:7e:8b:39:e2:42:8e:38:bf:9c:92:26:ac:68:de:4c:67:dc:39

     Sind in <arg> Umlaute oder andere Nicht-US-ASCII-Zeichen enthalten
     (bzw.  Oktette größer als 127), ist der 'SHA1'-Fingerabdruck von
     der verwendeten Plattform abhängig.

 -- Funktion: sha256sum (<arg>)
 -- Funktion: sha256sum (<arg>, <return-type>)

     Gibt den 'SHA256'-Fingerabdruck einer Zeichenkette, einer
     nicht-negativen Ganzzahl oder einer Liste von Oktetten zurück.  Der
     standardmäßige Rückgabewert ist eine Zeichenkette mit 64
     hexadezimalen Zeichen.

     Das optionale Argument <return-type> erlaubt es 'sha256sum',
     alternativ hierzu auch die entsprechende Ganzzahl oder Liste von
     Oktetten zurück zu geben (siehe *note sha1sum::).

     Beispiel:

          (%i1) string: sha256sum("foo bar baz");
          (%o1)  dbd318c1c462aee872f41109a4dfd3048871a03dedd0fe0e757ced57dad6f2d7

     Sind in <arg> Umlaute oder andere Nicht-US-ASCII-Zeichen enthalten
     (bzw.  Oktette größer als 127), ist der 'SHA256'-Fingerabdruck von
     der verwendeten Plattform abhängig.

 -- Funktion: string_to_octets (<string>)
 -- Funktion: string_to_octets (<string>, <encoding>)

     Kodiert den aktuellen Systemstandards entsprechend die Zeichenkette
     <string> in eine Liste von Oktetten.  Bei der Kodierung von
     Zeichenketten, die nicht ausschließlich US-ASCII-Zeichen enthalten,
     ist das Ergebnis abhängig von der Plattform, der Anwendung und vom
     unter Maxima liegenden Lisp.

     In dem Fall, dass UTF-8 das externe Format des Lisp Readers ist,
     kann das optionale Argument <encoding> genutzt werden, um für die
     String-Oktett-Umwandlung eine gewÃ¼nschte Kodierung auszuwählen.
     Siehe *note adjust_external_format::, falls es notwendig sein
     sollte, hierfür das externe Format zu ändern.

     Siehe *note octets_to_string:: für Beispiele und zusätzliche
     Informationen.


File: maxima.info,  Node: symmetries,  Next: to_poly_solve,  Prev: stringproc,  Up: Top

74 symmetries
*************

* Menu:

* Introduction to Symmetries::
* Functions and Variables for Symmetries::


File: maxima.info,  Node: Introduction to Symmetries,  Next: Functions and Variables for Symmetries,  Prev: symmetries,  Up: symmetries

74.1 Introduction to Symmetries
===============================

'sym' is a package for working with symmetric groups of polynomials.

It was written for Macsyma-Symbolics by Annick Valibouze
(<http://www-calfor.lip6.fr/~avb/>).  The algorithms are described in
the following papers:

  1. Fonctions symétriques et changements de bases.  Annick Valibouze.
     EUROCAL'87 (Leipzig, 1987), 323-332, Lecture Notes in Comput.  Sci
     378.  Springer, Berlin, 1989.
     <http://www.stix.polytechnique.fr/publications/1984-1994.html>

  2. Résolvantes et fonctions symétriques.  Annick Valibouze.
     Proceedings of the ACM-SIGSAM 1989 International Symposium on
     Symbolic and Algebraic Computation, ISSAC'89 (Portland, Oregon).
     ACM Press, 390-399, 1989.
     <http://www-calfor.lip6.fr/~avb/DonneesTelechargeables/MesArticles/issac89ACMValibouze.pdf>

  3. Symbolic computation with symmetric polynomials, an extension to
     Macsyma.  Annick Valibouze.  Computers and Mathematics (MIT, USA,
     June 13-17, 1989), Springer-Verlag, New York Berlin, 308-320, 1989.
     <http://www.stix.polytechnique.fr/publications/1984-1994.html>

  4. Théorie de Galois Constructive.  Annick Valibouze.  Mémoire
     d'habilitation à diriger les recherches (HDR), Université P. et M.
     Curie (Paris VI), 1994.


File: maxima.info,  Node: Functions and Variables for Symmetries,  Prev: Introduction to Symmetries,  Up: symmetries

74.2 Functions and Variables for Symmetries
===========================================

74.2.1 Changing bases
---------------------

 -- Function: comp2pui (<n>, <L>)

     implements passing from the complete symmetric functions given in
     the list <L> to the elementary symmetric functions from 0 to <n>.
     If the list <L> contains fewer than <n+1> elements, it will be
     completed with formal values of the type <h1>, <h2>, etc.  If the
     first element of the list <L> exists, it specifies the size of the
     alphabet, otherwise the size is set to <n>.

          (%i1) comp2pui (3, [4, g]);
                                  2                    2
          (%o1)    [4, g, 2 h2 - g , 3 h3 - g h2 + g (g  - 2 h2)]

 -- Function: ele2pui (<m>, <L>)

     goes from the elementary symmetric functions to the complete
     functions.  Similar to 'comp2ele' and 'comp2pui'.

     Other functions for changing bases: 'comp2ele'.

 -- Function: ele2comp (<m>, <L>)

     Goes from the elementary symmetric functions to the compete
     functions.  Similar to 'comp2ele' and 'comp2pui'.

     Other functions for changing bases: 'comp2ele'.

 -- Function: elem (<ele>, <sym>, <lvar>)

     decomposes the symmetric polynomial <sym>, in the variables
     contained in the list <lvar>, in terms of the elementary symmetric
     functions given in the list <ele>.  If the first element of <ele>
     is given, it will be the size of the alphabet, otherwise the size
     will be the degree of the polynomial <sym>.  If values are missing
     in the list <ele>, formal values of the type <e1>, <e2>, etc.  will
     be added.  The polynomial <sym> may be given in three different
     forms: contracted ('elem' should then be 1, its default value),
     partitioned ('elem' should be 3), or extended (i.e.  the entire
     polynomial, and 'elem' should then be 2).  The function 'pui' is
     used in the same way.

     On an alphabet of size 3 with <e1>, the first elementary symmetric
     function, with value 7, the symmetric polynomial in 3 variables
     whose contracted form (which here depends on only two of its
     variables) is <x^4-2*x*y> decomposes as follows in elementary
     symmetric functions:

          (%i1) elem ([3, 7], x^4 - 2*x*y, [x, y]);
          (%o1) 7 (e3 - 7 e2 + 7 (49 - e2)) + 21 e3

                                                   + (- 2 (49 - e2) - 2) e2
          (%i2) ratsimp (%);
                                        2
          (%o2)             28 e3 + 2 e2  - 198 e2 + 2401

     Other functions for changing bases: 'comp2ele'.

 -- Function: mon2schur (<L>)

     The list <L> represents the Schur function S_L: we have L = [i_1,
     i_2, ..., i_q], with i_1 <= i_2 <= ... <= i_q.  The Schur function
     S_[i_1, i_2, ..., i_q] is the minor of the infinite matrix h_[i-j],
     i <= 1, j <= 1, consisting of the q first rows and the columns 1 +
     i_1, 2 + i_2, ..., q + i_q.

     This Schur function can be written in terms of monomials by using
     'treinat' and 'kostka'.  The form returned is a symmetric
     polynomial in a contracted representation in the variables
     x_1,x_2,...

          (%i1) mon2schur ([1, 1, 1]);
          (%o1)                       x1 x2 x3
          (%i2) mon2schur ([3]);
                                            2        3
          (%o2)                x1 x2 x3 + x1  x2 + x1
          (%i3) mon2schur ([1, 2]);
                                                2
          (%o3)                  2 x1 x2 x3 + x1  x2

     which means that for 3 variables this gives:

             2 x1 x2 x3 + x1^2 x2 + x2^2 x1 + x1^2 x3 + x3^2 x1
              + x2^2 x3 + x3^2 x2
     Other functions for changing bases: 'comp2ele'.

 -- Function: multi_elem (<l_elem>, <multi_pc>, <l_var>)

     decomposes a multi-symmetric polynomial in the multi-contracted
     form <multi_pc> in the groups of variables contained in the list of
     lists <l_var> in terms of the elementary symmetric functions
     contained in <l_elem>.

          (%i1) multi_elem ([[2, e1, e2], [2, f1, f2]], a*x + a^2 + x^3,
                [[x, y], [a, b]]);
                                                            3
          (%o1)         - 2 f2 + f1 (f1 + e1) - 3 e1 e2 + e1
          (%i2) ratsimp (%);
                                   2                       3
          (%o2)         - 2 f2 + f1  + e1 f1 - 3 e1 e2 + e1

     Other functions for changing bases: 'comp2ele'.

 -- Function: multi_pui

     is to the function 'pui' what the function 'multi_elem' is to the
     function 'elem'.

          (%i1) multi_pui ([[2, p1, p2], [2, t1, t2]], a*x + a^2 + x^3,
                [[x, y], [a, b]]);
                                                      3
                                          3 p1 p2   p1
          (%o1)              t2 + p1 t1 + ------- - ---
                                             2       2

 -- Function: pui (<L>, <sym>, <lvar>)

     decomposes the symmetric polynomial <sym>, in the variables in the
     list <lvar>, in terms of the power functions in the list <L>.  If
     the first element of <L> is given, it will be the size of the
     alphabet, otherwise the size will be the degree of the polynomial
     <sym>.  If values are missing in the list <L>, formal values of the
     type <p1>, <p2> , etc.  will be added.  The polynomial <sym> may be
     given in three different forms: contracted ('elem' should then be
     1, its default value), partitioned ('elem' should be 3), or
     extended (i.e.  the entire polynomial, and 'elem' should then be
     2).  The function 'pui' is used in the same way.

          (%i1) pui;
          (%o1)                           1
          (%i2) pui ([3, a, b], u*x*y*z, [x, y, z]);
                                 2
                             a (a  - b) u   (a b - p3) u
          (%o2)              ------------ - ------------
                                  6              3
          (%i3) ratsimp (%);
                                                 3
                                (2 p3 - 3 a b + a ) u
          (%o3)                 ---------------------
                                          6
     Other functions for changing bases: 'comp2ele'.

 -- Function: pui2comp (<n>, <lpui>)

     renders the list of the first <n> complete functions (with the
     length first) in terms of the power functions given in the list
     <lpui>.  If the list <lpui> is empty, the cardinal is <n>,
     otherwise it is its first element (as in 'comp2ele' and
     'comp2pui').

          (%i1) pui2comp (2, []);
                                                 2
                                          p2 + p1
          (%o1)                   [2, p1, --------]
                                             2
          (%i2) pui2comp (3, [2, a1]);
                                                      2
                                           a1 (p2 + a1 )
                                   2  p3 + ------------- + a1 p2
                            p2 + a1              2
          (%o2)     [2, a1, --------, --------------------------]
                               2                  3
          (%i3) ratsimp (%);
                                      2                     3
                               p2 + a1   2 p3 + 3 a1 p2 + a1
          (%o3)        [2, a1, --------, --------------------]
                                  2               6
     Other functions for changing bases: 'comp2ele'.

 -- Function: pui2ele (<n>, <lpui>)

     effects the passage from power functions to the elementary
     symmetric functions.  If the flag 'pui2ele' is 'girard', it will
     return the list of elementary symmetric functions from 1 to <n>,
     and if the flag is 'close', it will return the <n>-th elementary
     symmetric function.

     Other functions for changing bases: 'comp2ele'.

 -- Function: puireduc (<n>, <lpui>)

     <lpui> is a list whose first element is an integer <m>.  'puireduc'
     gives the first <n> power functions in terms of the first <m>.

          (%i1) puireduc (3, [2]);
                                                   2
                                             p1 (p1  - p2)
          (%o1)          [2, p1, p2, p1 p2 - -------------]
                                                   2
          (%i2) ratsimp (%);
                                                     3
                                         3 p1 p2 - p1
          (%o2)              [2, p1, p2, -------------]
                                               2

 -- Function: schur2comp (<P>, <l_var>)

     <P> is a polynomial in the variables of the list <l_var>.  Each of
     these variables represents a complete symmetric function.  In
     <l_var> the <i>-th complete symmetric function is represented by
     the concatenation of the letter 'h' and the integer <i>: 'h<i>'.
     This function expresses <P> in terms of Schur functions.

          (%i1) schur2comp (h1*h2 - h3, [h1, h2, h3]);
          (%o1)                         s
                                         1, 2
          (%i2) schur2comp (a*h3, [h3]);
          (%o2)                         s  a
                                         3

74.2.2 Changing representations
-------------------------------

 -- Function: cont2part (<pc>, <lvar>)

     returns the partitioned polynomial associated to the contracted
     form <pc> whose variables are in <lvar>.

          (%i1) pc: 2*a^3*b*x^4*y + x^5;
                                     3    4      5
          (%o1)                   2 a  b x  y + x
          (%i2) cont2part (pc, [x, y]);
                                             3
          (%o2)              [[1, 5, 0], [2 a  b, 4, 1]]

 -- Function: contract (<psym>, <lvar>)

     returns a contracted form (i.e.  a monomial orbit under the action
     of the symmetric group) of the polynomial <psym> in the variables
     contained in the list <lvar>.  The function 'explose' performs the
     inverse operation.  The function 'tcontract' tests the symmetry of
     the polynomial.

          (%i1) psym: explose (2*a^3*b*x^4*y, [x, y, z]);
                   3      4      3      4      3    4        3    4
          (%o1) 2 a  b y z  + 2 a  b x z  + 2 a  b y  z + 2 a  b x  z

                                                     3      4      3    4
                                                + 2 a  b x y  + 2 a  b x  y
          (%i2) contract (psym, [x, y, z]);
                                        3    4
          (%o2)                      2 a  b x  y

 -- Function: explose (<pc>, <lvar>)

     returns the symmetric polynomial associated with the contracted
     form <pc>.  The list <lvar> contains the variables.

          (%i1) explose (a*x + 1, [x, y, z]);
          (%o1)                  a z + a y + a x + 1

 -- Function: part2cont (<ppart>, <lvar>)

     goes from the partitioned form to the contracted form of a
     symmetric polynomial.  The contracted form is rendered with the
     variables in <lvar>.

          (%i1) part2cont ([[2*a^3*b, 4, 1]], [x, y]);
                                        3    4
          (%o1)                      2 a  b x  y

 -- Function: partpol (<psym>, <lvar>)

     <psym> is a symmetric polynomial in the variables of the list
     <lvar>.  This function retturns its partitioned representation.

          (%i1) partpol (-a*(x + y) + 3*x*y, [x, y]);
          (%o1)               [[3, 1, 1], [- a, 1, 0]]

 -- Function: tcontract (<pol>, <lvar>)

     tests if the polynomial <pol> is symmetric in the variables of the
     list <lvar>.  If so, it returns a contracted representation like
     the function 'contract'.

 -- Function: tpartpol (<pol>, <lvar>)

     tests if the polynomial <pol> is symmetric in the variables of the
     list <lvar>.  If so, it returns its partitioned representation like
     the function 'partpol'.

74.2.3 Groups and orbits
------------------------

 -- Function: direct ([<p_1>, ..., <p_n>], <y>, <f>, [<lvar_1>, ...,
          <lvar_n>])
     calculates the direct image (see M. Giusti, D. Lazard et A.
     Valibouze, ISSAC 1988, Rome) associated to the function <f>, in the
     lists of variables <lvar_1>, ..., <lvar_n>, and in the polynomials
     <p_1>, ..., <p_n> in a variable <y>.  The arity of the function <f>
     is important for the calulation.  Thus, if the expression for <f>
     does not depend on some variable, it is useless to include this
     variable, and not including it will also considerably reduce the
     amount of computation.

          (%i1) direct ([z^2  - e1* z + e2, z^2  - f1* z + f2],
                        z, b*v + a*u, [[u, v], [a, b]]);
                 2
          (%o1) y  - e1 f1 y

                                           2            2             2   2
                            - 4 e2 f2 - (e1  - 2 e2) (f1  - 2 f2) + e1  f1
                          + -----------------------------------------------
                                                   2
          (%i2) ratsimp (%);
                        2                2                   2
          (%o2)        y  - e1 f1 y + (e1  - 4 e2) f2 + e2 f1
          (%i3) ratsimp (direct ([z^3-e1*z^2+e2*z-e3,z^2  - f1* z + f2],
                        z, b*v + a*u, [[u, v], [a, b]]));
                 6            5         2                        2    2   4
          (%o3) y  - 2 e1 f1 y  + ((2 e1  - 6 e2) f2 + (2 e2 + e1 ) f1 ) y

                                    3                               3   3
           + ((9 e3 + 5 e1 e2 - 2 e1 ) f1 f2 + (- 2 e3 - 2 e1 e2) f1 ) y

                   2       2        4    2
           + ((9 e2  - 6 e1  e2 + e1 ) f2

                              2       2       2                   2    4
           + (- 9 e1 e3 - 6 e2  + 3 e1  e2) f1  f2 + (2 e1 e3 + e2 ) f1 )

            2          2                      2     3          2
           y  + (((9 e1  - 27 e2) e3 + 3 e1 e2  - e1  e2) f1 f2

                           2            2    3                5
           + ((15 e2 - 2 e1 ) e3 - e1 e2 ) f1  f2 - 2 e2 e3 f1 ) y

                     2                   3           3     2   2    3
           + (- 27 e3  + (18 e1 e2 - 4 e1 ) e3 - 4 e2  + e1  e2 ) f2

                   2      3                   3    2   2
           + (27 e3  + (e1  - 9 e1 e2) e3 + e2 ) f1  f2

                             2    4        2   6
           + (e1 e2 e3 - 9 e3 ) f1  f2 + e3  f1

     Finding the polynomial whose roots are the sums a+u where a is a
     root of z^2 - e_1 z + e_2 and u is a root of z^2 - f_1 z + f_2.

          (%i1) ratsimp (direct ([z^2 - e1* z + e2, z^2 - f1* z + f2],
                                    z, a + u, [[u], [a]]));
                 4                    3             2
          (%o1) y  + (- 2 f1 - 2 e1) y  + (2 f2 + f1  + 3 e1 f1 + 2 e2

               2   2                              2               2
           + e1 ) y  + ((- 2 f1 - 2 e1) f2 - e1 f1  + (- 2 e2 - e1 ) f1

                            2                     2            2
           - 2 e1 e2) y + f2  + (e1 f1 - 2 e2 + e1 ) f2 + e2 f1  + e1 e2 f1

               2
           + e2

     'direct' accepts two flags: 'elementaires' and 'puissances'
     (default) which allow decomposing the symmetric polynomials
     appearing in the calculation into elementary symmetric functions,
     or power functions, respectively.

     Functions of 'sym' used in this function:

     'multi_orbit' (so 'orbit'), 'pui_direct', 'multi_elem' (so 'elem'),
     'multi_pui' (so 'pui'), 'pui2ele', 'ele2pui' (if the flag 'direct'
     is in 'puissances').

 -- Function: multi_orbit (<P>, [<lvar_1>, <lvar_2>,..., <lvar_p>])

     <P> is a polynomial in the set of variables contained in the lists
     <lvar_1>, <lvar_2>, ..., <lvar_p>.  This function returns the orbit
     of the polynomial <P> under the action of the product of the
     symmetric groups of the sets of variables represented in these <p>
     lists.

          (%i1) multi_orbit (a*x + b*y, [[x, y], [a, b]]);
          (%o1)                [b y + a x, a y + b x]
          (%i2) multi_orbit (x + y + 2*a, [[x, y], [a, b, c]]);
          (%o2)        [y + x + 2 c, y + x + 2 b, y + x + 2 a]
     Also see: 'orbit' for the action of a single symmetric group.

 -- Function: multsym (<ppart_1>, <ppart_2>, <n>)

     returns the product of the two symmetric polynomials in <n>
     variables by working only modulo the action of the symmetric group
     of order <n>.  The polynomials are in their partitioned form.

     Given the 2 symmetric polynomials in <x>, <y>: '3*(x + y) + 2*x*y'
     and '5*(x^2 + y^2)' whose partitioned forms are '[[3, 1], [2, 1,
     1]]' and '[[5, 2]]', their product will be

          (%i1) multsym ([[3, 1], [2, 1, 1]], [[5, 2]], 2);
          (%o1)         [[10, 3, 1], [15, 3, 0], [15, 2, 1]]
     that is '10*(x^3*y + y^3*x) + 15*(x^2*y + y^2*x) + 15*(x^3 + y^3)'.

     Functions for changing the representations of a symmetric
     polynomial:

     'contract', 'cont2part', 'explose', 'part2cont', 'partpol',
     'tcontract', 'tpartpol'.

 -- Function: orbit (<P>, <lvar>)

     computes the orbit of the polynomial <P> in the variables in the
     list <lvar> under the action of the symmetric group of the set of
     variables in the list <lvar>.

          (%i1) orbit (a*x + b*y, [x, y]);
          (%o1)                [a y + b x, b y + a x]
          (%i2) orbit (2*x + x^2, [x, y]);
                                  2         2
          (%o2)                 [y  + 2 y, x  + 2 x]
     See also 'multi_orbit' for the action of a product of symmetric
     groups on a polynomial.

 -- Function: pui_direct (<orbite>, [<lvar_1>, ..., <lvar_n>], [<d_1>,
          <d_2>, ..., <d_n>])

     Let <f> be a polynomial in <n> blocks of variables <lvar_1>, ...,
     <lvar_n>.  Let <c_i> be the number of variables in <lvar_i>, and
     <SC> be the product of <n> symmetric groups of degree <c_1>, ...,
     <c_n>.  This group acts naturally on <f>.  The list <orbite> is the
     orbit, denoted '<SC>(<f>)', of the function <f> under the action of
     <SC>.  (This list may be obtained by the function 'multi_orbit'.)
     The <di> are integers s.t.  c_1 <= d_1, c_2 <= d_2, ..., c_n <=
     d_n.

     Let <SD> be the product of the symmetric groups S_[d_1] x S_[d_2] x
     ... x S_[d_n].  The function 'pui_direct' returns the first <n>
     power functions of '<SD>(<f>)' deduced from the power functions of
     '<SC>(<f>)', where <n> is the size of '<SD>(<f>)'.

     The result is in multi-contracted form w.r.t.  <SD>, i.e.  only one
     element is kept per orbit, under the action of <SD>.

          (%i1) l: [[x, y], [a, b]];
          (%o1)                   [[x, y], [a, b]]
          (%i2) pui_direct (multi_orbit (a*x + b*y, l), l, [2, 2]);
                                                 2  2
          (%o2)               [a x, 4 a b x y + a  x ]
          (%i3) pui_direct (multi_orbit (a*x + b*y, l), l, [3, 2]);
                                       2  2     2    2        3  3
          (%o3) [2 a x, 4 a b x y + 2 a  x , 3 a  b x  y + 2 a  x ,

              2  2  2  2      3    3        4  4
          12 a  b  x  y  + 4 a  b x  y + 2 a  x ,

              3  2  3  2      4    4        5  5
          10 a  b  x  y  + 5 a  b x  y + 2 a  x ,

              3  3  3  3       4  2  4  2      5    5        6  6
          40 a  b  x  y  + 15 a  b  x  y  + 6 a  b x  y + 2 a  x ]
          (%i4) pui_direct ([y + x + 2*c, y + x + 2*b, y + x + 2*a],
                [[x, y], [a, b, c]], [2, 3]);
                                       2              2
          (%o4) [3 x + 2 a, 6 x y + 3 x  + 4 a x + 4 a ,

                           2                   3        2       2        3
                        9 x  y + 12 a x y + 3 x  + 6 a x  + 12 a  x + 8 a ]

74.2.4 Partitions
-----------------

 -- Function: kostka (<part_1>, <part_2>)

     written by P. Esperet, calculates the Kostka number of the
     partition <part_1> and <part_2>.

          (%i1) kostka ([3, 3, 3], [2, 2, 2, 1, 1, 1]);
          (%o1)                           6

 -- Function: lgtreillis (<n>, <m>)

     returns the list of partitions of weight <n> and length <m>.

          (%i1) lgtreillis (4, 2);
          (%o1)                   [[3, 1], [2, 2]]
     Also see: 'ltreillis', 'treillis' and 'treinat'.

 -- Function: ltreillis (<n>, <m>)

     returns the list of partitions of weight <n> and length less than
     or equal to <m>.

          (%i1) ltreillis (4, 2);
          (%o1)               [[4, 0], [3, 1], [2, 2]]
     Also see: 'lgtreillis', 'treillis' and 'treinat'.

 -- Function: treillis (<n>)

     returns all partitions of weight <n>.

          (%i1) treillis (4);
          (%o1)    [[4], [3, 1], [2, 2], [2, 1, 1], [1, 1, 1, 1]]

     See also: 'lgtreillis', 'ltreillis' and 'treinat'.

 -- Function: treinat (<part>)

     retruns the list of partitions inferior to the partition <part>
     w.r.t.  the natural order.

          (%i1) treinat ([5]);
          (%o1)                         [[5]]
          (%i2) treinat ([1, 1, 1, 1, 1]);
          (%o2) [[5], [4, 1], [3, 2], [3, 1, 1], [2, 2, 1], [2, 1, 1, 1],

                                                           [1, 1, 1, 1, 1]]
          (%i3) treinat ([3, 2]);
          (%o3)                 [[5], [4, 1], [3, 2]]

     See also: 'lgtreillis', 'ltreillis' and 'treillis'.

74.2.5 Polynomials and their roots
----------------------------------

 -- Function: ele2polynome (<L>, <z>)

     returns the polynomial in <z> s.t.  the elementary symmetric
     functions of its roots are in the list '<L> = [<n>, <e_1>, ...,
     <e_n>]', where <n> is the degree of the polynomial and <e_i> the
     <i>-th elementary symmetric function.

          (%i1) ele2polynome ([2, e1, e2], z);
                                    2
          (%o1)                    z  - e1 z + e2
          (%i2) polynome2ele (x^7 - 14*x^5 + 56*x^3  - 56*x + 22, x);
          (%o2)          [7, 0, - 14, 0, 56, 0, - 56, - 22]
          (%i3) ele2polynome ([7, 0, -14, 0, 56, 0, -56, -22], x);
                            7       5       3
          (%o3)            x  - 14 x  + 56 x  - 56 x + 22
     The inverse: 'polynome2ele (<P>, <z>)'.

     Also see: 'polynome2ele', 'pui2polynome'.

 -- Function: polynome2ele (<P>, <x>)

     gives the list '<l> = [<n>, <e_1>, ..., <e_n>]' where <n> is the
     degree of the polynomial <P> in the variable <x> and <e_i> is the
     <i>-the elementary symmetric function of the roots of <P>.

          (%i1) polynome2ele (x^7 - 14*x^5 + 56*x^3 - 56*x + 22, x);
          (%o1)          [7, 0, - 14, 0, 56, 0, - 56, - 22]
          (%i2) ele2polynome ([7, 0, -14, 0, 56, 0, -56, -22], x);
                            7       5       3
          (%o2)            x  - 14 x  + 56 x  - 56 x + 22
     The inverse: 'ele2polynome (<l>, <x>)'

 -- Function: prodrac (<L>, <k>)

     <L> is a list containing the elementary symmetric functions on a
     set <A>.  'prodrac' returns the polynomial whose roots are the <k>
     by <k> products of the elements of <A>.

     Also see 'somrac'.

 -- Function: pui2polynome (<x>, <lpui>)

     calculates the polynomial in <x> whose power functions of the roots
     are given in the list <lpui>.

          (%i1) pui;
          (%o1)                           1
          (%i2) kill(labels);
          (%o0)                         done
          (%i1) polynome2ele (x^3 - 4*x^2 + 5*x - 1, x);
          (%o1)                     [3, 4, 5, 1]
          (%i2) ele2pui (3, %);
          (%o2)                     [3, 4, 6, 7]
          (%i3) pui2polynome (x, %);
                                  3      2
          (%o3)                  x  - 4 x  + 5 x - 1
     See also: 'polynome2ele', 'ele2polynome'.

 -- Function: somrac (<L>, <k>)

     The list <L> contains elementary symmetric functions of a
     polynomial <P> .  The function computes the polynomial whose roots
     are the <k> by <k> distinct sums of the roots of <P>.

     Also see 'prodrac'.

74.2.6 Resolvents
-----------------

 -- Function: resolvante (<P>, <x>, <f>, [<x_1>,..., <x_d>])

     calculates the resolvent of the polynomial <P> in <x> of degree <n>
     >= <d> by the function <f> expressed in the variables <x_1>, ...,
     <x_d>.  For efficiency of computation it is important to not
     include in the list '[<x_1>, ..., <x_d>]' variables which do not
     appear in the transformation function <f>.

     To increase the efficiency of the computation one may set flags in
     'resolvante' so as to use appropriate algorithms:

     If the function <f> is unitary:
        * A polynomial in a single variable,
        * linear,
        * alternating,
        * a sum,
        * symmetric,
        * a product,
        * the function of the Cayley resolvent (usable up to degree 5)

               (x1*x2 + x2*x3 + x3*x4 + x4*x5 + x5*x1 -
                    (x1*x3 + x3*x5 + x5*x2 + x2*x4 + x4*x1))^2

          general,
     the flag of 'resolvante' may be, respectively:
        * unitaire,
        * lineaire,
        * alternee,
        * somme,
        * produit,
        * cayley,
        * generale.

          (%i1) resolvante: unitaire$
          (%i2) resolvante (x^7 - 14*x^5 + 56*x^3 - 56*x + 22, x, x^3 - 1,
                [x]);

          " resolvante unitaire " [7, 0, 28, 0, 168, 0, 1120, - 154, 7840,
                                   - 2772, 56448, - 33880,

          413952, - 352352, 3076668, - 3363360, 23114112, - 30494464,

          175230832, - 267412992, 1338886528, - 2292126760]
            3       6      3       9      6      3
          [x  - 1, x  - 2 x  + 1, x  - 3 x  + 3 x  - 1,

           12      9      6      3       15      12       9       6      3
          x   - 4 x  + 6 x  - 4 x  + 1, x   - 5 x   + 10 x  - 10 x  + 5 x

                 18      15       12       9       6      3
           - 1, x   - 6 x   + 15 x   - 20 x  + 15 x  - 6 x  + 1,

           21      18       15       12       9       6      3
          x   - 7 x   + 21 x   - 35 x   + 35 x  - 21 x  + 7 x  - 1]
          [- 7, 1127, - 6139, 431767, - 5472047, 201692519, - 3603982011]
                 7      6        5         4          3           2
          (%o2) y  + 7 y  - 539 y  - 1841 y  + 51443 y  + 315133 y

                                                        + 376999 y + 125253
          (%i3) resolvante: lineaire$
          (%i4) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3]);

          " resolvante lineaire "
                 24       20         16            12             8
          (%o4) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i5) resolvante: general$
          (%i6) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3]);

          " resolvante generale "
                 24       20         16            12             8
          (%o6) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i7) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3, x4]);

          " resolvante generale "
                 24       20         16            12             8
          (%o7) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i8) direct ([x^4 - 1], x, x1 + 2*x2 + 3*x3, [[x1, x2, x3]]);
                 24       20         16            12             8
          (%o8) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i9) resolvante :lineaire$
          (%i10) resolvante (x^4 - 1, x, x1 + x2 + x3, [x1, x2, x3]);

          " resolvante lineaire "
                                        4
          (%o10)                       y  - 1
          (%i11) resolvante: symetrique$
          (%i12) resolvante (x^4 - 1, x, x1 + x2 + x3, [x1, x2, x3]);

          " resolvante symetrique "
                                        4
          (%o12)                       y  - 1
          (%i13) resolvante (x^4 + x + 1, x, x1 - x2, [x1, x2]);

          " resolvante symetrique "
                                     6      2
          (%o13)                    y  - 4 y  - 1
          (%i14) resolvante: alternee$
          (%i15) resolvante (x^4 + x + 1, x, x1 - x2, [x1, x2]);

          " resolvante alternee "
                      12      8       6        4        2
          (%o15)     y   + 8 y  + 26 y  - 112 y  + 216 y  + 229
          (%i16) resolvante: produit$
          (%i17) resolvante (x^7 - 7*x + 3, x, x1*x2*x3, [x1, x2, x3]);

          " resolvante produit "
                  35      33         29        28         27        26
          (%o17) y   - 7 y   - 1029 y   + 135 y   + 7203 y   - 756 y

                   24           23          22            21           20
           + 1323 y   + 352947 y   - 46305 y   - 2463339 y   + 324135 y

                    19           18             17              15
           - 30618 y   - 453789 y   - 40246444 y   + 282225202 y

                       14              12             11            10
           - 44274492 y   + 155098503 y   + 12252303 y   + 2893401 y

                        9            8            7             6
           - 171532242 y  + 6751269 y  + 2657205 y  - 94517766 y

                      5             3
           - 3720087 y  + 26040609 y  + 14348907
          (%i18) resolvante: symetrique$
          (%i19) resolvante (x^7 - 7*x + 3, x, x1*x2*x3, [x1, x2, x3]);

          " resolvante symetrique "
                  35      33         29        28         27        26
          (%o19) y   - 7 y   - 1029 y   + 135 y   + 7203 y   - 756 y

                   24           23          22            21           20
           + 1323 y   + 352947 y   - 46305 y   - 2463339 y   + 324135 y

                    19           18             17              15
           - 30618 y   - 453789 y   - 40246444 y   + 282225202 y

                       14              12             11            10
           - 44274492 y   + 155098503 y   + 12252303 y   + 2893401 y

                        9            8            7             6
           - 171532242 y  + 6751269 y  + 2657205 y  - 94517766 y

                      5             3
           - 3720087 y  + 26040609 y  + 14348907
          (%i20) resolvante: cayley$
          (%i21) resolvante (x^5 - 4*x^2 + x + 1, x, a, []);

          " resolvante de Cayley "
                  6       5         4          3            2
          (%o21) x  - 40 x  + 4080 x  - 92928 x  + 3772160 x  + 37880832 x

                                                                 + 93392896

     For the Cayley resolvent, the 2 last arguments are neutral and the
     input polynomial must necessarily be of degree 5.

     See also:
     'resolvante_bipartite', 'resolvante_produit_sym',
     'resolvante_unitaire', 'resolvante_alternee1', 'resolvante_klein',
     'resolvante_klein3', 'resolvante_vierer', 'resolvante_diedrale'.

 -- Function: resolvante_alternee1 (<P>, <x>)

     calculates the transformation '<P>(<x>)' of degree <n> by the
     function product(x_i - x_j, 1 <= i < j <= n - 1).

     See also:
     'resolvante_produit_sym', 'resolvante_unitaire',
     'resolvante' , 'resolvante_klein', 'resolvante_klein3',
     'resolvante_vierer', 'resolvante_diedrale', 'resolvante_bipartite'.

 -- Function: resolvante_bipartite (<P>, <x>)

     calculates the transformation of '<P>(<x>)' of even degree <n> by
     the function x_1 x_2 ... x_[n/2] + x_[n/2 + 1] ... x_n.

     See also:
     'resolvante_produit_sym', 'resolvante_unitaire',
     'resolvante' , 'resolvante_klein', 'resolvante_klein3',
     'resolvante_vierer', 'resolvante_diedrale', 'resolvante_alternee1'.

          (%i1) resolvante_bipartite (x^6 + 108, x);
                        10        8           6             4
          (%o1)        y   - 972 y  + 314928 y  - 34012224 y

     See also:
     'resolvante_produit_sym', 'resolvante_unitaire',
     'resolvante', 'resolvante_klein', 'resolvante_klein3',
     'resolvante_vierer', 'resolvante_diedrale',
     'resolvante_alternee1'.

 -- Function: resolvante_diedrale (<P>, <x>)

     calculates the transformation of '<P>(<x>)' by the function '<x_1>
     <x_2> + <x_3> <x_4>'.

          (%i1) resolvante_diedrale (x^5 - 3*x^4 + 1, x);
                 15       12       11       10        9         8         7
          (%o1) x   - 21 x   - 81 x   - 21 x   + 207 x  + 1134 x  + 2331 x

                  6         5          4          3          2
           - 945 x  - 4970 x  - 18333 x  - 29079 x  - 20745 x  - 25326 x

           - 697

     See also:
     'resolvante_produit_sym', 'resolvante_unitaire',
     'resolvante_alternee1', 'resolvante_klein', 'resolvante_klein3',
     'resolvante_vierer', 'resolvante'.

 -- Function: resolvante_klein (<P>, <x>)

     calculates the transformation of '<P>(<x>)' by the function '<x_1>
     <x_2> <x_4> + <x_4>'.

     See also:
     'resolvante_produit_sym', 'resolvante_unitaire',
     'resolvante_alternee1', 'resolvante', 'resolvante_klein3',
     'resolvante_vierer', 'resolvante_diedrale'.

 -- Function: resolvante_klein3 (<P>, <x>)

     calculates the transformation of '<P>(<x>)' by the function '<x_1>
     <x_2> <x_4> + <x_4>'.

     See also:
     'resolvante_produit_sym', 'resolvante_unitaire',
     'resolvante_alternee1', 'resolvante_klein', 'resolvante',
     'resolvante_vierer', 'resolvante_diedrale'.

 -- Function: resolvante_produit_sym (<P>, <x>)

     calculates the list of all product resolvents of the polynomial
     '<P>(<x>)'.

          (%i1) resolvante_produit_sym (x^5 + 3*x^4 + 2*x - 1, x);
                  5      4             10      8       7       6       5
          (%o1) [y  + 3 y  + 2 y - 1, y   - 2 y  - 21 y  - 31 y  - 14 y

              4       3      2       10      8       7    6       5       4
           - y  + 14 y  + 3 y  + 1, y   + 3 y  + 14 y  - y  - 14 y  - 31 y

                 3      2       5      4
           - 21 y  - 2 y  + 1, y  - 2 y  - 3 y - 1, y - 1]
          (%i2) resolvante: produit$
          (%i3) resolvante (x^5 + 3*x^4 + 2*x - 1, x, a*b*c, [a, b, c]);

          " resolvante produit "
                 10      8       7    6        5       4       3     2
          (%o3) y   + 3 y  + 14 y  - y  - 14 y  - 31 y  - 21 y  - 2 y  + 1

     See also:
     'resolvante', 'resolvante_unitaire',
     'resolvante_alternee1', 'resolvante_klein',
     'resolvante_klein3', 'resolvante_vierer',
     'resolvante_diedrale'.

 -- Function: resolvante_unitaire (<P>, <Q>, <x>)

     computes the resolvent of the polynomial '<P>(<x>)' by the
     polynomial '<Q>(<x>)'.

     See also:
     'resolvante_produit_sym', 'resolvante',
     'resolvante_alternee1', 'resolvante_klein', 'resolvante_klein3',
     'resolvante_vierer', 'resolvante_diedrale'.

 -- Function: resolvante_vierer (<P>, <x>)

     computes the transformation of '<P>(<x>)' by the function '<x_1>
     <x_2> - <x_3> <x_4>'.

     See also:
     'resolvante_produit_sym', 'resolvante_unitaire',
     'resolvante_alternee1', 'resolvante_klein', 'resolvante_klein3',
     'resolvante', 'resolvante_diedrale'.

74.2.7 Miscellaneous
--------------------

 -- Function: multinomial (<r>, <part>)

     where <r> is the weight of the partition <part>.  This function
     returns the associate multinomial coefficient: if the parts of
     <part> are <i_1>, <i_2>, ..., <i_k>, the result is '<r>!/(<i_1>!
     <i_2>! ... <i_k>!)'.

 -- Function: permut (<L>)

     returns the list of permutations of the list <L>.

