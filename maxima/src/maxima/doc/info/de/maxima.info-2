This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.


File: maxima.info,  Node: Nutzerdefinierte Operatoren,  Prev: Zuweisungsoperatoren,  Up: Operatoren

7.7 Nutzerdefinierte Operatoren
===============================

* Menu:

* Einführung in nutzerdefinierte Operatoren::
* Funktionen und Variablen für nutzerdefinierte Operatoren::


File: maxima.info,  Node: Einführung in nutzerdefinierte Operatoren,  Next: Funktionen und Variablen für nutzerdefinierte Operatoren,  Prev: Nutzerdefinierte Operatoren,  Up: Nutzerdefinierte Operatoren

7.7.1 Einführung in nutzerdefinierte Operatoren
-----------------------------------------------

Es ist möglich neue Operatoren zu definieren, vorhandene Operatoren zu
entfernen oder deren Eigenschaften zu ändern.  Jede Funktion kann als
ein Operator definiert werden, die Funktion kann, muss aber nicht
definiert sein.

Im Folgenden werden die Operatoren 'dd' und '"<-"' definiert.  Nach der
Definition als Operatoren ist 'dd a' gleichbedeutend mit '"dd"(a)' und
'a <- b' entspricht dem Funktionsaufruf '"<-"(a,b)'.  In diesem Beispiel
sind die Funktionen '"dd"' und '"<-"' nicht definiert.

     (%i1) prefix ("dd");
     (%o1)                          dd
     (%i2) dd a;
     (%o2)                         dd a
     (%i3) "dd" (a);
     (%o3)                         dd a
     (%i4) infix ("<-");
     (%o4)                          <-
     (%i5) a <- dd b;
     (%o5)                      a <- dd b
     (%i6) "<-" (a, "dd" (b));
     (%o6)                      a <- dd b

Maxima kennt die folgenden Funktionen, um Operatoren zu definieren:
'prefix', 'postfix', 'infix', 'nary', 'matchfix' und 'nofix'.

Der Vorrang eines Operators <op> vor anderen Operatoren leitet sich aus
dem links- und rechtsseitigen Vorrang des Operators ab.  Sind die links-
und rechtsseitigen Vorränge von <op> beide größer als der links- und
rechtsseitige Vorrang eines anderen Operators, dann hat <op> Vorrang vor
diesem Operator.  Sind die Vorränge nicht beide größer oder kleiner,
werden weitere Regeln zur Bestimmung des Vorrangs herangezogen.

Maxima kennt die Wortart eines Operanden und des Ergebnisses eines
Operanden.  Wortart bedeutet hier, den Typ eines Operanden.  Maxima
kennt die drei Typen 'expr', 'clause' und 'any'.  Diese stehen für einen
algebraischen Ausdruck, einen logischen Ausdruck und einen beliebigen
Ausdruck.  Mit Hilfe der für einen Operator definierten Wortart kann der
Parser beim Einlesen eines Ausdrucks Syntaxfehler feststellen.

Die Assoziativität eines Operators <op> hängt ab von seinem Vorrang.
Ein größerer linksseitiger Vorrang hat zur Folge, dass der Operator <op>
vor einem anderen Operator auf seiner linken Seite ausgewertet wird.
Während ein größerer rechtsseitiger Vorrang zur Folge hat, dass der
Operator vor anderen Operatoren auf der rechten Seite ausgewertet wird.
Daraus folgt, dass ein größerer linksseitiger Vorrang <lbp> einen
Operator <op> rechts-assoziativ und eine größerer rechtsseitiger Vorrang
<rbp> den Operator links-assoziativ macht.  Sind der links- und
rechtsseitige Vorrang gleich groß, ist der Operator <op>
links-assoziativ.

Mit den Befehlen 'remove' und 'kill' können Operatoreigenschaften von
einem Symbol entfernt werden.  'remove("<a>", op)' entfernt die
Operatoreigenschaften des Symbols <a>.  'kill("<a>")' entfernt alle
Eigenschaften einschließich der Operator-Eigenschaften des Symbols <a>.
In diesem Fall steht der Name des Symbols in Anführungszeichen.

     (%i1) infix ("##");
     (%o1)                          ##
     (%i2) "##" (a, b) := a^b;
                                          b
     (%o2)                     a ## b := a
     (%i3) 5 ## 3;
     (%o3)                          125
     (%i4) remove ("##", op);
     (%o4)                         done
     (%i5) 5 ## 3;
     Incorrect syntax: # is not a prefix operator
     5 ##
       ^
     (%i5) "##" (5, 3);
     (%o5)                          125
     (%i6) infix ("##");
     (%o6)                          ##
     (%i7) 5 ## 3;
     (%o7)                          125
     (%i8) kill ("##");
     (%o8)                         done
     (%i9) 5 ## 3;
     Incorrect syntax: # is not a prefix operator
     5 ##
       ^
     (%i9) "##" (5, 3);
     (%o9)                       ##(5, 3)


File: maxima.info,  Node: Funktionen und Variablen für nutzerdefinierte Operatoren,  Prev: Einführung in nutzerdefinierte Operatoren,  Up: Nutzerdefinierte Operatoren

7.7.2 Funktionen und Variablen für nutzerdefinierte Operatoren
--------------------------------------------------------------

 -- Funktion: infix (<op>)
 -- Funktion: infix (<op>, <lbp>, <rbp>)
 -- Funktion: infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)

     Deklariert <op> als einen Infix-Operator.  Ein Infix-Operator hat
     eine Funktionsdefinition mit zwei Argumenten.  Der Infix-Operator
     steht zwischen den Operanden.  Zum Beispiel ist die Subtraktion '-'
     ein Infix-Operator.

     'infix(<op>)' deklariert <op> als einen Infix-Operator mit einem
     links- und rechtsseitigen Vorrang von jeweils 180.

     'infix(<op>, <lbp>, <rbp>)' deklariert <op> als einen
     Infix-Operator mit den angegebenen Werten für den links- und
     rechtsseitigen Vorrang.

     'infix(<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)' deklariert <op>
     als einen Infix-Operator mit den angegebenen Vorrängen sowie den
     Wortarten <lpos>, <rpos> und <pos> für den linken und den rechten
     Operanden sowie das Ergebnis des Operators.

     Beispiele:

     Sind die rechtsseitigen und linksseitigen Vorränge eines Operators
     <op> größer als die entsprechenden Vorränge eines anderen
     Operators, dann hat der Operator <op> Vorrang.

          (%i1) :lisp (get '$+ 'lbp)
          100
          (%i1) :lisp (get '$+ 'rbp)
          100
          (%i1) infix ("##", 101, 101);
          (%o1)                          ##
          (%i2) "##"(a, b) := sconcat("(", a, ",", b, ")");
          (%o2)       (a ## b) := sconcat("(", a, ",", b, ")")
          (%i3) 1 + a ## b + 2;
          (%o3)                       (a,b) + 3
          (%i4) infix ("##", 99, 99);
          (%o4)                          ##
          (%i5) 1 + a ## b + 2;
          (%o5)                       (a+1,b+2)

     Ein größerer linksseitige Vorrang <lbp> bewirkt, dass der Operator
     <op> rechts-assoziativ ist.  Ein größerer rechtsseitiger Vorrang
     macht dagegen den Operator <op> links-assoziativ.

          (%i1) infix ("##", 100, 99);
          (%o1)                          ##
          (%i2) "##"(a, b) := sconcat("(", a, ",", b, ")")$
          (%i3) foo ## bar ## baz;
          (%o3)                    (foo,(bar,baz))
          (%i4) infix ("##", 100, 101);
          (%o4)                          ##
          (%i5) foo ## bar ## baz;
          (%o5)                    ((foo,bar),baz)

     Maxima kann Syntaxfehler beim Einlesen eines Ausdrucks feststellen,
     wenn der eingelesene Operand nicht die für den Operator definierte
     Wortart hat.

          (%i1) infix ("##", 100, 99, expr, expr, expr);
          (%o1)                          ##
          (%i2) if x ## y then 1 else 0;
          Incorrect syntax: Found algebraic expression where
          logical expression expected
          if x ## y then
                       ^
          (%i2) infix ("##", 100, 99, expr, expr, clause);
          (%o2)                          ##
          (%i3) if x ## y then 1 else 0;
          (%o3)                if x ## y then 1 else 0

 -- Funktion: matchfix (<ldelimiter>, <rdelimiter>)
 -- Funktion: matchfix (<ldelimiter>, <rdelimiter>, <arg_pos>, <pos>)

     Deklariert einen Matchfix-Operator mit dem linksseitigen
     Begrenzungszeichen <ldelimiter> und dem rechtsseitigen
     Begrenzungszeichen <rdelimiter>.

     Ein Matchfix-Operator hat eine beliebige Anzahl an Argumenten, die
     zwischen dem linksseitigen und dem rechtsseitigen
     Begrenzungszeichen stehen.  Das Begrenzungszeichen kann eine
     beliebige Zeichenkette sein.  Einige Zeichen wie '%', ',', '$' und
     ';' können nicht als Begrenzungszeichen definiert werden.

     Ein linksseitiges Begrenzungszeichen kann nicht verschiedene
     rechtsseitige Begrenzungszeichen haben.

     Maxima-Operatoren können als Matchfix-Operatoren definiert werden,
     ohne dass sich die sonstigen Operatoreigenschaften ändern.  So kann
     zum Beispiel der Operator '+' als Matchfix-Operator definiert
     werden.

     'matchfix(<ldelimiter>, <rdelimiter>, <arg_pos>, <pos>)' definiert
     die Wortarten für die Argumente <arg_pos> und das Ergebnis <pos>
     sowie das linksseitige <ldelimiter> und rechtsseitige <rdelimiter>
     Begrenzungszeichen.

     Die zu einem Matchfix-Operator zugehörige Funktion kann jede
     nutzerdefinierte Funktion sein, die mit ':=' oder 'define'
     definiert wird.  Die Definition der Funktion kann mit
     'dispfun(<ldelimiter>)' ausgegeben werden.

     Maxima kennt nur den Operator für Listen '[ ]' als
     Matchfix-Operator.  Klammern '( )' und Anführungszeichen '" "'
     arbeiten wie Matchfix-Operatoren, werden aber vom Parser nicht als
     Matchfix-Operatoren behandelt.

     'matchfix' wertet die Argumente aus.  'matchfix' gibt das erste
     Argument <ldelimiter> als Ergebnis zurück.

     Beispiele:

     Begrenzungszeichen können eine beliebige Zeichenkette sein.

          (%i1) matchfix ("@@", "~");
          (%o1)                          @@
          (%i2) @@ a, b, c ~;
          (%o2)                      @@a, b, c~
          (%i3) matchfix (">>", "<<");
          (%o3)                          >>
          (%i4) >> a, b, c <<;
          (%o4)                      >>a, b, c<<
          (%i5) matchfix ("foo", "oof");
          (%o5)                          foo
          (%i6) foo a, b, c oof;
          (%o6)                     fooa, b, coof
          (%i7) >> w + foo x, y oof + z << / @@ p, q ~;
                               >>z + foox, yoof + w<<
          (%o7)                ----------------------
                                      @@p, q~

     Matchfix-Operatoren können für nutzerdefinierte Funktionen
     definiert werden.

          (%i1) matchfix ("!-", "-!");
          (%o1)                         "!-"
          (%i2) !- x, y -! := x/y - y/x;
                                              x   y
          (%o2)                   !-x, y-! := - - -
                                              y   x
          (%i3) define (!-x, y-!, x/y - y/x);
                                              x   y
          (%o3)                   !-x, y-! := - - -
                                              y   x
          (%i4) define ("!-" (x, y), x/y - y/x);
                                              x   y
          (%o4)                   !-x, y-! := - - -
                                              y   x
          (%i5) dispfun ("!-");
                                              x   y
          (%t5)                   !-x, y-! := - - -
                                              y   x

          (%o5)                         done
          (%i6) !-3, 5-!;
                                          16
          (%o6)                         - --
                                          15
          (%i7) "!-" (3, 5);
                                          16
          (%o7)                         - --
                                          15

 -- Funktion: nary (<op>)
 -- Funktion: nary (<op>, <bp>, <arg_pos>, <pos>)

     'nary(<op>)' definiert einen 'N-ary'-Operator <op> mit einem
     linksseitigen Vorrang von 180.  Der rechtsseitige Vorrang wird
     nicht benötigt.

     'nary(<op>, <bp>, <arg_pos>, <pos>)' definiert einen
     'N-ary'-Operator <op> mit einem rechtsseitigen Vorrang von <bp> und
     der Wortart <arg_pos> für den Operanden und der Wortart <pos> fÃ¼r
     das Ergebnis.

     Ein 'N-ary'-Operator ist ein Operator, der eine beliebige Anzahl an
     Argumenten haben kann.  Die Argumente werden durch den Operator
     voneinander getrennt, so ist zum Beispiel '+' ein 'N-ary'-Operator
     und 'A+B+C'.

     Im Unterschied zur Definition eines Operators kann eine Funktion
     'f' auch als 'nary' mit der Funktion 'declare' deklariert werden.
     Die Deklaration hat Auswirkung auf die Vereinfachung der Funktion.
     Zum Beispiel wird ein Ausdruck 'j(j(a,b),j(c,d)' zu 'j(a,b,c,d)'
     vereinfacht.

 -- Funktion: nofix (<op>)
 -- Funktion: nofix (<op>, <pos>)

     'nofix(<op>)' definiert den Operator <op> als einen Nofix-Operator.

     'nofix(<op>, <pos>)' definiert einen Nofix-Operator mit der Wortart
     <pos> für das Ergebnis.

     Nofix-Operatoren sind Operatoren, die kein Argument haben.  Tritt
     ein solcher Operator allein auf, wird die dazugehörige Funktion
     ausgewertet.  Zum Beispiel beendet die Funktion 'quit()' eine
     Maxima-Sitzung.  Wird diese Funktion mit 'nofix("quit")' als ein
     Nofix-Operator definiert, genügt die Eingabe von 'quit', um eine
     Maxima-Sitzung zu beenden.

 -- Funktion: postfix (<op>)
 -- Funktion: postfix (<op>, <lbp>, <lpos>, <pos>)

     'postfix (<op>)' definiert einen Postfix-Operator <op>.

     'postfix (<op>, <lbp>, <lpos>, <pos>)' definiert einen
     Postfix-Operator <op> mit einem linksseitigem Vorrang von <lbp>
     sowie den Wortarten <lpos> für den Operanden und <pos> für das
     Ergebnis.

     Ein Postfix-Operator hat einen Operanden, der dem Operator
     vorangestellt ist.  Ein Beispiel ist der '!'-Operator mit '3!'.
     Die Funktion 'postfix("x")' erweitert die Maxima-Syntax um den
     Postfix-Operator 'x'.

 -- Funktion: prefix (<op>)
 -- Funktion: prefix (<op>, <rbp>, <rpos>, <pos>)

     'prefix (<op>)' definiert einen Prefix-Operator <op>.

     'prefix (<op>, <lbp>, <lpos>, <pos>)' definiert einen
     Prefix-Operator <op> mit einem rechtsseitigem Vorrang von <rbp>
     sowie den Wortarten <rpos> für den Operanden und <pos> für das
     Ergebnis.

     Ein Prefix-Operator hat einen Operanden, der dem Operator
     nachfolgt.  Mit 'prefix("x")' wird die Maxima-Syntax um einen
     Prefix-Operator 'x' erweitert.


File: maxima.info,  Node: Auswertung,  Next: Vereinfachung,  Prev: Operatoren,  Up: Top

8 Auswertung
************

* Menu:

* Einführung in die Auswertung::
* Funktionen und Variablen für die Auswertung::


File: maxima.info,  Node: Einführung in die Auswertung,  Next: Funktionen und Variablen für die Auswertung,  Prev: Auswertung,  Up: Auswertung

8.1 Einführung in die Auswertung
================================

In *note Einführung in die Kommandozeile:: sind die vier Phasen der
Eingabe, Auswertung, Vereinfachung und Ausgabe erläutert, die jede
Eingabe des Nutzers bis zur Ausgabe auf der Konsole durchläuft.

Jede Eingabe eines Ausdrucks <expr> wird von Maxima ausgewertet.
Symbole, die keinen Wert haben, und Zahlen werden zu sich selbst
ausgewertet.  Symbole, die einen Wert haben, werden durch ihren Wert
ersetzt.

Beispiele:

Im ersten Beispiel werden Symbole und Zahlen zu sich selbst ausgewertet.
Im zweiten Beispiel erhält die Variable 'a' den Wert '2'.  In den
folgenden Ausdrücken wird die Variable 'a' ausgewertet und durch ihren
Wert ersetzt.

     (%i1) [a, b, 2, 1/2, 1.0];
                                       1
     (%o1)                   [a, b, 2, -, 1.0]
                                       2
     (%i2) a:2$

     (%i3) [a, sin(a), a^2];
     (%o3)                    [2, sin(2), 4]

Maxima unterscheidet Funktionen in einer Verbform von Funktionen in
einer Substantivform.  Funktionen in einer Verbform werden ausgewertet,
indem die Funktion auf die ausgewerteten Argumente angewendet wird.  Im
Gegensatz dazu werden Funktionen in einer Substantivform nicht auf die
Argumente angewendet, jedoch werden die Argumente weiterhin ausgewertet.
Funktionen können in beiden Formen auftreten.  Typische Beispiele sind
die Differentiation mit der Funktion 'diff' oder die Integration mit der
Funktion 'integrate'.  Siehe zum diesem Thema auch *note Substantive und
Verben::.

Beispiele:

Die Variable 'a' erhält einen Wert.  Im ersten Fall liegt die Funktion
'diff' in ihrer Verbform vor.  Die Auswertung bewirkt, dass die Funktion
auf die Argumente 'a*x^2' und <x> angewendet wird.  Im zweiten Fall
liegt die Funktion 'diff' in ihrer Substantivform vor.  Dies wird hier
durch den 'Quote-Operator' ''' bewirkt.  Jetzt wird die Funktion nicht
angewendet.  Das Ergebnis ist ein symbolischer Ausdruck für die
Ableitung.  Da auch in diesem Fall die Argumente ausgewertet werden,
wird auch hier der Wert '1/2' für die Variable 'a' eingesetzt.

     (%i1) a:1/2;
                                     1
     (%o1)                           -
                                     2
     (%i2) diff(a*x^2, x);
     (%o2)                           x
     (%i3) 'diff(a*x^2, x);
                                       2
                                  d   x
     (%o3)                        -- (--)
                                  dx  2

Nicht alle Maxima-Funktionen werten die Argumente aus.  Die
Dokumentation der Funktionen gibt häufig einen Hinweis darauf, ob die
Argumente ausgewertet werden oder nicht.

Beispiel:

Die Funktion 'properties' wertet das Argument nicht aus.  Dies ist für
den Nutzer praktisch, da ansonsten die Auswertung einer Variablen 'a',
die einen Wert hat, explizit mit dem Quote-Operator ''' unterdrückt
werden müsste, um die Eigenschaften des Symbols ''a' anzuzeigen.  Im
ersten Fall ist das Ergebnis eine leere Liste.  Das Symbol 'a' hat keine
Eigenschaften.  Im zweiten Fall erhält die Variable 'a' einen Wert.  Die
Funktion 'properties' wertet ihr Argument nicht aus und 'a' wird nicht
durch den Wert '2' ersetzt.  Die Funktion 'properties' zeigt weiterhin
die Eigenschaften des Symbols ''a' an.

     (%i1) properties(a);
     (%o1)                          []
     (%i2) a:2$

     (%i3) properties(a);
     (%o3)                        [value]

Die Auswertung von Symbolen, Funktionen und Ausdrücken kann mit dem
Quote-Operator ''' und dem Quote-Quote-Operator '''' kontrolliert
werden.  Der Quote-Operator unterdrückt die Auswertung.  Dagegen
erzwingt der Quote-Quote-Operator die Auswertung.

Mit der Funktion 'ev' wird ein Ausdruck in einer definierten Umgebung
ausgewertet, in der Optionsvariablen für die Auswertung einen bestimmten
Wert erhalten oder Auswertungsschalter 'evflag' und
Auswertungsfunktionen 'evfun' angewendet werden.


File: maxima.info,  Node: Funktionen und Variablen für die Auswertung,  Prev: Einführung in die Auswertung,  Up: Auswertung

8.2 Funktionen und Variablen für die Auswertung
===============================================

 -- Operator: '

     Der Quote-Operator ''' unterdrückt die Auswertung eines Symbols
     oder Ausdrucks.  Auf eine Funktion angewendet, unterdrückt der
     Quote-Operator die Auswertung der Funktion.  Die Auswertung der
     Argumente der Funktion wird nicht unterdrückt.  Das Ergebnis ist
     die Substantivform der Funktion.

     Wird der Quote-Operator auf einen eingeklammerten Ausdruck
     angewendet, wird die Auswertung aller Symbole und Funktionen
     innerhalb der Klammern unterdrückt.  ''(f(x))' bedeutet, dass der
     Ausdruck 'f(x)' nicht ausgewertet werden soll.  ''f(x)' bedeutet,
     dass die Substantivform von 'f' auf das ausgewertete Argument <x>
     angewendet wird.

     Der Quote-Operator unterdrückt die Auswertung, aber nicht die
     Vereinfachung von Ausdrücken.

     Substantivformen werden mit einem Hochkomma angezeigt, wenn die
     Optionsvariable 'noundisp' den Wert 'true' hat.

     Siehe auch den Quote-Quote-Operator '''' und den
     Auswertungsschalter 'nouns'.

     Beispiele:

     Auf ein Symbol angewendet, unterdrückt der Quote-Operator die
     Auswertung des Symbols.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) aa^2;
          (%o2)                        1048576
          (%i3) 'aa^2;
                                           2
          (%o3)                          aa
          (%i4) ''%;
          (%o4)                        1048576

     Auf eine Funktion angewendet, unterdrückt der Quote-Operator die
     Auswertung der Funktion.  Das Ergebnis ist die Substantivform der
     Funktion.

          (%i1) x0: 5;
          (%o1)                           5
          (%i2) x1: 7;
          (%o2)                           7
          (%i3) integrate (x^2, x, x0, x1);
                                         218
          (%o3)                          ---
                                          3
          (%i4) 'integrate (x^2, x, x0, x1);
                                       7
                                      /
                                      [   2
          (%o4)                       I  x  dx
                                      ]
                                      /
                                       5
          (%i5) %, nouns;
                                         218
          (%o5)                          ---
                                          3

     Wird der Quote-Operator auf einen eingeklammerten Ausdruck
     angewendet, wird die Auswertung aller Symbole und Funktionen
     innerhalb der Klammern unterdrückt.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) bb: 19;
          (%o2)                          19
          (%i3) sqrt(aa) + bb;
          (%o3)                          51
          (%i4) '(sqrt(aa) + bb);
          (%o4)                     bb + sqrt(aa)
          (%i5) ''%;
          (%o5)                          51

     Der Quote-Operator unterdrückt nicht die Vereinfachung von
     Ausdrücken.

          (%i1) sin (17 * %pi) + cos (17 * %pi);
          (%o1)                          - 1
          (%i2) '(sin (17 * %pi) + cos (17 * %pi));
          (%o2)                          - 1

     Gleitkommarechnungen sind eine Vereinfachung und keine Auswertung.
     Daher kann die Berechnung von 'sin(1.0)' nicht mit dem
     Quote-Operator unterdrückt werden.

          (%i1) sin(1.0);
          (%o1)                          .8414709848078965
          (%i2) '(sin(1.0));
          (%o2)                          .8414709848078965

 -- Operator: ''

     Der Quote-Quote-Operator '''' (zwei Hochkommata) modifiziert die
     Auswertung von Ausdrücken, die von der Eingabe gelesen werden.

     Wird der Quote-Quote-Operator auf einen allgemeinen Ausdruck <expr>
     angewendet, wird der Ausdruck <expr> durch seinen Wert ersetzt.

     Wird der Quote-Quote-Operator auf den Operator eines Ausdruckes
     angewendet, ändert sich der Operator, wenn er in seiner
     Substantivform vorliegt, in die Verbform.

     Der Quote-Quote-Operator wird vom Parser, der die Eingabe liest,
     sofort angewendet und nicht im eingelesen Ausdruck gespeichert.
     Daher kann die Auswertung des Quote-Quote-Operators nicht durch
     einen weiteren Quote-Operator verhindert werden.  Der
     Quote-Quote-Operator führt zur Auswertung von Ausdrücken, deren
     Auswertung unterdrückt ist.  Das ist der Fall für
     Funktionsdefinitionen, Lambda-Ausdrücke und Ausdrücke, deren
     Auswertung durch den Quote-Operator verhindert wurde.

     Der Quote-Quote-Operator wird von den Befehlen 'batch' und 'load'
     erkannt.

     Siehe auch den Quote-Operator ''' und den Auswertungsschalter
     'nouns'.

     Beispiele:

     Wird der Quote-Quote-Operator auf einen Ausdruck <expr> angewendet,
     wird der Wert von <expr> in den Ausdruck eingesetzt.

          (%i1) expand ((a + b)^3);
                               3        2      2      3
          (%o1)               b  + 3 a b  + 3 a  b + a
          (%i2) [_, ''_];
                                   3    3        2      2      3
          (%o2)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
          (%i3) [%i1, ''%i1];
                                   3    3        2      2      3
          (%o3)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
          (%i4) [aa : cc, bb : dd, cc : 17, dd : 29];
          (%o4)                   [cc, dd, 17, 29]
          (%i5) foo_1 (x) := aa - bb * x;
          (%o5)                 foo_1(x) := aa - bb x
          (%i6) foo_1 (10);
          (%o6)                      cc - 10 dd
          (%i7) ''%;
          (%o7)                         - 273
          (%i8) ''(foo_1 (10));
          (%o8)                         - 273
          (%i9) foo_2 (x) := ''aa - ''bb * x;
          (%o9)                 foo_2(x) := cc - dd x
          (%i10) foo_2 (10);
          (%o10)                        - 273
          (%i11) [x0 : x1, x1 : x2, x2 : x3];
          (%o11)                    [x1, x2, x3]
          (%i12) x0;
          (%o12)                         x1
          (%i13) ''x0;
          (%o13)                         x2
          (%i14) '' ''x0;
          (%o14)                         x3

     Wird der Quote-Quote-Operator auf den Operator in einem Ausdruck
     angewendet, ändert sich der Operator von seiner Substantivform in
     die Verbform.

          (%i1) declare (foo, noun);
          (%o1)                         done
          (%i2) foo (x) := x - 1729;
          (%o2)                 ''foo(x) := x - 1729
          (%i3) foo (100);
          (%o3)                       foo(100)
          (%i4) ''foo (100);
          (%o4)                        - 1629

     Der Quote-Quote-Operator wird vom Parser sofort auf den
     eingelesenen Ausdruck angewendet und ist nicht Teil eines
     Maxima-Ausdrucks.

          (%i1) [aa : bb, cc : dd, bb : 1234, dd : 5678];
          (%o1)                 [bb, dd, 1234, 5678]
          (%i2) aa + cc;
          (%o2)                        dd + bb
          (%i3) display (_, op (_), args (_));
                                     _ = cc + aa

                                   op(cc + aa) = +

                              args(cc + aa) = [cc, aa]

          (%o3)                         done
          (%i4) ''(aa + cc);
          (%o4)                         6912
          (%i5) display (_, op (_), args (_));
                                     _ = dd + bb

                                   op(dd + bb) = +

                              args(dd + bb) = [dd, bb]
          (%o5)                         done

     Der Quote-Quote-Operator bewirkt die Auswertung von Ausdrücken,
     deren Auswertung unterdrückt ist wie in Funktionsdefinitionen,
     Lambda-Ausdrücken und Ausdrücken, auf die der Quote-Operator
     angewendet wurde.

          (%i1) foo_1a (x) := ''(integrate (log (x), x));
          (%o1)               foo_1a(x) := x log(x) - x
          (%i2) foo_1b (x) := integrate (log (x), x);
          (%o2)           foo_1b(x) := integrate(log(x), x)
          (%i3) dispfun (foo_1a, foo_1b);
          (%t3)               foo_1a(x) := x log(x) - x

          (%t4)           foo_1b(x) := integrate(log(x), x)

          (%o4)                      [%t3, %t4]
          (%i5) integrate (log (x), x);
          (%o5)                     x log(x) - x
          (%i6) foo_2a (x) := ''%;
          (%o6)               foo_2a(x) := x log(x) - x
          (%i7) foo_2b (x) := %;
          (%o7)                    foo_2b(x) := %
          (%i8) dispfun (foo_2a, foo_2b);
          (%t8)               foo_2a(x) := x log(x) - x

          (%t9)                    foo_2b(x) := %

          (%o9)                      [%t8, %t9]
          (%i10) F : lambda ([u], diff (sin (u), u));
          (%o10)            lambda([u], diff(sin(u), u))
          (%i11) G : lambda ([u], ''(diff (sin (u), u)));
          (%o11)                 lambda([u], cos(u))
          (%i12) '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
          (%o12)         sum(b , k, 1, 3) + sum(a , k, 1, 3)
                              k                  k
          (%i13) '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
          (%o13)             b  + a  + b  + a  + b  + a
                              3    3    2    2    1    1

 -- Funktion: ev (<expr>, <arg_1>, ..., <arg_n>)

     Wertet den Ausdruck <expr> in einer Umgebung aus, die durch die
     Argumente <arg_1>, ..., <arg_n> spezifiziert wird.  Die Argumente
     sind Optionsvariablen (Boolesche Variablen), Zuweisungen,
     Gleichungen und Funktionen.  'ev' gibt das Ergebnis der Auswertung
     zurück.

     Die Auswertung wird in den folgenden Schritten durchgeführt:

       1. Zuerst wird die Umgebung gesetzt.  Dazu werden die Argumente
          <arg_1>, ..., <arg_n> ausgewertet.  Folgende Argumente sind
          möglich:

             * 'simp' bewirkt, dass der Ausdruck <expr> vereinfacht
               wird.  Der Wert der Optionsvariablen 'simp' wird dabei
               ignoriert.  Der Ausdruck wird also auch dann vereinfacht,
               wenn die Optionsvariable <simp> den Wert 'false' hat.

             * 'noeval' unterdrückt die Auswertungphase der Funktion
               'ev' (siehe Schritt (4) unten).  Dies ist nützlich im
               Zusammenhang mit anderen Schaltern und um einen Ausdruck
               <expr> erneuert zu vereinfachen, ohne dass dieser
               ausgewertet wird.

             * 'nouns' bewirkt die Auswertung von Substantivformen.
               Solche Substantivformen sind typischerweise nicht
               ausgewertete Funktionen wie ''integrate' oder ''diff',
               die im Ausdruck <expr> enthalten sind.

             * 'expand' bewirkt die Expansion des Ausdruckes <expr>.
               Siehe die Funktion 'expand'.

             * 'expand'(<m>, <n>) bewirkt die Expansion des Ausdruckes
               <expr>, wobei den Optionsvariablen 'maxposex' und
               'maxnegex' die Werte der Argumente <m> und <n> zugewiesen
               werden.  Siehe die Funktion 'expand'.

             * 'detout' bewirkt, dass bei der Berechnung von Inversen
               von Matrizen, die im Ausdruck <expr> enthalten sind,
               Determinanten den Matrizen vorangestellt und nicht
               elementweise in die Matrize hereinmultipliziert werden.

             * 'diff' bewirkt, dass alle Ableitungen ausgeführt werden,
               die im Ausdruck <expr> enthalten sind.

             * 'derivlist(<x>, <y>, <z>, ...)' bewirkt, dass die
               Ableitungen bezüglich der angegebenen Variablen <x>, <y>,
               <z>, ... ausgeführt werden.

             * 'risch' bewirkt das Integrale im Ausdruck <expr> mit dem
               Risch-Algorithmus berechnet werden.  Siehe 'risch'.  Wird
               der Schalter 'nouns' benutzt, wird der
               Standardalgorithmus für Integrale verwendet.

             * 'float' bewirkt, dass rationale Zahlen in
               Gleitkommazahlen konvertiert werden.

             * 'numer' bewirkt, dass mathematische Funktionen mit
               numerischen Argumenten ein Ergebnis in Gleitkommazahlen
               liefern.  Variablen in 'expr', denen numerische Werte
               zugewiesen wurden, werden durch diese ersetzt.  Der
               Schalter 'float' wird zusätzlich wirksam.

             * 'pred' bewirkt, dass Aussagen zu 'true' oder 'false'
               ausgewertet werden.

             * 'eval' bewirkt eine zusätzliche Auswertung des Ausdrucks
               <expr>.  (Siehe Schritt (5) unten).  'eval' kann mehrfach
               angewendet werden.  Jedes Auftreten von 'eval' führt zu
               einer weiteren Auswertung.

             * 'A', wobei 'A' ein Symbol ist, das als ein
               Auswertungsschalter 'evflag' definiert ist.  Während der
               Auswertung des Ausdrucks <expr> erhält 'A' den Wert
               'true'.

             * 'V: expression' (oder alternativ 'V=expression') bewirkt,
               dass 'V' während der Auswertung des Ausdrucks <expr> den
               Wert 'expression' erhält.  'V' kann auch eine
               Optionsvariable sein, die für die Auswertung den Wert
               'expression' erhält.  Wenn mehr als ein Argument der
               Funktion 'ev' übergeben wird, wird die Zuweisung der
               Werte parallel ausgeführt.  Wenn 'V' kein Atom ist, wird
               anstatt einer Zuweisung eine Substitution ausgeführt.

             * 'F', wobei 'F' der Name einer Funktion ist, die als eine
               Auswertungsfunktion (siehe 'evfun') definiert wurde.  'F'
               bewirkt, dass die Auswertungsfunktion auf den Ausdruck
               <expr> angewendet wird.

             * Jeder andere Funktionsname (zum Beispiel 'sum') bewirkt,
               dass jedes Auftreten dieser Funktion im Ausdruck <expr>
               ausgewertet wird.

             * Zusätzlich kann für die Auswertung von <expr> eine lokale
               Funktion 'F(x) := expression' definiert werden.

             * Wird ein Symbol, eine indizierte Variable oder ein
               indizierter Ausdruck, der oben nicht genannt wurde, als
               Argument übergeben, wird das Argument ausgewertet.  Wenn
               das Ergebnis eine Gleichung oder eine Zuweisung ist,
               werden die entsprechenden Zuweisungen und Substitutionen
               ausgeführt.  Wenn das Ergebnis eine Liste ist, werden die
               Elemente der Liste als zusätzliche Argumente von 'ev'
               betrachtet.  Dies erlaubt, das eine Liste mit Gleichungen
               (zum Beispiel '[%t1, %t2]', wobei '%t1' und '%t2'
               Gleichungen sind) wie sie zum Beispiel von der Funktion
               'solve' erzeugt wird, als Argument verwendet werden kann.

          Die Argumente der Funktion 'ev' können in einer beliebigen
          Reihenfolge übergeben werden.  Ausgenommen sind Gleichungen
          mit Substitutionen, die nacheinander von links nach rechts
          ausgewertet werden, sowie Auswertungsfunktionen, die verkettet
          werden.  So wird zum Beispiel 'ev(<expr>, ratsimp, realpart)'
          zu 'realpart(ratsimp(<expr>))'.

          Die Schalter 'simp', 'numer', 'float' und 'detout' sind auch
          Optionsvariablen, die lokal in einem Block oder global gesetzt
          werden können.

          Ist <expr> ein kanonischer rationaler Ausdruck (CRE =
          canonical rational expression), ist auch das Ergebnis der
          Funktion 'ev' ein CRE-Ausdruck, falls nicht die beiden
          Schalter 'float' und 'numer' den Wert 'true' haben.

       2. Während des Schritts (1) wird eine Liste der nicht indizierten
          Variablen erstellt, die auf der linken Seite von Gleichungen
          auftreten.  Die Gleichungen können dabei entweder als Argument
          oder als Wert eines Argumentes vorliegen.  Variablen, die
          nicht in dieser Liste enthalten sind, werden durch ihre
          globalen Werte ersetzt.  Davon ausgenommen sind Variablen, die
          eine Array-Funktion repräsentieren.  Ist zum Beispiel <expr>
          eine Marke wie '%i2' im Beispiel unten oder das letzte
          Ergebnis '%', so wird in diesem Schritt der globale Wert
          dieser Marke eingesetzt und die Bearbeitung durch 'ev'
          fortgesetzt.

       3. Wenn in den Argumenten Substitutionen aufgeführt sind, werden
          diese nun ausgeführt.

       4. Der resultierende Ausdruck wird erneut ausgewertet, außer wenn
          'noeval' unter den Argumente ist, und vereinfacht.  Die
          Funktionsaufrufe in <expr> werden erst ausgeführt, wenn die
          enthaltenden Variablen ausgewertet sind.  Dadurch verhält sich
          'ev(F(x))' wie 'F(ev(x))'.

       5. Für jedes Auftreten des Schalters 'eval' in den Argumenten
          werden die Schritte (3) und (4) wiederholt.

     Anstatt der Anwendung der Funktion 'ev' können alternativ der
     Ausdruck und die Argumente durch Kommata getrennt eingegeben
     werden:

          <expr>, <arg_1>, ..., <arg_n>

     Diese Kurzschreibweise ist jedoch als Teil eines anderen Ausdrucks,
     zum Beispiel in Funktionen oder Blöcken nicht gestattet.

     Beispiele:

          (%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                               d                    2
          (%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                               dw
          (%i2) ev (%, numer, expand, diff, x=2, y=1);
                                         2
          (%o2)                cos(w) + w  + 2 w + 2.449599732693821

     Im folgenden Beispiel werden die Zuweisungen parallel durchgeführt.
     Es wird die Kurzschreibweise der Funktion 'ev' angewendet.

          (%i3) programmode: false;
          (%o3)                                false
          (%i4) x+y, x: a+y, y: 2;
          (%o4)                              y + a + 2
          (%i5) 2*x - 3*y = 3$
          (%i6) -3*x + 2*y = -4$
          (%i7) solve ([%o5, %o6]);
          Solution

                                                    1
          (%t7)                               y = - -
                                                    5

                                                   6
          (%t8)                                x = -
                                                   5
          (%o8)                            [[%t7, %t8]]
          (%i8) %o6, %o8;
          (%o8)                              - 4 = - 4
          (%i9) x + 1/x > gamma (1/2);
                                             1
          (%o9)                          x + - > sqrt(%pi)
                                             x
          (%i10) %, numer, x=1/2;
          (%o10)                      2.5 > 1.772453850905516
          (%i11) %, pred;
          (%o11)                               true

 -- Auswertungsschalter: eval

     Als Argument des Kommandos 'ev(expr, eval)' bewirkt 'eval' eine
     zusätzliche Auswertung des Ausdrucks 'expr'.

     'eval' kann mehrfach auftreten.  Jedes Auftreten führt zu einer
     zusätzlichen Auswertung.

     Siehe auch die Funktion 'ev' sowie die Auswertungsschalter 'noeval'
     und 'infeval'

     Beispiele:

          (%i1) [a:b,b:c,c:d,d:e];
          (%o1)                            [b, c, d, e]
          (%i2) a;
          (%o2)                                  b
          (%i3) ev(a);
          (%o3)                                  c
          (%i4) ev(a),eval;
          (%o4)                                  e
          (%i5) a,eval,eval;
          (%o5)                                  e

 -- Eigenschaft: evflag

     Wenn ein Symbol <x> die Eigenschaft eines Auswertungsschalters
     besitzt, sind die Ausdrücke 'ev(<expr>, <x>)' und '<expr>, <x>' 
     äquivalent zu 'ev(<expr>, <x> = true)'.  Während der Auswertung von
     <expr> erhält also <x> den Wert 'true'.

     Mit 'declare(<x>, evflag)' wird der Variablen <x> die
     'evflag'-Eigenschaft gegeben.  Siehe auch die Funktion 'declare'.
     Mit 'kill' oder 'remove' kann diese Eigenschaft wieder entfernt
     werden.  Siehe auch 'properties' für die Anzeige von Eigenschaften.

     Folgende Optionsvariablen haben bereits die 'evflag'-Eigenschaft:

        algebraic           cauchysum       demoivre
        dotscrules          %emode          %enumer
        exponentialize      exptisolate     factorflag
        float               halfangles      infeval
        isolate_wrt_times   keepfloat       letrat
        listarith           logabs          logarc
        logexpand           lognegint
        m1pbranch           numer_pbranch   programmode
        radexpand           ratalgdenom     ratfac
        ratmx               ratsimpexpons   simp
        simpproduct         simpsum         sumexpand
        trigexpand

     Beispiele:

          (%i1) sin (1/2);
                                           1
          (%o1)                        sin(-)
                                           2
          (%i2) sin (1/2), float;
          (%o2)                   0.479425538604203
          (%i3) sin (1/2), float=true;
          (%o3)                   0.479425538604203
          (%i4) simp : false;
          (%o4)                         false
          (%i5) 1 + 1;
          (%o5)                         1 + 1
          (%i6) 1 + 1, simp;
          (%o6)                           2
          (%i7) simp : true;
          (%o7)                         true
          (%i8) sum (1/k^2, k, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o8)                        >    --
                                      /      2
                                      ====  k
                                      k = 1
          (%i9) sum (1/k^2, k, 1, inf), simpsum;
                                           2
                                        %pi
          (%o9)                         ----
                                         6
          (%i10) declare (aa, evflag);
          (%o10)                        done
          (%i11) if aa = true then YES else NO;
          (%o11)                         NO
          (%i12) if aa = true then YES else NO, aa;
          (%o12)                         YES

 -- Eigenschaft: evfun

     Wenn eine Funktion <F> die Eigenschaft 'evfun' besitzt, sind die
     Ausdrücke 'ev(<expr>, <F>)' und '<expr>, <F>'  äquivalent zu
     '<F>(ev(<expr>))'.

     Zwei oder mehr 'evfun'-Funktionen <F>, <G>, ... werden in der
     aufgeführten Reihenfolge auf den Ausdruck <expr> angewendet.

     Mit 'declare(<F>, evfun)' wird der Funktion <F> die
     'evfun'-Eigenschaft gegeben.  Siehe auch die Funktion 'declare'.
     Mit 'kill' oder 'remove' kann diese Eigenschaft wieder entfernt
     werden.  Siehe auch 'properties' für die Anzeige von Eigenschaften.

     Funktionen, die bereits die 'evfun'-Eigenschaft besitzen, sind:

        bfloat          factor       fullratsimp
        logcontract     polarform    radcan
        ratexpand       ratsimp      rectform
        rootscontract   trigexpand   trigreduce

     Beispiele:

          (%i1) x^3 - 1;
                                        3
          (%o1)                        x  - 1
          (%i2) x^3 - 1, factor;
                                          2
          (%o2)                 (x - 1) (x  + x + 1)
          (%i3) factor (x^3 - 1);
                                          2
          (%o3)                 (x - 1) (x  + x + 1)
          (%i4) cos(4 * x) / sin(x)^4;
                                      cos(4 x)
          (%o4)                       --------
                                         4
                                      sin (x)
          (%i5) cos(4 * x) / sin(x)^4, trigexpand;
                           4           2       2         4
                        sin (x) - 6 cos (x) sin (x) + cos (x)
          (%o5)         -------------------------------------
                                          4
                                       sin (x)
          (%i6) cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
                                     2         4
                                6 cos (x)   cos (x)
          (%o6)               - --------- + ------- + 1
                                    2          4
                                 sin (x)    sin (x)
          (%i7) ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
                                     2         4
                                6 cos (x)   cos (x)
          (%o7)               - --------- + ------- + 1
                                    2          4
                                 sin (x)    sin (x)
          (%i8) declare ([F, G], evfun);
          (%o8)                         done
          (%i9) (aa : bb, bb : cc, cc : dd);
          (%o9)                          dd
          (%i10) aa;
          (%o10)                         bb
          (%i11) aa, F;
          (%o11)                        F(cc)
          (%i12) F (aa);
          (%o12)                        F(bb)
          (%i13) F (ev (aa));
          (%o13)                        F(cc)
          (%i14) aa, F, G;
          (%o14)                      G(F(cc))
          (%i15) G (F (ev (aa)));
          (%o15)                      G(F(cc))

 -- Optionsvariable: infeval
     Standardwert: 'false'

     'infeval' bewirkt, dass die Funktion 'ev' die Auswertung eines
     Ausdrucks solange wiederholt, bis dieser sich nicht mehr ändert.
     Um zu verhindern, dass eine Variable in diesem Modus durch die
     Auswertung verschwindet, kann zum Beispiel für eine Variable 'x'
     der Ausdruck 'x='x' als Argument von 'ev' einfügt werden.
     Ausdrücke wie 'ev(x, x=x+1, infeval)' führen in diesem Modus zu
     Endlosschleifen.

     Siehe auch die Auswertungsschalter 'noeval' und 'eval'.

 -- Auswertungsschalter: noeval

     'noeval' unterdrückt die Auswertungsphase der Funktion 'ev'.  Der
     Schalter kann im Zusammenhang mit anderen Auswertungsschaltern
     genutzt werden, um einen Ausdruck erneut zu vereinfachen, ohne
     diesen auszuwerten.

     Siehe auch die Optionsvariable 'infeval' und den
     Auswertungsschalter 'eval'.

 -- Auswertungsschalter: nouns

     'nouns' ist ein Auswertungsschalter.  Wird dieser Schalter als eine
     Option der Funktion 'ev' genutzt, werden alle Substantivformen, die
     in dem Ausdruck enthalten sind, in Verbformen umgewandelt und
     ausgewertet.

     Siehe auch die Eigenschaft 'noun' und die Funktionen 'nounify' und
     'verbify'.

 -- Auswertungsschalter: pred

     Wird 'pred' als ein Argument der Funktion 'ev' eingesetzt, werden
     Aussagen zu 'true' oder 'false' ausgewertet.  Siehe die Funktion
     'ev'.

     Beispiel:

          (%i1) 1 < 2;
          (%o1)                                1 < 2
          (%i2) 1 < 2,pred;
          (%o2)                                true


File: maxima.info,  Node: Vereinfachung,  Next: Mathematische Funktionen,  Prev: Auswertung,  Up: Top

9 Vereinfachung
***************

* Menu:

* Einführung in die Vereinfachung::
* Funktionen und Variablen für die Vereinfachung::


File: maxima.info,  Node: Einführung in die Vereinfachung,  Next: Funktionen und Variablen für die Vereinfachung,  Prev: Vereinfachung,  Up: Vereinfachung

9.1 Einführung in die Vereinfachung
===================================

Nach der Auswertung einer Eingabe, die in *note Auswertung:: beschrieben
ist, schließt sich die Vereinfachung eines Ausdrucks an.  Mathematische
Funktionen mit denen symbolisch gerechnet werden kann, werden nicht
ausgewertet, sondern vereinfacht.  Mathematische Funktionen werden
intern von Maxima in einer Substantivform dargestellt.  Auch Ausdrücke
mit den arithmetischen Operatoren werden vereinfacht.  Numerische
Rechnungen wie die Addition oder Multiplikation sind daher keine
Auswertung, sondern eine Vereinfachung.  Die Auswertung eines Ausdrucks
kann mit dem 'Quote-Operator' ''' unterdrückt werden.  Entsprechend kann
die Vereinfachung eines Ausdrucks mit der Optionsvariablen 'simp'
kontrolliert werden.

Beispiele:

Im ersten Beispiel wird die Auswertung mit dem Quote-Operator
unterdrückt.  Das Ergebnis ist eine Substantivform für die Ableitung.
Im zweiten Beispiel ist die Vereinfachung unterdrückt.  Die Ableitung
wird ausgeführt, da es sich um eine Auswertung handelt.  Das Ergebnis
wird jedoch nicht zu '2*x' vereinfacht.

     (%i1) 'diff(x*x,x);
                                  d    2
     (%o1)                        -- (x )
                                  dx
     (%i2) simp:false;
     (%o2)                         false
     (%i3) diff(x*x,x);
     (%o3)                       1 x + 1 x

Für jede mathematischen Funktion oder Operator hat Maxima intern eine
eigene Routine, die für die Vereinfachung aufgerufen wird, sobald die
Funktion oder der Operator in einem Ausdruck auftritt.  Diese Routinen
implementieren Symmetrieeigenschaften, spezielle Funktionswerte oder
andere Eigenschaften und Regeln.  Mit einer Vielzahl von
Optionsvariablen kann Einfluss auf die Vereinfachung der Funktionen und
Operatoren genommen werden.

Beispiel:

Die Vereinfachung der Exponentialfunktion 'exp' wird von den folgenden
Optionsvariablen kontrolliert: '%enumer', '%emode', '%e_to_numlog',
'radexpand', 'logsimp', und 'demoivre'.  Im ersten Beispiel wird der
Ausdruck mit der Exponentialfunktion nicht vereinfacht.  Im zweiten
Beispiel vereinfacht Maxima ein Argument '%i*%pi/2'.

     (%i1) exp(x+%i*%pi/2), %emode:false;
                                     %i %pi
                                 x + ------
                                       2
     (%o1)                     %e
     (%i2) exp(x+%i*%pi/2), %emode:true;
                                       x
     (%o2)                        %i %e

Zusätzlich zu der Vereinfachung von einzelnen mathematischen Funktionen
und Operatoren, die automatisch von Maxima ausgeführt werden, kennt
Maxima Funktionen wie 'expand' oder 'radcan', die auf Ausdrücke
angewendet werden, um spezielle Vereinfachungen vorzunehmen.

Beispiel:

     (%i1) (log(x+x^2)-log(x))^a/log(1+x)^(a/2);
                                2               a
                          (log(x  + x) - log(x))
     (%o1)                -----------------------
                                         a/2
                               log(x + 1)
     (%i2) radcan(%);
                                         a/2
     (%o2)                     log(x + 1)

Einem Operator oder einer Funktion können Eigenschaften wie linear oder
symmetrisch gegeben werden.  Maxima berücksichtigt diese Eigenschaften
bei der Vereinfachung eines Ausdrucks.  Zum Beispiel wird mit dem
Kommando 'declare(f, oddfun)' eine Funktion als ungerade definiert.
Maxima vereinfacht dann jedes Auftreten eines Ausdrucks 'f(-x)' zu
'-f(x)'.  Entsprechend vereinfacht Maxima 'f(-x)' zu 'f(x)', wenn die
Funktion als gerade definiert wurde.

Die folgenden Eigenschaften sind in der Liste 'opproperties' enthalten
und kontrollieren die Vereinfachung von Funktionen und Operatoren:

   additive        lassociative     oddfun
   antisymmetric   linear           outative
   commutative     multiplicative   rassociative
   evenfun         nary             symmetric

Darüber hinaus haben auch die Fakten und die Eigenschaften des aktuellen
Kontextes Einfluss auf die Vereinfachung von Ausdrücken.  Siehe dazu die
Ausführungen in *note Maximas Datenbank::.

Beispiel:

Die Sinusfunktion vereinfacht für ein ganzzahliges Vielfaches von '%pi'
zum Wert '0'.  Erhält das Symbol 'n' die Eigenschaft 'integer', wird die
Sinusfunktion entsprechend vereinfacht.

     (%i1) sin(n*%pi);
     (%o1)                      sin(%pi n)
     (%i2) declare(n, integer);
     (%o2)                         done
     (%i3) sin(n*%pi);
     (%o3)                           0

Führen alle oben genannten Möglichkeiten nicht zu dem gewünschten
Ergebnis, kann der Nutzer Maxima um weitere Regeln für die Vereinfachung
erweitern.  Diese Möglichkeiten werden in *note Muster und Regeln::
erläutert.


File: maxima.info,  Node: Funktionen und Variablen für die Vereinfachung,  Prev: Einführung in die Vereinfachung,  Up: Vereinfachung

9.2 Funktionen und Variablen für die Vereinfachung
==================================================

 -- Eigenschaft: additive

     'declare(f, additive)' deklariert eine Funktion 'f' als additiv.
     Hat die Funktion 'f' ein Argument, dann wird 'f(x + y)' zu 'f(x) +
     f(y)' vereinfacht.

     Ist 'f' eine Funktion mit zwei oder mehr Argumenten, ist die
     Additivität für das erste Argument definiert.  Zum Beispiel wird
     'f(x + y,a + b)' zu 'f(y, b + a) + f(x, b + a)' vereinfacht.

     Siehe die Funktion 'declare'.

     Beispiel:

          (%i1) F3 (a + b + c);
          (%o1)                     F3(c + b + a)
          (%i2) declare (F3, additive);
          (%o2)                         done
          (%i3) F3 (a + b + c);
          (%o3)                 F3(c) + F3(b) + F3(a)

 -- Eigenschaft: antisymmetric

     'declare(f, antisymmetric)' deklariert die Funktion 'f' als
     antisymmetrisch.  Zum Beispiel wird 'f(y, x)' zu '- f(x, y)'
     vereinfacht.

     Siehe auch die Eigenschaft 'symmetric' und die Funktion 'declare'.

     Beispiel:

          (%i1) S (b, a);
          (%o1)                        S(b, a)
          (%i2) declare (T, antisymmetric);
          (%o2)                         done
          (%i3) T (b, a);
          (%o3)                       - T(a, b)
          (%i4) T (a, c, e, d, b);
          (%o4)                   T(a, b, c, d, e)

 -- Funktion: combine (<expr>)

     Terme einer rationalen Funktion, die denselben Nenner haben, werden
     zusammengefasst.

     Beispiel:

          (%i1) x^2/(1+x)+2*x/(1+x);
                                      2
                                     x       2 x
          (%o1)                     ----- + -----
                                    x + 1   x + 1
          (%i2) combine(%);
                                       2
                                      x  + 2 x
          (%o2)                       --------
                                       x + 1

 -- Eigenschaft: commutative

     'declare(f, commutative)' deklariert die Funktion 'f' als
     kommutativ.  Zum Beispiel wird 'f(x, z, y)' zu 'f(x, y, z)'
     vereinfacht.  Dies hat denselben Effekt wie die Deklaration
     'symmetric'.

     Siehe auch die Funktion 'declare'.

 -- Funktion: demoivre (<expr>)
 -- Optionsvariable: demoivre

     Die Funktion 'demoivre(expr)' konvertiert den Ausdruck <expr>, ohne
     die Optionsvariable 'demoivre' zu setzen.

     Hat die Optionsvariable 'demoivre' den Wert 'true', werden komplexe
     Exponentialfunktionen in äquivalente Kreisfunktionen umgewandelt.
     'exp(a + b*%i)' wird zu '%e^a*(cos(b)+%i*sin(b))' vereinfacht, wenn
     'b' frei von der imaginären Einheit '%i' ist.  'a' und 'b' werden
     nicht expandiert.

     Der Standardwert von 'demoivre' ist 'false'.

     Siehe auch die Funktion 'exponentialize', um trigonometrische und
     hyperbolische Funktionen in eine Exponentialform zu konvertieren.
     'demoivre' und 'exponentialize' können nicht gleichzeitig den Wert
     'true' haben.

 -- Funktion: distrib (<expr>)

     Summen werden ausmultipliziert.  Im Unterschied zu der Funktion
     'expand' wird 'distrib' nur auf der obersten Ebene eines Ausdruckes
     angewendet und ist daher schneller als 'expand'.  Im Unterschied zu
     der Funktion 'multthru' werden die Summen der obersten Ebenen
     vollständig ausmultipliziert.

     Beispiele:

          (%i1) distrib ((a+b) * (c+d));
          (%o1)                 b d + a d + b c + a c
          (%i2) multthru ((a+b) * (c+d));
          (%o2)                 (b + a) d + (b + a) c
          (%i3) distrib (1/((a+b) * (c+d)));
                                          1
          (%o3)                    ---------------
                                   (b + a) (d + c)
          (%i4) expand (1/((a+b) * (c+d)), 1, 0);
                                          1
          (%o4)                 ---------------------
                                b d + a d + b c + a c

 -- Optionsvariable: distribute_over
     Standardwert: 'true'

     Die Optionsvariable 'distribute_over' kontrolliert die Anwendung
     von Funktionen auf Listen, Matrizen oder Gleichungen.  Diese
     Eigenschaft wird nicht angewendet, wenn 'distribute_over' den Wert
     'false' hat.

     Beispiele:

     Die Funktion 'sin' wird auf eine Liste angewendet.

          (%i1) sin([x,1,1.0]);
          (%o1)                 [sin(x), sin(1), .8414709848078965]

     Die Funktion 'mod' hat zwei Argumente, die auf Listen angewendet
     werden kann.  Die Funktion kann auch auf verschachtelte Listen
     angewendet werden.

          (%i2) mod([x,11,2*a],10);
          (%o2)                    [mod(x, 10), 1, 2 mod(a, 5)]
          (%i3) mod([[x,y,z],11,2*a],10);
          (%o3)       [[mod(x, 10), mod(y, 10), mod(z, 10)], 1, 2 mod(a, 5)]

     Anwendung der Funktion 'floor' auf eine Matrix und eine Gleichung.

          (%i4) floor(matrix([a,b],[c,d]));
                                      [ floor(a)  floor(b) ]
          (%o4)                       [                    ]
                                      [ floor(c)  floor(d) ]
          (%i5) floor(a=b);
          (%o5)                         floor(a) = floor(b)

     Funktionen mit mehreren Argumenten können auf Listen für eines der
     Argumente oder alle Argumente angewendet werden.

          (%i6) expintegral_e([1,2],[x,y]);
          (%o6) [[expintegral_e(1, x), expintegral_e(1, y)],
                 [expintegral_e(2, x), expintegral_e(2, y)]]

 -- Optionsvariable: domain
     Standardwert: 'real'

     Hat 'domain' den Wert 'complex', wird 'sqrt(x^2)' nicht zu 'abs(x)'
     vereinfacht.

 -- Eigenschaft: evenfun
 -- Eigenschaft: oddfun

     Erhält eine Funktion oder ein Operator mit der Funktion 'declare'
     die Eigenschaft 'evenfun' oder 'oddfun' wird die Funktion oder der
     Operator von Maxima als gerade und ungerade interpretiert.  Diese
     Eigenschaft wird bei der Vereinfachung von Ausdrücken von Maxima
     angewendet.

     Beispiele:

          (%i1) o (- x) + o (x);
          (%o1)                     o(x) + o(- x)
          (%i2) declare (o, oddfun);
          (%o2)                         done
          (%i3) o (- x) + o (x);
          (%o3)                           0
          (%i4) e (- x) - e (x);
          (%o4)                     e(- x) - e(x)
          (%i5) declare (e, evenfun);
          (%o5)                         done
          (%i6) e (- x) - e (x);
          (%o6)                           0

 -- Funktion: expand (<expr>)
 -- Funktion: expand (<expr>, <p>, <n>)

     Expandiert den Ausdruck <expr>.  Produkte von Summen und Potenzen
     von Summen werden ausmultipliziert.  Die Nenner von rationalen
     Ausdrücken, die Summen sind, werden in ihre Terme aufgespalten.
     Produkte (kommutative und nicht-kommutative) werden in Summen
     herein multipliziert.

     Für Polynome ist es besser, die Funktion 'ratexpand' zu verwenden,
     welche für diesen Fall einen effizienteren Algorithmus hat.

     'maxnegex' und 'maxposex' kontrollieren den maximalen negativen und
     positiven Exponenten, für die ein Ausdruck expandiert wird.

     'expand(<expr>, <p>, <n>)' expandiert <expr>, wobei 'maxposex' den
     Wert <p> und 'maxnegex' den Wert <n> erhalten.

     'expon' ist der größte negative Exponent, für den ein Ausdruck
     automatisch expandiert wird.  Hat zum Beispiel 'expon' den Wert 4,
     wird '(x+1)^(-5)' nicht automatisch expandiert.

     'expop' ist der größte positive Exponent, für den ein Ausdruck
     automatisch expandiert wird.  So wird '(x+1)^3' dann automatisch
     expandiert, wenn 'expop' größer oder gleich 3 ist.  Soll '(x+1)^n'
     mit der Funktion 'expand' expandiert werden, weil 'n' größer als
     'expop' ist, dann ist dies nur möglich, wenn 'n' kleiner als
     'maxposex' ist.

     'expand(expr,0,0)' bewirkt eine erneuerte vollständige
     Vereinfachung des Ausdrucks <expr>.  Der Ausdruck wird nicht
     erneuert ausgewertet.  Im Unterschied zum Kommando 'ev(expr,
     noeval)' wird eine spezielle Darstellung (zum Beispiel eine
     CRE-Form) nicht entfernt.  Siehe auch 'ev'.

     Das 'expand'-Flag wird mit 'ev' verwendet, um einen Ausdruck zu
     expandieren.

     Die Datei 'simplification/facexp.mac' enthält weitere Funktionen
     wie 'facsum', 'factorfacsum' und 'collectterms' und Variablen wie
     'nextlayerfactor' und 'facsum_combine', um Ausdrücke zu
     vereinfachen.  Diese Funktionen werden automatisch geladen und
     erlauben spezielle Expansionen von Ausdrücken.  Eine kurze
     Beschreibung ist in der Datei 'simplification/facexp.usg'
     enthalten.  Eine Demo kann mit 'demo(facexp)' ausgeführt werden.

     Beispiele:

          (%i1) expr:(x+1)^2*(y+1)^3;
                                         2        3
          (%o1)                   (x + 1)  (y + 1)
          (%i2) expand(expr);
                 2  3        3    3      2  2        2      2      2
          (%o2) x  y  + 2 x y  + y  + 3 x  y  + 6 x y  + 3 y  + 3 x  y
                                                                2
                                               + 6 x y + 3 y + x  + 2 x + 1
          (%i3) expand(expr,2);
                         2        3              3          3
          (%o3)         x  (y + 1)  + 2 x (y + 1)  + (y + 1)
          (%i4) expr:(x+1)^-2*(y+1)^3;
                                             3
                                      (y + 1)
          (%o4)                       --------
                                             2
                                      (x + 1)
          (%i5) expand(expr);
                      3               2
                     y             3 y            3 y             1
          (%o5) ------------ + ------------ + ------------ + ------------
                 2              2              2              2
                x  + 2 x + 1   x  + 2 x + 1   x  + 2 x + 1   x  + 2 x + 1
          (%i6) expand(expr, 2, 2);
                                             3
                                      (y + 1)
          (%o6)                     ------------
                                     2
                                    x  + 2 x + 1

     Vereinfache einen Ausdruck erneut:

          (%i7) expr:(1+x)^2*sin(x);
                                          2
          (%o7)                    (x + 1)  sin(x)
          (%i8) exponentialize:true;
          (%o8)                         true
          (%i9) expand(expr, 0, 0);
                                      2    %i x     - %i x
                            %i (x + 1)  (%e     - %e      )
          (%o9)           - -------------------------------
                                           2

 -- Funktion: expandwrt (<expr>, <x_1>, ..., <x_n>)

     Expandiert den Ausdruck 'expr' in Bezug auf die Variablen <x_1>,
     ..., <x_n>.  Alle Produkte, die die Variablen enthalten, werden
     ausmultipliziert.  Das Ergebnis ist frei von Produkten von Summen,
     die nicht frei von den Variablen sind.  <x_1>, ..., <x_n> können
     Variable, Operatoren oder Ausdrücke sein.

     Standardmäßig wird der Nenner eines rationalen Ausdrucks nicht
     expandiert.  Dies kann mit der Optionsvariablen 'expandwrt_denom'
     kontrolliert werden.

     Die Funktion wird automatisch aus der Datei
     'simplification/stopex.mac' geladen.

 -- Optionsvariable: expandwrt_denom
     Standardwert: 'false'

     'expandwrt_denom' kontrolliert die Behandlung von rationalen
     Ausdrücken durch die Funktion 'expandwrt'.  Ist der Wert 'true',
     werden der Zähler und der Nenner eines rationalen Ausdrucks
     expandiert.  Ist der Wert 'false', wird allein der Zähler
     expandiert.

 -- Funktion: expandwrt_factored (<expr>, <x_1>, ..., <x_n>)

     Ist vergleichbar mit der Funktion 'expandwrt', behandelt aber
     Ausdrücke verschieden, die Produkte enthalten.
     'expandwrt_factored' expandiert nur die Faktoren im Ausdruck
     'expr', die die Variablen <x_1>, ..., <x_n> enthalten.

 -- Optionsvariable: expon
     Standardwert: 0

     'expon' ist der größte negative Exponent für den ein Ausdruck
     automatisch expandiert wird.  Hat zum Beispiel 'expon' den Wert 4,
     wird '(x+1)^(-5)' nicht automatisch expandiert.  Siehe auch
     'expop'.

 -- Funktion: exponentialize (<expr>)
 -- Optionsvariable: exponentialize

     Die Funktion 'exponentialize' konvertiert trigonometrische und
     hyperbolische Funktion die in dem Ausdruck <expr> auftreten in
     Exponentialfunktionen, ohne dass die Optionsvariable
     'exponentialize' gesetzt wird.

     Hat die Optionsvariable 'exponentialize' den Wert 'true', werden
     trigonometrische und hyperbolischen Funktionen in eine
     Exponentialform konvertiert.  Der Standardwert ist 'false'.

     'demoivre' konvertiert komplexe Exponentialfunktionen in
     trigonometrische und hyperbolische Funktionen.  'exponentialize'
     und 'demoivre' können nicht gleichzeitig den Wert 'true' haben.

 -- Optionsvariable: expop
     Standardwert: 0

     'expop' ist der größte positive Exponent, für den ein Ausdruck
     automatisch expandiert wird.  So wird '(x+1)^3' dann automatisch
     expandiert, wenn 'expop' größer oder gleich 3 ist.  Soll '(x+1)^n'
     mit der Funktion 'expand' expandiert werden, weil 'n' größer als
     'expop' ist, dann ist dies nur möglich, wenn 'n' kleiner als
     'maxposex' ist.  Siehe auch 'expon'.

 -- Eigenschaft: lassociative

     'declare(f, lassociative)' deklariert 'f' als eine
     links-assoziative Funktion.  Zum Beispiel wird 'f (f (a,b), f (c,
     d))' zu 'f (f (f (a, b), c), d)' vereinfacht.

     Siehe auch die Eigenschaft 'rassociative' und die Funktion
     'declare'.

 -- Eigenschaft: linear

     'declare(f, linear)' deklariert die Funktion 'f' als linear.

     Hat die Funktion 'f' ein Argument, dann wird 'f(x + y)' zu 'f(x) +
     f(y)' und 'f(a*x)' zu 'a*f(x)' vereinfacht.

     Ist 'f' eine Funktion mit zwei oder mehr Argumenten, ist die
     Linearität für das erste Argument definiert.  Zum Beispiel wird
     'f(a*x + b, x)' zu 'a f(x, x) + f(1, x) b' vereinfacht.

     'linear' ist äquivalent zu 'additive' und 'outative'.  Siehe auch
     'opproperties' und die Funktion 'declare'.

     Beispiel:

          (%i1) 'sum (F(k) + G(k), k, 1, inf);
                                 inf
                                 ====
                                 \
          (%o1)                   >    (G(k) + F(k))
                                 /
                                 ====
                                 k = 1
          (%i2) declare (nounify (sum), linear);
          (%o2)                         done
          (%i3) 'sum (F(k) + G(k), k, 1, inf);
                               inf          inf
                               ====         ====
                               \            \
          (%o3)                 >    G(k) +  >    F(k)
                               /            /
                               ====         ====
                               k = 1        k = 1

 -- Optionsvariable: maxnegex
     Standardwert: 1000

     'maxnegex' ist der größte negative Exponent, der von der Funktion
     'expand' exandieren wird.  Siehe auch 'maxposex'.

 -- Optionsvariable: maxposex
     Standardwert: 1000

     'maxposex' ist der größte positive Exponent, der von der Funktion
     'expand' expandiert wird.  Siehe auch 'maxnegex'.

 -- Eigenschaft: multiplicative

     'declare(f, multiplicative)' deklariert die Funktion 'f' als
     multiplikativ.

     Hat die Funktion 'f' ein Argument, dann wird 'f(x*y)' zu
     'f(x)*f(y)' vereinfacht.

     Ist 'f' eine Funktion mit zwei oder mehr Argumenten, ist die
     Multiplikativität für das erste Argument definiert.  Zum Beispiel
     wird 'f(a*x + b, x)' zu 'f(g(x), x)*f(h(x), x)' vereinfacht.

     Diese Vereinfachung werden nicht für Ausdrücke der Form
     'product(x[i], i, m, n)' ausgeführt.

     Siehe auch die Funktion 'declare'.

     Beispiel:

          (%i1) F2 (a * b * c);
          (%o1)                       F2(a b c)
          (%i2) declare (F2, multiplicative);
          (%o2)                         done
          (%i3) F2 (a * b * c);
          (%o3)                   F2(a) F2(b) F2(c)

 -- Funktion: multthru (<expr>)
 -- Funktion: multthru (<expr_1>, <expr_2>)

     Multipliziert einen oder mehrere Faktoren in eine Summe herein.
     'multthru' expandiert keine Potenzen von Summen.  'multthru' ist
     die effizienteste Methode, um Produkte von Summen
     auszumultiplizieren.  Da Maxima intern die Division als ein Produkt
     darstellt, kann 'multthru' auch angewendet werden, um einen Nenner
     in eine Summe hereinzumultiplizieren.

     'multthru(<expr_1>, <expr_2>)' multipliziert jeden Term des
     Ausdrucks <expr_2> mit <expr_1>.  Der Ausdruck <expr_2> kann dabei
     eine Summe oder eine Gleichung sein.

     Siehe auch die Funktionen 'expand' und 'function_distrib'.

          (%i1) x/(x-y)^2 - 1/(x-y) - f(x)/(x-y)^3;
                                1        x         f(x)
          (%o1)             - ----- + -------- - --------
                              x - y          2          3
                                      (x - y)    (x - y)
          (%i2) multthru ((x-y)^3, %);
                                     2
          (%o2)             - (x - y)  + x (x - y) - f(x)
          (%i3) ratexpand (%);
                                     2
          (%o3)                   - y  + x y - f(x)
          (%i4) ((a+b)^10*s^2 + 2*a*b*s + (a*b)^2)/(a*b*s^2);
                                  10  2              2  2
                           (b + a)   s  + 2 a b s + a  b
          (%o4)            ------------------------------
                                            2
                                       a b s
          (%i5) multthru (%);  /* note that this does not expand (b+a)^10 */
                                                  10
                                 2   a b   (b + a)
          (%o5)                  - + --- + ---------
                                 s    2       a b
                                     s
          (%i6) multthru (a.(b+c.(d+e)+f));
          (%o6)            a . f + a . c . (e + d) + a . b
          (%i7) expand (a.(b+c.(d+e)+f));
          (%o7)         a . f + a . c . e + a . c . d + a . b

 -- Eigenschaft: nary

     Erhält eine Funktion oder ein Operator mit der Funktion 'declare'
     die Eigenschaft 'nary', werden verschachtelte Anwendungen der
     Funktion oder des Operators wie zum Beispiel 'foo(x, foo(y, z))' zu
     'foo(x, y, z)' vereinfacht.  Die Deklaration als 'nary'
     unterscheidet sich von der Funktion 'nary'.  Während der
     Funktionsaufruf einen neuen Operator definiert, wirkt sich die
     Deklaration nur auf die Vereinfachung aus.

     Beispiel:

          (%i1) H (H (a, b), H (c, H (d, e)));
          (%o1)               H(H(a, b), H(c, H(d, e)))
          (%i2) declare (H, nary);
          (%o2)                         done
          (%i3) H (H (a, b), H (c, H (d, e)));
          (%o3)                   H(a, b, c, d, e)

 -- Optionsvariable: negdistrib
     Standardwert: 'true'

     Hat 'negdistrib' den Wert 'true', wird die Zahl -1 in eine Summe
     hereinmultipliziert.  Zum Beispiel wird '-(x + y)' zu '- y - x'
     vereinfacht.  'true' ist der Standardwert von 'negdistrib'.

     Erhält 'negdistrib' den Wert 'false' wird '-(x + y)' nicht
     vereinfacht.  'negdistrib' sollte sehr umsichtig und nur in
     speziellen Fällen für lokale Vereinfachungen genutzt werden.

 -- Systemvariable: opproperties

     'opproperties' ist eine Liste mit den Eigenschaften, die eine
     Funktion oder ein Operator erhalten kann und die die Vereinfachung
     der Funktionen und Operatoren kontrollieren.  Diese Eigenschaften
     erhalten die Funktionen und Operatoren mit der Funktion 'declare'.
     Es gibt weitere Eigenschaften, die Funktionen, Operatoren und
     Variablen erhalten können.  Die Systemvariable 'features' enthält
     eine vollständige Liste der Eigenschaften, die in Maximas Datenbank
     eingetragen werden.  Darüberhinaus können mit der Funktion
     'declare' noch Eigenschaften definiert werden, die in der
     Lisp-Eigenschaftsliste eingetragen werden.

     Die folgenden Eigenschaften sind in der Liste 'opproperties'
     enthalten und kontrollieren die Vereinfachung von Funktionen und
     Operatoren:

        linear          additive        multiplicative
        outative        commutative     symmetric
        antisymmetric   nary            lassociativ
        rassociative    evenfun         oddfun

 -- Eigenschaft: outative

     'declare(f, outative)' deklariert eine Funktion 'f' als outative.
     Hat der Operator oder die Funktion Argumente mit konstanten
     Faktoren, so werden diese konstanten Faktoren herausgezogen.

     Hat die Funktion 'f' ein Argument, dann wird 'f(a*x)' zu 'a*f(x)'
     vereinfacht, wenn 'a' ein konstanter Faktor ist.

     Ist 'f' eine Funktion mit zwei oder mehr Argumenten, ist die
     Outativität für das erste Argument definiert.  Zum Beispiel wird
     'f(a*g(x), x)' zu 'a*f(g(x),x)' vereinfacht, wenn 'a' ein
     konstanter Faktor ist.

     Die Funktionen 'sum', 'integrate' und 'limit' haben die Eigenschaft
     'outative'.  Siehe auch die Funktion 'declare'.

     Beispiel:

          (%i1) F1 (100 * x);
          (%o1)                       F1(100 x)
          (%i2) declare (F1, outative);
          (%o2)                         done
          (%i3) F1 (100 * x);
          (%o3)                       100 F1(x)
          (%i4) declare (zz, constant);
          (%o4)                         done
          (%i5) F1 (zz * y);
          (%o5)                       zz F1(y)

 -- Funktion: radcan (<expr>)

     Die Funktion 'radcan' vereinfacht Ausdrücke, die die
     Logarithmusfunktion, Exponentialfunktionen und Wurzeln enthalten.

     Beispiele:

          (%i1) radcan((log(x+x^2)-log(x))^a/log(1+x)^(a/2));
                                                     a/2
          (%o1)                            log(x + 1)

          (%i2) radcan((log(1+2*a^x+a^(2*x))/log(1+a^x)));
          (%o2)                                  2

          (%i3) radcan((%e^x-1)/(1+%e^(x/2)));
                                               x/2
          (%o3)                              %e    - 1

 -- Optionsvariable: radexpand
     Standardwert: 'true'

     'radexpand' kontrolliert die Vereinfachung von Wurzeln.

     Hat 'radexpand' den Wert 'all', werden die nten-Wurzeln der
     Faktoren eines Produktes, die eine n-te Potenz sind, aus der Wurzel
     herausgezogen.  Zum Beispiel vereinfacht 'sqrt(16*x^2' zu '4*x'.

     Inbesondere vereinfacht der Ausdruck 'sqrt(x^2)' folgendermaßen:

        * Hat 'radexpand' den Wert 'all' oder wurde 'assume(x>0)'
          ausgeführt, dann vereinfacht 'sqrt(x^2)' zu 'x'.

        * Hat 'radexpand' den Wert 'true' und 'domain' ist 'real', dann
          vereinfacht 'sqrt(x^2)' zu 'abs(x)'.

        * Hat 'radexpand' den Wert 'false' oder hat 'radexpand' den Wert
          'true' und 'domain' ist 'complex', dann wird 'sqrt(x^2)' nicht
          vereinfacht.

 -- Eigenschaft: rassociative

     'declare(f, rassociative)' deklariert die Funktion 'f' als
     rechts-assioziativ.  Zum Beispiel wird 'f(f(a, b), f(c, d))' zu
     'f(a, f(b, f(c, d)))' vereinfacht.

     Siehe auch die Eigenschaft 'lassociative' und die Funktion
     'declare'.

 -- Funktion: scsimp (<expr>, <rule_1>, ..., <rule_n>)

     Sequential Comparative Simplification (Methode nach Stoute).

     'scsimp' versucht den Ausdruck <expr> mit Hilfe der Regeln
     <rule_1>, ..., <rule_n> zu vereinfachen.  Die Regeln werden
     nacheinander solange angewendet, bis sich der Ausdruck nicht weiter
     vereinfacht.  Führt keine der Regeln zu einem Erfolg, wird der
     ursprüngliche Ausdruck zurückgegeben.

     'example(scsimp)' zeigt einige Beispiele.

 -- Optionsvariable: simp
     Standardwert: 'true'

     'simp' kontrolliert die Vereinfachung von Ausdrücken.  Der
     Standardwert von 'simp' ist 'true' und Ausdrücke werden
     vereinfacht.  'simp' ist auch ein Auswertungsschalter für die
     Funktion 'ev'.

     Wird 'simp' als ein Auswertungschalter mit dem Wert 'false'
     genutzt, dann wird die Vereinfachung nur während der
     Auswertungsphase unterdrückt.  'simp' kann nicht die Vereinfachung
     unterdrücken, die sich der Auswertung anschließt.

     Beispiele:

     Die Vereinfachung wird ausgeschaltet.  Der Ausdruck 'sin(1.0)' wird
     nicht zu einem numerischen Wert vereinfacht.  Der
     Auswertungsschalter 'simp' schaltet die Vereinfachung ein.

          (%i1) simp:false;
          (%o1)                                false
          (%i2) sin(1.0);
          (%o2)                              sin(1.0)
          (%i3) sin(1.0),simp;
          (%o3)                          .8414709848078965

     Die Vereinfachung wird wieder eingeschaltet.  Der
     Auswertungsschalter 'simp' kann die Vereinfachung nicht vollständig
     unterdrücken.  In der Ausgabe ist der Ausdruck vereinfacht, aber
     die Variable 'x' enthält einen nicht vereinfachten Ausdruck, da die
     Zuweisung noch während der Auswertungsphase des Ausdrucks
     vorgenommen wurde.

          (%i4) simp:true;
          (%o4)                                true
          (%i5) x:sin(1.0),simp:false;
          (%o5)                          .8414709848078965
          (%i6) :lisp $X
          ((%SIN) 1.0)

 -- Eigenschaft: symmetric

     'declare(f, symmetric)' deklariert die Funktion 'f' als
     symmetrisch.  Zum Beispiel wird 'f(x, z, y)' zu 'f(x, y, z)'
     vereinfacht.

     'commutative' entspricht 'symmetric' Siehe auch die Funktion
     'declare'.

     Beispiel:

          (%i1) S (b, a);
          (%o1)                        S(b, a)
          (%i2) declare (S, symmetric);
          (%o2)                         done
          (%i3) S (b, a);
          (%o3)                        S(a, b)
          (%i4) S (a, c, e, d, b);
          (%o4)                   S(a, b, c, d, e)

 -- Funktion: xthru (<expr>)

     Die Terme einer Summe des Ausdrucks <expr> werden so
     zusammengefasst, dass sie einen gemeinsamen Nenner haben.  Produkte
     und Potenzen von Summen werden dabei nicht expandiert.  Gemeinsame
     Faktoren im Zähler und Nenner werden gekürzt.

     Es kann vorteilhaft sein, vor dem Ausführen von 'ratsimp' zunächst
     mit 'xthru' die gemeinsamen Faktoren eines rationalen Ausdrucks zu
     kürzen.

     Siehe auch die Funktion 'combine'.

     Beispiele:

          (%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
                                          20
                           1       (x + 2)   - 2 y       x
          (%o1)        --------- + --------------- - ---------
                              19             20             20
                       (y + x)        (y + x)        (y + x)
          (%i2) xthru (%);
                                           20
                                    (x + 2)   - y
          (%o2)                     -------------
                                             20
                                      (y + x)


File: maxima.info,  Node: Mathematische Funktionen,  Next: Maximas Datenbank,  Prev: Vereinfachung,  Up: Top

10 Mathematische Funktionen
***************************

* Menu:

* Funktionen für Zahlen::
* Funktionen für komplexe Zahlen::
* Funktionen der Kombinatorik::
* Wurzel- Exponential- und Logarithmusfunktion::
* Winkelfunktionen::
* Hyperbelfunktionen::
* Zufallszahlen::


File: maxima.info,  Node: Funktionen für Zahlen,  Next: Funktionen für komplexe Zahlen,  Prev: Mathematische Funktionen,  Up: Mathematische Funktionen

10.1 Funktionen für Zahlen
==========================

 -- Funktion: abs (<z>)

     Die Funktion 'abs' ist die Betragsfunktion und für das numerische
     und symbolische Rechnen geeignet.  Ist das Argument <z> eine reelle
     oder komplexe Zahl wird der Betrag berechnet.  Wenn möglich werden
     allgemeine Ausdrücke mit der Betragsfunktion vereinfacht.  Maxima
     kann Ausdrücke mit der Betragsfunktion integrieren und ableiten
     sowie Grenzwerte von Ausdrücken mit der Betragsfunktion ermitteln.
     Das Paket 'abs_integrate' erweitert Maximas Möglichkeiten,
     Integrale mit der Betragsfunktion zu lösen.

     Die Betragsfunktion wird automatisch auf die Elemente von Listen
     und Matrizen sowie auf die beiden Seiten von Gleichungen
     angewendet.  Siehe 'distribute_over'.

     Siehe die Funktion 'cabs', um den Betrag eines komplexen Ausdrucks
     oder einer Funktion zu berechnen.

     Beispiele:

     Berechnung des Betrages für reelle und komplexen Zahlen sowie
     numerische Konstanten und unendliche Größen.  Das erste Beispiel
     zeigt, wie die Betragsfunktion von Maxima auf die Elemente einer
     Liste angewendet wird.

          (%i1) abs([-4, 0, 1, 1+%i]);
          (%o1)                  [4, 0, 1, sqrt(2)]

          (%i2) abs((1+%i)*(1-%i));
          (%o2)                           2
          (%i3) abs(%e+%i);
                                          2
          (%o3)                    sqrt(%e  + 1)
          (%i4) abs([inf, infinity, minf]);
          (%o4)                   [inf, inf, inf]

     Vereinfachung von Ausdrücken mit der Betragsfunktion.

          (%i5) abs(x^2);
                                          2
          (%o5)                          x
          (%i6) abs(x^3);
                                       2
          (%o6)                       x  abs(x)

          (%i7) abs(abs(x));
          (%o7)                       abs(x)
          (%i8) abs(conjugate(x));
          (%o8)                       abs(x)

     Ableitung und Integrale mit der Betragsfunktion.  Wird das Paket
     abs_integrate geladen, können weitere Integrale mit der
     Betragsfunktion gelöst werden.  Das letzte Beispiel zeigt die
     Laplacetransformation der Betragsfunktion.  Siehe 'laplace'.

          (%i9) diff(x*abs(x),x),expand;
          (%o9)                       2 abs(x)

          (%i10) integrate(abs(x),x);
                                       x abs(x)
          (%o10)                       --------
                                          2

          (%i11) integrate(x*abs(x),x);
                                     /
                                     [
          (%o11)                     I x abs(x) dx
                                     ]
                                     /

          (%i12) load(abs_integrate)$
          (%i13) integrate(x*abs(x),x);
                                2           3
                               x  abs(x)   x  signum(x)
          (%o13)               --------- - ------------
                                   2            6

          (%i14) integrate(abs(x),x,-2,%pi);
                                         2
                                      %pi
          (%o14)                      ---- + 2
                                       2

          (%i15) laplace(abs(x),x,s);
                                         1
          (%o15)                         --
                                          2
                                         s

 -- Funktion: ceiling (<x>)

     Die Funktion 'ceiling' ist für das numerische und symbolische
     Rechnen geeignet.

     Ist das Argument <x> eine reelle Zahl, gibt 'ceiling' die kleinste
     ganze Zahl zurück, die größer oder gleich <x> ist.

     Die Funktion 'ceiling' gibt auch dann einen numerischen Wert
     zurück, wenn das Argument ein konstanter Ausdruck ist, wie zum
     Beispiel '1+%e', der zu einer reellen Zahl ausgewertet werden kann.
     In diesem Fall wird der konstante Ausdruck in eine große
     Gleitkommazahl umgewandelt, auf die die Funktion 'ceiling'
     angewendet wird.  Aufgrund von Rundungsfehlern bei der Umwandlung
     in Gleitkommazahlen kann es zu Fehlern bei der Berechnung von
     'ceiling' kommen.  Um diese zu minimieren, wird die Anzahl der
     Stellen 'fpprec' für die Berechnung von 'ceiling' um drei Stellen
     erhöht.

     Ist das Argument <expr> der Funktion ein komplexer Ausdruck, wird
     eine Substantivform zurückgegeben.

     Wenn möglich werden Ausdrücke mit der Funktion 'ceiling' von Maxima
     vereinfacht.  Maxima kennt insbesondere Vereinfachungen für den
     Fall, dass das Argument der Funktion 'ceiling' ein Ausdruck mit den
     Funktionen 'floor' oder 'round' ist.  Weiterhin werden für die
     Vereinfachung die Aussagen und Fakten der aktiven Kontexte
     herangezogen.  Siehe *note Funktionen und Variablen für Fakten::.

     'ceiling' wird automatisch auf die Elemente von Listen und Matrizen
     sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
     'distribute_over'.

     Siehe auch die Funktionen 'floor' und 'round'.

     Beispiele:

          (%i1) ceiling(ceiling(x));
          (%o1)                      ceiling(x)
          (%i2) ceiling(floor(x));
          (%o2)                       floor(x)
          (%i3) declare (n, integer)$
          (%i4) ceiling([n, abs(n), max (n, 6)]);
          (%o4)               [n, abs(n), max(6, n)]
          (%i5) assume (x > 0, x < 1)$
          (%i6) ceiling (x);
          (%o6)                           1

     Sind die Werte einer Funktion eine Teilmenge der ganzen Zahlen,
     kann diese als 'integervalued' deklariert werden.  Die Funktionen
     'ceiling' und 'floor' können diese Information nutzen, um Ausdrücke
     zu vereinfachen.

          (%i1) declare (f, integervalued)$
          (%i2) floor (f(x));
          (%o2)                         f(x)
          (%i3) ceiling (f(x) - 1);
          (%o3)                       f(x) - 1

     Maxima kennt das Integral der Funktion 'ceiling'.

          (%i1) integrate(ceiling(x),x);
                         (- ceiling(x) + 2 x + 1) ceiling(x)
          (%o1)          -----------------------------------
                                          2

 -- Funktion: entier (<x>)

     'entier' ist eine andere Bezeichnung für die Funktion 'floor'.
     Siehe 'floor'.

 -- Funktion: floor (<x>)

     Die Funktion 'floor' ist für das numerische und symbolische Rechnen
     geeignet.

     Ist das Argument <x> eine reelle Zahl, gibt 'floor' die größte
     ganze Zahl zurück, die kleiner oder gleich <x> ist.

     Die Funktion 'floor' gibt auch dann einen numerischen Wert zurück,
     wenn das Argument ein konstanter Ausdruck ist, wie zum Beispiel
     '1+%e', der zu einer reellen Zahl ausgewertet werden kann.  In
     diesem Fall wird der konstante Ausdruck in eine große
     Gleitkommazahl umgewandelt, auf die die Funktion 'floor' angewendet
     wird.  Aufgrund von Rundungsfehlern bei der Umwandlung in
     Gleitkommazahlen kann es zu Fehlern bei der Berechnung von 'floor'
     kommen.  Um diese zu minimieren, wird die Anzahl der Stellen
     'fpprec' für die Berechnung von 'floor' um drei Stellen erhöht.

     Ist das Argument <x> der Funktion ein komplexer Ausdruck, wird eine
     Substantivform zurückgegeben.

     Wenn möglich werden Ausdrücke mit der Funktion 'floor' von Maxima
     vereinfacht.  Maxima kennt insbesondere Vereinfachungen für den
     Fall, dass das Argument der Funktion 'floor' ein Ausdruck mit den
     Funktionen 'ceiling' oder 'round' ist.  Weiterhin werden für die
     Vereinfachung die Aussagen und Fakten der aktiven Kontexte
     herangezogen.  Siehe *note Funktionen und Variablen für Fakten::.

     'floor' wird automatisch auf die Elemente von Listen und Matrizen
     sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
     'distribute_over'.

     Siehe auch die Funktionen 'ceiling' und 'round'.

     Beispiele:

          (%i1) floor(ceiling(x));
          (%o1)                      ceiling(x)
          (%i2) floor(floor(x));
          (%o2)                       floor(x)
          (%i3) declare(n, integer);
          (%o3)                         done
          (%i4) floor([n, abs(n), min (n, 6)]);
          (%o4)                [n, abs(n), min(6, n)]
          (%i5) assume(x>0, x<1)$
          (%i6) floor(x);
          (%o6)                           0

     Sind die Werte einer Funktion eine Teilmenge der ganzen Zahlen,
     kann diese als 'integervalued' deklariert werden.  Die Funktionen
     'ceiling' und 'floor' können diese Information nutzen, um Ausdrücke
     zu vereinfachen.

          (%i1) declare (f, integervalued)$
          (%i2) floor(f(x));
          (%o2)                         f(x)
          (%i3) ceiling(f(x) - 1);
          (%o3)                       f(x) - 1

     Maxima kennt das Integral der Funktion 'floor'.

          (%i6) integrate(floor(x),x);
                           (- floor(x) + 2 x - 1) floor(x)
          (%o6)            -------------------------------
                                          2

 -- Funktion: fix (<x>)

     'fix' ist eine andere Bezeichnung für die Funktion 'floor'.  Siehe
     'floor'.

 -- Funktion: lmax (<L>)

     Ist das Argument <L> eine Liste oder Menge, wird die Funktion 'max'
     auf die Elemente der Liste oder Menge angewendet und das Ergebnis
     zurückgegeben.  Ist <L> keine Liste oder Menge, signalisiert Maxima
     einen Fehler.

     Beispiel:

          (%i1) L:[1+%e, %pi, 3];
          (%o1)                   [%e + 1, %pi, 3]
          (%i1) lmax(L);
          (%o1)                        %e + 1

 -- Funktion: lmin (<L>)

     Ist das Argument <L> eine Liste oder Menge, wird die Funktion 'min'
     auf die Elemente der Liste oder Menge angewendet und das Ergebnis
     zurückgegeben.  Ist <L> keine Liste oder Menge, signalisiert Maxima
     einen Fehler.

     Beispiel:

          (%i1) L:[1+%e, %pi, 3];
          (%o1)                   [%e + 1, %pi, 3]
          (%i2) lmin(L);
          (%o2)                           3

 -- Funktion: max (<x_1>, ..., <x_n>)

     Sind alle Argumente <x_1>, ..., <x_n> Zahlen oder konstante
     Ausdrücke wie zum Beispiel '1+%e' oder 'sin(1)', dann wird der
     größte Zahlenwert zurückgegeben.  Sind symbolische Variablen oder
     allgemeine Ausdrücke unter den Argumenten, gibt Maxima einen
     vereinfachten Ausdruck zurück.  Die unendliche Größen 'inf' und
     'minf' können als Argument auftreten.

     Die Vereinfachung der Funktion 'max' kann kontrolliert werden, in
     dem mit der Funktion 'put' dem Symbol 'trylevel' zu der Eigenschaft
     'maxmin' ein Wert zwischen 1 bis 3 gegeben wird.  Folgende Werte
     können mit der Funktion 'put' gesetzt werden:

     'put(trylevel, 1, maxmin)'
          'trylevel' hat den Wert 1.  Das ist der Standardwert.  Maxima
          führt keine besonderen Vereinfachungen aus.
     'put(trylevel, 2, maxmin)'
          Maxima wendet die Vereinfachung 'max(e,-e) --> |e|' an.
     'put(trylevel, 3, maxima)'
          Maxima wendet die Vereinfachung 'max(e,-e) --> |e|' an und
          versucht Ausdrücke zu eliminieren, die zwischen zwei anderen
          Argumenten liegen.  So wird zum Beispiel 'max(x, 2*x, 3*x)' zu
          'max(x, 3*x)' vereinfacht.

     Mit dem Kommando 'get(trylevel, maxmin)' wird der aktuelle Wert für
     das Symbol 'trylevel' angezeigt.  Siehe die Funktion 'get'.

     'max' berücksichtigt bei der Vereinfachung von Ausdrücken die
     Aussagen und Fakten der aktiven Kontexte.  Siehe das Kapitel *note
     Funktionen und Variablen für Fakten::.

     Beispiele:

          (%i1) max(1.6, 3/2, 1);
          (%o1)                          1.6
          (%i2) max(1.5b0,1.5,3/2);
                                          3
          (%o2)                           -
                                          2
          (%i3) max(%e,%pi,1,2,3);
          (%o3)                          %pi
          (%i4) max(1+%e,%pi,1,2,3);
          (%o4)                        %e + 1
          (%i5) max(minf,inf);
          (%o5)                          inf
          (%i6) assume(a>b);
          (%o6)                        [a > b]
          (%i7) max(a,b);
          (%o7)                           a

 -- Funktion: min (<x_1>, ..., <x_n>)

     Sind alle Argumente <x_1>, ..., <x_n> Zahlen oder konstante
     Ausdrücke wie zum Beispiel '1+%e' oder 'sin(1)', dann wird der
     kleinste Zahlenwert zurückgegeben.  Sind symbolische Variablen oder
     allgemeine Ausdrücke unter den Argumenten, gibt Maxima einen
     vereinfachten Ausdruck zurück.  Die unendliche Größen 'inf' und
     'minf' können als Argument auftreten.

     Die Vereinfachung der Funktion 'min' kann kontrolliert werden, in
     dem mit der Funktion 'put' dem Symbol 'trylevel' zu der Eigenschaft
     'maxmin' ein Wert zwischen 1 bis 3 gegeben wird.  Folgende Werte
     können mit der Funktion 'put' gesetzt werden:

     'put(trylevel, 1, maxmin)'
          'trylevel' hat den Wert 1.  Das ist der Standardwert.  Maxima
          führt keine besonderen Vereinfachungen aus.
     'put(trylevel, 2, maxmin)'
          Maxima wendet die Vereinfachung 'min(e,-e) --> |e|' an.
     'put(trylevel, 3, maxima)'
          Maxima wendet die Vereinfachung 'min(e,-e) --> |e|' an und
          versucht Ausdrücke zu eliminieren, die zwischen zwei anderen
          Argumenten liegen.  So wird zum Beispiel 'min(x, 2*x, 3*x)' zu
          'min(x, 3*x)' vereinfacht.

     Mit dem Kommando 'get(trylevel, maxmin)' wird der aktuelle Wert für
     das Symbol 'trylevel' angezeigt.  Siehe die Funktion 'get'.

     'min' berücksichtigt bei der Vereinfachung von Ausdrücken die
     Aussagen und Fakten der aktiven Kontexte.  Siehe das Kapitel
     Funktionen und Variablen für Fakten.

     Beispiele:

          (%i1) min(1.6, 3/2, 1);
          (%o1)                           1
          (%i2) min(1.5b0,1.5,3/2);
                                          3
          (%o2)                           -
                                          2
          (%i3) min(%e,%pi,3);
          (%o3)                          %e
          (%i4) min(1+%e,%pi,3);
          (%o4)                           3
          (%i5) min(minf,inf);
          (%o5)                         minf
          (%i6) assume(a>b);
          (%o6)                        [a > b]
          (%i7) min(a,b);
          (%o7)                           b

 -- Funktion: round (<x>)

     Die Funktion 'round' ist für das numerische und symbolische Rechnen
     geeignet.

     Ist das Argument <x> eine reelle Zahl, gibt 'round' die am nächsten
     liegende ganze Zahl zurück.  Vielfache von 1/2 werden auf die
     nächste gerade ganze Zahl gerundet.

     Die Funktion 'round' gibt auch dann einen numerischen Wert zurück,
     wenn das Argument ein konstanter Ausdruck ist, wie zum Beispiel
     '1+%e', der zu einer reellen Zahl ausgewertet werden kann.  In
     diesem Fall wird der konstante Ausdruck in eine große
     Gleitkommazahl umgewandelt, auf die die Funktion 'round' angewendet
     wird.  Aufgrund von Rundungsfehlern bei der Umwandlung in
     Gleitkommazahlen kann es zu Fehlern bei der Berechnung von 'round'
     kommen.  Um diese zu minimieren, wird die Anzahl der Stellen
     'fpprec' für die Berechnung von 'round' um drei Stellen erhöht.

     Ist das Argument <x> der Funktion ein komplexer Ausdruck, wird eine
     Substantivform zurückgegeben.

     Wenn möglich werden Ausdrücke mit der Funktion 'round' von Maxima
     vereinfacht.  Maxima kennt insbesondere Vereinfachungen für den
     Fall, dass das Argument der Funktion 'round' ein Ausdruck mit den
     Funktionen 'ceiling' oder 'floor' ist.  Weiterhin werden für die
     Vereinfachung die Aussagen und Fakten der aktiven Kontexte
     herangezogen.  Siehe *note Funktionen und Variablen für Fakten::.

     'round' wird automatisch auf die Elemente von Listen und Matrizen
     sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
     'distribute_over'.

     Siehe auch die Funktionen 'ceiling' und 'floor'.

     Beispiele:

          (%i1) round(floor(x));
          (%o1)                       floor(x)
          (%i2) round(round(x));
          (%o2)                       round(x)
          (%i3) declare(n, integer);
          (%o3)                         done
          (%i4) round([n, abs(n), min(n,6)]);
          (%o4)                [n, abs(n), min(6, n)]

     Sind die Werte einer Funktion eine Teilmenge der ganzen Zahlen,
     kann diese als 'integervalued' deklariert werden.  Die Funktion
     'round' kann diese Information nutzen, um Ausdrücke zu
     vereinfachen.

          (%i1) declare(f, integervalued);
          (%o1)                         done
          (%i2) round(f(x));
          (%o2)                         f(x)
          (%i3) round(f(x) - 1);
          (%o3)                       f(x) - 1

 -- Funktion: signum (<z>)

     Die Signumfunktion 'signum' ist für das numerische und symbolische
     Rechnen geeignet.  Ist das Argument <z> eine Zahl, ist das Ergebnis
     0, 1 oder -1, wenn die Zahl Null, positiv oder negativ ist.  Das
     Argument kann auch ein konstanter Ausdruck wie '%pi' oder '1+%e'
     sein.  Ist das Argument <z> eine komplexe Zahl, vereinfacht die der
     Ausdruck 'signum(z)' zu 'z/abs(z)'.

     Ist das Argument <z> keine Zahl oder kein konstanter Ausdruck,
     versucht Maxima den Ausdruck zu vereinfachen.  Maxima kann die
     Funktion 'signum' differenzieren.  Wird das Paket abs_integrate
     geladen, kann Maxima Integrale mit der Funktion 'signum' lösen.

     'signum' wird automatisch auf die Elemente von Listen und Matrizen
     sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
     'distribute_over'.

     Beispiele:

     Ergebnisse für verschiedene Zahlen und konstante Ausdrücke.  Die
     Beispiele zeigen, dass das Ergebnis der Signumfunktion den Typ der
     Zahl erhält.  Die unendlichen Größen 'minf' und 'inf' können als
     Argument auftreten.

          (%i1) signum([-1.5, 0, 0.0, 1.5, 1.5b0, %e, sin(1), cos(4)]);
          (%o1)        [- 1.0, 0, 0.0, 1.0, 1.0b0, 1, 1, - 1]
          (%i2) signum(1+%i);
                                    %i         1
          (%o2)                   ------- + -------
                                  sqrt(2)   sqrt(2)
          (%i3) signum([minf,inf]);
          (%o3)                      [- 1, 1]

     Vereinfachungen der Signumfunktion.

          (%i3) signum(x*y);
          (%o3)                  signum(x) signum(y)
          (%i4) signum(-x);
          (%o4)                      - signum(x)

     Wird das Paket abs_integrate geladen, kann Maxima Integrale mit der
     Signumfunktion lösen.  Ausdrücke mit der Signumfunktion können
     differenziert werden.

          (%i5) load(abs_integrate)$

          (%i6) integrate(signum(x),x);
          (%o6)                        abs(x)

          (%i7) integrate(sin(x)*signum(x),x);
          (%o7)               (1 - cos(x)) signum(x)

          (%i7) diff(%,x);
          (%o7)                  signum(x) sin(x)


File: maxima.info,  Node: Funktionen für komplexe Zahlen,  Next: Funktionen der Kombinatorik,  Prev: Funktionen für Zahlen,  Up: Mathematische Funktionen

10.2 Funktionen für komplexe Zahlen
===================================

 -- Funktion: cabs (<expr>)

     Berechnet den Betrag eines komplexen Ausdrucks <expr>.  Im
     Unterschied zu der Funktion 'abs', zerlegt die Funktion 'cabs'
     einen komplexen Ausdruck immer in einen Realteil und Imaginärteil,
     um den komplexen Betrag zu berechnen.  Sind <x> und <y> zwei reelle
     Variablen oder Ausdrücke, berechnet die Funktion 'cabs' den Betrag
     des komplexen Ausdrucks 'x + %i*y' als:
                                     2    2
                               sqrt(y  + x )

     Die Funktion 'cabs' nutzt Symmetrieeigenschaften und implementierte
     Eigenschaften komplexer Funktionen, um den Betrag eines Ausdrucks
     zu berechnen.  Sind solche Eigenschaften für eine Funktion
     vorhanden, können diese mit der Funktion 'properties' angezeigt
     werden.  Eigenschaften, die das Ergebnis der Funktion 'cabs'
     bestimmen, sind: 'mirror symmetry', 'conjugate function' und
     'complex characteristic'.

     'cabs' ist eine Verbfunktion, die nicht für das symbolische Rechnen
     geeignet ist.  Für das symbolische Rechnen wie der Integration oder
     der Ableitung von Ausdrücken mit der Betragsfunktion muss die
     Funktion 'abs' verwendet werden.

     Das Ergebnis der Funktion 'cabs' kann die Betragsfunktion 'abs' und
     den Arkustangens 'atan2' enthalten.

     'cabs' wird automatisch auf die Elemente von Listen und Matrizen
     sowie auf die beiden Seiten von Gleichungen angewendet.

     Siehe auch die Funktionen 'rectform', 'realpart', 'imagpart',
     'carg', 'conjugate', und 'polarform' für das Rechnen mit komplexen
     Zahlen.

     Beispiele:

     Zwei Beispiele mit der Wurzelfunktion 'sqrt' und der Sinusfunktion
     'sin'.

          (%i1) cabs(sqrt(1+%i*x));
                                       2     1/4
          (%o1)                      (x  + 1)
          (%i2) cabs(sin(x+%i*y));
                              2        2         2        2
          (%o2)       sqrt(cos (x) sinh (y) + sin (x) cosh (y))

     Die Funktion 'erf' hat Spiegelsymmetrie, die hier für die
     Berechnung des komplexen Betrages angewendet wird.

          (%i3) cabs(erf(x+%i*y));
                                                    2
                     (erf(%i y + x) - erf(%i y - x))
          (%o3) sqrt(--------------------------------
                                    4
                                                                         2
                                          (erf(%i y + x) + erf(%i y - x))
                                        - --------------------------------)
                                                         4

     Maxima kennt komplexe Eigenschaften der Besselfunktionen, um den
     komplexen Betrag zu vereinfachen.  Dies ist ein Beispiel für die
     Besselfunktion 'bessel_j'.

          (%i4) cabs(bessel_j(1,%i));
          (%o4)                 abs(bessel_j(1, %i))

 -- Funktion: carg (<expr>)

     Gibt das komplexe Argument des Ausdrucks <expr> zurück.  Das
     komplexe Argument ist ein Winkel 'theta' im Intervall '(-%pi, %pi)'
     derart, dass <expr> = 'r exp (theta %i)' gilt, wobei 'r' den Betrag
     des komplexen Ausdrucks <expr> bezeichnet.  Das ist die Polarform
     des Ausdrucks, wie sie auch von der Funktion 'polarform'
     zurückgegeben wird.  Der Betrag des komplexen Ausdrucks kann mit
     der Funktion 'cabs' berechnet werden.

     Das Ergebnis der Funktion 'carg' kann die Funktion 'atan2'
     enthalten.

     'carg' wird automatisch auf die Elemente von Listen und Matrizen
     sowie auf die beiden Seiten von Gleichungen angewendet.  Siehe
     'distribute_over'.

     Die Funktion 'carg' ist eine Verbfunktion, mit der nicht symbolisch
     gerechnet werden kann.

     Siehe auch die Funktionen 'rectform', 'realpart' und 'imagpart'
     sowie die Funktionen 'cabs' und 'conjugate'.

     Beispiele:

          (%i1) carg (1);
          (%o1)                           0
          (%i2) carg (1 + %i);
                                         %pi
          (%o2)                          ---
                                          4
          (%i3) carg (exp (%i));
          (%o3)                           1

          (%i4) carg (exp (3/2 * %pi * %i));
                                          %pi
          (%o4)                         - ---
                                           2
          (%i5) carg(exp(x+%i*y));
          (%o5)                atan2(sin(y), cos(y))

          (%i6) carg(sqrt(x+%i*y));
                                    atan2(y, x)
          (%o6)                     -----------
                                         2
          (%i7) carg(sqrt(1+%i*y));
                                      atan(y)
          (%o7)                       -------
                                         2

 -- Funktion: conjugate (<expr>)

     Gibt den konjugiert komplexen Wert des Ausdrucks <expr> zurück.
     Sind <x> und <y> reelle Variablen oder Ausdrücke, dann hat der
     Ausdruck 'x + %i*y' das Ergebnis 'x - %i*y'.  Die Funktion
     'conjugate' ist für numerische und symbolische Rechnungen geeignet.

     Maxima kennt Regeln, um den konjugierten Wert für Summen, Produkte
     und Quotienten von komplexen Ausdrücken zu vereinfachen.  Weiterhin
     kennt Maxima Symmetrieeigenschaften und komplexe Eigenschaften von
     Funktionen, um den konjugierten Wert mit diesen Funktionen zu
     vereinfachen.  Sind solche Eigenschaften für eine Funktion
     vorhanden, können diese mit der Funktion 'properties' angezeigt
     werden.  Eigenschaften, die das Ergebnis der Funktion 'conjugate'
     bestimmen, sind: 'mirror symmetry', 'conjugate function' und
     'complex characteristic'.

     'conjugate' wird automatisch auf die Elemente von Listen und
     Matrizen sowie auf die beiden Seiten von Gleichungen angewendet.
     Siehe 'distribute_over'.

     Für das Rechnen mit komplexen Ausdrücken siehe auch die Funktionen
     'cabs' und 'carg' sowie 'rectform' und 'polarform'.

     Beispiele:

     Beispiele mit reellen, imaginären und komplexen Variablen.

          (%i1) declare ([x, y], real, [z1, z2], complex, j, imaginary);
          (%o1)                         done
          (%i2) conjugate(x + %i*y);
          (%o2)                       x - %i y
          (%i3) conjugate(z1*z2);
          (%o3)              conjugate(z1) conjugate(z2)
          (%i4) conjugate(j/z2);
                                           j
          (%o4)                    - -------------
                                     conjugate(z2)

     Im Folgenden nutzt Maxima Symmetrieeigenschaften, um den konjugiert
     komplexen Wert der Funktionen 'gamma' und 'sin' zu berechnen.  Die
     Logarithmusfunktion 'log' hat Spiegelsymmetrie, wenn das Argument
     einen positiven Realteil hat.

          (%i5) conjugate(gamma(x+%i*y));
          (%o5)                    gamma(x - %i y)
          (%i6) conjugate(sin(x+%i*y));
          (%o6)                    - sin(%i y - x)
          (%i7) conjugate(log(x+%i*y));
          (%o7)               conjugate(log(%i y + x))
          (%i8) conjugate(log(1+%i*y));
          (%o8)                     log(1 - %i y)

 -- Funktion: imagpart (<expr>)

     Gibt den Imaginärteil des Ausrucks <expr> zurück.  Intern berechnet
     Maxima den Imaginärteil mit der Funktion 'rectform', die einen
     Ausdruck in den Realteil und in den Imaginärteil zerlegt.  Daher
     treffen die Ausführungen zu 'rectform' auch auf die Funktion
     'imagpart' zu.

     Wie die Funktion 'rectform' ist auch die Funktion 'imagpart' eine
     Verbfunktion, mit der nicht symbolisch gerechnet werden kann.

     'imagpart' wird automatisch auf die Elemente von Listen und
     Matrizen sowie auf die beiden Seiten von Gleichungen angewendet.
     Siehe 'distribute_over'.

     Mit der Funktion 'realpart' wird der Realteil eines Ausdrucks
     berechnet.

     Siehe auch die Funktionen 'cabs', 'carg' und 'conjugate' für das
     Rechnen mit komplexen Zahlen.  Mit der Funktion 'polarform' kann
     ein komplexer Ausdruck in die Polarform gebracht werden.

     Beispiele:

     Für weitere Erläuterungen dieser Beispiele siehe auch die Funktion
     'rectform'.

          (%i1) imagpart((2-%i)/(1-%i));
                                          1
          (%o1)                           -
                                          2
          (%i2) imagpart(sin(x+%i*y));
          (%o2)                    cos(x) sinh(y)
          (%i3) imagpart(gamma(x+%i*y));
                       %i (gamma(x - %i y) - gamma(%i y + x))
          (%o3)        --------------------------------------
                                         2
          (%i4) imagpart(bessel_j(1,%i));
          (%o4)                    bessel_j(1, %i)

 -- Funktion: polarform (<expr>)

     Gibt den Ausdruck <expr> in der Polarform 'r %e^(%i theta)' zurück.
     'r' ist der Betrag des komplexen Ausdrucks, wie er auch mit der
     Funktion 'cabs' berechnet werden kann.  'theta' ist das Argument
     des komplexen Ausdrucks, das mit der Funktion 'carg' berechnet
     werden kann.

     Maxima kennt komplexe Eigenschaften von Funktionen, die bei der
     Berechnung der Polarform angewendet werden.  Siehe die Funktion
     'cabs' für weitere Erläuterungen.

     Wenn mit komplexen Ausdrücken in der Polarform gerechnet werden
     soll, ist es hilfreich die Optionsvariable '%emode' auf den Wert
     'false' zu setzen.  Damit wird verhindert, dass Maxima komplexe
     Ausdrücke mit der Exponentialfunktion 'exp' automatisch in die
     Standardform vereinfacht.

     'polarform' wird automatisch auf die Elemente von Listen und
     Matrizen sowie auf die beiden Seiten von Gleichungen angewendet.
     Siehe 'distribute_over'.

     Die Funktion 'polarform' ist eine Verbfunktion, mit der nicht
     symbolisch gerechnet werden kann.

     Siehe auch die Funktionen 'cabs', 'carg' und 'conjugate' für das
     Rechnen mit komplexen Zahlen.  Mit der Funktion 'rectform' kann ein
     komplexer Ausdruck in die Standardform gebracht werden.

     Beispiele:

     Die allgemeine Polarform eines komplexen Ausdrucks.  Die Variablen
     <x> und <y> werden von Maxima als reell angenommen.

          (%i1) polarform(x+%i*y);
                                 2    2    %i atan2(y, x)
          (%o1)            sqrt(y  + x ) %e

     Die Polarform einer komplexen Zahl und eines Ausdrucks mit einer
     reellen Variablen <x>.

          (%i2) polarform(4/5+3*%i/5);
                                     %i atan(3/4)
          (%o2)                    %e
          (%i3) polarform(sqrt(1+%i*x));
                                            %i atan(x)
                                            ----------
                                2     1/4       2
          (%o3)               (x  + 1)    %e

     Wenn in der Polarform gerechnet werden soll, ist es hilfreich die
     Optionsvariable '%emode' auf den Wert 'false' zu setzen.  Damit
     wird verhindert, dass Maxima komplexe Ausdrücke mit der
     Exponentialfunktion 'exp' automatisch in eine Standardform
     vereinfacht.

          (%i4) z:polarform(1+%i);
                                            %i %pi
                                            ------
                                              4
          (%o4)                   sqrt(2) %e
          (%i5) z^3;
                               3/2    %i         1
          (%o5)               2    (------- - -------)
                                    sqrt(2)   sqrt(2)
          (%i6) %emode:false;
          (%o6)                         false
          (%i7) z^3;
                                          3 %i %pi
                                          --------
                                    3/2      4
          (%o7)                    2    %e

 -- Funktion: realpart (<expr>)

     Gibt den Realteil des Ausdrucks <expr> zurück.  Intern berechnet
     Maxima den Realteil mit der Funktion 'rectform', die einen Ausdruck
     in den Realteil und in den Imaginärteil zerlegt.  Daher treffen die
     Ausführungen zu 'rectform' auch auf die Funktion 'realpart' zu.

     Wie die Funktion 'rectform' ist auch die Funktion 'realpart' eine
     Verbfunktion, mit der nicht symbolisch gerechnet werden kann.

     'realpart' wird automatisch auf die Elemente von Listen und
     Matrizen sowie auf die beiden Seiten von Gleichungen angewendet.
     Siehe 'distribute_over'.

     Mit der Funktion 'imagpart' wird der Imaginärteil eines Ausdrucks
     berechnet.

     Siehe auch die Funktionen 'cabs', 'carg' und 'conjugate' für das
     Rechnen mit komplexen Zahlen.  Mit der Funktion 'polarform' kann
     ein komplexer Ausdruck in die Polarform gebracht werden.

     Beispiele:

     Für weitere Erläuterungen dieser Beispiele siehe auch die Funktion
     'rectform'.

          (%i1) realpart((2-%i)/(1-%i));
                                          3
          (%o1)                           -
                                          2
          (%i2) realpart(sin(x+%i*y));
          (%o2)                    sin(x) cosh(y)
          (%i3) realpart(gamma(x+%i*y));
                          gamma(%i y + x) + gamma(x - %i y)
          (%o3)           ---------------------------------
                                          2
          (%i4) realpart(bessel_j(1,%i));
          (%o4)                           0

 -- Funktion: rectform (<expr>)

     Zerlegt den Ausdruck <expr> in den Realteil 'a' und den
     Imaginärteil 'b' und gibt den komplexen Ausdruck in der
     Standardform 'a + b %i' zurück.

     Die Funktion 'rectform' nutzt Symmetrieeigenschaften und
     implementierte Eigenschaften komplexer Funktionen, um den Realteil
     und Imaginärteil eines komplexen Ausdrucks zu berechnen.  Sind
     solche Eigenschaften für eine Funktion vorhanden, können diese mit
     der Funktion 'properties' angezeigt werden.  Eigenschaften, die das
     Ergebnis der Funktion 'rectform' bestimmen, sind: 'mirror
     symmetry', 'conjugate function' und 'complex characteristic'.

     'rectform' ist eine Verbfunktion, die nicht für das symbolische
     Rechnen geeignet ist.

     'rectform' wird automatisch auf die Elemente von Listen und
     Matrizen sowie auf die beiden Seiten von Gleichungen angewendet.
     Siehe 'distribute_over'.

     Die Funktionen 'realpart' und 'imagpart' geben jeweils allein den
     Realteil und den Imaginärteil eines Ausdrucks zurück.  Um einen
     Ausdruck in die Polarform zu bringen, kann die Funktion 'polarform'
     verwendet werden.

     Siehe auch die Funktionen 'cabs', 'carg' und 'conjugate' für das
     Rechnen mit komplexen Zahlen.

     Beispiele:

     Zerlegung eines komplexen Ausdrucks und der Sinusfunktion 'sin' in
     den Realteil und Imaginärteil.  Maxima kennt komplexe Eigenschaften
     der trigonometrischen Funktionen, um den Realteil und den
     Imaginärteil zu bestimmen.

          (%i1) rectform((2-%i)/(1-%i));
                                       %i   3
          (%o1)                        -- + -
                                       2    2
          (%i2) rectform(sin(x+%i*y));
          (%o2)          %i cos(x) sinh(y) + sin(x) cosh(y)

     Bei der Zerlegung in einen Realteil und einen Imaginärteil nutzt
     Maxima die Spiegelsymmetrie der Gammfunktion 'gamma'.  Die
     Eigenschaft der Spiegelsymmetrie wird mit der Funktion 'properties'
     angezeigt, der Eintrag lautet 'mirror symmetry'.

          (%i3) properties(gamma);
          (%o3)    [mirror symmetry, noun, rule, gradef, transfun]

          (%i4) rectform(gamma(x+%i*y));
                gamma(%i y + x) + gamma(x - %i y)
          (%o4) ---------------------------------
                                2
                                          gamma(x - %i y) - gamma(%i y + x)
                                        - ---------------------------------
                                                          2

     Maxima kennt komplexe Eigenschaften der Besselfunktionen.  Die
     Besselfunktion 'bessel_j' ist für eine ganzzahlige Ordnung und
     einem imaginären Argument rein imaginär.

          (%i5) rectform(bessel_j(1,%i));
          (%o5)                  %i bessel_j(1, %i)


File: maxima.info,  Node: Funktionen der Kombinatorik,  Next: Wurzel- Exponential- und Logarithmusfunktion,  Prev: Funktionen für komplexe Zahlen,  Up: Mathematische Funktionen

10.3 Funktionen der Kombinatorik
================================

 -- Operator: !!

     Ist der Operator der doppelten Fakultät.

     Für eine positive ganze Zahl 'n', wird 'n!!' zu dem Produkt 'n
     (n-2) (n-4) (n-6) ... (n - 2 (k-1))' vereinfacht, wobei 'k' gleich
     'floor(n/2)' ist und 'floor' die größte ganze Zahl als Ergebnis
     hat, die kleiner oder gleich 'n/2' ist.

     Für ein Argument 'n', das keine ganze positive Zahl ist, gibt 'n!!'
     die Substantivform 'genfact(n, n/2,2)' zurück.  Siehe die Funktion
     'genfact'.

     Die Verallgemeinerung der doppelten Fakultät für reelle und
     komplexe Zahlen ist als die Funktion 'double_factorial'
     implementiert.

     Beispiele:

          (%i1) [0!!, 1!!, 2!!, 3!!, 4!!, 5!!, 6!!, 7!!, 8!!];
          (%o1)           [1, 1, 2, 3, 8, 15, 48, 105, 384]
          (%i2) 1.5!!;
          (%o2)                  genfact(1.5, 0, 2)
          (%i3) x!!;
                                             x
          (%o3)                   genfact(x, -, 2)
                                             2

 -- Funktion: binomial (<x>, <y>)

     Ist der Binominialkoeffizient, der definiert ist als
                                            x!
                       binomial(x, y) = -----------
                                        (x - y)! y!

     Die Funktion 'binomial' ist für das numerische und symbolische
     Rechnen geeignet.

     Sind die Argumente <x> oder <y> ganze Zahlen, wird der
     Binominialkoeffizient zu einer ganzen Zahl vereinfacht.  Sind die
     Argumente <x> und <y> reelle oder komplexe Gleitkommazahlen, wird
     der Binominialkoeffizient mit der entsprechenden verallgemeinerten
     Fakultät berechnet.  Siehe auch 'factorial' und 'gamma'.

     Ist das Argument <y> oder die Differenz <x-y> eine ganz Zahl, wird
     der Binominialkoeffizient zu einem Polynom vereinfacht.

     Mit den Funktionen 'makefact' oder 'makegamma' werden
     Binominialkoeffizienten in einem Ausdruck durch äquivalente
     Ausdrücke mit der Fakultät oder der Gammafunktion ersetzt.

     Maxima kennt die Ableitung des Binominialkoeffizienten nach den
     Argumenten <x> und <y>.

     Beispiele:

          (%i1) binomial(11, 7);
          (%o1)                          330
          (%i2) binomial(%i, 1.5);
          (%o2)       .3693753994635863 %i - .7573400496142132
          (%i3) binomial(x, 3);
                                  (x - 2) (x - 1) x
          (%o3)                   -----------------
                                          6
          (%i4) binomial(x+3, 3);
                               (x + 1) (x + 2) (x + 3)
          (%o4)                -----------------------
                                          6
          (%i5) makefact(binomial(x,y));
                                         x!
          (%o5)                      -----------
                                     (x - y)! y!

          (%i6) diff(binomial(x,y), y);
          (%o6)  - binomial(x, y) (psi (y + 1) - psi (- y + x + 1))
                                      0             0

 -- Funktion: double_factorial (z)

     Ist die doppelte Fakultät, die allgemein definiert ist als
                         2  1/4 (1 - cos(z %pi))  z/2       z
                       (---)                     2    gamma(- + 1)
                        %pi                                 2

     Die Funktion 'double_factorial' ist für das numerische und
     symbolische Rechnen geeignet.  Ist das Argument <z> eine ganze
     Zahl, eine Gleitkommazahl, eine große Gleitkommazahl oder eine
     komplexe Gleitkommazahl, dann wird ein numerisches Ergebnis
     berechnet.  Für eine positive ganze Zahl ist das Ergebnis gleich
     dem Ergebnis des Operators der doppelten Fakultät '!!'.  Für
     rationale Zahlen ist das Ergebnis eine Substantivform.

     Für negative gerade ganze Zahlen ist die Funktion
     'double_factorial' nicht definiert.

     Hat die Optionsvariable 'factorial_expand' den Wert 'true',
     vereinfacht Maxima 'double_factorial' für das Argument 'n-1' und
     für Argumente 'n+2*k', wobei 'k' eine ganze Zahl ist.

     Maxima kennt die Ableitung der Funktion 'double_factorial'.

     'double_factorial' wird automatisch auf die Elemente von Listen und
     Matrizen sowie auf die beiden Seiten von Gleichungen angewendet.
     Siehe 'distribute_over'.

     Beispiele:

     Numerische Ergebnisse für ganze Zahlen, Gleitkommazahlen und
     komplexen Gleitkommazahlen.

          (%i1) double_factorial([-3, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o1) [- 1, 1, 1, 1, 2, 3, 8, 15, 48, 105, 384, 945, 3840]

          (%i2) double_factorial([1.5, 1.5b0, 0.5+%i, 0.5b0+%i]);
          (%o2) [1.380662681753386, 1.380662681753387b0,
          .4186422526242637 - .7218816624466643 %i,
          4.186422526242633b-1 - 7.218816624466641b-1 %i]

     Vereinfachungen, wenn die Optionsvariable 'factorial_expand' den
     Wert 'true' hat.

          (%i3) factorial_expand:true;
          (%o3)                         true
          (%i4) double_factorial(n-1);
                                         n!
          (%o4)                  -------------------
                                 double_factorial(n)
          (%i5) double_factorial(n+4);
          (%o5)          (n + 2) (n + 4) double_factorial(n)
          (%i6) double_factorial(n-4);
                                 double_factorial(n)
          (%o6)                  -------------------
                                      (n - 2) n

     Die Ableitung der Funktion 'double_factorial'.

          (%i7) diff(double_factorial(x), x);
                                               2
                                      %pi log(---) sin(%pi x)
                                              %pi                    x
          (%o7) (double_factorial(x) (----------------------- + psi (- + 1)
                                                 2                 0 2
                                                               + log(2)))/2

 -- Funktion: factcomb (<expr>)

     Fasst Faktoren mit Fakultäten im Ausdruck <expr> zusammen.  Zum
     Beispiel wird '(n+1)*n!' zu '(n+1)!' zusammengefasst.

     Hat die Optionsvariable 'sumsplitfact' den Wert 'false', wird nach
     der Vereinfachung mit 'factcomb' die Funktion 'minfactorial' auf
     den Ausdruck <expr> angewendet.

     Beispiele:

          (%i1) expr: ((n+1)*n!)/(n+2)!;
                                     (n + 1) n!
          (%o1)                      ----------
                                      (n + 2)!
          (%i2) factcomb(expr);
                                      (n + 1)!
          (%o2)                       --------
                                      (n + 2)!
          (%i3) factcomb(expr), sumsplitfact:false;
                                          1
          (%o3)                         -----
                                        n + 2

 -- Funktion: factorial (<z>)
 -- Operator: !

     Die Funktion 'factorial' ist für das numerische und symbolische
     Rechnen der Fakultät geeignet.  Der Operator der Fakultät '!', ist
     identisch mit der Funktion 'factorial'.

     Für eine ganze Zahl 'n', vereinfacht 'n!' zum Produkt der ganzen
     Zahlen von 1 bis einschließlich 'n'.  '0!' vereinfacht zu 1.  Für
     reelle und komplexe Gleitkommazahlen wird 'z!' mit der
     Verallgemeinerung 'gamma(z+1)' berechnet.  Siehe die Funktion
     'gamma'.  Für eine halbzahlige rationale Zahl 'n/2', vereinfacht
     '(n/2)!' zu einem rationalen Faktor multipliziert mit 'sqrt(%pi)'.

     Die Optionsvariable 'factlim' enthält die größte Zahl, für die die
     Fakultät einer ganzen Zahl numerisch berechnet wird.  Ist das
     Argument der Fakultät eine rationale Zahl, wird von Maxima die
     Funktion 'gamma' für die numerische Berechnung aufgerufen.  In
     diesem Fall ist 'gammalim - 1' der größte Nenner, für den die
     Fakultät vereinfacht wird.  Siehe 'gammalim'.

     Hat die Optionsvariable 'factorial_expand' den Wert 'true', wird
     die Fakultät von Argumenten der Form '(n+k)!' oder '(n-k)!'
     vereinfacht, wobei 'k' eine ganze Zahl ist.

     Mit den Funktionen 'minfactorial' und 'factcomb' können Fakultäten
     in Ausdrücken vereinfacht werden.

     Die Funktion 'makegamma' ersetzt Fakultäten in einem Ausdruck durch
     die Gammafunktion 'gamma'.  Umgekehrt ersetzt die Funktion
     'makefact' Binomialkoeffizienten und die Gammafunktion in einem
     Ausdruck durch Fakultäten.

     Maxima kennt die Ableitung der Fakultät und die Grenzwerte der
     Fakultät für spezielle Werte wie negative ganze Zahlen.

     Siehe auch die Gammfunktion 'gamma' und den Binomialkoeffizienten
     'binomial'.

     Beispiele:

     Die Fakultät einer ganzen Zahl wird zu einer exakten Zahl
     vereinfacht, wenn das Argument nicht größer als 'factlim' ist.  Die
     Fakultät für reelle und komplexe Zahlen wird als Gleitkommazahl
     berechnet.

          (%i1) factlim:10;
          (%o1)                          10
          (%i2) [0!, (7/2)!, 8!, 20!];
                               105 sqrt(%pi)
          (%o2)            [1, -------------, 40320, 20!]
                                    16
          (%i3) [4.77!, (1.0+%i)!];
          (%o3) [81.44668037931197, .3430658398165451 %i
                                                       + .6529654964201663]
          (%i4) [2.86b0!, (1.0b0+%i)!];
          (%o4) [5.046635586910012b0, 3.430658398165454b-1 %i
                                                    + 6.529654964201667b-1]

     Die Fakultät von numerischen Konstanten oder eines konstanten
     Ausdrucks wird numerisch berechnet, wenn die Konstante oder der
     Ausdruck zu einer Zahl ausgewertet werden kann.

          (%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
          (%o1)      [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
          (%i2) ev (%, numer, %enumer);
          (%o2) [.3430658398165451 %i + .6529654964201663,
                   7.188082728976031, 4.260820476357003, 1.227580202486819]

     Fakultäten werden vereinfacht und nicht ausgewertet.  Daher wird
     die Fakultät auch dann berechnet, wenn die Auswertung mit dem
     Quote-Operator ''' unterdrückt ist.

          (%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
                      105 sqrt(%pi)
          (%o1)   [1, -------------, 81.44668037931197, 40320, 20!]
                           16

     Maxima kennt die Ableitung der Fakultät.

          (%i1) diff(x!, x);
          (%o1)                    x! psi (x + 1)
                                         0

     Die Optionsvariable 'factorial_expand' kontrolliert die Expansion
     und Vereinfachung von Ausdrücken, die die Fakultät enthalten.

          (%i1) (n+1)!/n!,factorial_expand:true;
          (%o1)                         n + 1

 -- Optionsvariable: factlim
     Standardwert: 100000

     Die Optionsvariable 'factlim' spezifiziert die größte ganze Zahl,
     für die die Fakultät einer ganzen Zahl numerisch berechnet wird.
     Hat 'factlim' den Wert -1, wird die Fakultät für jede ganze Zahl
     berechnet.  Siehe die Funktion 'factorial'.

 -- Optionsvariable: factorial_expand
     Standardwert: 'false'

     Die Optionsvariable 'factorial_expand' kontrolliert die
     Vereinfachung von Ausdrücken wie '(n+k)!' oder '(n-k)!', wobei 'k'
     eine ganze Zahl ist.  Siehe 'factorial' für ein Beispiel.

     Siehe auch die Funktionen 'minfactorial' und 'factcomb' für die
     Vereinfachung von Ausdrücken mit der Fakultät.

 -- Funktion: genfact (<x>, <y>, <z>)

     Gibt die verallgemeinerte Fakultät zurück, die als 'x (x-z) (x - 2
     z) ... (x - (y - 1) z)' definiert ist.  Ist <x> eine ganze Zahl,
     dann entspricht 'genfact(x, x, 1)' der Fakultät 'x!' und
     'genfact(x, x/2, 2)' der doppelten Fakultät 'x!!'.  Siehe auch die
     Funktionen 'factorial' und 'double_factorial' sowie die Operatoren
     '!' und '!!'.

 -- Funktion: minfactorial (<expr>)

     Die Funktion 'minfactorial' vereinfacht Fakultäten 'factorial' in
     dem Ausdruck <epxr>, die sich um eine ganze Zahl voneinander
     unterscheiden.  Siehe auch die Funktion 'factcomb', um Fakultäten
     zusammenzufassen, sowie die Optionsvariable 'factorial_expand'.

          (%i1) n!/(n+2)!;
                                         n!
          (%o1)                       --------
                                      (n + 2)!
          (%i2) minfactorial (%);
                                          1
          (%o2)                    ---------------
                                   (n + 1) (n + 2)

 -- Optionsvariable: sumsplitfact
     Standardwert: 'true'

     Hat die Optionsvariable 'sumsplitfact' den Wert 'false', wird von
     der Funktion 'factcomb' nach der Zusammenfassung von Fakultäten die
     Funktion 'minfactorial' angewendet.  Siehe die Funktion 'factcomb'
     für ein Beispiel.


File: maxima.info,  Node: Wurzel- Exponential- und Logarithmusfunktion,  Next: Winkelfunktionen,  Prev: Funktionen der Kombinatorik,  Up: Mathematische Funktionen

10.4 Wurzel-, Exponential- und Logarithmusfunktion
==================================================

 -- Optionsvariable: %e_to_numlog
     Standardwert: 'false'

     Hat die Optionsvariable '%e_to_numlog' den Wert 'true', wird ein
     Ausdruck mit der Exponentialfunktion 'exp' der Form '%e^(r*log(x))'
     zu 'x^r' vereinfacht, wenn 'r' eine rationale Zahl ist.  Ist 'r'
     eine ganze Zahl, wird die Vereinfachung von der Optionsvariablen
     'logsimp' kontrolliert.

     Beispiel:

          (%i1) exp(1/2*log(x));
                                        log(x)
                                        ------
                                          2
          (%o1)                       %e
          (%i2) exp(1/2*log(x)), %e_to_numlog:true;
          (%o2)                        sqrt(x)

 -- Optionsvariable: %emode
     Standardwert: 'true'

     Die Optionsvariable '%emode' kontrolliert die Vereinfachung von
     Ausdrücken mit der Exponentialfunktion 'exp' der Form '%e^(%pi %i
     x)'.

     Ist das Argument <x> eine ganze Zahl oder eine rationale Zahl, die
     ein Vielfaches von 1/2, 1/3, 1/4 oder 1/6 ist, dann wird der
     Ausdruck '%e^(%pi %i x)' zu einer reellen oder komplexen Zahl
     vereinfacht.  Für Gleitkommazahlen wird diese Vereinfachung dann
     ausgeführt, wenn diese eine ganze Zahl oder halbzahlige rationale
     Zahl repräsentieren.

     Eine Summe im Exponenten wie zum Beispiel '%e^(%pi *%i (x+n))',
     wobei <n> eine der oben genannten Zahlen und <x> ein allgemeiner
     Ausdruck ist, wird vereinfacht, indem der Faktor '%^(%pi %i n)'
     entsprechend vereinfacht wird.

     Hat '%emode' den Wert 'false', werden keine speziellen
     Vereinfachungen für den Ausdruck '%e^(%pi %i x)' vorgenommen.

     Beispiele:

          (%i1) exp([2*%pi*%i, 1/2*%pi*%i, 0.5*%pi*%i, 0.5b0*%pi*%i]);
          (%o1)               [1, %i, 1.0 %i, 1.0b0 %i]

          (%i2) exp([1/3*%pi*%i, 1/4*%pi*%i, 1/6*%pi*%i]);
                   sqrt(3) %i   1    %i         1     %i   sqrt(3)
          (%o2)   [---------- + -, ------- + -------, -- + -------]
                       2        2  sqrt(2)   sqrt(2)  2       2

          (%i3) exp((1/3+x)*%pi*%i);
                              sqrt(3) %i   1    %i %pi x
          (%o3)              (---------- + -) %e
                                  2        2

 -- Optionsvariable: %enumer
     Standardwert: 'false'

     Hat '%enumer' den Wert 'true', wird die Konstante '%e' immer dann
     durch ihren nummerischen Wert ersetzt, wenn die Optionsvariable
     'numer' den Wert 'true' hat.

     Hat '%enumer' den Wert 'false', wird die Konstante '%e' nur dann
     durch ihren nummerischen Wert ersetzt, wenn der Exponent von '%e^x'
     zu einer Gleitkommazahl ausgewertet wird.

     Siehe auch 'ev' und 'numer'.

     Beispiel:

          (%i1) %enumer:true;
          (%o1)                         true
          (%i2) exp(x);
                                           x
          (%o2)                          %e
          (%i3) exp(x),numer;
                                                  x
          (%o3)                  2.718281828459045

 -- Funktion: exp (<z>)

     Ist die Exponentialfunktion.  Die Exponentialfunktion 'exp' wird
     von Maxima sofort zu '%e^<z>' vereinfacht und tritt in
     vereinfachten Ausdrücken nicht auf.  Maxima vereinfacht die
     Exponentialfunktion daher wie die allgemeine Exponentiation '^'.
     Darüberhinaus kennt Maxima spezielle Regeln für die Vereinfachung
     der Exponentialfunktion.

     Ist das Argument <z> der Exponentialfunktion eine ganze oder
     rationale Zahl wird ein vereinfachter Ausdruck zurückgegeben.  Ist
     das Argument <z> eine reelle oder komplexe Gleitkommazahl wird ein
     numerisches Ergebnis berechnet.

     Folgende Optionsvariablen kontrollieren die Vereinfachung der
     Exponentialfunktion:

     '%enumer'
          Hat die Optionsvariable '%enumer' den Wert 'true', vereinfacht
          Maxima die Eulersche Zahl '%e' immer dann zu ihrem numerischen
          Wert, wenn die Optionsvariable 'numer' auch den Wert 'true'
          hat.

     '%emode'
          Hat die Optionsvariable '%emode' den Wert 'true', wendet
          Maxima Regeln an, um Ausdrücke der Form '%e^(x*%i*%pi)' zu
          vereinfachen.  Der Standardwert von '%emode' ist 'true'.  Wenn
          mit komplexen Zahlen in der Polarform gerechnet wird, kann es
          hilfreich sein, die Optionsvariable '%emode' auf den Wert
          'false' zu setzen.

     '%e_to_numlog'
          Hat die Optionsvariable '%e_to_numlog' den Wert 'true',
          vereinfacht Maxima einen Ausdruck '%e^(r*log(x)' zu 'x^r',
          wobei <r> eine rationale Zahl ist.  Ist <r> eine ganze Zahl
          wird diese Vereinfachung von der Optionsvariablen 'logsimp'
          kontrolliert.  Für reelle oder komplexe Gleitkommazahlen wird
          diese Vereinfachung nicht ausgeführt.

     'radexpand'
          Die Optionsvariable 'radexpand' kontrolliert die Vereinfachung
          von Ausdrücken der Form '(%e^a)^b'.  Ist <a> ein reelles
          Argument vereinfacht Maxima immer zu einem Ausdruck
          '%e^(a*b)'.  Ist <a> ein komplexes Argument, wird die
          Vereinfachung '%e^(a*b)' dann ausgeführt, wenn die
          Optionsvariable 'radexpand' den Wert 'all' hat.

     'logsimp'
          Die Optionsvariable 'logsimp' kontrolliert die Vereinfachung
          der Exponentialfunktion für den Fall, dass im Argument <expr>
          die Logarithmusfunktion 'log' auftritt.  Hat die 'logsimp' den
          Wert 'true', wird ein Ausdruck '%e^(n*log(x)' zu 'x^n'
          vereinfacht, wenn <n> eine ganze Zahl ist.  Mit der
          Optionsvariablen '%e_to_numlog' wird diese Vereinfachung für
          eine rationale Zahl <n> kontrolliert.

     'demoivre'
          Ist eine Optionsvariable und eine Funktion, die auch als
          Auswertungsschalter 'evflag' definiert ist.  Hat die
          Optionsvariable 'demoivre' den Wert 'true', wird ein Ausdruck
          '%e^(x + %i y)' zu '%e^x (cos(y) + %i sin(y))' vereinfacht.
          Siehe auch die Optionsvariable 'exponentialize'.

     Maxima kennt viele spezielle unbestimmte und bestimmte Integrale
     mit der Exponentialfunktion.

 -- Funktion: log (<z>)

     Ist der natürliche Logarithmus zur Basis e.  Die
     Logarithmusfunktion ist für das numerische und symbolische Rechnen
     geeignet.

     Maxima hat keine vordefinierte Logarithmusfunktion zur Basis 10
     oder anderen Basen.  Eine einfache Definition ist zum Beispiel
     'log10(x) := log(x)/log(10)'.  Mit dem Kommando 'load(log10)' kann
     ein Paket geladen werden, dass eine dekadische Logarithmusfunktion
     'log10' definiert.

     Ist das Argument <z> der Logarithmusfunktion eine ganze oder
     rationale Zahl wird ein vereinfachter Ausdruck zurückgegeben.  Ist
     das Argument <z> eine reelle oder komplexe Gleitkommazahl wird ein
     numerisches Ergebnis berechnet.

     Die folgenden Optionsvariablen kontrollieren die Vereinfachung und
     Auswertung der Logarithmusfunktion:

     'logexpand'
          Hat die Optionsvariable 'logexpand' den Wert 'true', dann wird
          'log(a^b)' zu 'b*log(a)' vereinfacht.  Hat 'logexpand' den
          Wert 'all', wird zusätzlich 'log(a*b)' zu 'log(a)+log(b)'
          vereinfacht.  Mit den Wert 'super' vereinfacht Maxima
          weiterhin 'log(a/b)' zu 'log(a)-log(b)', wobei 'a/b' eine
          rationale Zahl ist.  'log(1/b' wird für eine ganze Zahl 'b'
          immer vereinfacht.  Hat die Optionsvariable 'logexpand' den
          Wert 'false' werden alle obigen Vereinfachungen ausgeschaltet.

     'logsimp'
          Hat die Optionsvariable 'logsimp' den Wert 'false', werden
          Exponentialfunktionen 'exp', die Logarithmusfunktionen im
          Exponenten enthalten, nicht vereinfacht.

     'lognegint'
          Hat die Optionsvariable 'lognegint' den Wert 'true', wird
          'log(-n)' zu 'log(n)+%i*%pi' für positive 'n' vereinfacht.

     '%e_to_numlog'
          Hat die Optionsvariable '%e_to_numlog' den Wert 'true', wird
          ein Ausdruck '%e^(r*log(x))' zu 'x^r' vereinfacht.  Dabei sind
          'r' eine rationale Zahl und 'x' ein beliebiger Ausdruck.  Die
          Funktion 'radcan' führt diese Vereinfachung ebenfalls aus.

     Die Logarithmusfunktion wird automatisch auf die Elemente von
     Listen und Matrizen sowie auf die beiden Seiten von Gleichungen
     angewendet.  Siehe 'distribute_over'.

     Beispiele:

     Verschiedene Beispiele mit der Logarithmusfunktion.

          (%i1) log(%e);
          (%o1)                           1
          (%i2) log(100.0);
          (%o2)                   4.605170185988092
          (%i3) log(2.5+%i);
          (%o3)       .3805063771123649 %i + .9905007344332917
          (%i4) taylor(log(1+x),x,0,5);
                                 2    3    4    5
                                x    x    x    x
          (%o4)/T/          x - -- + -- - -- + -- + . . .
                                2    3    4    5
          (%i5) rectform(log(x+%i*y));
                                 2    2
                            log(y  + x )
          (%o5)             ------------ + %i atan2(y, x)
                                 2
          (%i6) limit(log(x),x,0,plus);
          (%o6)                         minf
          (%i7) integrate(log(z)^n,z);
                                                              - n - 1
          (%o7) - gamma_incomplete(n + 1, - log(z)) (- log(z))
                                                                      n + 1
                                                                log(z)
          (%i8) laplace(log(t),t,s);
                                  - log(s) - %gamma
          (%o8)                   -----------------
                                          s
          (%i9) depends(y,x);
          (%o9)                        [y(x)]
          (%i10) ode2(diff(y,x)+log(y)+1,y,x);
                      - 1
          (%o10)    %e    expintegral_e(1, - log(y) - 1) = x + %c

 -- Optionsvariable: logabs
     Standardwert: 'false'

     Treten bei der unbestimmten Integration Logarithmusfunktionen im
     Ergebnis auf, so wird der Betrag der Argumente der
     Logarithmusfunktionen gebildet, wenn die Optionsvariable 'logabs'
     den Wert 'true' hat.

     Beispiele:

          (%i1) logabs:true;
          (%o1)                         true
          (%i2) integrate(1/x,x);
          (%o2)                      log(abs(x))
          (%i3) integrate(1/(1+x^3),x);
                                                             2 x - 1
                      ! 2        !                      atan(-------)
                  log(!x  - x + 1!)   log(abs(x + 1))        sqrt(3)
          (%o3) - ----------------- + --------------- + -------------
                          6                  3             sqrt(3)

 -- Funktion: logarc (<expr>)
 -- Optionsvariable: logarc

     Hat die Optionsvariable 'logarc' den Wert 'true', werden inverse
     Winkel- und Hyperbelfunktionen durch Logarithmusfunktionen ersetzt.
     Der Standardwert von 'logarc' ist 'false'.

     Die Funktion 'logarc(<expr>)' führt diese Ersetzung aus, ohne dass
     die Optionsvariable 'logarc' gesetzt wird.

     Beispiele:

          (%i1) logarc(asin(x));
                                               2
          (%o1)             - %i log(sqrt(1 - x ) + %i x)
          (%i2) logarc:true;
          (%o2)                         true
          (%i3) asin(x);
                                               2
          (%o3)             - %i log(sqrt(1 - x ) + %i x)

 -- Optionsvariable: logconcoeffp
     Standardwert: 'false'

     Der Optionsvariablen 'logconcoeffp' kann eine Aussagefunktion mit
     einem Argument zugewiesen werden, die kontrolliert, welche
     Koeffizienten von der Funktion 'logcontract' zusammengezogen
     werden.  Sollen zum Beispiel Wurzeln generiert werden, kann
     folgende Aussagefunktion definiert werden:

          logconcoeffp:'logconfun$
          logconfun(m) := featurep(m,integer) or ratnump(m)$

     Das Kommando 'logcontract(1/2*log(x))' liefert nun das Ergebnis
     'log(sqrt(x))'.

 -- Funktion: logcontract (<expr>)

     Der Ausdruck <expr> wird rekursiv nach Ausdrücken der Form
     'a1*log(b1) + a2*log(b2) + c' durchsucht.  Diese werden zu
     'log(ratsimp(b1^a1 * b2^a2)) + c' transformiert.

          (%i1) 2*(a*log(x) + 2*a*log(y))$
          (%i2) logcontract(%);
                                           2  4
          (%o2)                     a log(x  y )

     Wird die Variable <n> mit dem Kommando 'declare(n, integer)' als
     eine ganze Zahl deklariert, dann wird 'logcontract(2*a*n*log(x))'
     zu 'a*log(x^(2*n))' vereinfacht.  Die Koeffizienten, die
     zusammengezogen werden, sind in diesem Fall die Zahl 2 und die
     Variable <n>, welche die folgende Aussage erfüllen 'featurep(coeff,
     integer)'.  Der Nutzer kann kontrollieren, welche Koeffizienten
     zusammengezogen werden.  Dazu wird der Optionsvariablen
     'logconcoeffp' eine Aussagefunktion mit einem Argument zugewiesen.
     Sollen zum Beispiel Wurzeln generiert werden, kann folgende
     Definition verwendet: 'logconcoeffp: 'logconfun$ logconfun(m) :=
     featurep(m,integer) or ratnump(m)$'.  Dann hat das Kommando
     'logcontract(1/2*log(x))' das Ergebnis 'log(sqrt(x))'.

 -- Optionsvariable: logexpand
     Standardwert: 'true'

     Die Optionsvariable 'logexpand' kontrolliert die Vereinfachung der
     Logarithmusfunktion 'log'.

     Hat 'logexpand' den Wert 'true', wird 'log(a^b)' zu 'b*log(a)'
     vereinfacht.  Hat 'logexpand' den Wert 'all', wird zusätzlich
     'log(a*b)' zu 'log(a)+log(b)' vereinfacht.  Mit dem Wert 'super'
     vereinfacht Maxima weiterhin 'log(a/b)' zu 'log(a)-log(b)', wobei
     'a/b' eine rationale Zahl ist.  'log(1/b' wird für eine ganze Zahl
     'b' immer vereinfacht.  Hat die Optionsvariable 'logexpand' den
     Wert 'false' werden alle obigen Vereinfachungen ausgeschaltet.

 -- Optionsvariable: lognegint
     Standardwert: 'false'

     Hat die Optionsvariable 'lognegint' den Wert 'true', wird 'log(-n)'
     zu 'log(n)+%i*%pi' für positive 'n' vereinfacht.

 -- Optionsvariable: logsimp
     Standardwert: 'true'

     Hat die Optionsvariable 'logsimp' den Wert 'false', werden
     Exponentialfunktionen 'exp', die Logarithmusfunktionen im
     Exponenten enthalten, nicht vereinfacht.

 -- Funktion: plog (<x>)

     Gibt den Hauptwert des komplexen natürlichen Logarithmus im
     Intervall '-%pi' < 'carg(<x>)' <= '+%pi' zurück.

 -- Optionsvariable: rootsconmode
     Standardwert: 'true'

     'rootsconmode' kontrolliert das Verhalten der Funktion
     'rootscontract'.  Siehe die Funktion 'rootscontract' für Details.

 -- Funktion: rootscontract (<expr>)

     Konvertiert Produkte von Wurzeln in Wurzeln von Produkten.  Zum
     Beispiel hat 'rootscontract(sqrt(x)*y^(3/2))' das Ergebnis
     'sqrt(x*y^3)'.

     Hat die Optionsvariable 'radexpand' den Wert 'true' und die
     Optionsvariable 'domain' den Wert 'real', das sind die
     Standardwerte, wird 'abs(x)' zu 'sqrt(x^2)' vereinfacht.  Zum
     Beispiel hat 'rootscontract(abs(x) * sqrt(y))' das Ergebnis
     'sqrt(x^2*y)'.

     Die Optionsvariable 'rootsconmode' kontrolliert das Ergebnis
     folgendermaßen:

          Problem             Wert             Ergebnis
                              rootsconmode     rootscontract

          x^(1/2)*y^(3/2)     false            sqrt(x*y^3)
          x^(1/2)*y^(1/4)     false            sqrt(x)*y^(1/4)
          x^(1/2)*y^(1/4)     true             sqrt(x*sqrt(y))
          x^(1/2)*y^(1/3)     true             sqrt(x)*y^(1/3)
          x^(1/2)*y^(1/4)     all              (x^2*y)^(1/4)
          x^(1/2)*y^(1/3)     all              (x^3*y^2)^(1/6)

     Hat 'rootsconmode' den Wert 'false', kontrahiert 'rootscontract'
     nur Faktoren mit rationalen Exponenten, die den gleichen Nenner
     haben.  Hat 'rootsconmode' den Wert 'all', wird das kleinste
     gemeinsame Vielfache des Nenners der Faktoren verwendet, um die
     Faktoren zusammenzufassen.

     Ähnlich wie bei der Funktion 'logcontract' werden von
     'rootscontract' die Argumente unter der Wurzel mit der Funktion
     'ratsimp' vereinfacht.

     Beispiele:

          (%i1) rootsconmode: false$
          (%i2) rootscontract (x^(1/2)*y^(3/2));
                                             3
          (%o2)                      sqrt(x y )
          (%i3) rootscontract (x^(1/2)*y^(1/4));
                                             1/4
          (%o3)                     sqrt(x) y
          (%i4) rootsconmode: true$
          (%i5) rootscontract (x^(1/2)*y^(1/4));
          (%o5)                    sqrt(x sqrt(y))
          (%i6) rootscontract (x^(1/2)*y^(1/3));
                                             1/3
          (%o6)                     sqrt(x) y
          (%i7) rootsconmode: all$
          (%i8) rootscontract (x^(1/2)*y^(1/4));
                                        2   1/4
          (%o8)                       (x  y)
          (%i9) rootscontract (x^(1/2)*y^(1/3));
                                       3  2 1/6
          (%o9)                      (x  y )
          (%i10) rootsconmode: false$
          (%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                              *sqrt(sqrt(1 + x) - sqrt(x)));
          (%o11)                          1
          (%i12) rootsconmode: true$
          (%i13) rootscontract (sqrt(5+sqrt(5)) - 5^(1/4)*sqrt(1+sqrt(5)));
          (%o13)                          0

 -- Funktion: sqrt (<z>)

     Ist die Wurzelfunktion.  Die Wurzelfunktion wird von Maxima sofort
     zu '<x>^(1/2)' vereinfacht und tritt in Ausdrücken nicht auf.

     Die Wurzelfunktion ist für das numerische und symbolische Rechnen
     geeignet.  Ist das Argument <z> der Wurzelfunktion eine
     Gleitkommazahl, wird ein numerisches Ergebnis zurückgegeben.  Für
     ganze und rationale Zahlen wird die Wurzelfunktion vereinfacht.
     Die numerische Berechnung kann mit den Optionsvariablen und
     Auswertungsschaltern 'numer' und 'float' kontrolliert werden.

     Hat die Optionsvariable 'radexpand' den Wert 'true', werden die
     n-ten Wurzeln von Faktoren unter einer Wurzel aus der Wurzel
     herausgezogen.  So wird zum Beispiel 'sqrt(16*x^2)' nur dann zu
     '4*x' vereinfacht, wenn 'radexpand' den Wert 'true' hat.

     Siehe auch die Funktionen 'rootscontract' und 'sqrtdenest' für die
     Vereinfachung von Ausdrücken, die die Wurzelfunktion enthalten.

     Beispiele:

     Verschiedene Beispiele mit der Wurzelfunktion.

          (%i1) sqrt(4);
          (%o1)                           2
          (%i2) sqrt(24);
          (%o2)                       2 sqrt(6)
          (%i3) sqrt(2.0);
          (%o3)                   1.414213562373095
          (%i4) taylor(sqrt(1+x),x,0,5);
                                 2    3      4      5
                            x   x    x    5 x    7 x
          (%o4)/T/      1 + - - -- + -- - ---- + ---- + . . .
                            2   8    16   128    256
          (%i5) rectform(sqrt(x+%i*y));
                     2    2 1/4     atan2(y, x)
          (%o5) %i (y  + x )    sin(-----------)
                                         2
                                                2    2 1/4     atan2(y, x)
                                            + (y  + x )    cos(-----------)
                                                                    2
          (%i6) integrate(sqrt(t)*(t+1)^-2,t,0,1);
                                       %pi - 2
          (%o6)                        -------
                                          4


File: maxima.info,  Node: Winkelfunktionen,  Next: Hyperbelfunktionen,  Prev: Wurzel- Exponential- und Logarithmusfunktion,  Up: Mathematische Funktionen

10.5 Winkelfunktionen
=====================

* Menu:

* Einführung in Winkelfunktionen::
* Funktionen und Variablen für Winkelfunktionen::


File: maxima.info,  Node: Einführung in Winkelfunktionen,  Next: Funktionen und Variablen für Winkelfunktionen,  Prev: Winkelfunktionen,  Up: Winkelfunktionen

10.5.1 Einführung in Winkelfunktionen
-------------------------------------

Maxima kennt viele Winkel- und Hyperbelfunktionen.  Nicht alle
Identitäten für Winkel- und Hyperbelfunktionen sind programmiert, aber
es ist möglich weitere Identitäten mit der Fähigkeit der Erkennung von
Mustern hinzuzufügen.

Maxima kennt die folgenden Winkel- und Hyperbelfunktionen sowie deren
Inverse:

     sin       cos       tan
     sec       csc       cot
     asin      acos      atan
     asec      acsc      acot
     sinh      cosh      tanh
     sech      csch      coth
     asinh     acosh     atanh
     asech     acsch     acoth


File: maxima.info,  Node: Funktionen und Variablen für Winkelfunktionen,  Prev: Einführung in Winkelfunktionen,  Up: Winkelfunktionen

10.5.2 Funktionen und Variablen für Winkelfunktionen
----------------------------------------------------

 -- Funktion: asin (<z>)
 -- Funktion: acos (<z>)
 -- Funktion: atan (<z>)
 -- Funktion: acot (<z>)
 -- Funktion: acsc (<z>)
 -- Funktion: asec (<z>)

     Die inversen Winkelfunktionen: Arkussinus, Arkuskosinus,
     Arkustangens, Arkuskotangens, Arkuskosekans und Arkussekans.

     Die inversen Winkelfunktionen sind für das numerische und
     symbolische Rechnen geeignet.  Die inversen Winkelfunktionen können
     für reelle und komplexe Gleitkommazahlen in doppelter und in
     beliebiger Genauigkeit berechnet werden.  Ist das Argument eine
     ganze oder rationale Zahl, werden die inversen Winkelfunktionen
     nicht numerisch berechnet, sondern vereinfacht.  Die numerische
     Berechnung kann mit den Optionsvariablen und Auswertungsschaltern
     'numer' und 'float' erzwungen werden.

     Die inversen Winkelfunktionen sind bis auf die Funktionen 'acos'
     und 'asec' als ungerade definiert.  Die Funktionen 'acos' und
     'asec' vereinfachen für ein negatives Argument '-x' zu
     '%pi-acos(x)' und '%pi-asec(x)'.  Für die inversen Winkelfunktion
     'asin', 'acos' und 'atan' ist die Spiegelsymmetrie für den Fall
     implementiert, dass das komplexe Argument 'x+%i*y' einen Realteil
     'abs(x)<1' hat.

     Ist das Argument <z> eine Matrix, eine Liste oder eine Gleichung
     werden die inversen Winkelfunktionen auf die Elemente der Matrix,
     der Liste oder auf die beiden Seiten der Gleichung angewendet.
     Dieses Verhalten wird von der Optionsvariablen 'distribute_over'
     kontrolliert.

     Inverse Winkelfunktionen können für das symbolische Rechnen
     verwendet werden.  Maxima kann Ausdrücke mit inversen
     Winkelfunktionen differenzieren und integrieren, Grenzwerte
     bestimmen sowie Gleichungen mit inversen Winkelfunktionen lösen.

     Das Argument der inversen Winkelfunktionen kann eine Taylorreihe
     sein.  In diesem Fall wird die Taylorreihenentwicklung für die
     inverse Winkelfunktion vollständig ausgeführt.

     Die folgenden Optionsvariablen kontrollieren die Vereinfachung der
     inversen Winkelfunktionen:

     'distribute_over'
          Hat die Optionsvariable 'distribute_over' den Wert 'true' und
          ist das Argument der inversen Winkelfunktion eine Matrix,
          Liste oder Gleichung wird die Funktion auf die Elemente oder
          beiden Seiten der Gleichung angewendet.  Der Standardwert ist
          'true'.

     '%piargs'
          Hat die Optionsvariable '%piargs' den Wert 'true', werden die
          inversen Winkelfunktionen für spezielle Werte als Argument
          vereinfacht.  Der Standardwert ist 'true'.

     '%iargs'
          Hat die Optionsvariable '%iargs' den Wert 'true' und ist das
          Argument der inversen Winkelfunktion ein Vielfaches der
          imaginären Einheit '%i' werden die inversen Winkelfunktionen
          zu inversen Hyperbelfunktionen vereinfacht.  Der Standardwert
          ist 'true'.

     'triginverses'
          Hat die Optionsvariable 'triginverses' den Wert 'all' und ist
          das Argument die entsprechende Winkelfunktion vereinfachen die
          inversen Winkelfunktionen, zum Beispiel vereinfacht
          'asin(sin(x))' zu 'x'.  Der Standardwert ist 'true' und die
          Vereinfachung wird nicht vorgenommen.

     'logarc'
          Hat die Optionsvariable 'logarc' den Wert 'true', werden
          inverse Winkelfunktionen durch Logarithmusfunktionen ersetzt.
          Der Standardwert von 'logarc' ist 'false'.

 -- Funktion: atan2 (<y>, <x>)

     Ist der Arkustangens mit zwei Argumenten, der in Maxima wie folgt
     definiert ist:

          atan(y/x)           x>0
          atan(y/x) + %pi     x<0 und y>=0
          atan(y/x) - %pi     x<0 und y<0
            %pi / 2           x=0 und y>0
          - %pi / 2           x=0 und y<0
          nicht definiert     x=0 und y=0

     Mit der obigen Definition ist der Wertebereich des Arkustangens
     '-%pi < atan2(y,x) <= %pi'.  Alternativ kann der Arkustangens mit
     zwei Argumenten definiert werden als

                                   %i y + x
          atan2(y, x) = - %i log(-------------)
                                       2    2
                                 sqrt(y  + x )

     Der Arkustangens ist für das symbolische und numerische Rechnen
     geeignet.  Für reelle Argumente <x> und <y> deren Vorzeichen
     bestimmt werden kann, vereinfacht Maxima den Arkustangens wie oben
     in der Definition angegeben.  Sind beide Argumente Gleitkommazahlen
     wird ein numerisches Ergebnis berechnet.  Die numerische Berechnung
     für komplexe Gleitkommazahlen ist nicht implementiert.  Weiterhin
     kennt Maxima die speziellen Werte, wenn eines der Argumente <x>
     oder <y> unendlich ist.  'atan2(x, x)' und 'atan2(x, -x)' werden
     von Maxima vereinfacht, wenn Maxima das Vorzeichen von <x>
     ermitteln kann.

     Die Vereinfachung des Arkustangens wird weiterhin von den folgenden
     Optionsvariablen kontrolliert:

     'distribute_over'
          Hat die Optionsvariable 'distribute_over' den Wert 'true' und
          ist das Argument des Arkustangens eine Matrix, Liste oder
          Gleichung wird die Funktion auf die Elemente oder beiden
          Seiten der Gleichung angewendet.  Der Standardwert ist 'true'.

     'trigsign'
          Hat die Optionsvariable 'trigsign' den Wert 'true',
          vereinfacht Maxima 'atan2(-y, x)' zu '- atan2(y, x)'.  Der
          Standardwert ist 'true'.

     'logarc'
          Hat die Optionsvariable 'logarc' den Wert 'true', wird der
          Arkustangens durch einen Ausdruck mit der
          Logarithmusfunktionen ersetzt.  Der Standardwert von 'logarc'
          ist 'false'.

     Maxima kann Ausdrücke mit dem Arkustangens ableiten und integrieren
     sowie die Grenzwerte von Ausdrücken mit dem Arkustangens ermitteln.

     Beispiele:

          (%i1) atan2([-1, 1],[-1, 0, 1]);
                        3 %pi    %pi    %pi    3 %pi  %pi  %pi
          (%o1)     [[- -----, - ---, - ---], [-----, ---, ---]]
                          4       2      4       4     2    4
          (%i2) atan2(1,[-0.5, 0.5]);
          (%o2)         [2.034443935795703, 1.10714871779409]
          (%i3) assume(a>0)$

          (%i4) atan2(2*a, -2*a);
                                        3 %pi
          (%o4)                         -----
                                          4
          (%i5) diff(atan2(y,x), x);
                                           y
          (%o5)                       - -------
                                         2    2
                                        y  + x
          (%i6) integrate(atan2(y,x), x);
                                    2    2
                             y log(y  + x )          y
          (%o6)              -------------- + x atan(-)
                                   2                 x

 -- Funktion: sin (<z>)
 -- Funktion: cos (<z>)
 -- Funktion: tan (<z>)
 -- Funktion: cot (<z>)
 -- Funktion: csc (<z>)
 -- Funktion: sec (<z>)

     Die Winkelfunktionen: Sinus, Kosinus, Tangens, Kotangens, Kosekans
     und Sekans.

     Die Winkelfunktionen sind für das numerische und symbolische
     Rechnen geeignet.  Die Winkelfunktionen können für reelle und
     komplexe Gleitkommazahlen in doppelter und in beliebiger
     Genauigkeit berechnet werden.  Ist das Argument eine ganze oder
     rationale Zahl, werden die Winkelfunktionen nicht numerisch
     berechnet, sondern vereinfacht.  Die numerische Berechnung kann mit
     den Optionsvariablen und Auswertungsschaltern 'numer' und 'float'
     erzwungen werden.

     Die Winkelfunktionen sind gerade oder ungerade und haben
     Spiegelsymmetrie.  Maxima wendet diese Symmetrieeigenschaften
     automatisch bei der Vereinfachung von Ausdrücken mit
     Winkelfunktionen an.

     Ist das Argument <z> eine Matrix, eine Liste oder eine Gleichung
     werden die Winkelfunktionen auf die Elemente der Matrix, der Liste
     oder auf die beiden Seiten der Gleichung angewendet.  Dieses
     Verhalten wird von der Optionsvariablen 'distribute_over'
     kontrolliert.

     Winkelfunktionen können für das symbolische Rechnen verwendet
     werden.  Maxima kann Ausdrücke mit Winkelfunktionen differenzieren
     und integrieren, Grenzwerte bestimmen sowie Gleichungen und
     Differentialgleichungen mit Winkelfunktionen lösen.

     Das Argument der Winkelfunktionen kann eine Taylorreihe sein.  In
     diesem Fall wird die Taylorreihenentwicklung für die Winkelfunktion
     vollständig ausgeführt.

     Die folgenden Optionsvariablen kontrollieren die Vereinfachung der
     Winkelfunktionen:

     'distribute_over'
          Hat die Optionsvariable 'distribute_over' den Wert 'true' und
          ist das Argument der Winkelfunktion eine Matrix, Liste oder
          Gleichung wird die Funktion auf die Elemente oder beiden
          Seiten der Gleichung angewendet.  Der Standardwert ist 'true'.

     '%piargs'
          Hat die Optionsvariable '%piargs' den Wert 'true', werden die
          Winkelfunktionen für ganzzahlige und halbzahlige Vielfache der
          Konstanten '%pi' zu speziellen Werten vereinfacht.  Der
          Standardwert ist 'true'.

     '%iargs'
          Hat die Optionsvariable '%iargs' den Wert 'true' und ist das
          Argument der Winkelfunktion ein Vielfaches der imaginären
          Einheit '%i' werden die Winkelfunktionen zu Hyperbelfunktionen
          vereinfacht.  Der Standardwert ist 'true'.

     'trigsign'
          Hat die Optionsvariable 'trigsign' den Wert 'true', werden die
          gerade oder ungerade Symmetrie der Winkelfunktionen bei der
          Vereinfachung angewendet.  Der Standardwert ist 'true'.

     'triginverses'
          Hat die Optionsvariable 'triginverses' den Wert 'true' und ist
          das Argument eine inverse Winkelfunktion vereinfachen die
          Winkelfunktionen zu einem einfachen algebraischen Ausdruck,
          zum Beispiel vereinfacht 'sin(acos(x))' zu 'sqrt(1-x^2)'.  Der
          Standardwert ist 'true'.

     'trigexpand'
          Hat die Optionsvariable 'trigexpand' den Wert 'true', dann
          werden die Winkelfunktionen für ein Argument expandiert, das
          eine Summe oder ein Produkt mit einer ganzen Zahl ist.  Der
          Standardwert ist 'false'.

     'exponentialize'
          Hat die Optionsvariable 'exponentialize' den Wert 'true', dann
          werden die Winkelfunktionen in eine Exponentialform
          transformiert.  Der Standardwert ist 'false'.

     'halfangles'
          Hat die Optionsvariable 'halfangles' den Wert 'true', dann
          werden die Winkelfunktionen für halbzahlige Argumente zu einem
          äquivalenten Ausdruck transformiert.  Der Standardwert ist
          'false'.

     Beispiele:

     Im Folgenden werden Beispiele für die Sinusfunktion gezeigt.
     Numerische Berechnungen für Gleitkommazahlen:

          (%i1) sin(1+%i);
          (%o1)                      sin(%i + 1)
          (%i2) sin(1.0+%i);
          (%o2)       .6349639147847361 %i + 1.298457581415977
          (%i3) sin(1.0b0+%i);
          (%o3)     6.349639147847361b-1 %i + 1.298457581415977b0
          (%i4) sin(1.0b0),fpprec:45;
          (%o4)   8.41470984807896506652502321630298999622563061b-1

     Einige Vereinfachungen der Sinusfunktionen:

          (%i5) sin(%i*(x+y));
          (%o5)                    %i sinh(y + x)
          (%i6) sin(%pi/3);
                                       sqrt(3)
          (%o6)                        -------
                                          2
          (%i2) sin(x+y),trigexpand:true;
          (%o2)             cos(x) sin(y) + sin(x) cos(y)
          (%i3) sin(2*x+y),trigexpand:true;
                     2         2
          (%o3)  (cos (x) - sin (x)) sin(y) + 2 cos(x) sin(x) cos(y)

     Grenzwerte, Ableitungen und Integrale mit der Sinusfunktion:

          (%i4) limit(sin(x)/x,x,0);
          (%o4)                          1
          (%i5) diff(sin(sqrt(x))/x,x);
                            cos(sqrt(x))   sin(sqrt(x))
          (%o5)             ------------ - ------------
                                  3/2            2
                               2 x              x
          (%i6) integrate(sin(x^3),x);
          (%o6)
                                   1      3                     1        3
                  gamma_incomplete(-, %i x ) + gamma_incomplete(-, - %i x )
                                   3                            3
                - ---------------------------------------------------------
                                             12

     Reihenentwicklung der Sinusfunktion:

          (%i7) taylor(sin(x),x,0,3);
                                        3
                                       x
          (%o7)/T/                 x - -- + . . .
                                       6

 -- Optionsvariable: %piargs
     Standardwert: 'true'

     Hat '%piargs' den Wert 'true', werden Winkel- und
     Hyperbelfunktionen sowie deren Inverse zu algebraischen Konstanten
     vereinfacht, wenn das Argument ein ganzzahliges Vielfaches der
     folgenden Konstanten ist: '%pi', '%pi/2', '%pi/3', '%pi/4' oder
     '%pi/6'.

     Maxima kennt weiterhin einige Identitäten, wenn die Konstante '%pi'
     mit einer Variablen multipliziert wird, die als ganzzahlig
     deklariert wurde.

     Beispiele:

          (%i1) %piargs : false$
          (%i2) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                          %pi       %pi
          (%o2)            [sin(%pi), sin(---), sin(---)]
                                           2         3
          (%i3) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                                %pi       %pi       %pi
          (%o3)            [sin(---), sin(---), sin(---)]
                                 4         5         6
          (%i4) %piargs : true$
          (%i5) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                          sqrt(3)
          (%o5)                    [0, 1, -------]
                                             2
          (%i6) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                                   1         %pi   1
          (%o6)                [-------, sin(---), -]
                                sqrt(2)       5    2
          (%i7) [cos (%pi/3), cos (10*%pi/3), tan (10*%pi/3),
                 cos (sqrt(2)*%pi/3)];
                          1    1               sqrt(2) %pi
          (%o7)          [-, - -, sqrt(3), cos(-----------)]
                          2    2                    3

     Weitere Identitäten werden angewendet, wenn '%pi' und '%pi/2' mit
     einer ganzzahligen Variable multipliziert werden.

          (%i1) declare (n, integer, m, even)$
          (%i2) [sin (%pi * n), cos (%pi * m), sin (%pi/2 * m),
                 cos (%pi/2 * m)];
                                                m/2
          (%o2)                  [0, 1, 0, (- 1)   ]

 -- Optionsvariable: %iargs
     Standardwert: 'true'

     Hat '%iargs' den Wert 'true', werden Winkelfunktionen zu
     Hyperbelfunktionen vereinfacht, wenn das Argument ein Vielfaches
     der imaginären Einheit '%i' ist.

     Die Vereinfachung zu Hyperbelfunktionen wird auch dann ausgeführt,
     wenn das Argument offensichtlich reell ist.

     Beispiele:

          (%i1) %iargs : false$
          (%i2) [sin (%i * x), cos (%i * x), tan (%i * x)];
          (%o2)           [sin(%i x), cos(%i x), tan(%i x)]
          (%i3) %iargs : true$
          (%i4) [sin (%i * x), cos (%i * x), tan (%i * x)];
          (%o4)           [%i sinh(x), cosh(x), %i tanh(x)]

     Auch wenn das Argument offensichtlich reell ist, wird zu einer
     Hyperbelfunktion vereinfacht.

          (%i1) declare (x, imaginary)$
          (%i2) [featurep (x, imaginary), featurep (x, real)];
          (%o2)                     [true, false]
          (%i3) sin (%i * x);
          (%o3)                      %i sinh(x)

 -- Optionsvariable: halfangles
     Standardwert: 'false'

     Hat 'halfangles' den Wert 'true', werden Winkel- und
     Hyperbelfunktionen mit halbzahligen Argumenten '<expr>/2'
     vereinfacht.

     Für ein reelles Argument <x> im Intervall '0 < x < 2*%pi'
     vereinfacht der Sinus für ein halbzahliges Argument zu einer
     einfachen Formel:

                                   sqrt(1 - cos(x))
                                   ----------------
                                       sqrt(2)

     Ein komplizierter Faktor wird gebraucht, damit die Formel korrekt
     ist für ein komplexes Argument <z>:

                realpart(z)
          floor(-----------)
                   2 %pi
     (- 1)                   (1 - unit_step(- imagpart(z))

                                 realpart(z)            realpart(z)
                           floor(-----------) - ceiling(-----------)
                                    2 %pi                  2 %pi
                     ((- 1)                                          + 1))

     Maxima kennt diesen Faktor und ähnliche Faktoren für die Sinus,
     Kosinus, Sinus Hyperbolicus und Kosinus Hyperbolicus Funktionen.
     Für spezielle Argumente z dieser Funktionen vereinfachen diese
     Funktionen entsprechend.

     Beispiele:

          (%i1) halfangles:false;
          (%o1)                                false
          (%i2) sin(x/2);
                                                  x
          (%o2)                               sin(-)
                                                  2
          (%i3) halfangles:true;
          (%o3)                                true
          (%i4) sin(x/2);
                                                              x
                                                      floor(-----)
                                                            2 %pi
                                sqrt(1 - cos(x)) (- 1)
          (%o4)                 ----------------------------------
                                             sqrt(2)
          (%i5) assume(x>0, x<2*%pi)$
          (%i6) sin(x/2);
                                         sqrt(1 - cos(x))
          (%o6)                          ----------------
                                             sqrt(2)

 -- Paket: ntrig

     Das Paket 'ntrig' enthält Regeln, um Winkelfunktionen zu
     vereinfachen, die Argumente der Form '<f>(<n> %pi/10)' haben.  <f>
     ist eine der Funktionen 'sin', 'cos', 'tan', 'csc', 'sec' oder
     'cot'.

     Das Kommando 'load(ntrig)' lädt das Paket.  Die Vereinfachungen
     werden dann von Maxima automatisch ausgeführt.

 -- Funktion: trigexpand (<expr>)

     Die Funktion 'trigexpand' expandiert Winkel- und Hyperbelfunktionen
     im Ausdruck <expr>, die Summen und Vielfache von Winkeln als
     Argument haben.  Die besten Ergebnisse werden erzielt, wenn der
     Ausdruck <expr> zunächst expandiert wird.

     Folgende Schalter kontrollieren 'trigexpand':

     'trigexpand'
          Wenn 'true', werden Sinus- und Kosinusfunktionen expandiert.

     'halfangles'
          Wenn 'true', werden Vereinfachungen für halbzahlige Argumente
          angewendet.

     'trigexpandplus'
          Wenn 'true', werden Winkelfunktionen, die eine Summe als
          Argument haben, wie zum Beispiel 'sin(x+y)', vereinfacht.

     'trigexpandtimes'
          Wenn 'true', werden Winkelfunktionen, die ein Produkt als
          Argument haben, wie zum Beispiel 'sin(2 x)', vereinfacht.

     Beispiele:

          (%i1) x+sin(3*x)/sin(x),trigexpand=true,expand;
                                   2           2
          (%o1)               - sin (x) + 3 cos (x) + x
          (%i2) trigexpand(sin(10*x+y));
          (%o2)          cos(10 x) sin(y) + sin(10 x) cos(y)

 -- Optionsvariable: trigexpandplus
     Standardwert: 'true'

     'trigexpandplus' kontrolliert die Vereinfachung von
     Winkelfunktionen mit der Funktion 'trigexpand' für den Fall, dass
     Winkelfunktionen mit Summen als Argumente auftreten.  Hat
     'trigexpandplus' den Wert 'true', werden zum Beispiel
     Winkelfunktionen wie 'sin(x+y)' vereinfacht.

 -- Optionsvariable: trigexpandtimes
     Standardwert: 'true'

     'trigexpandtimes' kontrolliert die Vereinfachung von
     Winkelfunktionen mit der Funktion 'trigexpand' für den Fall, dass
     Winkelfunktionen mit Produkten als Argumente auftreten.  Hat
     'trigexpandtimes' den Wert 'true', werden zum Beispiel
     Winkelfunktionen wie 'sin(2 x)' vereinfacht.

 -- Optionsvariable: triginverses
     Standardwert: 'true'

     Kontrolliert die Vereinfachung, wenn das Argument einer
     Winkelfunktion oder Hyperbelfunktion eine der inversen Funktion
     ist.

     Hat 'triginverses' den Wert 'all', vereinfachen beide Ausdrücke
     'atan(tan(<x>))' und 'tan(atan(<x>))' zum Wert <x>.

     Hat 'triginverses' den Wert 'all', wird '<arcfun>(<fun>(<x>))'
     nicht vereinfacht.

     Hat 'triginverses' den Wert 'false', werden '<arcfun>(<fun>(<x>))'
     und '<fun>(<arcfun>(<x>))' nicht vereinfacht.

 -- Funktion: trigreduce (<expr>, <x>)
 -- Funktion: trigreduce (<expr>)

     Produkte und Potenzen von Winkelfunktionen und den
     Hyperbelfunktionen mit dem Argument <x> werden zu Funktionen
     vereinfacht, die Vielfache von <x> enthalten.  'trigreduce'
     versucht auch, Sinus- und Kosinusfunktionen in einem Nenner zu
     eliminieren.  Wird keine Variable <x> angegeben, werden alle
     Variablen im Ausdruck 'expr' betrachtet.

     Siehe auch 'poissimp'.

          (%i1) trigreduce(-sin(x)^2+3*cos(x)^2+x);
                         cos(2 x)      cos(2 x)   1        1
          (%o1)          -------- + 3 (-------- + -) + x - -
                            2             2       2        2

 -- Optionsvariable: trigsign
     Standardwert: 'true'

     Hat 'trigsign' den Wert 'true', werden Winkelfunktionen mit einem
     negativem Argument vereinfacht.  Zum Beispiel vereinfacht in diesem
     Fall 'sin(-x)' zu '-sin(x)'.

 -- Funktion: trigsimp (<expr>)

     Wendet die Identitäten 'sin(x)^2 + cos(x)^2 = 1' und 'cosh(x)^2 -
     sinh(x)^2 = 1' an, um Ausdrücke, die Funktionen wie 'tan', 'sec',
     usw.  enthalten, zu Ausdrücken mit den Funktionen 'sin', 'cos',
     'sinh', 'cosh' zu vereinfachen.

     Die Anwendung von Funktionen wie 'trigreduce', 'ratsimp' und
     'radcan' kann den Ausdruck weiter vereinfachen.

     Das Kommando 'demo(trgsmp)' zeigt einige Beispiele.

 -- Funktion: trigrat (<expr>)

     Gives a canonical simplifyed quasilinear form of a trigonometrical
     expression; <expr> is a rational fraction of several 'sin', 'cos'
     or 'tan', the arguments of them are linear forms in some variables
     (or kernels) and '%pi/<n>' (<n> integer) with integer coefficients.
     The result is a simplified fraction with numerator and denominator
     linear in 'sin' and 'cos'.  Thus 'trigrat' linearize always when it
     is possible.

          (%i1) trigrat(sin(3*a)/sin(a+%pi/3));
          (%o1)            sqrt(3) sin(2 a) + cos(2 a) - 1

     The following example is taken from Davenport, Siret, and Tournier,
     Calcul Formel, Masson (or in English, Addison-Wesley), section
     1.5.5, Morley theorem.

          (%i1) c : %pi/3 - a - b$
          (%i2) bc : sin(a)*sin(3*c)/sin(a+b);
                                                    %pi
                            sin(a) sin(3 (- b - a + ---))
                                                     3
          (%o2)             -----------------------------
                                     sin(b + a)
          (%i3) ba : bc, c=a, a=c;
                                                   %pi
                              sin(3 a) sin(b + a - ---)
                                                    3
          (%o3)               -------------------------
                                            %pi
                                    sin(a - ---)
                                             3
          (%i4) ac2 : ba^2 + bc^2 - 2*bc*ba*cos(b);
                   2         2         %pi
                sin (3 a) sin (b + a - ---)
                                        3
          (%o4) ---------------------------
                          2     %pi
                       sin (a - ---)
                                 3
                                                 %pi
           - (2 sin(a) sin(3 a) sin(3 (- b - a + ---)) cos(b)
                                                  3
                       %pi            %pi
           sin(b + a - ---))/(sin(a - ---) sin(b + a))
                        3              3
                2       2              %pi
             sin (a) sin (3 (- b - a + ---))
                                        3
           + -------------------------------
                          2
                       sin (b + a)
          (%i5) trigrat (ac2);
          (%o5) - (sqrt(3) sin(4 b + 4 a) - cos(4 b + 4 a)
           - 2 sqrt(3) sin(4 b + 2 a) + 2 cos(4 b + 2 a)
           - 2 sqrt(3) sin(2 b + 4 a) + 2 cos(2 b + 4 a)
           + 4 sqrt(3) sin(2 b + 2 a) - 8 cos(2 b + 2 a) - 4 cos(2 b - 2 a)
           + sqrt(3) sin(4 b) - cos(4 b) - 2 sqrt(3) sin(2 b) + 10 cos(2 b)
           + sqrt(3) sin(4 a) - cos(4 a) - 2 sqrt(3) sin(2 a) + 10 cos(2 a)
           - 9)/4


File: maxima.info,  Node: Hyperbelfunktionen,  Next: Zufallszahlen,  Prev: Winkelfunktionen,  Up: Mathematische Funktionen

10.6 Hyperbelfunktionen
=======================

* Menu:

* Einführung in Hyperbelfunktionen::
* Funktionen und Variablen für Hyperbelfunktionen::


File: maxima.info,  Node: Einführung in Hyperbelfunktionen,  Next: Funktionen und Variablen für Hyperbelfunktionen,  Prev: Hyperbelfunktionen,  Up: Hyperbelfunktionen

10.6.1 Einführung in Hyperbelfunktionen
---------------------------------------


File: maxima.info,  Node: Funktionen und Variablen für Hyperbelfunktionen,  Prev: Einführung in Hyperbelfunktionen,  Up: Hyperbelfunktionen

10.6.2 Funktionen und Variablen für Hyperbelfunktionen
------------------------------------------------------

 -- Funktion: asinh (<x>)
 -- Funktion: acosh (<x>)
 -- Funktion: atanh (<x>)
 -- Funktion: acoth (<x>)
 -- Funktion: acsch (<x>)
 -- Funktion: asech (<x>)

     Die inversen Hyperbelfunktionen: Areasinus Hyperbolicus,
     Areakosinus Hyperbolicus, Areatangens Hyperbolicus, Areakotangens
     Hyperbolicus, Areakosekans Hyperbolicus, Areasekans Hyperbolicus.

 -- Funktion: sinh (<x>)
 -- Funktion: cosh (<x>)
 -- Funktion: tanh (<x>)
 -- Funktion: coth (<x>)
 -- Funktion: csch (<x>)
 -- Funktion: sech (<x>)

     Die Hyperbelfunktionen: Sinus Hyperbolicus, Kosinus Hyperbolicus,
     Tangens Hyperbolicus, Kotangens Hyperbolicus, Kosekans
     Hyperbolicus, Sekans Hyperbolicus.


File: maxima.info,  Node: Zufallszahlen,  Prev: Hyperbelfunktionen,  Up: Mathematische Funktionen

10.7 Zufallszahlen
==================

 -- Funktion: make_random_state (<n>)
 -- Funktion: make_random_state (<s>)
 -- Funktion: make_random_state (true)
 -- Funktion: make_random_state (false)

     Ein Zufallszustand repräsentiert den Zustand des
     Zufallszahlengenerators.  Der Zustand enthält 627 32-Bit Worte.

     'make_random_state(<n>)' gibt einen neuen Zufallszustand zurück,
     der aus einer ganzen Zahl <n> modulo 2^32 erzeugt wird.  <n> kann
     eine negative Zahl sein.

     'make_random_state(<s>)' gibt eine Kopie des Zufallszutandes <s>
     zurück.

     'make_random_state(true)' gibt einen neuen Zufallszustand zurück,
     der aus der aktuellen Systemzeit des Computers erzeugt wird.

     'make_random_state(false)' gibt eine Kopie des aktuellen Zustands
     des Zufallszahlengenerators zurück.

 -- Funktion: set_random_state (<s>)

     Kopiert <s> in den Zufallszustand des Zufallszahlengenerators.

     'set_random_state' gibt immer 'done' zurück.

 -- Funktion: random (<x>)

     Erzeugt eine Pseudo-Zufallszahl.  Ist <x> eine ganze Zahl, gibt
     'random(<x>)' eine ganze Zahl im Intervall 0 bis einschließlich
     '<x>-1' zurück.  Ist <x> eine Gleitkommazahl, gibt 'random(<x>)'
     eine positive Gleitkommazahl zurück, die kleiner als <x> ist.
     'random' gibt eine Fehlermeldung, wenn <x> weder eine ganze Zahl
     noch eine Gleitkommazahl ist oder wenn <x> eine negative Zahl ist.

     Die Funktionen 'make_random_state' und 'set_random_state' verwalten
     den Zustand des Zufallszahlengenerators.

     Der Maxima-Zufallszahlengenerator ist eine Implementation des
     Mersenne twister MT 19937.

     Beispiele:

          (%i1) s1: make_random_state (654321)$
          (%i2) set_random_state (s1);
          (%o2)                         done
          (%i3) random (1000);
          (%o3)                          768
          (%i4) random (9573684);
          (%o4)                        7657880
          (%i5) random (2^75);
          (%o5)                11804491615036831636390
          (%i6) s2: make_random_state (false)$
          (%i7) random (1.0);
          (%o7)                   .2310127244107132
          (%i8) random (10.0);
          (%o8)                   4.394553645870825
          (%i9) random (100.0);
          (%o9)                   32.28666704056853
          (%i10) set_random_state (s2);
          (%o10)                        done
          (%i11) random (1.0);
          (%o11)                  .2310127244107132
          (%i12) random (10.0);
          (%o12)                  4.394553645870825
          (%i13) random (100.0);
          (%o13)                  32.28666704056853


File: maxima.info,  Node: Maximas Datenbank,  Next: Grafische Darstellung,  Prev: Mathematische Funktionen,  Up: Top

11 Maximas Datenbank
********************

* Menu:

* Einführung in Maximas Datenbank::
* Funktionen und Variablen für Eigenschaften::
* Funktionen und Variablen für Fakten::
* Funktionen und Variablen für Aussagen::


File: maxima.info,  Node: Einführung in Maximas Datenbank,  Next: Funktionen und Variablen für Eigenschaften,  Prev: Maximas Datenbank,  Up: Maximas Datenbank

11.1 Einführung in Maximas Datenbank
====================================

Eigenschaften
-------------

Variablen und Funktionen können mit der Funktion 'declare' Eigenschaften
zugewiesen werden.  Diese Eigenschaften werden in eine Datenbank
abgelegt oder in eine von Lisp bereitgestellte Eigenschaftsliste
eingetragen.  Mit der Funktion 'featurep' kann geprüft werden, ob ein
Symbol eine bestimmte Eigenschaft hat und mit der Funktion 'properties'
können alle Eigenschaften eines Symbols angezeigt werden.  Die Funktion
'remove' löscht Eigenschaften aus der Datenbank oder von der
Eigenschaftsliste.  Wird mit der Funktion 'kill' ein Symbol entfernt,
werden auch die zugewiesenen Eigenschaften gelöscht.

Weiterhin können mit den Funktionen 'put' und 'qput' beliebige vom
Nutzer vorgesehene Eigenschaften in die Eigenschaftsliste zu einem
Symbol abgelegt werden.  Mit der Funktion 'get' werden die Eigenschaften
von der Eigenschaftsliste gelesen und mit der Funktion 'rem' gelöscht.

Variablen können die folgenden Eigenschaften erhalten, die in die
Datenbank eingetragen werden.

   constant
   integer        noninteger
   even           odd
   rational       irrational
   real           imaginary      complex

Funktionen können die folgenden Eigenschaften erhalten, die in die
Datenbank eingetragen werden.

   increasing     decreasing
   posfun         integervalued

Die folgenden Eigenschaften können für Funktionen definiert werden und
wirken sich auf die Vereinfachung dieser Funktionen aus.  Diese
Eigenschaften werden in *note Vereinfachung:: beschrieben.

   linear         additive       multiplicative
   outative       commutative    symmetric
   antisymmetric  nary           lassociativ
   rassociative   evenfun        oddfun

Weitere Eigenschaften, die Variablen und Funktionen erhalten können, und
die in die Lisp-Eigenschaftsliste des Symbols abgelegt werden, sind.

   bindtest       feature        alphabetic
   scalar         nonscalar      nonarray

Kontexte
--------

Maxima verwaltet Kontexte, um Eigenschaften von Variablen und Funktionen
sowie Fakten abzulegen.  Fakten werden mit der Funktion 'assume'
definiert und in dem aktuellen Kontext abgelegt.  Mit 'assume(a>10)'
erhält Maxima zum Beispiel die Information, dass die Variable 'a' größer
als '10' ist.  Mit der Funktion 'forget' werden Fakten aus der Datenbank
entfernt.  Fragt Maxima den Nutzer nach Eigenschaften von Variablen,
werden die Antworten in einem Kontext abgelegt.

Ein Kontext hat einen Namen, mit dem auf diesen Bezug genommen werden
kann.  Nach dem Starten von Maxima hat der aktuelle Kontext den Namen
'initial'.  Es kann eine beliebige Anzahl weiterer Kontexte definiert
werden.  Diese können hierarchisch voneinander abhängen.  So ist der
Kontext 'initial' ein Unterkontext zum Kontext 'global'.  Die Fakten in
einem übergeordneten Kontext sind in dem Unterkontext immer präsent.
Der Kontext 'global' enthält zum Beispiel Fakten, die von Maxima
initialisiert werden, und zusätzlich zu den Fakten des Kontextes
'initial' aktiv sind.

Kontexte können eine beliege Anzahl an Fakten aufnehmen.  Sie können mit
der Funktion 'deactivate' deaktiviert werden, ohne dass die Fakten
verloren gehen und später mit der Funktion 'activate' aktiviert werden,
wodurch die Fakten für Aussagefunktionen wieder zur Verfügung stehen.


File: maxima.info,  Node: Funktionen und Variablen für Eigenschaften,  Next: Funktionen und Variablen für Fakten,  Prev: Einführung in Maximas Datenbank,  Up: Maximas Datenbank

11.2 Funktionen und Variablen für Eigenschaften
===============================================

 -- Eigenschaft: alphabetic

     Das Kommando 'declare(string, alphabetic)' deklariert die Zeichen
     der Zeichenkette <string> als alphabetisch.  Das Argument <string>
     muss eine Zeichenkette sein.  Zeichen, die als alphabetisch
     deklariert sind, können in Maxima-Bezeichnern verwendet werden.
     Siehe auch *note Bezeichner::.

     Beispiele:

     Die Zeichen '"~"', '"@"' und '`' als alphabetisch erklärt.

          (%i1) xx\~yy\`\@ : 1729;
          (%o1)                         1729
          (%i2) declare ("~`@", alphabetic);
          (%o2)                         done
          (%i3) xx~yy`@ + @yy`xx + `xx@@yy~;
          (%o3)               `xx@@yy~ + @yy`xx + 1729
          (%i4) listofvars (%);
          (%o4)                  [@yy`xx, `xx@@yy~]

 -- Eigenschaft: bindtest

     Hat ein Symbol <x> die Eigenschaft 'bindtest' und wird es
     ausgewertet, ohne das dem Symbol bisher ein Wert zugewiesen wurde,
     signalisiert Maxima einen Fehler.  Siehe auch die Funktion
     'declare'.

     Beispiel:

          (%i1) aa + bb;
          (%o1)                        bb + aa
          (%i2) declare (aa, bindtest);
          (%o2)                         done
          (%i3) aa + bb;
          aa unbound variable
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) aa : 1234;
          (%o4)                         1234
          (%i5) aa + bb;
          (%o5)                       bb + 1234

 -- Eigenschaft: constant

     Das Kommando 'declare(<a>, constant)' deklariert ein Symbol <a> als
     konstant.  Die Funktion 'constantp' hat für dieses Symbol dann das
     Ergebnis 'true'.  Die Deklaration als eine Konstante verhindert
     nicht, dass dem Symbol ein Wert zugewiesen werden kann.  Siehe
     'declare' und 'constantp'.

     Beispiel:

          (%i1) declare(c, constant);
          (%o1)                         done
          (%i2) constantp(c);
          (%o2)                         true
          (%i3) c : x;
          (%o3)                           x
          (%i4) constantp(c);
          (%o4)                         false

 -- Funktion: constantp (<expr>)

     Gibt für einen konstanten Ausdruck <expr> den Wert 'true' zurück,
     andernfalls 'false'.

     Ein Ausdruck wird von Maxima als ein konstanter Ausdruck erkannt,
     wenn seine Argumente Zahlen sind (einschließlich von Zahlen in
     einer CRE-Darstellung), symbolische Konstanten wie '%pi', '%e' und
     '%i', Variablen, die einen konstanten Wert haben, Variablen, die
     mit 'declare' als konstant deklariert sind, oder Funktionen, deren
     Argumente konstant sind.

     Die Funktion 'constantp' wertet das Argument aus.

     Siehe auch die Eigenschaft 'constant'.

     Beispiele:

          (%i1) constantp (7 * sin(2));
          (%o1)                                true
          (%i2) constantp (rat (17/29));
          (%o2)                                true
          (%i3) constantp (%pi * sin(%e));
          (%o3)                                true
          (%i4) constantp (exp (x));
          (%o4)                                false
          (%i5) declare (x, constant);
          (%o5)                                done
          (%i6) constantp (exp (x));
          (%o6)                                true
          (%i7) constantp (foo (x) + bar (%e) + baz (2));
          (%o7)                                false
          (%i8)

 -- Funktion: declare (<a_1>, <p_1>, <a_2>, <p_2>, ...)

     Weist dem Symbol <a_i> die Eigenschaft <p_i> zu.  Die Argumente
     <a_i> und <p_i> können Listen sein.  Ist <a_i> eine Liste, dann
     erhält jedes Symbol der Liste die Eigenschaft <p_i>.  Ist umgekehrt
     <p_i> eine Liste mit Eigenschaften, dann erhält das Symbol <a_i>
     diese Eigenschaften.  Entsprechend erhalten alle Symbole einer
     Liste <a_i> die Eigenschaften einer Liste <p_i>.

     Die Funktion 'declare' wertet die Argumente nicht aus.  'declare'
     gibt stets 'done' als Ergebnis zurück.

     Hat ein Symbol <sym> die Eigenschaft <prop> mit der Funktion
     'declare' erhalten, dann hat das Kommando 'featurep(<sym>, <prop>)'
     das Ergebnis 'true'.  Mit der Funktion 'properties' können alle
     Eigenschaften eines Symbols angezeigt werden.

     Mit der Funktion 'declare' können Symbole die folgenden
     Eigenschaften erhalten:

     'additive'
          Hat eine Funktion 'f' die Eigenschaft 'additive', wird ein
          Ausdruck der Form 'f(x + y + z + ...)' zu 'f(x) + f(y) + f(z)
          + ...' vereinfacht.  Siehe 'additive'.

     'alphabetic'
          <a_i> ist eine Zeichenkette, deren Zeichen als alphabetische
          Zeichen deklariert werden.  Die Zeichen können dann in
          Maxima-Bezeichnern verwendet werden.  Siehe 'alphabetic' für
          Beispiele.

     'antisymmetric, commutative, symmetric'
          <a_i> wird als eine symmetrische, antisymmetrische oder
          kommutative Funktion interpretiert.  Die Eigenschaften
          'commutative' und 'symmetric' sind äquivalent.  Siehe
          'antisymmetric', 'commutative' und 'symmetric'.

     'bindtest'
          Hat ein Symbol die Eigenschaft 'bindtest' und wird es
          ausgewertet, ohne das dem Symbol bisher ein Wert zugewiesen
          wurde, signalisiert Maxima einen Fehler.  Siehe 'bindtest' für
          Beispiele.

     'constant'
          Hat ein Symbol die Eigenschaft 'constant', wird es von Maxima
          als eine Konstante interpretiert.  Siehe auch 'constant'.

     'even, odd'
          Erhält eine Variable die Eigenschaft 'even' oder 'odd', wird
          sie als gerade oder ungerade interpretiert.

     'evenfun, oddfun'
          Erhält eine Funktion oder ein Operator die Eigenschaft
          'evenfun' oder 'oddfun' wird die Funktion oder der Operator
          von Maxima als gerade und ungerade interpretiert.  Diese
          Eigenschaft wird bei der Vereinfachung von Ausdrücken von
          Maxima angewendet.  Siehe 'evenfun' und 'oddfun'.

     'evflag'
          Deklariert die Variable 'a_i' als einen Auswertungsschalter.
          Während der Auswertung eines Ausdrucks mit der Funktion 'ev',
          erhält der Auswertungsschalter 'a_i' den Wert 'true'.  Siehe
          'evflag' für Beispiele.

     'evfun'
          Deklariert eine Funktion <a_i> als eine Auswertungsfunktion.
          Tritt die Funktion <a_i> als Argument der Funktion 'ev' auf,
          so wird die Funktion auf den Ausdruck angewendet.  Siehe
          'evfun' für Beispiele.

     'feature'
          <a_i> wird als eine Eigenschaft 'feature' interpretiert.
          Andere Symbole können dann diese vom Nutzer definierte
          Eigenschaft erhalten.  Siehe 'feature'.

     'increasing, decreasing'
          Erhält eine Funktion die Eigenschaft 'decreasing' oder
          'increasing', wird die Funktion als eine monoton steigende
          oder fallende Funktion interpretiert.  Siehe 'decreasing' und
          'increasing'.

     'integer, noninteger'
          <a_i> wird als eine ganzzahlige oder nicht-ganzzahlige
          Variable interpretiert.  Siehe 'integer' und 'noninteger'.

     'integervalued'
          Erhält eine Funktion die Eigenschaft 'integervalued', nimmt
          Maxima für Vereinfachungen an, dass die Funktionen einen
          ganzzahligen Wertebereich hat.  Für ein Beispiel siehe
          'integervalued'.

     'lassociative, rassociative'
          <a_i> wird als eine rechts- oder links-assoziative Funktion
          interpretiert.  Siehe 'lassociative' und 'rassociative'.

     'linear'
          Entspricht der Deklaration einer Funktion als 'outative' und
          'additive'.  Siehe auch 'linear'.

     'mainvar'
          Wird eine Variable als <mainvar> deklariert, wird sie als eine
          "Hauptvariable" interpretiert.  Eine Hauptvariable wird vor
          allen Konstanten und Variablen in einer kanonischen Ordnung
          eines Maxima-Ausdrückes angeordnet.  Die Anordnung wird durch
          die Funktion 'ordergreatp' bestimmt.  Siehe auch 'mainvar'.

     'multiplicative'
          Hat eine Funktion 'f' die Eigenschaft 'multiplicative', werden
          Ausdrücke der Form '<a_i>(x * y * z * ...)' zu '<a_i>(x) *
          <a_i>(y) * <a_i>(z) * ...' vereinfacht.  Die Vereinfachung
          wird nur für das erste Argument der Funktion <f> ausgeführt.
          Siehe 'multiplicative'.

     'nary'
          Erhält eine Funktion oder ein Operator die Eigenschaft 'nary',
          wird die Funktion oder der Operator bei der Vereinfachung als
          Nary-Funktion oder Nary-Operator interpretiert.
          Verschachtelte Ausdrücke wie 'foo(x, foo(y, z))' werden zum
          Beispiel zu 'foo(x, y, z)' vereinfacht.  Die Deklaration
          'nary' unterscheidet sich von der Funktion 'nary'.  Während
          der Funktionsaufruf einen neuen Operator definiert, wirkt sich
          die Deklaration nur auf die Vereinfachung aus.  Siehe auch
          'nary'.

     'nonarray'
          Hat ein Symbol <a_i> die Eigenschaft 'nonarray', wird es nicht
          als ein Array interpretiert, wenn das Symbol einen Index
          erhält.  Diese Deklaration verhindert die mehrfache
          Auswertung, wenn <a_i> als indizierte Variable genutzt wird.
          Siehe 'nonarray'.

     'nonscalar'
          <a_i> wird als eine nicht-skalare Variable interpretiert.  Ein
          Symbol wird also als ein Vektor oder eine Matrix deklariert.
          Siehe 'nonscalar'.

     'noun'
          <a_i> wird als Substantivform interpretiert.  Abhängig vom
          Kontext wird <a_i> durch ''<a_i>' oder 'nounify(<a_i>)'
          ersetzt.  Siehe auch 'noun'.  für ein Beispiel.

     'outative'
          Ausdrücke mit der Funktion <a_i> werden so vereinfacht, dass
          konstante Faktoren aus dem Argument herausgezogen werden.  Hat
          die Funktion <a_i> ein Argument, wird ein Faktor dann als
          konstant angesehen, wenn er ein Symbol oder eine deklarierte
          Konstante ist.  Hat die Funktion <a_i> zwei oder mehr
          Argumente, wird ein Faktor dann als konstant angesehen, wenn
          das zweite Argument ein Symbol und der Faktor unabhängig vom
          zweiten Argument ist.  Siehe auch 'outative'.

     'posfun'
          <a_i> wird als eine Funktion interpretiert, die nur positive
          Werte hat.  Siehe 'posfun'.

     'rational, irrational'
          <a_i> wird als eine rationale oder irrationale Zahl
          interpretiert.  Siehe 'rational' und 'irrational'.

     'real, imaginary, complex'
          <a_i> wird als eine reelle, imaginäre oder komplexe Zahl
          interpretiert.  Siehe 'real', 'imaginary' und 'complex'.

     'scalar'
          <a_i> wird als skalare Variable interpretiert.  Siehe
          'scalar'.

 -- Eigenschaft: decreasing
 -- Eigenschaft: increasing

     Erhält eine Funktion mit der Funktion 'declare' die Eigenschaft
     'decreasing' oder 'increasing' wird die Funktion als eine steigende
     oder fallende Funktion interpretiert.

     Beispiel:

          (%i1) assume(a > b);
          (%o1)                        [a > b]
          (%i2) is(f(a) > f(b));
          (%o2)                        unknown
          (%i3) declare(f, increasing);
          (%o3)                         done
          (%i4) is(f(a) > f(b));
          (%o4)                         true

 -- Eigenschaften: even
 -- Eigenschaften: odd

     Hat eine Variable mit der Funktion 'declare' die Eigenschaft 'even'
     oder 'odd' erhalten, wird sie von Maxima als gerade oder ungerade
     ganze Zahl interpretiert.  Diese Eigenschaften werden jedoch nicht
     von den Funktionen 'evenp', 'oddp' oder 'integerp' erkannt.

     Siehe auch die Funktion 'askinteger'.

     Beispiele:

          (%i1) declare(n, even);
          (%o1)                         done
          (%i2) askinteger(n, even);
          (%o2)                          yes
          (%i3) askinteger(n);
          (%o3)                          yes
          (%i4) evenp(n);
          (%o4)                         false

 -- Eigenschaft: feature

     'feature' ist eine Eigenschaft, die ein Symbol <sym> mit der
     Funktion 'declare' erhalten kann.  In diesem Fall ist das Symbol
     <sym> selbst eine Eigenschaft, so dass das Kommando 'declare(x,
     sym)' einem Symbol <x> die vom Nutzer definierte Eigenschaft 'sym'
     gibt.

     Maxima unterscheidet Systemeigenschaften und mathematische
     Eigenschaften, die Symbole und Ausdrücke haben können.  Für
     Systemeigenschaften siehe die Funktion 'status'.  Für mathematische
     Eigenschaften siehe die Funktionen 'declare' und 'featurep'.

     Beispiel:

          (%i1) declare (FOO, feature);
          (%o1)                         done
          (%i2) declare (x, FOO);
          (%o2)                         done
          (%i3) featurep (x, FOO);
          (%o3)                         true

 -- Funktion: featurep (<a>, <p>)

     Stellt fest, ob das Symbol oder der Ausdruck <a> die Eigenschaft
     <p> hat.  Maxima nutzt die Fakten der aktiven Kontexte und die
     definierten Eigenschaften für Symbole und Funktionen.

     'featurep' gibt sowohl für den Fall 'false' zurück, dass das
     Argument <a> nicht die Eigenschaft <p> hat, als auch für den Fall,
     dass Maxima dies nicht anhand der bekannten Fakten und
     Eigenschaften entscheiden kann.

     'featurep' wertet die Argumente aus.

     Siehe auch 'declare' und 'featurep'..

     Beispiele:

          (%i1) declare (j, even)$
          (%i2) featurep (j, integer);
          (%o2)                           true

 -- Systemvariable: features

     Maxima kennt spezielle mathematische Eigenschaften von Funktionen
     und Variablen.

     'declare(<x>)', <foo> gibt der Funktion oder Variablen <x> die
     Eigenschaft <foo>.

     'declare(<foo>, feature)' deklariert die neue Eigenschaft <foo>.
     Zum Beispiel deklariert 'declare([red, green, blue], feature)' die
     drei neuen Eigenschaften 'red', 'green' und 'blue'.

     'featurep(<x>, <foo>)' hat die Rückgabe 'true', wenn <x> die
     Eigenschaft <foo> hat.  Ansonsten wird 'false' zurückgegeben.

     Die Informationsliste 'features' enthält eine Liste der
     Eigenschaften, die Funktionen und Variablen erhalten können und die
     in die Datenbank eingetragen werden:

        integer         noninteger       even
        odd             rational         irrational
        real            imaginary        complex
        analytic        increasing       decreasing
        oddfun          evenfun          posfun
        commutative     lassociative     rassociative
        symmetric       antisymmetric

     Hinzu kommen die vom Nutzer definierten Eigenschaften.

     'features' ist eine Liste der mathematischen Eigenschaften.  Es
     gibt weitere Eigenschaften.  Siehe 'declare' und 'status'.

 -- Funktion: get (<a>, <i>)

     Gibt die Eigenschaft <i> des Symbols <a> zurück.  Hat das Symbol
     <a> nicht die Eigenschaft <i>, wird 'false' zurückgegeben.

     'get' wertet die Argumente aus.

     Beispiele:

          (%i1) put (%e, 'transcendental, 'type);
          (%o1)                    transcendental
          (%i2) put (%pi, 'transcendental, 'type)$
          (%i3) put (%i, 'algebraic, 'type)$
          (%i4) typeof (expr) := block ([q],
                  if numberp (expr)
                  then return ('algebraic),
                  if not atom (expr)
                  then return (maplist ('typeof, expr)),
                  q: get (expr, 'type),
                  if q=false
                  then errcatch (error(expr,"is not numeric.")) else q)$
          (%i5) typeof (2*%e + x*%pi);
          x is not numeric.
          (%o5)  [[transcendental, []], [algebraic, transcendental]]
          (%i6) typeof (2*%e + %pi);
          (%o6)     [transcendental, [algebraic, transcendental]]

 -- Eigenschaften: integer
 -- Eigenschaften: noninteger

     Hat eine Variable mit der Funktion 'declare' die Eigenschaft
     'integer' oder 'noninteger' erhalten, wird sie von Maxima als eine
     ganze Zahl oder als nicht-ganze Zahl interpretiert.  Siehe auch
     'askinteger'.

     Beispiele:

          (%i1) declare(n, integer, x, noninteger);
          (%o1)                         done
          (%i2) askinteger(n);
          (%o2)                          yes
          (%i3) askinteger(x);
          (%o3)                          no

 -- Eigenschaft: integervalued

     Erhält eine Funktion mit 'declare' die Eigenschaft 'integervalued',
     nimmt Maxima für Vereinfachungen an, dass der Wertebereich der
     Funktion ganzzahlig ist.

     Beispiel:

          (%i1) exp(%i)^f(x);
                                        %i f(x)
          (%o1)                      (%e  )
          (%i2) declare(f, integervalued);
          (%o2)                         done
          (%i3) exp(%i)^f(x);
                                        %i f(x)
          (%o3)                       %e

 -- Eigenschaft: nonarray

     'declare(a, nonarray)' gibt dem Symbol <a> die Eigenschaft nicht
     ein Array zu sein.  Dies verhindert die mehrfache Auswertung, wenn
     das Symbol <a> als indizierte Variable genutzt wird.

     Beispiel:

          (%i1) a:'b$ b:'c$ c:'d$

          (%i4) a[x];
          (%o4)                          d
                                          x
          (%i5) declare(a, nonarray);
          (%o5)                         done
          (%i6) a[x];
          (%o6)                          a
                                          x

 -- Eigenschaft: nonscalar

     Hat ein Symbol die Eigenschaft 'nonscalar', verhält es sich wie
     eine Matrix oder Liste bei nicht-kommutativen Rechenoperationen.

 -- Funktion: nonscalarp (<expr>)

     Gibt 'true' zurück, wenn der Ausdruck <expr> kein Skalar ist.  Der
     Ausdruck enthält dann Matrizen, Listen oder Symbole, die als
     'nonscalar' deklariert wurden.

 -- Eigenschaft: posfun

     'declare(f, posfun)' deklariert die Funktion 'f' als eine Funktion,
     die nur positive Werte annimmt.  'is(f(x) > 0)' gibt dann 'true'
     zurück.

 -- Funktion: printprops (<a>, <i>)
 -- Funktion: printprops ([<a_1>, ..., <a_n>], <i>)
 -- Funktion: printprops (all, <i>)

     Zeigt die zum Kennzeichen <i> zugeordnete Eigenschaft des Atoms <a>
     an.  <i> kann einer der Werte 'gradef', 'atvalue', 'atomgrad' oder
     'matchdeclare' sein.  <a> kann sowohl eine Liste von Atomen, als
     auch das Atom 'all' sein.  In diesem Fall werden alle Atome
     angezeigt, die eine Eigenschaft zum Kennzeichen <i> haben.

     Beispiel:

          (%i1) gradef(f(x), 2*g(x));
          (%o1)                         f(x)
          (%i2) printprops(f,gradef);
                                 d
                                 -- (f(x)) = 2 g(x)
                                 dx

          (%o2)                         done

 -- Funktion: properties (<a>)

     Gibt eine Liste mit den Eigenschaften zurück, die das Symbol <a>
     von Maxima oder dem Nutzer erhalten hat.  Die Rückgabe kann jede
     Eigenschaft enthalten, die mit der Funktion 'declare' einem Symbol
     zugewiesen ist.  Diese Eigenschaften sind:

        linear         additive       multiplicative
        outative       commutative    symmetric
        antisymmetric  nary           lassociativ
        rassociative   evenfun        oddfun
        bindtest       feature        alphabetic
        scalar         nonscalar      nonarray
        constant       integer        noninteger
        even           odd            rational
        irrational     real           imaginary
        complex        increasing     decreasing
        posfun         integervalued

     Die folgenden Einträge beschreiben Eigenschaften, die Variablen
     haben können:

     'value'
          Der Variable ist mit dem Operatoren ':' oder '::' ein Wert
          zugewiesen.
     'system value'
          Die Variable ist eine Optionsvariable oder Systemvariable, die
          von Maxima definiert ist.
     'numer'
          Die Variable hat einen numerischen Wert auf der
          Eigenschaftsliste, der mit der Funktion 'numerval' zugewiesen
          ist.
     'assign property'
          Die Variable hat eine eine Funktion auf der Eigenschaftsliste,
          die die Zuweisung eines Wertes kontrolliert.

     Einträge, die die Eigenschaften von Funktionen beschreiben:

     'function'
          Eine mit dem Operator ':=' oder der Funktion 'define'
          definierte Nutzerfunktion.
     'macro'
          Eine mit dem Operator '::=' definierte Makrofunktion.
     'system function'
          Ein interne Maxima-Funktion.
     'special evaluation form'
          Eine Maxima-Spezialform, die die Argumente nicht auswertet.
     'transfun'
          Wird eine Nutzerfunktion mit 'translate' übersetzt oder mit
          der Funktion 'compile' kompiliert, erhält sie die Eigenschaft
          'transfun'.  Interne Maxima-Funktionen, die mit dem Lisp-Makro
          'defmfun' definiert werden, haben ebenfalls diese Eigenschaft.
     'deftaylor'
          Für die Funktion ist eine Taylorreihenentwicklung definiert.
     'gradef'
          Die Funktion hat eine Ableitung.
     'integral'
          Die Funktion hat eine Stammfunktion.
     'distribute over bags'
          Ist das Argument der Funktion eine Liste, Matrix oder
          Gleichung so wird die Funktion auf die Elemente oder beide
          Seiten der Gleichung angewendet.
     'limit function'
          Es existiert eine Funktion für die Behandlung spezieller
          Grenzwerte.
     'conjugate function'
          Es existiert eine Funktion, um die konjugiert komplexe
          Funktion für spezielle Wertebereiche zu ermitteln.
     'mirror symmetry'
          Die Funktion hat die Eigenschaft der Spiegelsymmetrie.
     'complex characteristic'
          Es existiert eine Funktion, um den Realteil und den
          Imaginärteil der Funktion für spezielle Wertebereiche zu
          ermitteln.
     'user autoload function'
          Die Funktion wird automatisch beim ersten Aufruf aus einer
          Datei geladen.  Der Nutzer kann mit dem Funktion
          'setup_autoload' eine solche Funktion definieren.

     Weitere Eigenschaften, die Symbole erhalten können:

     'operator'
          Das Symbol ist ein Maxima-Operator oder ein nutzerdefinierte
          Operator.

     'rule'
          Die Funktion oder der Operator haben eine Regel für die
          Vereinfachung.

     'alias'

     'database info'
          Das Symbol hat Einträge in Maximas Datenbank.

     'hashed array, declared array, complete array'
          Ein Hashed-Array, ein deklariertes Array oder ein Array dessen
          Elemente einen bestimmten Typ haben.

     'array function'
          Eine Array-Funktion die mit dem Operator ':=' definiert ist.

     'atvalue'
          Dem Symbol ist mit der Funktion 'atvalue' ein Wert an einer
          Stelle zugewiesen.

     'atomgrad'
          Für das Symbol ist mit der Funktion 'gradef' eine Ableitung
          definiert.

     'dependency'
          Für das Symbol ist eine Abhängigkeit mit der Funktion
          'depends' definiert.

     'matchdeclare'
          Das Symbol ist eine mit 'matchdeclare' definierte
          Mustervariable, der eine Aussagefunktion zugeordnet ist.

     'modedeclare'
          Für das Symbol ist mit der Funktion 'mode_declare' ein Typ
          definiert.

     'user properties'

     'context'
          Das Symbol bezeichnet einen Kontext.

     'activecontext'
          Das Symbol bezeichnet einen aktiven Kontextes.

 -- Systemvariable: props
     Standardwert: '[]'

     'props' ist eine Liste der Symbole, die vom Nutzer eine Eigenschaft
     erhalten haben, die in die Lisp-Eigenschaftsliste des Symbols
     eingetragen wird.  Neben den Funktionen 'put' und 'qput', mit denen
     der Nutzer direkt eine Eigenschaft zu einem Symbol in die
     Lisp-Eigenschaftsliste eintragen kann, legen auch Maxima-Funktionen
     Eigenschaften zu Symbolen in der Eigenschaftsliste ab und tragen
     diese Symbole in die Systemvariable 'props' ein.  Zu diesen
     Funktionen gehören zum Beispiel 'declare', 'numerval',
     'matchdeclare', 'mode_declare', 'gradef' oder 'setup_autoload'.

     Nach dem Start von Maxima sollte die Systemvariable 'props' keine
     Symbole enthalten.  Das ist jedoch nicht der Fall und kann als ein
     Fehler betrachtet werden, der in Zukunft zu beheben ist.

 -- Funktion: propvars (<prop>)

     Gibt eine Liste mit den Atomen zurück, die in der Informationsliste
     'props' eingetragen sind und die die Eigenschaft <prop> haben.  Zum
     Beispiel gibt 'propvars(atvalue)' eine Liste der Atome zurück, die
     die Eigenschaft 'atvalue' haben.

 -- Funktion: put (<atom>, <value>, <indicator>)

     Weist den Wert <value> der Eigenschaft <indicator> des Atoms <atom>
     zu.  <indicator> kann eine beliebige Eigenschaft sein und
     beschränkt sich nicht auf die vom System definierten Eigenschaften.
     'put' wertet die Argumente aus.  'put' gibt <value> zurück.

     Beispiele:

          (%i1) put (foo, (a+b)^5, expr);
                                             5
          (%o1)                       (b + a)
          (%i2) put (foo, "Hello", str);
          (%o2)                         Hello
          (%i3) properties (foo);
          (%o3)            [[user properties, str, expr]]
          (%i4) get (foo, expr);
                                             5
          (%o4)                       (b + a)
          (%i5) get (foo, str);
          (%o5)                         Hello

 -- Funktion: qput (<atom>, <value>, <indicator>)

     Entspricht der Funktion 'put' mit dem Unterschied, dass 'qput' die
     Argumente nicht auswertet.

     Beispiele:

          (%i1) foo: aa$
          (%i2) bar: bb$
          (%i3) baz: cc$
          (%i4) put (foo, bar, baz);
          (%o4)                          bb
          (%i5) properties (aa);
          (%o5)                [[user properties, cc]]
          (%i6) get (aa, cc);
          (%o6)                          bb
          (%i7) qput (foo, bar, baz);
          (%o7)                          bar
          (%i8) properties (foo);
          (%o8)            [value, [user properties, baz]]
          (%i9) get ('foo, 'baz);
          (%o9)                          bar

 -- Eigenschaft: rational
 -- Eigenschaft: irrational

     Hat eine Variable mit der Funktion 'declare' die Eigenschaft
     'rational' oder 'irrational' erhalten, wird sie von Maxima als eine
     rationale Zahl oder als eine nicht rationale Zahl interpretiert.

 -- Eigenschaft: real
 -- Eigenschaft: imaginary
 -- Eigenschaft: complex

     Hat eine Variable mit der Funktion 'declare' die Eigenschaft
     'real', 'imaginary' oder 'complex' erhalten, wird sie von Maxima
     als eine reelle Zahl, imaginäre Zahl oder als eine komplexe Zahl
     interpretiert.

 -- Funktion: rem (<atom>, <indicator>)

     Entfernt die Eigenschaft <indicator> vom Atom <atom>.

 -- Funktion: remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)
 -- Funktion: remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)
 -- Funktion: remove ("<a>", operator)
 -- Funktion: remove (<a>, transfun)
 -- Funktion: remove (all, <p>)

     Entfernt Eigenschaften von Atomen.

     'remove(<a_1>, <p_1>, ..., <a_n>, <p_n>)' entfernt die Eigenschaft
     'p_k' von dem Atom 'a_k'.

     'remove([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)' entfernt
     die Eigenschaften <p_1>, ..., <p_n> von den Atomen <a_1>, ...,
     <a_m>.  Es können mehrere Paare an Listen angegeben werden.

     'remove(all, <p>)' entfernt die Eigenschaft <p> von allen Atomen,
     die diese Eigenschaft aufweisen.

     Die zu entfernenden Eigenschaften können vom System definierte
     Eigenschaften wie 'function', 'macro', 'mode_declare' oder
     nutzerdefinierte Eigenschaften sein.

     'remove("<a>", operator)' oder 'remove("<a>", op)' entfernen vom
     Atom <a> die Operatoreigenschaften, die mit den Funktionen
     'prefix', 'infix', 'nary', 'postfix', 'matchfix' oder 'nofix'
     definiert wurden.  Die Namen von Operatoren müssen als eine
     Zeichenkette angegeben werden.

     'remove' gibt immer 'done' zurück.

 -- Eigenschaft: scalar

     Hat ein Symbol die Eigenschaft 'scalar', verhält es sich wie ein
     Skalar bei nicht-kommutativen Rechenoperationen.

 -- Funktion: scalarp (<expr>)

     Gibt 'true' zurück, wenn der Ausdruck <expr> eine Zahl, Konstante,
     ein als Skalar definiertes Symbol oder ein aus diesen Objekten
     zusammengesetzter Ausdruck ist.  Der Ausdruck darf jedoch keine
     Liste oder eine Matrix sein.


File: maxima.info,  Node: Funktionen und Variablen für Fakten,  Next: Funktionen und Variablen für Aussagen,  Prev: Funktionen und Variablen für Eigenschaften,  Up: Maximas Datenbank

11.3 Funktionen und Variablen für Fakten
========================================

 -- Funktion: activate (<context_1>, ..., <context_n>)

     Das Kommando 'activate(<context>)' aktiviert den Kontext <context>.
     Der Funktion 'activate' können mehrere Kontexte <context_1>, ...,
     <context_n> übergeben werden.  Nur die Aussagen und Fakten eines
     aktiven Kontextes stehen für die Auswertung von Aussagen zur
     Verfügung.

     Maxima gibt 'done' zurück, wenn der Kontext erfolgreich aktiviert
     werden konnte oder wenn der Kontext bereits aktiv ist.  Wird
     versucht einen nicht existierenden Kontext zu aktivieren, gibt
     Maxima eine Fehlermeldung aus.

     Das Kommando 'facts()' gibt die Fakten und Aussagen des aktuellen
     Kontextes aus.  Die Aussagen und Fakten anderer Kontexte können
     zwar aktiv sein, sind aber in der Rückgabe von 'facts' nicht
     enthalten.  Um die Aussagen und Fakten eines anderen als des
     aktuellen Kontexts auszugeben, kann das Kommando 'facts(<context>)'
     ausgeführt werden.

     Die Systemvariable 'activecontexts' enthält eine Liste der aktiven
     Kontexte.  Siehe auch die Systemvariable 'contexts' für eine Liste
     aller Kontexte, die Maxima kennt.

 -- Systemvariable: activecontexts
     Standardwert: '[]'

     Die Systemvariable 'activecontexts' enthält eine Liste der
     Kontexte, die mit der Funktion 'activate' aktiviert wurden.
     Unterkontexte sind aktiv, ohne dass die Funktion 'activate'
     aufgerufen werden muss und sind nicht in der Liste 'activecontexts'
     enthalten.  Siehe auch die Funktion 'activate' für die Aktivierung
     eines Kontextes und die Systemvariable 'contexts' für eine Liste
     aller vorhandenen Kontexte.

 -- Funktion: askinteger (<expr>, integer)
 -- Funktion: askinteger (<expr>)
 -- Funktion: askinteger (<expr>, even)
 -- Funktion: askinteger (<expr>, odd)

     Das Kommando 'askinteger(<expr>, integer)' versucht anhand der
     Aussagen und Fakten der aktiven Kontexte zu entscheiden, ob <expr>
     eine ganze Zahl repräsentiert.  Kann 'askinteger' die Frage nicht
     entscheiden, fragt Maxima den Nutzer.  Die Antwort wird dem
     aktuellen Kontext hinzugefügt.  'askinteger(<expr>)' ist äquivalent
     zu 'askinteger(<expr>, integer)'.

     'askinteger(<expr>, even)' und 'askinteger(<expr>, odd)' versuchen
     zu entscheiden, ob <expr> eine gerade oder ungerade ganze Zahl
     repräsentiert.  Kann Maxima dies nicht entscheiden, wird der Nutzer
     gefragt.  Die Antwort wird dem aktuellen Kontext hinzugefügt.

     Beispiele:

          (%i1) askinteger(n,integer);
          Is n an integer?
          yes;
          (%o1)                          yes
          (%i2) askinteger(e,even);
          Is e an even number?
          yes;
          (%o2)                          yes
          (%i3) facts();
          (%o3)           [kind(n, integer), kind(e, even)]
          (%i4) declare(f,integervalued);
          (%o4)                         done
          (%i5) askinteger(f(x));
          (%o5)                          yes

 -- Funktion: asksign (<expr>)

     Die Funktion 'asksign' versucht zu entscheiden, ob der Ausdruck
     <expr> einen positiven, negativen oder den Wert Null repräsentiert.
     Kann Maxima dies nicht feststellen, wird der Nutzer nach weiteren
     Informationen gefragt, um die Frage zu entscheiden.  Die Antworten
     des Nutzers werden für die laufende Auswertung dem aktuellen
     Kontext hinzugefügt.  Der Rückgabewert der Funktion 'asksign' ist
     'pos', 'neg' oder 'zero' für einen positiven, negativen oder den
     Wert Null.

 -- Funktion: assume (<pred_1>, ..., <pred_n>)

     Fügt die Aussagen <pred_1>, ..., <pred_n> dem aktuellen Kontext
     hinzu.  Eine inkonsistente oder redundante Aussage wird dem Kontext
     nicht hinzugefügt.  'assume' gibt eine Liste mit den Aussagen
     zurück, die dem Kontext hinzugefügt wurden, oder die Symbole
     'redunant' und 'inconsistent'.

     Die Aussagen <pred_1>, ..., <pred_n> können nur Ausdrücke mit den
     relationalen Operatoren '"<"', '"<="', 'equal', 'notequal', '">="'
     und '">"' sein.  Aussagen können nicht die Operatoren '"="' für
     Gleichungen oder '"#"' für Ungleichungen enthalten.  Auch können
     keine Aussagefunktionen wie 'integerp' verwendet werden.

     Zusammengesetzte Aussagen mit dem Operator 'and' der Form '<pred_1>
     and ... and <pred_n>' sind möglich, nicht dagegen Aussagen mit dem
     Operator 'or' der Form '<pred_1> or ... or <pred_n>'.  Ein Ausdruck
     mit dem Operator 'not' der Form 'not(<pred_k>)' ist dann möglich,
     wenn <pred_k> eine relationale Aussage ist.  Aussagen der Form 'not
     (<pred_1> and <pred_2>)' und 'not (<pred_1> or <pred_2>)' sind
     dagegen nicht möglich.

     Der Folgerungsmechanismus von Maxima ist nicht sehr stark.  Viele
     Schlußfolgerungen können von Maxima nicht abgeleitet werden.  Dies
     ist eine bekannte Schwäche von Maxima.

     'assume' behandelt keine Aussagen mit komplexen Zahlen.  Enthält
     eine Aussage eine komplexe Zahl, gibt 'assume' den Wert
     'inconsistent' oder 'redunant' zurück.

     'assume' wertet die Argumente aus.

     Siehe auch 'is', 'facts', 'forget', 'context' und 'declare'.

     Beispiele:

          (%i1) assume (xx > 0, yy < -1, zz >= 0);
          (%o1)              [xx > 0, yy < - 1, zz >= 0]
          (%i2) assume (aa < bb and bb < cc);
          (%o2)                  [bb > aa, cc > bb]
          (%i3) facts ();
          (%o3)     [xx > 0, - 1 > yy, zz >= 0, bb > aa, cc > bb]
          (%i4) is (xx > yy);
          (%o4)                         true
          (%i5) is (yy < -yy);
          (%o5)                         true
          (%i6) is (sinh (bb - aa) > 0);
          (%o6)                         true
          (%i7) forget (bb > aa);
          (%o7)                       [bb > aa]
          (%i8) prederror : false;
          (%o8)                         false
          (%i9) is (sinh (bb - aa) > 0);
          (%o9)                        unknown
          (%i10) is (bb^2 < cc^2);
          (%o10)                       unknown

 -- Optionsvariable: assumescalar
     Standardwert: 'true'

     Die Optionsvariable 'assumescalar' kontrolliert, wie ein Ausdruck
     von den arithmetischen Operatoren '"+"', '"*"', '"^"', '"."' und
     '"^^"' behandelt wird, wenn Maxima nicht ermitteln kann, ob der
     Ausdruck ein Skalar oder Nicht-Skalar ist.  'assumescalar' hat drei
     mögliche Werte:

     'false'
          Unbekannte Ausdrücke werden als ein Nicht-Skalar behandelt.

     'true'
          Unbekannte Ausdrücke werden als ein Skalar für die
          kommutativen arithmetischen Operatoren '"+"', '"*"' und '"^"'
          behandelt.

     'all'
          Unbekannte Ausdrücke werden für alle arithmetischen Operatoren
          als ein Skalar behandelt.

     Es ist besser Variablen als ein Skalar oder Nicht-Skalar mit der
     Funktion 'declare' zu deklarieren, anstatt die Vereinfachung mit
     der Optionsvariablen 'assumescalar' zu kontrollieren.  Siehe auch
     die Eigenschaften 'scalar' und 'nonscalar' sowie die Funktionen
     'scalarp' und 'nonscalarp'.

     Beispiele:

     Maxima kann nicht ermitteln, ob das Symbol 'x' ein Skalar oder ein
     Nicht-Skalar ist.

          (%i1) scalarp(x);
          (%o1)                         false
          (%i2) nonscalarp(x);
          (%o2)                         false

     Hat 'assumescalar' den Wert 'true', behandelt Maxima das Symbol 'x'
     als einen Skalar für die kommutative Multiplikation.

          (%i3) x * [a,b,c], assumescalar:false;
          (%o3)                      x [a, b, c]
          (%i4) x * [a,b,c], assumescalar:true;
          (%o4)                    [a x, b x, c x]

     Für die nicht kommutative Multiplikation behandelt Maxima das
     Symbol 'x' dann als einen Skalar, wenn 'assumescalar' den Wert
     'all' hat.

          (%i5) x . [a,b,c], assumescalar:false;
          (%o5)                     x . [a, b, c]
          (%i6) x . [a,b,c], assumescalar:true;
          (%o6)                     x . [a, b, c]
          (%i7) x . [a,b,c], assumescalar:all;
          (%o7)                 [x . a, x . b, x . c]

 -- Optionsvariable: assume_pos
     Standardwert: 'false'

     Die Optionsvariable 'assume_pos' kontrolliert das Ergebnis der
     Funktionen 'sign' und 'asksign', für den Fall, dass Maxima das
     Vorzeichen einer Variablen oder indizierten Variablen nicht aus den
     aktiven Kontexten ermitteln kann.  Hat 'assume_pos' den Wert
     'true', dann wird für Variable oder indizierte Variable, immer das
     Ergebnis 'pos' ermittelt, wenn die Optionsvariable
     'assume_pos_pred' den Standardwert 'false' hat und das Vorzeichen
     nicht aus den aktiven Kontexten ermittelt werden kann.

     Die Optionsvariable 'assume_pos_pred' hat den Standardwert 'false'.
     In diesem Fall werden von Maxima Variablen und indizierte Variablen
     als positiv angenommen, wenn 'assume_pos' den Wert 'true' hat.  Der
     Optionsvariablen 'assume_pos_pred' kann eine Aussagefunktion mit
     einem Argument zugewiesen werden.  Hat die Aussagefunktion für ein
     Argument <expr> das Ergebnis 'true', wird das Argument als positiv
     angenommen, wenn die Optionsvariable 'assume_pos' den Wert 'true'
     hat und Maxima das Vorzeichen nicht aus den aktiven Kontexten
     ermitteln kann.

     Die Funktionen 'sign' und 'asksign' versuchen das Vorzeichen eines
     Ausdrucks anhand der Vorzeichen der Argumente zu ermitteln.  Sind
     zum Beispiel 'a' und 'b' beide positiv, dann wird für den Ausdruck
     'a+b' ein positives Vorzeichen ermittelt.  Auch wenn die Vorzeichen
     der Variablen 'a' und 'b' nicht bekannt sind, hat daher
     'asksign(a+b)' das Ergebnis 'pos', wenn 'assume_pos' den Wert
     'true' hat, da in diesem Fall die Variablen als positiv angenommen
     werden.

     Es gibt jedoch keine Möglichkeit, alle Ausdrücke grundsätzlich als
     positiv zu erklären.  Selbst wenn der Optionsvariablen
     'assume_pos_pred' eine Aussagefunktion zugewiesen wird, die alle
     Ausdrücke als positiv erklärt, werden Differenzen 'a-b' oder das
     Vorzeichen der Logarithmusfunktion 'log(a)' nicht als positiv
     ermittelt.  Die Fragen der Funktion 'asksign' an den Nutzer können
     daher nie vollständig mit dem Mechanismus der Optionsvariablen
     'assume_pos' unterdrückt werden.

     Siehe für weitere Beispiele die Optionsvariable 'assume_pos_pred'.

     Beispiele:

     Das Vorzeichen der Variablen 'x' ist nicht bekannt.  Erhält die
     Optionsvariable 'assume_pos' den Wert 'true', wird für die Variable
     'x' und die indizierte Variable 'x[1]' ein positives Vorzeichen
     ermittelt.

          (%i1) sign(x);
          (%o1)                          pnz
          (%i2) assume_pos:true;
          (%o2)                         true
          (%i3) sign(x);
          (%o3)                          pos
          (%i4) sign(x[1]);
          (%o4)                          pos

     Die Vorzeichen der Variablen 'a' und 'b' sind nicht bekannt.
     Maxima ermittelt ein positives Vorzeichen für die Summe der
     Variablen.  Das Vorzeichen der Differenz ist dagegen weiterhin
     nicht bekannt.

          (%i5) sign(a+b);
          (%o5)                          pos
          (%i6) sign(a-b);
          (%o6)                          pnz

 -- Optionsvariable: assume_pos_pred
     Standardwert: 'false'

     Der Optionsvariablen 'assume_pos_pred' kann eine Aussagefunktion
     wie zum Beispiel 'symbolp' oder ein Lambda-Ausdruck mit einem
     Argument 'x' zugewiesen werden.  Hat die Optionsvariable
     'assume_pos' den Wert 'true', werden Variablen, indizierte
     Variablen oder die Werte von Funktionen dann als positiv
     angenommen, wenn die Aussagefunktion das Ergebnis 'true' hat.

     Die Aussagefunktion wird intern von den Funktionen 'sign' und
     'asksign' aufgerufen, wenn die Optionsvariable 'assume_pos' den
     Wert 'true' hat und das Vorzeichen einer Variablen, indizierten
     Variablen oder für den Wert einer Funktion nicht ermittelt werden
     konnte.  Gibt die Aussagefunktion das Ergebnis 'true' zurück, wird
     das Argument als positiv angenommen.

     Hat die Optionsvariable 'assume_pos_pred' den Standardwert 'false'
     werden Variablen und indizierte Variablen von Maxima als positiv
     angenommen, wenn die Optionsvariable 'assume_pos' den Wert 'true'
     hat.  Das entspricht einer Aussagefunktion, die als 'lambda([x],
     symbolp(x) or subvarp(x))' definiert wird.

     Siehe auch 'assume' und 'assume_pos'.

     Beispiele:

     Der Optionsvariablen 'assume_pos_pred' wird der Name der
     Aussagefunktion 'symbolp' zugewiesen.  Indizierte Variablen werden
     nun nicht mehr als positiv angenommen, wie es für den Standartwert
     'false' gilt.

          (%i1) assume_pos: true$
          (%i2) assume_pos_pred: symbolp$
          (%i3) sign (a);
          (%o3)                          pos
          (%i4) sign (a[1]);
          (%o4)                          pnz

     Der Optionsvariablen 'assume_pos_pred' wird ein Lambda-Ausdruck
     zugewiesen, der für alle Argumente das Ergebnis 'true' hat.  Die
     Funktion 'sign' ermittelt nun für Variablen, indizierte Variablen
     und den Werten von Funktionen ein positives Vorzeichen.  Dies
     trifft jedoch nicht für die Logarithmusfunktion oder eine Differenz
     zu.

          (%i1) assume_pos: true$
          (%i2) assume_pos_pred: lambda([x], true);
          (%o2)                   lambda([x], true)
          (%i3) sign(a);
          (%o3)                          pos
          (%i4) sign(a[1]);
          (%o4)                          pos
          (%i5) sign(foo(x));
          (%o5)                          pos
          (%i6) sign(foo(x)+foo(y));
          (%o6)                          pos
          (%i7) sign(log(x));
          (%o7)                          pnz
          (%i8) sign(x-y);
          (%o8)                          pnz

 -- Optionsvariable: context
     Standardwert: 'initial'

     Die Optionsvariable 'context' enthält den Namen des aktuellen
     Kontextes.  Das ist der Kontext, der die Aussagen der Funktion
     'assume' oder die mit der Funktion 'declare' definierten
     Eigenschaften aufnimmt und aus dem die Aussagen mit der Funktion
     'forget' oder die Eigenschaften mit der Funktion 'remove' gelöscht
     werden.

     Wird der Optionsvariablen 'context' der Name eines existierenden
     Kontextes zugewiesen, wird dieser zum aktuellen Kontext.  Existiert
     der Kontext noch nicht, wird er durch Aufruf der Funktion
     'newcontext' erzeugt.

     Siehe auch 'contexts' für eine allgemeinere Beschreibung von
     Kontexten.

     Beispiele:

     Der Standardkontext ist 'initial'.  Es wird ein neuer Kontext
     'mycontext' generiert, der die Aussagen und Eigenschaften aufnimmt.

          (%i1) context;
          (%o1)                        initial
          (%i2) context:mycontext;
          (%o2)                       mycontext
          (%i3) contexts;
          (%o3)             [mycontext, initial, global]
          (%i4) assume(a>0);
          (%o4)                        [a > 0]
          (%i5) declare(b,integer);
          (%o5)                         done
          (%i6) facts(mycontext);
          (%o6)               [a > 0, kind(b, integer)]

 -- Systemvariable: contexts
     Standardwert: '[initial, global]'

     Die Systemvariable 'contexts' enthält eine Liste der Kontexte, die
     Maxima bekannt sind.  Die Liste enthält auch die nicht aktiven
     Kontexte.

     Die Kontexte 'global' und 'initial' sind immer vorhanden.  Diese
     werden von Maxima initialisiert und können nicht entfernt werden.
     Der Kontext 'global' enthält Aussagen und Fakten für
     Systemvariablen und Systemfunktionen.  Mit den Funktionen
     'newcontext' oder 'supcontext' kann der Nutzer weitere Kontexte
     anlegen.

     Die Kontexte haben eine Hierarchie.  Die Wurzel ist immer der
     Kontext 'global', der damit ein Unterkontext aller anderen Kontexte
     und immer aktiv ist.  Der Kontext 'initial' ist anfangs leer und
     nimmt, sofern kein weiterer Kontext angelegt wurde, die Aussagen
     und Fakten des Nutzers auf, die mit den Funktionen 'assume' und
     'declare' definiert werden.  Mit der Funktion 'facts' können die
     Aussagen und Fakten von Kontexten angezeigt werden.

     Die Verwaltung verschiedener Kontexte ermöglicht es, Aussagen und
     Fakten in einem Kontext zusammenzustellen.  Durch das Aktivieren
     mit der Funktion 'activate' oder Deaktivieren mit der Funktion
     'deactivate' können diese Aussagen und Fakten für Maxima verfügbar
     gemacht oder wieder ausgeschaltet werden.

     Die Aussagen und Fakten in einem Kontext bleiben so lange
     verfügbar, bis sie mit den Funktionen 'forget' oder 'remove'
     gelöscht werden.  Weiterhin kann der gesamte Kontext mit der
     Funktion 'killcontext' entfernt werden.

     Beispiel:

     Das folgende Beispiel zeigt wie ein Kontext 'mycontext' angelegt
     wird.  Der Kontext enthält die Aussage '[a>0]'.  Der Kontext kann
     mit der Funktion 'activate' aktiviert werden, um die Aussage
     verfügbar zu machen.

          (%i1) newcontext(mycontext);
          (%o1)                       mycontext
          (%i2) context;
          (%o2)                       mycontext
          (%i3) assume(a>0);
          (%o3)                        [a > 0]
          (%i4) context:initial;
          (%o4)                        initial
          (%i5) is(a>0);
          (%o5)                        unknown
          (%i6) activate(mycontext);
          (%o6)                         done
          (%i7) is(a>0);
          (%o7)                         true

 -- Funktion: deactivate (<context_1>, ..., <context_n>)

     Die Kontexte <context_1>, ..., <context_n> werden deaktiviert.  Die
     Aussagen und Fakten dieser Kontexte stehen für die Auswertung von
     Aussagen nicht mehr zur Verfügung.  Die Kontexte werden nicht
     gelöscht und können mit der Funktion 'activate' wieder aktiviert
     werden.

     Die deaktivierten Kontexte werden aus der Liste 'activecontexts'
     entfernt.

 -- Funktion: facts (<item>)
 -- Funktion: facts ()

     Ist <item> der Name eines Kontextes, gibt 'facts(<item>)' eine
     Liste der Aussagen und Fakten des Kontextes 'item' zurück.

     Ist <item> nicht der Name eines Kontextes, gibt 'facts(<item>)'
     eine Liste mit den Aussagen und Fakten zurück, die zu <item> im
     aktuellen Kontext bekannt sind.  Aussagen und Fakten die zu einem
     anderen aktiven Kontext gehören einschließlich der Unterkontexte,
     sind nicht in der Liste enthalten.

     'facts()' gibt eine Liste der Fakten des aktuellen Kontextes
     zurück.

     Beispiel:

          (%i1) context:mycontext;
          (%o1)                       mycontext
          (%i2) assume(a>0, a+b>0, x<0);
          (%o2)               [a > 0, b + a > 0, x < 0]
          (%i3) facts();
          (%o3)               [a > 0, b + a > 0, 0 > x]
          (%i4) facts(a);
          (%o4)                  [a > 0, b + a > 0]
          (%i5) facts(x);
          (%o5)                        [0 > x]
          (%i6) context:initial;
          (%o6)                        initial
          (%i7) activate(mycontext);
          (%o7)                         done
          (%i8) facts();
          (%o8)                          []
          (%i9) facts(mycontext);
          (%o9)               [a > 0, b + a > 0, 0 > x]

 -- Funktion: forget (<pred_1>, ..., <pred_n>)
 -- Funktion: forget (<L>)

     Entfernt Aussagen, die mit 'assume' einem Kontext hinzugefügt
     wurden.  Die Aussagen können Ausdrücke sein, die äquivalent aber
     nicht unbedingt identisch zu vorherigen Fakten sind.

     'forget(<L>)' entfernt alle Aussagen, die in der Liste <L>
     enthalten sind.

 -- Funktion: is (<expr>)

     Versucht festzustellen, ob die Aussage <expr> mit Hilfe der
     Aussagen und Fakten der aktiven Kontexte entschieden werden kann.

     Kann die Aussage <expr> zu 'true' oder 'false' entschieden werden,
     wird das entsprechende Ergebnis zurückgegeben.  Andernfalls wird
     der Rückgabewert durch den Schalter 'prederror' bestimmt.  Hat
     'prederror' den Wert 'true', wird eine Fehlermeldung ausgegeben.
     Ansonsten wird 'unknown' zurückgegeben.

     Siehe auch 'assume', 'facts' und 'maybe'.

     Beispiele:

     'is' wertet Aussagen aus.

          (%i1) %pi > %e;
          (%o1)                       %pi > %e
          (%i2) is (%pi > %e);
          (%o2)                         true

     'is' versucht Aussagen anhand der Aussagen und Fakten der aktiven
     Kontexte zu entscheiden.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) assume (b > c);
          (%o2)                        [b > c]
          (%i3) is (a < b);
          (%o3)                         false
          (%i4) is (a > c);
          (%o4)                         true
          (%i5) is (equal (a, c));
          (%o5)                         false

     Wenn 'is' eine Aussage anhand der Aussagen und Fakten der aktiven
     Kontexte nicht entscheiden kann, wird der Rückgabewert vom Wert des
     Schalters 'prederror' bestimmt.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) prederror: true$
          (%i3) is (a > 0);
          Maxima was unable to evaluate the predicate:
          a > 0
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) prederror: false$
          (%i5) is (a > 0);
          (%o5)                        unknown

 -- Funktion: killcontext (<context_1>, ..., <context_n>)

     Das Kommando 'killcontext(<context>)' löscht den Kontext <context>.

     Ist einer der Kontexte der aktuelle Kontext, wird der erste
     vorhandene Unterkontext zum aktuellen Kontext.  Ist der erste
     verfügbare Kontext der Kontext 'global', dann wird der Kontext
     'initial' zum aktuellen Kontext.  Wird der Kontext 'initial'
     gelöscht, dann wird eine neuer leerer Kontext 'initial' erzeugt.

     'killcontext' löscht einen Kontext nicht, wenn dieser ein
     Unterkontext des aktuellen Kontextes ist oder wenn der Kontext mit
     der Funktion 'activate' aktiviert wurde.

     'killcontext' wertet die Argumente aus.  'killcontext' gibt 'done'
     zurück.

 -- Funktion: maybe (<expr>)

     Versucht festzustellen, ob die Aussage <expr> anhand der Aussagen
     und Fakten der aktive Kontexte entschieden werden kann.

     Kann die Aussage als 'true' oder 'false' entschieden werden, gibt
     'maybe' entsprechend 'true' oder 'false' zurück.  Andernfalls gibt
     'maybe' den Wert 'unknown' zurück.

     'maybe' entspricht der Funktion 'is' mit 'prederror: false'.  Dabei
     wird 'maybe' ausgeführt, ohne dass 'prederror' einen Wert erhält.

     Siehe auch 'assume', 'facts' und 'is'.

     Beispiele:

          (%i1) maybe (x > 0);
          (%o1)                        unknown
          (%i2) assume (x > 1);
          (%o2)                        [x > 1]
          (%i3) maybe (x > 0);
          (%o3)                         true

 -- Funktion: newcontext (<name>)

     'newcontext(<name>)' erzeugt einen neuen, leeren Kontext mit dem
     Namen <name>.  Der neue Kontext hat den Kontext 'global' als
     Subkontext und wird zum aktuellen Kontext.

     'newcontext' wertet seine Argumente aus.  'newcontext' gibt 'name'
     zurück.

 -- Optionsvariable: prederror
     Standardwert: 'false'

     Hat 'prederror' den Wert 'true', wird eine Fehlermeldung
     ausgegeben, wenn eine Aussage mit einer 'if'-Anweisung oder der
     Funktion 'is' nicht zu 'true' oder 'false' ausgewertet werden kann.

     Hat 'prederror' den Wert 'false', wird für diese Fälle 'unknown'
     zurückgegeben.

     Siehe auch 'is' und 'maybe'.

 -- Funktion: sign (<expr>)

     Versucht das Vorzeichen des Ausdrucks <expr> auf Grundlage der
     Fakten der aktuellen Datenbank zu finden.  'sign' gibt eine der
     folgende Antworten zurück: 'pos' (positiv), 'neg' (negative),
     'zero' (null), 'pz' (positive oder null), 'nz' (negative oder
     null), 'pn' (positiv oder negative) oder 'pnz' (positiv, negative
     oder null, für den Fall das Vorzeichen nicht bekannt ist).

 -- Funktion: supcontext (<name>, <context>)
 -- FunKtion: supcontext (<name>)

     Erzeugt einen neuen Kontext, mit dem Namen 'name', der den Kontext
     'context' als einen Unterkontext enthält.  Der Kontext <context>
     muss existieren.

     Wird <context> nicht angegeben, wird der aktuelle Kontext
     angenommen.


File: maxima.info,  Node: Funktionen und Variablen für Aussagen,  Prev: Funktionen und Variablen für Fakten,  Up: Maximas Datenbank

11.4 Funktionen und Variablen für Aussagen
==========================================

 -- Funktion: charfun (<p>)

     Gibt den Wert 0 zurück, wenn die Aussage <p> zu 'false' ausgewertet
     werden kann und den Wert 1, wenn die Auswertung 'true' liefert.
     Kann die Aussage weder zu 'false' oder 'true' ausgewertet werden,
     wird eine Substantiv-Form zurück gegeben.

     Beispiele:

          (%i1) charfun (x < 1);
          (%o1)                    charfun(x < 1)
          (%i2) subst (x = -1, %);
          (%o2)                           1
          (%i3) e : charfun ('"and" (-1 < x, x < 1))$
          (%i4) [subst (x = -1, e), subst (x = 0, e), subst (x = 1, e)];
          (%o4)                       [0, 1, 0]

 -- Funktion: compare (<x>, <y>)

     Liefert den Vergleichsoperator <op> ('<', '<=', '>', '>=', '=' oder
     '#'), so dass der Ausdruck 'is(<x> <op> <y>)' zu 'true' ausgewertet
     werden kann.  Ist eines der Argumente eine komplexe Zahl, dann wird
     'notcomparable' zurückgegeben.  Kann Maxima keinen
     Vergleichsoperator bestimmen, wird 'unknown' zurückgegeben.

     Beispiele:

          (%i1) compare (1, 2);
          (%o1)                           <
          (%i2) compare (1, x);
          (%o2)                        unknown
          (%i3) compare (%i, %i);
          (%o3)                           =
          (%i4) compare (%i, %i + 1);
          (%o4)                     notcomparable
          (%i5) compare (1/x, 0);
          (%o5)                           #
          (%i6) compare (x, abs(x));
          (%o6)                          <=

     Die Funktion 'compare' versucht nicht festzustellen, ob der
     Wertebereich einer Funktion reelle Zahlen enthält.  Obwohl der
     Wertebereich von 'acos(x^2+1)' bis auf Null keine reellen Zahlen
     enthält, gibt 'compare' das folgende Ergebnis zurück:

          (%i1) compare (acos (x^2 + 1), acos (x^2 + 1) + 1);
          (%o1)                           <

 -- Funktion: equal (<a>, <b>)

     Repräsentiert die Äquivalenz, das heißt den gleichen Wert.

     'equal' wird nicht ausgewertet oder vereinfacht.  Die Funktion 'is'
     versucht einen Ausdruck mit 'equal' zu einem booleschen Wert
     auszuwerten.  'is(equal(<a>, <b>))' gibt 'true' oder 'false'
     zurück, wenn und nur wenn <a> und <b> gleich oder ungleich sind für
     alle Werte ihrer Variablen, was mit 'ratsimp(<a> - <b>)' bestimmt
     wird.  Gibt 'ratsimp' das Ergebnis 0 zurück, werden die beiden
     Ausdrücke als äquivalent betracht.  Zwei Ausdrücke können
     äquivalent sein, obwohl sie nicht syntaktisch gleich (im
     allgemeinen identisch) sind.

     Kann 'is' einen Ausdruck mit 'equal' nicht zu 'true' oder 'false'
     auswerten, hängt das Ergebnis vom Wert des globalen Flags
     'prederror' ab.  Hat 'prederror' den Wert 'true', gibt 'is' eine
     Fehlermeldung zurück.  Ansonsten wird 'unknown' zurückgegeben.

     Es gibt weitere Operatoren, die einen Ausdruck mit 'equal' zu
     'true' oder 'false' auswerten können.  Dazu gehören 'if', 'and',
     'or' und 'not'.

     Die Umkehrung von 'equal' ist 'notequal'.

     Beispiele:

     'equal' wird von allein weder ausgewertet noch vereinfacht:

          (%i1) equal (x^2 - 1, (x + 1) * (x - 1));
                                  2
          (%o1)            equal(x  - 1, (x - 1) (x + 1))
          (%i2) equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) equal (x, y);
          (%o3)                      equal(x, y)

     Die Funktion 'is' versucht, 'equal' zu einem booleschen Wert
     auszuwerten.  Der Ausdruck 'is(equal(<a>, <b>))' gibt den Wert
     'true' zurück, when 'ratsimp(<a> - <b>)' den Wert 0 hat.  Zwei
     Ausdrücke können äquivalent sein, obwohl sie nicht syntaktisch
     gleich sind.

          (%i1) ratsimp (x^2 - 1 - (x + 1) * (x - 1));
          (%o1)                           0
          (%i2) is (equal (x^2 - 1, (x + 1) * (x - 1)));
          (%o2)                         true
          (%i3) is (x^2 - 1 = (x + 1) * (x - 1));
          (%o3)                         false
          (%i4) ratsimp (x - (x + 1));
          (%o4)                          - 1
          (%i5) is (equal (x, x + 1));
          (%o5)                         false
          (%i6) is (x = x + 1);
          (%o6)                         false
          (%i7) ratsimp (x - y);
          (%o7)                         x - y
          (%i8) is (equal (x, y));
          (%o8)                        unknown
          (%i9) is (x = y);
          (%o9)                         false

     Kann 'is' einen Ausdruck mit 'equal' nicht zu 'true' oder 'false'
     vereinfachen, hängt das Ergebnis vom Wert des globalen Flags
     'prederror' ab.

          (%i1) [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
                              2             2
          (%o1)             [x  + 2 x + 1, x  - 2 x - 1]
          (%i2) ratsimp (aa - bb);
          (%o2)                        4 x + 2
          (%i3) prederror : true;
          (%o3)                         true
          (%i4) is (equal (aa, bb));
          Maxima was unable to evaluate the predicate:
                 2             2
          equal(x  + 2 x + 1, x  - 2 x - 1)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) prederror : false;
          (%o5)                         false
          (%i6) is (equal (aa, bb));
          (%o6)                        unknown

     Einige weitere Operatoren werten 'equal' und 'notequal' zu einem
     booleschen Wert aus.

          (%i1) if equal (y, y - 1) then FOO else BAR;
          (%o1)                          BAR
          (%i2) eq_1 : equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
                                   2                   2
          (%o3)             equal(y  + 2 y + 1, (y + 1) )
          (%i4) [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
          (%o4)                  [false, true, true]

     Da 'not <expr>' den Ausdruck <expr> auswertet, ist 'not equal(<a>,
     <b>)' äquivalent zu 'is(notequal(<a>, <b>))'

          (%i1) [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
          (%o1)            [notequal(2 z, 2 z - 1), true]
          (%i2) is (notequal (2*z, 2*z - 1));
          (%o2)                         true

 -- Funktion: notequal (<a>, <b>)

     Repräsentiert die Verneinung von 'equal(<a>, <b>)'.

     Beispiele:

          (%i1) equal (a, b);
          (%o1)                      equal(a, b)
          (%i2) maybe (equal (a, b));
          (%o2)                        unknown
          (%i3) notequal (a, b);
          (%o3)                    notequal(a, b)
          (%i4) not equal (a, b);
          (%o4)                    notequal(a, b)
          (%i5) maybe (notequal (a, b));
          (%o5)                        unknown
          (%i6) assume (a > b);
          (%o6)                        [a > b]
          (%i7) equal (a, b);
          (%o7)                      equal(a, b)
          (%i8) maybe (equal (a, b));
          (%o8)                         false
          (%i9) notequal (a, b);
          (%o9)                    notequal(a, b)
          (%i10) maybe (notequal (a, b));
          (%o10)                        true

 -- Funktion: unknown (<expr>)

     Gibt den Wert 'true' zurück, wenn der Ausdruck <expr> einen
     Operator oder eine Funktion enthält, die nicht von Maximas
     Vereinfacher erkannt wird.

 -- Funktion: zeroequiv (<expr>, <v>)

     Testet, ob ein Ausdruck <expr> mit der Variablen <v> äquivalent zu
     Null ist.  Die Funktion gibt 'true', 'false' oder 'dontknow'
     zurück.

     'zeroequiv' hat Einschränkungen:

       1. Funktionen im Ausdruck <expr> müssen von Maxima
          differenzierbar und auswertbar sein.

       2. Hat der Ausdruck Pole auf der reellen Achse, können Fehler
          auftreten.

       3. Enthält der Ausdruck Funktionen, die nicht Lösung einer
          Differentialgleichung erster Ordnung sind (zum Beispiel Bessel
          Funktionen), können die Ergebnisse fehlerhaft sein.

       4. Der Algorithmus wertet die Funktion an zufällig Punkten für
          ausgewählte Teilausdrücke aus.  Dies ist ein riskantes
          Verfahren und kann zu Fehlern führen.

     'zeroequiv(sin(2*x) - 2*sin(x)*cos(x), x)' hat zum Beispiel das
     Ergebnis 'true' und 'zeroequiv (%e^x + x, x)' hat das Ergebnis
     'false'.  Andererseits hat 'zeroequiv (log(a*b) - log(a) - log(b),
     a)' das Ergebnis 'dontknow', wegen dem zusätzlichem Parameter 'b'.


File: maxima.info,  Node: Grafische Darstellung,  Next: Eingabe und Ausgabe,  Prev: Maximas Datenbank,  Up: Top

12 Grafische Darstellung
************************

* Menu:

* Einführung in die grafische Darstellung::
* Grafikformate::
* Funktionen und Variablen für die grafische Darstellung::
* Grafikoptionen::
* Gnuplot Optionen::
* Gnuplot_pipes Formatfunktionen::


File: maxima.info,  Node: Einführung in die grafische Darstellung,  Next: Grafikformate,  Prev: Grafische Darstellung,  Up: Grafische Darstellung

12.1 Einführung in die grafische Darstellung
============================================

Maxima verwendet externe Grafikprogramme, um grafische Darstellungen
auszugeben.  Die Grafikfunktionen berechnen die Punkte der Grafik und
senden diese mit einem Satz an Kommandos an das externe Grafikprogramm.
Die Daten werden als Datenstrom über eine Pipe oder als eine Datei an
das Grafikprogramm übergeben.  Die Datei erhält den Namen
'maxout.interface', wobei 'interface' der Name des externen
Grafikprogramms ist.  Die möglichen Dateiendungen sind: 'gnuplot',
'xmaxima', 'mgnuplot', 'gnuplot_pipes' oder 'geomview'.

Die Datei 'maxout.interface' wird in dem Verzeichnis gespeichert, das
durch die Systemvariable 'maxima_tempdir' bezeichnet wird.

Die Datei 'maxout.interface' kann wiederholt an das Grafikprogramm
übergeben werden.  Gibt Maxima keine Grafik aus, kann diese Datei
geprüft werden, um mögliche Fehler festzustellen.

Das Paket 'draw' ist eine Alternative, um Funktionsgraphen und eine
Vielzahl anderer Graphen zu erstellen.  Das Paket 'draw' hat einen
größeren Umfang an Funktionalitäten und ist flexibler, wenn der Graph
besondere Formatierungen enthalten soll.  Einige Grafikoptionen sind in
beiden beiden Grafikpaketen vorhanden, können sich aber in der Syntax
unterscheiden.  Mit dem Kommando '? opt', wobei 'opt' eine Grafikoption
ist, wird möglicherweise nur die Dokumentation der
Standard-Grafikroutinen angezeigt.  Um auch die entsprechende
Grafikoption des Paketes 'draw' zu sehen, kann '?? opt' auf der
Kommandozeile eingegeben werden.  Siehe *note draw::.


File: maxima.info,  Node: Grafikformate,  Next: Funktionen und Variablen für die grafische Darstellung,  Prev: Einführung in die grafische Darstellung,  Up: Grafische Darstellung

12.2 Grafikformate
==================

Maxima verwendet für die Ausgabe von Grafiken die Grafikprogramme
Gnuplot, Xmaxima oder Geomview.  Mit der Grafikoption 'plot_format'
können verschiedene Grafikformate für diese Programme ausgewählt werden.
Die Grafikformate sind:

   * *gnuplot* (Standard für Windows)

     Startet das externe Programm Gnuplot.  Gnuplot muss installiert
     sein.  Die Grafikkommandos und Daten werden in die Datei
     'maxout.gnuplot' gespeichert.

   * *gnuplot_pipes* (Standard, wenn nicht Windows)

     Dieses Format ist für Windows nicht verfügbar.  Es ist ähnlich dem
     Format 'gnuplot', mit der Ausnahme, dass die Grafikkommandos als
     Datenstrom über eine Pipe an Gnuplot gesendet werden, während die
     Daten in der Datei 'maxout.gnuplot_pipes' gespeichert werden.  Es
     wird nur eine Instanz von Gnuplot gestartet.  Aufeinander folgende
     Grafikkommandos werden an ein bereits geöffnetes Gnuplot-Programm
     gesendet.  Gnuplot wird mit der Funktion 'gnuplot_close'
     geschlossen.  In diesem Grafikformat kann die Funktion
     'gnuplot_replot' genutzt werden, um eine Grafik zu modifizieren,
     die bereits auf dem Bildschirm ausgegeben wurde.

     Dieses Grafikformat sollte nur für die Ausgabe von Grafiken auf den
     Bildschirm verwendet werden.  Für die Ausgabe von Grafiken in eine
     Datei ist das Grafikformat 'gnuplot' besser geeignet.

   * *mgnuplot*

     Mgnuplot ist eine Tcl/Tk-Anwendung, die Gnuplot für die Ausgabe von
     Grafiken nutzt.  Die Anwendung ist in der Maxima-Distribution
     enthalten.  Mgnuplot bietet eine rudimentäre GUI für Gnuplot, hat
     aber weniger Fähigkeiten als Gnuplot.  Mgnuplot benötigt die
     Installation von Gnuplot und Tcl/Tk.

   * *xmaxima*

     Xmaxima ist eine auf Tcl/Tk basierende grafische Nutzeroberfläche,
     die von der Maxima-Konsole gestartet werden kann.  Um dieses
     Grafikformat zu nutzen, muss Xmaxima installiert sein, das in der
     Distribution von Maxima enthalten ist.  Wird Maxima aus Xmaxima
     gestartet, werden die Grafikkommandos und Daten über denselben
     Socket gesendet, der auch für die Kommunikation zwischen Xmaxima
     und Maxima geöffnet wird.  Wird das Grafikformat von einer Konsole
     oder einer anderen Nutzeroberfläche gestartet, werden die
     Grafikkommandos und Daten in die Datei 'maxout.xmaxima'
     gespeichert.  Diese Datei wird an Xmaxima für die Ausgabe der
     Grafik übergeben.

     In früheren Versionen wurde dieses Grafikformat 'openmath' genannt.
     Dieser Name wird weiterhin als ein Synonym für 'xmaxima'
     akzeptiert.

   * *geomview*

     Geomview ist ein - auf Motif basierendes - interaktives 3D Programm
     für Unix, das auch verwendet werden kann, um Plots von Maxima
     anzuzeigen.  Um dieses Format zu verwenden muss das Programm
     geomview installiert sein.


File: maxima.info,  Node: Funktionen und Variablen für die grafische Darstellung,  Next: Grafikoptionen,  Prev: Grafikformate,  Up: Grafische Darstellung

12.3 Funktionen und Variablen für die grafische Darstellung
===========================================================

 -- Funktion: contour_plot (<expr>, <x_range>, <y_range>, <options>,
          ...)

     Zeichnet einen Konturgraphen (die Isolinien einer Funktion) von
     <expr> im Bereich <x_range> und <y_range> mit den Optionen
     <options>.  <expr> ist ein Ausdruck oder der Name einer Funktion
     'f(x,y)' mit zwei Argumenten.  Alle weiteren Argumente entsprechen
     denen der Funktion 'plot3d'.

     Die Funktion steht nur für die Grafikformate 'gnuplot' und
     'gnuplot_pipes' zur Verfügung.  Das Paket 'implicit_plot' enthält
     die Funktion 'implicit_plot' mit der für alle Grafikformate
     Konturgraphen erstellt werden können.

     Beispiele:

          (%i1) contour_plot(x^2 + y^2, [x, -4, 4], [y, -4, 4])$

     Es kann jede Option genutzt werden, die von der Funktion 'plot3d'
     akzeptiert wird.  Standardmäßig zeichnet Gnuplot den Graphen mit 3
     Isolinien.  Die Anzahl der Isolinien kann mit der Gnuplot-Option
     'gnuplot_preamble' erhöht werden.  In diesem Beispiel werden 12
     Isolinien gezeichnet und die Legende ist entfernt.

          (%i1) contour_plot (u^3 + v^2, [u, -4, 4], [v, -4, 4],
                        [legend,false],
                        [gnuplot_preamble, "set cntrparam levels 12"])$

 -- Funktion: get_plot_option (<keyword>, <index>)

     Gibt die Werte der Parameter der Option mit dem Namen <keyword>
     zurück.  Die Optionen und ihre Parameter sind in der Variablen
     'plot_options' gespeichert.  Hat <index> den Wert 1 wird der Name
     der Option <keyword> zurückgeben.  Der Wert 2 für <index> gibt den
     Wert des ersten Parameters zurück, und so weiter.

     Siehe auch 'plot_options', 'set_plot_option' und das Kapitel
     Grafikoptionen.

     Beispiel:

          (%i1) get_plot_option(color,1);
          (%o1)                         color
          (%i2) get_plot_option(color,2);
          (%o2)                         blue
          (%i3) get_plot_option(color,3);
          (%o3)                          red

 -- Funktion: implicit_plot (<expr>, <x_range>, <y_range>)
 -- Funktion: implicit_plot ([<expr_1>, ..., <expr_n>], <x_range>,
          <y_range>)

     Zeichnet den Graphen eines oder mehrerer Ausdrücke, die implizit
     gegeben sind.  <expr> ist der Ausdruck der gezeichnet werden soll,
     <x_range> ist der Wertebereich der x-Achse und <y_range> der
     Wertebereich der y-Achse.  Die Funktion 'implicit_plot' beachtet
     die Werte der Parameter der Grafikoptionen, die in der
     Systemvariablen 'plot_options' enthalten sind.  Grafikoptionen
     können auch als Argumente übergeben werden.

     Der Algorithmus von 'implicit_plot' stellt Vorzeichenwechsel der
     Funktion in den Bereichen <x_range> und <y_range> fest.  Für
     komplizierte Flächen kann der Algorithmus versagen.

     Die Funktion wird mit dem Kommando 'load(implicit_plot)' geladen.

     Beispiel:

          (%i1) load(implicit_plot)$
          (%i2) implicit_plot (x^2 = y^3 - 3*y + 1, [x, -4, 4], [y, -4, 4])$

 -- Funktion: make_transform ([<var1>, <var2>, <var3>], <fx>, <fy>,
          <fz>)

     Gibt eine Funktion zurück, die als Parameter für die Grafikoption
     'transform_xy' geeignet ist.  Die zwei Argumente <var1> und <var2>
     repräsentieren die zwei unabhängigen Variablen der Funktion
     'plot3d'.  Das dritte Argument <var3> ist die Funktion, die von den
     zwei Variablen abhängt.  Die drei Funktionen <fx>, <fy> und <fz>
     müssen von den drei Argumenten <var1>, <var2> und <var3> abhängen
     und die Argumente der Funktion 'plot3d' in kartesische Koordinaten
     für die Ausgabe des Graphen transformieren.

     Die Transformationen 'polar_to_xy' für die Transformation von
     Polarkoordinaten und 'spherical_to_xyz' für die Transformation von
     Kugelkoordinaten in kartesische Koordinaten sind bereits definiert.

     Beispiel:

     Definition der Transformation von Zylinderkoordinaten nach
     kartesischen Koordinaten.  Die Definition ist identisch mit der für
     'polar_to_xy'.  Der Graph zeigt einen Kegel.

          (%i1) cylinder_to_xy:make_transform([r,phi,z],r*cos(phi),
                                                        r*sin(phi),z)$
          (%i2) plot3d(-r,[r,0,3],[phi,0,2*%pi],
                                  [transform_xy, cylinder_to_xy])$

 -- Systemfunktion: polar_to_xy

     Kann als Parameter der Grafikoption 'transform_xy' der Funktion
     'plot3d' übergeben werden.  Der Parameter 'polar_to_xy' bewirkt,
     dass die zwei unabhängigen Variablen der Funktion 'plot3d' von
     Polarkoordinaten in kartesische Koordinaten transformiert werden.

     Für ein Beispiele siehe 'make_transform'.

 -- Funktion: plot2d (<plot>, <x_range>, ..., <options>, ...)
 -- Funktion: plot2d ([<plot_1>, ..., <plot_n>], ..., <options>, ...)
 -- Funktion: plot2d ([<plot_1>, ..., <plot_n>], <x_range>, ...,
          <options>, ...)

     <plot>, <plot_1>, ..., <plot_n> sind Ausdrücke, Namen von
     Funktionen oder Listen, mit denen diskrete Punkte oder Funktionen
     in einer parametrischen Darstellung angegeben werden.  Diskrete
     Punkte können als '[discrete, [<x1>, ..., <xn>], [<y1>, ...,
     <yn>]]' oder als '[discrete, [[<x1>, <y1>], ..., [<xn>, ...,
     <yn>]]' angegeben werden.  Eine parametrische Darstellung hat die
     Form '[parametric, <x_expr>, <y_expr>, <t_range>]'.

     Die Funktion 'plot2d' zeichnet einen zweidimensionalen Graphen
     einer oder mehrerer Ausdrücke als Funktion einer Variablen oder
     eines Parameters.  Mit der Grafikoption <x_range> wird der Name der
     unabhängigen Variablen und deren Bereich angegeben.  Die Syntax der
     Grafikoption <x_range> ist: '[<variable>, <min>, <max>]'.

     Ein diskreter Graph wird durch eine Liste definiert, die mit dem
     Schlüsselwort <disrecte> beginnt.  Es folgen ein oder zwei Listen
     mit den Werten.  Werden zwei Listen übergeben, müssen diese
     dieselbe Länge haben.  Die Daten der ersten Listen werden als die
     x-Koordinaten der Punkte und die der zweiten als die y-Koordinaten
     der Punkte interpretiert.  Wird nur eine Liste übergeben, sind die
     Elemente Listen mit je zwei Elementen, die die x- und y-Koordinaten
     der Punkte repräsentieren.

     Ein parametrischer Graph wird durch eine Liste definiert, die mit
     dem Schlüsselwort <parametric> beginnt.  Es folgen zwei Ausdrücke
     oder Namen von Funktionen und ein Parameter.  Der Bereich für den
     Parameter muss eine Liste sein, die den Namen des Parameters,
     seinen größten und seinen kleinsten Wert enthält: '[<parameter>,
     <min>, <max>]'.  Der Graph ist der Weg für die zwei Ausdrücke oder
     Namen von Funktionen, wenn der Parameter <parameter> von <min> nach
     <max> zunimmt.

     Als optionales Argument kann ein Wertebereich für die vertikale
     Koordinatenachse mit der Grafikoption 'y' angegeben werden: '[y,
     <min>, <max>]'.  Die vertikale Achse wird immer mit dem
     Schlüsselwort 'y' bezeichnet.  Wird kein Wertebereich 'y'
     angegeben, wird dieser durch den größten und kleinsten 'y'-Wert des
     zu zeichnenden Graphen festgelegt.

     Auch alle anderen Grafikoptionen werden als Listen angegeben, die
     mit einem Schlüsselwort beginnen, auf das die Parameter der
     Grafikoption folgen.  Siehe 'plot_options'.

     Werden mehrere Graphen gezeichnet, wird eine Legende hinzugefügt,
     die die einzelnen Graphen unterscheidet.  Mit der Grafikoption
     <legend> können die Bezeichnungen für die Legende festgelegt
     werden.  Wird diese Option nicht genutzt, generiert Maxima die
     Bezeichnungen der Legende aus den Ausdrücken oder Namen der
     Funktionen, die als Argument übergeben wurden.

     Siehe auch das Kapitel 'Grafikoptionen'.

     Beispiele:

     Graph einer einfachen Funktion.

          (%i1) plot2d (sin(x), [x, -%pi, %pi])$

     Wächst die Funktion sehr schnell, kann es notwendig sein, die Werte
     auf der vertikalen Achse mit der Grafikoption 'y' zu begrenzen.

          (%i1) plot2d (sec(x), [x, -2, 2], [y, -20, 20])$

     Die Ansicht eines Graphen kann sich für verschiedene
     Grafikprogramme unterscheiden.  In Xmaxima bewirkt die Grafikoption
     '[box, false]', das die Koordinatenachsen mit Pfeilen dargestellt
     werden.

          (%i1) plot2d ( x^2 - 1, [x, -3, 3], [box, false], grid2d,
                [yx_ratio, 1], [axes, solid], [xtics, -2, 4, 2],
                [ytics, 2, 2, 6], [label, ["x", 2.9, -0.3],
                ["x^2-1", 0.1, 8]], [title, "A parabola"])$

     Ein Graph mit einer logarithmischen Skala:

          (%i1) plot2d (exp(3*s), [s, -2, 2], logy)$

     Graphen von Funktionen, deren Namen als Argumente übergeben werden.

          (%i1) F(x) := x^2 $
          (%i2) :lisp (defun |$g| (x) (m* x x x))
          $g
          (%i2) H(x) := if x < 0 then x^4 - 1 else 1 - x^5 $
          (%i3) plot2d ([F, G, H], [u, -1, 1], [y, -1.5, 1.5])$

     Graph einer parametrisch definierten Schmetterlingskurve.

          (%i1) r: (exp(cos(t))-2*cos(4*t)-sin(t/12)^5)$
          (%i2) plot2d([parametric, r*sin(t), r*cos(t), [t, -8*%pi, 8*%pi]])$

     Graph der Funktion 'abs(x)' und eines parametrischen Kreises.  Das
     Seitenverhältnis der Grafik wurde mit den Grafikoptionen 'same_xy'.

          (%i1) plot2d([[parametric, cos(t), sin(t), [t,0,2*%pi]], -abs(x)],
                   [x, -sqrt(2), sqrt(2)], same_xy)$

     Graph für diskrete Punkte.  Die Punkte sind in zwei separaten
     Listen jeweils für die x- und y-Koordinaten angegeben.
     Standardmäßig werden die Punkte mit einer Linie verbunden.

          (%i1) plot2d ([discrete, makelist(i*%pi, i, 1, 5),
                                      [0.6, 0.9, 0.2, 1.3, 1]])$

     In diesem Beispiel wird eine Tabelle mit drei Spalten in eine Datei
     'data.txt' gespeichert.  Die Datei wird gelesen und die zweite und
     dritte Spalte werden gezeichnet.

          (%i1) with_stdout ("data.txt", for x:0 thru 10 do
                                       print (x, x^2, x^3))$
          (%i2) data: read_matrix ("data.txt")$
          (%i3) plot2d ([discrete, transpose(data)[2], transpose(data)[3]],
            [style,points], [point_type,diamond], [color,red])$

     Graph von experimentellen Datenpunkten zusammen mit einer
     theoretischen Funktion, die die Daten beschreibt.

          (%i1) xy: [[10, .6], [20, .9], [30, 1.1], [40, 1.3], [50, 1.4]]$
          (%i2) plot2d([[discrete, xy], 2*%pi*sqrt(l/980)], [l,0,50],
                  [style, points, lines], [color, red, blue],
                  [point_type, asterisk],
                  [legend, "experiment", "theory"],
                  [xlabel, "pendulum's length (cm)"],
                  [ylabel, "period (s)"])$

 -- Funktion: plot3d (<expr>, <x_range>, <y_range>, ..., <options>, ...)
 -- Funktion: plot3d ([<expr_1>, ..., <expr_n>], <x_range>, <y_range>,
          ..., <options>, ...)

     Zeichnet einen Graph mit einer oder mehreren Flächen, die als eine
     Funktion von zwei Variablen oder in parametrischer Form definiert
     sind.

     Die zu zeichnenden Funktionen werden als Ausdrücke oder mit ihrem
     Namen als Argumente übergeben.  Mit der Maus kann der Graph rotiert
     werden, um die Fläche aus verschiedenen Blickwinkeln zu betrachten.

     Siehe auch das Kapitel Grafikoptionen.

     Beispiele:

     Graph einer einfachen Funktion.

          (%i1) plot3d (u^2 - v^2, [u, -2, 2], [v, -3, 3], [grid, 100, 100],
                  [mesh_lines_color,false])$

     Mit der Grafikoption 'z' wird der Wertebereich der z-Achse
     begrenzt.  Dieses Beispiel zeigt den Graph ohne Färbung der Fläche.

          (%i1) plot3d ( log ( x^2*y^2 ), [x, -2, 2], [y, -2, 2], [z, -8, 4],
                         [palette, false], [color, magenta, blue])$

     Unendlich große Werte der z-Koordinate können auch durch Wahl eines
     Gitters vermieden werden, das nicht mit einer der Asymptoten
     zusammenfällt.  Das Beispiel zeigt zudem die Nutzung einer Palette.

          (%i1) plot3d (log (x^2*y^2), [x, -2, 2], [y, -2, 2],[grid, 29, 29],
                 [palette, [gradient, red, orange, yellow, green]],
                 color_bar, [xtics, 1], [ytics, 1], [ztics, 4],
                 [color_bar_tics, 4])$

     Graph mit zwei Flächen mit verschiedenen Wertebereichen.

          (%i1) plot3d ([[-3*x - y, [x, -2, 2], [y, -2, 2]],
             4*sin(3*(x^2 + y^2))/(x^2 + y^2), [x, -3, 3], [y, -3, 3]],
             [x, -4, 4], [y, -4, 4])$

     Graph der kleinschen Flasche, die parametrisch definiert ist.

          (%i1) expr_1: 5*cos(x)*(cos(x/2)*cos(y)+sin(x/2)*sin(2*y)+3)-10$
          (%i2) expr_2: -5*sin(x)*(cos(x/2)*cos(y)+sin(x/2)*sin(2*y)+3)$
          (%i3) expr_3: 5*(-sin(x/2)*cos(y)+cos(x/2)*sin(2*y))$
          (%i4) plot3d ([expr_1, expr_2, expr_3], [x, -%pi, %pi],
                  [y, -%pi, %pi], [grid, 50, 50])$

     Graph einer Kugelfunktion, die vordefinierte
     Koordinatentransformation 'spherical_to_xyz' wird verwendet, um von
     Kugelkoordinaten in ein kartesisches Koordinatensystem zu
     transformieren.

          (%i1) plot3d (sin(2*theta)*cos(phi), [theta, 0, %pi],
                  [phi, 0, 2*%pi],
                  [transform_xy, spherical_to_xyz], [grid,30,60],
             [legend,false])$

     Gebrauch der vordefinierten Funktion 'polar_to_xy', um von
     zylindrischen Koordinaten in ein kartesisches Koordinatensystem zu
     transformieren.  Siehe auch 'polar_to_xy'.  Dieses Beispiel zeigt
     auch wie der Rahmen und die Legende entfernt werden können.

          (%i1) plot3d (r^.33*cos(th/3), [r,0,1], [th,0,6*%pi], [box, false],
             [grid, 12, 80], [transform_xy, polar_to_xy], [legend, false])$

     Graph einer Kugel, wobei die Koordinatentransformation von
     Kugelkoordinaten in ein kartesisches Koordinatensystem genutzt
     wird.

          (%i1) plot3d ( 5, [theta, 0, %pi], [phi, 0, 2*%pi], same_xyz,
            [transform_xy, spherical_to_xyz], [mesh_lines_color,blue],
            [palette,[gradient,"#1b1b4e", "#8c8cf8"]], [legend, false])$

     Definition einer Funktion mit zwei Variablen als eine Matrix.  Der
     Quote-Operator ''' in der Definition der Funktion verhindert, das
     'plot3d' fehlschlägt, wenn die Argumente keine ganze Zahlen sind.

          (%i1) M: matrix([1,2,3,4], [1,2,3,2], [1,2,3,4], [1,2,3,3])$
          (%i2) f(x, y) := float('M [round(x), round(y)])$
          (%i3) plot3d (f(x,y), [x,1,4],[y,1,4],[grid,3,3],[legend,false])$

     Wird die Höhenangabe 'elevation' auf Null gesetzt, kann die Fläche
     als eine Karte betrachtet werden.  Jede Farbe repräsentiert einen
     anderen Wert der Fläche.

          (%i1) plot3d (cos (-x^2 + y^3/4), [x,-4,4], [y,-4,4], [zlabel,""],
                 [mesh_lines_color,false], [elevation,0], [azimuth,0],
                 color_bar, [grid,80,80], [ztics,false], [color_bar_tics,1])$

 -- Systemvariable: plot_options

     Die Elemente dieser Liste definieren die Standardwerte für die
     Ausgabe von Graphen.  Ist einer der Werte ein Argument der
     Funktionen 'plot2d' oder 'plot3d', wird der Standardwert
     überschrieben.  Die Standardwerte können mit der Funktion
     'set_plot_option' gesetzt werden.  Einige Grafikoptionen sind nicht
     in der Liste 'plot_options' enthalten.

     Jedes Element der Liste 'plot_options' ist eine Liste mit zwei oder
     mehr Einträgen.  Der erste Eintrag ist der Name der Grafikoption.
     Die weiteren Einträge sind die Parameter der Option.  In einigen
     Fällen kann der Parameter einer Option wiederum eine Liste sein.

     Siehe auch 'set_plot_option', 'get_plot_option' und das Kapitel
     Grafikoptionen.

 -- Funktion: set_plot_option (<option>)

     Akzeptiert die meisten der Optionen, die im Kapitel Grafikoptionen
     aufgelistet sind und speichert diese in der globalen Variable
     'plot_options'.  'set_plot_options' wertet die Argumente aus und
     gibt die vollständige Liste 'plot_optons' zurück.

     Siehe auch 'plot_options', 'get_plot_option' und das Kapitel
     Grafikoptionen.

     Beispiele:

     Setze einen neue Werte für die Grafikoption 'grid'.

          (%i1) set_plot_option ([grid, 30, 40]);
          (%o1) [[t, - 3, 3], [grid, 30, 40], [transform_xy, false],
          [run_viewer, true], [axes, true], [plot_format, gnuplot_pipes],
          [color, blue, red, green, magenta, black, cyan],
          [point_type, bullet, circle, plus, times, asterisk, box, square,
          triangle, delta, wedge, nabla, diamond, lozenge],
          [palette, [hue, 0.25, 0.7, 0.8, 0.5],
          [hue, 0.65, 0.8, 0.9, 0.55], [hue, 0.55, 0.8, 0.9, 0.4],
          [hue, 0.95, 0.7, 0.8, 0.5]], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 29], [adapt_depth, 5],
          [gnuplot_preamble, ], [gnuplot_default_term_command,
          set term pop], [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript \
          eps enhanced color solid 24], [plot_realpart, false]]

 -- Systemfunktion: spherical_to_xyz

     Kann als Parameter für die Option 'transform_xy' der Funktion
     'plot3d' übergeben werden.  Der Parameter 'spherical_to_xyz'
     bewirkt, dass die zwei unabhängigen Variablen und die Funktion beim
     Aufruf von 'plot3d' von Kugelkoordinaten in kartesische Koordinaten
     umgerechnet werden.


File: maxima.info,  Node: Grafikoptionen,  Next: Gnuplot Optionen,  Prev: Funktionen und Variablen für die grafische Darstellung,  Up: Grafische Darstellung

12.4 Grafikoptionen
===================

Die Grafikoptionen bestehen aus einer Liste, die mit einem Schlüsselwort
beginnt und ein oder mehrere Parameter enthält.  Die meisten Optionen
können mit den Funktionen 'plot2d', 'plot3d', 'contour_plot' oder
'implicit_plot' genutzt und mit der Funktion 'set_plot_option' gesetzt
werden.  Auf Ausnahmen wird im Folgenden hingewiesen.

 -- Grafikoption: adapt_depth [adapt_depth, <integer>]
     Standardwert: '5'

     Die maximale Zahl an Teilungen von Intervallen, die der adaptive
     Algorithmus für das Zeichnen eines Graphen vornimmt.  Zusammen mit
     der Grafikoption 'nticks' hat diese Grafikoption Einfluss darauf,
     wie glatt der Graph gezeichnet wird.

 -- Grafikoption: axes [axes, <symbol>]
     Standardwert: 'true'

     'symbol' kann einen der Werte 'true', 'false', 'x' oder 'y'
     annehmen.  Ist der Wert 'false', werden keine Achsen gezeichnet.
     Mit 'x' oder 'y' werden nur die x- oder nur die y-Achse gezeichnet.
     Mit 'true' werden beide Achsen gezeichnet.  Diese Option wird nur
     von den Funktionen 'plot2d' und 'implicit_plot' beachtet.

 -- Grafikoption: azimuth [azimuth, <number>]
     Standardwert: '30'

     Setzt den Wert des Azimutwinkels in Grad für die Ansicht einer
     dreidimensionalen Grafik.  Siehe auch 'elevation'.

 -- Grafikoption: box [box, <symbol>]
     Standardwert: 'true'

     Hat die Grafikoption 'box' den Wert 'true', erhält die Grafik einen
     Rahmen.  Ist der Wert 'false', wird kein Rahmen gezeichnet.

 -- Grafikoption: color [color, <color_1>, ..., <color_n>]
     Standardwert: '[blue, red, green, magenta, black, cyan]'

     Wenn die Funktionen 'plot2d' oder 'implicit_plot' mehrere Graphen
     zeichnen, definiert die Grafikoption 'color' die Farben der
     einzelnen Graphen.  Für einen 3D-Graphen mit der Funktion 'plot3d'
     definiert die Grafikoption 'color' die Farbe der Flächen.

     Gibt es mehr Kurven oder Flächen als Farben, werden die Farben
     wiederholt.  Im Grafikformat Gnuplot können nur die Farben 'blue',
     'red', 'green', 'magenta', 'black', 'cyan' verwendet werden.  Im
     Grafikformat Xmaxima können die Farben auch als eine Zeichenkette
     angegeben werden, die mit dem Zeichen # beginnt und auf dem sechs
     hexadezimale Zahlenwerte folgen.  Je zwei Werte bezeichnen die
     rote, grüne und blaue Komponente der Farbe.

     Siehe auch 'style'.

 -- Grafikoption: colorbox [colorbox, <symbol>]
     Standardwert: 'false'

     Hat die Grafikoption 'colorbox' den Wert 'true', wird immer dann,
     wenn das Grafikkommando 'plot3d' eine Palette mit verschiedenen
     Farben nutzt, um die z-Werte darzustellen, eine Legende mit den
     Farben und den dazugehörenden z-Werten angezeigt.

 -- Grafikoption: elevation [elevation, <number>]
     Standardwert: '60'

     Setzt den Wert des Elevationswinkels in Grad für die Ansicht einer
     dreidimensionalen Grafik.  Siehe auch 'azimuth'.

 -- Grafikoption: grid [grid, <integer>, <integer>]
     Standardwert: '[30, 30]'

     Setzt die Anzahl der Gitterlinen für die x- und y-Achsen einer
     dreidimensionalen Grafik.

 -- Grafikoption: legend [legend, <string_1>, ..., <string_n>]
 -- Grafikoption: legend [legend, <false>]

     Definiert die Einträge einer Legende, wenn mehrere Graphen
     gezeichnet werden.  Sind mehr Graphen als Einträge vorhanden,
     werden die Einträge wiederholt.  Hat die Grafikoption 'legend' den
     Wert 'false', wird keine Legende gezeichnet.  Standardmäßig werden
     die Ausdrücke oder Namen der Funktionen als Einträge verwendet.
     Für diskrete Grafiken werden die Einträge mit discrete1, discrete2,
     ... bezeichnet.  Diese Grafikoption kann nicht mit der Funktion
     'set_plot_option' gesetzt werden.

 -- Grafikoption: logx [logx]

     Bewirkt, dass die horizontale Achse logarithmisch skaliert wird.
     Diese Grafikoption kann nicht mit der Funktion 'set_plot_option'
     gesetzt werden.  Siehe auch 'logy'.

 -- Grafikoption: logy [logy]

     Bewirkt, dass die vertikale Achse logarithmisch skaliert wird.
     Diese Grafikoption kann nicht mit der Funktion 'set_plot_option'
     gesetzt werden.  Siehe auch 'logx'.

 -- Grafikoption: mesh_lines_color [mesh_lines_color, <color>]
     Standardwert: 'black'

     Setzt die Farbe, die von der Funktion 'plot3d' genutzt wird, um die
     Gitterlinien zu zeichnen.  Es können dieselben Farben verwendet
     werden wie für die Grafikoption 'color'.  Hat 'mesh_lines_color'
     Wert 'false', werden keine Gitterlinien gezeichnet.

 -- Grafikoption: nticks [nticks, <integer>]
     Standardwert: '29'

     Wird eine Grafik mit der Funktion 'plot2d' gezeichnet, gibt
     'nticks' die Anzahl der Anfangspunkte für das Zeichnen der Grafik
     an.  Werden parametrische Kurven mit den Funktionen 'plot2d' oder
     'plot3d' gezeichnet, ist 'nticks' die Anzahl der Punkte, für die
     der Graph gezeichnet wird.

     Zusammen mit der Grafikoption 'adapt_depth' hat diese Grafikoption
     Einfluss darauf, wie glatt der Graph gezeichnet wird.

 -- Grafikoption: palette [palette, [<palette_1>], ..., [<palette_n>]]
 -- Grafikoption: palette [palette, <false>]
     Standardwert: '[hue, 0.25, 0.7, 0.8, 0.5], [hue, 0.65, 0.8, 0.9, 0.55],
     [hue, 0.55, 0.8, 0.9, 0.4], [hue, 0.95, 0.7, 0.8, 0.5]'

     Eine Palette kann aus einer oder einer Liste mit mehreren Paletten
     bestehen.  Jede Palette beginnt mit einem Schlüsselwort, worauf 4
     Zahlen folgen.  Die ersten drei Zahlen haben Werte zwischen 0 und
     1.  Diese definieren den Farbton 'hue', die Sättigung 'saturation'
     und die Grundfarbe 'value', die der kleinste z-Wert erhält.  Die
     Schlüsselworte 'hue', 'saturation' und 'value' spezifizieren,
     welches der drei Attribute mit dem Wert von z geändert werden.  Der
     letzte Wert der Liste, spezifiziert, welcher Wert zum größten
     z-Wert gehört.  Dieser größte Wert kann größer als 1 und auch
     negativ sein.  Die Werte der modifizierten Attribute werden Modulo
     1 gerundet.

     Gnuplot verwendet nur die erste Palette in einer Liste mit
     Paletten.  Xmaxima nutzt alle Paletten nacheinander, wenn mehrere
     Flächen gezeichnet werden.  Sind nicht genügend Paletten vorhanden,
     werden die Paletten wiederholt.

     Die Farbe der Gitterlinien wird mit der Option 'mesh_lines_color' 
     angegeben.  Hat 'palette' den Wert 'false', werden die Flächen
     nicht gefärbt, sondern als ein Gitternetz gezeichnet.  Die Farbe
     der Gitterlinien wird in diesem Fall mit der Grafikoption 'color'
     festgelegt.

 -- Grafikoption: plot_format [plot_format, <format>]
     Standardwert: 'gnuplot' für Windows, ansonsten 'gnuplot_pipes'

     Setzt das Grafikformat für die Ausgabe einer Grafik.  'format' kann
     die Werte 'gnuplot', 'xmaxima', 'mgnuplot' oder 'gnuplot_pipes'
     annehmen.  Siehe das Kapitel Grafikformate.

 -- Grafikoption: plot_realpart [plot_realpart, <symbol>]
     Standardwert: 'false'

     Hat 'plot_realpart' den Wert 'true', werden Funktionen als komplex
     angenommen und der Realteil wird gezeichnet.  Das entspricht dem
     Aufruf der Grafikfunktion mit dem Ausdruck 'realpart(<function>)'.
     Hat 'plot_realpart' den Wert 'false', wird keine Grafik gezeichnet,
     wenn die Funktion keinen Realteil hat.  Zum Beispiel ist 'log(x)'
     komplex, wenn <x> negativ ist.  Hat 'plot_realpart' den Wert
     'true', wird der Wert 'log(-5)' als 'log(5)' gezeichnet.  Hat
     'plot_realpart' den Wert 'false' wird kein Wert gezeichnet.

 -- Grafikoption: point_type [point_type, <type_1>, ..., <type_n>]
     Standardwert: '[bullet, circle, plus, times, asterisk, box, square,
     triangle, delta, wedge, nabla, diamond, lozenge]'

     Werden im Grafikformat Gnuplot Punkte mit den Stilen 'points' oder
     'linespoints' gezeichnet, werden die Symbole für die einzelnen
     Datensätze nacheinander der Liste 'point_type' entnommen.  Gibt es
     mehr Datensätze als Symbole, werden diese wiederholt.  Siehe auch
     'style'.

 -- Grafikoption: psfile [psfile, <filename>]

     Speichert die Grafik in eine Postscript-Datei mit den Namen
     <filename>.  Die Grafik wird nicht auf dem Bildschirm ausgegeben.
     Standardmäßig wird die Datei in dem Ordner abgespeichert, dessen
     Namen in der Optionsvariablen 'maxima_tempdir' enthalten ist.

 -- Grafikoption: run_viewer [run_viewer, <symbol>]

     Standardwert: 'true'

     Kontrolliert, ob die Bildschirmausgabe des Grafikformats gestartet
     wird.

 -- Grafikoption: style [style, <type_1>, ..., <type1_n>]
 -- Grafikoption: style [style, [<style_1>], ..., [<style_n>]]
     Standardwert: 'lines'

     Bestimmt den Stil für das Zeichnen von Funktionen oder Datensätzen
     mit der Funktion 'plot2d'.  Werden mehr Graphen gezeichnet, als
     Stile vorhanden sind, werden diese wiederholt.  Die möglichen Stile
     sind 'lines' für Linien, 'points' für einzelne Punkte,
     'linespoints' für Linien mit Punkten oder 'dots' für kleine Punkte.
     Das Grafikformat Gnuplot akzeptiert zusätzlich den Stil 'impulses'.

     Jeder Stil kann weitere Parameter erhalten, die zusammen mit dem
     Stil als eine Liste angegeben werden.  Der Stil 'lines' akzeptiert
     zwei Zahlen, die die Breite der Linie und deren Farbe angegeben.
     Die Standardfarben haben die Zahlenwerte: 1: 'blue', 2: 'red', 3:
     'magenta', 4: 'orange', 5: 'brown', 6: 'lime' und 7: 'aqua'.  Im
     Grafikformat Gnuplot kann die Kodierung der Farben für verschiedene
     Terminals abweichend sein.  Wird zum Beispiel das Terminal
     [<gnuplot_term>,<ps>] verwendet, entspricht dem Zahlenwert 4 die
     Farbe 'black'.

     Der Stil 'points' akzeptiert zwei oder drei Parameter.  Der erste
     Parameter ist der Radius des Punktes.  Der zweite Parameter ist
     eine Zahl, der wie für den Stil 'lines' eine Farbe angibt.  Der
     dritte Parameter ist eine Zahl, mit der im Grafikformat Gnuplot die
     folgenden Zeichen für die Darstellung der Punkte ausgewählt werden
     können: 1: 'bullet', 2: 'circle', 3: 'plus', 4: 'times', 5:
     'asterisk', 6: 'box', 7: 'square', 8: 'triangle', 9: 'delta', 10:
     'wedge', 11: 'nabla', 12: 'diamond', 13: 'lozenge'.

     Der Stil 'linesdots' akzeptiert bis zu vier Parameter: die Breite
     der Linie, den Radius der Punkte, die Farbe und das Symbol für das
     Zeichnen der Punkte.

     Siehe auch die Grafikoptionen 'color' und 'point_type'.

 -- Grafikoption: t [t, <min>, <max>]

     Bestimmt den Wertebereich für das Zeichnen einer parametrischen
     Kurve mit der Funktion 'plot2d'.  Die Variable einer parametrischen
     Kurve muss mit 't' bezeichnet werden.

 -- Grafikoption: transform_xy [transform_xy, <symbol>]
     Standardwert: 'false'

     <symbol> hat entweder den Wert 'false' oder ist das Ergebnis der
     Funktion 'make_transform'.  Wenn verschieden von 'false', wird die
     Funktion genutzt, um die drei Koordinaten einer dreidimensionalen
     Grafik zu transformieren.

     Siehe auch 'polar_to_xy' und 'spherical_to_xyz'.  für bereits
     vordefinierte Koordinatentransformationen.

 -- Grafikoption: x [x, <min>, <max>]

     Die erste Grafikoption der Funktionen 'plot2d' oder 'plot3d'
     bezeichnet die unabhängige Variable.  Die unabhängige Variable muss
     nicht mit 'x' bezeichnet werden, sondern kann ein beliebiges von
     'x' verschiedenes Symbol sein.  Die Werte <min> und <max> geben in
     diesem Fall den Wertebereich der unabhängigen Variablen an.  Die
     Grafikoption 'x' kann ein zweites Mal angegeben werden, um den
     Bereich für die x-Achse festzulegen.

 -- Grafikoption: xlabel [xlabel, <string>]
     Standardwert: '"x"'

     Legt die Zeichenkette <string> fest, mit der die x-Achse der Grafik
     bezeichnet wird.  Der Standardwert ist '"x"' oder der Name der
     ersten unabhängigen Variablen.  Diese Grafikoption kann nicht mit
     dem Kommando 'set_plot_option' gesetzt werden.

 -- Grafikoption: y [y, <min>, <max>]

     Für einen dreidimensionalen Graphen legt diese Grafikoption die
     zweite unabhängige Variable fest.  Die unabhängige Variable muss
     nicht mit 'y' bezeichnet werden, sondern kann ein beliebiges von
     'y' verschiedenes Symbol sein.  Die Werte <min> und <max> geben in
     diesem Fall den Wertebereich der Variablen an.  Wird die
     Grafikoption für einen zweidimensionalen Graphen verwendet oder für
     einen dreidimensionalen Graphen ein zweites Mal eingesetzt, dann
     wird der Bereich für die y-Achse festgelegt.

 -- Grafikoption: ylabel [ylabel, <string>]
     Standardwert: '"y"'

     Legt die Zeichenkette <string> fest, mit der die y-Achse der Grafik
     bezeichnet wird.  Der Standardwert ist '"y"' oder für den Fall
     einer dreidimensionalen Grafik der Name der zweiten unabhängigen
     Variablen.  Diese Grafikoption kann nicht mit dem Kommando
     'set_plot_option' gesetzt werden.

 -- Grafikoption: z [z, <min>, <max>]

     Legt für eine dreidimensionalen Grafik den Bereich für die z-Achse
     fest.

 -- Grafikoption: zlabel [zlabel, <string>]
     Standardwert: '"z"'

     Legt die Zeichenkette <string> fest, mit der die z-Achse der Grafik
     bezeichnet wird.  Der Standardwert ist '"z"'.  Diese Grafikoption
     kann nicht mit dem Kommando 'set_plot_option' gesetzt werden und
     wird von den Funktionen 'plot2d' sowie 'implicit_plot' ignoriert.


File: maxima.info,  Node: Gnuplot Optionen,  Next: Gnuplot_pipes Formatfunktionen,  Prev: Grafikoptionen,  Up: Grafische Darstellung

12.5 Gnuplot Optionen
=====================

Es gibt einige spezielle Optionen für das Grafikformat Gnuplot.  Diese
Optionen werden mit einem Schlüsselwort bezeichnet und zusammen mit
einer Zeichenkette, die ein gültiges Gnuplot-Kommando darstellt, an
Gnuplot übergeben.  In den meisten Fällen gibt es eine entsprechende
Grafikoption, die ein vergleichbares Ergebnis erzeugt.  Die
Grafikoptionen sollten den Gnuplot-Optionen vorgezogen werden.

 -- Grafikoption: gnuplot_term

     Setzt den Terminaltyp für das Grafikformat Gnuplot.

        * *default* (Standardwert)

          Die Ausgabe von Gnuplot wird in einem separatem Fenster
          angezeigt.

        * *dumb*

          Die Ausgabe von Gnuplot wird in der Maxima Konsole mit
          Ascii-Zeichen angezeigt.

        * *ps*

          Gnuplot generiert PostScript-Kommandos.  Mit der Grafikoption
          'gnuplot_out_file' werden die PostScript-Kommandos in eine
          Datei <filename> geschrieben.  Ansonsten werden die Kommandos
          in die Datei 'maxplot.ps' geschrieben.

        * Jede andere gültige Gnuplot Spezifikation

     Gnuplot kann Ausgaben in verschiedenen Formaten wie zum Beispiel
     PNG, JPEG, SVG generieren.  Die verschiedenen Formate werden mit
     der Option 'gnuplot_term' angegeben.  Weiterhin kann jedes gültige
     Kommando als Zeichenkette übergeben werden.  Zum Beispiel generiert
     '[gnuplot_term, png]' eine Grafik im PNG-Format.  Das Kommando
     '[gnuplot_term, "png size 1000, 1000"]' generiert eine Grafik im
     PNG-Format mit dem Format 1000 x 1000 Punkte.  Erhält die
     Grafikoption 'gnuplot_out_file' den Wert <filename>, wird die
     Ausgabe in die Datei <filename> geschrieben.  Ansonsten werden die
     Kommandos in die Datei 'maxplot.<term>' geschrieben, wobei <term>
     das verwendete Grafikformat ist.

 -- Grafikoption: gnuplot_out_file

     Zusammen mit der Option 'gnuplot_term', kann die Ausgabe in dem
     angegebenen Gnuplot-Format in eine Datei geschrieben werden.  Eine
     Postscript-Datei kann auch mit der Grafikoption 'psfile' angegeben
     werden.  Die Grafikoption 'psfile' funktioniert auch mit dem
     Grafikformat 'xmaxima'.

          [gnuplot_term, png], [gnuplot_out_file, "graph3.png"]

 -- Grafikoption: gnuplot_pm3d

     Hat die Grafikoption 'gnuplot_pm3d' den Wert 'false', wird der
     PM3D-Modus ausgeschaltet.  Dieser Modus ist standardmäßig
     eingeschaltet.

 -- Grafikoption: gnuplot_preamble

     Fügt Gnuplot-Kommandos ein, die vor dem Zeichnen der Grafik
     ausgeführt werden.  Jedes gültige Gnuplot-Kommando kann verwendet
     werden.  Mehrere Kommandos sollten mit einem Semikolon voneinander
     getrennt werden.  Der Standardwert der Option 'gnuplot_preamble'
     ist eine leere Zeichenkette '""'.

 -- Grafikoption: gnuplot_curve_titles

     Dies ist eine veraltete Option, die von der Grafikoption 'legend'
     ersetzt wurde.

 -- Grafikoption: gnuplot_curve_styles

     Dies ist eine veraltete Option, die von der Grafikoption 'style'
     ersetzt wurde.

 -- Grafikoption: gnuplot_default_term_command

     Das Gnuplot-Kommando, um den Standardtyp eines Terminals zu setzen.
     Der Standardwert ist 'set term pop'.

 -- Grafikoption: gnuplot_dumb_term_command

     Das Gnuplot-Kommando, um die Breite und Höhe des Terminaltyps
     'dumb' zu setzen.  Der Standardwert ist '"set term dumb 79 22"'.
     Die Ausgabe hat eine Breite von 79 Zeichen und eine Höhe von 22
     Zeichen.

 -- Grafikoption: gnuplot_ps_term_command

     Das Gnuplot-Kommando, um die Parameter für eine Postscript-Terminal
     zu setzen.  Ein Postscript-Terminal hat die Standardwerte '"set
     size 1.5, 1.5; set term postscript eps enhanced color solid 24"'.
     Das Terminal wird auf den 1,5 fachen Wert des Standardwertes und
     die Schriftgröße auf 24 gesetzt.  Siehe die Gnuplot-Dokumentation
     für eine Beschreibung weiterer Parameter, die für ein
     Postscript-Terminal gesetzt werden können.


File: maxima.info,  Node: Gnuplot_pipes Formatfunktionen,  Prev: Gnuplot Optionen,  Up: Grafische Darstellung

12.6 Gnuplot_pipes Formatfunktionen
===================================

 -- Funktion: gnuplot_start ()

     Öffnet eine Pipe, die im Grafikformat 'gnuplot_pipes' für den
     Austausch der Daten genutzt wird.

 -- Funktion: gnuplot_close ()

     Schließt die Pipe, die im Grafikformat 'gnuplot_pipes' für den
     Austausch der Daten genutzt wird.

 -- Funktion: gnuplot_restart ()

     Schließt die Pipe, die im Grafikformat 'gnuplot_pipes' für den
     Austausch der Daten genutzt wird, und öffnet eine neue Pipe.

 -- Funktion: gnuplot_replot ()
 -- Funktion: gnuplot_replot (<string>)

     Aktualisiert die Ausgabe von Gnuplot.  Wird 'gnuplot_replot' mit
     einer Zeichenkette <string> aufgerufen, die Gnuplot-Kommandos
     enthält, dann werden die Kommandos vor der Aktualisierung an
     Gnuplot gesendet.

 -- Funktion: gnuplot_reset ()

     Im Grafikformat 'gnuplot_pipes' wird Gnuplot zurückgesetzt.  Um die
     Anzeige zu aktualisieren, kann das Kommando 'gnuplot_replot' nach
     dem Kommando 'gnuplot_reset' ausgeführt werden.


File: maxima.info,  Node: Eingabe und Ausgabe,  Next: Mengen,  Prev: Grafische Darstellung,  Up: Top

13 Eingabe und Ausgabe
**********************

* Menu:

* Kommentare::
* Dateien::
* Funktionen und Variablen für die Eingabe und Ausgabe::
* Funktionen und Variablen für die TeX-Ausgabe::
* Funktionen und Variablen für die Fortran-Ausgabe::


File: maxima.info,  Node: Kommentare,  Next: Dateien,  Prev: Eingabe und Ausgabe,  Up: Eingabe und Ausgabe

13.1 Kommentare
===============

Ein Kommentar in der Maxima-Eingabe ist ein Text der von den Zeichen
'/*' und '*/' eingeschlossen ist.  Der Maxima-Parser behandelt einen
Kommentar wie ein Zwischenraumzeichen, wenn ein Token eingelesen wird.
Ein Token endet immer an einem Zwischenraumzeichen.  Eine Eingabe wie
'a/* foo */b' enthält die beiden Token 'a' und 'b' und nicht das
einzelne Token 'ab'.  Ansonsten werden Kommentare von Maxima ignoriert.
Kommentare werden im eingelesenen Ausdruck nicht gespeichert.

Kommentare können in beliebiger Tiefe verschachtelt werden.  Die
Begrenzungszeichen '/*' und '*/' müssen paarweise auftreten.

Beispiele:

     (%i1) /* aa is a variable of interest */  aa : 1234;
     (%o1)                         1234
     (%i2) /* Value of bb depends on aa */  bb : aa^2;
     (%o2)                        1522756
     (%i3) /* User-defined infix operator */  infix ("b");
     (%o3)                           b
     (%i4) /* Parses same as a b c, not abc */  a/* foo */b/* bar */c;
     (%o4)                         a b c
     (%i5) /* Comments /* can be nested /* to any depth */ */ */  1 + xyz;
     (%o5)                        xyz + 1


File: maxima.info,  Node: Dateien,  Next: Funktionen und Variablen für die Eingabe und Ausgabe,  Prev: Kommentare,  Up: Eingabe und Ausgabe

13.2 Dateien
============

Folgende Funktionen und Variablen arbeiten mit Dateien:

   appendfile           batch                 batchload
   closefile            file_output_append    filename_merge
   file_search          file_search_maxima    file_search_lisp
   file_search_demo     file_search_usage     file_search_tests
   file_type            file_type_lisp        file_type_maxima
   load                 load_pathname         loadfile
   loadprint            pathname_directory    pathname_name
   pathname_type        printfile             save
   stringout            with_stdout           writefile


File: maxima.info,  Node: Funktionen und Variablen für die Eingabe und Ausgabe,  Next: Funktionen und Variablen für die TeX-Ausgabe,  Prev: Dateien,  Up: Eingabe und Ausgabe

13.3 Funktionen und Variablen für die Eingabe und Ausgabe
=========================================================

 -- Funktion: appendfile (<filename>)

     Startet wie die Funktion 'writefile' eine Aufzeichnung aller Ein-
     und Ausgaben der Konsole.  Die Ein- und Ausgaben werden in die
     Datei <filename> geschrieben.  Im Unterschied zu 'writefile' werden
     die Daten immer an eine existierende Datei angehängt, wenn diese
     existiert.  Existiert die Datei nicht, wird diese angelegt.

     Die Funktion 'closefile' beendet die Aufzeichnung.

 -- Funktion: batch (<filename>)
 -- Funktion: batch (<filename>, option)

     Das Kommando 'batch(<filename>)' liest Maxima-Ausdrücke aus der
     Datei <filename> ein, wertet diese aus und gibt die Ergebnisse auf
     der Konsole aus.  'batch' sucht die Datei <filename> in den
     Verzeichnissen, die in der Liste 'file_search_maxima' enthalten
     sind.  Siehe auch die Funktion 'file_search'.

     'batch(<filename>, demo)' entspricht dem Kommando
     'demo(<filename>)'.  'batch' sucht für diesen Fall die Datei in der
     Liste der Verzeichnisse 'file_search_demo'.  Siehe auch die
     Funktion 'demo'.

     'batch(<filename>, test)' entspricht dem Kommando 'run_testsuite'
     mit der Option 'display_all=true'.  Im Unterschied zur Funktion
     'run_testsuite' sucht die Funktion 'batch' die Datei <filename> in
     den Verzeichnissen der Liste 'file_search_maxima' und nicht in der
     Liste 'file_search_tests'.

     Die Maxima-Ausdrücke in der Datei werden wie auf der Konsole mit
     den Zeichen ';' oder '$' beendet.  Die Systemvariable '%' und die
     Funktion '%th' beziehen sich auf vorhergehende Zeilen in der Datei.
     Die Datei kann ':lisp'-Unterbrechungskommandos enthalten.
     Leerzeichen, Tabulatoren, Zeilenschaltungen und Kommentare werden
     ignoriert.  Eine geeignete Datei kann mit einem Texteditor oder der
     Funktion 'stringout' erstellt werden.

     Den Ein- und Ausgaben werden jeweils Ein- und Ausgabemarken
     zugewiesen.  Tritt während der Auswertung eines Ausdrucks ein
     Fehler auf, wird das Einlesen der Datei abgebrochen.  Werden
     Eingaben vom Nutzer benötigt, wie zum Beispiel bei Fragen der
     Funktionen 'asksign' oder 'askinteger', dann wartet 'batch' auf die
     Antworten, um dann die Verarbeitung der Datei fortzusetzen.

     Die Verarbeitung von 'batch' kann durch die Eingabe von 'control-C'
     abgebrochen werden.  Die weitere Reaktion auf einen Abbruch mit
     'control-C' hängt von der Lisp-Implementation ab.

     'batch' wertet die Argumente aus.  'batch' gibt den Namen der Datei
     <filename> als Zeichenkette zurück, wenn die Funktion ohne zweites
     Argument oder mit der Option 'demo' aufgerufen wird.  Wird die
     Funktion mit der Option 'test' aufgerufen, ist die Rückgabe eine
     leere Liste '[]' oder eine Liste, die <filename> und die Nummern
     der fehlgeschlagenen Tests enthält.

     Siehe auch die Funktionen 'load' und 'batchload', um Dateien zu
     laden, sowie die Funktionen 'run_testsuite' und 'demo'.

 -- Funktion: batchload (<filename>)

     Liest Ausdrücke aus der Datei <filename> ein und wertet diese aus,
     ohne die eingelesenen und ausgewerteten Ausdrücke anzuzeigen und
     ohne Zuweisung von Eingabe- und Ausgabemarken.  Die Ausgabe von
     Fehlermeldungen oder sonstigem Text, der von Funktionen ausgegeben
     wird, wird nicht unterdrückt.

     Die Systemvariable '%' und die Funktion '%th' beziehen sich auf die
     letzte Eingabe auf der Konsole und nicht auf Zeilen oder Ergebnisse
     der Datei.  Im Gegensatz zur Funktion 'batch' darf eine Datei, die
     von 'batchload' geladen wird, keine ':lisp'-Unterbrechungskommandos
     enthalten.

     'batchload' gibt eine Zeichenkette mit dem Pfad der Datei
     <filename> zurück.  Siehe auch die Funktionen 'batch' und 'load',
     um Dateien zu laden.

 -- Funktion: closefile ()

     Beendet eine Aufzeichnung, die von den Funktionen 'writefile' oder
     'appendfile' gestartet wurde, und schließt die Ausgabedatei.

 -- Optionsvariable: file_output_append
     Standardwert: 'false'

     Die Optionsvariable 'file_output_append' kontrolliert, ob die
     Funktionen 'save', 'stringout' oder 'with_stdout', die in eine
     Datei schreiben, diese löschen und neu anlegen oder die Daten
     anhängen.  Wenn 'file_output_append' den Wert 'true' hat, werden
     die Daten an die existierende Datei angehängt.  Ansonsten wird eine
     neue Datei erstellt.

     Plot-Funktionen und der Übersetzer erstellen grundsätzlich neue
     Dateien und die Funktionen 'tex' und 'appendfile' hängen die
     Ausgabe immer an eine bestehende Datei an.

 -- Funktion: filename_merge (<path>, <filename>)

     Setzt einen Pfad aus <path> und <filename> zusammen.  Endet <path>
     mit einer Zeichenkette der Form '###.<something>', wird diese
     Zeichenkette durch '<filename.something>' ersetzt.  Ansonsten wird
     der Endbestandteil durch <filename> ersetzt.

     Die Rückgabe ist ein Lisp-Dateiname.

     Beispiele:

          (%i1) filename_merge("user/", "myfile");
          (%o1)                      user/myfile

          (%i2) filename_merge("user/###.lisp", "myfile");
          (%o2)                   user/myfile.lisp

 -- Funktion: file_search (<filename>)
 -- Funktion: file_search (<filename>, <pathlist>)

     'file_search' sucht die Datei <filename> und gibt den Pfad als eine
     Zeichenkette zurück, wenn die Datei gefunden wurde.  Ansonsten wird
     'false' zurückgegeben.  'file_search(<filename>)' sucht in den
     Standardsuchverzeichnissen, die mit den Optionsvariablen
     'file_search_maxima', 'file_search_lisp' und 'file_search_demo'
     spezifiziert werden.

     'file_search' prüft zuerst, ob die Datei 'filename' existiert.
     Dann prüft 'file_search', ob die Datei anhand von Mustern im
     Dateinamen gefunden werden kann.  Siehe 'file_search_maxima' für
     die Suche von Dateien.

     Das Argument <filename> kann ein Name mit einer Pfadangabe oder
     allein der Dateiname sein.  Sind in den Suchverzeichnissen
     Dateinamen mit Mustern enthalten, kann die Datei auch ohne Endung
     angegeben werden.  Zum Beispiel finden die folgenden Kommandos
     dieselbe Datei, wenn '/home/wfs/special/###.mac' in der Liste
     'file_search_maxima' enthalten ist:

          file_search ("/home/wfs/special/zeta.mac");
          file_search ("zeta.mac");
          file_search ("zeta");

     'file_search(<filename>, <pathlist>)' sucht nur in den
     Verzeichnissen <pathlist>.  Das Argument <pathlist> überschreibt
     die Standardsuchverzeichnisse.  Auch ein einzelnes Verzeichnis muss
     als eine Liste übergeben werden.

     Die Standardsuchverzeichnisse können modifiziert werden.  Siehe
     dazu auch 'file_search_maxima'.

     'file_search' wird von der Funktion 'load' mit den
     Verzeichnislisten 'file_search_maxima' und 'file_search_lisp'
     aufgerufen.

 -- Optionsvariable: file_search_maxima
 -- Optionsvariable: file_search_lisp
 -- Optionsvariable: file_search_demo
 -- Optionsvariable: file_search_usage
 -- Optionsvariable: file_search_tests

     Diese Optionsvariablen bezeichnen Listen mit Verzeichnissen, die
     von Funktionen wie 'load' und 'demo' durchsucht werden, um eine
     Datei zu finden.  Die Standardwerte bezeichnen verschiedene
     Verzeichnisse der Maxima-Installation.

     Diese Variablen können modifiziert werden, indem die Standardwerte
     ersetzt oder weitere Verzeichnisse angehängt werden.  Zum Beispiel
     wird im Folgenden der Standardwert der Optionsvariablen
     'file_search_maxima' ersetzt:

          file_search_maxima: ["/usr/local/foo/###.mac",
              "/usr/local/bar/###.mac"]$

     In diesem Beispiel werden zwei weitere Verzeichnisse zu der
     Optionsvariablen 'file_search_maxima' hinzugefügt:

          file_search_maxima: append (file_search_maxima,
              ["/usr/local/foo/###.mac", "/usr/local/bar/###.mac"])$

     Soll eine erweiterte Liste der Suchverzeichnisse nach jedem Start
     von Maxima zur Verfügung stehen, kann das obige Kommando in die
     Datei 'maxima-init.mac' aufgenommen werden.

     Mehrere Dateiendungen und Pfade können mit Wildcard-Konstruktionen
     spezifiziert werden.  Eine Zeichenkette '###' wird durch einen
     Dateinamen ersetzt.  Werden mehrere Zeichenketten durch Kommata
     getrennt und mit geschweiften Klammern angegeben wie zum Beispiel
     '{foo, bar, baz}', expandiert die Liste in mehrere Zeichenketten.
     Das folgende Beispiel expandiert für 'neumann'

          "/home/{wfs,gcj}/###.{lisp,mac}"

     in '/home/wfs/neumann.lisp', '/home/gcj/neumann.lisp',
     '/home/wfs/neumann.mac' und '/home/gcj/neumann.mac'.

 -- Funktion: file_type (<filename>)

     Gibt eine Vermutung über den Typ der Datei <filename> zurück.  Es
     wird nur die Dateiendung betrachtet.

     Die Rückgabe ist das Symbol 'maxima' oder 'lisp', wenn die
     Dateiendung einen der Werte der Optionsvariablen 'file_type_maxima'
     oder der Optionsvariablen 'file_type_lisp' entspricht.  Ansonsten
     ist die Rückgabe das Symbol 'object'.

     Siehe auch die Funktion 'pathname_type'.

 -- Optionsvariable: file_type_lisp
     Standardwert: '[l, lsp, lisp]'

     Die Optionsvariable 'file_type_lisp' enthält die Dateiendungen, die
     Maxima als die Bezeichnung für eine Lisp-Datei annimmt.

     Siehe auch die Funktion 'file_type'.

 -- Optionsvariable: file_type_maxima
     Standardwert: '[mac, mc, demo, dem, dm1, dm2, dm3, dmt]'

     Die Optionsvariable 'file_type_maxima' enthält die Dateiendungen,
     die Maxima als die Bezeichnung für eine Maxima-Datei annimmt.

     Siehe auch die Funktion 'file_type'.

 -- Funktion: load (<filename>)

     Wertet die Ausdrücke in der Datei <filename> aus, wodurch die
     Variablen, Funktionen und andere Objekte in Maxima geladen werden.
     Alle bisher zugewiesen Variablen und Definitionen werden
     überschrieben.  Um die Datei zu finden, wird von 'load' die
     Funktion 'file_search' mit den Verzeichnislisten
     'file_search_maxima' und 'file_search_lisp' aufgerufen.  Ist 'load'
     erfolgreich, wird der Dateiname zurückgegeben.  Ansonsten gibt
     'load' eine Fehlermeldung aus.

     'load' verarbeitet Dateien mit Lisp-Code oder Maxima-Code.
     Dateien, die mit den Funktionen 'save', 'translate_file' und
     'compile_file' erstellt wurden, enthalten Lisp-Code.  Dateien, die
     mit 'stringout' erstellt wurden, enthalten Maxima-Code.  Die
     Ausgabedateien dieser Funktionen können mit 'load' geladen werden.
     'load' ruft die Funktion 'loadfile' auf, um Lisp-Dateien und
     'batchload' auf, um Maxima-Dateien zu verarbeiten.

     'load' erkennt keine ':lisp'-Unterbrechungskommandos in
     Maxima-Dateien.  Die Systemvariablen '_', '__' und '%' und die
     Funktion '%th' behalten jeweils ihren letzten Wert vor dem Aufruf
     von 'load'.

     Siehe auch die Funktionen 'loadfile', 'batch', 'batchload' und
     'demo'.  'loadfile' verarbeitet Lisp-Dateien.  'batch', 'batchload'
     und 'demo' verarbeiten Maxima-Dateien.

     Siehe 'file_search' für mehr Informationen, wie Maxima Dateien in
     Verzeichnissen findet.  'load' wertet die Argumente aus.

 -- Systemvariable: load_pathname
     Standardwert: 'false'

     Wird eine Datei mit den Funktionen 'load', 'loadfile' oder
     'batchload' geladen, enthält die Systemvariable 'load_pathname' den
     Namen der Datei.  Der Wert der Systemvariablen kann in der Datei,
     die geladen wird, ausgelesen werden.

     Beispiele:

     Ist eine Batch-Datei mit den Namen 'test.mac' in dem Verzeichnis
          "/home/dieter/workspace/mymaxima/temp/"
     abgelegt und enthält die Datei die folgenden Befehle

          print("The value of load_pathname is: ", load_pathname)$
          print("End of batchfile")$

     dann wird das Folgende ausgegeben:

          (%i1) load("/home/dieter/workspace/mymaxima/temp/test.mac")$
          The value of load_pathname is:
                        /home/dieter/workspace/mymaxima/temp/test.mac
          End of batchfile

 -- Funktion: loadfile (<filename>)

     Lädt die Datei <filename> und wertet die Lisp-Ausdrücke in der
     Datei aus.  'filename' ruft nicht 'file_search' auf, um eine Datei
     zu finden.  Daher muss 'filename' ein vollständiger Dateiname sein.

     'loadfile' kann Dateien verarbeiten, die mit den Funktionen 'save',
     'translate_file' und 'compile_file' erzeugt wurden.

 -- Optionsvariable: loadprint
     Standardwert: 'true'

     'loadprint' kontrolliert, ob Meldungen ausgegeben werden, wenn eine
     Datei geladen wird.

        * Hat 'loadprint' den Wert 'true', wird immer eine Meldung
          ausgegeben.
        * Hat 'loadprint' den Wert ''loadfile', wird eine Meldung
          ausgegeben, wenn die Datei mit der Funktion 'loadfile' geladen
          wird.
        * Hat 'loadprint' den Wert ''autoload', wird eine Meldung
          ausgegeben, wenn eine Datei automatisch geladen wird.
        * Hat 'loadprint' den Wert 'false', werden keine Meldungen beim
          Laden von Dateien ausgegeben.

 -- Funktion: pathname_directory (<pathname>)
 -- Funktion: pathname_name (<pathname>)
 -- Funktion: pathname_type (<pathname>)

     Diese Funktionen geben die Bestandteile eines Pfadnamens zurück.

     Beispiele:

          (%i1) pathname_directory("/home/dieter/maxima/changelog.txt");
          (%o1)                 /home/dieter/maxima/
          (%i2) pathname_name("/home/dieter/maxima/changelog.txt");
          (%o2)                       changelog
          (%i3) pathname_type("/home/dieter/maxima/changelog.txt");
          (%o3)                          txt

 -- Funktion: printfile (<path>)

     Druckt eine Datei mit dem Namen <path> auf der Konsole aus.  <path>
     kann ein Symbol oder eine Zeichenkette sein.  'printfile' sucht die
     Datei in den Verzeichnissen, die in der Optionsvariablen
     'file_search_usage' enthalten sind.

     'printfile' gibt <path> zurück, wenn die Datei existiert.

 -- Funktion: save (<filename>, <name_1>, <name_2>, <name_3>, ...)
 -- Funktion: save (<filename>, values, functions, labels, ...)
 -- Funktion: save (<filename>, [<m>, <n>])
 -- Funktion: save (<filename>, <name_1>=<expr_1>, ...)
 -- Funktion: save (<filename>, all)
 -- Funktion: save (<filename>, <name_1>=<expr_1>, <name_2>=<expr_2>,
          ...)

     Speichert die aktuellen Werte von <name_1>, <name_2>, <name_3>,
     ..., in die Datei <filename>.  Die Argumente sind die Namen von
     Variablen, Funktionen oder anderen Objekten.  Argumente, die keinen
     Wert haben, werden ignoriert.  'save' gibt den Namen der Datei
     'filename' zurück.

     'save' speichert die Daten in einem Lisp-Format.  Die gespeicherten
     Daten können mit dem Kommando 'load(<filename>)' zurückgelesen
     werden.  Siehe 'load'.

     Die Optionsvariable 'file_output_append' kontrolliert, ob 'save'
     die Daten an die Ausgabedatei anhängt, wenn diese bereits
     existiert, oder die Ausgabedatei zuvor löscht.  Hat
     'file_output_append' den Wert 'true', werden die Daten angehängt.
     Ansonsten wird die Datei gelöscht und neu angelegt, wenn diese
     bereits existiert.  Existiert die Ausgabedatei noch nicht, wird
     diese angelegt.

     'save(<filename>, values, functions, labels, ...)' speichert die
     Werte aller Einträge der Listen 'values', 'functions', 'labels',
     u.s.w.  in die Ausgabedatei.  Es kann jede der vorhandenen
     Informationslisten, die in der Systemvariablen 'infolists'
     enthalten ist, als Argument übergeben werden.  'values' enthält zum
     Beispiel alle vom Nutzer definierten Variablen.

     'save(<filename>, [<m>, <n>])' speichert die Werte der Eingabe- und
     Ausgabemarken von <m> bis <n>.  <m> und <n> müssen ganze Zahlen
     sein.  Die Eingabe- und Ausgabemarken können auch einzeln
     gespeichert werden, zum Beispiel mit dem Kommando 'save("foo.1",
     %i42, %o42)'.  'save(<filename>, labels)' speichert alle Eingabe-
     und Ausgabemarken.  Beim Zurücklesen der Marken werden vorhandene
     Werte überschrieben.

     'save(<filename>, <name_1> = <expr_1>, <name_2> = <expr_2>, ...)'
     speichert die Werte <expr_1>, <expr_2>, ..., unter den Namen
     <name_1>, <name_2>, ... ab.  Dies kann nützlich sein, um zum
     Beispiel die Werte von Marken unter einem neuen Namen
     abzuspeichern.  Die rechte Seite der Gleichungen kann ein
     beliebiger ausgewerteter Ausdruck sein.  Die neuen Namen werden der
     aktuellen Sitzung nicht hinzugefügt und nur in der Ausgabedatei
     gespeichert.

     Die verschiedenen Möglichkeiten der Funktion 'save', können
     miteinander kombiniert werden.  Das Kommando 'save(<filename>, aa,
     bb, cc=42, functions, [11,17])' ist dafür ein Beispiel.

     'save(<filename>, all)' speichert den aktuellen Zustand von Maxima
     in eine Ausgabedatei.  Eingeschlossen sind alle nutzerdefinierten
     Variablen, Funktionen oder Arrays, einschließlich automatischer
     Definitionen.  Die gespeicherten Daten enthalten auch die Werte von
     geänderten System- oder Optionsvariablen.  Siehe dazu auch
     'myoptions'.

     'save' wertet das Argument <filename> aus.  Alle anderen Argumente
     werden nicht ausgewertet.

 -- Funktion: stringout (<filename>, <expr_1>, <expr_2>, <expr_3>, ...)
 -- Funktion: stringout (<filename>, [<m>, <n>])
 -- Funktion: stringout (<filename>, input)
 -- Funktion: stringout (<filename>, functions)
 -- Funktion: stringout (<filename>, values)

     'stringout' schreibt Ausdrücke in einem Format in eine Datei, dass
     identisch mit dem Format der Eingabe ist.  Die Datei kann als
     Eingabedatei für die Funktionen 'batch' oder 'demo' genutzt werden.
     Sie kann mit einem Texteditor für jeden Zweck editiert werden.
     'stringout' kann ausgeführt werden, wenn das Kommando 'writefile'
     aktiv ist.

     Die Optionsvariable 'file_output_append' kontrolliert, ob
     'stringout' die Daten an die Ausgabedatei anhängt, wenn diese
     bereits existiert oder die Ausgabedatei zuvor löscht.  Hat
     'file_output_append' den Wert 'true', werden die Daten angehängt,
     wenn die Datei bereits existiert.  Ansonsten wird die Datei
     gelöscht und neu angelegt.  Existiert die Ausgabedatei noch nicht,
     wird diese angelegt.

     Die allgemeine Form von 'stringout' schreibt die Werte eines oder
     mehrerer Ausdrücke in die Ausgabedatei.  Ist ein Ausdruck eine
     Variable, wird nur der Wert der Variablen, nicht jedoch der Name
     der Variablen in die Ausgabedatei geschrieben.  Ein nützlicher
     Spezialfall ist, dass die Werte der Eingabe- und Ausgabemarken
     ('%i1', '%i2', '%i3', ... und '%o1', '%o2', '%o3', ...) in die
     Datei geschrieben werden können.

     Hat die Optionsvariable 'grind' den Wert 'true', wird die Ausgabe
     im Format der Funktion 'grind' in die Ausgabedatei geschrieben.
     Ansonsten wird das Format der Funktion 'string' für die Ausgabe
     genutzt.

     'stringout(<filename>, [<m>, <n>])' schreibt die Werte aller
     Eingabemarken von <m> bis <n> in die Ausgabedatei.
     'stringout(<filename>, input)' schreibt alle Eingabemarken in die
     Ausgabedatei.  'stringout(<filename>, functions)' schreibt alle vom
     Nutzer definierten Funktionen, die in der Informationsliste
     'functions' enthalten sind, in die Ausgabedatei.

     'stringout(<filename>, values)' schreibt alle benuzterdefinierten
     Variablen, die in der Informationsliste 'values' enthalten sind, in
     die Ausgabedatei.  Die Variablen werden als eine Zuweisung, mit dem
     Namen der Variablen, dem Zuweisungsoperator ':' und dem Wert in die
     Datei geschrieben.  Im Unterschied dazu, speichert die allgemeine
     Form der Funktion 'stringout' die Variablen nicht als Zuweisung.

 -- Funktion: with_stdout (<f>, <expr_1>, <expr_2>, <expr_3>, ...)
 -- Funktion: with_stdout (<s>, <expr_1>, <expr_2>, <expr_3>, ...)

     'with_stdout' wertet Argumente <expr_1>, <expr_2>, <expr_3>, ...
     aus und schreibt die Ergebnisse der Auswertung in die Ausgabedatei
     'f' oder in den Stream 's'.  Die Ergebnisse werden nicht auf der
     Konsole ausgegeben.

     Die Optionsvariable 'file_output_append' bestimmt, ob 'with_stdout'
     die Daten an die Ausgabedatei anhängt oder die Ausgabedatei zuvor
     löscht.  Hat 'file_output_append' den Wert 'true', werden die Daten
     angehängt.  Ansonsten wird die Datei gelöscht und neu angelegt.
     Existiert die Ausgabedatei noch nicht, wird diese angelegt.

     'with_stout' gibt das Ergebnis des letzten Argumentes zurück.

     Siehe auch 'writefile'.

     Beispiel:

          (%i1) with_stdout ("tmp.out", for i:5 thru 10 do
                   print (i, "! yields", i!))$
          (%i2) printfile ("tmp.out")$
          5 ! yields 120
          6 ! yields 720
          7 ! yields 5040
          8 ! yields 40320
          9 ! yields 362880
          10 ! yields 3628800

 -- Funktion: writefile (<filename>)

     Startet eine Aufzeichnung aller Ein- und Ausgaben der Konsole.  Die
     Ein- und Ausgaben werden in die Datei <filename> geschrieben.

     Die Ausgabedatei kann von Maxima nicht wieder zurückgelesen werden.
     Um ein Datei zu erzeugen, die von Maxima zurückgelesen werden kann,
     siehe die Funktionen 'save' und 'stringout'.  'save' speichert
     Ausdrücke in einem Lisp-Format und 'stringout' in einem
     Maxima-Format.

     Die Reaktion der Funktion 'writefile' für den Fall, dass die
     Ausgabedatei bereits existiert, hängt von der Lisp-Implementation
     ab.  Die Ausgabedatei kann zurückgesetzt werden oder die Daten
     werden angehängt.  Die Funktion 'appendfile' hängt die Daten immer
     an eine existierende Datei an.

     Um eine Aufzeichnung ohne Textausgaben von Funktionen zu erhalten,
     kann 'writefile' nach der Ausführung von 'playback' ausgeführt
     werden.  'playback' gibt alle vorhergenden Eingabe- und
     Ausgabemarken aus, jedoch nicht sonstige Textausgaben von
     Maxima-Funktionen.

     Mit 'closefile' wird die Aufzeichnung beendet.

