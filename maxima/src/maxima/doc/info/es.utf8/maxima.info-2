This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.


File: maxima.info,  Node: Simplificación,  Next: Funciones matemáticas,  Prev: Expresiones,  Up: Top

9 Simplificación
****************

* Menu:

* Introducción a la simplificación::
* Funciones y variables para simplificación::  


File: maxima.info,  Node: Introducción a la simplificación,  Next: Funciones y variables para simplificación,  Prev: Simplificación,  Up: Simplificación

9.1 Introducción a la simplificación
====================================

Tras la evaluación de una expresión se procede a su simplificación.  Las
funciones matemáticas que involucran cálculos simbólicos y las
expresiones con operadores aritméticos no son evaluadas, sino
simplificadas, para lo cual Maxima las representa internamente en forma
nominal; de ahí que el cálculo numérico de una suma o de una
multiplicación no se considera una evaluación, sino una simplificación.
La evaluación de una expresión puede inhibirse con el operador de
comilla simple (''') y su simplificación se puede controlar con el valor
asignado a la variable opcional 'simp'.

En el siguiente ejemplo, se evita la simplificación con el operador de
comilla simple, siendo el resultado una expresión nominal.  A
continuación, se inhibe la simplificación tras la evaluación de la
derivada, dejando sin reducir el resultado a '2*x'.

     (%i1) 'diff(x*x,x);
                                  d    2
     (%o1)                        -- (x )
                                  dx
     (%i2) simp:false;
     (%o2)                         false
     (%i3) diff(x*x,x);
     (%o3)                       1 x + 1 x

Para cada función u operador matemático dispone Maxima de una rutina
interna que será utilizada para su simplificación siempre que se la
encuentre en una expresión.  Estas rutinas implementan propiedades
simétricas, valores especiales de las funciones y otras propiedades y
reglas.  La gran cantidad de variables opcionales permiten mantener bajo
control la simplificación de funciones y operadores.

Veamos un ejemplo.  La simplificación de la función exponencial 'exp' se
controla con las siguientes variables opcionales: '%enumer', '%emode',
'%e_to_numlog', 'code', 'logsimp' y 'demoivre'.  En el primer caso la
expresión con la función exponencial no se simplifica, pero en el
segundo se reduce a '%i*%pi/2'.

     (%i1) exp(x+%i*%pi/2), %emode:false;
                                     %i %pi
                                 x + ------
                                       2
     (%o1)                     %e
     (%i2) exp(x+%i*%pi/2), %emode:true;
                                       x
     (%o2)                        %i %e

Junto con la simplificación aislada de funciones y operadores que Maxima
realiza de forma automática, existen también funciones como 'expand' o
'radcan' que realizan sobre las expresiones simplificaciones especiales.
Sigue un ejemplo:

     (%i1) (log(x+x^2)-log(x))^a/log(1+x)^(a/2);
                                2               a
                          (log(x  + x) - log(x))
     (%o1)                -----------------------
                                         a/2
                               log(x + 1)
     (%i2) radcan(%);
                                         a/2
     (%o2)                     log(x + 1)

A un operador o función se le pueden asignar propiedades tales como la
linealidad, la simetría u otras.  Maxima tiene en cuenta estas
propiedades durante la simplificación.  Por ejemplo, la instrucción
'declare(f, oddfun)' declara la función como impar, con lo que Maxima
sabrá que las formas 'f(-x)' y '-f(x)' son equivalentes, llevando a cabo
la reducción oportuna.

Las siguientes propiedades están en la lista 'opproperties' y controlan
la simplificación de funciones y operadores:

   additive        lassociative     oddfun
   antisymmetric   linear           outative
   commutative     multiplicative   rassociative
   evenfun         nary             symmetric

Tanto las propiedades como los hechos (o hipótesis) establecidos por el
usuario dentro de un contexto influyen sobre el proceso de
simplificación.  Para más detalles véase el capítulo sobre la base de
datos de Maxima.

La función seno reduce los múltiplos enteros de '%pi' al valor cero.  En
este ejemplo se muestra cómo al dotar al símbolo 'n' de la propiedad de
ser entero, la función se simplifica de la forma apropiada.

     (%i1) sin(n*%pi);
     (%o1)                      sin(%pi n)
     (%i2) declare(n, integer);
     (%o2)                         done
     (%i3) sin(n*%pi);
     (%o3)                           0

Si las técnicas anteriores no devuelven el resultado esperado por el
usuario, éste puede extender a voluntad las reglas que pueda aplicar
Maxima; para más información al respecto, véase el capítulo dedicado a
las reglas y patrones.


File: maxima.info,  Node: Funciones y variables para simplificación,  Prev: Introducción a la simplificación,  Up: Simplificación

9.2 Funciones y variables para simplificación
=============================================

 -- Propiedad: additive
     Si 'declare(f,additive)' ha sido ejecutado, entonces:

     (1) Si 'f' es univariado, cada vez que el simplificador encuentre
     'f' aplicada a una suma, 'f' será distribuida bajo esta suma.  Por
     ejemplo, 'f(x+y)' se simplificará a 'f(x)+f(y)'.

     (2) Si 'f' es una función de 2 o más argumentos, aditivamente es
     definida como aditiva en el primer argumento de 'f', como en el
     caso de 'sum' o 'integrate'.  Por ejemplo, 'f(h(x)+g(x),x)' se
     simplificará a 'f(h(x),x)+f(g(x),x)'.  Esta simplificación no
     ocurre cuando 'f' se aplica a expresiones de la forma
     'sum(x[i],i,lower-limit,upper-limit)'.

     Ejemplo:

          (%i1) F3 (a + b + c);
          (%o1)                     F3(c + b + a)
          (%i2) declare (F3, additive);
          (%o2)                         done
          (%i3) F3 (a + b + c);
          (%o3)                 F3(c) + F3(b) + F3(a)

 -- Propiedad: antisymmetric
     Si 'declare(h,antisymmetric)' es ejecutado, esto dice al
     simplificador que 'h' es antisimétrico.  E.g.  'h(x,z,y)' será
     simplificado a '-h(x,y,z)'.  Que es, el producto de (-1)^n por el
     resultado dado por 'symmetric' o 'commutative', donde n es el
     número de intercambios necesarios de dos argumentos para
     convertirle a esta forma.

     Ejemplos:

          (%i1) S (b, a);
          (%o1)                        S(b, a)
          (%i2) declare (S, symmetric);
          (%o2)                         done
          (%i3) S (b, a);
          (%o3)                        S(a, b)
          (%i4) S (a, c, e, d, b);
          (%o4)                   S(a, b, c, d, e)
          (%i5) T (b, a);
          (%o5)                        T(b, a)
          (%i6) declare (T, antisymmetric);
          (%o6)                         done
          (%i7) T (b, a);
          (%o7)                       - T(a, b)
          (%i8) T (a, c, e, d, b);
          (%o8)                   T(a, b, c, d, e)

 -- Función: combine (<expr>)
     Simplifica la suma <expr> combinando términos de con igual
     denominador reduciéndolos a un único término.

 -- Propiedad: commutative
     Si 'declare(h,commutative)' es ejecutado, le dice al simplificador
     que 'h' es una función conmutaiva.  Por ejemplo, 'h(x,z,y)' se
     simplificará a 'h(x,y,z)'.  Esto es lo mismo que 'symmetric'.

 -- Función: demoivre (<expr>)
 -- Variable opcional: demoivre

     La función 'demoivre (expr)' convierte una expresión sin modificar
     la variable global 'demoivre'.

     Cuando 'demoivre' vale 'true', los exponenciales complejos se
     convierten en expresiones equivalentes pero en términos de las
     funciones trigonométricas: 'exp (a + b*%i)' se reduce a '%e^a *
     (cos(b) + %i*sin(b))' si 'b' no contiene a '%i'.  Las expresiones
     'a' y 'b' no se expanden.

     El valor por defecto de 'demoivre' es 'false'.

     La función 'exponentialize' convierte funciones trigonométricas e
     hiperbólicas a la forma exponencial, por lo que 'demoivre' y
     'exponentialize' no pueden valer 'true' al mismo tiempo.

 -- Función: distrib (<expr>)
     Distribuye sumas sobre productos.  Difiere de 'expand' en que
     trabaja sólo al nivel superior de una expresión, siendo más rápida
     que 'expand'.  Difiere de 'multthru' en que expande todas las sumas
     del nivel superior.

     Ejemplos:

          (%i1) distrib ((a+b) * (c+d));
          (%o1)                 b d + a d + b c + a c
          (%i2) multthru ((a+b) * (c+d));
          (%o2)                 (b + a) d + (b + a) c
          (%i3) distrib (1/((a+b) * (c+d)));
                                          1
          (%o3)                    ---------------
                                   (b + a) (d + c)
          (%i4) expand (1/((a+b) * (c+d)), 1, 0);
                                          1
          (%o4)                 ---------------------
                                b d + a d + b c + a c

 -- Variable opcional: distribute_over
     Valor por defecto: 'true'

     'distribute_over' controla la distribución de funciones sobre
     estructuras como listas, matrices y ecuaciones.  Actualmente, no
     todas las funciones de Maxima tienen esta propiedad.  Es posible
     consultar si una función tiene esta propiedad con la instrucción
     'properties'.

     La propiedad distributiva se desactiva asignándole a
     'distribute_over' el valor 'false'.

     Ejemplos:

     La función 'sin' se distribuye sobre una lista:

          (%i1) sin([x,1,1.0]);
          (%o1)                 [sin(x), sin(1), .8414709848078965]

     'mod' es una función de dos argumentos que se distribuye sobre
     listas.  La distribución sobre listas anidadas también es posible.

          (%i2) mod([x,11,2*a],10);
          (%o2)                    [mod(x, 10), 1, 2 mod(a, 5)]
          (%i3) mod([[x,y,z],11,2*a],10);
          (%o3)       [[mod(x, 10), mod(y, 10), mod(z, 10)], 1, 2 mod(a, 5)]

     Distribución de la función 'floor' sobre una matriz y una ecuación.

          (%i4) floor(matrix([a,b],[c,d]));
                                      [ floor(a)  floor(b) ]
          (%o4)                       [                    ]
                                      [ floor(c)  floor(d) ]
          (%i5) floor(a=b);
          (%o5)                         floor(a) = floor(b)

     Funciones con más de un argumento se distribuyen sobre cualquiera
     de sus argumentos, o sobre todos ellos.

          (%i6) expintegral_e([1,2],[x,y]);
          (%o6) [[expintegral_e(1, x), expintegral_e(1, y)],
                 [expintegral_e(2, x), expintegral_e(2, y)]]

     Comprueba si una función tiene la propiedad 'distribute_over':

          (%i7) properties(abs);
          (%o7) [integral, distributes over bags, noun, rule, gradef]

 -- Variable opcional: domain
     Valor por defecto: 'real'

     Si 'domain' vale 'complex', 'sqrt (x^2)' permanecerá como 'sqrt
     (x^2)' en lugar de devolver 'abs(x)'.

 -- Propiedad: evenfun
 -- Propiedad: oddfun

     'declare(f, evenfun' o 'declare(f, oddfun)' indican a Maxima que
     reconozca la función 'f' como par o impar, respectivamente.

     Ejemplos:

          (%i1) o (- x) + o (x);
          (%o1)                     o(x) + o(- x)
          (%i2) declare (o, oddfun);
          (%o2)                         done
          (%i3) o (- x) + o (x);
          (%o3)                           0
          (%i4) e (- x) - e (x);
          (%o4)                     e(- x) - e(x)
          (%i5) declare (e, evenfun);
          (%o5)                         done
          (%i6) e (- x) - e (x);
          (%o6)                           0

 -- Función: expand (<expr>)
 -- Función: expand (<expr>, <p>, <n>)
     Expande la expresión <expr>.  Los productos de sumas y de sumas con
     exponentes se multiplican, los numeradores de las expresiones
     racionales que son sumas se separan en sus respectivos términos, y
     las multiplicaciones (tanto las que son conmutativas como las que
     no) se distribuyen sobre las sumas en todos los niveles de <expr>.

     En el caso de los polinomios es más aconsejable utilizar
     'ratexpand', que utiliza un algoritmo más eficiente.

     Las variables 'maxnegex' y 'maxposex' controlan los máximos
     exponentes negativos y positivos que se van a expandir.

     La llamada 'expand (<expr>, <p>, <n>)' expande <expr> asignando a
     'maxposex' el valor <p> y a 'maxnegex' el <n>.  Esto es útil para
     expandir sólo parte de la expresión.

     La variable 'expon' guarda el mayor exponente negativo que será
     expandido automáticamente, independientemente de 'expand'.  Por
     ejemplo, si 'expon' vale 4 entonces '(x+1)^(-5)' no se expandirá
     automáticamente.

     La variable 'expop' guarda el mayor exponente positivo que será
     expandido automáticamente.  Así, '(x+1)^3' se expandirá
     automáticamente sólo si 'expop' es mayor o igual que 3.  Si se
     quiere expandir '(x+1)^n', siendo 'n' mayor que 'expop', entonces
     'expand ((x+1)^n)' se desarrollará sólo si 'maxposex' no es menor
     que 'n'.

     'expand(expr, 0, 0)' provoca que se vuelva a simplificar 'expr'.
     'expr' no se vuelve a evaluar.  A diferencia de 'ev(expr, noeval)',
     se elimina la representación canónica de la expresión.  Véase
     también 'ev'.

     La variable 'expand' utilizada con 'ev' provocará una expansión.

     El fichero 'share/simplification/facexp.mac' contiene algunas
     funciones relacionadas con 'expand' (en concreto, 'facsum',
     'factorfacsum' y 'collectterms', que se cargan automáticamente) y
     variables ('nextlayerfactor' y 'facsum_combine') que permiten al
     usuario estructurar las expresiones controlando la expansión.  En
     'simplification/facexp.usg' se pueden encontrar breves
     descripciones de estas funciones.  Se accederá a una demostración
     con la instrucción 'demo("facexp")'.

     Ejemplo:

          (%i1) expr:(x+1)^2*(y+1)^3;
                                                2        3
          (%o1)                          (x + 1)  (y + 1)
          (%i2) expand(expr);
                 2  3        3    3      2  2        2      2      2
          (%o2) x  y  + 2 x y  + y  + 3 x  y  + 6 x y  + 3 y  + 3 x  y
                                                           2
                                          + 6 x y + 3 y + x  + 2 x + 1

          (%i3) expand(expr,2);
                                2        3              3          3
          (%o3)                x  (y + 1)  + 2 x (y + 1)  + (y + 1)

          (%i4) expr:(x+1)^-2*(y+1)^3;
                                                    3
                                             (y + 1)
          (%o4)                              --------
                                                    2
                                             (x + 1)
          (%i5) expand(expr);
                           3               2
                          y             3 y            3 y             1
          (%o5)      ------------ + ------------ + ------------ + ------------
                      2              2              2              2
                     x  + 2 x + 1   x  + 2 x + 1   x  + 2 x + 1   x  + 2 x + 1

          (%i6) expand(expr,2,2);
                                                    3
                                             (y + 1)
          (%o6)                            ------------
                                            2
                                           x  + 2 x + 1

     Vuelve a simplificar una expresión pero sin expansión:

          (%i7) expr:(1+x)^2*sin(x);
                                                 2
          (%o7)                           (x + 1)  sin(x)
          (%i8) exponentialize:true;
          (%o8)                                true
          (%i9) expand(expr,0,0);
                                             2    %i x     - %i x
                                   %i (x + 1)  (%e     - %e      )
          (%o9)                  - -------------------------------
                                                  2

 -- Función: expandwrt (<expr>, <x_1>, ..., <x_n>)
     Expande la expresión 'expr' con respecto a las variables <x_1>,
     ..., <x_n>.  Todos los productos que contengan a las variables
     aparecen explícitamente.  El resultado que se obtenga no tendr'a
     productos de sumas de expresiones que contengan a las variables.
     Los argumentos <x_1>, ..., <x_n> pueden ser variables, operadores o
     expresiones.

     Por defecto, no se expanden los denominadores, pero esto puede
     cambiarse mediante el uso de la variable 'expandwrt_denom'.

     Esta función se carga automáticamente de
     'simplification/stopex.mac'.

 -- Variable opcional: expandwrt_denom
     Valor por defecto: 'false'

     La variable 'expandwrt_denom' controla el tratamiento de las
     expresiones racinales por parte de 'expandwrt'.  Si vale 'true', se
     expandirán tanto el numerador como el denominador de la expresión
     respecto de los argumentos de 'expandwrt', pero si
     'expandwrt_denom' vale 'false', sólo se expandirá el numerador.

 -- Función: expandwrt_factored (<expr>, <x_1>, ..., <x_n>)
     Es similar a 'expandwrt', pero trata a las expresiones que son
     productos de una forma algo diferente.  La función
     'expandwrt_factored' expande sólo aquellos factores de 'expr' que
     contienen a las variables <x_1>, ..., <x_n>.

     Esta función se carga automáticamente de
     'simplification/stopex.mac'.

 -- Variable opcional: expon
     Valor por defecto: 0

     La variable 'expon' guarda el mayor exponente negativo que será
     expandido automáticamente, independientemente de 'expand'.  Por
     ejemplo, si 'expon' vale 4 entonces '(x+1)^(-5)' no se expandirá
     automáticamente.

 -- Función: exponentialize (<expr>)
 -- Variable opcional: exponentialize

     La función 'exponentialize (expr)' convierte las funciones
     trigonométricas e hiperbólicas de <expr> a exponenciales, sin
     alterar la variable global 'exponentialize'.

     Cuando la variable 'exponentialize' vale 'true', todas las
     funciones trigonométricas e hiperbólicas se convierten a forma
     exponencial.  El valor por defecto es 'false'.

     La función 'demoivre' convierte funciones trigonométricas e
     hiperbólicas a la forma exponencial, por lo que 'demoivre' y
     'exponentialize' no pueden valer 'true' al mismo tiempo.

 -- Variable opcional: expop
     Valor por defecto: 0

     La variable 'expop' guarda el mayor exponente positivo que será
     expandido automáticamente.  Así, '(x+1)^3' se expandirá
     automáticamente sólo si 'expop' es mayor o igual que 3.  Si se
     quiere expandir '(x+1)^n', siendo 'n' mayor que 'expop', entonces
     'expand ((x+1)^n)' se desarrollará sólo si 'maxposex' no es menor
     que 'n'.

 -- Propiedad: lassociative
     La instrucción 'declare (g, lassociative)' le indica al
     simplificador de Maxima que 'g' es asociativo por la izquierda.
     Por ejemplo, 'g (g (a, b), g (c, d))'se reduce a 'g (g (g (a, b),
     c), d)'.

 -- Propiedad: linear
     Es una de las propiedades de operadores de Maxima.  Si la función
     univariante 'f' se declara lineal, la expansión de 'f(x + y)'
     produce 'f(x) + f(y)', 'f(a*x)' produce 'a*f(x)' si 'a' es una
     constante.  Si la función tiene dos o más argumentos, la linealidad
     se interpreta como la de 'sum' o 'integrate', esto es, 'f (a*x + b,
     x)' produce 'a*f(x,x) + b*f(1,x)' si 'a' y 'b' no contienen a 'x'.

     'linear' equivale a 'additive' y 'outative'.  Véase también
     'opproperties'.

     Ejemplo:

          (%i1) 'sum (F(k) + G(k), k, 1, inf);
                                 inf
                                 ====
                                 \
          (%o1)                   >    (G(k) + F(k))
                                 /
                                 ====
                                 k = 1
          (%i2) declare (nounify (sum), linear);
          (%o2)                         done
          (%i3) 'sum (F(k) + G(k), k, 1, inf);
                               inf          inf
                               ====         ====
                               \            \
          (%o3)                 >    G(k) +  >    F(k)
                               /            /
                               ====         ====
                               k = 1        k = 1

 -- Variable opcional: maxnegex
     Valor por defecto: 1000

     La variable 'maxnegex' es el mayor exponente negativo que expandirá
     la función 'expand'.  Véase también 'maxposex'.

 -- Variable opcional: maxposex
     Valor por defecto: 1000

     La variable 'maxposex' es el mayor exponenteque expandirá la
     función 'expand'.  Véase también 'maxnegex'.

 -- Propiedad: multiplicative
     La instrucción 'declare (f, multiplicative)' indica al
     simplificador de Maxima que 'f' is multiplicativa.

       1. Si 'f' es univariante, cada vez que el simplificador encuentre
          a 'f' aplicad a un producto, 'f' se distribuirá sobre ese
          producto.  Por ejemplo, 'f(x*y)' se reduciría a 'f(x)*f(y)'.
       2. Si 'f' es una función de 2 o más argumentos, la
          multiplicabilidad se define como multiplicabilidad para el
          primer argumento de 'f', de modo que 'f (g(x) * h(x), x)' se
          reduciría a 'f (g(x) ,x) * f (h(x), x)'.

     Esta transformación no se realiza cuando 'f' se aplica a
     expresiones de la forma 'product (x[i], i, m, n)'.

     Ejemplo:

          (%i1) F2 (a * b * c);
          (%o1)                       F2(a b c)
          (%i2) declare (F2, multiplicative);
          (%o2)                         done
          (%i3) F2 (a * b * c);
          (%o3)                   F2(a) F2(b) F2(c)

 -- Función: multthru (<expr>)
 -- Función: multthru (<expr_1>, <expr_2>)
     Multiplica un factor (que debería ser una suma) de <expr> por los
     otros factores de <expr>.  Esto es, <expr> es '<f_1> <f_2> ...
     <f_n>', donde al menos un factor, por ejemplo <f_i>, es una suma de
     términos.  Cada término en esta suma se multiplica por los otros
     factores del producto, excepto el propio <f_i>.  La función
     'multthru' no expande sumas elevadas a exponentes, siendo el método
     más rápido para distribuir productos (sean o no conmutativos) sobre
     sumas.  Puesto que los cocientes se representan como productos,
     puede utilizarse'multthru' para dividir sumas entre productos.

     La llamada 'multthru (<expr_1>, <expr_2>)' multiplica cada término
     de <expr_2> (que debería ser una suma o una ecuación) por <expr_1>.
     Si <expr_1> no es ella misma una suma, entonces la llamada es
     equivalente a 'multthru (<expr_1>*<expr_2>)'.

          (%i1) x/(x-y)^2 - 1/(x-y) - f(x)/(x-y)^3;
                                1        x         f(x)
          (%o1)             - ----- + -------- - --------
                              x - y          2          3
                                      (x - y)    (x - y)
          (%i2) multthru ((x-y)^3, %);
                                     2
          (%o2)             - (x - y)  + x (x - y) - f(x)
          (%i3) ratexpand (%);
                                     2
          (%o3)                   - y  + x y - f(x)
          (%i4) ((a+b)^10*s^2 + 2*a*b*s + (a*b)^2)/(a*b*s^2);
                                  10  2              2  2
                           (b + a)   s  + 2 a b s + a  b
          (%o4)            ------------------------------
                                            2
                                       a b s
          (%i5) multthru (%);  /* note that this does not expand (b+a)^10 */
                                                  10
                                 2   a b   (b + a)
          (%o5)                  - + --- + ---------
                                 s    2       a b
                                     s
          (%i6) multthru (a.(b+c.(d+e)+f));
          (%o6)            a . f + a . c . (e + d) + a . b
          (%i7) expand (a.(b+c.(d+e)+f));
          (%o7)         a . f + a . c . e + a . c . d + a . b

 -- Propiedad: nary

     'declare(f, nary)' le indica a Maxima que reconozca la función 'f'
     como n-aria.

     La declaración 'nary' no equivale a invocar la función
     'function_nary, nary'.  El único efecto de 'declare(f, nary)' es
     indicar al simplificador de Maxima que aplane expresiones anidadas,
     como simplificar 'foo(x, foo(y, z))' a 'foo(x, y, z)'.  Véase
     también 'declare'.

     Ejemplo:

          (%i1) H (H (a, b), H (c, H (d, e)));
          (%o1)               H(H(a, b), H(c, H(d, e)))
          (%i2) declare (H, nary);
          (%o2)                         done
          (%i3) H (H (a, b), H (c, H (d, e)));
          (%o3)                   H(a, b, c, d, e)

 -- Variable opcional: negdistrib
     Valor por defecto: 'true'

     Si 'negdistrib' vale 'true', -1 se distribuye sobre una expresión.
     Por ejemplo, '-(x + y)' se transforma en '- y - x'.  Dándole el
     valor 'false' se mostrará '- (x + y)' tal cual.  Esto puede ser
     útil, pero también peligroso; al igual que el indicador 'simp', no
     conviene asignarle el valor 'false'.

 -- Variable del sistema: opproperties

     La variable 'opproperties' es la lista con las propiedades
     especiales de los operadores reconocidas por el simplificador de
     Maxima: 'linear', 'additive', 'multiplicative', 'outative',
     'evenfun', 'oddfun', 'commutative', 'symmetric', 'antisymmetric',
     'nary', 'lassociative', 'rassociative'.

 -- Propiedad: outative
     La instrucción 'declare (f, outative)' le indica al simplificador
     de Maxima que los factores constantes del argumento de la función
     'f' pueden ser extraídos.

       1. Si 'f' es univariante, cada vez que el simplificador se
          encuentra con 'f' aplicada a un producto, éste será
          particionado en factores que son constantes y factores que no
          lo son, siendo entonces los constantes extraídos de la
          función.  Por ejemplo, 'f(a*x)' se reducirá a 'a*f(x)' siendo
          'a' una constante.  Las constantes no atómicas no serán
          extraídas.
       2. Si 'f' es una función de 2 o más argumentos, esta propiedad se
          define como en 'sum' o 'integrate', esto es, 'f (a*g(x), x)'
          se reducirá a 'a * f(g(x), x)' si 'a' no contiene a 'x'.

     Las funciones 'sum', 'integrate' y 'limit' han sido todas
     declaradas con la propiedad 'outative'.

     Ejemplo:

          (%i1) F1 (100 * x);
          (%o1)                       F1(100 x)
          (%i2) declare (F1, outative);
          (%o2)                         done
          (%i3) F1 (100 * x);
          (%o3)                       100 F1(x)
          (%i4) declare (zz, constant);
          (%o4)                         done
          (%i5) F1 (zz * y);
          (%o5)                       zz F1(y)

 -- Función: radcan (<expr>)
     Simplifica la expresión <expr>, que puede contener logaritmos,
     exponenciales y radicales, convirtiéndola a una forma canónica, lo
     que significa que todas las expresiones funcionalmente equivalentes
     se reducen a una forma única.  Ciertas expresiones, sin embargo,
     son reducidas por 'radcan' a una forma regular, lo que significa
     que dos expresiones equivalentes no tienen necesariamente el mismo
     aspecto, pero su diferencia puede ser reducida por 'radcan' a cero.

     Con algunas expresiones 'radcan' puede consunir mucho tiempo.  Este
     es el coste por explorar ciertas relaciones entre las componentes
     de la expresión para simplificaciones basadas en factorizaciones y
     expansiones parciales de fracciones de exponentes.

     Ejemplos:

          (%i1) radcan((log(x+x^2)-log(x))^a/log(1+x)^(a/2));
                                                     a/2
          (%o1)                            log(x + 1)

          (%i2) radcan((log(1+2*a^x+a^(2*x))/log(1+a^x)));
          (%o2)                                  2

          (%i3) radcan((%e^x-1)/(1+%e^(x/2)));
                                               x/2
          (%o3)                              %e    - 1

 -- Variable opcional: radexpand
     Valor por defecto: 'true'

     La variable 'radexpand' controla algunas simplificaciones de
     radicales.

     Si 'radexpand' vale 'all', las raíces <n>-ésimas de los factores de
     un producto que sean potencias de <n> se extraen del símbolo
     radical.  Por ejemplo, si 'radexpand' vale 'all', 'sqrt (16*x^2)'
     se reduce a '4*x'.

     Más concretamente, considérese 'sqrt (x^2)'.
        * Si 'radexpand' vale 'all' o se ha ejecutado 'assume (x > 0)',
          'sqrt(x^2)' se reduce a 'x'.
        * Si 'radexpand' vale 'true' y 'domain' es 'real' (su valor por
          defecto), 'sqrt(x^2)' se reduce a 'abs(x)'.
        * Si 'radexpand' vale 'false' o 'radexpand' vale 'true' y
          'domain' es 'complex', 'sqrt(x^2)' no se simplifica.

     Nótese que 'domain' sólo se tiene en cuenta si 'radexpand' vale
     'true'.

 -- Propiedad: rassociative
     La instrucción 'declare (g, rassociative)' le indica al
     simplificador de Maxima que 'g' es asociativa por la derecha.  Por
     ejemplo, 'g(g(a, b), g(c, d))' se reduce a 'g(a, g(b, g(c, d)))'.

 -- Función: scsimp (<expr>, <rule_1>, ..., <rule_n>)
     Es el "Sequential Comparative Simplification" (método debido a
     Stoute).  La función 'scsimp' intenta simplificar <expr> de acuerdo
     con las reglas <rule_1>, ..., <rule_n>.  Si se obtiene una
     expresión más pequeña, el proceso se repite.  En caso contrario,
     después de que se hayan intentado todas las simplificaciones,
     devuelve la respuesta original.

     La instrucción 'example (scsimp)' muestra algunos ejemplos.

 -- Variable opcional: simp
     Valor por defecto: 'true'

     La variable 'simp' activa y desactiva la simplificación.  La
     simplificación está activada por defecto.  La variable 'simp'
     también es reconocida por la función 'ev' como variable de entorno.
     Véase también 'ev'.

     Cuando 'simp' se utiliza en un entorno 'ev' con el valor 'false',
     la simplificación se evita sólo durante la fase de evaluación de
     una expresión.  La variable no evita la simplificación que sigue a
     la fase de evaluación.

     Ejemplos:

     La simplificación se suspende globalmente.  La expresión 'sin(1.0)'
     no se simplifica a su valor numérico.  La variable de entorno
     'simp' conmuta el estado de la simplificación.

          (%i1) simp:false;
          (%o1)                                false
          (%i2) sin(1.0);
          (%o2)                              sin(1.0)
          (%i3) sin(1.0),simp;
          (%o3)                          .8414709848078965

     La simplificación se vuelve a activar.  La variable de entorno
     'simp' no puede suprimir totalmente la simplificación.  El
     resultado muestra una expresión simplificada, pero la variable 'x'
     guarda como valor una expresión sin simplificar, porque la
     asignación se realizó durante la fase de evaluación de la
     expresión.

          (%i4) simp:true;
          (%o4)                                true
          (%i5) x:sin(1.0),simp:false;
          (%o5)                          .8414709848078965
          (%i6) :lisp $X
          ((%SIN) 1.0)

 -- Propiedad: symmetric
     La instrucción 'declare (h, symmetric)' le indica al simplificador
     de Maxima que 'h' es una función simétrica.  Por ejemplo, 'h (x, z,
     y)' se reduce a 'h (x, y, z)'.

     El nombre 'commutative' es sinónimo de 'symmetric'.

 -- Función: xthru (<expr>)
     Combina todos los términos de <expr> (la cual debe ser una suma)
     sobre un común denominador sin expandir productos ni sumas elevadas
     a exponentes al modo que lo hace 'ratsimp'.  La función 'xthru'
     cancela factores comunes en el numerador y denominador de
     expresiones racionales, pero sólo si los factores son explícitos.

     En ocasiones puede ser útil el uso de 'xthru' antes de la llamada a
     'ratsimp' a fin de cancelar factores explícitos del máximo común
     divisor del numerador y denominador y así simplificar la expresión
     a la que se va a aplicar 'ratsimp'.

          (%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
           xthru (%);
                                          20
                           1       (x + 2)   - 2 y       x
          (%o1)        --------- + --------------- - ---------
                              19             20             20
                       (y + x)        (y + x)        (y + x)


File: maxima.info,  Node: Funciones matemáticas,  Next: Base de datos de Maxima,  Prev: Simplificación,  Up: Top

10 Funciones matemáticas
************************

* Menu:

* Funciones para los números::
* Funciones para los números complejos::
* Funciones combinatorias::
* Funciones radicales exponenciales y logarítmicas::
* Funciones trigonométricas::
* Números aleatorios::


File: maxima.info,  Node: Funciones para los números,  Next: Funciones para los números complejos,  Prev: Funciones matemáticas,  Up: Funciones matemáticas

10.1 Funciones para los números
===============================

 -- Función: abs (<z>)
     La función 'abs' representa el valor absoluto y se puede aplicar
     tanto a argumentos numéricos como simbólicos.  Si el argumento <z>
     es un número real o complejo, 'abs' devuelve el valor absoluto de
     <z>.  Si es posible, las expresiones simbólicas que utilizan la
     función del valor absoluto también se simplifican.

     Maxima puede derivar, integrar y calcular límites de expresiones
     que contengan a 'abs'.  El paquete 'abs_integrate' extiende las
     capacidades de Maxima para calcular integrales que contengan
     llamadas a 'abs'.  Véase '(%i12)' en el ejemplo de más abajo.

     Cuando se aplica a una lista o matriz, 'abs' se distribuye
     automáticamente sobre sus elementos.  De forma similar, también se
     distribuye sobre los dos miembros de una igualdad.  Para cambiar
     este comportamiento por defecto, véase la variable
     'distribute_over'.

     Ejemplos:

     Cálculo del valor absoluto de números reales y complejos,
     incluyendo constantes numéricas e infinitos.  El primer ejemplo
     muestra cómo 'abs' se distribuye sobre los elementos de una lista.

          (%i1) abs([-4, 0, 1, 1+%i]);
          (%o1)                  [4, 0, 1, sqrt(2)]

          (%i2) abs((1+%i)*(1-%i));
          (%o2)                           2
          (%i3) abs(%e+%i);
                                          2
          (%o3)                    sqrt(%e  + 1)
          (%i4) abs([inf, infinity, minf]);
          (%o4)                   [inf, inf, inf]

     Simplificación de expresiones que contienen 'abs':

          (%i5) abs(x^2);
                                          2
          (%o5)                          x
          (%i6) abs(x^3);
                                       2
          (%o6)                       x  abs(x)

          (%i7) abs(abs(x));
          (%o7)                       abs(x)
          (%i8) abs(conjugate(x));
          (%o8)                       abs(x)

     Integrando y derivando con la función 'abs'.  Nótese que se pueden
     calcular más integrales que involucren la función 'abs' si se carga
     el paquete 'abs_integrate'.  El último ejemplo muestra la
     transformada de Laplace de 'abs'.  Véase 'laplace'.

          (%i9) diff(x*abs(x),x),expand;
          (%o9)                       2 abs(x)

          (%i10) integrate(abs(x),x);
                                       x abs(x)
          (%o10)                       --------
                                          2

          (%i11) integrate(x*abs(x),x);
                                     /
                                     [
          (%o11)                     I x abs(x) dx
                                     ]
                                     /

          (%i12) load(abs_integrate)$
          (%i13) integrate(x*abs(x),x);
                                2           3
                               x  abs(x)   x  signum(x)
          (%o13)               --------- - ------------
                                   2            6

          (%i14) integrate(abs(x),x,-2,%pi);
                                         2
                                      %pi
          (%o14)                      ---- + 2
                                       2

          (%i15) laplace(abs(x),x,s);
                                         1
          (%o15)                         --
                                          2
                                         s

 -- Función: ceiling (<x>)
     Si <x> es un número real, devuelve el menor entero mayor o igual
     que <x>.

     Si <x> es una expresión constante (por ejemplo, '10 * %pi'),
     'ceiling' evalúa <x> haciendo uso de números grandes en coma
     flotante (big floats), aplicando a continuación 'ceiling' al número
     decimal obtenido.  Puesto que 'ceiling' hace evaluaciones en coma
     flotante, es posible, pero improbable, que esta función devuelva un
     valor erróneo para entradas constantes.  Para evitar estos errores,
     la evaluación en punto flotante se lleva a cabo utilizando tres
     valores para 'fpprec'.

     Para argumentos no constantes, 'ceiling' intenta devolver un valor
     simplificado.  Aquí se presentan algunos ejemplos sobre las
     simplificaciones que 'ceiling' es capaz de hacer:

          (%i1) ceiling (ceiling (x));
          (%o1)                      ceiling(x)
          (%i2) ceiling (floor (x));
          (%o2)                       floor(x)
          (%i3) declare (n, integer)$
          (%i4) [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
          (%o4)                [n, abs(n), max(n, 6)]
          (%i5) assume (x > 0, x < 1)$
          (%i6) ceiling (x);
          (%o6)                           1
          (%i7) tex (ceiling (a));
          $$\left \lceil a \right \rceil$$
          (%o7)                                false

     La función 'ceiling' no se extiende automáticamente a los elementos
     de listas y matrices.  Por último, para todos los argumentos que
     tengan una forma compleja, 'ceiling' devuelve una forma nominal.

     Si el rango de una función es subconjunto de los números enteros,
     entonces puede ser declarada como 'integervalued'.  Tanto 'ceiling'
     como 'floor' son funciones que hacen uso de esta información; por
     ejemplo:

          (%i1) declare (f, integervalued)$
          (%i2) floor (f(x));
          (%o2)                         f(x)
          (%i3) ceiling (f(x) - 1);
          (%o3)                       f(x) - 1

     Ejemplo de uso:

          (%i1) unitfrac(r) := block([uf : [], q],
              if not(ratnump(r)) then
                 error("unitfrac: argument must be a rational number"),
              while r # 0 do (
                  uf : cons(q : 1/ceiling(1/r), uf),
                  r : r - q),
              reverse(uf))$
          (%i2) unitfrac (9/10);
                                      1  1  1
          (%o2)                      [-, -, --]
                                      2  3  15
          (%i3) apply ("+", %);
                                         9
          (%o3)                          --
                                         10
          (%i4) unitfrac (-9/10);
                                            1
          (%o4)                       [- 1, --]
                                            10
          (%i5) apply ("+", %);
                                          9
          (%o5)                         - --
                                          10
          (%i6) unitfrac (36/37);
                                  1  1  1  1    1
          (%o6)                  [-, -, -, --, ----]
                                  2  3  8  69  6808
          (%i7) apply ("+", %);
                                         36
          (%o7)                          --
                                         37

 -- Función: entier (<x>)
     Devuelve el mayor entero menor o igual a <x>, siendo <x> numérico.
     La función 'fix' (como en 'fixnum') es un sinónimo, de modo que
     'fix(<x>)' hace justamente lo mismo.

 -- Función: floor (<x>)

     Si <x> es un número real, devuelve el mayor entero menor o igual
     que <x>.

     Si <x> es una expresión constante (por ejemplo, '10 * %pi'),
     'floor' evalúa <x> haciendo uso de números grandes en coma flotante
     (big floats), aplicando a continuación 'floor' al número decimal
     obtenido.  Puesto que 'floor' hace evaluaciones en coma flotante,
     es posible, pero improbable, que esta función devuelva un valor
     erróneo para entradas constantes.  Para evitar estos errores, la
     evaluación en punto flotante se lleva a cabo utilizando tres
     valores para 'fpprec'.

     Para argumentos no constantes, 'floor' intenta devolver un valor
     simplificado.  Aquí se presentan algunos ejemplos sobre las
     simplificaciones que 'floor' es capaz de hacer:

          (%i1) floor (ceiling (x));
          (%o1)                      ceiling(x)
          (%i2) floor (floor (x));
          (%o2)                       floor(x)
          (%i3) declare (n, integer)$
          (%i4) [floor (n), floor (abs (n)), floor (min (n, 6))];
          (%o4)                [n, abs(n), min(n, 6)]
          (%i5) assume (x > 0, x < 1)$
          (%i6) floor (x);
          (%o6)                           0
          (%i7) tex (floor (a));
          $$\left \lfloor a \right \rfloor$$
          (%o7)                         false

     La función 'floor' no se extiende automáticamente a los elementos
     de listas y matrices.  Por último, para todos los argumentos que
     tengan una forma compleja, 'floor' devuelve una forma nominal.

     Si el rango de una función es subconjunto de los números enteros,
     entonces puede ser declarada como 'integervalued'.  Tanto 'ceiling'
     como 'floor' son funciones que hacen uso de esta información; por
     ejemplo:

          (%i1) declare (f, integervalued)$
          (%i2) floor (f(x));
          (%o2)                         f(x)
          (%i3) ceiling (f(x) - 1);
          (%o3)                       f(x) - 1

 -- Función: fix (<x>)
     Es un sinónimo de 'entier (<x>)'.

 -- Función: lmax (<L>)

     Si <L> es una lista o conjunto, devuelve 'apply ('max, args
     (<L>))'.  Si <L> no es una lista o conjunto, envía un mensaje de
     error.

 -- Función: lmin (<L>)

     Si <L> es una lista o conjunto, devuelve 'apply ('min, args
     (<L>))'.  Si <L> no es una lista o conjunto, envía un mensaje de
     error.

 -- Función: max (<x_1>, ..., <x_n>)
     Devuelve un valor simplificado de la mayor de las expresiones desde
     <x_1> hasta <x_n>.  Si 'get (trylevel, maxmin)' es 2 o más, 'max'
     aplica la simplificación 'max (e, -e) --> |e|'.  Si 'get (trylevel,
     maxmin)' es 3 o más, <max> intenta eliminar las expresiones que
     estén entre otros dos de los argumentos dados; por ejemplo, 'max
     (x, 2*x, 3*x) --> max (x, 3*x)'.  Para asignar el valor 2 a
     'trylevel' se puede hacer 'put (trylevel, 2, maxmin)'.

 -- Función: min (<x_1>, ..., <x_n>)
     Devuelve un valor simplificado de la menor de las expresiones desde
     <x_1> hasta <x_n>.  Si 'get (trylevel, maxmin)' es 2 o más, 'min'
     aplica la simplificación 'min (e, -e) --> |e|'.  Si 'get (trylevel,
     maxmin)' es 3 o más, <min> intenta eliminar las expresiones que
     estén entre otros dos de los argumentos dados; por ejemplo, 'min
     (x, 2*x, 3*x) --> min (x, 3*x)'.  Para asignar el valor 2 a
     'trylevel' se puede hacer 'put (trylevel, 2, maxmin)'.

 -- Función: round (<x>)
     Si <x> es un número real, la función devuelve el entero más próximo
     a <x>.  Los múltiplos de 1/2 se redondean al entero par más
     próximo.  La evaluación de <x> es similar a 'floor' y 'ceiling'.

 -- Función: signum (<x>)
     Tanto sea <x> real o complejo, la función 'signum' devuelve 0 si
     <x> es cero.  Para un valor no nulo de <x>, la función devuelve
     'x/abs(x)'.

     Para valores no numéricos de <x>, Maxima intenta determinar el
     signo del argumento.  Cuando es negativo, cero o positivo, 'signum'
     devuelve -1, 0 o 1, respectivamente.  En caso de no poder
     determinarse, 'signum' devuelve una forma simplificada equivalente.
     Estas simplificaciones incluyen la transformación de 'signum(-x)'
     en '-signum(x)' y la de 'signum(x*y)' en 'signum(x) * signum(y)'.

     La función 'signum' es distributiva respecto de listas, matrices o
     ecuaciones.  Véase 'distribute_over'.


File: maxima.info,  Node: Funciones para los números complejos,  Next: Funciones combinatorias,  Prev: Funciones para los números,  Up: Funciones matemáticas

10.2 Funciones para los números complejos
=========================================

 -- Función: cabs (<expr>)
     Calcula el valor absoluto de una expresión que representa a un
     número complejo.  Al contrario que 'abs', la función 'cabs' siempre
     descompone su argumento en sus partes real e imaginaria.  Si 'x' e
     'y' representan variables o expresiones reales, la función 'cabs'
     calcula el valor absoluto de 'x + %i*y' como
                                     2    2
                               sqrt(y  + x )

     La función 'cabs' puede utilizar propiedades como la simetría de
     funciones complejas para calcular el valor absoluto de una
     expresión.

     'cabs' no es una función apropiada para cálculos simbólicos; en
     tales casos, que incluyen la integración, diferenciación y límites
     que contienen valores absolutos, es mejor utilizar 'abs'.

     El resultado devuelto por 'cabs' puede incluir la función de valor
     absoluto, 'abs', y el arco tangente, 'atan2'.

     Cuando se aplica a una lista o matriz, 'cabs' automáticamente se
     distribuye sobre sus elementos.  También se distribuye sobre los
     dos miembros de una igualdad.

     Para otras formas de operar con números complejos, véanse las
     funciones 'rectform', 'realpart', 'imagpart', 'carg', 'conjugate' y
     'polarform'.

     Ejemplos:

     Ejemplos con 'sqrt' and 'sin':

          (%i1) cabs(sqrt(1+%i*x));
                                       2     1/4
          (%o1)                      (x  + 1)
          (%i2) cabs(sin(x+%i*y));
                              2        2         2        2
          (%o2)       sqrt(cos (x) sinh (y) + sin (x) cosh (y))

     La simetría especular de la función de error 'erf' se utiliza para
     calcular el valor absoluto del argumento complejo:

          (%i3) cabs(erf(x+%i*y));
                                                    2
                     (erf(%i y + x) - erf(%i y - x))
          (%o3) sqrt(--------------------------------
                                    4
                                                                         2
                                          (erf(%i y + x) + erf(%i y - x))
                                        - --------------------------------)
                                                         4

     Dado que Maxima reconoce algunas identidades complejas de las
     funciones de Bessel, le permite calcular su valor absoluto cuando
     tiene argumentos complejos.  Un ejemplo para 'bessel_j':

          (%i4) cabs(bessel_j(1,%i));
          (%o4)                 abs(bessel_j(1, %i))

 -- Función: carg (<z>)
     Devuelve el argumento complejo de <z>.  El argumento complejo es un
     ángulo 'theta' en '(-%pi, %pi]' tal que 'r exp (theta %i) = <z>'
     donde 'r' es la magnitud de <z>.

     La función 'carg' es computacional, no simplificativa.

     Véanse también 'abs' (módulo complejo), 'polarform', 'rectform',
     'realpart' y 'imagpart'.

     Ejemplos:

          (%i1) carg (1);
          (%o1)                           0
          (%i2) carg (1 + %i);
                                         %pi
          (%o2)                          ---
                                          4
          (%i3) carg (exp (%i));
          (%o3)                           1
          (%i4) carg (exp (%pi * %i));
          (%o4)                          %pi
          (%i5) carg (exp (3/2 * %pi * %i));
                                          %pi
          (%o5)                         - ---
                                           2
          (%i6) carg (17 * exp (2 * %i));
          (%o6)                           2

 -- Función: conjugate (<x>)
     Devuelve el conjugado complejo de <x>.

          (%i1) declare ([aa, bb], real, cc, complex, ii, imaginary);

          (%o1)                         done
          (%i2) conjugate (aa + bb*%i);

          (%o2)                      aa - %i bb
          (%i3) conjugate (cc);

          (%o3)                     conjugate(cc)
          (%i4) conjugate (ii);

          (%o4)                         - ii
          (%i5) conjugate (xx + yy);

          (%o5)             conjugate(yy) + conjugate(xx)

 -- Función: imagpart (<expr>)
     Devuelve la parte imaginaria de la expresión <expr>.

     La función 'imagpart' es computacional, no simplificativa.

     Véanse también 'abs', 'carg', 'polarform', 'rectform' y 'realpart'.

 -- Función: polarform (<expr>)
     Devuelve una expresión de la forma 'r %e^(%i theta)' equivalente a
     <expr>, con 'r' y 'theta' son reales.

 -- Función: realpart (<expr>)
     Devuelve la parte real de <expr>.  La funciones 'realpart' y
     'imagpart' operan también con expresiones que contengan funciones
     trigonométricas e hiperbólicas, raíces cuadradas, logaritmos y
     exponentes.

 -- Función: rectform (<expr>)
     Devuelve una expresión de la forma 'a + b %i' equivalente a <expr>,
     con <a> y <b> reales.


File: maxima.info,  Node: Funciones combinatorias,  Next: Funciones radicales exponenciales y logarítmicas,  Prev: Funciones para los números complejos,  Up: Funciones matemáticas

10.3 Funciones combinatorias
============================

 -- Operador: !!
     El operador doble factorial.

     Para un número entero, de punto flotante o racional 'n', 'n!!' se
     evaluará como el producto de 'n (n-2) (n-4) (n-6) ... (n - 2
     (k-1))' donde 'k' es igual a 'entier(n/2)', que es, el mayor entero
     menor o igual a 'n/2'.  Note que esta definición no coincide con
     otras definciones publicadas para argumentos, los cuales no son
     enteros.

     Para un entero par (o impar) 'n', 'n!' se evalua el producto de
     todos los enteros pares (o impares) consecutivos desde 2 (o 1) por
     'n' inclusive.

     Para un argumento 'n' el cual no es un número entero, punto
     flotante o racional, 'n!!' produce una forma de nombre 'genfact (n,
     n/2, 2)'.

 -- Función: binomial (<x>, <y>)
     Es el coeficiente binomial '<x>!/(<y>! (<x> - <y>)!)'.  Si <x> y
     <y> son enteros, entonces se calcula el valor numérico del
     coeficiente binomial.  Si <y> o <x - y> son enteros, el coeficiente
     binomial se expresa como un polinomio.

     Ejemplos:

          (%i1) binomial (11, 7);
          (%o1)                          330
          (%i2) 11! / 7! / (11 - 7)!;
          (%o2)                          330
          (%i3) binomial (x, 7);
                  (x - 6) (x - 5) (x - 4) (x - 3) (x - 2) (x - 1) x
          (%o3)   -------------------------------------------------
                                        5040
          (%i4) binomial (x + 7, x);
                (x + 1) (x + 2) (x + 3) (x + 4) (x + 5) (x + 6) (x + 7)
          (%o4) -------------------------------------------------------
                                         5040
          (%i5) binomial (11, y);
          (%o5)                    binomial(11, y)

 -- Función: factcomb (<expr>)
     Trata de combinar los coeficientes de los factoriales de <expr> con
     los mismos factoriales, convirtiendo, por ejemplo, '(n + 1)*n!' en
     '(n + 1)!'.

     Si la variable 'sumsplitfact' vale 'false' hará que 'minfactorial'
     se aplique después de 'factcomb'.

 -- Función: factorial (<x>)
 -- Operador: !

     Representa la función factorial.  Maxima considera 'factorial
     (<x>)' y '<x>!' como sinónimos.

     Para cualquier número complejo 'x', excepto para enteros negativos,
     'x!' se define como 'gamma(x+1)'.

     Para un entero 'x', 'x!' se reduce al producto de los enteros desde
     1 hasta 'x' inclusive.  '0!' se reduce a 1.  Para un número real o
     complejo en formato de coma flotante 'x', 'x!' se reduce al valor
     de 'gamma(x+1)'.  Cuando 'x' es igual a 'n/2', siendo 'n' un entero
     impar, entonces 'x!' se reduce a un factor racional multiplicado
     por 'sqrt(%pi)' (pues 'gamma(1/2)') es igual a 'sqrt(%pi)').

     Las variables opcionales 'factlim' y 'gammalim' controlan la
     evaluación numérica de factoriales de argumentos enteros y
     racionales.

     Las funciones 'minfactorial' y 'factcomb' simplifican expresiones
     que contiene factoriales.

     Véanse también 'factlim', 'gammalim', 'minfactorial' y 'factcomb'.

     Las funciones 'gamma', 'bffac' y 'cbffac' son variaciones de la
     función matemática gamma.  Las funciones 'bffac' y 'cbffac' son
     llamadas internamente desde 'gamma' para evaluar la función gamma
     de números reales y complejos decimales con precisión de reales
     grandes (bigfloats).

     Las funciones 'makegamma' substituye a 'gamma' para factoriales y
     funciones relacionadas.

     Maxima reconoce la derivada de la función factorial y los límites
     para ciertos valores específicos, tales como los enteros negativos.

     La variable opcional 'factorial_expand' controla la simplificación
     de expresiones como '(n+x)!', para 'n' entero.

     Véase también 'binomial'.

     Ejemplos:

     El factorial de un entero se reduce a un número exacto, a menos que
     el argumento sea mayor que 'factlim'.  Los factoriales de números
     reales o complejos se evalúan como decimales de coma flotante.

          (%i1) factlim:10;
          (%o1)                                 10
          (%i2) [0!, (7/2)!, 8!, 20!];
                                      105 sqrt(%pi)
          (%o2)                   [1, -------------, 40320, 20!]
                                           16
          (%i3) [4.77!, (1.0+%i)!];
          (%o3)    [81.44668037931197,
                    .3430658398165454 %i + .6529654964201665]
          (%i4) [2.86b0!, (1.0b0+%i)!];
          (%o4) [5.046635586910012b0,
                 3.430658398165454b-1 %i + 6.529654964201667b-1]

     El factorial de una constante conocida o de una expresión general
     no se calcula.  Pero puede ser posible reducir el factorial después
     de evaluado el argumento.

          (%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
          (%o1)      [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
          (%i2) ev (%, numer, %enumer);
          (%o2) [.3430658398165454 %i + .6529654964201665,
                 7.188082728976031,
                 4.260820476357003, 1.227580202486819]

     Los factoriales son simplificados o reducidos, no evaluados.  Así
     'x!' puede ser reemplazado en una expresión nominal.

          (%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
                    105 sqrt(%pi)
          (%o1) [1, -------------, 81.44668037931199, 40320,
                         16
                                       2432902008176640000]

     Maxima reconoce la derivada de la función factorial.

          (%i1) diff(x!,x);
          (%o1)                           x! psi (x + 1)
                                                0

     La variable opcional 'factorial_expand' controla la simplificación
     de expresiones con la función factorial.

          (%i1) (n+1)!/n!,factorial_expand:true;
          (%o1)                                n + 1

 -- Variable opcional: factlim
     Valor por defecto: -1

     La variable 'factlim' especifica el mayor factorial que será
     expandido automáticamente.  Si su valor es -1, entonces se
     expandirán todos los enteros.

 -- Variable opcional: factorial_expand
     Valor por defecto: false

     La variable 'factorial_expand' controla la simplificación de
     expresiones tales como '(n+1)!', siendo 'n' un entero.

     Véase '!' para un ejemplo.

 -- Función: genfact (<x>, <y>, <z>)
     Devuelve el factorial generalizado, definido como 'x (x-z) (x - 2
     z) ... (x - (y - 1) z)'.  Así, para el entero <x>, 'genfact (x, x,
     1) = x!' y 'genfact (x, x/2, 2) = x!!'.

 -- Función: minfactorial (<expr>)

     Busca en <expr> la presencia de dos factoriales que solo se
     diferencien en una unidad; en tal caso, 'minfactorial' devuelve una
     expresión simplificada.

          (%i1) n!/(n+2)!;
                                         n!
          (%o1)                       --------
                                      (n + 2)!
          (%i2) minfactorial (%);
                                          1
          (%o2)                    ---------------
                                   (n + 1) (n + 2)

 -- Variable opcional: sumsplitfact
     Valor por defecto: 'true'

     Si 'sumsplitfact' vale 'false', 'minfactorial' se aplica después de
     'factcomb'.


File: maxima.info,  Node: Funciones radicales exponenciales y logarítmicas,  Next: Funciones trigonométricas,  Prev: Funciones combinatorias,  Up: Funciones matemáticas

10.4 Funciones radicales, exponenciales y logarítmicas
======================================================

 -- Variable opcional: %e_to_numlog
     Valor por defecto: 'false'

     Si '%e_to_numlog' vale 'true', 'r' es un número racional y 'x' una
     expresión, '%e^(r*log(x))' se reduce a 'x^r' .  Téngase en cuenta
     que la instrucción 'radcan' también hace este tipo de
     transformaciones, así como otras más complicadas.  La instrucción
     'logcontract' "contrae" expresiones que contienen algún 'log'.

 -- Variable opcional: %emode
     Valor por defecto: 'true'

     Si '%emode' vale 'true', '%e^(%pi %i x)' se simplifica como sigue.

     '%e^(%pi %i x)' se simplifica a 'cos (%pi x) + %i sin (%pi x)' si
     'x' es un número decimal de coma flotante, un entero o un múltiplo
     de 1/2, 1/3, 1/4 o 1/6, y luego se sigue simplificando.

     Para otros valores numéricos de 'x', '%e^(%pi %i x)' se simplifica
     a '%e^(%pi %i y)' donde 'y' es 'x - 2 k' para algún entero 'k' tal
     que 'abs(y) < 1'.

     Si '%emode' vale 'false', no se realizan simplificaciones
     especiales a '%e^(%pi %i x)'.

 -- Variable opcional: %enumer
     Valor por defecto: 'false'

     Si la variable '%enumer' vale 'true' hace que '%e' se reemplace por
     2.718...  siempre que 'numer' valga 'true'.

     Si '%enumer' vale 'false', esta sustitución se realiza sólo si el
     exponente en '%e^x' tiene un valor numérico.

     Véanse también 'ev' y 'numer'.

 -- Función: exp (<x>)
     Representa la función exponencial.  La expresión 'exp (<x>)' en la
     entrada se simplifica en '%e^<x>'; 'exp' no aparece en expresiones
     simplificadas.

     Si la variable 'demoivre' vale 'true' hace que '%e^(a + b %i)' se
     simplifique a '%e^(a (cos(b) + %i sin(b)))' si 'b' no contiene a
     '%i'.  Véase 'demoivre'.

     Si la variable '%emode' vale 'true', hace que '%e^(%pi %i x)' se
     simplifique.  Véase '%emode'.

     Si la variable '%enumer' vale 'true' hace que '%e' se reemplace por
     2.718...  siempre que 'numer' valga 'true'.  Véase '%enumer'.

 -- Función: li [<s>] (<z>)

     Representa la función polilogarítmica de orden <s> y argumento <z>,
     definida por la serie infinita

                                           inf
                                           ====   k
                                           \     z
                                  Li (z) =  >    --
                                    s      /      s
                                           ====  k
                                           k = 1

     'li [1]' es '- log (1 - z)'.  'li [2]' y 'li [3]' son las funciones
     di- y trilogaritmo, respectivamente.

     Cuando el orden es 1, el polilogaritmo se simplifica a '- log (1 -
     z)', el cual a su vez se reduce a un valor numérico si <z> es un
     número real o complejo en coma flotante o si está presente el
     término 'numer'.

     Cuando el orden es 2 ó 3, el polilogaritmo se reduce a un valor
     numérico si <z> es un número real en coma flotante o si está
     presente el término 'numer'.

     Ejemplos:

          (%i1) assume (x > 0);
          (%o1)                        [x > 0]
          (%i2) integrate ((log (1 - t)) / t, t, 0, x);
          (%o2)                       - li (x)
                                          2
          (%i3) li [2] (7);
          (%o3)                        li (7)
                                         2
          (%i4) li [2] (7), numer;
          (%o4)        1.24827317833392 - 6.113257021832577 %i
          (%i5) li [3] (7);
          (%o5)                        li (7)
                                         3
          (%i6) li [2] (7), numer;
          (%o6)        1.24827317833392 - 6.113257021832577 %i
          (%i7) L : makelist (i / 4.0, i, 0, 8);
          (%o7)   [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]
          (%i8) map (lambda ([x], li [2] (x)), L);
          (%o8) [0, .2676526384986274, .5822405249432515,
          .9784693966661848, 1.64493407, 2.190177004178597
           - .7010261407036192 %i, 2.374395264042415
           - 1.273806203464065 %i, 2.448686757245154
           - 1.758084846201883 %i, 2.467401098097648
           - 2.177586087815347 %i]
          (%i9) map (lambda ([x], li [3] (x)), L);
          (%o9) [0, .2584613953442624, 0.537213192678042,
          .8444258046482203, 1.2020569, 1.642866878950322
           - .07821473130035025 %i, 2.060877505514697
           - .2582419849982037 %i, 2.433418896388322
           - .4919260182322965 %i, 2.762071904015935
           - .7546938285978846 %i]

 -- Función: log (<x>)
     Representa el logaritmo natural (en base e) de <x>.

     Maxima no tiene definida una función para el logaritmo de base 10 u
     otras bases.  El usuario puede hacer uso de la definición 'log10(x)
     := log(x) / log(10)'.

     La simplificación y evaluación de logaritmos se controla con
     ciertas variables globales:

     'logexpand'
          hace que 'log(a^b)' se convierta en 'b*log(a)'.  Si toma el
          valor 'all', 'log(a*b)' también se reducirá a 'log(a)+log(b)'.
          Si toma el valor 'super', entonces 'log(a/b)' también se
          reducirá a 'log(a)-log(b)', siendo 'a/b' racional con 'a#1',
          (la expresión 'log(1/b)', para 'b' entero, se simplifica
          siempre).  Si toma el valor 'false', se desactivarán todas
          estas simplificaciones.

     'logsimp'
          si vale 'false', entonces no se transforma '%e' a potencias
          que contengan logaritmos.

     'lognegint'
          si vale 'true' se aplica la regla 'log(-n)' ->
          'log(n)+%i*%pi', siendo 'n' un entero positivo.

     '%e_to_numlog'
          si vale 'true', 'r' es un número racional y 'x' una expresión,
          '%e^(r*log(x))' se reduce a 'x^r'.  Téngase en cuenta que la
          instrucción 'radcan' también hace este tipo de
          transformaciones, así como otras más complicadas.  La
          instrucción 'logcontract' "contrae" expresiones que contengan
          algún 'log'.

 -- Variable opcional: logabs
     Valor por defecto: 'false'

     Cuando se calculan integrales indefinidas en las que se generan
     logaritmos, como en 'integrate(1/x,x)', el resultado se devuelve de
     la forma 'log(abs(...))' si 'logabs' vale 'true', o de la forma
     'log(...)' si 'logabs' vale 'false'.  En la integración definida se
     hace la asignación 'logabs:true', ya que aquí es normalmente
     necesario evaluar la integral indefinida en los extremos del
     intervalo de integración.

 -- Variable opcional: logarc
 -- Función: logarc (<expr>)

     Si la variable global 'logarc' toma el valor 'true', las funciones
     circulares e hiperbólicas inversas se reemplazan por funciones
     logarítmicas equivalentes.  El valor por defecto de 'logarc' es
     'false'.

     La función 'logarc(<expr>)' realiza la anterior transformación en
     la expresión <expr> sin necesidad de alterar el valor de la
     variable global 'logarc'.

 -- Variable opcional: logconcoeffp
     Valor por defecto: 'false'

     Controla qué coeficientes se contraen cuando se utiliza
     'logcontract'.  Se le puede asignar el nombre de una función de
     predicado de un argumento; por ejemplo, si se quiere introducir
     raíces cuadradas, se puede hacer 'logconcoeffp:'logconfun$
     logconfun(m):=featurep(m,integer) or ratnump(m)$' .  Entonces
     'logcontract(1/2*log(x));' devolverá 'log(sqrt(x))'.

 -- Función: logcontract (<expr>)
     Analiza la expresión <expr> recursivamente, transformando
     subexpresiones de la forma 'a1*log(b1) + a2*log(b2) + c' en
     'log(ratsimp(b1^a1 * b2^a2)) + c'

          (%i1) 2*(a*log(x) + 2*a*log(y))$
          (%i2) logcontract(%);
                                           2  4
          (%o2)                     a log(x  y )

     Si se hace 'declare(n,integer);' entonces
     'logcontract(2*a*n*log(x));' da 'a*log(x^(2*n))'.  Los coeficientes
     que se contraen de esta manera son aquellos que como el 2 y el 'n'
     satisfacen 'featurep(coeff,integer)'.  El usuario puede controlar
     qué coeficientes se contraen asignándole a la variable global
     'logconcoeffp' el nombre de una función de predicado de un
     argumento; por ejemplo, si se quiere introducir raíces cuadradas,
     se puede hacer 'logconcoeffp:'logconfun$
     logconfun(m):=featurep(m,integer) or ratnump(m)$' .  Entonces
     'logcontract(1/2*log(x));' devolverá 'log(sqrt(x))'.

 -- Variable opcional: logexpand
     Valor por defecto: 'true'

     Si 'logexpand' vale 'true' hace que 'log(a^b)' se convierta en
     'b*log(a)'.  Si toma el valor 'all', 'log(a*b)' también se reducirá
     a 'log(a)+log(b)'.  Si toma el valor 'super', entonces 'log(a/b)'
     también se reducirá a 'log(a)-log(b)', siendo 'a/b' racional con
     'a#1', (la expresión 'log(1/b)', para 'b' entero, se simplifica
     siempre).  Si toma el valor 'false', se desactivarán todas estas
     simplificaciones.

 -- Variable opcional: lognegint
     Valor por defecto: 'false'

     Si 'lognegint' vale 'true' se aplica la regla 'log(-n)' ->
     'log(n)+%i*%pi' siendo 'n' un entero positivo.

 -- Variable opcional: logsimp
     Valor por defecto: 'true'

     Si 'logsimp' vale 'false', entonces no se transforma '%e' a
     potencias que contengan logaritmos.

 -- Función: plog (<x>)
     Representa la rama principal del logaritmo natural complejo con
     '-%pi' < 'carg(<x>)' <= '+%pi' .

 -- Función: sqrt (<x>)
     Raíz cuadrada de <x>.  Se representa internamente por '<x>^(1/2)'.
     Véase también 'rootscontract'.

     Si la variable 'radexpand' vale 'true' hará que las raíces
     'n'-ésimas de los factores de un producto que sean potencias de 'n'
     sean extraídas del radical; por ejemplo, 'sqrt(16*x^2)' se
     convertirá en '4*x' sólo si 'radexpand' vale 'true'.


File: maxima.info,  Node: Funciones trigonométricas,  Next: Números aleatorios,  Prev: Funciones radicales exponenciales y logarítmicas,  Up: Funciones matemáticas

10.5 Funciones trigonométricas
==============================

* Menu:

* Introducción a la trigonometría::  
* Funciones y variables para trigonometría:: 


File: maxima.info,  Node: Introducción a la trigonometría,  Next: Funciones y variables para trigonometría,  Prev: Funciones trigonométricas,  Up: Funciones trigonométricas

10.5.1 Introducción a la trigonometría
--------------------------------------

Maxima reconoce muchas funciones trigonométricas.  No están programadas
todas las identidades trigonométricas, pero el usuario puede añadir
muchas de ellas haciendo uso de las técnicas basadas en patrones.  Las
funciones trigonométricas definidas en Maxima son: 'acos', 'acosh',
'acot', 'acoth', 'acsc', 'acsch', 'asec', 'asech', 'asin', 'asinh',
'atan', 'atanh', 'cos', 'cosh', 'cot', 'coth', 'csc', 'csch', 'sec',
'sech', 'sin', 'sinh', 'tan' y 'tanh'.  Hay también un determinado
número de instrucciones especiales para manipular funciones
trigonométricas; véanse a este respecto 'trigexpand', 'trigreduce' y la
variable 'trigsign'.  Dos paquetes adicionales amplían las reglas de
simplificación de Maxima, 'ntrig' y 'atrig1'.  Ejecútese
'describe(<command>)' para más detalles.


File: maxima.info,  Node: Funciones y variables para trigonometría,  Prev: Introducción a la trigonometría,  Up: Funciones trigonométricas

10.5.2 Funciones y variables para trigonometría
-----------------------------------------------

 -- Variable opcional: %piargs
     Valor por defecto: 'true'

     Cuando '%piargs' vale 'true', las funciones trigonométricas se
     simplifican a constantes algebraicas cuando el argumento es
     múltiplo entero de %pi, %pi/2, %pi/3, %pi/4 o %pi/6.

     Maxima conoce algunas identidades aplicables cuando %pi, etc., se
     multiplican por una variable entera (esto es, un símbolo declarado
     como entero).

     Ejemplo:

          (%i1) %piargs : false$
          (%i2) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                          %pi       %pi
          (%o2)            [sin(%pi), sin(---), sin(---)]
                                           2         3
          (%i3) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                                %pi       %pi       %pi
          (%o3)            [sin(---), sin(---), sin(---)]
                                 4         5         6
          (%i4) %piargs : true$
          (%i5) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                          sqrt(3)
          (%o5)                    [0, 1, -------]
                                             2
          (%i6) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                                   1         %pi   1
          (%o6)                [-------, sin(---), -]
                                sqrt(2)       5    2
          (%i7) [cos (%pi/3), cos (10*%pi/3), tan (10*%pi/3),
                 cos (sqrt(2)*%pi/3)];
                          1    1               sqrt(2) %pi
          (%o7)          [-, - -, sqrt(3), cos(-----------)]
                          2    2                    3

     Se aplican ciertas identidades cuando %pi o %pi/2 se multiplican
     por una variable entera.

          (%i1) declare (n, integer, m, even)$
          (%i2) [sin (%pi * n), cos (%pi * m), sin (%pi/2 * m),
                 cos (%pi/2 * m)];
                                                m/2
          (%o2)                  [0, 1, 0, (- 1)   ]

 -- Variable opcional: %iargs
     Valor por defecto: 'true'

     Cuando '%iargs' vale 'true', las funciones trigonométricas se
     simplifican a funciones hiperbólicas si el argumento es
     aparentemente un múltiplo de la unidad imaginaria %i.

     La simplificación se lleva a cabo incluso cuando el argumento es
     manifiestamente real; Maxima sólo se fija en si el argumento es un
     múltiplo literal de %i.

     Ejemplos:

          (%i1) %iargs : false$
          (%i2) [sin (%i * x), cos (%i * x), tan (%i * x)];
          (%o2)           [sin(%i x), cos(%i x), tan(%i x)]
          (%i3) %iargs : true$
          (%i4) [sin (%i * x), cos (%i * x), tan (%i * x)];
          (%o4)           [%i sinh(x), cosh(x), %i tanh(x)]

     La simplificación se aplica incluso en el caso de que el argumento
     se reduzca a un número real.

          (%i1) declare (x, imaginary)$
          (%i2) [featurep (x, imaginary), featurep (x, real)];
          (%o2)                     [true, false]
          (%i3) sin (%i * x);
          (%o3)                      %i sinh(x)

 -- Function: acos (<x>)
     Arco coseno.

 -- Función: acosh (<x>)
     Arco coseno hiperbólico.

 -- Función: acot (<x>)
     Arco cotangente.

 -- Función: acoth (<x>)
     Arco cotangente hiperbólica.

 -- Función: acsc (<x>)
     Arco cosecante.

 -- Función: acsch (<x>)
     Arco cosecante hiperbólica.

 -- Función: asec (<x>)
     Arco secante.

 -- Función: asech (<x>)
     Arco secante hiperbólica.

 -- Función: asin (<x>)
     Arco seno.

 -- Función: asinh (<x>)
     Arco seno hiperbólico.

 -- Función: atan (<x>)
     Arco tangente.

 -- Función: atan2 (<y>, <x>)
     Calcula el valor de 'atan(<y>/<x>)' en el intervalo de '-%pi' a
     '%pi'.

 -- Función: atanh (<x>)
     Arco tangente hiperbólica.

 -- Paquete: atrig1
     El paquete 'atrig1' contiene ciertas reglas de simplificación
     adicionales para las funciones trigonométricas inversas.  Junto con
     las reglas que ya conoce Maxima, los siguientes ángulos están
     completamente implementados: '0', '%pi/6', '%pi/4', '%pi/3' y
     '%pi/2'.  Los ángulos correspondientes en los otros tres cuadrantes
     también están disponibles.  Para hacer uso de estas reglas,
     ejecútese 'load(atrig1);'.

 -- Función: cos (<x>)
     Coseno.

 -- Función: cosh (<x>)
     Coseno hiperbólico.

 -- Función: cot (<x>)
     Cotangente.

 -- Función: coth (<x>)
     Cotangente hiperbólica.

 -- Función: csc (<x>)
     Cosecante.

 -- Función: csch (<x>)
     Cosecante hiperbólica.

 -- Variable opcional: halfangles
     Valor por defecto: 'false'

     Si 'halfangles' vale 'true', las funciones trigonométricas con
     argumentos del tipo '<expr>/2' se simplifican a funciones con
     argumentos <expr>.

     Para un argumento real <x> en el intervalo '0 < x < 2*%pi' el seno
     del semiángulo se simplifica como

                              sqrt(1 - cos(x))
                              ----------------
                                  sqrt(2)

     Se necesita un factor relativamente complicado para que esta
     fórmula sea también válida para cualquier argumento complejo <z>:

                     realpart(z)
               floor(-----------)
                        2 %pi
          (- 1)                   (1 - unit_step(- imagpart(z))

                                realpart(z)            realpart(z)
                          floor(-----------) - ceiling(-----------)
                                   2 %pi                  2 %pi
                    ((- 1)                                          + 1))

     Maxima reconoce este factor y otros similares para las funciones
     'sin', 'cos', 'sinh' y 'cosh'.  Para valores especiales del
     argumento z, estos factores se simplifican de forma apropiada.

     Ejemplos:

          (%i1) halfangles:false;
          (%o1)                                false
          (%i2) sin(x/2);
                                                  x
          (%o2)                               sin(-)
                                                  2
          (%i3) halfangles:true;
          (%o3)                                true
          (%i4) sin(x/2);
                                                              x
                                                      floor(-----)
                                                            2 %pi
                                sqrt(1 - cos(x)) (- 1)
          (%o4)                 ----------------------------------
                                             sqrt(2)
          (%i5) assume(x>0, x<2*%pi)$
          (%i6) sin(x/2);
                                         sqrt(1 - cos(x))
          (%o6)                          ----------------
                                             sqrt(2)

 -- Paquete: ntrig
     El paquete 'ntrig' contiene un conjunto de reglas de simplificación
     que se pueden usar para simplificar funciones trigonométricas cuyos
     argumentos son de la forma '<f>(<n> %pi/10)' donde <f> es
     cualquiera de las funciones 'sin', 'cos', 'tan', 'csc', 'sec' o
     'cot'.

 -- Función: sec (<x>)
     Secante.

 -- Función: sech (<x>)
     Secante hiperbólica.

 -- Función: sin (<x>)
     Seno.

 -- Función: sinh (<x>)
     Seno hiperbólico.

 -- Función: tan (<x>)
     Tangente.

 -- Función: tanh (<x>)
     Tangente hiperbólica.

 -- Función: trigexpand (<expr>)
     Expande funciones trigonométricas e hiperbólicas de sumas de
     ángulos y de múltiplos de ángulos presentes en <expr>.  Para
     mejorar los resultados, <expr> debería expandirse.  Para facilitar
     el control por parte del usuario de las simplificaciones, esta
     función tan solo expande un nivel de cada vez, expandiendo sumas de
     ángulos o de múltiplos de ángulos.  A fin de obtener una expansión
     completa en senos y coseno, se le dará a la variable 'trigexpand'
     el valor 'true'.

     La función 'trigexpand' está controlada por las siguientes
     variables:

     'trigexpand'
          Si vale 'true', provoca la expansión de todas las expresiones
          que contengan senos y cosenos.
     'trigexpandplus'
          Controla la regla de la suma para 'trigexpand', la expansión
          de una suma como 'sin(x + y)' se llevará a cabo sólo si
          'trigexpandplus' vale 'true'.
     'trigexpandtimes'
          Controla la regla del producto para 'trigexpand', la expansión
          de un producto como 'sin(2 x)' se llevará a cabo sólo si
          'trigexpandtimes' vale 'true'.

     Ejemplos:

          (%i1) x+sin(3*x)/sin(x),trigexpand=true,expand;
                                   2           2
          (%o1)               - sin (x) + 3 cos (x) + x
          (%i2) trigexpand(sin(10*x+y));
          (%o2)          cos(10 x) sin(y) + sin(10 x) cos(y)

 -- Variable optativa: trigexpandplus
     Valor por defecto: 'true'

     La variable 'trigexpandplus' controla la regla de la suma para
     'trigexpand'.  Así, si la instrucción 'trigexpand' se utiliza o si
     la variable 'trigexpand' vale 'true', se realizará la expansión de
     sumas como 'sin(x+y)' sólo si 'trigexpandplus' vale 'true'.

 -- Variable optativa: trigexpandtimes
     Valor por defecto: 'true'

     La variable 'trigexpandtimes' controla la regla del producto para
     'trigexpand'.  Así, si la instrucción 'trigexpand' se utiliza o si
     la variable 'trigexpand' vale 'true', se realizará la expansión de
     productos como 'sin(2*x)' sólo si 'trigexpandtimes' vale 'true'.

 -- Variable optativa: triginverses
     Valor por defecto: 'true'

     La variable 'triginverses' controla la simplificación de la
     composición de funciones trigonométricas e hiperbólicas con sus
     funciones inversas.

     Si vale 'all', tanto 'atan(tan(<x>))' como 'tan(atan(<x>))' se
     reducen a <x>.

     Si vale 'true', se desactiva la simplificación de
     '<arcfun>(<fun>(<x>))'.

     Si vale 'false', se desactivan las simplificaciones de
     '<arcfun>(<fun>(<x>))' y '<fun>(<arcfun>(<x>))'.

 -- Función: trigreduce (<expr>, <x>)
 -- Función: trigreduce (<expr>)
     Combina productos y potencias de senos y cosenos trigonométricos e
     hiperbólicos de <x>, transformándolos en otros que son múltiplos de
     <x>.  También intenta eliminar estas funciones cuando aparecen en
     los denominadores.  Si no se introduce el argumento <x>, entonces
     se utilizan todas las variables de <expr>.

     Véase también 'poissimp'.

          (%i1) trigreduce(-sin(x)^2+3*cos(x)^2+x);
                         cos(2 x)      cos(2 x)   1        1
          (%o1)          -------- + 3 (-------- + -) + x - -
                            2             2       2        2

     Las rutinas de simplificación trigonométrica utilizan información
     declarada en algunos casos sencillos.  Las declaraciones sobre
     variables se utilizan como se indica a continuación:

          (%i1) declare(j, integer, e, even, o, odd)$
          (%i2) sin(x + (e + 1/2)*%pi);
          (%o2)                        cos(x)
          (%i3) sin(x + (o + 1/2)*%pi);
          (%o3)                       - cos(x)

 -- Variable optativa: trigsign
     Valor por defecto: 'true'

     Si 'trigsign' vale 'true', se permite la simplificación de
     argumentos negativos en funciones trigonométricas, como en
     'sin(-x)', que se transformará en '-sin(x)' sólo si 'trigsign' vale
     'true'.

 -- Función: trigsimp (<expr>)
     Utiliza las identidades sin(x)^2 + cos(x)^2 = 1 y cosh(x)^2 -
     sinh(x)^2 = 1 para simplificar expresiones que contienen 'tan',
     'sec', etc., en expresiones con 'sin', 'cos', 'sinh', 'cosh'.

     Las funciones 'trigreduce', 'ratsimp' y 'radcan' puden seguir
     siendo útiles para continuar el proceso de simplificación.

     La instrucción 'demo ("trgsmp.dem")' muestra algunos ejemplos de
     'trigsimp'.

 -- Función: trigrat (<expr>)
     Devuelve una forma canónica simplificada cuasi-lineal de una
     expresión trigonométrica; <expr> es una fracción racional que
     contiene 'sin', 'cos' o 'tan', cuyos argumentos son formas lineales
     respecto de ciertas variables (o kernels) y '%pi/<n>' (<n> entero)
     con coeficientes enteros.  El resultado es una fracción
     simplificada con el numerador y denominador lineales respecto de
     'sin' y 'cos'.  Así, 'trigrat' devuelve una expresión lineal
     siempre que sea posible.

          (%i1) trigrat(sin(3*a)/sin(a+%pi/3));
          (%o1)            sqrt(3) sin(2 a) + cos(2 a) - 1

     El siguiente ejemplo se ha tomado de Davenport, Siret y Tournier,
     Calcul Formel, Masson (o en inglés, Addison-Wesley), sección 1.5.5,
     teorema de Morley.

          (%i1) c : %pi/3 - a - b$
          (%i2) bc : sin(a)*sin(3*c)/sin(a+b);
                                                    %pi
                            sin(a) sin(3 (- b - a + ---))
                                                     3
          (%o2)             -----------------------------
                                     sin(b + a)
          (%i3) ba : bc, c=a, a=c;
                                                   %pi
                              sin(3 a) sin(b + a - ---)
                                                    3
          (%o3)               -------------------------
                                            %pi
                                    sin(a - ---)
                                             3
          (%i4) ac2 : ba^2 + bc^2 - 2*bc*ba*cos(b);
                   2         2         %pi
                sin (3 a) sin (b + a - ---)
                                        3
          (%o4) ---------------------------
                          2     %pi
                       sin (a - ---)
                                 3
                                                 %pi
           - (2 sin(a) sin(3 a) sin(3 (- b - a + ---)) cos(b)
                                                  3
                       %pi            %pi
           sin(b + a - ---))/(sin(a - ---) sin(b + a))
                        3              3
                2       2              %pi
             sin (a) sin (3 (- b - a + ---))
                                        3
           + -------------------------------
                          2
                       sin (b + a)
          (%i5) trigrat (ac2);
          (%o5) - (sqrt(3) sin(4 b + 4 a) - cos(4 b + 4 a)
           - 2 sqrt(3) sin(4 b + 2 a) + 2 cos(4 b + 2 a)
           - 2 sqrt(3) sin(2 b + 4 a) + 2 cos(2 b + 4 a)
           + 4 sqrt(3) sin(2 b + 2 a) - 8 cos(2 b + 2 a) - 4 cos(2 b - 2 a)
           + sqrt(3) sin(4 b) - cos(4 b) - 2 sqrt(3) sin(2 b) + 10 cos(2 b)
           + sqrt(3) sin(4 a) - cos(4 a) - 2 sqrt(3) sin(2 a) + 10 cos(2 a)
           - 9)/4


File: maxima.info,  Node: Números aleatorios,  Prev: Funciones trigonométricas,  Up: Funciones matemáticas

10.6 Números aleatorios
=======================

 -- Función: make_random_state (<n>)
 -- Función: make_random_state (<s>)
 -- Función: make_random_state (true)
 -- Función: make_random_state (false)

     Un objeto de estado aleatorio representa el estado del generador de
     números aleatorios.  El estado consiste en 627 cadenas binarias de
     32 bits.

     La llamada 'make_random_state (<n>)' devuelve un nuevo objeto de
     estado aleatorio creado a partir de una semilla entera igual a <n>
     módulo 2^32.  El argumento <n> puede ser negativo.

     La llamada 'make_random_state (<s>)' devuelve una copia del estado
     aleatorio <s>.

     La llamada 'make_random_state (true)' devuelve un nuevo objeto de
     estado aleatorio, cuya semilla se genera a partir de la hora actual
     del reloj del sistema como semilla.

     La llamada 'make_random_state (false)' devuelve una copia del
     estado actual del generador de números aleatorios.

 -- Función: set_random_state (<s>)
     Establece <s> como estado del generador de números aleatorios.

     La función 'set_random_state' devuelve 'done' en todo caso.

 -- Función: random (<x>)
     Devuelve un número seudoaleatorio.  Si <x> es un entero, 'random
     (<x>)' devuelve un entero entre 0 y '<x> - 1', ambos inclusive.  Si
     <x> es un decimal en punto flotante, 'random (<x>)' devuelve un
     decimal no negativo en punto flotante menor que <x>.  La función
     'random' emite un mensaje de error si <x> no es ni entero ni de
     punto flotante, o si <x> no es positivo.

     Las funciones 'make_random_state' y 'set_random_state' permiten
     controlar el estado del generador de números aleatorios.

     El generador de números aleatorios de Maxima implementa el
     algoritmo de Mersenne twister MT 19937.

     Ejemplos:

          (%i1) s1: make_random_state (654321)$
          (%i2) set_random_state (s1);
          (%o2)                         done
          (%i3) random (1000);
          (%o3)                          768
          (%i4) random (9573684);
          (%o4)                        7657880
          (%i5) random (2^75);
          (%o5)                11804491615036831636390
          (%i6) s2: make_random_state (false)$
          (%i7) random (1.0);
          (%o7)                   .2310127244107132
          (%i8) random (10.0);
          (%o8)                   4.394553645870825
          (%i9) random (100.0);
          (%o9)                   32.28666704056853
          (%i10) set_random_state (s2);
          (%o10)                        done
          (%i11) random (1.0);
          (%o11)                  .2310127244107132
          (%i12) random (10.0);
          (%o12)                  4.394553645870825
          (%i13) random (100.0);
          (%o13)                  32.28666704056853


File: maxima.info,  Node: Base de datos de Maxima,  Next: Gráficos,  Prev: Funciones matemáticas,  Up: Top

11 Base de datos de Maxima
**************************

* Menu:

* Introducción a la base de datos de Maxima::
* Funciones y variables para las propiedades::
* Funciones y variables para los hechos::
* Funciones y variables para los predicados::


File: maxima.info,  Node: Introducción a la base de datos de Maxima,  Next: Funciones y variables para las propiedades,  Prev: Base de datos de Maxima,  Up: Base de datos de Maxima

11.1 Introducción a la base de datos de Maxima
==============================================

Propiedades
-----------

A las variables y funciones se les puede asignar propiedades con la
función 'declare'.  Estas propiedades son almacenadas en un banco de
datos o registradas en una lista de propiedades que proporciona Lisp.
Con la función 'featurep' se puede comprobar si un símbolo tiene una
determinada propiedad y con la función 'properties' se pueden obtener
todas las propiedades asociadas a él.  A su vez, la función 'remove'
elimina una propiedad de la base de datos o de la lista de propiedades.
En caso de utilizar 'kill' para borrar el valor asignado a una variable,
también serán borradas todas las propiedades asociadas a la misma.

El usuario tiene la facultad de añadirle propiedades a un símbolo con
las funciones 'put' y 'qput'.  Con la función 'get' podrá leer sus
propiedades y borrarlas con 'rem'.

Las variables pueden tener las siguientes propiedades a almacenar en el
banco de datos:

   constant
   integer        noninteger
   even           odd
   rational       irrational
   real           imaginary      complex

Las funciones pueden tener las siguientes propiedades a almacenar en el
banco de datos:

   increasing     decreasing
   posfun         integervalued

Las siguientes propiedades se pueden aplicar a funciones y se utilizan
para su correcta simplificación.  Estas propiedades se describen en el
capítulo dedicado a la simplificación:

   linear         additive       multiplicative
   outative       commutative    symmetric
   antisymmetric  nary           lassociativ
   rassociative   evenfun        oddfun

Otras propiedades aplicables a variables y funciones, y que se almacenan
en la lista de propiedades de Lisp, son:

   bindtest       feature        alphabetic
   scalar         nonscalar      nonarray

Contextos
---------

Maxima administra contextos en los que se almacenan tanto las
propiedades de las variables y funciones como hechos o hipótesis sobre
las mismas.  Los hechos se establecen con la función 'assume' y se
almacenan en el contexto actual.  Por ejemplo, con 'assume(a>10)' guarda
Maxima la información sobre el hecho de que la variable 'a' es mayor que
'10'.  Con la función 'forget' se borran los hechos de la base de datos.
Cuando Maxima pregunta al usuario sobre las propiedades de una variable,
éstas son almacenadas en un contexto.

Cada contexto se identifica por un nombre.  Al iniciarse Maxima, el
contexto actual recibe el nombre de 'initial' y se puede definir un
número arbitrario de contextos adicionales que pueden organizarse de
forma jerárquica.  Así, el contexto 'initial' está incluido en el
contexto 'global'.  Los hechos definidos en un contexto dado están
siempre activos en los contextos de nivel inferior.  Por ejemplo, el
contexto 'global' contiene hechos que se inicializan por el propio
Maxima y estarán activos, por tanto, en el contexto 'initial'.

Los contextos pueden almacenar un número arbitrario de hechos y pueden
desactivarse con la función 'deactivate'.  Desactivar un contexto no
implica la pérdida de los hechos almacenados, pudiendo ser
posteriormente reactivado con la función 'activate', estando los hechos
siempre a disposición del usuario.


File: maxima.info,  Node: Funciones y variables para las propiedades,  Next: Funciones y variables para los hechos,  Prev: Introducción a la base de datos de Maxima,  Up: Base de datos de Maxima

11.2 Funciones y variables para las propiedades
===============================================

 -- Propiedad: alphabetic

     'alphabetic' es un tipo de propiedad reconocida por 'declare'.  La
     expresión 'declare(<s>, alphabetic)' le indica a Maxima que
     reconozca como alfabéticos todos los caracteres que haya en <s>,
     que debe ser una cadena de texto.

     Véase también 'Identifiers'.

     Ejemplo:

          (%i1) xx\~yy\`\@ : 1729;
          (%o1)                         1729
          (%i2) declare ("~`@", alphabetic);
          (%o2)                         done
          (%i3) xx~yy`@ + @yy`xx + `xx@@yy~;
          (%o3)               `xx@@yy~ + @yy`xx + 1729
          (%i4) listofvars (%);
          (%o4)                  [@yy`xx, `xx@@yy~]

 -- Propiedad: bindtest
     La sentencia 'declare(<x>, bindtest' le indica a Maxima que
     devuelva un mensaje de error cuando el símbolo <x> no tenga
     asociado valor alguno.

     Ejemplo:

          (%i1) aa + bb;
          (%o1)                        bb + aa
          (%i2) declare (aa, bindtest);
          (%o2)                         done
          (%i3) aa + bb;
          aa unbound variable
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) aa : 1234;
          (%o4)                         1234
          (%i5) aa + bb;
          (%o5)                       bb + 1234

 -- Propiedad: constant
     'declare(<a>, constant)' declara <a> como constante.  La
     declaración de un símbolo como constante no impide que se le asigne
     un valor no constante al símbolo.

     Véanse 'constantp' y 'declare'

     Ejemplo:

          (%i1) declare(c, constant);
          (%o1)                         done
          (%i2) constantp(c);
          (%o2)                         true
          (%i3) c : x;
          (%o3)                           x
          (%i4) constantp(c);
          (%o4)                         false

 -- Función: constantp (<expr>)
     Devuelve 'true' si <expr> es una expresión constante y 'false' en
     caso contrario.

     Una expresión se considera constante si sus argumentos son números
     (incluidos los números racionales que se muestran con '/R/'),
     constantes simbólicas como '%pi', '%e' o '%i', variables con valor
     constante o declarada como constante por 'declare', o funciones
     cuyos argumentos son constantes.

     La función 'constantp' evalúa sus argumentos.

     Ejemplos:

          (%i1) constantp (7 * sin(2));
          (%o1)                                true
          (%i2) constantp (rat (17/29));
          (%o2)                                true
          (%i3) constantp (%pi * sin(%e));
          (%o3)                                true
          (%i4) constantp (exp (x));
          (%o4)                                false
          (%i5) declare (x, constant);
          (%o5)                                done
          (%i6) constantp (exp (x));
          (%o6)                                true
          (%i7) constantp (foo (x) + bar (%e) + baz (2));
          (%o7)                                false
          (%i8)

 -- Función: declare (<a_1>, <f_1>, <a_2>, <f_2>, ...)
     Asigna al átomo o lista de átomos <a_i> la propiedad o lista de
     propiedades<p_i>.  Si <a_i> y/o <p_i> son listas, cada uno de los
     átomos adquiere todas las propiedades.

     La función 'declare' no evalúa sus argumentos y siempre devuelve la
     expresión 'done'.

     La llamada 'featurep (<object>, <feature>)' devuelve 'true' si
     <object> ha sido previamente declarado como poseedor de la
     propiedad <feature>.

     Véase también 'features'.

     La función 'declare' reconoce las siguientes propiedades:

     'additive'
          Hace que Maxima simplifique las expresiones <a_i> haciendo uso
          de la sustitución '<a_i>(x + y + z + ...)'  '-->' '<a_i>(x) +
          <a_i>(y) + <a_i>(z) + ...'.  Tal sustitución se aplica
          únicamente al primer argumento.

     'alphabetic'
          Indica a Maxima que reconozca todos los caracteres de la
          cadena alfanumérica <a_i> como caracteres alfabéticos.

     'antisymmetric, commutative, symmetric'
          Hace que Maxima reconozca a <a_i> como una función simétrica o
          antisimétrica.  La propiedad 'commutative' equivale a
          'symmetric'.

     'bindtest'
          Hace que Maxima envíe un error si <a_i> es evaluado sin
          habérsele asignado un valor.

     'constant'
          Hace que Maxima considere a <a_i> como una constante
          simbólica.

     'even, odd'
          Hace que Maxima reconozca a <a_i> como una variable entera par
          o impar.

     'evenfun, oddfun'
          Hace que Maxima reconozca a <a_i> como una función par o
          impar.

     'evflag'
          Hace que <a_i> sea reconocida por 'ev', de manera que a <a_i>
          se le asigne el valor 'true' durante la ejecución de 'ev'
          cuando <a_i> aparezca como argumento de control de 'ev'.
          Véase también 'evflag'.

     'evfun'
          Hace que <a_i> sea reconocida por 'ev', de manera que la
          función nombrada por <a_i> se aplique cuando <a_i> aparezca
          como argumento de control de 'ev'.  Véase también 'evfun'.

     'feature'
          Hace que Maxima considere a <a_i> como el nombre de una
          propiedad.  Otros átomos podrán ser declarados entonces como
          poseedores de la propiedad <a_i>.

     'increasing, decreasing'
          Hace que Maxima reconozca a <a_i> como una función creciente o
          decreciente.

     'integer, noninteger'
          Hace que Maxima reconozca a <a_i> como una variable entera o
          no entera.

     'integervalued'
          Hace que Maxima reconozca a <a_i> como una función de valor
          entero.

     'lassociative, rassociative'
          Hace que Maxima reconozca a <a_i> como una función asociativa
          por la derecha o por la izquierda.

     'linear'
          Equivale a declarar <a_i> conjuntamente como 'outative' y
          'additive'.

     'mainvar'
          Hace que Maxima considere a <a_i> como una "variable
          principal", dándole prioridad frente a cualesquiera otras
          constantes o variables en la ordenación canónica de
          expresiones de Maxima, tal como determina 'ordergreatp'.

     'multiplicative'
          Hace que Maxima simplifique las expresiones <a_i> haciendo uso
          de la sustitución '<a_i>(x * y * z * ...)'  '-->' '<a_i>(x) *
          <a_i>(y) * <a_i>(z) * ...'.  Tal sustitución se aplica
          únicamente al primer argumento.

     'nary'
          Hace que Maxima reconozca a <a_i> como una función n-aria.

          La declaración 'nary' no es equivalente a la función 'nary'.
          El único efecto de 'declare(foo, nary)' consiste en hacer que
          el simplificador de Maxima reduzca expresiones anidadas; por
          ejemplo, para transformar 'foo(x, foo(y, z))' a 'foo(x, y,
          z)'.

     'nonarray'
          Indica que Maxima no debe considerar <a_i> como un array.
          Esta declaración evita la evaluación múltiple de variables
          subindicadas.

     'nonscalar'
          Hace que Maxima considere a <a_i> como una variable no
          escalar.  Se aplica comúnmente para declarar una variable como
          un vector simbólico o una matriz simbólica.

     'noun'
          Hace que Maxima considere a <a_i> como un nombre.  El efecto
          que se obtiene es que se reemplazan todas las expresiones
          <a_i> por ''<a_i>' o 'nounify (<a_i>)', dependiendo del
          contexto.

     'outative'
          Hace que Maxima simplifique las expresiones <a_i> extrayendo
          los factores constantes del primer argumento.

          Cuando <a_i> tenga un único argumento, un factor se
          considerará constante si es una constante literal o declarada.

          Cuando <a_i> tenga dos o más argumentos, un factor se
          considerará constante si el segundo argumento es un símbolo y
          el factor no contiene al segundo argumento.

     'posfun'
          Hace que Maxima reconozca a <a_i> como una función positiva.

     'rational, irrational'
          Hace que Maxima reconozca a <a_i> como una variable real
          racional o irracional.

     'real, imaginary, complex'
          Hace que Maxima reconozca a <a_i> como una variable real,
          imaginaria o compleja.

     'scalar'
          Hace que Maxima considere a <a_i> como una variable escalar.

     Ejemplos sobre el uso de estas propiedades están disponibles en la
     documentación correspondiente a cada propiedad por separado.

 -- Propiedad: decreasing
 -- Propiedad: increasing

     Las instrucciones 'declare(<f>, decreasing)' y 'declare(<f>,
     increasing' le indican a Maxima que reconozca la función <f> como
     una función decreciente o creciente.

     Véase también 'declare' para más propiedades.

     Ejemplo:

          (%i1) assume(a > b);
          (%o1)                        [a > b]
          (%i2) is(f(a) > f(b));
          (%o2)                        unknown
          (%i3) declare(f, increasing);
          (%o3)                         done
          (%i4) is(f(a) > f(b));
          (%o4)                         true

 -- Propiedad: even
 -- Propiedad: odd

     'declare(<a>, even)' y 'declare(<a>, odd)' le indican a Maxima que
     reconozca el símbolo <a> como entero par o impar.  Las propiedades
     'even' y 'odd' no son reconocidas por las funciones 'evenp', 'oddp'
     y 'integerp'.

     Véanse también 'declare' y 'askinteger'.

     Ejemplo:

          (%i1) declare(n, even);
          (%o1)                         done
          (%i2) askinteger(n, even);
          (%o2)                          yes
          (%i3) askinteger(n);
          (%o3)                          yes
          (%i4) evenp(n);
          (%o4)                         false

 -- Propiedad: feature

     Maxima interpreta dos tipos diferentes de propiedades, del sistema
     y las que se aplican a expresiones matemáticas.  Véase 'status'
     para obtener información sobre propiedades del sistema, así como
     'features' y 'featurep' para propiedades de las expresiones
     matemáticas.

     'feature' no es el nombre de ninguna función o variable.

 -- Función: featurep (<a>, <f>)

     Intenta determinar si el objeto <a> tiene la propiedad <f> en base
     a los hechos almacenados en la base de datos.  En caso afirmativo,
     devuelve 'true', o 'false' en caso contrario.

     Nótese que 'featurep' devuelve 'false' cuando no se puedan
     verificar ni <f> ni su negación.

     'featurep' evalúa su argumento.

     Véanse también 'declare' y 'features'.

     Ejemplos:

          (%i1) declare (j, even)$
          (%i2) featurep (j, integer);
          (%o2)                           true

 -- Declaración: features
     Maxima reconoce ciertas propiedades matemáticas sobre funciones y
     variables.

     La llamada 'declare (<x>, <foo>)' asocia la propiedad <foo> a la
     función o variable <x>.

     La llamada 'declare (<foo>, feature)' declara una nueva propiedad
     <foo>.  Por ejemplo, 'declare ([rojo, verde, azul], feature)'
     declara tres nuevas propiedades, 'rojo', 'verde' y 'azul'.

     El predicado 'featurep (<x>, <foo>)' devuelve 'true' si <x> goza de
     la propiedad <foo>, y 'false' en caso contrario.

     La lista 'features' contiene las propiedades que reconoce Maxima; a
     saber,

        integer        noninteger      even
        odd            rational        irrational
        real           imaginary       complex
        analytic       increasing      decreasing
        oddfun         evenfun         posfun
        commutative    lassociative    rassociative
        symmetric      antisymmetric

     junto con las definidas por el usuario.

     La lista 'features' sólo contiene propiedades matemáticas.  Hay
     otra lista con propiedades no matemáticas; Véase 'status'.

     Ejemplo:

          (%i1) declare (FOO, feature);
          (%o1)                         done
          (%i2) declare (x, FOO);
          (%o2)                         done
          (%i3) featurep (x, FOO);
          (%o3)                         true

 -- Función: get (<a>, <i>)

     Recupera la propiedad de usuario indicada por <i> asociada al átomo
     <a> o devuelve 'false' si <a> no tiene la propiedad <i>.

     La función 'get' evalúa sus argumentos.

     Véanse también 'put' y 'qput'.

          (%i1) put (%e, 'transcendental, 'type);
          (%o1)                    transcendental
          (%i2) put (%pi, 'transcendental, 'type)$
          (%i3) put (%i, 'algebraic, 'type)$
          (%i4) typeof (expr) := block ([q],
                  if numberp (expr)
                  then return ('algebraic),
                  if not atom (expr)
                  then return (maplist ('typeof, expr)),
                  q: get (expr, 'type),
                  if q=false
                  then errcatch (error(expr,"is not numeric.")) else q)$
          (%i5) typeof (2*%e + x*%pi);
          x is not numeric.
          (%o5)  [[transcendental, []], [algebraic, transcendental]]
          (%i6) typeof (2*%e + %pi);
          (%o6)     [transcendental, [algebraic, transcendental]]

 -- Propiedad: integer
 -- Propiedad: noninteger

     'declare(<a>, integer)' o 'declare(<a>, noninteger)' indica a
     Maxima que reconozca <a> como una variable entera o no entera.

     Véase también 'declare'.

     Ejemplo:

          (%i1) declare(n, integer, x, noninteger);
          (%o1)                         done
          (%i2) askinteger(n);
          (%o2)                          yes
          (%i3) askinteger(x);
          (%o3)                          no

 -- Propiedad: integervalued

     'declare(<f>, integervalued)' indica a MAxima que reconozca <f>
     como una función que toma valores enteros.

     Véase también 'declare'.

     Ejemplo:

          (%i1) exp(%i)^f(x);
                                        %i f(x)
          (%o1)                      (%e  )
          (%i2) declare(f, integervalued);
          (%o2)                         done
          (%i3) exp(%i)^f(x);
                                        %i f(x)
          (%o3)                       %e

 -- Propiedad: nonarray

     La instrucción 'declare(a, nonarray)' le indica a Maxima que no
     considere <a> como un array.  Esta declaración evita la evaluación
     múltiple de <a>, si ésta es una variable subindicada.

     Véase también 'declare'.

     Ejemplo:

          (%i1) a:'b$ b:'c$ c:'d$

          (%i4) a[x];
          (%o4)                          d
                                          x
          (%i5) declare(a, nonarray);
          (%o5)                         done
          (%i6) a[x];
          (%o6)                          a
                                          x

 -- Propiedad: nonscalar
     Hace que los átomos se comporten como hace una lista o matriz con
     respecto del operador '.' del la multiplicación no conmutativa.

     Véase también 'declare'.

 -- Función: nonscalarp (<expr>)
     Devuelve 'true' si <expr> no es escalar, es decir, si contiene
     átomos declarados como no escalares, listas o matrices.

 -- Declaración: posfun
     La instrucción 'declare (f, posfun)' declara a 'f' como función
     positiva, de forma que 'is (f(x) > 0)' devolverá 'true'.

     Véase también 'declare'.

 -- Función: printprops (<a>, <i>)
 -- Función: printprops ([<a_1>, ..., <a_n>], <i>)
 -- Función: printprops (all, <i>)
     Muestra la propiedad con el indicador <i> asociado con el átomo
     <a>.  <a> puede ser también una lista de átomos o el átomo 'all' en
     cuyo caso todos los átomos a los cuales se les haya dado esa
     propiedad serán usados.  Por ejemplo, 'printprops ([f, g],
     atvalue)'.  'printprops' es para propiedades que no pueden ser
     mostradas de otra manera, i.e.  para 'atvalue', 'atomgrad',
     'gradef', y 'matchdeclare'.

 -- Función: properties (<a>)
     Devuelve una lista con los nombres de todas las propiedades
     asociadas al t'omo <a>.

 -- Variable del sistema: props
     Valor por defecto: '[]'

     'props' son t'omos que tienen asociadas otras propiedades además de
     las explícitamente mencionadas en 'infolists', tales como las
     especificadas por 'atvalue', 'matchdeclare' y la función 'declare'.

 -- Función: propvars (<prop>)

     Devuelve la lista con los átomos de la lista 'props' que tienen la
     propiedad indicada por <prop>.  Así, 'propvars (atvalue)' devuelve
     la lista con los átomos a los que se les ha asociado valores con
     'atvalue'.

 -- Función: put (<átomo>, <valor>, <indicador>)

     Asigna el <valor> a la propiedad (especificada por <indicador>) de
     <átomo>; <indicador> puede ser el nombre de cualquier propiedad y
     no solamente de aquellas definidas por el sistema.

     'rem' deshace la asignación realizada por 'put'.

     La función 'put' evalúa sus argumentos y devuelve <valor>.

     Ejemplos:

          (%i1) put (foo, (a+b)^5, expr);
                                             5
          (%o1)                       (b + a)
          (%i2) put (foo, "Hello", str);
          (%o2)                         Hello
          (%i3) properties (foo);
          (%o3)            [[user properties, str, expr]]
          (%i4) get (foo, expr);
                                             5
          (%o4)                       (b + a)
          (%i5) get (foo, str);
          (%o5)                         Hello

 -- Función: qput (<átomo>, <valor>, <indicador>)

     Asigna <valor> a la propiedad de <átomo> que especifique
     <indicador>.  Actúa del mismo modeo que 'put', excepto que sus
     argumentos no son evaluados.

     Véase también 'get'.

     Ejemplo:

          (%i1) foo: aa$
          (%i2) bar: bb$
          (%i3) baz: cc$
          (%i4) put (foo, bar, baz);
          (%o4)                          bb
          (%i5) properties (aa);
          (%o5)                [[user properties, cc]]
          (%i6) get (aa, cc);
          (%o6)                          bb
          (%i7) qput (foo, bar, baz);
          (%o7)                          bar
          (%i8) properties (foo);
          (%o8)            [value, [user properties, baz]]
          (%i9) get ('foo, 'baz);
          (%o9)                          bar

 -- Propiedad: rational
 -- Propiedad: irrational

     'declare(<a>, rational)' o 'declare(<a>, irrational)' indica a
     Maxima que reconozca <a> como una variable real racional o
     irracional.

     Véase también 'declare'.

 -- Propiedad: real
 -- Propiedad: imaginary
 -- Propiedad: complex

     'declare(<a>, real)', 'declare(<a>, imaginary)' o 'declare(<a>,
     complex)' indican a Maxima que reconozca <a> como variable real,
     imaginaria puro o compleja, respectivamente.

     Véase también 'declare'.

 -- Función: rem (<átomo>, <indicador>)

     Elimina del <átomo> la propiedad indicada por <indicador>.  'rem'
     deshace la asignación realizada por 'put'.

     'rem' devuelve 'done' si <átomo> tenía la propiedad <indicador>
     cuando 'rem' fue invocado, devolviendo 'false' si carecía tal
     propiedad.

 -- Función: remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)
 -- Función: remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)
 -- Función: remove ("<a>", operator)
 -- Función: remove (<a>, transfun)
 -- Función: remove (all, <p>)

     Elimina propiedades asociadas con átomos.

     La llamada 'remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)' elimina la
     propiedad 'p_k' del átomo 'a_k'.

     La llamada 'remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)'
     elimina las propiedades '<p_1>, ..., <p_n>' de los átomos <a_1>,
     ..., <a_m>.  Puede tener más de un par de listas.

     La llamada 'remove (all, <p>)' elimina la propiedad <p> de todos
     los átomos que la tengan.

     Las propiedades eliminadas pueden ser de las que define el sistema,
     como 'function', 'macro' o 'mode_declare'; 'remove' no elimina las
     propiedades definidas por 'put'.

     La llamada 'remove ("<a>", operator)' o su equivalente 'remove
     ("<a>", op)' elimina de <a> las propiedades de operador declaradas
     por 'prefix', 'infix', 'nary', 'postfix', 'matchfix' o 'nofix'.
     Nótese que el nombre del operador debe escribirse como cadena
     precedida de apóstrofo.

     La función 'remove' devuelve siempre 'done' independientemente que
     haya algún átomo con la propiedad especificada.

     La función 'remove' no evalúa sus argumentos.

 -- Propiedad: scalar

     'declare(<a>, scalar)' indica a Maxima que considere a <a> como una
     variable escalar.

     Véase también 'declare'.

 -- Función: scalarp (<expr>)

     Devuelve 'true' si <expr> es un número, constante o variable
     declarada como 'scalar' con 'declare', o compuesta completamente de
     tales números, constantes o variables, pero que no contengan
     matrices ni listas.


File: maxima.info,  Node: Funciones y variables para los hechos,  Next: Funciones y variables para los predicados,  Prev: Funciones y variables para las propiedades,  Up: Base de datos de Maxima

11.3 Funciones y variables para los hechos
==========================================

 -- Función: activate (<context_1>, ..., <context_n>)
     Activa los contextos <context_1>, ..., <context_n>.  Los hechos en
     estos contextos están disponibles para hacer deducciones y extraer
     información.  Los hechos en estos contextos no se listan al invocar
     'facts ()'.

     La variable 'activecontexts' es la lista de contextos que se han
     activado por medio de la función 'activate'.

 -- Variable del sistema: activecontexts
     Valor por defecto: '[]'

     La variable 'activecontexts' es la lista de contextos que se han
     activado por medio de la función 'activate', pero que no se han
     activado por ser subcontextos del contexto actual.

 -- Función: askinteger (<expr>, integer)
 -- Función: askinteger (<expr>)
 -- Función: askinteger (<expr>, even)
 -- Función: askinteger (<expr>, odd)

     La llamada 'askinteger (<expr>, integer)' intenta determinar a
     partir de la base de datos de 'assume' si <expr> es un entero.  La
     función 'askinteger' pide más información al usuario si no
     encuentra la respuesta, tratando de almacenar la nueva información
     en la base de datos si es posible.  La llamada 'askinteger
     (<expr>)' equivale a 'askinteger (<expr>, integer)'.

     La llamadas 'askinteger (<expr>, even)' ay 'askinteger (<expr>,
     odd)' intentan determinar si <expr> es un entero par o impar,
     respectivamente.

 -- Función: asksign (<expr>)
     Primero intenta determinar si la expresión especificada es
     positiva, negativa o cero.  Si no lo consigue, planteará al usuario
     preguntas que le ayuden a conpletar la deducción.  Las respuestas
     del usuario son almacenadas en la base de datos durante el tiempo
     que dure este cálculo.  El valor que al final devuelva 'asksign'
     será 'pos', 'neg' o 'zero'.

 -- Función: assume (<pred_1>, ..., <pred_n>)
     Añade los predicados <pred_1>, ..., <pred_n> al contexto actual.
     Si un predicado es inconsistente o redundante con los otros
     predicados del contexto actual, entonces no es añadido al contexto.
     El contexto va acumulando predicados con cada llamada a 'assume'.

     La función 'assume' devuelve una lista cuyos miembros son los
     predicados que han sido añadidos al contexto, o los átomos
     'redundant' o 'inconsistent' si fuere necesario.

     Los predicados <pred_1>, ..., <pred_n> tan solo pueden ser
     expresiones formadas con los operadores relacionales '< <= equal
     notequal >=' y '>'.  Los predicados no pueden estar formados por
     expresiones que sean del tipo igualdad '=' ni del tipo desigualdad
     '#', ni tampoco pueden ser funciones de predicado como 'integerp'.

     En cambio, sí se reconocen predicados compuestos de la forma
     '<pred_1> and ... and <pred_n>', pero no '<pred_1> or ... or
     <pred_n>'.  También se reconoce 'not <pred_k>' si <pred_k> es un
     predicado relacional.  Expresiones de la forma 'not (<pred_1> and
     <pred_2>)' y 'not (<pred_1> or <pred_2>)' no son reconocidas.

     El mecanismo deductivo de Maxima no es muy potente; existen muchas
     consecuencias que, siendo obvias, no pueden ser obtenidas por 'is'.
     Se trata de una debilidad reconocida.

     'assume' no gestiona predicados con números complejos.  Si un
     predicado contiene un número complejo, 'assume' devuelve
     'inconsistent' o 'redunant'.

     La función 'assume' evalúa sus argumentos.

     Véanse también 'is', 'facts', 'forget', 'context' y 'declare'.

     Ejemplos:

          (%i1) assume (xx > 0, yy < -1, zz >= 0);
          (%o1)              [xx > 0, yy < - 1, zz >= 0]
          (%i2) assume (aa < bb and bb < cc);
          (%o2)                  [bb > aa, cc > bb]
          (%i3) facts ();
          (%o3)     [xx > 0, - 1 > yy, zz >= 0, bb > aa, cc > bb]
          (%i4) is (xx > yy);
          (%o4)                         true
          (%i5) is (yy < -yy);
          (%o5)                         true
          (%i6) is (sinh (bb - aa) > 0);
          (%o6)                         true
          (%i7) forget (bb > aa);
          (%o7)                       [bb > aa]
          (%i8) prederror : false;
          (%o8)                         false
          (%i9) is (sinh (bb - aa) > 0);
          (%o9)                        unknown
          (%i10) is (bb^2 < cc^2);
          (%o10)                       unknown

 -- Variable opcional: assumescalar
     Valor por defecto: 'true'

     La variable 'assumescalar' ayuda a controlar si una expresión
     'expr' para la cual 'nonscalarp (expr)' es 'false' va a tener un
     comportamiento similar a un escalar bajo ciertas transformaciones.

     Sea 'expr' cualquier expresión distinta de una lista o matriz, y
     sea también '[1, 2, 3]' una lista o una matriz.  Entonces, 'expr .
     [1, 2, 3]' dará como resultado '[expr, 2 expr, 3 expr]' si
     'assumescalar' es 'true', o si 'scalarp (expr)' es 'true', o si
     'constantp (expr)' es 'true'.

     Si 'assumescalar' vale 'true', la expresión se comportará como un
     escalar sólo en operaciones conmutativas, pero no en el caso de la
     multiplicación no conmutativa o producto matricial '.'.

     Si 'assumescalar' vale 'false', la expresión se comportará como un
     no escalar.

     Si 'assumescalar' vale 'all', la expresión se comportará como un
     escalar para todas las operaciones.

 -- Variable opcional: assume_pos
     Valor por defecto: 'false'

     Si 'assume_pos' vale 'true' y el signo de un parámetro <x> no puede
     ser determinado a partir del contexto actual o de otras
     consideraciones, 'sign' y 'asksign (<x>)' devolverán 'true'.  Con
     esto se pueden evitar algunas preguntas al usuario que se generan
     automáticamente, como las que hacen 'integrate' y otras funciones.

     By default, a parameter is <x> such that 'symbolp (<x>)' or
     'subvarp (<x>)'.

     Por defecto, un parámetro <x> es aquel para el que 'symbolp (<x>)'
     o 'subvarp (<x>)' devuelven 'true'.  La clase de expresiones que se
     consideran parámetros se puede extender mediante la utilización de
     la variable 'assume_pos_pred'.

     Las funciones 'sign' y 'asksign' intentan deducir el signo de una
     expresión a partir de los signos de los operandos que contiene.
     Por ejemplo, si 'a' y 'b' son ambos positivos, entonces 'a + b'
     también es positivo.

     Sin embargo, no es posible obviar todas las preguntas que hace
     'asksign'.  En particular, cuando el argumento de 'asksign' es una
     diferencia '<x> - <y>' o un logaritmo 'log(<x>)', 'asksign' siempre
     solicita una respuesta por parte del usuario, incluso cuando
     'assume_pos' vale 'true' y 'assume_pos_pred' es una función que
     devuelve 'true' para todos los argumentos.

 -- Variable opcional: assume_pos_pred
     Valor por defecto: 'false'

     Cuando a 'assume_pos_pred' se le asigna el nombre de una función o
     una expresión lambda de un único argumento <x>, ésta será invocada
     para determinar si <x> se considera un parámetro por 'assume_pos'.
     La variable 'assume_pos_pred' se ignora cuando 'assume_pos' vale
     'false'.

     La función 'assume_pos_pred' es invocada por 'sign' y por 'asksign'
     con un argumento <x>, el cual puede ser un átomo, una variable
     subindicada o una expresión de llamada a una función.  Si la
     función 'assume_pos_pred' devuelve 'true', <x> será considerada
     como un parámetro por 'assume_pos'.

     Por defecto, un parámetro <x> es aquel para el que 'symbolp (<x>)'
     o 'subvarp (<x>)' devuelven 'true'.

     Véanse también 'assume' y 'assume_pos'.

     Ejemplos:

          (%i1) assume_pos: true$
          (%i2) assume_pos_pred: symbolp$
          (%i3) sign (a);
          (%o3)                          pos
          (%i4) sign (a[1]);
          (%o4)                          pnz
          (%i5) assume_pos_pred: lambda ([x], display (x), true)$
          (%i6) asksign (a);
                                        x = a

          (%o6)                          pos
          (%i7) asksign (a[1]);
                                       x = a
                                            1

          (%o7)                          pos
          (%i8) asksign (foo (a));
                                     x = foo(a)

          (%o8)                          pos
          (%i9) asksign (foo (a) + bar (b));
                                     x = foo(a)

                                     x = bar(b)

          (%o9)                          pos
          (%i10) asksign (log (a));
                                        x = a

          Is  a - 1  positive, negative, or zero?

          p;
          (%o10)                         pos
          (%i11) asksign (a - b);
                                        x = a

                                        x = b

                                        x = a

                                        x = b

          Is  b - a  positive, negative, or zero?

          p;
          (%o11)                         neg

 -- Variable opcional: context
     Valor por defecto: 'initial'

     La variable 'context' da nombre al conjunto de hechos establecidos
     desde 'assume' y 'forget'.  La función 'assume' añade nuevos hechos
     al conjunto nombrado por 'context', mientras que 'forget' los va
     eliminando.  Asignando a 'context' un nuevo nombre <foo> cambia el
     contexto actual a <foo>.  Si el contexto <foo> no existe todavía,
     se crea automáticamente mediante una llamada a 'newcontext'.

     Véase 'contexts' para una descripción general del mecanismo que
     siguen los contextos.

 -- Variable opcional: contexts
     Valor por defecto: '[initial, global]'

     La variable 'contexts' es una lista que contiene los contextos
     existentes, incluyendo el actualmente activo.

     El mecanismo que siguen los contextos permiten al usuario agrupar y
     nombrar un conjunto de hechos, que recibe el nombre de contexto.
     Una vez hecho esto, el usuario puede hacer que Maxima tenga en
     cuenta o que olvide cualquier número de hechos sin más que activar
     o desactivar su contexto.

     Cualquier átomo simbólico puede ser el nombre de un contexto, y los
     hechos contenidos en tal contexto pueden ser almacenados hasta que
     se destruyan uno a uno mediante llamadas a la función 'forget', o
     que se destruyan conjuntamente invocando a 'kill' para eliminar el
     contexto al que pertenecen.

     Los contextos tienen estructura jerárquica, siendo su raíz el
     contexto 'global', el cual contiene información sobre Maxima que
     necesitan algunas funciones.  Cuando en un contexto todos los
     hechos están activos (lo que significa que están siendo utilizados
     en deducciones) lo estarán también en cualquier subcontexto del
     contexto actual.

     Cuando se comienza una sesión de Maxima, el usuario estará
     trabajando en un contexto llamado 'initial', el cual tiene un
     subcontexto de nombre 'global'.

     Véanse también 'facts', 'newcontext', 'supcontext', 'killcontext',
     'activate', 'deactivate', 'assume' y 'forget'.

 -- Función: deactivate (<contexto_1>, ..., <contexto_n>)
     Desactiva los contextos especificados <contexto_1>, ...,
     <contexto_n>.

 -- Función: facts (<item>)
 -- Función: facts ()
     Si <item> es el nombre de un contexto, 'facts (<item>)' devuelve
     una lista con los hechos asociados al contexto especificado.

     Si <item> no es el nombre de un contexto, 'facts (<item>)' devuelve
     una lista con los hechos conocidos acerca de <item> en el contexto
     actual.  Los hechos que estén activos en contextos diferentes no
     aparecen en la lista.

     La llamada 'facts ()', sin argumentos, muestra el contexto actual.

 -- Función: forget (<pred_1>, ..., <pred_n>)
 -- Función: forget (<L>)
     Borra los predicados establecidos por 'assume'.  Los predicados
     pueden ser expresiones equivalentes, pero no necesariamente
     idénticas, a las establecidas por 'assume'.

     La llamada 'forget (<L>)', siendo <L> una lista de predicados,
     borra todos los predicados contenidos en ella.

 -- Función: is (<expr>)
     Intenta determinar si el predicado <expr> se puede deducir de los
     hechos almacenados en la base de datos gestionada por 'assume'.

     Si el predicado se reduce a 'true' o 'false', 'is' devuelve 'true'
     o 'false', respectivamente.  En otro caso, el valor devuelto está
     controlado por la variable global 'prederror'.  Si 'prederror' vale
     'true', 'is' emite un mensaje de error; en caso contrario, 'is'
     devuelve 'unknown'.

     La instrucción 'ev(<expr>, pred)' (que puede escribirse como
     '<expr>, pred' en el modo interactivo) equivale a 'is(<expr>)'.

     Véanse también 'assume', 'facts' y 'maybe'.

     Ejemplos:

     'is' evalúa los predicados,

          (%i1) %pi > %e;
          (%o1)                       %pi > %e
          (%i2) is (%pi > %e);
          (%o2)                         true

     'is' intenta evaluar predicados a partir del conocimiento
     almacenado en la base de datos de 'assume'.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) assume (b > c);
          (%o2)                        [b > c]
          (%i3) is (a < b);
          (%o3)                         false
          (%i4) is (a > c);
          (%o4)                         true
          (%i5) is (equal (a, c));
          (%o5)                         false

     Si 'is' no puede evaluar el valor lógico del predicado a partir de
     la base de datos gestionada por 'assume', la variable global
     'prederror' controla el comportamiento de 'is'.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) prederror: true$
          (%i3) is (a > 0);
          Maxima was unable to evaluate the predicate:
          a > 0
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) prederror: false$
          (%i5) is (a > 0);
          (%o5)                        unknown

 -- Función: killcontext (<contexto_1>, ..., <contexto_n>)
     Elimina los contextos <contexto_1>, ..., <contexto_n>.

     Si alguno de estos contextos es el actual, el nuevo contexto activo
     será el primer subcontexto disponible del actual que no haya sido
     eliminado.  Si el primer contexto no eliminado disponible es
     'global' entonces 'initial' será usado en su lugar.  Si el contexto
     'initial' es eliminado, se creará un nuevo contexto 'initial'
     completamente vacío.

     La función 'killcontext' no elimina un contexto actualmente activo
     si es un subcontexto del contexto actual, o si se hace uso de la
     función 'activate'.

     La función 'killcontext' evalúa sus argumentos y devuelve 'done'.

 -- Función: maybe (<expr>)
     Intenta determinar si el predicado <expr> se puede deducir de los
     hechos almacenados en la base de datos gestionada por 'assume'.

     Si el predicado se reduce a 'true' o 'false', 'maybe' devuelve
     'true' o 'false', respectivamente.  En otro caso, 'maybe' devuelve
     'unknown'.

     La función 'maybe' es funcionalmente equivalente a 'is' con
     'prederror: false', pero el resultado se calcula sin asignar valor
     alguno a 'prederror'.

     Véanse también 'assume', 'facts' y 'is'.

     Ejemplos:

          (%i1) maybe (x > 0);
          (%o1)                        unknown
          (%i2) assume (x > 1);
          (%o2)                        [x > 1]
          (%i3) maybe (x > 0);
          (%o3)                         true

 -- Función: newcontext (<nombre>)
     Crea un nuevo contexto vacío <nombre>, el cual tiene a 'global'
     como su único subcontexto.  El recién creado contexto pasa a ser el
     contexto actualmente activo.

     La función 'newcontext' evalúa sus argumentos y devuelve <nombre>.

 -- Función: sign (<expr>)
     Intenta determinar el signo de <expr> en base a los hechos
     almacenados en la base de datos.  Devuelve una de las siguientes
     respuestas: 'pos' (positivo), 'neg' (negativo), 'zero' (cero), 'pz'
     (positivo o cero), 'nz' (negativo o cero), 'pn' (positivo o
     negativo), o 'pnz' (positivo, negativo o cero, lo que significa que
     el signo es desconocido).

 -- Función: supcontext (<nombre>, <contexto>)
 -- Función: supcontext (<nombre>)
     Crea un nuevo contexto <nombre>, que tiene a <contexto> como
     subcontexto.  El argumento <contexto> debe existir ya.

     Si no se especifica <context>, se tomará como tal el actual.


File: maxima.info,  Node: Funciones y variables para los predicados,  Prev: Funciones y variables para los hechos,  Up: Base de datos de Maxima

11.4 Funciones y variables para los predicados
==============================================

 -- Función: charfun (<p>)

     Devuelve 0 cuando el predicado <p> toma el valor 'false', y
     devuelve 1 cuando vale 'true'.  Si el predicado toma un valor
     diferente de 'true' y 'false' (desconocido), entonces devuelve una
     forma nominal.

     Ejemplos:

          (%i1) charfun(x<1);
          (%o1) charfun(x<1)
          (%i2) subst(x=-1,%);
          (%o2) 1
          (%i3) e : charfun('"and"(-1 < x, x < 1))$
          (%i4) [subst(x=-1,e), subst(x=0,e), subst(x=1,e)];
          (%o4) [0,1,0]

 -- Función: compare (<x>, <y>)

     Devuelve un operador de comparación <op> ('<', '<=', '>', '>=', '='
     o '#') de manera que 'is (<x> <op> <y>)' tome el valor 'true';
     cuando tanto <x> como <y> dependan de '%i' y '<x> # <y>', devuelve
     'notcomparable'; cuando no exista tal operador o Maxima sea incapaz
     de determinarlo, devolverá 'unknown'.

     Ejemplos:

          (%i1) compare(1,2);
          (%o1) <
          (%i2) compare(1,x);
          (%o2) unknown
          (%i3) compare(%i,%i);
          (%o3) =
          (%i4) compare(%i,%i+1);
          (%o4) notcomparable
          (%i5) compare(1/x,0);
          (%o5) #
          (%i6) compare(x,abs(x));
          (%o6) <=

     La función 'compare' no intenta determinar si los dominios reales
     de sus argumentos son conjuntos no vacíos; así,

          (%i1) compare(acos(x^2+1), acos(x^2+1) + 1);
          (%o1) <

     Aquí, el dominio real de 'acos (x^2 + 1)' es el conjunto vacío.

 -- Función: equal (<a>, <b>)
     Representa la equivalencia, esto es, la igualdad de los valores.

     Por sí misma, 'equal' no evalúa ni simplifica.  La función 'is'
     intenta evaluar 'equal' a un resultado booleano.  La instrucción
     'is(equal(<a>, <b>))' devuelve 'true' (o 'false') si y sólo si <a>
     y <b> son iguales (o no iguales) para todos los posibles valores de
     sus variables, tal como lo determina 'ratsimp(<a> - <b>)'; si
     'ratsimp' devuelve 0, las dos expresiones se consideran
     equivalentes.  Dos expresiones pueden ser equivalentes sin ser
     sintácticamente iguales (es decir, idénticas).

     Si 'is' no consigue reducir 'equal' a 'true' o 'false', el
     resultado está controlado por la variable global 'prederror'.  Si
     'prederror' vale 'true', 'is' emite un mensaje de error; en caso
     contrario, 'is' devuelve 'unknown'.

     Además de 'is', otros operadores evalúan 'equal' y 'notequal' a
     'true' o 'false'; a saber, 'if', 'and', 'or' y 'not'.

     La negación de 'equal' es 'notequal'.

     Ejemplos:

     Por sí misma, 'equal' no evalúa ni simplifica.

          (%i1) equal (x^2 - 1, (x + 1) * (x - 1));
                                  2
          (%o1)            equal(x  - 1, (x - 1) (x + 1))
          (%i2) equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) equal (x, y);
          (%o3)                      equal(x, y)

     La función 'is' intenta evaluar 'equal' a un resultado booleano.
     La instrucción 'is(equal(<a>, <b>))' devuelve 'true' si
     'ratsimp(<a> - <b>)' devuelve 0.  Dos expresiones pueden ser
     equivalentes sin ser sintácticamente iguales (es decir, idénticas).

          (%i1) ratsimp (x^2 - 1 - (x + 1) * (x - 1));
          (%o1)                           0
          (%i2) is (equal (x^2 - 1, (x + 1) * (x - 1)));
          (%o2)                         true
          (%i3) is (x^2 - 1 = (x + 1) * (x - 1));
          (%o3)                         false
          (%i4) ratsimp (x - (x + 1));
          (%o4)                          - 1
          (%i5) is (equal (x, x + 1));
          (%o5)                         false
          (%i6) is (x = x + 1);
          (%o6)                         false
          (%i7) ratsimp (x - y);
          (%o7)                         x - y
          (%i8) is (equal (x, y));
          (%o8)                        unknown
          (%i9) is (x = y);
          (%o9)                         false

     Si 'is' no consigue reducir 'equal' a 'true' o 'false', el
     resultado está controlado por la variable global 'prederror'.

          (%i1) [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
                              2             2
          (%o1)             [x  + 2 x + 1, x  - 2 x - 1]
          (%i2) ratsimp (aa - bb);
          (%o2)                        4 x + 2
          (%i3) prederror : true;
          (%o3)                         true
          (%i4) is (equal (aa, bb));
          Maxima was unable to evaluate the predicate:
                 2             2
          equal(x  + 2 x + 1, x  - 2 x - 1)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) prederror : false;
          (%o5)                         false
          (%i6) is (equal (aa, bb));
          (%o6)                        unknown

     Otros operadores evalúan 'equal' y 'notequal' a 'true' o 'false'.

          (%i1) if equal (y, y - 1) then FOO else BAR;
          (%o1)                          BAR
          (%i2) eq_1 : equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
                                   2                   2
          (%o3)             equal(y  + 2 y + 1, (y + 1) )
          (%i4) [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
          (%o4)                  [false, true, true]

     Debido a que 'not <expr>' obliga a la evaluación previa de <expr>,
     'not equal(<a>, <b>)' equivale a 'is(notequal(<a>, <b>))'.

          (%i1) [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
          (%o1)            [notequal(2 z, 2 z - 1), true]
          (%i2) is (notequal (2*z, 2*z - 1));
          (%o2)                         true

 -- Función: notequal (<a>, <b>)
     Representa la negación de 'equal (<a>, <b>)'.

     Ejemplos:

          (%i1) equal (a, b);
          (%o1)                      equal(a, b)
          (%i2) maybe (equal (a, b));
          (%o2)                        unknown
          (%i3) notequal (a, b);
          (%o3)                    notequal(a, b)
          (%i4) not equal (a, b);
          (%o4)                    notequal(a, b)
          (%i5) maybe (notequal (a, b));
          (%o5)                        unknown
          (%i6) assume (a > b);
          (%o6)                        [a > b]
          (%i7) equal (a, b);
          (%o7)                      equal(a, b)
          (%i8) maybe (equal (a, b));
          (%o8)                         false
          (%i9) notequal (a, b);
          (%o9)                    notequal(a, b)
          (%i10) maybe (notequal (a, b));
          (%o10)                        true

 -- Función: unknown (<expr>)
     Devuelve 'true' si y sólo si <expr> contiene un operador o función
     no reconocido por el simplificador de Maxima.

 -- Función: zeroequiv (<expr>, <v>)
     Analiza si la expresión <expr> de variable <v> equivale a cero,
     devolviendo 'true', 'false' o 'dontknow'.

     La función 'zeroequiv' tiene estas restricciones:
       1. No utilizar funciones que Maxima no sepa derivar y evaluar.
       2. Si la expresión tiene polos en la recta real, pueden aparecer
          errores en el resultado, aunque es poco probable.
       3. Si la expresión contiene funciones que no son soluciones de
          ecuaciones diferenciales ordinarias de primer orden (como las
          funciones de Bessel) pueden presentarse resultados
          incorrectos.
       4. El algoritmo utiliza evaluaciones en puntos aleatoriamente
          seleccionados.  Esto conlleva un riesgo,aunque el algoritmo
          intenta minimizar el error.

     Por ejemplo, 'zeroequiv (sin(2*x) - 2*sin(x)*cos(x), x)' devuelve
     'true' y 'zeroequiv (%e^x + x, x)' devuelve 'false'.  Por otro lado
     'zeroequiv (log(a*b) - log(a) - log(b), a)' devuelve 'dontknow'
     debido a la presencia del parámetro 'b'.


File: maxima.info,  Node: Gráficos,  Next: Lectura y escritura,  Prev: Base de datos de Maxima,  Up: Top

12 Gráficos
***********

* Menu:

* Introducción a los gráficos::
* Formatos gráficos::
* Funciones y variables para gráficos::
* Opciones gráficas::
* Opciones para Gnuplot::
* Funciones para el formato Gnuplot_pipes::


File: maxima.info,  Node: Introducción a los gráficos,  Next: Formatos gráficos,  Prev: Gráficos,  Up: Gráficos

12.1 Introducción a los gráficos
================================

Maxima utiliza un programa gráfico externo para hacer figuras (véase la
sección 'Formatos gráficos').  Las funciones gráficas calculan un
conjunto de puntos y se los pasa al programa gráfico, junto con una
serie de instrucciones.  Estas instrucciones pueden pasarse al programa
gráfico, bien a través de una tubería (pipe, en inglés), bien llamando
al programa, junto con el nombre del fichero en el que se almacenan los
datos.  Al fichero de datos se le da el nombre 'maxout.interface', donde
'interface' es el nombre del intefaz a ser utilizado ('gnuplot',
'xmaxima', 'mgnuplot' o 'gnuplot_pipes').

El fichero 'maxout.interface', si se utiliza, se almacena en la carpeta
especificada por la variable <maxima_tempdir>, cuyo valor se puede
cambiar por una cadena de texto que represente la ruta a una carpeta
válida, en la que Maxima pueda guardar nuevos ficheros.

Una vez creado el gráfico, el fichero 'maxout.interface' puede
ejecutarse nuevamente con el programa externo adecuado.  Si una
instrucción gráfica de Maxima falla, este fichero puede ser
inspeccionado a fin de encontrar el origen del problema.

Junto con las funciones gráficas descritas en esta sección, el paquete
'draw' añade otras funcionalidades.  Nótese que algunas opciones
gráficas se llaman igual en ambos contextos gráficos, pero con diferente
sintaxis; para acceder a la información de estas opciones en el ámbito
de 'draw', es necesario teclear '?? opc', donde 'opc' es el nombre de la
opción.


File: maxima.info,  Node: Formatos gráficos,  Next: Funciones y variables para gráficos,  Prev: Introducción a los gráficos,  Up: Gráficos

12.2 Formatos gráficos
======================

Actualmente, Maxima utiliza dos programas gráficos externos: Gnuplot y
Xmaxima.  Existen varios formatos diferentes para estos programas, que
pueden seleccionarse con la opción 'plot_format' (véase la sección
Opciones gráficas).

Los formatos gráficos se listan a continuación:

   * *gnuplot* (formato por defecto para Windows)

     Se utiliza para ejecutar el programa externo Gnuplot, el cual debe
     estar instalado en el sistema.  Las instrucciones gráficas y los
     datos se almacenan en el fichero 'maxout.gnuplot'.

   * *gnuplot_pipes* (formato por defecto para plataformas distintas de
     Windows)

     Este formato no está disponible en plataformas Windows.  Es similar
     al formato 'gnuplot', excepto por el hecho de que las instrucciones
     son enviadas a Gnuplot por una tubería, mientras que los datos se
     almacenan en el fichero 'maxout.gnuplot_pipes'.  Mediante esta
     técnica, un único proceso de Gnuplot se mantiene activo y sucesivos
     gráficos son enviados al mismo proceso, a menos que la tubería a
     Gnuplot se cierre con la función 'gnuplot_close()'.  Cuando se
     utiliza este formato, se puede utilizar la función 'gnuplot_replot'
     para modificar un gráfico que ya había sido representado
     previamente en la pantalla (véase 'gnuplot_replot').

     Este formato debería ser utilizado únicamente cuando se representen
     los gráficos por pantalla; para gráficos almacenados en ficheros,
     mejor utilizar el formato 'gnuplot'.

   * *mgnuplot*

     Mgnuplot es una interfaz para Gnuplot basada en Tk.  Se incluye en
     la distribución de Maxima.  Mgnuplot ofrece una interface gráfica
     de usuario rudimentaria para gnuplot, pero tiene algunas mejoras
     respecto de la interface propia de gnuplot.  Mgnuplot requiere de
     una instalación externa de Gnuplot y de Tcl/Tk.

   * *xmaxima*

     Xmaxima es un interfaz gráfico Tcl/Tk de Maxima, que también se
     puede utilizar para representar gráficos cuando Maxima se ejecuta
     desde la consola o desde otros interfaces.  Para utilizar este
     formato, debe estar instalado junto con Maxima.  Si Maxima se
     ejecuta desde el propio Xmaxima, las instrucciones gráficas y los
     datos se envían por el mismo canal de comunicación que se establece
     entre Maxima y Xmaxima (un socket).  Cuando Maxima se ejecuta desde
     una consola o desde otro interfaz, las instrucciones gráficas y los
     datos se almacenan en un fichero de nombre 'maxout.xmaxima', que le
     es pasado a Xmaxima como argumento

     En versiones anteriores, este formato se llamaba 'openmath', cuyo
     nombre se sigue aceptando como sinónimo de 'xmaxima'.


File: maxima.info,  Node: Funciones y variables para gráficos,  Next: Opciones gráficas,  Prev: Formatos gráficos,  Up: Gráficos

12.3 Funciones y variables para gráficos
========================================

 -- Función: contour_plot (<expr>, <x_range>, <y_range>, <options>, ...)

     Dibuja las curvas de nivel de <expr> en el rectángulo <x_range> por
     <y_range>.  Cualesquiera otros argumentos adicionales se tratan
     como en 'plot3d'.

     'contour_plot' sólo trabaja con los métodos 'gnuplot' o
     'gnuplot_pipes'.

     Véase también 'implicit_plot'.

     Ejemplos:

          (%i1) contour_plot (x^2 + y^2, [x, -4, 4], [y, -4, 4])$

     Se pueden añadir cualesquiera opciones que acepte 'plot3d'; por
     ejemplo, la opción 'legend' con un valor 'false', para eliminar la
     leyenda.  Gnuplot muestra por defecto tres líneas de contorno, pero
     para aumentar el número de niveles es necesario añadir algún código
     nativo de Gnuplot:

          (%i1) contour_plot (u^3 + v^2, [u, -4, 4], [v, -4, 4],
                        [legend,false],
                        [gnuplot_preamble, "set cntrparam levels 12"])$

 -- Función: get_plot_option (<keyword>, <index>)

     Devuelve el valor actual de la opción <keyword> almacenada en la
     variable global 'plot_options'.  Si <index> toma el valor 1,
     devuelve el propio valor de <keyword>; si vale 2 le añade el primer
     parámetro, y así sucesivamente.

     Véanse también 'plot_options', 'set_plot_option' y la sección
     Opciones gráficas.

 -- Función: make_transform ([<var1>, <var2>, <var3>], <fx>, <fy>, <fz>)

     Devuelve una función que se puede utilizar con la opción
     'transform_xy' de 'plot3d'.  Las tres variables ficticias <var1>,
     <var2> y <var3> representan las tres variables de la función
     'plot3d', las dos primeras independientes y la tercera dependiente.
     Las tres funciones <fx>, <fy> y <fz> deben depender solo de las
     tres variables anteriores y retornar las correspondientes x, y, z
     que se deben dibujar.  Hay dos transformaciones predefinidas:
     'polar_to_xy' y 'spherical_to_xyz'.

     Véanse 'polar_to_xy' y 'spherical_to_xyz'.

 -- Símbolo del sistema: polar_to_xy

     Cuando a la opción 'transform_xy' de 'plot3d' se le pasa el valor
     'polar_to_xy', se interpretarán las dos primeras variables
     independientes como polares, transformándolas luego a coordenadas
     cartesianas.

 -- Función: plot2d (<plot>, <x_range>, ..., <options>, ...)
 -- Función: plot2d ([<plot_1>, ..., <plot_n>], ..., <options>, ...)
 -- Función: plot2d ([<plot_1>, ..., <plot_n>], <x_range>, ...,
          <options>, ...)

     Donde <plot>, <plot_1>, ..., <plot_n> pueden ser expresiones,
     nombres de funciones o una lista de cualquiera de las siguientes
     formas: '[discrete, [<x1>, ..., <xn>], [<y1>, ..., <yn>]]',
     '[discrete, [[<x1>, <y1>], ..., [<xn>, ..., <yn>]]' o '[parametric,
     <x_expr>, <y_expr>, <t_range>]'.

     Muestra un gráfico de una o más expresiones como función de una
     variable.

     La función 'plot2d' representa uno o más gráficos en dos
     dimensiones.  Las expresiones o nombres de funciones que se
     utilicen para definir curvas deben depender todas ellas de una
     única variable <var>, siendo obligatorio utilizar <x_range> para
     nombrar la variable y darle sus valores mínimo y máximo usando la
     siguiente sintaxis: '[<variable>, <min>, <max>]'.

     Un gráfico también se puede definir de forma discreta o
     paramétrica.  La forma discreta se utiliza para dibujar un conjunto
     de puntos de coordenadas dadas.  Un gráfico discreto se define como
     una lista que empiezan con la palabra clave <discrete> seguida de
     una o dos listas de valores numéricos.  Cuando haya dos listas,
     ambas deben ser de igual longitud, la primera se interpreta como la
     de abscisas y la segunda de ordenadas.  Cuando haya una lista
     siguiendo la clave <discrete>, cada uno de sus elementos debe ser a
     su vez una lista de solo dos valores, correspondientes a las
     coordenadas x e y.

     Un gráfico paramétrico se define como una lista que empieza con la
     palabra clave <parametric>, seguida de dos expresiones o nombres de
     funciones y un rango paramétrico.  El rango paramétrico debe ser
     una lista formada con el nombre del parámetro seguido de sus
     valores mínimo y máximo: '[<param>, <min>, <max>]'.  El gráfico se
     formará con los puntos cuyas coordenadas devuelvan las dos
     expresiones o funciones, según <param> aumente desde <min> hasta
     <max>.

     La especificación del rango para el eje vertical es opcional y toma
     la forma '[y, <min>, <max>]' (<y> se utiliza siempre para el eje
     vertical).  En caso de utilizar esta opción, el gráfico mostrará
     exactamente ese rango vertical, independientemente de los valores
     alcanzados por los elementos gráficos.  Si no se especifica el
     rango vertical, se ajustará a los valores extremos alcanzados por
     las ordenadas de los puntos que aparezcan en el gráfico.

     Cualesquiera otras opciones deben ser listas, comenzando con el
     nombre de la opción seguido de uno o más valores.  Véase
     'plot_options'.

     Si hay varias expresiones para ser dibujadas, se mostrará una
     leyenda que identifique a cada una de ellas.  Las etiquetas a
     utilizar pueden especificarse con la opción <legend>.  Si no se
     utiliza esta opción, Maxima creará etiquetas a partir de las
     expresiones o nombres de funciones.

     Ejemplos:

     Dibujando la función sinusoidal:

          (%i1) plot2d (sin(x), [x, -%pi, %pi])$

     Si la función crece rápidamente puede ser necesario limitar los
     valores del eje vertical:

          (%i1) plot2d (sec(x), [x, -2, 2], [y, -20, 20])$
          plot2d: some values were clipped.

     El aspecto del gráfico puede ser diferente dependiendo del programa
     gráfico utilizado.  Por ejemplo, cuando se desactiva el marco,
     Xmaxima dibuja los ejes como flechas:

          (%i1) plot2d ( x^2-1, [x, -3, 3], [y, -2, 10],
                                [box, false], [plot_format, xmaxima])$

     Gráfico con escala logarítmica:

          (%i1) plot2d (exp(3*s), [s, -2, 2], [logy])$

     Dibujando funciones especificadas por su nombre:

          (%i1) F(x) := x^2 $
          (%i2) :lisp (defun |$g| (x) (m* x x x))
          $g
          (%i2) H(x) := if x < 0 then x^4 - 1 else 1 - x^5 $
          (%i3) plot2d ([F, G, H], [u, -1, 1], [y, -1.5, 1.5])$

     Ejemplo de función paramétrica.  Curva de la mariposa:

          (%i1) r: (exp(cos(t))-2*cos(4*t)-sin(t/12)^5)$
          (%i2) plot2d([parametric, r*sin(t), r*cos(t),
                       [t, -8*%pi, 8*%pi], [nticks, 2000]])$

     Una circunferencia de dos vueltas y solo siete puntos:

          (%i1) plot2d ([parametric, cos(t), sin(t),
                        [t, -2*%pi, 2*%pi], [nticks, 8]])$

     Dibujo de una función junto con la representación paramétrica de
     una circunferencia.  El tamaño del gráfico se ha ajustado con las
     opciones x e y para que la circunferencia no se vea como una
     elipse.  Estos valores son aceptables para el terminal Postscript
     utilizado para producir este gráfico, y puede seer necesario
     adaptar los valores para otros terminales:

          (%i1) plot2d([[parametric, cos(t), sin(t),
                        [t,0,2*%pi], [nticks, 80]],
                  abs(x)], [x,-2,2], [y, -1.5, 1.5])$
          plot2d: some values were clipped.

     Puntos discretos definiendo separadamente las coordenadas x e y:

          (%i1) plot2d ([discrete, [10, 20, 30, 40, 50],
                                   [.6, .9, 1.1, 1.3, 1.4]])$

     Los mismos puntos del ejemplo anterior, pero definiendo una a una
     las coordenadas y sin segmentos que unan los puntos:

          (%i1) plot2d([discrete, [[10, .6], [20, .9], [30, 1.1],
                                   [40, 1.3], [50, 1.4]]],
                                  [style, points])$

     En este ejemplo, se guarda una tabla de tres columnas en el archivo
     'data.txt', que luego será leído para representar las dos últimas
     columnas:

          (%i1) with_stdout ("data.txt", for x:0 thru 10 do
                                             print (x, x^2, x^3))$
          (%i2) data: read_matrix ("data.txt")$
          (%i3) plot2d ([discrete, transpose(data)[2], transpose(data)[3]],
            [style,points], [point_type,diamond], [color,red])$

     Un gráfico de datos empíricos junto con su modelo teórico:

          (%i1) xy: [[10, .6], [20, .9], [30, 1.1], [40, 1.3], [50, 1.4]]$
          (%i2) plot2d([[discrete, xy], 2*%pi*sqrt(l/980)], [l,0,50],
                  [style, points, lines], [color, red, blue],
                  [point_type, asterisk],
                  [legend, "experiment", "theory"],
                  [xlabel, "pendulum's length (cm)"],
                  [ylabel, "period (s)"])$

 -- Función: plot3d (<expr>, <x_range>, <y_range>, ..., <options>, ...)
 -- Función: plot3d ([<expr_1>, ..., <expr_n>], <x_range>, <y_range>,
          ..., <options>, ...)

     Dibuja una o más superficies definidas como funciones de dos
     variables o en forma paramétrica

     Las funciones a dibujar se pueden especificar como expresiones o
     nombres de funciones.  Puede utilizarse el ratón para hacer girar
     el gráfico y observarlo desde distintos ángulos.

     Ejemplos:

     Representación de una función:

          (%i1) plot3d (2^(-u^2 + v^2), [u, -3, 3], [v, -2, 2])$

     Uso de la opción z para acotar una función que tiende a infinito
     (en este caso, la función tiende a menos infinito en los ejes x e
     y):

          (%i1) plot3d ( log ( x^2*y^2 ), [x, -2, 2], [y, -2, 2], [z, -8, 4],
                         [palette, false], [color, magenta, blue])$

     Los valores infinitos de z se pueden obviar eligiendo una retícula
     que no coincida con las asíntotas; este ejemplo también muestra
     cómo seleccionar las paletas predefinidas, en este caso la número
     4:

          (%i1) plot3d (log (x^2*y^2), [x, -2, 2], [y, -2, 2],
                   [grid, 29, 29],
                   [palette, get_plot_option(palette,5)])$

     Dos superficies en el mismo gráfico, compartiendo el mismo dominio;
     en Gnuplot, ambas superfifies comparten la misma paleta:

          (%i1) plot3d ([2^(-x^2 + y^2), 4*sin(3*(x^2+y^2))/(x^2+y^2),
                        [x, -3, 3], [y, -2, 2]])$

     Las mismas superficies, pero con diferentes dominios; en Xmaxima
     cada superficies usa una paleta diferente, elegida de la lista
     definida por la opción 'palette':

          (%i1) plot3d ([[2^(-x^2 + y^2),[x,-2,2],[y,-2,2]],
                   4*sin(3*(x^2+y^2))/(x^2+y^2),
                   [x, -3, 3], [y, -2, 2]], [plot_format,xmaxima])$

     La botella de Klein, definida paramétricamente:

          (%i1) expr_1:5*cos(x)*(cos(x/2)*cos(y)+sin(x/2)*sin(2*y)+3.0)-10.0$
          (%i2) expr_2:-5*sin(x)*(cos(x/2)*cos(y) + sin(x/2)*sin(2*y) + 3.0)$
          (%i3) expr_3: 5*(-sin(x/2)*cos(y) + cos(x/2)*sin(2*y))$
          (%i4) plot3d ([expr_1, expr_2, expr_3], [x, -%pi, %pi],
                  [y, -%pi, %pi], [grid, 40, 40])$

     Gráfico de un armónico esférico, utilizando las transformaciones
     predefinidas 'spherical_to_xyz':

          (%i1) plot3d (sin(2*theta)*cos(phi), [theta, 0, %pi],
                        [phi, 0, 2*%pi],
                        [transform_xy, spherical_to_xyz], [grid,30,60])$

     Uso de la transformación predefinida 'polar_to_xy'.  Este ejemplo
     también muestra cómo eliminar el marco y la leyenda:

          (%i1) plot3d (r^.33*cos(th/3), [r, 0, 1], [th, 0, 6*%pi],
                   [grid, 12, 80],
                   [transform_xy, polar_to_xy], [box, false],
                   [legend,false])$

     Dibujo de una esfera utilizando la transformación esférica.  En
     Xmaxima, los tres ejes utilizan escalas proporcionales, manteniendo
     la forma simétrica de la esfera.  Se utiliza una paleta con color
     degradado:

          (%i1) plot3d ( 5, [theta, 0, %pi], [phi, 0, 2*%pi],
                   [plot_format,xmaxima],
                   [transform_xy, spherical_to_xyz],
                   [palette,[value,0.65,0.7,0.1,0.9]])$

     Definición de una función con dos variables utilizando una matriz.
     Nótese la comilla simple en la definición de la función para
     prevenir que 'plot3d' falle al detectar que la matriz necesita
     índices enteros:

          (%i1) M: matrix([1, 2, 3, 4], [1, 2, 3, 2], [1, 2, 3, 4],
                          [1, 2, 3, 3])$
          (%i2) f(x, y) := float('M [round(x), round(y)])$
          (%i3) plot3d (f(x,y), [x, 1, 4], [y, 1, 4], [grid, 4, 4])$
          apply: subscript must be an integer; found: round(x)

     Asignando a la opción 'elevation' el valor cero, una superficie
     puede verse como una aplicación en la que cada color representa un
     nivel diferente.  La opción 'colorbox' se utiliza para mostrar la
     correspondencia entre colores y niveles; las líneas de la retícula
     se desactivan para facilitar la visualización de los colores:

          (%i1) plot3d (cos (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4],
                  [mesh_lines_color, false], [elevation, 0], [azimuth, 0],
                  [colorbox, true], [grid, 150, 150])$

     Véase también la sección Opciones gráficas.

 -- Variable global: plot_options

     Los elementos de esta lista establecen las opciones por defecto
     para los gráficos.  Si una opción está presente en una llamada a
     'plot2d' o a 'plot3d', este valor adquiere prevalencia sobre las
     opciones por defecto.  En otro caso se utilizará el valor que tenga
     en 'plot_options'.  Las opciones por defecto se asignan mediante la
     función 'set_plot_option'.

     Cada elemento de 'plot_options' es una lista de dos o más
     elementos, el primero de los cuales es el nombre de la opción,
     siendo los siguientes los valores que toma.  En algunos casos el
     valor asignado es a su vez una lista, que puede contener varios
     elementos.

     Véanse también 'set_plot_option', 'get_option' y la sección
     Opciones gráficas.

 -- Función: set_plot_option (<option>)

     Acepta la mayor parte de opciones listadas en la sección Opciones
     gráficas y las almacena en la variable global 'plot_options'.

     La función 'set_plot_option' evalúa su argumento y devuelve la
     lista completa 'plot_options' tal como queda después de la
     actualización.

     Véanse también 'plot_options', 'get_option' y la sección Opciones
     gráficas.

     Ejemplos:

     Modificación de los valores para 'grid'.

          (%i1) set_plot_option ([grid, 30, 40]);
          (%o1) [[t, - 3, 3], [grid, 30, 40], [transform_xy, false],
          [run_viewer, true], [axes, true], [plot_format, gnuplot_pipes],
          [color, blue, red, green, magenta, black, cyan],
          [point_type, bullet, circle, plus, times, asterisk, box, square,
          triangle, delta, wedge, nabla, diamond, lozenge],
          [palette, [hue, 0.25, 0.7, 0.8, 0.5],
          [hue, 0.65, 0.8, 0.9, 0.55], [hue, 0.55, 0.8, 0.9, 0.4],
          [hue, 0.95, 0.7, 0.8, 0.5]], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 29], [adapt_depth, 5],
          [gnuplot_preamble, ], [gnuplot_default_term_command,
          set term pop], [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript \
          eps enhanced color solid 24], [plot_realpart, false]]

 -- Símbolo del sistema: spherical_to_xyz

     Cuando a la opción 'transform_xy' de 'plot3d' se le pasa el valor
     'spherical_to_xyz', se interpretarán las variables independientes
     como esféricas, transformándolas luego a coordenadas cartesianas.


File: maxima.info,  Node: Opciones gráficas,  Next: Opciones para Gnuplot,  Prev: Funciones y variables para gráficos,  Up: Gráficos

12.4 Opciones gráficas
======================

Todas las opciones consisten en una lista que comienza con una palabra
clave seguida de uno o más valores.  La mayor parte de las opciones
pueden utilizarse con cualquiera de las funciones gráficas <plot2d>,
<plot3d>, <contour_plot> y <implicit_plot>, o en la función
<set_plot_option>.  Las excepciones se indican en la lista siguiente.

 -- Opción para plot: adapt_depth [adapt_depth, <integer>]
     Valor por defecto: 5

     Número máximo de particiones utilizado por el algoritmo adaptativo
     de representación gráfica.

 -- Opción para plot: axes [axes, <symbol>]
     Valor por defecto: 'true'

     El argumento <symbol> puede valer 'true', 'false', 'x' o 'y'.  Si
     vale 'false', no se mostrarán los ejes; si es igual a 'x' o 'y',
     solo ese eje será el que se representa; si vale 'true', se
     mostrarán ambos ejes.

     Esta opción solo es relevante para 'plot2d' y 'implicit_plot'.

 -- Opción para plot: azimuth [azimuth, <number>]
     Valor por defecto: 30

     Un gráfico 'plot3d' se puede interpretar como comenzando
     horizontalmente en el plano xy; a partir de ahí, la coordenada z se
     eleva perpendicularmente al papel.  El eje z gira entonces
     alrededor del eje x un ángulo igual a 'elevation', luego gira el
     plano xy alrededor del nuevo eje z un ángulo 'azimuth'.  Esta
     opción establece el valor para 'azimuth' en grados sexagesimales.

     Véase también 'elevation'.

 -- Opción para plot: box [box, <symbol>]
     Valor por defecto: 'true'

     Si vale 'true', se representará el marco para el gráfico; si vale
     'false', no.

 -- Opción para plot: color [color, <color_1>, ..., <color_n>]
     Valor por defecto: blue, red, green, magenta, black, cyan

     Define el color para las curvas en 'plot2d' y 'implicit_plot'.  En
     'plot3d' define los colores para el enrejado de las superficies si
     no se utiliza la paleta; una cara de la superficie tendrá <color_1>
     y la otra <color_2>, o el mismo color si se especifica solo uno.

     Si hay más curvas o superficies que caras, los colores se repetirán
     secuencialmente.  Con Gnuplot, los colores pueden ser: azul, rojo,
     verde, magenta, negro y cián; con Xmaxima, los colores pueden ser
     esos mismos, o una cadena de texto que comienza con el carácter '#'
     seguido de seis dígitos hexadecimales: dos para la componente roja,
     otros dos para la verde y otros dos para la azul.  Si se introduce
     un nombre de color no reconocido, en su lugar se utilizará el
     negro.

 -- Opción para plot: colorbox [colorbox, <symbol>]
     Valor por defecto: 'false'

     El argumento <symbol> puede valer 'true' o 'false'.  Si vale 'true'
     y 'plot3d' utiliza la paleta de colores para representar diferentes
     valores de z, se dibujará un rectángulo en la parte derecha,
     indicando los colores utilizados para los diferentes valores de z.
     Esta opción no funciona en Xmaxima.

 -- Opción para plot: elevation [elevation, <number>]
     Valor por defecto: 60

     Un gráfico 'plot3d' se puede interpretar como comenzando
     horizontalmente en el plano xy; a partir de ahí, la coordenada z se
     eleva perpendicularmente al papel.  El eje z gira entonces
     alrededor del eje x un ángulo igual a 'elevation', luego gira el
     plano xy alrededor del nuevo eje z un ángulo 'azimuth'.  Esta
     opción establece el valor para 'elevation' en grados sexagesimales.

     Véase también 'azimuth'.

 -- Opción para plot: grid [grid, <integer>, <integer>]
     Valor por defecto: 30, 30

     Establece el número de puntos para los puntos de la rejilla en las
     direcciones x e y en escenas 3D.

 -- Opción para plot: legend [legend, <string_1>, ..., <string_n>]
 -- Opción para plot: legend [legend, <false>]

     Especifica las etiquetas para los gráficos en los que aparecen
     varios objetos.  Si hay más expresiones que etiquetas, éstas se
     repetirán.  Con el valor 'false' no se mostrarán etiquetas.  Por
     defecto se pasarán los nombres de las expresiones o funciones, o
     las palabras 'discrete1', 'discrete2', ..., para gráficos de
     puntos.  Esta opción no se puede utilizar con <set_plot_option>.

 -- Opción para plot: logx [logx]

     Hace que el eje de abscisas se dibuje en la escala logarítmica.
     Esta opción no se puede utilizar con <set_plot_option>.

 -- Opción para plot: logy [logy]

     Hace que el eje de ordenadas se dibuje en la escala logarítmica.
     Esta opción no se puede utilizar con <set_plot_option>.

 -- Opción para plot: mesh_lines_color [mesh_lines_color, <color>]
     Valor por defecto: 'black'

     Establece el color del enrejado en los gráficos creados por
     'plot3d' cuando se utiliza una paleta.  Acepta los mismos colores
     que la opción 'color'.  También se le puede dar el valor 'false'
     para eliminar el enrejado.

 -- Opción para plot: nticks [nticks, <integer>]
     Valor por defecto: 29

     Cuando se dibujan funciones con 'plot2d', establece el número
     inicial de puntos utilizado por la rutina gráfica adaptativa.
     Cuando se dibujan funciones con 'plot3d' o paramétricas con
     'plot2d', su valor es igual al número de puntos que se
     representarán en el gráfico.

 -- Opción para plot: palette [palette, [<palette_1>], ...,
          [<palette_n>]]
 -- Opción para plot: palette [palette, <false>]
     Valor por defecto: [hue, 0.25, 0.7, 0.8, 0.5], [hue, 0.65, 0.8,
     0.9, 0.55], [hue, 0.55, 0.8, 0.9, 0.4], [hue, 0.95, 0.7, 0.8, 0.5]

     Puede consistir en una paleta o en una lista de varias paletas.
     Cada paleta es una lista con una palabra clave seguida de cuatro
     números.  Los tres primeros números, que deben tomar valores entre
     0 y 1, definen el matiz, la saturación y el valor de un color
     básico a asignar al mínimo valor de z.  La palabra clave especifica
     cuál de los tres atributos ('hue', 'saturation' o 'value')
     incrementará de acuerdo con los valores de z.  El último número se
     corresponde con el incremento del máximo valor de z.  Este último
     número puede ser mayor que 1 o negativo.

     Gnuplot solo utiliza la primera paleta de la lista; Xmaxima
     utilizará las paletas de la lista secuencialmente cuando haya que
     representar varias superficies conjuntamente; si el número de
     paletas no es suficiente, se repetirán también de forma secuencial.

     El color del enrrejado de la superficie se establece con
     'mesh_lines_color'.  Si 'palette' tiene el valor 'false', las
     superficies se representan solo con el enrrejado; en tal caso, el
     color de las líneas será el determinado por 'color'.

 -- Opción para plot: plot_format [plot_format, <format>]
     Valor por defecto: en sistemas Windows, 'gnuplot'; en otros,
     'gnuplot_pipes'

     Establece el formato a utlizar por las rutinas gráficas.

     Debe tomar uno de los siguientes valores: 'gnuplot', 'xmaxima',
     'mgnuplot' o 'gnuplot_pipes'.

 -- Opción para plot: plot_realpart [plot_realpart, <symbol>]
     Valor por defecto: 'false'

     Cuando vale 'true', se representa gráficamente la parte real de las
     funciones; equivale a ejecutar 'realpart(<función>)'.  Si vale
     'false', no se representa nada cuando la función no devuelva un
     valor real.  Por ejemplo, si 'x' es negativo, 'log(x)' devuelve un
     valor negativo cuya parte real es 'log(abs(x))'; en tal caso, si
     'plot_realpart' vale 'true', 'log(-5)' se representa como 'log(5)',
     mientras que no se representa nada si 'plot_realpart' vale 'false'.

 -- Opción para plot: point_type [point_type, <type_1>, ..., <type_n>]
     Valor por defecto: 'bullet', 'circle', 'plus', 'times', 'asterisk',
     'box', 'square', 'triangle', 'delta', 'wedge', 'nabla', 'diamond',
     'lozenge'

     En Gnuplot, cada conjunto de puntos que vaya a ser representado con
     los estilos 'points' o 'linespoints' se hará con objetos tomados de
     esta lista en orden secuencial.  Si hay más conjuntos de puntos que
     objetos en la lista, se irán repitiendo de forma secuencial.  Los
     objetos que pueden ser utilizados son: 'bullet', 'circle', 'plus',
     'times', 'asterisk', 'box', 'square', 'triangle', 'delta', 'wedge',
     'nabla', 'diamond' o 'lozenge'

 -- Opción para plot: psfile [psfile, <string>]

     Guarda el gráfico en formato Postscript con nombre <string> en
     lugar de mostrarlo en pantalla.  Por defecto, el fichero se creará
     en la carpeta definida en la variable <maxima_tempdir>, cuyo valor
     se podrá cambiar para almacenar el fichero en otra carpeta.

 -- Opción para plot: run_viewer [run_viewer, <symbol>]
     Valor por defecto: 'true'

     Controla si el visor apropiado para la salida gráfica debe
     ejecutarse o no.

 -- Opción para plot: style [style, <type_1>, ..., <type1_n>]
 -- Opción para plot: style [style, [<style_1>], ..., [<style_n>]]
     Valor por defecto: <lines> (dibuja todos los puntos unidos por
     líneas de ancho 1 y con el primer color de la lista de la opción
     'color').

     Estilos a utilizar para las funciones o conjuntos de datos en
     gráficos 2d.  A la palabra 'style' debe seguirle uno o más estilos.
     Si hay más funciones o conjuntos de datos que estilos, éstos se
     repetirán.  Los estilos que se admiten son: <lines> para segmentos
     lineales, <points> para puntos aislados, <linespoints> para
     segmentos y puntos, <dots> para pequeños puntos aislados.  Gnuplot
     también acepta el estilo <impulses>.

     Los estilos se pueden escribir como elementos de una lista, junto
     con algunos parámetros adicionales.  <lines> acepta uno o dos
     números: el ancho de la línea y un entero que identifica el color.
     Los códigos de color por defecto son: 1, azul; 2, rojo; 3, magenta;
     4, naranja; 5, marrón; 6, verde lima; 7, aguamarina.  En caso de
     utilizar Gnuplot con un terminal diferente de X11, estos colores
     pueden cambiar; por ejemplo, bajo la opción [<gnuplot_term>,<ps>],
     el índice 4 se corresponde con el negro en lugar del naranja.

     <points> acepta uno, dos o tres parámetros; el primer parámetro es
     el radio de los puntos, el segundo es un entero para seleccionar el
     color, con igual codificación que en <lines> y el tercer parámetro
     sólo es utilizado por Gnuplot y hace referencia a varios objetos
     para representar los puntos.  Los tipos de objetos disponibles son:
     1, círculos rellenos; 2, circunferencias; 3, +; 4, x; 5, *; 6,
     cuadrados rellenos; 7, cuadrados huecos; 8, triángulos rellenos; 9,
     triángulos huecos; 10, triángulos rellenos invertidos; 11,
     triángulos huecos invertidos; 12, rombos rellenos; 13, rombos
     huecos.

     <linesdots> acepta hasta cuatro parámetros: ancho de línea, radio
     de los puntos, color y tipo de objetos para representar puntos.

     Véanse también 'color' y 'point_type'.

 -- Opción para plot: transform_xy [transform_xy, <symbol>]
     Valor por defecto: 'false'

     La variable <symbol> puede ser 'false' o el resultado devuelto por
     la función 'transform_xy'.  Si es distinto de 'false', se utiliza
     para transformar las tres coordenadas en 'plot3d'.

     Véanse 'make_transform', 'polar_to_xy' y 'spherical_to_xyz'.

 -- Opción para plot: x [x, <min>, <max>]

     Cuando se utiliza como primera opción en una instrucción para un
     gráfico 2D (o cualquiera de las dos primeras en un gráfico 3D),
     indica que su primera variable independiente es x y ajusta su
     rango.  También se puede utilizar después de la primera opción (o
     después de la segunda opción en un gráfico 3D) para definir el
     dominio horizontal que se representará en el gráfico.

 -- Opción para plot: xlabel [xlabel, <string>]

     Especifica la etiqueta para el primer eje.  Si no se utiliza esta
     opción, la etquieta será el nombre de la variable independiente,
     cuando se utilicen 'plot2d' o 'implicit_plot', o el nombre de la
     primera variable cuando se utilicen 'plot3d' o 'contour_plot', o la
     primera expresión en el caso de una curva paramétrica.  No puede
     utilizarse con <set_plot_option>.

 -- Opción para plot: y [y, <min>, <max>]

     Cuando se utiliza como una de las dos primeras opciones en
     'plot3d', indica que una de las variables independientes es "y" y
     ajusta su rango.  En otro caso, define el dominio de la segunda
     variable que se mostrará en el gráfico.

 -- Opción para plot: ylabel [ylabel, <string>]

     Especifica la etiqueta para el segundo eje.  Si no se utiliza esta
     opción, la etiqueta será "y", cuando se utilicen 'plot2d' o
     'implicit_plot', o el nombre de la segunda variable cuando se
     utilicen 'plot3d' o 'contour_plot', o la segunda expresión en el
     caso de una curva paramétrica.  No puede utilizarse con
     <set_plot_option>.

 -- Opción para plot: z [z, <min>, <max>]

     Se utiliza en 'plot3d' para ajustar el rango de valores de z que se
     mostrará en el gáfico.

 -- Opción para plot: zlabel [zlabel, <string>]

     Especifica la etiqueta para el tercer eje cuando se utiliza
     'plot3d'.  Si no se utiliza esta opción, la etiqueta será "z" en el
     caso de superficies, o la tercera expresión en el caso de una curva
     paramétrica.  No puede utilizarse con <set_plot_option> y se ignora
     en 'plot2d' y 'implicit_plot'.


File: maxima.info,  Node: Opciones para Gnuplot,  Next: Funciones para el formato Gnuplot_pipes,  Prev: Opciones gráficas,  Up: Gráficos

12.5 Opciones para Gnuplot
==========================

Hay varias opciones gráficas que son específicas de Gnuplot.  Algunas de
ellas son comandos propios de Gnuplot que se especifican como cadenas de
texto.  Consúltese la documentación de Gnuplot para más detalles.

 -- Opción para plot: gnuplot_term

     Establece el terminal de salida para Gnuplot.

        * *default* (valor por defecto)

          Gnuplot muestra el gráfico en una ventana gráfica.

        * *dumb*

          Gnuplot muestra el gráfico en la consola de Maxima en estilo
          ASCII artístico.

        * *ps*

          Gnuplot genera código en lenguaje PostScript.  Si a la opción
          'gnuplot_out_file' se le da el valor <filename>, Gnuplot
          escribe el código PostScript en <filename>.  En caso
          contrario, se guarda en el archivo 'maxplot.ps'.

        * Cualquier otro terminal admitido por Gnuplot.

          Gnuplot puede generar gráficos en otros muchos formatos, tales
          como png, jpeg, svg etc.  Para crear gráficos en cualquera de
          estos formatos, a la opción 'gnuplot_term' se le puede asignar
          cualquiera de los terminales admitidos por Gnuplot, bien por
          su nombre (símbolo) bien con la especificación completa del
          terminal (cadena).  Por ejemplo, '[gnuplot_term,png]' guarda
          el gráfico en formato PNG (Portable Network Graphics),
          mientras que '[gnuplot_term,"png size 1000,1000"]' lo hace con
          dimensiones 1000x1000 píxeles.  Si a la opción
          'gnuplot_out_file' se le da el valor <filename>, Gnuplot
          escribe el código PostScript en <filename>.  En caso
          contrario, se guarda en el archivo 'maxplot.<term>', siendo
          <term> el nombre del terminal.

 -- Opción para plot: gnuplot_out_file

     Cuando se utiliza conjuntamente con la opción 'gnuplot_term', puede
     utilizarse para almacenar el gráfico en un fichero en uno de los
     formatos aceptados por Gnuplot.  Si se quiere crear un fichero
     Postscript se puede utilizar la opción 'psfile', que también
     funciona con Openmath.

          [gnuplot_term, png], [gnuplot_out_file, "graph3.png"]

 -- Opción para plot: gnuplot_pm3d

     Controla la utilización del modo PM3D, que tiene capacidades
     avanzadas para gráficos tridimensionales.  PM3D sólo está
     disponible en versiones de Gnuplot posteriores a la 3.7.  El valor
     por defecto de 'gnuplot_pm3d' es 'false'.

 -- Opción para plot: gnuplot_preamble

     Introduce instrucciones de Gnuplot antes de que se haga el gráfico.
     Puede utilizarse cualquier comando válido de Gnuplot.  Si interesa
     introducir varios comandos se separarán con punto y coma.  El valor
     por defecto de 'gnuplot_preamble' es la cadena vacía '""'.

 -- Opción para plot: gnuplot_curve_titles

     Opción obsoleta que ha sido sustituida por 'legend'.

 -- Opción para plot: gnuplot_curve_styles

     Opción obsoleta que ha sido sustituida por 'style'.

 -- Opción para plot: gnuplot_default_term_command

     Comando de Gnuplot para establecer el tipo de terminal por defecto.
     El valor por defecto es 'set term pop'.

 -- Opción para plot: gnuplot_dumb_term_command

     Comando de Gnuplot para establecer el tipo de terminal para el
     terminal oculto.  El valor por defecto es '"set term dumb 79 22"',
     que da una salida de texto de 79 por 22 caracteres.

 -- Opción para plot: gnuplot_ps_term_command

     Comando de Gnuplot para establecer el tipo de terminal para el
     terminal PostScript.  El valor por defecto es '"set size 1.5,
     1.5;set term postscript eps enhanced color solid 24"', que
     establece un tamaño de 1.5 veces el valor por defecto de gnuplot,
     junto con un tamaño de fuente de 24, entre otras cosas.  Consúltese
     la documentación de gnuplot para más información sobre 'set term
     postscript'.


File: maxima.info,  Node: Funciones para el formato Gnuplot_pipes,  Prev: Opciones para Gnuplot,  Up: Gráficos

12.6 Funciones para el formato Gnuplot_pipes
============================================

 -- Función: gnuplot_start ()

     Inicializa una tubería hacia Gnuplot, con el fin de ser utilizada
     para utilizar el formato 'gnuplot_pipes'.  No es necesario
     inicializarla manualmente antes de hacer gráficos.

 -- Función: gnuplot_close ()

     Cierra la tubería hacia Gnuplot que haya sido utilizada para hacer
     gráficos.

 -- Función: gnuplot_restart ()

     Cierra la tubería hacia Gnuplot que haya sido utilizada para hacer
     gráficos e inicializa una nueva.

 -- Función: gnuplot_replot ()
 -- Función: gnuplot_replot (<s>)

     Actualiza la ventana de Gnuplot.  Si 'gnuplot_replot' es invocada
     con un comando de Gnuplot en la cadena <s>, entonces <s> es enviada
     a Gnuplot antes de redibujar la ventana.

 -- Función: gnuplot_reset ()

     Resetea Gnuplot cuando se utiliza el formato 'gnuplot_pipes'.  Para
     actualizar la ventana de Gnuplot invóquese a 'gnuplot_replot'
     después de 'gnuplot_reset'.


File: maxima.info,  Node: Lectura y escritura,  Next: Polinomios,  Prev: Gráficos,  Up: Top

13 Lectura y escritura
**********************

* Menu:

* Comentarios::
* Archivos::
* Funciones y variables para lectura y escritura::
* Funciones y variables para salida TeX::
* Funciones y variables para salida Fortran::


File: maxima.info,  Node: Comentarios,  Next: Archivos,  Prev: Lectura y escritura,  Up: Lectura y escritura

13.1 Comentarios
================

En Maxima, un comentario es cualquier texto encerrado entre las marcas
'/*' y '*/'.

El analizador sintáctico de Maxima trata los comentarios como espacios
en blanco a efectos de encontrar tokens en el flujo de entrada.  Una
entrada tal como 'a/* foo */b' contiene dos tokens, 'a' y 'b', no un
único token 'ab'.  En cualquier otro contexto, los comentarios son
ignorados por Maxima; no se almacenan ni sus contenidos ni sus
localizaciones.

Los comentarios pueden anidarse hasta una profundidad arbitraria.  Las
marcas '/*' y '*/' deben emparejarse y debe haber igual número de ambos.

Ejemplos:

     (%i1) /* aa is a variable of interest */  aa : 1234;
     (%o1)                         1234
     (%i2) /* Value of bb depends on aa */  bb : aa^2;
     (%o2)                        1522756
     (%i3) /* User-defined infix operator */  infix ("b");
     (%o3)                           b
     (%i4) /* Parses same as a b c, not abc */  a/* foo */b/* bar */c;
     (%o4)                         a b c
     (%i5) /* Comments /* can be nested /* to any depth */ */ */  1 + xyz;
     (%o5)                        xyz + 1


File: maxima.info,  Node: Archivos,  Next: Funciones y variables para lectura y escritura,  Prev: Comentarios,  Up: Lectura y escritura

13.2 Archivos
=============

Un archivo no es más que una área de un cierto dispositivo de
almacenamiento que contiene datos o texto.  Los archivos se agrupan en
los discos en "directorios", que son listas de archivos.  Instrucciones
que operan con archivos son:

        appendfile           batch                 batchload
        closefile            file_output_append    filename_merge
        file_search          file_search_maxima    file_search_lisp
        file_search_demo     file_search_usage     file_search_tests
        file_type            file_type_lisp        file_type_maxima
        load                 load_pathname         loadfile
        loadprint            pathname_directory    pathname_name
        pathname_type        printfile             save
        stringout            with_stdout           writefile

Cuando el nombre de un fichero se pasa a funciones como 'plot2d', 'save'
o 'writefile' y en él no se incluye la ruta de acceso, Maxima almacena
el fichero en la carpeta de trabajo actual.  La ubicación de la carpeta
de trabajo depende del sistema operativo y de la instalación.


File: maxima.info,  Node: Funciones y variables para lectura y escritura,  Next: Funciones y variables para salida TeX,  Prev: Archivos,  Up: Lectura y escritura

13.3 Funciones y variables para lectura y escritura
===================================================

 -- Función: appendfile (<filename>)
     Añade información de la consola a <filename>, de igual manera que
     lo hace 'writefile', pero con la salvedad de que si el archivo ya
     existe la información queda añadida al final de su contenido.

     La función 'closefile' cierra los archivos abiertos por
     'appendfile' o 'writefile'.

 -- Función: batch (<filename>)
 -- Function: batch (<filename>, 'option')

     'batch(<filename>)' lee expresiones de Maxima desde <filename> y
     las evalúa.  La función 'batch' busca <filename> en la lista
     'file_search_maxima'.  Véase 'file_search'.

     'batch(<filename>, test)' es como 'run_testsuite' con la opción
     'display_all=true'.  En este caso 'batch' busca <filename> en la
     lista 'file_search_maxima' y no en 'file_search_tests' como hace
     'run_testsuite'.  Además, 'run_testsuite' ejecuta tests que están
     en la lista 'testsuite_files'.  Con 'batch' es posible ejecutar
     cualquier fichero que se encuentre en 'file_search_maxima' en modo
     de prueba.

     El contenido de <filename> debe ser una secuencia de expresiones de
     Maxima, cada una de las cuales termina en ';' o '$'.  La variable
     especial '%' y la función '%th' se refieren a resultados previos
     dentro del archivo.  El archivo puede incluir construcciones del
     tipo ':lisp'.  Espacios, tabulaciones y saltos de línea en el
     archivo se ignoran.  Un archivo de entrada válido puede crearse con
     un editor de texto o con la función 'stringout'.

     La función 'batch' lee las expresiones del archivo <filename>,
     muestra las entradas en la consola, realiza los cálculos
     solicitados y muestra las expresiones de los resultados.  A las
     expresiones de entrada se les asignan etiquetas, así como a las de
     salida.  La función 'batch' evalúa todas las expresiones de entrada
     del archivo a menos que se produzca un error.  Si se le solicita
     información al usuario (con 'asksign' o 'askinteger', por ejemplo)
     'batch' se detiene para leer la nueva información para luego
     continuar.

     Es posible detener 'batch' tecleando 'control-C' desde la consola.
     El efecto de 'control-C' depende del entorno Lisp instalado.

     La función 'batch' tiene diversas aplicaciones, tales como servir
     de almacén de código escrito por el usuario, suministrar
     demostraciones libres de errores o ayudar a organizar el trabajo
     del usuario en la resolución de problemas complejos.

     La función 'batch' evalúa su argumento y devuelve la ruta hacia
     <filename> en formato cadena cuando es invocada sin segundo
     argumento o con la opción 'demo'.  Cuando es llamada con la opción
     'test', devuelve la lista vacía '[]' o una lista con <filename> y
     los números de tests que han fallado.

     Véanse también 'load', 'batchload' y 'demo'.

 -- Función: batchload (<filename>)
     Lee expresiones de Maxima desde <filename> y las evalúa sin mostrar
     las entradas ni las salidas y sin asignarles etiquetas.  Sin
     embargo, las salidas producidas por 'print' o 'describe' sí se
     muestran.

     La variable especial '%' y la función '%th' se refieren a
     resultados previos del intérprete interactivo, no a los del propio
     archivo.  El archivo no puede incluir construcciones del tipo
     ':lisp'.

     La función 'batchload' devuelve la ruta de <filename> en formato de
     cadena.

     La función 'batchload' evalúa sus argumentos.

     Véanse también 'batch' y 'load'.

 -- Función: closefile ()
     La función 'closefile' cierra los archivos abiertos por
     'appendfile' o 'writefile'.

 -- Variable opcional: file_output_append
     Valor por defecto: 'false'

     La variable 'file_output_append' controla si las funciones de
     escritura de ficheros añaden información o sustituyen el fichero de
     salida.  Cuando 'file_output_append' toma el valor 'true', estas
     funciones amplían el contenido de sus ficheros de salida; en otro
     caso, sustituyen el fichero anterior de igual nombre por otro con
     el nuevo contenido.

     Las funciones 'save', 'stringout' y 'with_stdout' se ven afectadas
     por el valor que tome la variable 'file_output_append'.  Otras
     funciones que también escriben en ficheros de salida no tienen en
     cuenta este valor; en concreto, las funciones para la
     representación de gráficos y las de traducción siempre sustituyen
     el fichero anterior por uno nuevo de igual nombre, mientras que las
     funciones 'tex' y 'appendfile' siempre añaden información al
     fichero de salida sin eliminar la información anterior.

 -- Función: filename_merge (<path>, <filename>)
     Construye una ruta modificada a partir de <path> y <filename>.  Si
     la componente final de <path> es de la forma '###.<something>', la
     componente se reemplaza con '<filename>.<something>'.  En otro
     caso, la componente final se reemplaza simplemente por <filename>.

     El resultado es un objeto Lisp de tipo pathname.

 -- Función: file_search (<filename>)
 -- Función: file_search (<filename>, <pathlist>)

     La función 'file_search' busca el archivo <filename> y devuelve su
     ruta como una cadena; si no lo encuentra, 'file_search' devuelve
     'false'.  La llamada 'file_search (<filename>)' busca en los
     directorios de búsqueda por defecto, que son los especificados por
     las variables 'file_search_maxima', 'file_search_lisp' y
     'file_search_demo'.

     La función 'file_search' analiza primero si el nombre del argumento
     existe antes de hacerlo coincidir con los comodines de los patrones
     de búsqueda de archivos.  Véase 'file_search_maxima' para más
     información sobre patrones de búsqueda de archivos.

     El argumento <filename> puede ser una ruta con nombre de archivo, o
     simplemente el nombre del archivo, o, si el directorio de búsqueda
     de archivo incluye un patrón de búsqueda, es suficiente con el
     nombre de archivo sin extensión.  Por ejemplo,

          file_search ("/home/wfs/special/zeta.mac");
          file_search ("zeta.mac");
          file_search ("zeta");

     todos buscan el mismo archivo, dando por hecho que el archivo
     existe y que '/home/wfs/special/###.mac' está en
     'file_search_maxima'.

     La llamada 'file_search (<filename>, <pathlist>)' busca solamente
     en los directorios especificados por <pathlist>, que es una lista
     de cadenas.  El argumento <pathlist> ignora los directorios de
     búsqueda por defecto, de manera que si se da la lista de rutas,
     'file_search' busca solamente en ellas y no en los directorios por
     defecto.  Incluso si hay un único directorio en <pathlist>, debe
     ser suministrado como una lista de un único elemento.

     El usuario puede modificar los directorios de búsqueda por defecto;
     véase para ello See 'file_search_maxima'.

     La función 'file_search' es llamada por 'load' con los directorios
     de búsqueda 'file_search_maxima' y 'file_search_lisp'.

 -- Variable opcional: file_search_maxima
 -- Variable opcional: file_search_lisp
 -- Variable opcional: file_search_demo
 -- Variable opcional: file_search_usage
 -- Variable opcional: file_search_tests

     Estas variables especifican listas de directorios en los que deben
     buscar la funciones 'load', 'demo' y algunas otras.  Los valores
     por defecto de estas variables nombran directorios de la
     instalación de Maxima.

     El usuario puede modificar estas variables, bien reemplazando los
     valores por defecto, bien añadiendo nuevos directorios.  Por
     ejemplo,

          file_search_maxima: ["/usr/local/foo/###.mac",
              "/usr/local/bar/###.mac"]$

     reemplaza el valor por defecto de 'file_search_maxima', mintras que

          file_search_maxima: append (file_search_maxima,
              ["/usr/local/foo/###.mac", "/usr/local/bar/###.mac"])$

     añade dos directorios más.  Puede ser conveniente colocar una
     expresión como esta en el archivo 'maxima-init.mac', de manera que
     la ruta de búsqueda de ficheros se asigne automáticamente cada vez
     que arranca Maxima.

     Se pueden especificar varias extensiones de archivos y rutas con
     comodines especiales.  La cadena '###' representa el nombre del
     archivo buscado y una lista separada de comas y encerrada entre
     llaves, '{foo,bar,baz}' representa múltiples cadenas.  Por ejemplo,
     suponiendo que se busca el nombre 'neumann',

          "/home/{wfs,gcj}/###.{lisp,mac}"

     se interpreta como '/home/wfs/neumann.lisp',
     '/home/gcj/neumann.lisp', '/home/wfs/neumann.mac' y
     '/home/gcj/neumann.mac'.

 -- Función: file_type (<filename>)
     Devuelve una descripción del contenido de <filename> basada en la
     extensión, sin intentar abrir el archivo para inspeccionar su
     contenido.

     El valor devuelto es un símbolo 'object', 'lisp' o 'maxima'.  Si la
     extensión es "mac", "mc", "demo", "dem", "dm1", "dm2", "dm3" o
     "dmt", 'file_type' devuelve 'maxima'.  Si la extensión es "l",
     "lsp" o "lisp", 'file_type' devuelve 'lisp'.  Si la extensión no es
     ninguna de las anteriores, 'file_type' devuelve 'object'.

     Véase también 'pathname_type'.

     Ejemplos:

          (%i2) map('file_type,["test.lisp", "test.mac", "test.dem", "test.txt"]);
          (%o2)            [lisp, maxima, maxima, object]

 -- Variable opcional: file_type_lisp
     Valor por defecto: '[l, lsp, lisp]'

     'file_type_lisp' es una lista con extensiones de ficheros que
     Maxima reconoce como fuente de Lisp.

     Véase también 'file_type'

 -- Variable opcional: file_type_maxima
     Valor por defecto: '[mac, mc, demo, dem, dm1, dm2, dm3, dmt]'

     'file_type_maxima' es una lista con extensiones de ficheros que
     Maxima reconoce como fuente de Maxima.

     Véase también 'file_type'

 -- Función: load (<filename>)
     Evalúa las expresiones del archivo <filename>, trayendo variables,
     funciones y otros objetos a Maxima.  Una asignación hecha
     previamente a una variable en Maxima será destruida por otra
     asignación que se le haga en <filename>.  Para encontrar el
     fichero, 'load' llama a 'file_search' con 'file_search_maxima' y
     'file_search_lisp' como directorios de búsqueda.  Si la llamada a
     'load' funciona correctamente, devuelve el nombre del fichero; en
     caso contrario, 'load' muestra un mensaje de error.

     La función 'load' trabaja indistintamente con código Lisp y Maxima.
     Los ficheros creados con 'save', 'translate_file' y 'compile_file',
     que crea código Lisp, y 'stringout', que crea código Maxima, todos
     ellos pueden ser procesados por 'load'.  La función 'load' llama a
     'loadfile' para cargar archivos en Lisp y a 'batchload' para cargar
     archivos en Maxima.

     La función 'load' no reconoce las construcciones de tipo ':lisp' en
     ficheros de Maxima.  Además, mientras se está procesando
     <filename>, las variables globales '_', '__', '%' y '%th' mantienen
     los valores que tenían cuando se realizó la llamada a 'load'.

     Véanse también 'loadfile', 'batch', 'batchload' y 'demo';
     'loadfile' procesa archivos en Lisp; 'batch', 'batchload' y 'demo'
     procesan archivos en Maxima.

     Véase 'file_search' para más detalles sobre el mecanismo de
     búsqueda de archivos.

     La función 'load' evalúa sus argumentos.

 -- Variable del sistema: load_pathname
     Valor por defecto: 'false'

     Cuando se carga un fichero con las funciones 'load', 'loadfile' o
     'batchload', a la variable 'load_pathname' se le asigna la ruta al
     fichero en cuestión.

     Se puede acceder a la variable 'load_pathname' mientras se está
     cargando el fichero.

     Ejemplo:

     Supóngase que se tiene el fichero 'test.mac' en la carpeta
     '"/home/usuario/workspace/mymaxima/temp/"' con las siguientes
     instrucciones:

          print("The value of load_pathname is: ", load_pathname)$
          print("End of batchfile")$

     Entonces se obtiene el siguiente resultado:

          (%i1) load("/home/usuario/workspace/mymaxima/temp/test.mac")$
          The value of load_pathname is:
                             /home/usuario/workspace/mymaxima/temp/test.mac
          End of batchfile

 -- Función: loadfile (<filename>)
     Evalúa las expresiones Lisp del archivo <filename>.  La función
     'loadfile' no llama a 'file_search', de manera que 'filename' debe
     incluir la extensión del archivo y su ruta completa.

     La función 'loadfile' puede procesar ficheros creados por 'save',
     'translate_file' y 'compile_file'.  Puede ser más conveniente
     utilizar 'load' en lugar de 'loadfile'.

 -- Variable opcional: loadprint
     Valor por defecto: 'true'

     La variable 'loadprint' indica si mostrar un mensaje cuando se
     carga un archivo.

        * Si 'loadprint' vale 'true', se muestra siempre un mensaje.
        * Si 'loadprint' vale ''loadfile', muestra un mensaje sólo si el
          archivo es cargado con la función 'loadfile'.
        * Si 'loadprint' vale ''autoload', muestra un mensaje sólo
          cuandi un archivo se carga automáticamente.  Véase
          'setup_autoload'.
        * Si 'loadprint' vale 'false', nunca mostrará mensajes.

 -- Variable opcional: packagefile
     Valor por defecto: 'false'

     Los desarrolladores de paquetes que utilizan 'save' o 'translate'
     para crear paquetes (ficheros) que van a ser utilizados por
     terceros pueden hacer 'packagefile: true' para evitar que se añada
     información a la listas de información de Maxima, como 'values' o
     'functions'.

 -- Función: pathname_directory (<pathname>)
 -- Función: pathname_name (<pathname>)
 -- Función: pathname_type (<pathname>)

     Estas funciones devuelven las componentes de <pathname>.

     Ejemplos:

          (%i1) pathname_directory("/home/usuario/maxima/changelog.txt");
          (%o1)                 /home/usuario/maxima/
          (%i2) pathname_name("/home/usuario/maxima/changelog.txt");
          (%o2)                       changelog
          (%i3) pathname_type("/home/usuario/maxima/changelog.txt");
          (%o3)                          txt

 -- Función: printfile (<path>)

     Envía el fichero al que hace referncia la ruta <path> a la consola.
     <path> puede ser una cadena o un símbolo, en cuyo caso se
     convertirá en una cadena.

     Si <path> hace referencia a un fichero accesible desde el
     directorio actual de trabajo, entonces se enviará a la consola; en
     caso contrario, 'printfile' intentará localizar el fichero
     añadiéndole <path> a cada uno de los elementos de
     'file_search_usage' a través de 'filename_merge'.

     'printfile' devuelve la ruta del fichero encontado.

 -- Función: save (<filename>, <name_1>, <name_2>, <name_3>, ...)
 -- Función: save (<filename>, values, functions, labels, ...)
 -- Función: save (<filename>, [<m>, <n>])
 -- Función: save (<filename>, <name_1>=<expr_1>, ...)
 -- Función: save (<filename>, all)
 -- Función: save (<filename>, <name_1>=<expr_1>, <name_2>=<expr_2>,
          ...)

     Alamacena los valores actuales de <name_1>, <name_2>, <name_3>,
     ..., en el archivo <filename>.  Los argumentos son nombres de
     variables, funciones u otros objetos.  Si un nombre no tiene un
     valor o una función asociado a él, entonces se ignora.

     La función 'save' devuelve <filename>.

     La función 'save' almacena datos en forma de expresiones Lisp.  Los
     datos almacenados por 'save' pueden recuperarse con 'load
     (<filename>)'.  El resultado de ejecutar 'save' cuando <filename>
     ya existe depende del soporte Lisp implementado; el archivo puede
     ser sobreescrito o que 'save' envíe un mesaje de error.

     La llamada 'save (<filename>, values, functions, labels, ...)'
     almacena los elementos cuyos nombres son 'values', 'functions',
     'labels', etc.  Los nombres pueden ser cualesquiera de los
     especificados por la variable 'infolists'; 'values' incluye todas
     las variables definidas por el usuario.

     La llamada 'save (<filename>, [<m>, <n>])' almacena los valores de
     las etiquetas de entrada y salida desde <m> hasta <n>.  Nótese que
     <m> y <n> deben ser números.  Las etiquetas de entrada y salida
     también se pueden almacenar una a una, por ejemplo, 'save ("foo.1",
     %i42, %o42)'.  La llamada 'save (<filename>, labels)' almacena
     todas las etiquetas de entrada y salida.  Cuando las etiquetas
     almacenadas en el archivo sean posteriormente recuperadas, se
     sobreescribirán las activas en ese momento.

     La llamada 'save (<filename>, <name_1>=<expr_1>, <name_2>=<expr_2>,
     ...)' almacena los valores de <expr_1>, <expr_2>, ..., con los
     nombres <name_1>, <name_2>, ....  Es útil hacer este tipo de
     llamada para con etiquetas de entrada y salida, por ejemplo, 'save
     ("foo.1", aa=%o88)'.  El miembro derecho de la igualdad puede ser
     cualquier expresión, que será evaluada.  Esta llamada a la función
     'save' no incorpora nuevos nombres a la sesión actual de Maxima,
     simplemente los almacena en el archivo <filename>.

     Todas estas formas de llamar a la función 'save' se pueden combinar
     a voluntad.  Por ejemplo, 'save (<filename>, aa, bb, cc=42,
     functions, [11, 17])'.

     La llamada 'save (<filename>, all)' almacena el estado actual de
     Maxima, lo que incluye todas las variables definidas por el
     usuario, funciones, arreglos, etc., así como algunos objetos
     definidos automáticamente.  Los elementos almacenados incluyen
     variables del sistema, como 'file_search_maxima' o 'showtime', si
     han sido modificadas por el usuario.  Véase 'myoptions'.

     'save' evalúa <filename> pero no el resto de argumentos.

 -- Función: stringout (<filename>, <expr_1>, <expr_2>, <expr_3>, ...)
 -- Función: stringout (<filename>, [<m>, <n>])
 -- Función: stringout (<filename>, input)
 -- Función: stringout (<filename>, functions)
 -- Función: stringout (<filename>, values)

     La función 'stringout' escribe expresiones en un archivo de la
     misma forma en que se escribirían como expresiones de entrada.  El
     archivo puede ser utilizado entonces como entrada a las funciones
     'batch' o 'demo', y puede ser editado para cualquier otro
     propósito.

     La forma general de 'stringout' escribe los valores de una o más
     expresiones en el archivo de salida.  Nótese que si una expresión
     es una variable, solamente se escribirá el valor de la variable y
     no el nombre de ésta.  Como caso especial, y muy útil en algunas
     ocasiones, las expresiones pueden ser etiquetas de entrada ('%i1',
     '%i2', '%i3', ...)  o de salida ('%o1', '%o2', '%o3', ...).

     Si 'grind' vale 'true', 'stringout' formatea la salida utilizando
     'grind'.  En caso contrario, se utilizará el formato 'string'.
     Véanse 'grind' y 'string'.

     La forma especial 'stringout (<filename>, [<m>, <n>])' escribe los
     valores de las etiquetas de entrada desde la m hasta la n, ambas
     inclusive.

     La forma especial 'stringout (<filename>, input)' escribe todas las
     etiquetas de entrada en el archivo.

     La forma especial 'stringout (<filename>, functions)' escribe todas
     las funciones definidas por el usuario, contenidas en la lista
     global 'functions', en el archivo.

     La forma especial 'stringout (<filename>, values)' escribe todas
     las variables asignadas por el usuario, contenidas en la lista
     global 'values', en el archivo.  Cada variable se escribe como una
     sentencia de asignación, con el nombre de la variable seguida de
     dos puntos y a continuación su valor.  Nótese que la forma general
     de 'stringout' no escribe las variables como sentencias de
     asignación.

 -- Función: with_stdout (<f>, <expr_1>, <expr_2>, <expr_3>, ...)
 -- Función: with_stdout (<s>, <expr_1>, <expr_2>, <expr_3>, ...)
     Evalúa <expr_1>, <expr_2>, <expr_3>, ...  y escribe los resultados
     en el fichero <f> o flujo de salida <s>.  Las expresiones que se
     evalúan no se escriben.  La salida puede generarse por medio de
     'print', 'display', 'grind' entre otras funciones.

     La variable global 'file_output_append' controla si 'with_stdout'
     añade o reinicia el contenido del fichero de salida <f>.  Si
     'file_output_append' vale 'true', 'with_stdout' añade contenido al
     fichero de salida.  En cualquier caso, 'with_stdout' crea el
     fichero si éste no existe.

     La función 'with_stdout' devuelve el valor de su último argumento.

     Véase también 'writefile'.

          (%i1) with_stdout ("tmp.out",
                             for i:5 thru 10 do print (i, "! yields", i!))$
          (%i2) printfile ("tmp.out")$
          5 ! yields 120
          6 ! yields 720
          7 ! yields 5040
          8 ! yields 40320
          9 ! yields 362880
          10 ! yields 3628800

 -- Función: writefile (<filename>)
     Comienza escribiendo una transcripción de la sesión de Maxima en el
     archivo <filename>.  Cualquier interacción entre Maxima y el
     usuario se almacena también en este archivo, tal como aparece en la
     consola.

     Puesto que la transcripción se escribe en el formato de salida a la
     consola, su contenido no es interpretable por Maxima.  Para hacer
     un archivo que contenga expresiones que puedan ser nuevamente
     cargadas en Maxima, véanse 'save' y 'stringout'; la función 'save'
     almacena expresiones en formato Lisp, mientras que 'stringout' lo
     hace en formato Maxima.

     El resultado de ejecutar 'writefile' cuando el archivo <filename>
     ya existe depende del entorno Lisp operativo; el contenido anterior
     puede ser sobreescrito o ampliado con la sesión actual.  La función
     'appendfile' siempre añade la sesión al contenido actual.

     Puede ser útil ejecutar 'playback' después de 'writefile' para
     guardar las interacciones previas de la sesión.  Puesto que
     'playback' muestra solamente las variables de entrada y salida
     ('%i1', '%o1', etc.), cualquier salida generada por una sentencia
     de impresión desde dentro de una función no es mostrada por
     'playback'.

     La función 'closefile' cierra los archivos abiertos por 'writefile'
     o 'appendfile'.


File: maxima.info,  Node: Funciones y variables para salida TeX,  Next: Funciones y variables para salida Fortran,  Prev: Funciones y variables para lectura y escritura,  Up: Lectura y escritura

13.4 Funciones y variables para salida TeX
==========================================

 -- Función: tex (<expr>)
 -- Función: tex (<expr>, <destination>)
 -- Función: tex (<expr>, false)
 -- Función: tex (<label>)
 -- Función: tex (<label>, <destination>)
 -- Función: tex (<label>, false)

     Devuelve la expresión en un formato apropiado para para ser
     incorporado a un documento basado en TeX. El resultado que se
     obtiene es un fragmento de código que puede incluirse en un
     documento mayor, pero que no puede ser procesado aisladamente.

     La instrucción 'tex (<expr>)' imprime en la consola la
     representación en TeX de <expr>.

     La instrucción 'tex (<label>)' imprime en la consola la
     representación en TeX de la expresión a la que hace referencia la
     etiqueta <label>, asignándole a su vez una etiqueta de ecuación que
     será mostrada al lado izquierdo de la misma.  La etiqueta de la
     expresión en TeX es la misma que la de Maxima.

     <destination> puede ser tanto un flujo de salida como el nombre de
     un fichero.

     Si <destination> es el nombre de un fichero, 'tex' añade la salida
     al fichero.  Las funciones 'openw' y 'opena' crean flujos de
     salida.

     Las instrucciones 'tex (<expr>, false)' y 'tex (<label>, false)'
     devuelven el código TeX en formato de cadena.

     La función 'tex' evalúa su primer argumento tras comprobar si se
     trata de una etiqueta.  La doble comilla simple '''' fuerza la
     evaluación del argumento, anulando la comprobación sobre la
     etiqueta.

     Véase también 'texput'.

     Ejemplos:

          (%i1) integrate (1/(1+x^3), x);
                                              2 x - 1
                            2            atan(-------)
                       log(x  - x + 1)        sqrt(3)    log(x + 1)
          (%o1)      - --------------- + ------------- + ----------
                              6             sqrt(3)          3
          (%i2) tex (%o1);
          $$-{{\log \left(x^2-x+1\right)}\over{6}}+{{\arctan \left({{2\,x-1
           }\over{\sqrt{3}}}\right)}\over{\sqrt{3}}}+{{\log \left(x+1\right)
           }\over{3}}\leqno{\tt (\%o1)}$$
          (%o2)                          (\%o1)
          (%i3) tex (integrate (sin(x), x));
          $$-\cos x$$
          (%o3)                           false
          (%i4) tex (%o1, "foo.tex");
          (%o4)                          (\%o1)

     'tex (<expr>, false)' devuelve el código TeX en formato de cadena.

          (%i1) S : tex (x * y * z, false);
          (%o1) $$x\,y\,z$$
          (%i2) S;
          (%o2) $$x\,y\,z$$

 -- Función: tex1 (<e>)
     Devuelve una cadena con el código TeX de la expresión <e>.  El
     código TeX no se encierra entre delimitadores para una ecuación ni
     cualesquiera otros entornos.

     Ejemplo:

          (%i1) tex1 (sin(x) + cos(x));
          (%o1)                     \sin x+\cos x

 -- Función: texput (<a>, <s>)
 -- Función: texput (<a>, <f>)
 -- Función: texput (<a>, <s>, <operator_type>)
 -- Función: texput (<a>, [<s_1>, <s_2>], matchfix)
 -- Función: texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)

     Establece el formato en TeX del átomo <a>, el cual puede ser un
     símbolo o el nombre de un operador.

     La instrucción 'texput (<a>, <s>)' hace que la función 'tex'
     introduzca <s> en la salida TeX en el lugar de <a>.

     La instrucción 'texput (<a>, <f>)' hace que 'tex' llame a la
     función <f> para que genere código TeX. La función <f> debe aceptar
     un único argumento, el cual es una expresión que tenga como
     operador <a> y que devuelva una cadena con el código TeX. Esta
     función puede llamar a 'tex1' para generar el código TeX para los
     argumentos de la expresión de entrada.

     La instrucción 'texput (<a>, <s>, <operator_type>)', en la que
     <operator_type> es 'prefix', 'infix' o 'postfix', 'nary' o
     'nofix',hace que la función 'tex' introduzca <s> en la salida TeX
     en el lugar de <a>, colocándolo en el lugar correcto.

     La instrucción 'texput (<a>, [<s_1>, <s_2>], matchfix)' hace que la
     función 'tex' introduzca <s_1> y <s_2> en la salida TeX a los lados
     de los argumentos de <a>.  Si son más de uno, los argumentos se
     separan por comas.

     La instrucción 'texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)' hace
     que la función 'tex' introduzca <s_1> y <s_2> en la salida TeX a
     los lados de los argumentos de <a>, con <s_3> separando los
     argumentos.

     Ejemplos:

     Asigna código TeX para una variable.

     Llama a una función que genera código TeX.

          (%i1) texfoo (e) := block ([a, b], [a, b] : args (e),
            concat ("\\left[\\stackrel{", tex1 (b),
                    "}{", tex1 (a), "}\\right]"))$
          (%i2) texput (foo, texfoo);
          (%o2)                        texfoo
          (%i3) tex (foo (2^x, %pi));
          $$\left[\stackrel{\pi}{2^{x}}\right]$$
          (%o3)                         false

          (%i1) texput (me,"\\mu_e");
          (%o1)                         \mu_e
          (%i2) tex (me);
          $$\mu_e$$
          (%o2)                         false

     Asigna código TeX para una función ordinaria (no para un operador).

          (%i1) texput (lcm, "\\mathrm{lcm}");
          (%o1)                     \mathrm{lcm}
          (%i2) tex (lcm (a, b));
          $$\mathrm{lcm}\left(a , b\right)$$
          (%o2)                         false

     Asigna código TeX para un operador prefijo.

          (%i1) prefix ("grad");
          (%o1)                         grad
          (%i2) texput ("grad", " \\nabla ", prefix);
          (%o2)                        \nabla
          (%i3) tex (grad f);
          $$ \nabla f$$
          (%o3)                         false

     Asigna código TeX para un operador infijo.

          (%i1) infix ("~");
          (%o1)                           ~
          (%i2) texput ("~", " \\times ", infix);
          (%o2)                        \times
          (%i3) tex (a ~ b);
          $$a \times b$$
          (%o3)                         false

     Asigna código TeX para un operador postfijo..

          (%i1) postfix ("##");
          (%o1)                          ##
          (%i2) texput ("##", "!!", postfix);
          (%o2)                          !!
          (%i3) tex (x ##);
          $$x!!$$
          (%o3)                         false

     Asigna código TeX para un operador n-ario.

          (%i1) nary ("@@");
          (%o1)                          @@
          (%i2) texput ("@@", " \\circ ", nary);
          (%o2)                         \circ
          (%i3) tex (a @@ b @@ c @@ d);
          $$a \circ b \circ c \circ d$$
          (%o3)                         false

     Asigna código TeX para un operador "no-fijo".

          (%i1) nofix ("foo");
          (%o1)                          foo
          (%i2) texput ("foo", "\\mathsc{foo}", nofix);
          (%o2)                     \mathsc{foo}
          (%i3) tex (foo);
          $$\mathsc{foo}$$
          (%o3)                         false

     Asigna código TeX para un operador "bi-fijo" (matchfix).

          (%i1) matchfix ("<<", ">>");
          (%o1)                          <<
          (%i2) texput ("<<", [" \\langle ", " \\rangle "], matchfix);
          (%o2)                [ \langle ,  \rangle ]
          (%i3) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o3)                         false
          (%i4) tex (<<a, b>>);
          $$ \langle a , b \rangle $$
          (%o4)                         false
          (%i5) texput ("<<", [" \\langle ", " \\rangle ", " \\, | \\,"],
                matchfix);
          (%o5)           [ \langle ,  \rangle ,  \, | \,]
          (%i6) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o6)                         false
          (%i7) tex (<<a, b>>);
          $$ \langle a \, | \,b \rangle $$
          (%o7)                         false

 -- Función: get_tex_environment (<op>)
 -- Función: set_tex_environment (<op>, <before>, <after>)

     Gestiona el entorno de las salidas TeX que se obtienen de la
     función 'tex'.  El entorno TeX está formado por dos cadenas: una
     que se escribe antes que cualquier salida en TeX, y otra que se
     escribe después.

     'get_tex_environment' devuelve el entorno TeX que se aplica al
     operador <op>.  Si no se ha asignado ningún entorno, devolverá el
     que tenga por defecto.

     'set_tex_environment' asigna el entorno TeX al operador <op>.

     Ejemplos:

          (%i1) get_tex_environment (":=");
          (%o1) [
          \begin{verbatim}
          , ;
          \end{verbatim}
          ]
          (%i2) tex (f (x) := 1 - x);

          \begin{verbatim}
          f(x):=1-x;
          \end{verbatim}

          (%o2)                         false
          (%i3) set_tex_environment (":=", "$$", "$$");
          (%o3)                       [$$, $$]
          (%i4) tex (f (x) := 1 - x);
          $$f(x):=1-x$$
          (%o4)                         false

 -- Función: get_tex_environment_default ()
 -- Función: set_tex_environment_default (<before>, <after>)

     Gestiona el entorno de las salidas TeX que se obtienen de la
     función 'tex'.  El entorno TeX está formado por dos cadenas: una
     que se escribe antes que cualquier salida en TeX, y otra que se
     escribe después.

     'get_tex_environment_default' devuelve el entorno TeX que se aplica
     a expresiones para las cuales el operador de mayor rango no tiene
     entorno TeX asignado (mediante 'set_tex_environment').

     'set_tex_environment_default' asigna el entorno TeX por defecto.

     Ejemplos:

          (%i1) get_tex_environment_default ();
          (%o1)                       [$$, $$]
          (%i2) tex (f(x) + g(x));
          $$g\left(x\right)+f\left(x\right)$$
          (%o2)                         false
          (%i3) set_tex_environment_default ("\\begin{equation}
          ", "
          \\end{equation}");
          (%o3) [\begin{equation}
          ,
          \end{equation}]
          (%i4) tex (f(x) + g(x));
          \begin{equation}
          g\left(x\right)+f\left(x\right)
          \end{equation}
          (%o4)                         false


File: maxima.info,  Node: Funciones y variables para salida Fortran,  Prev: Funciones y variables para salida TeX,  Up: Lectura y escritura

13.5 Funciones y variables para salida Fortran
==============================================

 -- Variable opcional: fortindent
     Valor por defecto: 0

     La variable 'fortindent' controla el margen izquierdo de las
     expresiones que escribe la instrucción 'fortran'.  El valor 0
     escribe con un margen normal de 6 espacios; valores positivos harán
     que las expresiones se escriban más a la derecha.

 -- Función: fortran (<expr>)
     Escribe <expr> en código Fortran.  La salida se escribe con
     márgenes, y si ésta es demasiado larga 'fortran' sigue escribiendo
     en líneas sucesivas.  La función 'fortran' escribe el operador de
     exponenciación '^' como '**', e imprime un número complejo 'a + b
     %i' como '(a,b)'.

     El argumento <expr> puede ser una ecuación.  En tal caso, 'fortran'
     escribe una sentencia de asignación, dándole el valor del miembro
     derecho de la expresión al miembro izquierdo.  En particular, si el
     miembro derecho de <expr> es el nombre de una matriz, entonces
     'fortran' escribe una sentencia de asignación para cada elemento de
     la matriz.

     Si <expr> no es reconozida por 'fortran', la expresión se escribe
     en formato 'grind' sin avisos.  La función 'fortran' no reconoce
     listas, arreglos ni funciones.

     La variable 'fortindent' controla el margen izquierdo de las
     expresiones que escribe la instrucción 'fortran'.  El valor 0
     escribe con un margen normal de 6 espacios; valores positivos harán
     que las expresiones se escriban más a la derecha.

     Si 'fortspaces' vale 'true', 'fortran' rellena las líneas con
     espacios de 80 columnas.

     La función 'fortran' evalúa sus argumentos; un argumento precedido
     de apóstrofo previene de la evaluación.  La función 'fortran'
     siempre devuelve 'done'.

     Ejemplos:

     (%i1) expr: (a + b)^12$
     (%i2) fortran (expr);
           (b+a)**12
     (%o2)                         done
     (%i3) fortran ('x=expr);
           x = (b+a)**12
     (%o3)                         done
     (%i4) fortran ('x=expand (expr));
           x = b**12+12*a*b**11+66*a**2*b**10+220*a**3*b**9+495*a**4*b**8+792
          1   *a**5*b**7+924*a**6*b**6+792*a**7*b**5+495*a**8*b**4+220*a**9*b
          2   **3+66*a**10*b**2+12*a**11*b+a**12
     (%o4)                         done
     (%i5) fortran ('x=7+5*%i);
           x = (7,5)
     (%o5)                         done
     (%i6) fortran ('x=[1,2,3,4]);
           x = [1,2,3,4]
     (%o6)                         done
     (%i7) f(x) := x^2$
     (%i8) fortran (f);
           f
     (%o8)                         done

 -- Variable opcional: fortspaces
     Valor por defecto: 'false'

     Si 'fortspaces' vale 'true', 'fortran' rellena las líneas con
     espacios de 80 columnas.


File: maxima.info,  Node: Polinomios,  Next: Funciones Especiales,  Prev: Lectura y escritura,  Up: Top

14 Polinomios
*************

* Menu:

* Introducción a los polinomios::  
* Funciones y variables para polinomios::  


File: maxima.info,  Node: Introducción a los polinomios,  Next: Funciones y variables para polinomios,  Prev: Polinomios,  Up: Polinomios

14.1 Introducción a los polinomios
==================================

Los polinomios se almacenan en Maxima, bien en un formato general, bien
en una forma conocida como canónica (Cannonical Rational Expressions,
CRE). La última corresponde al formato estándar y se utiliza
internamente para realizar operaciones como 'factor', 'ratsimp' y demás.

Las Expresiones Racionales Canónicas (CRE) constituyen un tipo de
representación que es especialmente apropiado para expandir polinomios y
funciones racionales (así como para polinomios parcialmente factorizados
y funciones racionales cuando a la variable 'ratfac' se le asigna el
valor 'true').  En esta forma CRE las variables se ordenan de mayor a
menor.  Los polinomios se representan recursivamente como una lista
compuesta por la variable principal seguida por una serie de pares de
expresiones, una por cada término del polinomio.  El primer miembro de
cada par es el exponente de la variable principal en ese término y el
segundo miembro es el coeficiente de ese término, el cual puede ser un
número o un polinomio en otra variable representado también de esta
forma.  Así, la parte principal de la forma CRE de 3*X^2-1 es (X 2 3 0
-1) y la de 2*X*Y+X-3 es (Y 1 (X 1 2) 0 (X 1 1 0 -3)) asumiendo que Y es
la variable principal, y será (X 1 (Y 1 2 0 1) 0 -3) si se asume que la
variable principal es X. Qué variable se considera "principal" se
determinada en orden alfabético inverso.  Las "variables" de la
expresión CRE no son necesariamente atómicas.  De hecho cualquier
subexpresión cuyo operador principal no es + - * / ni ^ con potencia
entera puede ser considerada como una "variable" de la expresión (en
forma CRE) en el cual aparezca.  Por ejemplo las variables CRE de la
expresión X+SIN(X+1)+2*SQRT(X)+1 son X, SQRT(X) y SIN(X+1).  Si el
usuario no especifica una ordenación de las variables mediante la
función 'ratvars' Maxima escogerá una alfabéticamente.  En general, laa
CRE representan expresiones racionales, esto es, fracciones de
polinomios, donde el numerador y el denominador no tienen factores
comunes, siendo el denominador es positivo.  La forma interna es
esencialmente un par de polinomios (el numerador y el denominador)
precedida por la lista de variables ordenadas.  Si una expresión a ser
mostrada está en la forma CRE o contiene alguna subexpresión en forma de
CRE, el simbolo /R/ será seguido por la etiqueta de la línea de comando.
Véase la función 'rat' para convertir una expresión a la forma CRE. Una
extensión de la forma CRE se utiliza para la representación de las
series de Taylor.  La noción de una expresión racional se extiende de
manera que los exponentes de las variables pueden ser números racionales
positivos o negativos y no sólo enteros positivos y los coeficientes
pueden ser también expresiones racionales y no sólo polinomios.  Estas
expresiones se representan internamente por una forma polinomial
recursiva que es similar a la forma CRE, pero que la generaliza,
aportando información adicional como el grado de truncamiento.  Como con
la forma CRE, el símbolo /T/ sigue la etiqueta de línea de comando en la
que se encuentra dicha expresión.


File: maxima.info,  Node: Funciones y variables para polinomios,  Prev: Introducción a los polinomios,  Up: Polinomios

14.2 Funciones y variables para polinomios
==========================================

 -- Variable opcional: algebraic
     Valor por defecto: 'false'

     La variable 'algebraic' debe valer 'true' para que se pueda hacer
     la simplificación de enteros algebraicos.

 -- Variable opcional: berlefact
     Valor por defecto: 'true'

     Si 'berlefact' vale 'false' entonces se utiliza el algoritmo de
     factorización de Kronecker, en caso contrario se utilizará el
     algoritmo de Berlekamp, que es el que se aplica por defecto.

 -- Función: bezout (<p1>, <p2>, <x>)
     Es una alternativa a la función 'resultant'.  Devuelve una matriz.

          (%i1) bezout(a*x+b, c*x^2+d, x);
                                   [ b c  - a d ]
          (%o1)                    [            ]
                                   [  a     b   ]
          (%i2) determinant(%);
                                      2      2
          (%o2)                      a  d + b  c
          (%i3) resultant(a*x+b, c*x^2+d, x);
                                      2      2
          (%o3)                      a  d + b  c

 -- Función: bothcoef (<expr>, <x>)
     Devuelve una lista cuyo primer miembro es el coeficiente de <x> en
     <expr> (que coincide con el que devuelve 'ratcoef' si <expr> está
     en formato CRE, o el que devuelve 'coeff' si no está en este
     formato) y cuyo segundo miembro es la parte restante de <expr>.
     Esto es, '[A, B]' donde '<expr> = A*<x> + B'.

     Ejemplo:

          (%i1) islinear (expr, x) := block ([c],
                  c: bothcoef (rat (expr, x), x),
                  is (freeof (x, c) and c[1] # 0))$
          (%i2) islinear ((r^2 - (x - r)^2)/x, x);
          (%o2)                         true

 -- Función: coeff (<expr>, <x>, <n>)
 -- Función: coeff (<expr>, <x>)
     Devuelve el coeficiente de '<x>^<n>' en <expr>, donde <expr> es un
     polinomio o monomio en <x>.

     'coeff(<expr>, <x>^<n>)' es equivalente a 'coeff(<expr>, <x>,
     <n>)'.  'coeff(<expr>, <x>, 0)' devuelve el resto de <expr>, el
     cual no contiene a <x>.  En caso de omisión, se entiende que <n> es
     igual a 1.

     <x> puede ser tanto el nombre de una variable simple como el de una
     variable con subíndice, o también una subexpresión de <expr> que
     contenga un operador junto con todos sus argumentos.

     En ocasiones, es posible calcular los coeficientes de expresiones
     equivalentes a <expr> aplicando 'expand' o 'factor'.  'coeff' no
     aplica ni 'expand', ni 'factor', ni ninguna otra función.

     'coeff' se distribuye sobre listas, matrices y ecuaciones.

     Ejemplos:

     'coeff' devuelve el coeficiente de '<x>^<n>' en <expr>.

          (%i1) coeff (b^3*a^3 + b^2*a^2 + b*a + 1, a^3);
                                          3
          (%o1)                          b

     'coeff(<expr>, <x>^<n>)' es equivalente a 'coeff(<expr>, <x>,
     <n>)'.

          (%i1) coeff (c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z, 3);
          (%o1)                         - c
                                           3
          (%i2) coeff (c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z^3);
          (%o2)                         - c
                                           3

     'coeff(<expr>, <x>, 0)' devuelve el resto de <expr>, el cual no
     contiene a <x>.

          (%i1) coeff (a*u + b^2*u^2 + c^3*u^3, b, 0);
                                      3  3
          (%o1)                      c  u  + a u

     <x> puede ser tanto el nombre de una variable simple como el de una
     variable con subíndice, o también una subexpresión de <expr> que
     contenga un operador junto con todos sus argumentos.

          (%i1) coeff (h^4 - 2*%pi*h^2 + 1, h, 2);
          (%o1)                        - 2 %pi
          (%i2) coeff (v[1]^4 - 2*%pi*v[1]^2 + 1, v[1], 2);
          (%o2)                        - 2 %pi
          (%i3) coeff (sin(1 + x)*sin(x) + sin(1 + x)^3*sin(x)^3, sin(1 + x)^3);
                                          3
          (%o3)                        sin (x)
          (%i4) coeff ((d - a)^2*(b + c)^3 + (a + b)^4*(c - d), a + b, 4);
          (%o4)                         c - d

     'coeff' no aplica ni 'expand', ni 'factor', ni ninguna otra
     función.

          (%i1) coeff (c*(a + b)^3, a);
          (%o1)                           0
          (%i2) expand (c*(a + b)^3);
                           3          2        2        3
          (%o2)           b  c + 3 a b  c + 3 a  b c + a  c
          (%i3) coeff (%, a);
                                          2
          (%o3)                        3 b  c
          (%i4) coeff (b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c, (a + b)^3);
          (%o4)                           0
          (%i5) factor (b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c);
                                            3
          (%o5)                      (b + a)  c
          (%i6) coeff (%, (a + b)^3);
          (%o6)                           c

     'coeff' se distribuye sobre listas, matrices y ecuaciones.

          (%i1) coeff ([4*a, -3*a, 2*a], a);
          (%o1)                      [4, - 3, 2]
          (%i2) coeff (matrix ([a*x, b*x], [-c*x, -d*x]), x);
                                    [  a    b  ]
          (%o2)                     [          ]
                                    [ - c  - d ]
          (%i3) coeff (a*u - b*v = 7*u + 3*v, u);
          (%o3)                         a = 7

 -- Función: content (<p_1>, <x_1>, ..., <x_n>)
     Devuelve una lista cuyo primer miembro es el máximo común divisor
     de los coeficientes de los términos del polinomio <p_1> de variable
     <x_n> (este es el contenido) y cuyo segundo miembro es el polinomio
     <p_1> dividido por el contenido.

     Ejemplos:

          (%i1) content (2*x*y + 4*x^2*y^2, y);
                                             2
          (%o1)                   [2 x, 2 x y  + y]

 -- Función: denom (<expr>)
     Devuelve el denominador de la expresión racional <expr>.

 -- Función: divide (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Calcula el cociente y el resto del polinomio <p_1> dividido por el
     polinomio <p_2>, siendo la variable principal <x_n>.  Las otras
     funciones son como en la función 'ratvars'.  El resultado es una
     lista cuyo primer miembro es el cociente y el segundo miembro el
     resto.

     Ejemplos:

          (%i1) divide (x + y, x - y, x);
          (%o1)                       [1, 2 y]
          (%i2) divide (x + y, x - y);
          (%o2)                      [- 1, 2 x]

     Nótese que 'y' es la variable principal en el segundo ejemplo.

 -- Función: eliminate ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_k>])
     Elimina variables de ecuaciones (o de expresiones que se supone
     valen cero) tomando resultantes sucesivas.  Devuelve una lista con
     '<n> - <k>' expresiones y <k> variables <x_1>, ..., <x_k>
     eliminadas.  Primero se elimina <x_1> dando '<n> - 1' expresiones,
     después se elimina 'x_2', etc.  Si '<k> = <n>' entonces se devuelve
     una lista con una única expresión, libre de las variables <x_1>,
     ..., <x_k>.  En este caso se llama a 'solve' para resolver la
     última resultante para la última variable.

     Ejemplo:

          (%i1) expr1: 2*x^2 + y*x + z;
                                                2
          (%o1)                    z + x y + 2 x
          (%i2) expr2: 3*x + 5*y - z - 1;
          (%o2)                  - z + 5 y + 3 x - 1
          (%i3) expr3: z^2 + x - y^2 + 5;
                                    2    2
          (%o3)                    z  - y  + x + 5
          (%i4) eliminate ([expr3, expr2, expr1], [y, z]);
                       8         7         6          5          4
          (%o4) [7425 x  - 1170 x  + 1299 x  + 12076 x  + 22887 x

                                              3         2
                                      - 5154 x  - 1291 x  + 7688 x + 15376]

 -- Función: ezgcd (<p_1>, <p_2>, <p_3>, ...)
     Devuelve una lista cuyo primer elemento es el máximo común divisor
     (mcd) de los polinomios <p_1>, <p_2>, <p_3>, ..., siendo los
     miembros restantes los mismos polinomios divididos por el mcd.  Se
     utiliza siempre el algoritmo 'ezgcd'.

     Véanse también 'gcd', 'gcdex', 'gcdivide' y 'poly_gcd'.

     Ejemplos:

     Los tres polinomios tiene como máximo común divisor '2*x-3', el
     cual se calcula primero con la función 'gcd' y luego con 'ezgcd'.

          (%i1) p1 : 6*x^3-17*x^2+14*x-3;
                                  3       2
          (%o1)                6 x  - 17 x  + 14 x - 3
          (%i2) p2 : 4*x^4-14*x^3+12*x^2+2*x-3;
                              4       3       2
          (%o2)            4 x  - 14 x  + 12 x  + 2 x - 3
          (%i3) p3 : -8*x^3+14*x^2-x-3;
                                    3       2
          (%o3)                - 8 x  + 14 x  - x - 3

          (%i4) gcd(p1, gcd(p2, p3));
          (%o4)                        2 x - 3

          (%i5) ezgcd(p1, p2, p3);
                             2               3      2           2
          (%o5) [2 x - 3, 3 x  - 4 x + 1, 2 x  - 4 x  + 1, - 4 x  + x + 1]

 -- Variable opcional: facexpand
     Valor por defecto: 'true'

     La variable 'facexpand' controla si los factores irreducibles
     devueltos por 'factor' están en formato expandido (por defecto) o
     recursivo (CRE normal).

 -- Función: factor (<expr>)
 -- Función: factor (<expr>, <p>)

     Factoriza la expresión <expr>, que puede contener cualquier número
     de variables o funciones, en factores irreducibles respecto de los
     enteros.  La llamada 'factor (<expr>, <p>)' factoriza <expr> en el
     campo de los racionales con un elemento añadido cuyo polinomio
     mínimo es <p>.

     La función 'factor' utiliza a 'ifactors' para factorizar enteros.

     Si la variable 'factorflag' vale 'false' suprime la factorización
     de los factores enteros en las expresiones racionales.

     La variable 'dontfactor' puede contener una lista de variables con
     respecto a las cuales no se factorizará (inicialmente está vacía).
     Tampoco se factorizará respecto de cualesquiera otra variables que
     sean menos importantes (según la ordenación que se sigue en el
     formato CRE) que aquellas que se encuentran en la lista
     'dontfactor'.

     Si la variable 'savefactors' vale 'true', los factores de una
     expresión en forma de producto se guardarán por ciertas funciones a
     fin de acelerar posteriores factorizaciones de expresiones que
     contengan algunos de estos mismos factores.

     Si 'berlefact' vale 'false' entonces se utiliza el algoritmo de
     factorización de Kronecker, en caso contrario se utilizará el
     algoritmo de Berlekamp, que es el que se aplica por defecto.

     Si la variable 'intfaclim' vale 'true', Maxima desistirá de
     factorizar enteros si no encuentra ningún factor después de las
     divisiones tentativas y de aplicar el método rho de Pollard.  Si
     vale 'false' (este es el caso cuando el usuario invoca
     explícitamente a 'factor'), se intentará la factorización completa
     del entero.  El valor asignado a 'intfaclim' se utiliza en llamadas
     internas a 'factor'.  Así, se puede cambiar el valor de 'intfaclim'
     para evitar que Maxima dedique un tiempo prohibitivo a factorizar
     números enteros grandes.

     Ejemplos:

          (%i1) factor (2^63 - 1);
                              2
          (%o1)              7  73 127 337 92737 649657
          (%i2) factor (-8*y - 4*x + z^2*(2*y + x));
          (%o2)               (2 y + x) (z - 2) (z + 2)
          (%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                          2  2        2    2    2
          (%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
          (%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                                 2
                               (x  + 2 x + 1) (y - 1)
          (%o4)                ----------------------
                                     36 (y + 1)
          (%i5) factor (1 + %e^(3*x));
                                x         2 x     x
          (%o5)              (%e  + 1) (%e    - %e  + 1)
          (%i6) factor (1 + x^4, a^2 - 2);
                              2              2
          (%o6)             (x  - a x + 1) (x  + a x + 1)
          (%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                                 2
          (%o7)              - (y  + x) (z - x) (z + x)
          (%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                                       x + 2
          (%o8)               ------------------------
                                                     2
                              (x + 3) (x + b) (x + c)
          (%i9) ratsimp (%);
                          4                  3
          (%o9) (x + 2)/(x  + (2 c + b + 3) x

               2                       2             2                   2
           + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
          (%i10) partfrac (%, x);
                     2                   4                3
          (%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

               2              2         2                2
           + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                           c - 2
           - ---------------------------------
               2                             2
             (c  + (- b - 3) c + 3 b) (x + c)

                                   b - 2
           + -------------------------------------------------
                       2             2       3      2
             ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                                   1
           - ----------------------------------------------
                       2
             ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
          (%i11) map ('factor, %);
                        2
                       c  - 4 c - b + 6                 c - 2
          (%o11) - ------------------------- - ------------------------
                          2        2                                  2
                   (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                                 b - 2                        1
                      + ------------------------ - ------------------------
                                       2                          2
                        (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
          (%i12) ratsimp ((x^5 - 1)/(x - 1));
                                 4    3    2
          (%o12)                x  + x  + x  + x + 1
          (%i13) subst (a, x, %);
                                 4    3    2
          (%o13)                a  + a  + a  + a + 1
          (%i14) factor (%th(2), %);
                                 2        3        3    2
          (%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
          (%i15) factor (1 + x^12);
                                 4        8    4
          (%o15)               (x  + 1) (x  - x  + 1)
          (%i16) factor (1 + x^99);
                           2            6    3
          (%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

             10    9    8    7    6    5    4    3    2
           (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

             20    19    17    16    14    13    11    10    9    7    6
           (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

              4    3            60    57    51    48    42    39    33
           - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

              30    27    21    18    12    9    3
           - x   - x   + x   + x   - x   - x  + x  + 1)

 -- Variable opcional: factorflag
     Valor por defecto: 'false'

     Si 'factorflag' vale 'false' se evita la factorización de factores
     enteros de expresiones racionales.

 -- Función: factorout (<expr>, <x_1>, <x_2>, ...)
     Reorganiza la suma <expr> como una suma de términos de la forma 'f
     (<x_1>, <x_2>, ...)*g', donde 'g' es un producto de expresiones que
     no contienen ningún <x_i> y 'f' se factoriza.

     Nótese que 'factorout' ignora la variable opcional 'keepfloat'.

     Ejemplo:

          (%i1) expand (a*(x+1)*(x-1)*(u+1)^2);
                       2  2          2      2      2
          (%o1)     a u  x  + 2 a u x  + a x  - a u  - 2 a u - a
          (%i2) factorout(%,x);
                   2
          (%o2) a u  (x - 1) (x + 1) + 2 a u (x - 1) (x + 1)
                                                        + a (x - 1) (x + 1)

 -- Función: factorsum (<expr>)
     Intenta agrupar términos en los factores de <expr> que son sumas en
     grupos de términos tales que su suma sea factorizable.  La función
     'factorsum' puede restablecer el recuperar de 'expand ((x + y)^2 +
     (z + w)^2)' pero no puede recuperar 'expand ((x + 1)^2 + (x +
     y)^2)' porque los términos tienen variables comunes.

     Ejemplo:

          (%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
                     2      2                            2      2
          (%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                               2        2    2            2
                                  + 2 u v x + u  x + a w  + v  + 2 u v + u
          (%i2) factorsum (%);
                                             2          2
          (%o2)            (x + 1) (a (z + w)  + (v + u) )

 -- Función: fasttimes (<p_1>, <p_2>)
     Calcula el producto de los polinomios <p_1> y <p_2> utilizando un
     algoritmo especial.  Los polinomios 'p_1' y 'p_2' deben ser
     multivariantes, densos y aproximadamente del mismo tamaño.  La
     multiplicación clásica es de orden 'n_1 n_2' donde 'n_1' es el
     grado de 'p_1' y 'n_2' el grado de 'p_2'.  La función 'fasttimes'
     es de orden 'max (n_1, n_2)^1.585'.

 -- Función: fullratsimp (<expr>)
     Aplica repetidamente 'ratsimp' a una expresión, seguida de
     simplificaciones no racionales, hasta que no se obtienen más
     transformaciones; entonces devuelve el resultado.

     En presencia de expresiones no racionales, una llamada a 'ratsimp'
     seguida de una simplificación no racional ("general") puede no ser
     suficiente para conseguir un resultado simplificado.  En ocasiones
     serán necesarias más de una llamada a 'ratsimp', que es lo que hace
     precisamente 'fullratsimp'.

     Ejemplo:

          (%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                                 a/2     2   a/2     2
                               (x    - 1)  (x    + 1)
          (%o1)                -----------------------
                                        a
                                       x  - 1
          (%i2) ratsimp (expr);
                                    2 a      a
                                   x    - 2 x  + 1
          (%o2)                    ---------------
                                        a
                                       x  - 1
          (%i3) fullratsimp (expr);
                                        a
          (%o3)                        x  - 1
          (%i4) rat (expr);
                                 a/2 4       a/2 2
                               (x   )  - 2 (x   )  + 1
          (%o4)/R/             -----------------------
                                        a
                                       x  - 1

 -- Función: fullratsubst (<a>, <b>, <c>)
     Similar a 'ratsubst' excepto por el hecho de que se llama a í misma
     recursivamente hasta que el resultado deja de cambiar.  Esta
     función es útil cuando la expresión a sustituir y la que la
     sustituye tienen variables comunes.

     La función 'fullratsubst' también acepta sus argumentos en el
     formato de 'lratsubst'.

     Es necesario ejecutar 'load ("lrats")' para cargar 'fullratsubst' y
     'lratsubst'.

     Ejemplos:

          (%i1) load ("lrats")$
        * 'subst' puede hacer sustituciones múltiples; 'lratsubst' es
          análoga a 'subst'.
          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c
        * Si sólo se quiere una sustitución, entonces se puede dar una
          única ecuación como primer argumento.
          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b
        * 'fullratsubst' equivale a 'ratsubst', excepto por el hecho de
          que se llama a í misma recursivamente hasta que el resultado
          deja de cambiar.
          (%i5) ratsubst (b*a, a^2, a^3);
                                         2
          (%o5)                         a  b
          (%i6) fullratsubst (b*a, a^2, a^3);
                                           2
          (%o6)                         a b
        * 'fullratsubst' también acepta una lista de ecuaciones o una
          sóla ecuación como primer argumento.
          (%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
          (%o7)                           b
          (%i8) fullratsubst (a^2 = b*a, a^3);
                                           2
          (%o8)                         a b
        * 'fullratsubst' puede caer en una recursión infinita.
          (%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

          *** - Lisp stack overflow. RESET

 -- Función: gcd (<p_1>, <p_2>, <x_1>, ...)
     Devuelve el máximo común divisor de <p_1> y <p_2>.  La variable
     'gcd' determiona qué algoritmo se va a utilizar.  Asignándole a
     'gcd' los valores 'ez', 'subres', 'red' o 'spmod', se seleccionan
     los algoritmos 'ezgcd', subresultante 'prs', reducido o modular,
     respectivamente.  Si 'gcd' vale 'false' entonces 'gcd(<p_1>, <p_2>,
     <x>)' devolverá siempre 1 para cualquier <x>.  Muchas funciones
     (por ejemplo, 'ratsimp', 'factor', etc.)  hacen uso de 'gcd'
     implícitamente.  En caso de polinomios homogéneos se recomienda
     darle a 'gcd' el valor 'subres'.  Para calcular un máximo común
     divisor en presencia de raíces, como en 'gcd (<x>^2 - 2*sqrt(2)*<x>
     + 2, <x> - sqrt(2))', la variable 'algebraic' debe igualarse a
     'true' y 'gcd' no puede ser 'ez'.

     Se recomienda utilizar el algoritmo 'subres' en lugar de 'red', por
     ser aquél más moderno.

     Si la variable 'gcd', cuyo valor por defecto es 'spmod', vale
     'false', no se calculará el máximo común divisor cuando las
     expresiones se conviertan a su forma canónica (CRE), lo que
     redundará en ocasiones en mayor rapidez de cálculo.

 -- Función: gcdex (<f>, <g>)
 -- Función: gcdex (<f>, <g>, <x>)
     Devuelve una lista '[<a>, <b>, <u>]' en la que <u> es el máximo
     común divisor (mcd) de <f> y <g>, e igual a '<a> <f> + <b> <g>'.
     Los argumentos <f> y <g> deben ser polinomios univariantes, o
     indicarles la variable principal <x> en caso de ser multivariantes.

     La función 'gcdex' implementa el algoritmo de Euclides, en el que
     tenemos una secuencia de 'L[i]: [a[i], b[i], r[i]]' todos ellos
     ortogonales a '[f, g, -1]' siendo el siguiente calculado a partir
     de 'q = quotient(r[i]/r[i+1])' y 'L[i+2]: L[i] - q L[i+1]'; el
     proceso termina en 'L[i+1]' cuando el resto 'r[i+2]' se anula.

          (%i1) gcdex (x^2 + 1, x^3 + 4);
                                 2
                                x  + 4 x - 1  x + 4
          (%o1)/R/           [- ------------, -----, 1]
                                     17        17
          (%i2) % . [x^2 + 1, x^3 + 4, -1];
          (%o2)/R/                        0

 -- Función: gcfactor (<n>)
     Factoriza el entero gaussiano <n> como producto, a su vez, de
     enteros gaussianos, (un entero gaussiano es de la forma'<a> + <b>
     %i' donde <a> y <b> son números enteros).  Los factores se
     normalizan de manera que tanto la parte real como imaginaria sean
     no negativas.

 -- Función: gfactor (<expr>)
     Factoriza el polinomio <expr> sobre los enteros gaussianos (un
     entero gaussiano es de la forma'<a> + <b> %i' donde <a> y <b> son
     números enteros).  Es como 'factor (<expr>, <a>^2+1)' donde <a>
     vale '%i'.

     Ejemplo:

          (%i1) gfactor (x^4 - 1);
          (%o1)           (x - 1) (x + 1) (x - %i) (x + %i)

 -- Función: gfactorsum (<expr>)
     Esta función es similar a 'factorsum' pero aplica 'gfactor' en
     lugar de 'factor'.

 -- Función: hipow (<expr>, <x>)
     Devuelve el mayor exponente explícito de <x> en <expr>.  El
     argumento<x> puede ser una variable o una expresión general.  Si
     <x> no aparece en <expr>, 'hipow' devuelve '0'.

     La función 'hipow' no tiene en cuenta expresiones equivalentes a
     'expr'.  En particular, 'hipow' no expande 'expr', de manera que
     'hipow (<expr>, <x>)' y 'hipow (expand (<expr>, <x>))' pueden dar
     resultados diferentes.

     Ejemplos:

          (%i1) hipow (y^3 * x^2 + x * y^4, x);
          (%o1)                           2
          (%i2) hipow ((x + y)^5, x);
          (%o2)                           1
          (%i3) hipow (expand ((x + y)^5), x);
          (%o3)                           5
          (%i4) hipow ((x + y)^5, x + y);
          (%o4)                           5
          (%i5) hipow (expand ((x + y)^5), x + y);
          (%o5)                           0

 -- Variable opcional: intfaclim
     Valor por defecto: 'true'

     Si vale 'true', Maxima desistirá de factorizar enteros si no
     encuentra ningún factor después de las divisiones tentativas y de
     aplicar el método rho de Pollard, por lo que la factorización puede
     quedar incompleta.

     Si vale 'false' (este es el caso cuando el usuario invoca
     explícitamente a 'factor'), se intentará la factorización completa
     del entero.  El valor asignado a 'intfaclim' se utiliza en llamadas
     internas a 'factor'.  A la variable 'intfaclim' se le asigna el
     valor 'false' cuando se calculan factores desde las funciones
     'divisors', 'divsum' y 'totient'.

     Las llamadas internas a 'factor' respetan el valor dado por el
     usuario a 'intfaclim'.  Asignando a 'intfaclim' el valor 'true' se
     puede reducir el tiempo que Maxima dedica a factorizar enteros
     grandes.

 -- Variable opcional: keepfloat
     Valor por defecto: 'false'

     Si 'keepfloat' vale 'true', los números decimales en coma flotante
     no se racionalizan cuando las expresiones que los contienen se
     convierten al formato canónico racional (CRE).

     Nótese que la función 'solve' y todas aquellas otras que la invocan
     (por ejemplo, 'eigenvalues') ignoran esta variable, por lo que
     hacen la conversión de los números decimales.

     Ejemplos:

          (%i1) rat(x/2.0);

          `rat' replaced 0.5 by 1/2 = 0.5
                                                 x
          (%o1)/R/                               -
                                                 2
          (%i2) rat(x/2.0), keepfloat;

          (%o2)/R/                             0.5 x

     'solve' ignora 'keepfloat':

          (%i3) solve(1.0-x,x), keepfloat;

          `rat' replaced 1.0 by 1/1 = 1.0
          (%o3)                               [x = 1]

 -- Función: lopow (<expr>, <x>)

     Devuelve el menor exponente de <x> que aparece explícitamente en
     <expr>.

          (%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
          (%o1)                       min(a, 2)

 -- Función: lratsubst (<L>, <expr>)
     Esta función es similar a 'subst (<L>, <expr>)', excepto por el
     hecho de que utiliza 'ratsubst' en lugar de 'subst'.

     El primer argumento de 'lratsubst' es una ecuación o lista de
     ecuaciones idénticas en formato a las aceptadas por 'subst'.  Las
     sustituciones se hacen en el orden dado por la lista de ecuaciones,
     esto es, de izquierda a derecha.

     La instrucción 'load ("lrats")' carga 'fullratsubst' y 'lratsubst'.

     Ejemplos:

          (%i1) load ("lrats")$
        * 'subst' can carry out multiple substitutions.  'lratsubst' is
          analogous to 'subst'.
          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c
        * If only one substitution is desired, then a single equation
          may be given as first argument.
          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b

 -- Variable opcional: modulus
     Valor por defecto: 'false'

     Si 'modulus' es un número positivo <p>, las operaciones con números
     racionales (como los devueltos por 'rat' y funciones relacionadas)
     se realizan módulo <p>, utilizando el llamado sistema de módulo
     balanceado, en el que '<n> módulo <p>' se define como un entero <k>
     de '[-(<p>-1)/2, ..., 0, ..., (<p>-1)/2]' si <p> es impar, o de
     '[-(<p>/2 - 1), ..., 0, ...., <p>/2]' si <p> es par, de tal manera
     que '<a> <p> + <k>' es igual a <n> para algún entero <a>.

     Normalmente a 'modulus' se le asigna un número primo.  Se acepta
     que a 'modulus' se le asigne un entero positivo no primo, pero se
     obtendrá un mensaje de aviso.  Maxima responderá con un mensaje de
     error cuando se le asigne a 'modulus' cero o un número negativo.

     Ejemplos:

          (%i1) modulus:7;
          (%o1)                           7
          (%i2) polymod([0,1,2,3,4,5,6,7]);
          (%o2)            [0, 1, 2, 3, - 3, - 2, - 1, 0]
          (%i3) modulus:false;
          (%o3)                         false
          (%i4) poly:x^6+x^2+1;
                                      6    2
          (%o4)                      x  + x  + 1
          (%i5) factor(poly);
                                      6    2
          (%o5)                      x  + x  + 1
          (%i6) modulus:13;
          (%o6)                          13
          (%i7) factor(poly);
                                2        4      2
          (%o7)               (x  + 6) (x  - 6 x  - 2)
          (%i8) polymod(%);
                                      6    2
          (%o8)                      x  + x  + 1

 -- Función: num (<expr>)
     Devuelve el numerador de <expr> si se trata de una fracción.  Si
     <expr> no es una fracción, se devuelve <expr>.

     La función 'num' evalúa su argumento.

 -- Función: polydecomp (<p>, <x>)

     Descompone el polinomio <p> de variable <x> en una composición
     funcional de polinomios en <x>.  La función 'polydecomp' devuelve
     una lista '[<p_1>, ..., <p_n>]' tal que

          lambda([x],p_1)(lambda ([x],p_2)(...(lambda([x],p_n)(x))...))

     es igual a <p>.  El grado de <p_i> es mayor que 1 para <i> menor
     que <n>.

     Esta descomposición no es única.

     Ejemplos:

          (%i1) polydecomp (x^210, x);
                                    7   5   3   2
          (%o1)                   [x , x , x , x ]
          (%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                          6      4      3    2
          (%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
          (%i3) polydecomp (p, x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     La siguiente función compone 'L = [e_1, ..., e_n]' como funciones
     de 'x'; se trata de la inversa de 'polydecomp':

          compose (L, x) :=
            block ([r : x], for e in L do r : subst (e, x, r), r) $

     Se vuelve a obtener el resultado del ejemplo de más arriba haciendo
     uso de 'compose':

          (%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     Nótese que aunque 'compose (polydecomp (<p>, <x>), <x>)' devuelve
     siempre <p> (sin expandir), 'polydecomp (compose ([<p_1>, ...,
     <p_n>], <x>), <x>)' no devuelve necesariamente '[<p_1>, ...,
     <p_n>]':

          (%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                                    2       2
          (%o4)                   [x  + 2, x  + 1]
          (%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
                                2       2
                               x  + 3  x  + 5
          (%o5)               [------, ------, 2 x + 1]
                                 4       2

 -- Función: polymod (<p>)
 -- Función: polymod (<p>, <m>)
     Convierte el polinomio <p> a una representación modular respecto
     del módulo actual, que es el valor almacenado en la variable
     'modulus'.

     La llamada 'polymod (<p>, <m>)' especifica un módulo <m> para ser
     utilizado en lugar de valor almacenado en 'modulus'.

     Véase 'modulus'.

 -- Función: powers (<expr>, <x>)
     Devuelve las potencias de <x> dentro de <expr>.

     La instrucción 'load (powers)' carga esta función.

 -- Función: quotient (<p_1>, <p_2>)
 -- Función: quotient (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Devuelve el polinomio <p_1> dividido por el polinomio <p_2>.  Los
     argumentos <x_1>, ..., <x_n> se interpretan como en la función
     'ratvars'.

     La función 'quotient' devuelve el primer elemento de la lista
     devuelta por 'divide'.

 -- Función: rat (<expr>)
 -- Función: rat (<expr>, <x_1>, ..., <x_n>)
     Convierte <expr> al formato canónico racional (canonical rational
     expression o CRE) expandiendo y combinando todos los términos sobre
     un denominador común y cancelando el máximo común divisor del
     numerador y denominador, así como convirtiendo números decimales en
     coma flotante a números racionales dentro de la tolerancia indicada
     por 'ratepsilon'.  Las variables se ordenan de acuerdo a <x_1>,
     ..., <x_n> si se han especificado, como en la función 'ratvars'.

     En general, 'rat' no simplifica otras funciones que no sean la suma
     '+', resta '-', multiplicación '*', división '/' y exponenciación
     de exponente entero, mientras que 'ratsimp' sí lo hace.  Nótese que
     los átomos (números y variables) en expresiones en formato CRE no
     son los mismos que en el formato general.  Por ejemplo, 'rat(x)- x'
     devuelve 'rat(0)', que tiene una representación interna diferente
     de 0.

     Si 'ratprint' vale 'false' no aparecerán mensajes informando al
     usuario sobre la conversión de números decimales en coma flotante a
     números racionales.

     Si 'keepfloat' vale 'true' no se convertirán números decimales en
     coma flotante a números racionales.

     Véanse también 'ratexpand' y 'ratsimp'.

     Ejemplos:
          (%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x)
                   / (4*y^2 + x^2);
                                                     4
                                            (x - 2 y)
                        (y + a) (2 y + x) (------------ + 1)
                                             2      2 2
                                           (x  - 4 y )
          (%o1)         ------------------------------------
                                        2    2
                                     4 y  + x
          (%i2) rat (%, y, a, x);
                                      2 a + 2 y
          (%o2)/R/                    ---------
                                       x + 2 y

 -- Variable opcional: ratalgdenom
     Valor por defecto: 'true'

     Si 'ratalgdenom' vale 'true', se permite la racionalización de
     denominadores eliminando radicales.  La variable 'ratalgdenom' sólo
     tiene efecto cuando expresiones en formato canónico (CRE) están
     siendo utilizadas en modo algebraico.

 -- Función: ratcoef (<expr>, <x>, <n>)
 -- Función: ratcoef (<expr>, <x>)
     Devuelve el coeficiente de la expresión '<x>^<n>' dentro de la
     expresión <expr>.  Si se omite, <n> se considera igual a 1.

     El valor devuelto está libre de las variables en <x>, excepto
     quizás en un sentido no racional.  Si no existe un coeficiente de
     este tipo se devuelve 0.

     La función 'ratcoef' expande y simplifica racionalmente su primer
     argumento, por lo que puede dar una respuesta diferente a la dada
     por la función 'coeff', la cual tiene un carácter puramente
     sintáctico.  Así, 'ratcoef ((x + 1)/y + x, x)' devuelve '(y +
     1)/y', mientras que 'coeff' devuelve 1.

     La llamada 'ratcoef (<expr>, <x>, 0)', siendo <expr> una suma,
     devuelve una suma formada por los términos que no contienen <x>.

     Puesto que <expr> se simplifica racionalmente antes de ser
     examinada, algunos coeficientes puede que no aparezcan como en la
     expresión original.

     Ejemplo:

          (%i1) s: a*x + b*x + 5$
          (%i2) ratcoef (s, a + b);
          (%o2)                           x

 -- Función: ratdenom (<expr>)
     Devuelve el denominador de <expr>, después de transformar <expr> al
     formato canónico (CRE). El valor retornado está también en formato
     CRE.

     El argumento <expr> se transforma al formato CRE por la función
     'rat', a menos que ya esté en este formato.  Esta conversión puede
     cambiar la forma de <expr> colocando todos sus términos sobre un
     denominador común.

     La función 'denom' es parecida, pero devuelve una expresión general
     en lugar de una CRE. Tampoco 'denom' intenta colocar todos sus
     términos sobre un denominador común, de manera que algunas
     expresiones que son consideradas como divisiones por 'ratdenom', no
     son tales para 'denom'.

 -- Variable opcional: ratdenomdivide
     Valor por defecto: 'true'

     Si 'ratdenomdivide' vale 'true', la función 'ratexpand' expande una
     fracción en la que el numerador es una suma en una suma de
     divisiones.  En otro caso, 'ratexpand' reduce una suma de
     divisiones a una única fracción, cuyo numerador es la suma de los
     denominadores de cada fracción.

     Ejemplos:

          (%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                                      2
                                     x  + x + 1
          (%o1)                      ----------
                                        2
                                       y  + 7
          (%i2) ratdenomdivide: true$
          (%i3) ratexpand (expr);
                                 2
                                x        x        1
          (%o3)               ------ + ------ + ------
                               2        2        2
                              y  + 7   y  + 7   y  + 7
          (%i4) ratdenomdivide: false$
          (%i5) ratexpand (expr);
                                      2
                                     x  + x + 1
          (%o5)                      ----------
                                        2
                                       y  + 7
          (%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
                                               2
                                     b        a
          (%o6)                    ------ + ------
                                    2        2
                                   b  + 3   b  + 3
          (%i7) ratexpand (expr2);
                                            2
                                       b + a
          (%o7)                        ------
                                        2
                                       b  + 3

 -- Función: ratdiff (<expr>, <x>)
     Deriva la expresión racional <expr> con respecto a <x>.  El
     argumento <expr> debe ser una fracción algebraica o un polinomio en
     <x>.  El argumento <x> puede ser una variable o una subexpresión de
     <expr>.

     El resultado equivale al devuelto por 'diff', aunque es posible que
     se obtenga en una forma diferente.  La función 'ratdiff' puede ser
     más rápida que 'diff' en expresiones racionales.

     La función 'ratdiff' devuelve una expresión en formato canónico o
     CRE si 'expr' es también una expresión CRE. En otro caso, 'ratdiff'
     devuelve una expresión general.

     La función 'ratdiff' considera únicamente la dependencia de <expr>
     respecto de <x>, ignorando cualquier dependencia establecida por
     'depends'.

     Ejemplo:

          (%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                                     3
                                  4 x  + 10 x - 11
          (%o1)                   ----------------
                                        5
                                       x  + 5
          (%i2) ratdiff (expr, x);
                              7       5       4       2
                           8 x  + 40 x  - 55 x  - 60 x  - 50
          (%o2)          - ---------------------------------
                                    10       5
                                   x   + 10 x  + 25
          (%i3) expr: f(x)^3 - f(x)^2 + 7;
                                   3       2
          (%o3)                   f (x) - f (x) + 7
          (%i4) ratdiff (expr, f(x));
                                     2
          (%o4)                   3 f (x) - 2 f(x)
          (%i5) expr: (a + b)^3 + (a + b)^2;
                                        3          2
          (%o5)                  (b + a)  + (b + a)
          (%i6) ratdiff (expr, a + b);
                              2                    2
          (%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a

 -- Función: ratdisrep (<expr>)
     Devuelve su argumento como una expresión general.  Si <expr> es una
     expresión general, se devuelve sin cambios.

     Normalmente se invoca a 'ratdisrep' a fin de convertir una
     expresión en formato canónico (CRE) al formato general, lo que
     puede ser utilizado si se quiere parar el contagio que produce el
     formato CRE, o para utilizar funciones racionales en contextos no
     racionales.

     Véase también 'totaldisrep'.

 -- Función: ratexpand (<expr>)
 -- Variable opcional: ratexpand
     Expande <expr> multiplicando productos de sumas y sumas con
     exponentes, combinando fracciones con común denominador, cancelando
     el máximo común divisor del numerador y del denominador y luego
     dividiendo los sumandos del numerador por el denominador.

     El valor que devuelve 'ratexpand' es una expresión general, incluso
     cuando <expr> está en formato canónico o CRE.

     Si la variable 'ratexpand' vale 'true' hará que las expresiones CRE
     se expandan completamente cuando se conviertan al formato general o
     se muestren en el terminal, mientras que si vale 'false' se
     mostrarán de forma recursiva.  Véase también 'ratsimp'.

     Si 'ratdenomdivide' vale 'true', 'ratexpand' expande una fracción
     en la que el numerador es una suma en una suma de fracciones, todas
     ellas con denominador común.  En otro caso, 'ratexpand' reduce una
     suma de fracciones en una única fracción, cuyo numerador es la suma
     de los numeradores de cada fracción.

     Si 'keepfloat' vale 'true', los números decimales en coma flotante
     no se racionalizan cuando las expresiones que los contienen se
     convierten al formato canónico racional (CRE).

     Ejemplos:

          (%i1) ratexpand ((2*x - 3*y)^3);
                               3         2       2        3
          (%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
          (%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                                   x - 1       1
          (%o2)                   -------- + -----
                                         2   x - 1
                                  (x + 1)
          (%i3) expand (expr);
                              x              1           1
          (%o3)          ------------ - ------------ + -----
                          2              2             x - 1
                         x  + 2 x + 1   x  + 2 x + 1
          (%i4) ratexpand (expr);
                                  2
                               2 x                 2
          (%o4)           --------------- + ---------------
                           3    2            3    2
                          x  + x  - x - 1   x  + x  - x - 1

 -- Variable opcional: ratfac
     Valor por defecto: 'false'

     Si 'ratfac' vale 'true', las expresiones canónicas (CRE) se
     manipulan en una forma parcialmente factorizada.

     Durante las operaciones racionales, las expresiones se mantienen
     completamente factorizadas tanto como sea posible sin llamar a
     'factor'.  Esto debería ahorrar espacio y tiempo en algunos
     cálculos.  El numerador y denominador se hacen primos relativos,
     por ejemplo 'rat ((x^2 - 1)^4/(x + 1)^2)' devuelve '(x - 1)^4 (x +
     1)^2)', pero los factores dentro de cada parte pueden no ser primos
     relativos.

     En el paquete 'ctensr' sobre manipulación de tensores por
     componentes, los tensores de Ricci, Einstein, Riemann y Weyl y la
     curvatura escalar se factorizan automáticamente si 'ratfac' vale
     'true'; 'ratfac' debe activarse únicamente en aquellos casos en los
     que se sabe que el número de términos de las componentes
     tensoriales es pequño.

     Nota: Los esquemas de comportamiento basados en 'ratfac' y
     'ratweight' son incompatibles y no se debe pretender usarlos al
     mismo tiempo.

 -- Función: ratnumer (<expr>)
     Devuelve el numerador de <expr>, después de reducir <expr> a su
     forma canónica (CRE). El valor retornado está también en formato
     CRE.

     El argumento <expr> se transforma al formato CRE por la función
     'rat', a menos que ya esté en este formato.  Esta conversión puede
     cambiar la forma de <expr> colocando todos sus términos sobre un
     denominador común.

     Es parecida a la función 'num', pero devuelve una expresión general
     en lugar de una CRE. Además, 'num' no intenta colocar todos los
     términos sobre un denominador común, de manera que algunas
     expresiones que son consideradas fracciones por 'ratnumer' no se
     consideran como tales por 'num'.

 -- Función: ratp (<expr>)
     Devuelve 'true' si <expr> es una expresión canónica racional
     (canonical rational expression o CRE) o una CRE extendida, en caso
     contrario devuelve 'false'.

     Las expresiones CRE son creadas por 'rat' y funciones asociadas.
     Las CRE extendidas son creadas por 'taylor' y funciones asociadas.

 -- Variable opcional: ratprint
     Valor por defecto: 'true'

     Si 'ratprint' vale 'true', se muestra al usuario un mensaje dando
     cuenta de la conversión de números decimales en coma flotante a
     formato racional.

 -- Función: ratsimp (<expr>)
 -- Función: ratsimp (<expr>, <x_1>, ..., <x_n>)
     Simplifica la expresión <expr> y todas sus subexpresiones,
     incluyendo los argumentos de funciones no racionales.  El resultado
     es un cociente de dos polinomios en una forma recursiva, esto es,
     los coeficientes de la variable principal son polinomios respecto
     de las otras variables.  Las variables pueden incluir funciones no
     racionales, como 'sin (x^2 + 1)', y los argumentos de tales
     funciones son también racionalmente simplificados.

     La llamada 'ratsimp (<expr>, <x_1>, ..., <x_n>)' permite la
     simplificación racional con la especificación del orden de las
     variables, como en 'ratvars'.

     Si 'ratsimpexpons' vale 'true', 'ratsimp' se aplica a los
     exponentes de las expresiones durante la simplificación.

     Véase también 'ratexpand'.  Nótese que 'ratsimp' se ve afectada por
     algunas de las variables globales que controlan a 'ratexpand'.

     Ejemplos:

          (%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                                   2      2
                             x         (log(x) + 1)  - log (x)
          (%o1)        sin(------) = %e
                            2
                           x  + x
          (%i2) ratsimp (%);
                                       1          2
          (%o2)                  sin(-----) = %e x
                                     x + 1
          (%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                                 3/2
                          (x - 1)    - sqrt(x - 1) (x + 1)
          (%o3)           --------------------------------
                               sqrt((x - 1) (x + 1))
          (%i4) ratsimp (%);
                                     2 sqrt(x - 1)
          (%o4)                    - -------------
                                           2
                                     sqrt(x  - 1)
          (%i5) x^(a + 1/a), ratsimpexpons: true;
                                         2
                                        a  + 1
                                        ------
                                          a
          (%o5)                        x

 -- Variable opcional: ratsimpexpons
     Valor por defecto: 'false'

     Si 'ratsimpexpons' vale 'true', 'ratsimp' se aplica a los
     exponentes de las expresiones durante la simplificación.

 -- Variable opcional: radsubstflag
     Valor por defecto: 'false'

     Si 'radsubstflag' vale 'true' se permite a 'ratsubst' hacer la
     sustitución 'u' por 'sqrt (x)' in 'x'.

 -- Función: ratsubst (<a>, <b>, <c>)

     Sustituye <b> por <a> en <c> y devuelve la expresión resultante.
     El argumento <b> puede ser una suma, un producto, una potencia,
     etc.

     La función 'ratsubst' reconoce el significado de las expresiones,
     mientras que 'subst' tan solo realiza sustituciones sintácticas.
     Así por ejemplo, 'subst (a, x + y, x + y + z)' devuelve 'x + y + z'
     cuando 'ratsubst' devuelve 'z + a'.

     Si 'radsubstflag' vale 'true', 'ratsubst' sustituye radicales en
     expresiones que no los contienen explícitamente.

     'ratsubst' ignora el valor 'true' de la variable opcional
     'keepfloat'.

     Ejemplos:

          (%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                                        3      4
          (%o1)                      a x  y + a
          (%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
                         4         3         2
          (%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
          (%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
                      4           2                     2
          (%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
          (%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                                  4           2
          (%o4)                cos (x) - 2 cos (x) + 1
          (%i5) radsubstflag: false$
          (%i6) ratsubst (u, sqrt(x), x);
          (%o6)                           x
          (%i7) radsubstflag: true$
          (%i8) ratsubst (u, sqrt(x), x);
                                          2
          (%o8)                          u

 -- Función: ratvars (<x_1>, ..., <x_n>)
 -- Función: ratvars ()
 -- Variable del sistema: ratvars
     Declara como variables principales <x_1>, ..., <x_n> en expresiones
     racionales.  Si <x_n> está presente en una expresión racional, se
     considerará como variable principal.  Si no está presente, entonces
     se considerará principal a la variable <x_[n-1]> si aparece en la
     expresión, se continúa así hasta <x_1>, que se considerará como
     variable principal sólo si ninguna de las variables que le siguen
     está presente en la expresión.

     Si una variable de la expresión racional no está presente en la
     lista 'ratvars', se le dará una prioridad inferior a la de <x_1>.

     Los argumentos de 'ratvars' pueden ser tanto variables como
     funciones no racionales como 'sin(x)'.

     La variable 'ratvars' es una lista que contiene los argumentos
     pasados a la función 'ratvars' la última vez que fue invocada.
     Cada llamada a la función 'ratvars' reinicializa la lista.  La
     llamada 'ratvars ()' vacía la lista.

 -- Variable opcional: ratvarswitch
     Valor por defecto: 'true'

     Maxima almacena una lista interna en la variable Lisp 'VARLIST'
     cuyo contenido son las variables principales de las expresiones
     racionales.  Cuando 'ratvarswitch' vale 'true', su valor por
     defecto, cada evaluación comienza con la lista 'VARLIST' vacía.  En
     caso contrario, las variables principales de las expresiones
     anteriores se mantienen en la lista 'VARLIST'.

     Las variables principales declaradas con la función 'ratvars' no se
     ven afectadas por la opción 'ratvarswitch'.

     Ejemplos:

     Cuando 'ratvarswitch' vale 'true', su valor por defecto, cada
     evaluación comienza con la lista 'VARLIST' vacía.

          (%i1) ratvarswitch:true$

          (%i2) rat(2*x+y^2);
                                       2
          (%o2)/R/                    y  + 2 x
          (%i3) :lisp varlist
          ($X $Y)

          (%i3) rat(2*a+b^2);
                                       2
          (%o3)/R/                    b  + 2 a

          (%i4) :lisp varlist
          ($A $B)

     Cuando 'ratvarswitch' vale 'false', las variables principales de
     las expresiones anteriores se mantienen en lista 'VARLIST'.

          (%i4) ratvarswitch:false$

          (%i5) rat(2*x+y^2);
                                       2
          (%o5)/R/                    y  + 2 x
          (%i6) :lisp varlist
          ($X $Y)

          (%i6) rat(2*a+b^2);
                                       2
          (%o6)/R/                    b  + 2 a

          (%i7) :lisp varlist
          ($A $B $X $Y)

 -- Función: ratweight (<x_1>, <w_1>, ..., <x_n>, <w_n>)
 -- Función: ratweight ()
     Asigna un peso <w_i> a la variable <x_i>.  Un término será
     reemplazado por 0 si su peso excede el valor de la variable
     'ratwtlvl' (por defecto no se realiza el truncamiento).  El peso de
     un término es la suma de los productos de los pesos de las
     variables que lo forman multiplicados por sus exponentes.  Por
     ejemplo, el peso de '3 x_1^2 x_2' es '2 w_1 + w_2'.  El
     truncamiento basado en 'ratwtlvl' solamente se lleva a cabo cuando
     se multiplican o se elevan a potencias expresiones canónicas (CRE).

     La llamada 'ratweight ()' devuelve la lista acumulada de
     asignaciones de pesos.

     Nota: Los esquemas de comportamiento basados en 'ratfac' y
     'ratweight' son incompatibles y no se debe pretender usarlos al
     mismo tiempo.

     Ejemplos:

          (%i1) ratweight (a, 1, b, 1);
          (%o1)                     [a, 1, b, 1]
          (%i2) expr1: rat(a + b + 1)$
          (%i3) expr1^2;
                            2                  2
          (%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
          (%i4) ratwtlvl: 1$
          (%i5) expr1^2;
          (%o5)/R/                  2 b + 2 a + 1

 -- Variable del sistema: ratweights
     Valor por defecto: '[]'

     La variable 'ratweights' es una lista que contiene los pesos
     asignados por 'ratweight'.  Las lista es acumulativa, en el sentido
     de que cada llamada a 'ratweight' añade nuevos elementos a la
     lista.

 -- Variable opcional: ratwtlvl
     Valor por defecto: 'false'

     La variable 'ratwtlvl' se utiliza en combinación con la función
     'ratweight' para controlar el truncamiento de expresiones
     racionales canónicas (CRE). Con el valor por defecto, 'false', no
     se produce truncamiento alguno.

 -- Función: remainder (<p_1>, <p_2>)
 -- Función: remainder (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Devuelve el resto de la división del polinomio <p_1> entre <p_2>.
     Los argumentos <x_1>, ..., <x_n> se interpretan como en 'ratvars'.

     La función 'remainder' devuelve el segundo elemento de la lista
     retornada por 'divide'.

 -- Función: resultant (<p_1>, <p_2>, <x>)
     Calcula la resultante de los dos polinomios <p_1> y <p_2>,
     eliminando la variable <x>.  La resultante es un determinante de
     los coeficientes de <x> en <p_1> y <p_2>, que es igual a cero si
     sólo si <p_1> y <p_2> tienen un factor común no constante.

     Si <p_1> o <p_2> pueden ser factorizados, puede ser necesario
     llamar a 'factor' antes que invocar a 'resultant'.

     La variable opcional 'resultant' controla qué algoritmo será
     utilizado para calcular la resultante.  Véanse 'option_resultant' y
     'resultant'.

     La función 'bezout' toma los mismos argumentos que 'resultant' y
     devuelve una matriz.  El determinante del valor retornado es la
     resultante buscada.

     Ejemplos:

          (%i1) resultant(2*x^2+3*x+1, 2*x^2+x+1, x);
          (%o1)                           8
          (%i2) resultant(x+1, x+1, x);
          (%o2)                           0
          (%i3) resultant((x+1)*x, (x+1), x);
          (%o3)                           0
          (%i4) resultant(a*x^2+b*x+1, c*x + 2, x);
                                   2
          (%o4)                   c  - 2 b c + 4 a

          (%i5) bezout(a*x^2+b*x+1, c*x+2, x);
                                  [ 2 a  2 b - c ]
          (%o5)                   [              ]
                                  [  c      2    ]
          (%i6) determinant(%);
          (%o6)                   4 a - (2 b - c) c

 -- Variable opcional: resultant
     Valor por defecto: 'subres'

     La variable opcional 'resultant' controla qué algoritmo será
     utilizado para calcular la resultante con la función 'resultant'.
     Los valores posibles son:

     'subres'
          para el algoritmo PRS (polynomial remainder sequence)
          subresultante,
     'mod'
          para el algoritmo resultante modular y
     'red'
          para el algoritmo PRS (polynomial remainder sequence)
          reducido.

     En la mayor parte de problemas, el valor por defecto, 'subres', es
     el más apropiado.  Pero en el caso de problemas bivariantes o
     univariantes de grado alto, puede ser mejor utilizar 'mod'.

 -- Variable opcional: savefactors
     Valor por defecto: 'false'

     Si 'savefactors' vale 'true', los factores de una expresión
     producto se almacenan por ciertas funciones a fin de acelerar
     posteriores factorizaciones de expresiones que contengan algunos de
     estos factores.

 -- Función: showratvars (<expr>)
     Devuelve una lista de las variables de expresiones canónicas
     racionales (CRE) en la expresión 'expr'.

     Véase también 'ratvars'.

 -- Función: tellrat (<p_1>, ..., <p_n>)
 -- Función: tellrat ()
     Añade al anillo de enteros algebraicos conocidos por Maxima los
     elementos que son soluciones de los polinomios <p_1>, ..., <p_n>.
     Cada argumento <p_i> es un polinomio de coeficientes enteros.

     La llamada 'tellrat (<x>)' hace que se sustituya 0 por <x> en las
     funciones racionales.

     La llamada 'tellrat ()' devuelve una lista con las sustituciones
     actuales.

     A la variable 'algebraic' se le debe asignar el valor 'true' a fin
     de poder realizar la simplificación de enteros algebraicos.

     Maxima reconoce la unidad imaginaria '%i' y todas las raíces de los
     enteros.

     La instrucción 'untellrat' borra todas las propiedades de
     'tellrat'.

     Es ambiguo aplicar 'tellrat' a un polinomio multivariante tal como
     'tellrat (x^2 - y^2)', pues no se sabe si sustituir '<y>^2' por
     '<x>^2' o al revés.  Maxima sigue un cierto orden, pero si el
     usuario quiere especificar uno en concreto, puede hacerlo mediante
     la sintaxis 'tellrat (y^2 = x^2)', que indica que se ponga '<x>^2'
     en lugar de '<y>^2'.

     Ejemplos:

          (%i1) 10*(%i + 1)/(%i + 3^(1/3));
                                     10 (%i + 1)
          (%o1)                      -----------
                                            1/3
                                      %i + 3
          (%i2) ev (ratdisrep (rat(%)), algebraic);
                       2/3      1/3              2/3      1/3
          (%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
          (%i3) tellrat (1 + a + a^2);
                                      2
          (%o3)                     [a  + a + 1]
          (%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                                1                 a
          (%o4)           ------------- + -----------------
                          sqrt(2) a - 1   sqrt(3) + sqrt(2)
          (%i5) ev (ratdisrep (rat(%)), algebraic);
                   (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
          (%o5)    ----------------------------------------------
                                         7
          (%i6) tellrat (y^2 = x^2);
                                  2    2   2
          (%o6)                 [y  - x , a  + a + 1]

 -- Función: totaldisrep (<expr>)
     Convierte cada subexpresión de <expr> del formato canónico (CRE) al
     general y devuelve el resultado.  Si <expr> está en formato CRE
     entonces 'totaldisrep' es idéntico a 'ratdisrep'.

     La función 'totaldisrep' puede ser útil para modificar expresiones
     como las ecuaciones, listas, matrices, etc., que tienen algunas
     subexpresiones en formato CRE.

 -- Función: untellrat (<x_1>, ..., <x_n>)
     Elimina de <x_1>, ..., <x_n> las propiedades relacionadas con
     'tellrat'.


File: maxima.info,  Node: Funciones Especiales,  Next: Funciones elípticas,  Prev: Polinomios,  Up: Top

15 Funciones Especiales
***********************

* Menu:

* Introducción a las funciones especiales::
* Funciones de Bessel::
* Funciones de Airy::
* Funciones Gamma y factorial::
* Integral exponencial::
* Función de error::
* Funciones de Struve::
* Funciones hipergeométricas::
* Funciones de cilindro parabólico::
* Funciones y variables para las funciones especiales::


File: maxima.info,  Node: Introducción a las funciones especiales,  Next: Funciones de Bessel,  Prev: Funciones Especiales,  Up: Funciones Especiales

15.1 Introducción a las funciones especiales
============================================

A continuación se especifican las notaciones correspondientes a las
funciones especiales:

     bessel_j (index, expr)    Función de Bessel de primera especie
     bessel_y (index, expr)    Función de Bessel de segunda especie
     bessel_i (index, expr)    Función de Bessel modificada de primera especie
     bessel_k (index, expr)    Función de Bessel modificada de segunda especie
     hankel_1 (v,z)            Función de Hankel de primera especie
     hankel_2 (v,z)            Función de Hankel de segunda especie
     struve_h (v,z)            Función H de Struve
     struve_l (v,z)            Función L de Struve
     %p[u,v] (z)               Función de Legendre de primera especie
     %q[u,v] (z)               Función de Legendre de segunda especie
     %f[p,q] ([], [], expr)    Función hipergeométrica generalizada
     gamma(z)                  Función Gamma
     gamma_incomplete_lower(a,z) Función Gamma incompleta inferior
     gamma_incomplete (a,z)    Extremo de la función Gamma incompleta
     hypergeometric(l1, l2, z) Función hipergeométrica
     slommel
     %m[u,k] (z)               Función de Whittaker de primera especie
     %w[u,k] (z)               Función de Whittaker de segunda especie
     erfc (z)                  Complemento de la función de error, erf
     expintegral_e (v,z)       Integral exponencial E
     expintegral_e1 (z)        Integral exponencial E1
     expintegral_ei (z)        Integral exponencial Ei
     expintegral_li (z)        Integral logarítmica Li
     expintegral_si (z)        Integral exponencial Si
     expintegral_ci (z)        Integral exponencial Ci
     expintegral_shi (z)       Integral exponencial Shi
     expintegral_chi (z)       Integral exponencial Chi
     kelliptic (z)             Integral elíptica completa
                                       de primera especie (K)
     parabolic_cylinder_d(v,z) Función D de cilindro parabólico


File: maxima.info,  Node: Funciones de Bessel,  Next: Funciones de Airy,  Prev: Introducción a las funciones especiales,  Up: Funciones Especiales

15.2 Funciones de Bessel
========================

 -- Función: bessel_j (<v>, <z>)
     Función de Bessel de primera especie de orden v y argumento z.

     La función 'bessel_j' se define como

                          inf
                          ====       k  - v - 2 k  v + 2 k
                          \     (- 1)  2          z
                           >    --------------------------
                          /        k! gamma(v + k + 1)
                          ====
                          k = 0

     aunque la serie infinita no se utiliza en los cálculos.

 -- Función: bessel_y (<v>, <z>)
     Función de Bessel de segunda especie de orden v y argumento z.

     La función 'bessel_y' se define como

                        cos(%pi v) bessel_j(v, z) - bessel_j(-v, z)
                        -------------------------------------------
                                       sin(%pi v)

     si v no es un entero.  En caso de que v sea un entero n, se calcula
     el límite cuando v se aproxima a n.

 -- Función: bessel_i (<v>, <z>)
     Función modificada de Bessel de primera especie de orden v y
     argumento z.

     La función 'bessel_i' se define como

                              inf
                              ====   - v - 2 k  v + 2 k
                              \     2          z
                               >    -------------------
                              /     k! gamma(v + k + 1)
                              ====
                              k = 0

     aunque la serie infinita no se utiliza en los cálculos.

 -- Función: bessel_k (<v>, <z>)
     Función modificada de Bessel de segunda especie de orden v y
     argumento z.

     La función 'bessel_k' se define como

                     %pi csc(%pi v) (bessel_i(-v, z) - bessel_i(v, z))
                     -------------------------------------------------
                                            2

     si v no es un entero.  Si v es igual al entero n, entonces se
     calcula el límite cuando v tiende a n.

 -- Función: hankel_1 (<v>, <z>)
     Función de Hankel de primera especie de orden v y argumento z (A&S
     9.1.3).  La función 'hankel_1' se define como

             bessel_j(v,z) + %i * bessel_y(v,z)

     Maxima evalúa 'hankel_1' numéricamente para el orden real v y el
     argumento complejo z en doble precisión (float).  La evaluación
     numérica en gran precisión (bigfloat) y para órdenes complejos no
     está implementada.

     Si 'besselexpand' vale 'true', 'hankel_1' se expande en términos de
     funciones elementales cuando el orden v es la mitad de un entero
     impar.  Véase al respecto 'besselexpand'.

     Maxima reconoce la derivada de 'hankel_1' con respecto del
     argumento z.

     Ejemplos:

     Evaluación numérica:

          (%i1) hankel_1(1,0.5);
          (%o1)              .2422684576748738 - 1.471472392670243 %i
          (%i2) hankel_1(1,0.5+%i);
          (%o2)             - .2558287994862166 %i - 0.239575601883016

     No se soportan órdenes complejos.  Maxima devuelve una forma
     nominal:

          (%i3) hankel_1(%i,0.5+%i);
          (%o3)                       hankel_1(%i, %i + 0.5)

     Expansión de 'hankel_1' cuando 'besselexpand' vale 'true':

          (%i4) hankel_1(1/2,z),besselexpand:true;
                                sqrt(2) sin(z) - sqrt(2) %i cos(z)
          (%o4)                 ----------------------------------
                                        sqrt(%pi) sqrt(z)

     Derivada de 'hankel_1' respecto del argumento z.  No está soportada
     la derivada respecto del orden v.  Maxima devuelve una forma
     nominal:

          (%i5) diff(hankel_1(v,z),z);
                              hankel_1(v - 1, z) - hankel_1(v + 1, z)
          (%o5)               ---------------------------------------
                                                 2
          (%i6) diff(hankel_1(v,z),v);
                                       d
          (%o6)                        -- (hankel_1(v, z))
                                       dv

 -- Función: hankel_2 (<v>, <z>)
     Función de Hankel de segunda especie de orden v y argumento z (A&S
     9.1.4).  La función 'hankel_2' se define como

             bessel_j(v,z) - %i * bessel_y(v,z)

     Maxima evalúa 'hankel_2' numéricamente para el orden real v y el
     argumento complejo z en doble precisión (float).  La evaluación
     numérica en gran precisión (bigfloat) y para órdenes complejos no
     está implementada.

     Si 'besselexpand' vale 'true', 'hankel_2' se expande en términos de
     funciones elementales cuando el orden v es la mitad de un entero
     impar.  Véase al respecto 'besselexpand'.

     Maxima reconoce la derivada de 'hankel_2' con respecto del
     argumento z.

     Véanse ejemplos en 'hankel_1'.

 -- Variable optativa: besselexpand
     Valor por defecto: 'false'

     Controla la expansión de las funciones de Bessel cuando el orden es
     la mitad de un entero impar.  En tal caso, las funciones de Bessel
     se pueden expandir en términos de otras funciones elementales.  Si
     'besselexpand' vale 'true', se expande la función de Bessel.

          (%i1) besselexpand: false$
          (%i2) bessel_j (3/2, z);
                                              3
          (%o2)                      bessel_j(-, z)
                                              2
          (%i3) besselexpand: true$
          (%i4) bessel_j (3/2, z);
                                                  sin(z)   cos(z)
                                 sqrt(2) sqrt(z) (------ - ------)
                                                     2       z
                                                    z
          (%o4)                  ---------------------------------
                                             sqrt(%pi)

 -- Función: scaled_bessel_i (<v>, <z>)

     Es la función de Bessel modificada de primera especie de orden v y
     argumento z, es decir scaled_bessel_i(v,z) =
     exp(-abs(z))*bessel_i(v, z).  Esta función es especialmente útil
     para calcular bessel_i cuando z es grande.  Sin embargo, Maxima no
     sabe mucho más sobre esta función.  En cálculos simbólicos, quizás
     sea preferible trabajar directamente con la expresión
     'exp(-abs(z))*bessel_i(v, z)'.

 -- Función: scaled_bessel_i0 (<z>)

     Idéntica a 'scaled_bessel_i(0,z)'.

 -- Función: scaled_bessel_i1 (<z>)

     Idéntica a 'scaled_bessel_i(1,z)'.

 -- Función: %s [<u>,<v>] (<z>)

     Función s[u,v](z) de Lommel.  Gradshteyn & Ryzhik 8.570.1.

