This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.


File: maxima.info,  Node: Grupos,  Next: Ambiente em Tempo de Execução,  Prev: Simetrias,  Up: Top

33 Grupos
*********

* Menu:

* Funções e Variáveis Definidas para Grupos::


File: maxima.info,  Node: Funções e Variáveis Definidas para Grupos,  Prev: Grupos,  Up: Grupos

33.1 Funções e Variáveis Definidas para Grupos
==============================================

 -- Função: todd_coxeter (<relação>, <subgroupo>)
 -- Função: todd_coxeter (<relação>)

     Acha a ordem de G/H onde G é o módulo do Grupo Livre <relação>, e H
     é o subgroupo de G gerado por <subgroupo>.  <subgroupo> é um
     argumento opcional, cujo valor padrão é [].  Em fazendo isso a
     função produz uma tabela de multiplicação à direita de G sobre G/H,
     onde os co-conjuntos são enumerados [H,Hg2,Hg3,...].  Isso pode ser
     visto internamente no 'todd_coxeter_state'.

     Exemplo:

          (%i1) symet(n):=create_list(
                  if (j - i) = 1 then (p(i,j))^^3 else
                      if (not i = j) then (p(i,j))^^2 else
                          p(i,i) , j, 1, n-1, i, 1, j);
                                                                 <3>
          (%o1) symet(n) := create_list(if j - i = 1 then p(i, j)

                                          <2>
           else (if not i = j then p(i, j)    else p(i, i)), j, 1, n - 1,

          i, 1, j)
          (%i2) p(i,j) := concat(x,i).concat(x,j);
          (%o2)        p(i, j) := concat(x, i) . concat(x, j)
          (%i3) symet(5);
                   <2>           <3>    <2>           <2>           <3>
          (%o3) [x1   , (x1 . x2)   , x2   , (x1 . x3)   , (x2 . x3)   ,

                      <2>           <2>           <2>           <3>    <2>
                    x3   , (x1 . x4)   , (x2 . x4)   , (x3 . x4)   , x4   ]
          (%i4) todd_coxeter(%o3);

          Rows tried 426
          (%o4)                          120
          (%i5) todd_coxeter(%o3,[x1]);

          Rows tried 213
          (%o5)                          60
          (%i6) todd_coxeter(%o3,[x1,x2]);

          Rows tried 71
          (%o6)                          20


File: maxima.info,  Node: Ambiente em Tempo de Execução,  Next: Opções Diversas,  Prev: Grupos,  Up: Top

34 Ambiente em Tempo de Execução
********************************

* Menu:

* Introdução a Ambiente em Tempo de Execução::  
* Interrupções::                  
* Funções e Variáveis Definidas para Ambiente em Tempo de Execução::  


File: maxima.info,  Node: Introdução a Ambiente em Tempo de Execução,  Next: Interrupções,  Prev: Ambiente em Tempo de Execução,  Up: Ambiente em Tempo de Execução

34.1 Introdução a Ambiente em Tempo de Execução
===============================================

'maxima-init.mac' é um arquivo que é chamado automaticamente quando o
Maxima inicia.  Você pode usar 'maxima-init.mac' para personalizar seu
ambiente Maxima.  'maxima-init.mac', se existir, é tipicamente colocado
no diretório chamado por 'maxima_userdir', embora possa estar em
qualquer outro diretório procurado pela função 'file_search'.

   Aqui está um exemplo do arquivo 'maxima-init.mac':

     setup_autoload ("specfun.mac", ultraspherical, assoc_legendre_p);
     showtime:all;

   Nesse Exemplo, 'setup_autoload' diz ao Maxima para chamar o arquivo
especificado ('specfun.mac') se qualquer das funções ('ultraspherical',
'assoc_legendre_p') forem chamadas sem estarem definidas.  Dessa forma
você não precisa lembrar de chamar o arquivo antes das funções.

   A declaração 'showtime: all' diz ao Maxima escolher a variável
'showtime'.  O arquivo 'maxima-init.mac' pode conter qualquer outras
atribuições ou outras declarações do Maxima.


File: maxima.info,  Node: Interrupções,  Next: Funções e Variáveis Definidas para Ambiente em Tempo de Execução,  Prev: Introdução a Ambiente em Tempo de Execução,  Up: Ambiente em Tempo de Execução

34.2 Interrupções
=================

O usuário pode parar uma computação que consome muito tempo com o
caractere ^C (control-C). A ação padrão é parar a computação e mostrar
outra linha de comando do usuário.  Nesse caso, não é possível continuar
a computação interrompida.

   Se a variável Lisp '*debugger-hook*' é escolhida para 'nil', através
do comando

     :lisp (setq *debugger-hook* nil)

então na ocasião do recebimento do ^C, Maxima iniciará o depurador Lisp,
e o usuário pode usar o depurador para inspecionar o ambiente Lisp.  A
computação interrompida pode ser retomada através do comando 'continue'
no depurador Lisp.  O método de retorno para ao Maxima partindo do
depurador Lisp (outro como executando a computação para complementação)
é diferente para cada versão do Lisp.

   Em sistemas Unix, o caratere ^Z (control-Z) faz com que Maxima pare
tudo e aguarde em segundo plano, e o controle é retornado para a linha
de comando do shell.  O comando 'fg' faz com que o Maxima retorne ao
primeiro plano e continue a partir do ponto no qual foi interrompido.


File: maxima.info,  Node: Funções e Variáveis Definidas para Ambiente em Tempo de Execução,  Prev: Interrupções,  Up: Ambiente em Tempo de Execução

34.3 Funções e Variáveis Definidas para Ambiente em Tempo de Execução
=====================================================================

 -- Declaração: feature
     Maxima compreende dois tipos distintos de recurso, recursos do
     sistema e recursos aplicados a expressões matemáticas.  Veja Também
     'status' para informações sobre recursos do sistema.  Veja Também
     'features' e 'featurep' para informações sobre recursos
     matemáticos.

     'feature' por si mesmo não é o nome de uma função ou variável.

 -- Função: featurep (<a>, <f>)
     Tenta determinar se o objeto <a> tem o recurso <f> na base dos
     fatos dentro base de dados corrente.  Se possue, é retornado
     'true', de outra forma é retornado 'false'.

     Note que 'featurep' retorna 'false' quando nem <f> nem a negação de
     <f> puderem ser estabelecidas.

     'featurep' avalia seus argumentos.

     Veja também 'declare' e 'features'.

          (%i1) declare (j, even)$
          (%i2) featurep (j, integer);
          (%o2)                           true

 -- Variável de sistema: maxima_tempdir

     'maxima_tempdir' nomeia o diretório no qual Maxima cria alguns
     arquivos temporários.  Em particular, arquivos temporários para
     impressão são criados no 'maxima_tempdir'.

     O valor inicial de 'maxima_tempdir' é o diretório do usuário, se o
     maxima puder localizá-lo; de outra forma Maxima supõe um diretório
     adequado.

     A 'maxima_tempdir' pode ser atribuído uma seqüência de caracteres
     que corresponde a um diretório.

 -- Variável de sistema: maxima_userdir

     'maxima_userdir' nomeia um diretório no qual Maxima espera
     encontrar seus próprios arquivos e os do arquivos do Lisp.  (Maxima
     procura em alguns outros diretórios também; 'file_search_maxima' e
     'file_search_lisp' possuem a lista completa.)

     O valor inicial de 'maxima_userdir' é um subdiretório do diretório
     do usuário, se Maxima puder localizá-lo; de outra forma Maxima
     supõe um diretório adequado.

     A 'maxima_userdir' pode ser atribuído uma seqüência de caracteres
     que corresponde a um diretório.  Todavia, fazendo uma atribuição a
     'maxima_userdir' não muda automaticamente o valor de
     'file_search_maxima' e de 'file_search_lisp'; Essas variáveis devem
     ser modificadas separadamente.

 -- Função: room ()
 -- Função: room (true)
 -- Função: room (false)
     Mostra uma descrição do estado de armazenamento e gerenciamento de
     pilha no Maxima.  'room' chama a função Lisp de mesmo nome.

        * 'room ()' mostra uma descrição moderada.
        * 'room (true)' mostra uma descrição detalhada.
        * 'room (false)' mostra uma descrição resumida.

 -- Função: status (feature)
 -- Função: status (feature, <recurso_ativo>)
 -- Função: status (status)
     Retorna informações sobre a presença ou ausência de certos recursos
     dependentes do sistema operacional.

        * 'status (feature)' retorna uma lista dos recursos do sistema.
          Inclui a versão do Lisp, tipo de sistema operacional, etc.  A
          lista pode variar de um tipo de Lisp para outro.
        * 'status (feature, <recurso_ativo>)' retorna 'true' se
          <recurso_ativo> está na lista de ítens retornada através de
          'status (feature)' e 'false' de outra forma.  'status' não
          avalia o argumento <recurso_ativo>.  O operador
          apóstrofo-apóstrofo, '''', evita a avaliação.  Um recurso cujo
          nome contém um caractere especial, tal como um hífem, deve ser
          fornecido como um argumento em forma de seqüência de
          caracteres.  Por Exemplo, 'status (feature, "ansi-cl")'.
        * 'status (status)' retorna uma lista de dois elementos
          '[feature, status]'.  'feature' e 'status' são dois argumentos
          aceitos pela função 'status'; Não está claro se essa lista tem
          significância adicional.

     A variável 'features' contém uma lista de recursos que se aplicam a
     expressões matemáticas.  Veja 'features' e 'featurep' para maiores
     informações.

 -- Função: time (%o1, %o2, %o3, ...)
     Retorna uma lista de tempos, em segundos, usados para calcular as
     linhas de saída '%o1', '%o2', '%o3', ....  O tempo retornado é uma
     estimativa do Maxima do tempo interno de computação, não do tempo
     decorrido.  'time' pode somente ser aplicado a variáveis(rótulos)
     de saída de linha; para quaisquer outras variáveis, 'time' retorna
     'unknown' (tempo desconhecido).

     Escolha 'showtime: true' para fazer com que Maxima moste o tempo de
     computação e o tempo decorrido a cada linha de saída.

 -- Função: timedate ()
     Retorna uma seqüência de caracteres representando a data e hora
     atuais.  A seqüência de caracteres tem o formato 'HH:MM:SS Dia,
     mm/dd/aaaa (GMT-n)', Onde os campos são horas, minutos, segundos,
     dia da semana, mês, dia do mês, ano, e horas que diferem da hora
     GMT.

     O valor de retorno é uma seqüência de caracteres Lisp.

     Exemplo:

          (%i1) d: timedate ();
          (%o1) 08:05:09 Wed, 11/02/2005 (GMT-7)
          (%i2) print ("timedate mostra o tempo atual", d)$
          timedate reports current time 08:05:09 Wed, 11/02/2005 (GMT-7)

 -- Função: absolute_real_time ()

     Retorna o número de segundos desde a meia noite do dia primeiro de
     janeiro de 1900 (UTC). O valor de retorno é um inteiro.

     Veja também 'elapsed_real_time' e 'elapsed_run_time'.

     Exemplo:

          (%i1) absolute_real_time ();
          (%o1)                      3385045277
          (%i2) 1900 + absolute_real_time () / (365.25 * 24 * 3600);
          (%o2)                   2007.265612087104

 -- Função: elapsed_real_time ()

     Retorna o n;umero de segundos (incluindo frações de segundo) desde
     que Maxima tenha sido recentemente iniciado ou reiniciado.  O valor
     de retorno é um número em ponto flutuante.

     Veja também 'absolute_real_time' e 'elapsed_run_time'.

     Exemplo:

          (%i1) elapsed_real_time ();
          (%o1)                       2.559324
          (%i2) expand ((a + b)^500)$
          (%i3) elapsed_real_time ();
          (%o3)                       7.552087

 -- Função: elapsed_run_time ()

     Retorna uma estimativa do número de segundos (incluindo frações de
     segundo) que o Maxima gastou em computações desde que Maxima tenha
     sido recentemente iniciado ou reiniciado.  O valor de retorno é um
     número em ponto flutuante.

     Veja também 'absolute_real_time' e 'elapsed_real_time'.

     Exemplo:

          (%i1) elapsed_run_time ();
          (%o1)                         0.04
          (%i2) expand ((a + b)^500)$
          (%i3) elapsed_run_time ();
          (%o3)                         1.26


File: maxima.info,  Node: Opções Diversas,  Next: Regras e Modelos,  Prev: Ambiente em Tempo de Execução,  Up: Top

35 Opções Diversas
******************

* Menu:

* Introdução a Opções Diversas::  
* Compartilhado::                       
* Funções e Variáveis Definidas para Opções Diversas::  


File: maxima.info,  Node: Introdução a Opções Diversas,  Next: Compartilhado,  Prev: Opções Diversas,  Up: Opções Diversas

35.1 Introdução a Opções Diversas
=================================

Nessa seção várias opções são tratadas pelo fato de possuirem um efeito
global sobre a operação do Maxima.  Também várias listas tais como a
lista de todas as funções definidas pelo usuário, são discutidas.


File: maxima.info,  Node: Compartilhado,  Next: Funções e Variáveis Definidas para Opções Diversas,  Prev: Introdução a Opções Diversas,  Up: Opções Diversas

35.2 Compartilhado
==================

O diretório "share" do Maxima contém programas e outros arquivos de
interesse para os usuários do Maxima, mas que não são parte da
implementação do núcleo do Maxima.  Esses programas são tipicamente
chamados via 'load' ou 'setup_autoload'.

   ':lisp *maxima-sharedir*' mostra a localização do diretório
compartilhado dentro do sistema de arquivos do usuário.

   'printfile ("share.usg")' imprime uma lista de pacotes desatualizados
dos pacotes compartilhados.  Usuários podem encontrar isso de forma mais
detalhada navegando no diretório compartilhado usando um navegador de
sistema de arquivo.


File: maxima.info,  Node: Funções e Variáveis Definidas para Opções Diversas,  Prev: Compartilhado,  Up: Opções Diversas

35.3 Funções e Variáveis Definidas para Opções Diversas
=======================================================

 -- Variável de sistema: aliases
     Valor padrão: '[]'

     'aliases' é a lista de átomos que possuem um alias definido pelo
     usuário (escolhido através das funções 'alias', 'ordergreat',
     'orderless' ou através da declaração do átomo como sendo um 'noun'
     (substantivo) com 'declare').

 -- Declaração: alphabetic
     'alphabetic' é uma declaração reconhecida por 'declare'.  A
     expressão 'declare(<s>, alphabetic)' diz ao Maxima para reconhecer
     como alfabético todos os caracteres em <s>, que deve ser uma
     seqüência de caracteres.

     Veja também *note Identificadores::.

     Exemplo:

          (%i1) xx\~yy\`\@ : 1729;
          (%o1)                         1729
          (%i2) declare ("~`@", alphabetic);
          (%o2)                         done
          (%i3) xx~yy`@ + @yy`xx + `xx@@yy~;
          (%o3)               `xx@@yy~ + @yy`xx + 1729
          (%i4) listofvars (%);
          (%o4)                  [@yy`xx, `xx@@yy~]

 -- Função: apropos (<string>)
     Procura por nomes Maxima que possuem <string> aparecendo em
     qualquer lugar dentro de seu nome.  Dessa forma, 'apropos (exp)'
     retorna uma lista de todos os sinalizadores e funções que possuem
     'exp' como parte de seus nomes, tais como 'expand', 'exp', e
     'exponentialize'.  Dessa forma você pode somente lembra parte do
     nome de alguma coisa você pode usar esse comando para achar o
     restante do nome.  Similarmente, você pode dizer 'apropos (tr_)'
     para achar uma lista de muitos dos comutadores relatando para o
     tradutor, muitos dos quais começam com 'tr_'.

 -- Função: args (<expr>)
     Retorna a lista de argumentos de 'expr', que pode ser de qualquer
     tipo de expressão outra como um átomo.  Somente os argumentos do
     operador de nível mais alto são extraídos; subexpressões de 'expr'
     aparecem como elementos ou subexpressões de elementos da lista de
     argumentos.

     A ordem dos ítens na lista pode depender do sinalizador global
     'inflag'.

     'args (<expr>)' é equivalente a 'substpart ("[", <expr>, 0)'.  Veja
     também 'substpart' e 'op'.

 -- Variável de opção: genindex
     Valor padrão: 'i'

     'genindex' é o prefixo usado para gerar a próxima variável do
     somatório quando necessário.

 -- Variável de opção: gensumnum
     Valor padrão: 0

     'gensumnum' é o sufixo numérico usado para gerar variável seguinte
     do somatório.  Se isso for escolhido para 'false' então o índice
     consistirá somente de 'genindex' com um sufixo numérico.

 -- Constante: inf
     Infinito positivo real.

 -- Constante: infinity
     Infinito complexo, uma magnitude infinita de ângulo de fase
     arbitrária.  Veja também 'inf' e 'minf'.

 -- Variável de sistema: infolists
     Valor padrão: '[]'

     'infolists' é uma lista dos nomes de todas as listas de informação
     no Maxima.  São elas:

     'labels'
          Todos associam '%i', '%o', e rótulos '%t'.
     'values'
          Todos associam átomos que são variáveis de usuário, não opções
          do Maxima ou comutadores, criados através de ':' ou '::' ou
          associando funcionalmente.

     'functions'
          Todas as funções definidas pelo usuário, criadas através de
          ':=' ou 'define'.

     'arrays'
          Todos os arrays declarados e não declarados, criados através
          de ':', '::', ou ':='.
     'macros'
          Todas as macros definidas pelo usuário.

     'myoptions'
          Todas as opções alguma vez alteradas pelo usuário (mesmo que
          tenham ou não elas tenham mais tarde retornadas para seus
          valores padrão).

     'rules'
          Todos os modelos definidos pelo usuário que coincidirem e
          regras de simplificação, criadas através de 'tellsimp',
          'tellsimpafter', 'defmatch', ou 'defrule'.

     'aliases'
          Todos os átomos que possuem um alias definido pelo usuário,
          criado através das funções 'alias', 'ordergreat', 'orderless'
          ou declarando os átomos como um 'noun' com 'declare'.

     'dependencies'
          Todos os átomos que possuem dependências funcionais, criadas
          através das funções 'depends' ou 'gradef'.

     'gradefs'
          Todas as funções que possuem derivadas definidas pelo usuário,
          cridas através da função 'gradef'.

     'props'
          Todos os átomos que possuem quaisquer propriedades outras que
          não essas mencionadas acima, tais como propriedades
          estabelecidas por 'atvalue' , 'matchdeclare', etc., também
          propriedades estabelecidas na função 'declare'.

     'let_rule_packages'
          Todos os pacote de régras em uso definidos pelo usuário mais o
          pacote especial 'default_let_rule_package'.
          ('default_let_rule_package' é o nome do pacote de régras usado
          quando um não está explicitamente escolhido pelo usuário.)

 -- Função: integerp (<expr>)
     Retorna 'true' se <expr> é um inteiro numérico literal, de outra
     forma retorna 'false'.

     'integerp' retorna 'false' se seu argumento for um símbolo, mesmo
     se o argumento for declarado inteiro.

     Exemplos:

          (%i1) integerp (0);
          (%o1)                         true
          (%i2) integerp (1);
          (%o2)                         true
          (%i3) integerp (-17);
          (%o3)                         true
          (%i4) integerp (0.0);
          (%o4)                         false
          (%i5) integerp (1.0);
          (%o5)                         false
          (%i6) integerp (%pi);
          (%o6)                         false
          (%i7) integerp (n);
          (%o7)                         false
          (%i8) declare (n, integer);
          (%o8)                         done
          (%i9) integerp (n);
          (%o9)                         false

 -- Variável de opção: m1pbranch
     Valor padrão: 'false'

     'm1pbranch' é principal descendente de '-1' a um expoente.
     Quantidades tais como '(-1)^(1/3)' (isto é, um expoente racional
     "ímpar") e '(-1)^(1/4)' (isto é, um expoente racional "par") são
     manuseados como segue:

                        domain:real

          (-1)^(1/3):      -1
          (-1)^(1/4):   (-1)^(1/4)

                       domain:complex
          m1pbranch:false          m1pbranch:true
          (-1)^(1/3)               1/2+%i*sqrt(3)/2
          (-1)^(1/4)              sqrt(2)/2+%i*sqrt(2)/2

 -- Função: numberp (<expr>)
     Retorna 'true' se <expr> for um inteiro literal, número racional,
     número em ponto flutuante, ou um grande número em ponto flutuante,
     de outra forma retorna 'false'.

     'numberp' retorna 'false' se seu argumento for um símbolo, mesmo se
     o argumento for um número simbólico tal como '%pi' ou '%i', ou
     declarado ser 'even', 'odd', 'integer', 'rational', 'irrational',
     'real', 'imaginary', or 'complex'.  Nota de Tradução: par, ímpar,
     inteiro, racional, irracional, real, imaginário, ou complexo.

     Exemplos:

          (%i1) numberp (42);
          (%o1)                         true
          (%i2) numberp (-13/19);
          (%o2)                         true
          (%i3) numberp (3.14159);
          (%o3)                         true
          (%i4) numberp (-1729b-4);
          (%o4)                         true
          (%i5) map (numberp, [%e, %pi, %i, %phi, inf, minf]);
          (%o5)      [false, false, false, false, false, false]
          (%i6) declare (a, even, b, odd, c, integer, d, rational,
               e, irrational, f, real, g, imaginary, h, complex);
          (%o6)                         done
          (%i7) map (numberp, [a, b, c, d, e, f, g, h]);
          (%o7) [false, false, false, false, false, false, false, false]

 -- Função: properties (<a>)
     Retorna uma lista de nomes de todas as propriedades associadas com
     o átomo <a>.

 -- Símbolo especial: props
     'props' são átomos que possuem qualquer propriedade outra como
     essas explicitamente mencionadas em 'infolists', tais como
     especificado através de 'atvalue', 'matchdeclare', etc., e também
     propriedades especificadas na função 'declare'.

 -- Função: propvars (<prop>)
     Retorna uma lista desses átomos sobre a lista 'props' que possui a
     propriedade indicada através de <prop>.  Dessa forma 'propvars
     (atvalue)' retorna uma lista de átomos que possuem atvalues.

 -- Função: put (<átomo>, <valor>, <indicador>)
     Atribui <valor> para a propriedade (especificada através de
     <indicador>) do <átomo>.  <indicador> pode ser o nome de qualquer
     propriedade, não apenas uma propriedade definida pelo sistema.

     'put' avalia seus argumentos.  'put' retorna <valor>.

     Exemplos:

          (%i1) put (foo, (a+b)^5, expr);
                                             5
          (%o1)                       (b + a)
          (%i2) put (foo, "Hello", str);
          (%o2)                         Hello
          (%i3) properties (foo);
          (%o3)            [[user properties, str, expr]]
          (%i4) get (foo, expr);
                                             5
          (%o4)                       (b + a)
          (%i5) get (foo, str);
          (%o5)                         Hello

 -- Função: qput (<átomo>, <valor>, <indicador>)
     Atribui <valor> para a propriedade (especificada através de
     <indicador>) do <átomo>.  Isso é o mesmo que 'put', exceto que os
     argumentos nã são avaliados.

     Exemplo:

          (%i1) foo: aa$
          (%i2) bar: bb$
          (%i3) baz: cc$
          (%i4) put (foo, bar, baz);
          (%o4)                          bb
          (%i5) properties (aa);
          (%o5)                [[user properties, cc]]
          (%i6) get (aa, cc);
          (%o6)                          bb
          (%i7) qput (foo, bar, baz);
          (%o7)                          bar
          (%i8) properties (foo);
          (%o8)            [value, [user properties, baz]]
          (%i9) get ('foo, 'baz);
          (%o9)                          bar

 -- Função: rem (<átomo>, <indicador>)
     Remove a propriedade indicada através de <indicador> do <átomo>.

 -- Função: remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)
 -- Função: remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)
 -- Função: remove ("<a>", operator)
 -- Função: remove (<a>, transfun)
 -- Função: remove (all, <p>)
     Remove propriedades associadas a átomos.

     'remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)' remove a propriedade
     'p_k' do átomo 'a_k'.

     'remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)' remove as
     propriedades '<p_1>, ..., <p_n>' dos átomos <a_1>, ..., <a_m>.
     Pode existir mais que um par de listas.

     'remove (all, <p>)' remove a propriedade <p> de todos os átomos que
     a possuem.

     A propriedade removida pode ser definida pelo sistema tal como
     'function', 'macro' ou 'mode_declare', ou propriedades definidas
     pelo usuário.

     uma propriedade pode ser 'transfun' para remover a versão traduzida
     Lisp de uma função.  Após executar isso, a versão Maxima da função
     é executada em lugar da versão traduzida.

     'remove ("<a>", operator)' ou, equivalentemente, 'remove ("<a>",
     op)' remove de <a> as propriedades 'operator' declaradas através de
     'prefix', 'infix', 'nary', 'postfix', 'matchfix', ou 'nofix'.  Note
     que o nome do operador deve ser escrito como uma seqüência de
     caracteres com apóstofo.

     'remove' sempre retorna 'done' se um átomo possui ou não uma
     propriedade especificada.  Esse comportamento é diferente das
     funções remove mais específicas 'remvalue', 'remarray',
     'remfunction', e 'remrule'.

 -- Função: remvalue (<nome_1>, ..., <nome_n>)
 -- Função: remvalue (all)
     Remove os valores de Variáveis de usuário <nome_1>, ..., <nome_n>
     (que podem ser subscritas) do sistema.

     'remvalue (all)' remove os valores de todas as variáveis em
     'values', a lista de todas as variáveis nomeadas através do usuário
     (em oposição a essas que são automaticamente atribuídas através do
     Maxima).

     Veja também 'values'.

 -- Função: rncombine (<expr>)
     Transforma <expr> combinando todos os termos de <expr> que possuem
     denominadores idênticos ou denominadores que diferem de cada um dos
     outros apenas por fatores numéricos somente.  Isso é ligeiramente
     diferente do comportamento de de 'combine', que coleta termos que
     possuem denominadores idênticos.

     Escolhendo 'pfeformat: true' e usando 'combine' retorna resultados
     similares a esses que podem ser obtidos com 'rncombine', mas
     'rncombine' pega o passo adicional de multiplicar cruzado fatores
     numérios do denominador.  Esses resultados em forma ideal, e a
     possibilidade de reconhecer alguns cancelamentos.

     Para usar essa função escreva primeiramente 'load(rncomb)'.

 -- Função: scalarp (<expr>)
     Retorna 'true' se <expr> for um número, constante, ou variável
     declarada 'scalar' com 'declare', ou composta inteiramente de
     números, constantes, e tais Variáveis, bmas não contendo matrizes
     ou listas.

 -- Função: setup_autoload (<nomearquivo>, <função_1>, ..., <função_n>)
     Especifica que se qualquer entre <função_1>, ..., <função_n> for
     referenciado e não ainda definido, <nomedeqrquivo> é chamado via
     'load'.  <nomearquivo> usualmente contém definições para as funções
     especificadas, embora isso não seja obrigatório.

     'setup_autoload' não trabalha para funções array.

     'setup_autoload' não avalia seus argumentos.

     Exemplo:

          (%i1) legendre_p (1, %pi);
          (%o1)                  legendre_p(1, %pi)
          (%i2) setup_autoload ("specfun.mac", legendre_p, ultraspherical);
          (%o2)                         done
          (%i3) ultraspherical (2, 1/2, %pi);
          Warning - you are redefining the Macsyma função ultraspherical
          Warning - you are redefining the Macsyma função legendre_p
                                      2
                           3 (%pi - 1)
          (%o3)            ------------ + 3 (%pi - 1) + 1
                                2
          (%i4) legendre_p (1, %pi);
          (%o4)                          %pi
          (%i5) legendre_q (1, %pi);
                                        %pi + 1
                                %pi log(-------)
                                        1 - %pi
          (%o5)                 ---------------- - 1
                                       2


File: maxima.info,  Node: Regras e Modelos,  Next: Listas,  Prev: Opções Diversas,  Up: Top

36 Regras e Modelos
*******************

* Menu:

* Introdução a Regras e Modelos::  
* Funções e Variáveis Definidas para Regras e Modelos::  


File: maxima.info,  Node: Introdução a Regras e Modelos,  Next: Funções e Variáveis Definidas para Regras e Modelos,  Prev: Regras e Modelos,  Up: Regras e Modelos

36.1 Introdução a Regras e Modelos
==================================

Essa seção descreve coincidências de modelos definidos pelo usuário e
regras de simplificação.  Existem dois grupos de funções que implementam
até certo ponto diferentes esquemas de coincidência de modelo.  Em um
grupo estão 'tellsimp', 'tellsimpafter', 'defmatch', 'defrule',
'apply1', 'applyb1', e 'apply2'.  Em outro grupo estão 'let' e
'letsimp'.  Ambos os esquemas definem modelos em termos de variáveis de
modelo declaradas por 'matchdeclare'.

   Regras de coincidência de modelos definidas por 'tellsimp' e
'tellsimpafter' são aplicadas automaticamente através do simplificador
do Maxima.  Regras definidas através de 'defmatch', 'defrule', e 'let'
são aplicadas através de uma chamada explícita de função.

   Existe mecanismos adicionais para regras aplicadas a polinômios
através de 'tellrat', e para álgebra comutativa e não comutativa no
pacote 'affine'.


File: maxima.info,  Node: Funções e Variáveis Definidas para Regras e Modelos,  Prev: Introdução a Regras e Modelos,  Up: Regras e Modelos

36.2 Funções e Variáveis Definidas para Regras e Modelos
========================================================

 -- Função: apply1 (<expr>, <rule_1>, ..., <rule_n>)
     Repetidamente aplica <rule_1> a <expr> até que isso falhe, então
     repetidamente aplica a mesma regra a todas as subexpressões de
     <expr>, da esquerda para a direita, até que <rule_1> tenha falhado
     sobre todas as subexpressões.  Chama o resultado da transformação
     de <expr> dessa maneira de <expr_2>.  Então <rule_2> é aplicada no
     mesmo estilo iniciando no topo de <expr_2>.  Quando <rule_n> falhar
     na subexpressão final, o resultado é retornado.

     'maxapplydepth' é a intensidade de nível mais distante de
     subexpressões processadas por 'apply1' e 'apply2'.

     Veja também 'applyb1', 'apply2', e 'let'.

 -- Função: apply2 (<expr>, <rule_1>, ..., <rule_n>)
     Se <rule_1> falhar sobre uma dada subexpressão, então <rule_2> é
     repetidamente aplicada, etc.  Somente se todas as regras falharem
     sobre uma dada subexpressão é que o conjunto completo de regras é
     repetidamente aplicada à próxima subexpressão.  Se uma das regras
     obtém sucesso, então a mesma subexpressão é reprocessada, iniciando
     com a primeira regra.

     'maxapplydepth' é a intensidade do nível mais distante de
     subexpressões processadas através de 'apply1' e 'apply2'.

     Veja também 'apply1' e 'let'.

 -- Função: applyb1 (<expr>, <rule_1>, ..., <rule_n>)
     Repetidamente aplica <rule_1> para a subexpressão mais distante de
     <expr> até falhar, então repetidamente aplica a mesma regra um
     nível mais acima (i.e., subexpressãos mais larga), até que <rule_1>
     tenha falhado sobre a expressão de nível mais alto.  Então <rule_2>
     é aplicada com o mesmo estilo para o resultado de <rule_1>.  após
     <rule_n> ter sido aplicada à expressão de nível mais elevado, o
     resultado é retornado.

     'applyb1' é similar a 'apply1' mas trabalha da base para cima em
     lugar de do topo para baixo.

     'maxapplyheight' é o ápice que 'applyb1' encontra antes de
     interromper.

     Veja também 'apply1', 'apply2', e 'let'.

 -- Variável de opção: current_let_rule_package
     Valor padrão: 'default_let_rule_package'

     'current_let_rule_package' é o nome do pacote de regras que está
     sendo usado por funções no pacote 'let' ('letsimp', etc.)  se
     nenhum outro pacote de regras for especificado.  A essa variável
     pode ser atribuído o nome de qualquer pacote de regras definido via
     comando 'let'.

     Se uma chamada tal como 'letsimp (expr, nome_pct_regras)' for
     feita, o pacote de regras 'nome_pct_regras' é usado para aquela
     chamada de função somente, e o valor de 'current_let_rule_package'
     não é alterado.

 -- Variável de opção: default_let_rule_package
     Valor padrão: 'default_let_rule_package'

     'default_let_rule_package' é o nome do pacote de regras usado
     quando um não for explicitamente escolhido pelo usuário com 'let'
     ou através de alteração do valor de 'current_let_rule_package'.

 -- Função: defmatch (<prognome>, <modelo>, <x_1>, ..., <x_n>)
 -- Função: defmatch (<prognome>, <modelo>)
     Define uma função '<prognome>(<expr>, <x_1>, ..., <x_n>)' que testa
     <expr> para ver se essa expressão coincide com <modelo>.

     <modelo> é uma expressão contendo os argumentos modelo <x_1>, ...,
     <x_n> (se existir algum) e alguns modelos de variáveis (se existir
     algum).  os argumentos modelo são fornecidos explicitamente como
     argumentos para 'defmatch' enquanto os modelos de variáveis são
     declarados através da função 'matchdeclare'.  Qualquer variável não
     declarada como modelo em 'matchdeclare' ou como um argumento modelo
     em 'defmatch' coincide somente com si mesma.

     O primeiro argumento para a função criada <prognome> é uma
     expressão a serem comparadas contra o modelo e os outros argumentos
     são os atuais argumetnos que correspondem às variáveis respectivas
     <x_1>, ..., <x_n> no modelo.

     Se a tentativa de coincidência obtiver sucesso, <prognome> retorna
     uma lista de equações cujos lados esquerdos são os argumetnos de
     modelo e variáveis de modelo, e cujo lado direito forem as
     subexpressões cujos argumentos de modelo e as variáveis coincidem.
     Os modelos de variáveis, mas não tos argumentos de modelo, são
     atribuídos às subexpressões que coincidirem.  Se a coincidência
     falhar, <prognome> retorna 'false'.

     Um modelo literal (isto é, um modelo que não contiver nem
     argumentos de modelo nem variáveis de modelo) retorna 'true' se a
     coincidência ocorrer.

     Veja também 'matchdeclare', 'defrule', 'tellsimp', e
     'tellsimpafter'.

     Exemplos:

     Define uma função 'linearp(expr, x)' que testa 'expr' para ver se
     essa expressão da forma 'a*x + b' tal que 'a' e 'b' não contenham
     'x' e 'a' seja não nulo.  Essa função de coincidência coincide com
     expressões que sejam lineares em qualquer variável, por que o
     argumento de modelo 'x' é fornecido para 'defmatch'.

          (%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b, freeof(x));
          (%o1)                         done
          (%i2) defmatch (linearp, a*x + b, x);
          (%o2)                        linearp
          (%i3) linearp (3*z + (y + 1)*z + y^2, z);
                                   2
          (%o3)              [b = y , a = y + 4, x = z]
          (%i4) a;
          (%o4)                         y + 4
          (%i5) b;
                                          2
          (%o5)                          y
          (%i6) x;
          (%o6)                           x

     Define uma função 'linearp(expr)' que testa 'expr' para ver se essa
     expressão é da forma 'a*x + b' tal que 'a' e 'b' não contenham 'x'
     e 'a' seja não nulo.  Essa função de coincidência somente coincide
     com expressões lineares em 'x', não em qualquer outra variável,
     porque nenhum argumento de modelo é fornecido a 'defmatch'.

          (%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b, freeof(x));
          (%o1)                         done
          (%i2) defmatch (linearp, a*x + b);
          (%o2)                        linearp
          (%i3) linearp (3*z + (y + 1)*z + y^2);
          (%o3)                         false
          (%i4) linearp (3*x + (y + 1)*x + y^2);
                                       2
          (%o4)                  [b = y , a = y + 4]

     Define uma função 'checklimits(expr)' que testa 'expr' para ver se
     essa expressão é uma integral definida.

          (%i1) matchdeclare ([a, f], true);
          (%o1)                         done
          (%i2) constinterval (l, h) := constantp (h - l);
          (%o2)        constinterval(l, h) := constantp(h - l)
          (%i3) matchdeclare (b, constinterval (a));
          (%o3)                         done
          (%i4) matchdeclare (x, atom);
          (%o4)                         done
          (%i5) simp : false;
          (%o5)                         false
          (%i6) defmatch (checklimits, 'integrate (f, x, a, b));
          (%o6)                      checklimits
          (%i7) simp : true;
          (%o7)                         true
          (%i8) 'integrate (sin(t), t, %pi + x, 2*%pi + x);
                                 x + 2 %pi
                                /
                                [
          (%o8)                 I          sin(t) dt
                                ]
                                /
                                 x + %pi
          (%i9) checklimits (%);
          (%o9)    [b = x + 2 %pi, a = x + %pi, x = t, f = sin(t)]

 -- Função: defrule (<nomeregra>, <modelo>, <substituição>)
     Define e nomeia uma regra de substituição para o modelo dado.  Se a
     regra nomeada <nomeregra> for aplicada a uma expressão (através de
     'apply1', 'applyb1', ou 'apply2'), toda subexpressão coincidindo
     com o modelo será substituída por 'substituição'.  Todas as
     variáveis em 'substituição' que tiverem sido atribuidos valores
     pela coincidência com o modelo são atribuidas esses valores na
     'substituição' que é então simplificado.

     As regras por si mesmas podem ser tratadas como funções que
     transforma uma expressão através de uma operação de coincidência de
     modelo e substituição.  Se a coincidência falhar, a função da regra
     retorna 'false'.

 -- Função: disprule (<nomeregra_1>, ..., <nomeregra_2>)
 -- Função: disprule (all)
     Mostra regras com os nomes <nomeregra_1>, ..., <nomeregra_n>, como
     retornado por 'defrule', 'tellsimp', ou 'tellsimpafter', ou um
     modelo definido por meio de 'defmatch'.  Cada regra é mostrada com
     um rótulo de expressão intermediária ('%t').

     'disprule (all)' mostra todas as regras.

     'disprule' não avalia seus argumentos.  'disprule' retorna a lista
     de rótulos de expressões intermedáirias correspondendo às regras
     mostradas.

     Veja também 'letrules', que mostra regras definidas através de
     'let'.

     Examples:

          (%i1) tellsimpafter (foo (x, y), bar (x) + baz (y));
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (x + y, special_add (x, y));
          (%o2)                   [+rule1, simplus]
          (%i3) defmatch (quux, mumble (x));
          (%o3)                         quux
          (%i4) disprule (foorule1, "+rule1", quux);
          (%t4)        foorule1 : foo(x, y) -> baz(y) + bar(x)

          (%t5)          +rule1 : y + x -> special_add(x, y)

          (%t6)                quux : mumble(x) -> []

          (%o6)                    [%t4, %t5, %t6]
          (%i6) ''%;
          (%o6) [foorule1 : foo(x, y) -> baz(y) + bar(x),
          +rule1 : y + x -> special_add(x, y), quux : mumble(x) -> []]

 -- Função: let (<prod>, <repl>, <prednome>, <arg_1>, ..., <arg_n>)
 -- Função: let ([<prod>, <repl>, <prednome>, <arg_1>, ..., <arg_n>],
          <nome_pacote>)
     Define uma regra de substituição para 'letsimp' tal que <prod> é
     substituído por <repl>.  <prod> é um produto de expoentes positivos
     ou negativos dos seguintes termos:

        * Atomos que 'letsimp' irá procurar literalmente a menos que
          previamente chamando 'letsimp' a função 'matchdeclare' é usada
          para associar um predicado com o átomo.  Nesse caso 'letsimp'
          irá coincidir com o átomo para qualquer termo de um produto
          satisfazendo o predicado.
        * Núcleos tais como 'sin(x)', 'n!', 'f(x,y)', etc.  Como com
          átomos acima 'letsimp' irá olhar um literal coincidente a
          menos que 'matchdeclare' seja usada para associar um predicado
          com o argumento do núcleo.

     Um termo para um expoente positivo irá somente coincidir com um
     termo tendo ao menos aquele expoente.  Um termo para um expoente
     negativo por outro lado irá somente coincidir com um termo com um
     expoente ao menos já negativo.  o caso de expentes negativos em
     <prod> o comutador 'letrat' deve ser escolhido para 'true'.  Veja
     também 'letrat'.

     Se um predicado for incluído na função 'let' seguido por uma lista
     de argumentos, uma tentativa de coincidência (i.e.  uma que pode
     ser aceita se o predicado fosse omitido) é aceita somente se
     'prednome (arg_1', ..., arg_n')' avaliar para 'true' onde <arg_i'>
     é o valor coincidente com <arg_i>.  O <arg_i> pode ser o nome de
     qualquer átomo ou o argumento de qualquer núcleo aparecendo em
     <prod>.  <repl> pode ser qualquer expressão racional.  Se quaisquer
     dos átomos ou argumentos de <prod> aparecer em <repl> a
     substituição é feita.

     O sinalizador global 'letrat' controla a simplificação dos
     quocientes através de 'letsimp'.  Quando 'letrat' for 'false',
     'letsimp' simplifica o numerador e o denominador de <expr>
     separadamente, e não simplifica o quociente.  Substituições tais
     como 'n!/n' vão para '(n-1)!' então falham quando 'letrat' for
     'false'.  Quando 'letrat' for 'true', então o numerador, o
     denominador, e o quociente são simplificados nessa ordem.

     Essas funções de substituição permitem a você trabalhar com muitos
     pacotes de regras.  Cada pacote de regras pode conter qualquer
     número de regras 'let' e é referenciado através de um nome definido
     pelo usuário.  'let ([<prod>, <repl>, <prednome>, <arg_1>, ...,
     <arg_n>], <nome_pacote>)' adiciona a regra <prednome> ao pacote de
     regras <nome_pacote>.  'letsimp (<expr>, <nome_pacote>)' aplica as
     regras em <nome_pacote>.  'letsimp (<expr>, <nome_pacote1>,
     <nome_pacote2>, ...)' é equivalente a 'letsimp (<expr>,
     <nome_pacote1>)' seguido por 'letsimp (%, <nome_pacote2>)', ....

     'current_let_rule_package' é o nome do pacote de regras que está
     atualmente sendo usando.  Essa variável pode receber o nome de
     qualquer pacote de regras definidos via o comando 'let'.  Quando
     qualquer das funções compreendidas no pacote 'let' são chamadas sem
     o nome do pacote, o pacote nomeado por 'current_let_rule_package' é
     usado.  Se uma chamada tal como 'letsimp (<expr>,
     <nome_pct_regras>)' é feita, o pacote de regras <nome_pct_regras> é
     usado somente para aquele comando 'letsimp', e
     'current_let_rule_package' não é alterada.  Se não especificado de
     outra forma, 'current_let_rule_package' avalia de forma padronizada
     para 'default_let_rule_package'.

          (%i1) matchdeclare ([a, a1, a2], true)$
          (%i2) oneless (x, y) := is (x = y-1)$
          (%i3) let (a1*a2!, a1!, oneless, a2, a1);
          (%o3)         a1 a2! --> a1! where oneless(a2, a1)
          (%i4) letrat: true$
          (%i5) let (a1!/a1, (a1-1)!);
                                  a1!
          (%o5)                   --- --> (a1 - 1)!
                                  a1
          (%i6) letsimp (n*m!*(n-1)!/m);
          (%o6)                      (m - 1)! n!
          (%i7) let (sin(a)^2, 1 - cos(a)^2);
                                  2               2
          (%o7)                sin (a) --> 1 - cos (a)
          (%i8) letsimp (sin(x)^4);
                                  4           2
          (%o8)                cos (x) - 2 cos (x) + 1

 -- Variável de opção: letrat
     Valor padrão: 'false'

     Quando 'letrat' for 'false', 'letsimp' simplifica o numerador e o
     denominador de uma razão separadamente, e não simplifica o
     quociente.

     Quando 'letrat' for 'true', o numerador, o denominador, e seu
     quocienten são simplificados nessa ordem.

          (%i1) matchdeclare (n, true)$
          (%i2) let (n!/n, (n-1)!);
                                   n!
          (%o2)                    -- --> (n - 1)!
                                   n
          (%i3) letrat: false$
          (%i4) letsimp (a!/a);
                                         a!
          (%o4)                          --
                                         a
          (%i5) letrat: true$
          (%i6) letsimp (a!/a);
          (%o6)                       (a - 1)!

 -- Função: letrules ()
 -- Função: letrules (<nome_pacote>)
     Mostra as regras em um pacote de regras.  'letrules ()' mostra as
     regras no pacote de regras corrente.  'letrules (<nome_pacote>)'
     mostra as regras em 'nome_pacote'.

     O pacote de regras corrente é nomeado por
     'current_let_rule_package'.  Se não especificado de outra forma,
     'current_let_rule_package' avalia de forma padrão para
     'default_let_rule_package'.

     Veja também 'disprule', que mostra regras defindas por 'tellsimp' e
     'tellsimpafter'.

 -- Função: letsimp (<expr>)
 -- Função: letsimp (<expr>, <nome_pacote>)
 -- Função: letsimp (<expr>, <nome_pacote_1>, ..., <nome_pacote_n>)
     Repetidamente aplica a substituição definida por 'let' até que
     nenhuma mudança adicional seja feita para <expr>.

     'letsimp (<expr>)' usa as regras de 'current_let_rule_package'.

     'letsimp (<expr>, <nome_pacote>)' usa as regras de <nome_pacote>
     sem alterar 'current_let_rule_package'.

     'letsimp (<expr>, <nome_pacote_1>, ..., <nome_pacote_n>)' é
     equivalente a 'letsimp (<expr>, <nome_pacote_1>', seguido por
     'letsimp (%, <nome_pacote_2>)', e assim sucessivamente.

 -- Variável de opção: let_rule_packages
     Valor padrão: '[default_let_rule_package]'

     'let_rule_packages' é uma lista de todos os pacotes de regras 'let'
     definidos pelo usuário mais o pacote padrão
     'default_let_rule_package'.

 -- Função: matchdeclare (<a_1>, <pred_1>, ..., <a_n>, <pred_n>)
     Associa um predicado <pred_k> com uma variável ou lista de
     variáveis <a_k> de forma que <a_k> coincida com expressões para as
     quais o predicado retorne qualquer coisa que não 'false'.

     Umpredicado é o nome de uma função, ou de uma expressão lambda, ou
     uma chamada de função ou chamada de função lambda iomitindo o
     úlltimo argumento, ou 'true' ou 'all'.  Qualquer expressão coincide
     com 'true' ou 'all'.  Se o predicado for especificado como uma
     chamada de função ou chamada de função lambda, a expressão a ser
     testada é anexada ao final da lista de argumentos; os argumentos
     são avaliados ao mesmo tempo que a coincidência é avaliada.  De
     outra forma, o predicado é especificado como um nome de função ou
     expressão lambda, e a expressão a ser testada é o argumento
     sozinho.  Uma função predicado não precisa ser definida quando
     'matchdeclare' for chamada; o predicado não é avaliado até que uma
     coincidência seja tentada.

     Um predicado pode retornar uma expressão Booleana além de 'true' ou
     'false'.  Expressões Booleanas são avaliadas por 'is' dentro da
     função da regra construída, de forma que não é necessário chamar
     'is' dentro do predicado.

     Se uma expressão satisfaz uma coincidência de predicado, a variável
     de coincidência é atribuída à expressão, exceto para variáveis de
     coincidência que são operandos de adição '+' ou multiplicação '*'.
     Somente adição e multiplicação são manuseadas de forma especial;
     outros operadores enários (ambos os definidos internamente e os
     definidos pelo usuário) são tratados como funções comuns.

     No caso de adição e multiplicação, a variável de coincidência pode
     ser atribuida a uma expressão simples que satisfaz o predicado de
     coincidência, ou uma adição ou um produto (respectivamente) de tais
     expressões.  Tal coincidência de termo multiplo é gulosa:
     predicados são avaliados na ordem em que suas variáveis associadas
     aparecem no modelo de coincidência, e o termo que satisfizer mais
     que um predicado é tomado pelo primeiro predicado que satisfizer.
     Cada predicado é testado contra todos os operandos de adição ou
     produto antes que o próximo predicado seja avaliado.
     Adicionalmente, se 0 ou 1 (respectivamente) satisfazem um predicado
     de coincidência, e não existe outros termos que satisfaçam o
     predicado, 0 ou 1 é atribuído para a variável de coincidência
     associada com o predicado.

     O algorítmo para processar modelos contendo adição e multiplicação
     faz alguns resultados de coincidência (por exemplo, um modelo no
     qual uma variável "coincida com qualquer coisa" aparecer)
     dependerem da ordem dos termos no modelo de coincidência e na
     expressão a ser testada a coincidência.  Todavia, se todos os
     predicados de coincidência são mutuamente exclusivos, o resultado
     de coincidência é insensível a ordenação, como um predicado de
     coincidência não pode aceitar termos de coincidência de outro.

     Chamado 'matchdeclare' com uma variável <a> como um argumento muda
     a propriedade 'matchdeclare' para <a>, se a variável <a> tiver sido
     declarada anteriormente; somente o 'matchdeclare' mais recente está
     em efeito quando uma regra é definida, mudanças posteriores para a
     propriedade 'matchdeclare' (via 'matchdeclare' ou 'remove') não
     afetam regras existentes.

     'propvars (matchdeclare)' retorna a lista de todas as variáveis
     para as quais exista uma propriedade 'matchdeclare'.  'printprops
     (<a>, matchdeclare)' retorna o predicado para a variável 'a'.
     'printprops (all, matchdeclare)' retorna a lista de predicados para
     todas as variáveis 'matchdeclare'.  'remove (<a>, matchdeclare)'
     remove a propriedade 'matchdeclare' da variável <a>.

     As funções 'defmatch', 'defrule', 'tellsimp', 'tellsimpafter', e
     'let' constroem regras que testam expressões contra modelos.

     'matchdeclare' coloca apóstrofo em seus argumentos.  'matchdeclare'
     sempre retorna 'done'.

     Exemplos:

     Um predicado é o nome de uma função, ou uma expressão lambda, ou
     uma chamada de função ou chamada a função lambda omitindo o último
     argumento, or 'true' or 'all'.

          (%i1) matchdeclare (aa, integerp);
          (%o1)                         done
          (%i2) matchdeclare (bb, lambda ([x], x > 0));
          (%o2)                         done
          (%i3) matchdeclare (cc, freeof (%e, %pi, %i));
          (%o3)                         done
          (%i4) matchdeclare (dd, lambda ([x, y], gcd (x, y) = 1) (1728));
          (%o4)                         done
          (%i5) matchdeclare (ee, true);
          (%o5)                         done
          (%i6) matchdeclare (ff, all);
          (%o6)                         done

     Se uma expressão satisfaz um predicado de coincidência, a variável
     de coincidência é atribuída à expressão.

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) defrule (r1, bb^aa, ["integer" = aa, "atom" = bb]);
                              aa
          (%o2)        r1 : bb   -> [integer = aa, atom = bb]
          (%i3) r1 (%pi^8);
          (%o3)               [integer = 8, atom = %pi]

     No caso de adição e multiplicação, à variável de coincidência pode
     ser atribuída uma expressão simples que satisfaz o predicado de
     coincidência, ou um somatório ou produtório (respectivamente) de
     tais expressões.

          (%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
          (%o1)                         done
          (%i2) defrule (r1, aa + bb, ["all atoms" = aa, "all nonatoms" = bb]);
          bb + aa partitions `sum'
          (%o2)  r1 : bb + aa -> [all atoms = aa, all nonatoms = bb]
          (%i3) r1 (8 + a*b + sin(x));
          (%o3)     [all atoms = 8, all nonatoms = sin(x) + a b]
          (%i4) defrule (r2, aa * bb, ["all atoms" = aa, "all nonatoms" = bb]);
          bb aa partitions `product'
          (%o4)   r2 : aa bb -> [all atoms = aa, all nonatoms = bb]
          (%i5) r2 (8 * (a + b) * sin(x));
          (%o5)    [all atoms = 8, all nonatoms = (b + a) sin(x)]

     Quando coincidindo argumentos de '+' e '*', se todos os predicados
     de coincidência forem mutuamente exclusivos, o resultado da
     coincidência é insensíve à ordenação, como um predicado de
     coincidência não pode aceitar termos que coincidiram com outro.

          (%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
          (%o1)                         done
          (%i2) defrule (r1, aa + bb, ["all atoms" = aa, "all nonatoms" = bb]);
          bb + aa partitions `sum'
          (%o2)  r1 : bb + aa -> [all atoms = aa, all nonatoms = bb]
          (%i3) r1 (8 + a*b + %pi + sin(x) - c + 2^n);
                                                               n
          (%o3) [all atoms = %pi + 8, all nonatoms = sin(x) + 2  - c + a b]
          (%i4) defrule (r2, aa * bb, ["all atoms" = aa, "all nonatoms" = bb]);
          bb aa partitions `product'
          (%o4)   r2 : aa bb -> [all atoms = aa, all nonatoms = bb]
          (%i5) r2 (8 * (a + b) * %pi * sin(x) / c * 2^n);
                                                            n
                                                   (b + a) 2  sin(x)
          (%o5) [all atoms = 8 %pi, all nonatoms = -----------------]
                                                           c

     As funções 'propvars' e 'printprops' retornam informações sobre
     variávels de coincidência.

          (%i1) matchdeclare ([aa, bb, cc], atom, [dd, ee], integerp);
          (%o1)                         done
          (%i2) matchdeclare (ff, floatnump, gg, lambda ([x], x > 100));
          (%o2)                         done
          (%i3) propvars (matchdeclare);
          (%o3)             [aa, bb, cc, dd, ee, ff, gg]
          (%i4) printprops (ee, matchdeclare);
          (%o4)                    [integerp(ee)]
          (%i5) printprops (gg, matchdeclare);
          (%o5)              [lambda([x], x > 100, gg)]
          (%i6) printprops (all, matchdeclare);
          (%o6) [lambda([x], x > 100, gg), floatnump(ff), integerp(ee),
                                integerp(dd), atom(cc), atom(bb), atom(aa)]

 -- Função: matchfix (<delimitador_e>, <delimitador_d>)
 -- Função: matchfix (<delimitador_e>, <delimitador_d>, <arg_pos>,
          <pos>)
     Declara um operador 'matchfix' com delimitadores esquerdo e direito
     <delimitador_e> e <delimitador_d>.  Os delimitadores são
     especificados como seqüêcias de caracteres.

     Um operador "matchfix" é uma função que aceita qualquer número de
     argumentos, tal que os argumentos ocorram entre os delimitadores
     correspondentes esquerdo e direito.  Os delimitadores podem ser
     quaisquer seqüêcias de caracteres, contanto que o analisador de
     expressões do Maxima possa distingüir os delimitadores dos
     operandos e de outras expressões e operadores.  Na prática essas
     regras excluem delimitadores não analisáveis tais como '%', ',',
     '$' e ';', e pode ser necessário isolar os delimitadores com
     espaços em branco.  O delimitador da direita pode ser o mesmo ou
     diferente do delimitador da esquerda.

     Um delimitador esquerdo pode ser associado com somente um
     delimitador direito; dois diferentes operadores 'matchfix' não
     podem ter o mesmo delimitador esquerdo.

     Um operador existente pode ser redeclarado com um operador
     'matchfix' sem alterar suas outras propriedades.  Particularmente,
     operadores internos tais como adição '+' podem ser declarados
     'matchfix', mas funções operadores não podem ser definidas para
     operadores internos.

     'matchfix (<delimitador_e>, <delimitador_d>, <arg_pos>, <pos>)'
     declara o argumento <arg_pos> como sendo um entre: expressão
     lógica, expressão comum do Maxima mas que não seja do tipo
     anterior, e qualquer outro tipo de expressão que não esteja
     incluída nos dois primeiros tipos.  Essa declaração resulta em
     <pos> sendo um entre: expressão lógica, expressão comum do Maxima
     mas que não seja do tipo anterior, e qualquer outro tipo de
     expressão que não esteja incluída nos dois primeiros tipos e os
     delimitadores <delimitador_e> e <delimitador_d>.

     A função para realizar uma operação 'matchfix' é uma função comum
     definida pelo usuário.  A função operador é definida da forma usual
     com o operador de definição de função ':=' ou 'define'.  Os
     argumentos podem ser escritos entre os delimitadores, ou com o
     delimitador esquerdo com uma seqüência de caracteres com apóstrofo
     e os argumentos seguindo entre parêntesis.  'dispfun
     (<delimitador_e>)' mostra a definição da função operador.

     O único operador interno 'matchfix' é o construtor de listas '[ ]'.
     Parêntesis '( )' e aspas duplas '" "' atuam como operadores
     'matchfix', mas não são tratados como tal pelo analisador do
     Maxima.

     'matchfix' avalia seus argumentos.  'matchfix' retorna seu primeiro
     argumento, <delimitador_e>.

     Exemplos:

        * Delimitadores podem ser quase quaisquer seqüência de
          caracteres.
          (%i1) matchfix ("@@", "~");
          (%o1)                          @@
          (%i2) @@ a, b, c ~;
          (%o2)                      @@a, b, c~
          (%i3) matchfix (">>", "<<");
          (%o3)                          >>
          (%i4) >> a, b, c <<;
          (%o4)                      >>a, b, c<<
          (%i5) matchfix ("foo", "oof");
          (%o5)                          foo
          (%i6) foo a, b, c oof;
          (%o6)                     fooa, b, coof
          (%i7) >> w + foo x, y oof + z << / @@ p, q ~;
                               >>z + foox, yoof + w<<
          (%o7)                ----------------------
                                      @@p, q~

        * Operadores 'matchfix' são funções comuns definidas pelo
          usuário.
          (%i1) matchfix ("!-", "-!");
          (%o1)                         "!-"
          (%i2) !- x, y -! := x/y - y/x;
                                              x   y
          (%o2)                   !-x, y-! := - - -
                                              y   x
          (%i3) define (!-x, y-!, x/y - y/x);
                                              x   y
          (%o3)                   !-x, y-! := - - -
                                              y   x
          (%i4) define ("!-" (x, y), x/y - y/x);
                                              x   y
          (%o4)                   !-x, y-! := - - -
                                              y   x
          (%i5) dispfun ("!-");
                                              x   y
          (%t5)                   !-x, y-! := - - -
                                              y   x

          (%o5)                         done
          (%i6) !-3, 5-!;
                                          16
          (%o6)                         - --
                                          15
          (%i7) "!-" (3, 5);
                                          16
          (%o7)                         - --
                                          15

 -- Função: remlet (<prod>, <nome>)
 -- Função: remlet ()
 -- Função: remlet (all)
 -- Função: remlet (all, <nome>)
     Apaga a regra de substituiçao, prod -> repl, mais recentemente
     definida através dea função 'let'.  Se 'nome' for fornecido a regra
     é apagada do pacote de regras chamado 'nome'.

     'remlet()' e 'remlet(all)' apagam todas as regras de substituição
     do pacote de regras corrente.  Se o nome de um pacote de regras for
     fornecido, e.g.  'remlet (all, <nome>)', o pacote de regras <nome>
     é também apagado.

     Se uma substituição é para ser mudada usando o mesmo produto,
     'remlet' não precisa ser chamada, apenas redefina a substituição
     usando o mesmo produto (literalmente) com a função 'let' e a nova
     substituição e/ou nome de predicado.  Pode agora 'remlet (<prod>)'
     ser chamada e a regra de substituição original é ressuscitada.

     Veja também 'remrule', que remove uma regra definida através de
     'tellsimp' ou de 'tellsimpafter'.

 -- Função: remrule (<op>, <nomeregra>)
 -- Função: remrule (<op>, all)
     Remove regras definidas por 'tellsimp', ou 'tellsimpafter'.

     'remrule (<op>, <nomeregra>)' remove a regra com o nome 'nomeregra'
     do operador <op>.  Quando <op> for um operador interno ou um
     operador definido pelo usuário (como definido por 'infix',
     'prefix', etc.), <op> e <rulename> devem ser colocados entre aspas
     duplas.

     'remrule (<op>, all)' remove todas as regras para o operador <op>.

     Veja também 'remlet', que remove uma regra definida através de
     'let'.

     Examples:

          (%i1) tellsimp (foo (aa, bb), bb - aa);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (aa + bb, special_add (aa, bb));
          (%o2)                   [+rule1, simplus]
          (%i3) infix ("@@");
          (%o3)                          @@
          (%i4) tellsimp (aa @@ bb, bb/aa);
          (%o4)                   [@@rule1, false]
          (%i5) tellsimpafter (quux (%pi, %e), %pi - %e);
          (%o5)                  [quuxrule1, false]
          (%i6) tellsimpafter (quux (%e, %pi), %pi + %e);
          (%o6)             [quuxrule2, quuxrule1, false]
          (%i7) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
                 quux (%e, %pi)];
                                               bb
          (%o7) [bb - aa, special_add(aa, bb), --, %pi - %e, %pi + %e]
                                               aa
          (%i8) remrule (foo, foorule1);
          (%o8)                          foo
          (%i9) remrule ("+", "+rule1");
          (%o9)                           +
          (%i10) remrule ("@@", "@@rule1");
          (%o10)                         @@
          (%i11) remrule (quux, all);
          (%o11)                        quux
          (%i12) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
                  quux (%e, %pi)];
          (%o12) [foo(aa, bb), bb + aa, aa @@ bb, quux(%pi, %e),
                                                   quux(%e, %pi)]

 -- Função: tellsimp (<pattern>, <replacement>)
     é similar a 'tellsimpafter' mas coloca nova informação antes da
     antiga de forma que essa nova regra seja aplicada antes das regras
     de simplificação internas.

     'tellsimp' é usada quando for importante modificar a expressão
     antes que o simplificador trabalhe sobre ela, por exemplo se o
     simplificador "sabe" alguma coisa sobre a expressão, mas o que ele
     retorna não é para sua apreciação.  Se o simplificador "sabe"
     alguma coisa sobre o principal operador da expressão, mas está
     simplesmente escondendo de você, você provavelmente quer usar
     'tellsimpafter'.

     O modelo pode não ser uma adição, um produto, variável simples, ou
     número.

     'rules' é a lista de regras definidas por 'defrule', 'defmatch',
     'tellsimp', e 'tellsimpafter'.

     Exemplos:

          (%i1) matchdeclare (x, freeof (%i));
          (%o1)                         done
          (%i2) %iargs: false$
          (%i3) tellsimp (sin(%i*x), %i*sinh(x));
          (%o3)                 [sinrule1, simp-%sin]
          (%i4) trigexpand (sin (%i*y + x));
          (%o4)         sin(x) cos(%i y) + %i cos(x) sinh(y)
          (%i5) %iargs:true$
          (%i6) errcatch(0^0);
           0
          0  has been generated
          (%o6)                          []
          (%i7) ev (tellsimp (0^0, 1), simp: false);
          (%o7)                  [^rule1, simpexpt]
          (%i8) 0^0;
          (%o8)                           1
          (%i9) remrule ("^", %th(2)[1]);
          (%o9)                           ^
          (%i10) tellsimp (sin(x)^2, 1 - cos(x)^2);
          (%o10)                 [^rule2, simpexpt]
          (%i11) (1 + sin(x))^2;
                                                2
          (%o11)                    (sin(x) + 1)
          (%i12) expand (%);
                                             2
          (%o12)               2 sin(x) - cos (x) + 2
          (%i13) sin(x)^2;
                                            2
          (%o13)                     1 - cos (x)
          (%i14) kill (rules);
          (%o14)                        done
          (%i15) matchdeclare (a, true);
          (%o15)                        done
          (%i16) tellsimp (sin(a)^2, 1 - cos(a)^2);
          (%o16)                 [^rule3, simpexpt]
          (%i17) sin(y)^2;
                                            2
          (%o17)                     1 - cos (y)

 -- Função: tellsimpafter (<modelo>, <substituição>)
     Define a uma regra de simplificação que o simplificador do Maxima
     aplica após as regras de simplificação internas.  <modelo> é uma
     expressão, compreendendo variáveis de modelo (declaradas através de
     'matchdeclare') e outros átomos e operações, considerados literais
     para o propósito de coincidência de modelos.  <substituição> é
     substituída para uma expressão atual que coincide com <modelo>;
     variáveis de modelo em <substituição> são atribuidas a valores
     coincidentes na expressão atual.

     <modelo> pode ser qualquer expressão não atômica na qual o
     principal operador não é uma variável de modelo; a regra de
     simplificação está associada com o operador principal.  Os nomes de
     funções (com uma excessão, descrita abaixo), listas, e arrays podem
     aparecer em <modelo> como o principal operador somente como
     literais (não variáveis de modelo); essas regras fornecem
     expressões tais como 'aa(x)' e 'bb[y]' como modelos, se 'aa' e 'bb'
     forem variáveis de modelo.  Nomes de funções, listas, e arrays que
     são variáveis de modelo podem aparecer como operadores outros que
     não o operador principal em <modelo>.

     Existe uma excessão para o que foi dito acima com relação a regras
     e nomes de funções.  O nome de uma função subscrita em uma
     expressão tal como 'aa[x](y)' pode ser uma variável de modelo,
     porque o operador principal não é 'aa' mas ao contrário o átomo
     Lisp 'mqapply'.  Isso é uma conseqüência da representação de
     expressões envolvendo funções subscritas.

     Regras de simplificação são aplicadas após avaliação (se não
     suprimida através de colocação de apóstrofo ou do sinalizador
     'noeval').  Regras estabelecidas por 'tellsimpafter' são aplicadas
     na ordem em que forem definidas, e após quaisquer regras internas.
     Regras são aplicadas de baixo para cima, isto é, aplicadas primeiro
     a subexpressões antes de ser aplicada à expressão completa.  Isso
     pode ser necessário para repetidamente simplificar um resultado
     (por exemplo, via o operador apóstrofo-apóstrofo '''' ou o
     sinalizador 'infeval') para garantir que todas as regras são
     aplicadas.

     Variáveis de modelo são tratadas como variáveis locais em regras de
     simplificação.  Assim que uma regra é definida, o valor de uma
     variável de modelo não afeta a regra, e não é afetado pela regra.
     Uma atribuição para uma variável de modelo que resulta em uma
     coincidência de regra com sucesso não afeta a atribuição corrente
     (ou necessita disso) da variável de modelo.  Todavia, como com
     todos os átomos no Maxima, as propriedades de variáveis de modelo
     (como declarado por 'put' e funções relacionadas) são globais.

     A regra construída por 'tellsimpafter' é nomeada após o operador
     principal de 'modelo'.  Regras para operadores internos, e
     operadores definidos pelo usuário definidos por meio de 'infix',
     'prefix', 'postfix', 'matchfix', e 'nofix', possuem nomes que são
     seqüências de caracteres do Maxima.  Regras para outras funções
     possuem nomes que são identificadores comuns do Maxima.

     O tratamento de substantivos e formas verbais é desprezívelmente
     confuso.  Se uma regra é definida para uma forma substantiva (ou
     verbal) e uma regra para o verbo correspondente (ou substantivo) já
     existe, então a nova regra definida aplica-se a ambas as formas
     (substantiva e verbal).  Se uma regra para a correspondente forma
     verbal (ou substantiva) não existe, a nova regra definida
     aplicar-se-á somente para a forma substantiva (ou verbal).

     A regra construída através de 'tellsimpafter' é uma função Lisp
     comum.  Se o nome da regra for '$foorule1', a construção ':lisp
     (trace $foorule1)' rastreia a função, e ':lisp (symbol-function
     '$foorule1' mostra sua definição.

     'tellsimpafter' não avalia seus argumentos.  'tellsimpafter'
     retorna a lista de regras para o operador principal de <modelo>,
     incluindo a mais recente regra estabelecia.

     Veja também 'matchdeclare', 'defmatch', 'defrule', 'tellsimp',
     'let', 'kill', 'remrule', e 'clear_rules'.

     Exemplos:

     <modelo> pode ser qualquer expressão não atômica na qual o
     principal operador não é uma variável de modelo.

          (%i1) matchdeclare (aa, atom, [ll, mm], listp, xx, true)$
          (%i2) tellsimpafter (sin (ll), map (sin, ll));
          (%o2)                 [sinrule1, simp-%sin]
          (%i3) sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);
                              1  sqrt(2)  sqrt(3)
          (%o3)              [-, -------, -------, 1, 0]
                              2     2        2
          (%i4) tellsimpafter (ll^mm, map ("^", ll, mm));
          (%o4)                  [^rule1, simpexpt]
          (%i5) [a, b, c]^[1, 2, 3];
                                          2   3
          (%o5)                      [a, b , c ]
          (%i6) tellsimpafter (foo (aa (xx)), aa (foo (xx)));
          (%o6)                   [foorule1, false]
          (%i7) foo (bar (u - v));
          (%o7)                    bar(foo(u - v))

     Regras são aplicadas na ordem em que forem definidas.  Se duas
     regras podem coincidir com uma expressão, a regra que foi primeiro
     definida é a que será aplicada.

          (%i1) matchdeclare (aa, integerp);
          (%o1)                         done
          (%i2) tellsimpafter (foo (aa), bar_1 (aa));
          (%o2)                   [foorule1, false]
          (%i3) tellsimpafter (foo (aa), bar_2 (aa));
          (%o3)              [foorule2, foorule1, false]
          (%i4) foo (42);
          (%o4)                       bar_1(42)

     variáveis de modelo são tratadas como variáveis locais em regras de
     simplificação.  (Compare a 'defmatch', que trata variáveis de
     modelo como variáveis globais.)

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) bb: 12345;
          (%o3)                         12345
          (%i4) foo (42, %e);
          (%o4)                 bar(aa = 42, bb = %e)
          (%i5) bb;
          (%o5)                         12345

     Como com todos os átomos, propriedades de variáveis de modelo são
     globais embora valores sejam locais.  Nesse exemplo, uma
     propriedade de atribuição é declarada via 'define_variable'.  Essa
     é a propriedade do átomo 'bb' através de todo o Maxima.

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) foo (42, %e);
          (%o3)                 bar(aa = 42, bb = %e)
          (%i4) define_variable (bb, true, boolean);
          (%o4)                         true
          (%i5) foo (42, %e);
          Error: bb was declared mode boolean, has value: %e
           -- an error.  Quitting.  To debug this try debugmode(true);

     Regras são nomeadas após operadores principais.  Nomes de regras
     para operadores internos e operadores definidos pelo usuário são
     seqüências de caracteres, enquanto nomes para outras funções são
     identificadores comuns.

          (%i1) tellsimpafter (foo (%pi + %e), 3*%pi);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (foo (%pi * %e), 17*%e);
          (%o2)              [foorule2, foorule1, false]
          (%i3) tellsimpafter (foo (%i ^ %e), -42*%i);
          (%o3)         [foorule3, foorule2, foorule1, false]
          (%i4) tellsimpafter (foo (9) + foo (13), quux (22));
          (%o4)                   [+rule1, simplus]
          (%i5) tellsimpafter (foo (9) * foo (13), blurf (22));
          (%o5)                  [*rule1, simptimes]
          (%i6) tellsimpafter (foo (9) ^ foo (13), mumble (22));
          (%o6)                  [^rule1, simpexpt]
          (%i7) rules;
          (%o7) [trigrule0, trigrule1, trigrule2, trigrule3, trigrule4,
          htrigrule1, htrigrule2, htrigrule3, htrigrule4, foorule1,
          foorule2, foorule3, +rule1, *rule1, ^rule1]
          (%i8) foorule_name: first (%o1);
          (%o8)                       foorule1
          (%i9) plusrule_name: first (%o4);
          (%o9)                        +rule1
          (%i10) [?mstringp (foorule_name), symbolp (foorule_name)];
          (%o10)                    [false, true]
          (%i11) [?mstringp (plusrule_name), symbolp (plusrule_name)];
          (%o11)                    [true, true]
          (%i12) remrule (foo, foorule1);
          (%o12)                         foo
          (%i13) remrule ("^", "^rule1");
          (%o13)                          ^

     Um exemplo trabalhado: multiplicação anticomutativa.

          (%i1) gt (i, j) := integerp(j) and i < j;
          (%o1)           gt(i, j) := integerp(j) and i < j
          (%i2) matchdeclare (i, integerp, j, gt(i));
          (%o2)                         done
          (%i3) tellsimpafter (s[i]^^2, 1);
          (%o3)                 [^^rule1, simpncexpt]
          (%i4) tellsimpafter (s[i] . s[j], -s[j] . s[i]);
          (%o4)                   [.rule1, simpnct]
          (%i5) s[1] . (s[1] + s[2]);
          (%o5)                    s  . (s  + s )
                                    1     2    1
          (%i6) expand (%);
          (%o6)                      1 - s  . s
                                          2    1
          (%i7) factor (expand (sum (s[i], i, 0, 9)^^5));
          (%o7) 100 (s  + s  + s  + s  + s  + s  + s  + s  + s  + s )
                      9    8    7    6    5    4    3    2    1    0

 -- Função: clear_rules ()
     Executa 'kill (rules)' e então re-escolhe o próximo número de regra
     para 1 para adição '+', multiplicação '*', e exponenciação '^'.


File: maxima.info,  Node: Listas,  Next: Conjuntos,  Prev: Regras e Modelos,  Up: Top

37 Listas
*********

* Menu:

* Introdução a Listas::
* Funções e Variáveis Definidas para Listas::


File: maxima.info,  Node: Introdução a Listas,  Next: Funções e Variáveis Definidas para Listas,  Prev: Listas,  Up: Listas

37.1 Introdução a Listas
========================

Listas são o bloco básico de construção para Maxima e Lisp.**Todos os
outros tipos de dado como arrays, tabelas desordenadas, números são
representados como listas Lisp.  Essas listas Lisp possuem a forma

     ((MPLUS) $A 2)

para indicar a expressão 'a+2'.**No nível um do Maxima poderemos ver a
notação infixa 'a+2'.**Maxima também tem listas que foram impressas como

     [1, 2, 7, x+y]

para uma lista com 4 elementos.**Internamente isso corresponde a uma
lista Lisp da forma

     ((MLIST) 1  2  7  ((MPLUS)  $X $Y ))

O sinalizador que denota o tipo campo de uma expressão Maxima é uma
lista em si mesmo, após ter sido adicionado o simplificador a lista
poderá transforma-se

     ((MLIST SIMP) 1 2 7 ((MPLUS SIMP) $X $Y))


File: maxima.info,  Node: Funções e Variáveis Definidas para Listas,  Prev: Introdução a Listas,  Up: Listas

37.2 Funções e Variáveis Definidas para Listas
==============================================

 -- Função: append (<list_1>, ..., <list_n>)
     Retorna uma lista simples dos elementos de <list_1> seguidos pelos
     elementos de <list_2>, ....  'append' também trabalha sobre
     expressões gerais, e.g.  'append (f(a,b), f(c,d,e));' retorna
     'f(a,b,c,d,e)'.

     Faça 'example(append);' para um exemplo.

 -- Função: assoc (<key>, <list>, <default>)
 -- Função: assoc (<key>, <list>)
     Essa função procura pela chave <key> do lado esquerdo da entrada
     <list> que é da forma '[x,y,z,...]' onde cada elemento de <list> é
     uma expressão de um operando binário e 2 elementos.  Por exemplo
     'x=1', '2^3', '[a,b]' etc.  A chave <key> é verificada contra o
     primeiro operando.  'assoc' retorna o segundo operando se 'key' for
     achada.  Se a chave 'key' não for achada isso retorna o valor
     padrão <default>.  <default> é opcional e o padrão é 'false'.

 -- Função: atom (<expr>)
     Retorna 'true' se <expr> for atomica (i.e.  um número, nome ou
     seqüência de caracteres) de outra forma retorna 'false'.  Desse
     modo 'atom(5)' é 'true' enquanto 'atom(a[1])' e 'atom(sin(x))' São
     'false' (assumindo 'a[1]' e 'x' não estão associados).

 -- Função: cons (<expr>, <list>)
     Retorna uma nova lista construída do elemento <expr> como seu
     primeiro elemento, seguido por elementos de <list>.  'cons' também
     trabalha sobre outras expressões, e.g.  'cons(x, f(a,b,c));' ->
     'f(x,a,b,c)'.

 -- Função: copylist (<list>)
     Retorna uma cópia da lista <list>.

 -- Função: create_list (<form>, <x_1>, <list_1>, ..., <x_n>, <list_n>)

     Cria uma lista por avaliação de <form> com <x_1> associando a cada
     elemento <list_1>, e para cada tal associação anexa <x_2> para cada
     elemento de <list_2>, ....  O número de elementos no resultado será
     o produto do número de elementos de cada lista.  Cada variável
     <x_i> pode atualmente ser um síbolo -o qual não pode ser avaliado.
     A lista de argumentos será avaliada uma única vez no início do
     bloco de repetição.

          (%i82) create_list1(x^i,i,[1,3,7]);
          (%o82) [x,x^3,x^7]

     Com um bloco de repetição duplo:

          (%i79) create_list([i,j],i,[a,b],j,[e,f,h]);
          (%o79) [[a,e],[a,f],[a,h],[b,e],[b,f],[b,h]]

     Em lugar de <list_i> dois argumentos podem ser fornecidos cada um
     dos quais será avaliado como um número.  Esses podem vir a ser
     inclusive o limite inferior e superior do bloco de repetição.

          (%i81) create_list([i,j],i,[1,2,3],j,1,i);
          (%o81) [[1,1],[2,1],[2,2],[3,1],[3,2],[3,3]]

     Note que os limites ou lista para a variável 'j' podem depender do
     valor corrente de 'i'.

 -- Função: delete (<expr_1>, <expr_2>)
 -- Função: delete (<expr_1>, <expr_2>, <n>)
     Remove todas as ocorrências de <expr_1> em <expr_2>.  <expr_1> pode
     ser uma parcela de <expr_2> (se isso for uma adição) ou um fator de
     <expr_2> (se isso for um produto).

          (%i1) delete(sin(x), x+sin(x)+y);
          (%o1)                         y + x

     'delete(<expr_1>, <expr_2>, <n>)' remove as primeiras <n>
     ocorrências de <expr_1> em <expr_2>.  Se houver menos que <n>
     ocorrências de <expr_1> em <expr_2> então todas as corrências seram
     excluídas.

          (%i1) delete(a, f(a,b,c,d,a));
          (%o1)                      f(b, c, d)
          (%i2) delete(a, f(a,b,a,c,d,a), 2);
          (%o2)                     f(b, c, d, a)

 -- Função: eighth (<expr>)
     Retorna o oitavo item de uma expressão ou lista <expr>.  Veja
     'first' para maiores detalhes.

 -- Função: endcons (<expr>, <list>)
     Retorna uma nova lista consistindo de elementos de 'list' seguidos
     por <expr>.  'endcons' também trabalha sobre expressões gerais,
     e.g.  'endcons(x, f(a,b,c));' -> 'f(a,b,c,x)'.

 -- Função: fifth (<expr>)
     Retorna o quinto item da expressão ou lista <expr>.  Veja 'first'
     para maiores detalhes.

 -- Função: first (<expr>)
     Retorna a primeira parte de <expr> que pode resultar no primeiro
     elemento de uma lista, a primeira linha de uma matriz, a primeira
     parcela de uma adição, etc.  Note que 'first' e suas funções
     relacionadas, 'rest' e 'last', trabalham sobre a forma de <expr>
     que é mostrada não da forma que é digitada na entrada.  Se a
     variável 'inflag' é escolhida para 'true' todavia, essa funções
     olharão na forma interna de <expr>.  Note que o simplificador
     re-ordena expressões.  Desse modo 'first(x+y)' será 'x' se 'inflag'
     for 'true' e 'y' se 'inflag' for 'false' ('first(y+x)' fornece os
     mesmos resultados).  As funções 'second' ..  'tenth' retornam da
     segunda até a décima parte do seu argumento.

 -- Função: fourth (<expr>)
     Retorna o quarto item da expressõ ou lista <expr>.  Veja 'first'
     para maiores detalhes.

 -- Função: get (<a>, <i>)
     Recupera a propriedade de usuário indicada por <i> associada com o
     átomo <a> ou retorna 'false' se "a" não tem a propriedade <i>.

     'get' avalia seus argumentos.

          (%i1) put (%e, 'transcendental, 'type);
          (%o1)                    transcendental
          (%i2) put (%pi, 'transcendental, 'type)$
          (%i3) put (%i, 'algebraic, 'type)$
          (%i4) typeof (expr) := block ([q],
                  if numberp (expr)
                  then return ('algebraic),
                  if not atom (expr)
                  then return (maplist ('typeof, expr)),
                  q: get (expr, 'type),
                  if q=false
                  then errcatch (error(expr,"is not numeric.")) else q)$
          (%i5) typeof (2*%e + x*%pi);
          x is not numeric.
          (%o5)  [[transcendental, []], [algebraic, transcendental]]
          (%i6) typeof (2*%e + %pi);
          (%o6)     [transcendental, [algebraic, transcendental]]

 -- Função: join (<l>, <m>)
     Cria uma nova lista contendo os elementos das lista <l> e <m>,
     intercaladas.  O resultado tem os elementos '[<l>[1], <m>[1],
     <l>[2], <m>[2], ...]'.  As listas <l> e <m> podem conter qualquer
     tipo de elementos.

     Se as listas forem de diferentes comprimentos, 'join' ignora
     elementos da lista mais longa.

     Maxima reclama se <l> ou <m> não for uma lista.

     Exemplos:

          (%i1) L1: [a, sin(b), c!, d - 1];
          (%o1)                [a, sin(b), c!, d - 1]
          (%i2) join (L1, [1, 2, 3, 4]);
          (%o2)          [a, 1, sin(b), 2, c!, 3, d - 1, 4]
          (%i3) join (L1, [aa, bb, cc, dd, ee, ff]);
          (%o3)        [a, aa, sin(b), bb, c!, cc, d - 1, dd]

 -- Função: last (<expr>)
     Retorna a última parte (parcela, linha, elemento, etc.)  de <expr>.

 -- Função: length (<expr>)
     Retorna (por padrão) o número de partes na forma externa (mostrada)
     de <expr>.  Para listas isso é o número de elementos, para matrizes
     isso é o número de linhas, e para adições isso é o número de
     parcelas (veja 'dispform').

     O comando 'length' é afetado pelo comutador 'inflag'.  Então, e.g.
     'length(a/(b*c));' retorna 2 se 'inflag' for 'false' (Assumindo
     'exptdispflag' sendo 'true'), mas 3 se 'inflag' for 'true' (A
     representação interna é essencialmente 'a*b^-1*c^-1').

 -- Variável de opção: listarith
     Valor padrão: 'true' - se 'false' faz com que quaisquer operações
     aritméticas com listas sejam suprimidas; quando 'true', operações
     lista-matriz são contagiosas fazendo com que listas sejam
     convertidas para matrizes retornando um resultado que é sempre uma
     matriz.  Todavia, operações lista-lista podem retornar listas.

 -- Função: listp (<expr>)
     Retorna 'true' se <expr> for uma lista de outra forma retorna
     'false'.

 -- Função: makelist (<expr>, <i>, <i_0>, <i_1>)
 -- Função: makelist (<expr>, <x>, <list>)
     Constrói e retorna uma lista, cada elemento dessa lista é gerado
     usando <expr>.

     'makelist (<expr>, <i>, <i_0>, <i_1>)' retorna uma lista, o
     'j''ésimo elemento dessa lista é igual a 'ev (<expr>, <i>=j)' para
     'j' variando de <i_0> até <i_1>.

     'makelist (<expr>, <x>, <list>)' retorna uma lista, o 'j''ésimo
     elemento é igual a 'ev (<expr>, <x>=<list>[j])' para 'j' variando
     de 1 até 'length (<list>)'.

     Exemplos:

          (%i1) makelist(concat(x,i),i,1,6);
          (%o1)               [x1, x2, x3, x4, x5, x6]
          (%i2) makelist(x=y,y,[a,b,c]);
          (%o2)                 [x = a, x = b, x = c]

 -- Função: member (<expr_1>, <expr_2>)

     Retorna 'true' se 'is(<expr_1> = <a>)' para algum elemento <a> em
     'args(<expr_2>)', de outra forma retorna 'false'.

     'expr_2' é tipicamente uma lista, nesse caso 'args(<expr_2>) =
     <expr_2>' e 'is(<expr_1> = <a>)' para algum elemento <a> em
     'expr_2' é o teste.

     'member' não inspeciona partes dos argumentos de 'expr_2', então
     'member' pode retornar 'false' mesmo se 'expr_1' for uma parte de
     algum argumento de 'expr_2'.

     Veja também 'elementp'.

     Exemplos:

          (%i1) member (8, [8, 8.0, 8b0]);
          (%o1)                         true
          (%i2) member (8, [8.0, 8b0]);
          (%o2)                         false
          (%i3) member (b, [a, b, c]);
          (%o3)                         true
          (%i4) member (b, [[a, b], [b, c]]);
          (%o4)                         false
          (%i5) member ([b, c], [[a, b], [b, c]]);
          (%o5)                         true
          (%i6) F (1, 1/2, 1/4, 1/8);
                                         1  1  1
          (%o6)                     F(1, -, -, -)
                                         2  4  8
          (%i7) member (1/8, %);
          (%o7)                         true
          (%i8) member ("ab", ["aa", "ab", sin(1), a + b]);
          (%o8)                         true

 -- Função: ninth (<expr>)
     Retorna o nono item da expressão ou lista <expr>.  Veja 'first'
     para maiores detalhes.

 -- Função: rest (<expr>, <n>)
 -- Função: rest (<expr>)
     Retorna <expr> com seus primeiros <n> elementos removidos se <n>
     for positivo e seus últimos '- <n>' elementos removidos se <n> for
     negativo.  Se <n> for 1 isso pode ser omitido.  <expr> pode ser uma
     lista, matriz, ou outra expressão.

 -- Função: reverse (<list>)
     Ordem reversa para os membros de <list> (não os membros em si
     mesmos).  'reverse' também trabalha sobre expressões gerais, e.g.
     'reverse(a=b);' fornece 'b=a'.

 -- Função: second (<expr>)
     Retorna o segundo item da expressão ou lista <expr>.  Veja 'first'
     para maiores detalhes.

 -- Função: seventh (<expr>)
     Retorna o sétimo item da expressão ou lista <expr>.  Veja 'first'
     para maiores detalhes.

 -- Função: sixth (<expr>)
     Retorna o sexto item da expressão ou lista <expr>.  Veja 'first'
     para maiores detalhes.

 -- Função: sublist_indices (<L>, <P>)

     Retorna os índices dos elementos 'x' da lista <L> para os quais o
     predicado 'maybe(<P>(x))' retornar 'true'; isso inclui 'unknown'
     bem como 'false'.  <P> pode ser um nome de função ou uma expressão
     lambda.  <L> deve ser uma lista literal.

     Exemplos:

          (%i1) sublist_indices ('[a, b, b, c, 1, 2, b, 3, b], lambda ([x], x='b));
          (%o1)                     [2, 3, 7, 9]
          (%i2) sublist_indices ('[a, b, b, c, 1, 2, b, 3, b], symbolp);
          (%o2)                  [1, 2, 3, 4, 7, 9]
          (%i3) sublist_indices ([1 > 0, 1 < 0, 2 < 1, 2 > 1, 2 > 0], identity);
          (%o3)                       [1, 4, 5]
          (%i4) assume (x < -1);
          (%o4)                       [x < - 1]
          (%i5) map (maybe, [x > 0, x < 0, x < -2]);
          (%o5)                [false, true, unknown]
          (%i6) sublist_indices ([x > 0, x < 0, x < -2], identity);
          (%o6)                          [2]

 -- Função: tenth (<expr>)
     Retorna o décimo item da expressão ou lista <expr>.  Veja 'first'
     para maiores detalhes.

 -- Função: third (<expr>)
     Retorna o terceiro item da expressão ou lista <expr>.  Veja 'first'
     para maiores detalhes.


File: maxima.info,  Node: Conjuntos,  Next: Definição de Função,  Prev: Listas,  Up: Top

38 Conjuntos
************

* Menu:

* Introdução a Conjuntos::       
* Funções e Variáveis Definidas para Conjuntos::       


File: maxima.info,  Node: Introdução a Conjuntos,  Next: Funções e Variáveis Definidas para Conjuntos,  Prev: Conjuntos,  Up: Conjuntos

38.1 Introdução a Conjuntos
===========================

Maxima fornece funções de conjunto, tais como intersecção e união, para
conjuntos finitos que são definidos por enumeração explícitamente.
Maxima trata listas e conjuntos como objetos distintos.  Esse recurso
torna possível trabalhar com conjuntos que possuem elementos que são ou
listas ou conjuntos.

   Adicionalmente para funções de conjuntos finitos, Maxima fornece
algumas funoes relacionadas a análise combinatória; essas incluem os
números de Stirling de primero e de segundo tipo, os números de Bell,
coefincientes multinomiais, partições de inteiros não negativos, e umas
poucas outras.  Maxima também define uma função delta de Kronecker.

38.1.1 Utilização
-----------------

Para construir um conjunto com elementos 'a_1, ..., a_n', escreva
'set(a_1, ..., a_n)' ou '{a_1, ..., a_n}'; para construir o conjunto
vazio, escreva 'set()' ou '{}'.  Para inserção de dados, 'set(...)' e '{
... }' são equivalentes.  Conjuntos são sempre mostrados entre chaves
('{ ... }').

   Se um elemento é listado mais de uma vez, a simplificação elimina o
elemento redundante.

     (%i1) set();
     (%o1)                          {}
     (%i2) set(a, b, a);
     (%o2)                        {a, b}
     (%i3) set(a, set(b));
     (%o3)                       {a, {b}}
     (%i4) set(a, [b]);
     (%o4)                       {a, [b]}
     (%i5) {};
     (%o5)                          {}
     (%i6) {a, b, a};
     (%o6)                        {a, b}
     (%i7) {a, {b}};
     (%o7)                       {a, {b}}
     (%i8) {a, [b]};
     (%o8)                       {a, [b]}

   Dois elementos <x> e <y> são redundantes (i.e., considerados o mesmo
para propósito de construção de conjuntos) se e somente se 'is(<x> =
<y>)' retornar 'true'.  Note que 'is(equal(<x>, <y>))' pode retornar
'true' enquanto 'is(<x> = <y>)' retorna 'false'; nesse caso os elementos
<x> e <y> são considerados distintos.

     (%i1) x: a/c + b/c;
                                   b   a
     (%o1)                         - + -
                                   c   c
     (%i2) y: a/c + b/c;
                                   b   a
     (%o2)                         - + -
                                   c   c
     (%i3) z: (a + b)/c;
                                   b + a
     (%o3)                         -----
                                     c
     (%i4) is (x = y);
     (%o4)                         true
     (%i5) is (y = z);
     (%o5)                         false
     (%i6) is (equal (y, z));
     (%o6)                         true
     (%i7) y - z;
                                b + a   b   a
     (%o7)                    - ----- + - + -
                                  c     c   c
     (%i8) ratsimp (%);
     (%o8)                           0
     (%i9) {x, y, z};
                               b + a  b   a
     (%o9)                    {-----, - + -}
                                 c    c   c

   Para construir um conjunto dos elementos de uma lista, use 'setify'.

     (%i1) setify ([b, a]);
     (%o1)                        {a, b}

   Os elementos de conjuntos 'x' e 'y' são iguais fornecendo 'is(x = y)'
avaliando para 'true'.  Dessa forma 'rat(x)' e 'x' são iguais como
elementos de conjuntos; conseqüentemente,

     (%i1) {x, rat(x)};
     (%o1)                          {x}

   Adicionalmente, uma vez que 'is((x - 1)*(x + 1) = x^2 - 1)' avalia
para 'false', '(x - 1)*(x + 1)' e 'x^2 - 1' são distintos elementos de
conjunto; dessa forma

     (%i1) {(x - 1)*(x + 1), x^2 - 1};
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}

   Para reduzir esse conjunto a um conjunto simples, apliquemos 'rat' a
cada elemeto do conjunto

     (%i1) {(x - 1)*(x + 1), x^2 - 1};
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}
     (%i2) map (rat, %);
                                   2
     (%o2)/R/                    {x  - 1}

   Para remover redundâncias de outros conjuntos, você pode precisar
usar outras funções de simplificação.  Aqui está um exemplo que usa
'trigsimp':

     (%i1) {1, cos(x)^2 + sin(x)^2};
                                 2         2
     (%o1)                {1, sin (x) + cos (x)}
     (%i2) map (trigsimp, %);
     (%o2)                          {1}

   Um conjunto esta'simplificado quando seus elementos não são
redundantes e o conjunto está ordenado.  A versão corrente das funções
de conjunto usam a função do Máxima 'orderlessp' para ordenar conjuntos;
odavia, versões futuras das funções de conjunto podem usar uma função de
ordenação diferente.

   Algumas operações sobre conjuntos, tais como substituições, forçam
automaticamente a uma re-simplificação; por exemplo,

     (%i1) s: {a, b, c}$
     (%i2) subst (c=a, s);
     (%o2)                        {a, b}
     (%i3) subst ([a=x, b=x, c=x], s);
     (%o3)                          {x}
     (%i4) map (lambda ([x], x^2), set (-1, 0, 1));
     (%o4)                        {0, 1}

   Maxima trata listas e conjuntos como objetos distintos; funções tais
como 'union' e 'intersection' reclamam se qualquer argumetno não for um
conjunto.  se você precisar aplicar uma função de conjunto a uma lista,
use a função 'setify' para converter essa lsita para um conjunto.  dessa
forma

     (%i1) union ([1, 2], {a, b});
     Function union expects a set, instead found [1,2]
      -- an error.  Quitting.  To debug this try debugmode(true);
     (%i2) union (setify ([1, 2]), {a, b});
     (%o2)                     {1, 2, a, b}

   Para extrair todos os elemetnos de conjunto de um conjunto 's' que
satisfazem um predicado 'f', use 'subset(s, f)'.  (Um predicado é um uma
função que avalia para os valores booleanos 'true'/'false'.)  Por
exemplo, para encontrar as equações em um dado conjunto que não depende
de uma variável 'z', use

     (%i1) subset ({x + y + z, x - y + 4, x + y - 5}, lambda ([e], freeof (z, e)));
     (%o1)               {- y + x + 4, y + x - 5}

   A seção *note Funções e Variáveis Definidas para Conjuntos:: passui
uma lista completa das funções de conjunto no Maxima.

38.1.2 Iterações entre Elementos de Conjuntos
---------------------------------------------

Existem dois camainhos para fazer iterações sobre elementos de
conjuntos.  Um caminho é usar 'map'; por exemplo:

     (%i1) map (f, {a, b, c});
     (%o1)                  {f(a), f(b), f(c)}

   O outro caminho é usar 'for <x> in <s> do'

     (%i1) s: {a, b, c};
     (%o1)                       {a, b, c}
     (%i2) for si in s do print (concat (si, 1));
     a1
     b1
     c1
     (%o2)                         done

   A função Maxima 'first' e 'rest' trabalham atualmente sobre
conjuntos.  Aplicada a um conjunto, 'first' retorna o primeiro elemento
mostrado de um conjunto; qual élemento que é mostrado pode ser
dependente da implementação.  Se 's' for um conjunto, então 'rest(s)' é
equivalente a 'disjoin(first(s), s)'.  Atualmente, existem outras
funções do Maxima que trabalham corretamente sobre conjuntos.  Em
futuras versões das funções de conjunto, 'first' e 'rest' podem vir a
funcionar diferentemente ou não completamente.

38.1.3 Erros
------------

As funções de conjunto usam a função Maxima 'orderlessp' para organizar
os elementos de cum conjunto e a função (a nível de Lisp) 'like' para
testar a igualdade entre elementos de conjuntos.  Ambas essas funções
possuem falhas conhecidas que podem se manifestar se você tentar usar
conjuntos com elementos que são listas ou matrizes que contenham
expressões na forma racional canônica (CRE). Um exemplo é

     (%i1) {[x], [rat (x)]};
     Maxima encountered a Lisp error:

       The value #:X1440 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

   Essa expressão faz com que o Maxima fique exitante com um erro (a
mensagem de erro depende de qual a versão do Lisp seu Maxima está
usando).  Outro exemplo é

     (%i1) setify ([[rat(a)], [rat(b)]]);
     Maxima encountered a Lisp error:

       The value #:A1440 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

   Essas falhas são causadas por falhas em 'orderlessp' e 'like'; elas
não são caudadas por falhas nas funções de conjunto.  Para ilustrar,
tente as expressões

     (%i1) orderlessp ([rat(a)], [rat(b)]);
     Maxima encountered a Lisp error:

       The value #:B1441 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.
     (%i2) is ([rat(a)] = [rat(a)]);
     (%o2)                         false

   Até que essas falhas sejam corrigidas, não construa conjuntos com com
elementos que sejam listas ou matrizes contendo expressões na forma
racional canônica (CRE); um conjunto com um elemento na forma CRE,
todavia, pode não ser um problema:

     (%i1) {x, rat (x)};
     (%o1)                          {x}

   A 'orderlessp' do Maxima possui outra falha que pode causr problemas
com funções de conjunto, sabidamente o predicado de ordenação
'orderlessp' é não transitivo.  o mais simples exemplo conhecido que
mostra isso é

     (%i1) q: x^2$
     (%i2) r: (x + 1)^2$
     (%i3) s: x*(x + 2)$
     (%i4) orderlessp (q, r);
     (%o4)                         true
     (%i5) orderlessp (r, s);
     (%o5)                         true
     (%i6) orderlessp (q, s);
     (%o6)                         false

   Essa falha pode causar problemas com todas as funções de conjutno bem
como com funções Maxima em geral.  É provável, mas não certo, que essa
falha possa ser evitada se todos os elementos do conjunto estiverem ou
na forma CRE ou tiverem sido simplificado usando 'ratsimp'.

   Os mecanismos 'orderless' e 'ordergreat' do Maxima são incompatíveis
com as funções de conjunto.  Se você rpecisar usar ou 'orderless' ou
'ordergreat', chame todas essas funções antes de construir quaisquer
conjuntos, e não chame 'unorder'.

   Se você encontrar alguma coisa que você pense ser uma falha em alguma
funçõ de conjunto, por favor relate isso para a base de dados de falhas
do Maxima.  Veja 'bug_report'.

38.1.4 Autores
--------------

Stavros Macrakis de Cambridge, Massachusetts e Barton Willis da
Universidade e Nebraska e Kearney (UNK) escreveram as fnções de conjunto
do Maxima e sua documentação.


File: maxima.info,  Node: Funções e Variáveis Definidas para Conjuntos,  Prev: Introdução a Conjuntos,  Up: Conjuntos

38.2 Funções e Variáveis Definidas para Conjuntos
=================================================

 -- Função: adjoin (<x>, <a>)

     Retorna a união do conjunto <a> com '{<x>}'.

     'adjoin' reclama se <a> não for um conjunto literal.

     'adjoin(<x>, <a>)' e 'union(set(<x>), <a>)' são equivalentes;
     todavia, 'adjoin' pode ser um pouco mais rápida que 'union'.

     Veja também 'disjoin'.

     Exemplos:

          (%i1) adjoin (c, {a, b});
          (%o1)                       {a, b, c}
          (%i2) adjoin (a, {a, b});
          (%o2)                        {a, b}

 -- Função: belln (<n>)

     Representa o n-ésimo número de Bell number.  'belln(n)' é o número
     de partições de um conjunto <n> elementos.

     Para inteiros não negativos <n>, 'belln(<n>)' simplifica para o
     n-ésimo número de Bell.  'belln' não simplifica para qualquer outro
     tipo de argumento.

     'belln' distribui sobre equações, listas, matrizes e conjuntos.

     Exemplos:

     'belln' aplicado a inteiros não negativos.

          (%i1) makelist (belln (i), i, 0, 6);
          (%o1)               [1, 1, 2, 5, 15, 52, 203]
          (%i2) is (cardinality (set_partitions ({})) = belln (0));
          (%o2)                         true
          (%i3) is (cardinality (set_partitions ({1, 2, 3, 4, 5, 6})) = belln (6));
          (%o3)                         true

     'belln' aplicado a argumentos que não são inteiros não negativos.

          (%i1) [belln (x), belln (sqrt(3)), belln (-9)];
          (%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]

 -- Função: cardinality (<a>)

     Retorna o número de elementos distintos do conjunto <a>.

     'cardinality' ignora elementos redundantes mesmo quando a
     simplificação está dessabilitada.

     Exemplos:

          (%i1) cardinality ({});
          (%o1)                           0
          (%i2) cardinality ({a, a, b, c});
          (%o2)                           3
          (%i3) simp : false;
          (%o3)                         false
          (%i4) cardinality ({a, a, b, c});
          (%o4)                           3

 -- Função: cartesian_product (<b_1>, ... , <b_n>)
     Retorna um conjunto de listas da forma '[<x_1>, ..., <x_n>]', onde
     <x_1>, ..., <x_n> são elementos dos conjuntos <b_1>, ...  , <b_n>,
     respectivamente.

     'cartesian_product' reclama se qualquer argumento não for um
     conjunto literal.

     Exemplos:

          (%i1) cartesian_product ({0, 1});
          (%o1)                      {[0], [1]}
          (%i2) cartesian_product ({0, 1}, {0, 1});
          (%o2)           {[0, 0], [0, 1], [1, 0], [1, 1]}
          (%i3) cartesian_product ({x}, {y}, {z});
          (%o3)                      {[x, y, z]}
          (%i4) cartesian_product ({x}, {-1, 0, 1});
          (%o4)              {[x, - 1], [x, 0], [x, 1]}

 -- Função: disjoin (<x>, <a>)
     Retorna o conjunto <a> sem o elemento <x>.  Se <x> não for um
     elemento de <a>, retorna <a> sem modificações.

     'disjoin' reclama se <a> não for um conjunto literal.

     'disjoin(<x>, <a>)', 'delete(<x>, <a>)', e 'setdifference(<a>,
     set(<x>))' são todos equivalentes.  Desses, 'disjoin' é geralmente
     mais rápido que os outros.

     Exemplos:

          (%i1) disjoin (a, {a, b, c, d});
          (%o1)                       {b, c, d}
          (%i2) disjoin (a + b, {5, z, a + b, %pi});
          (%o2)                      {5, %pi, z}
          (%i3) disjoin (a - b, {5, z, a + b, %pi});
          (%o3)                  {5, %pi, b + a, z}

 -- Função: disjointp (<a>, <b>)
     Retorna 'true' se e somente se os conjuntos <a> e <b> forem
     disjuntos.

     'disjointp' reclama se ou <a> ou <b> não forem conjuntos literais.

     Exemplos:

          (%i1) disjointp ({a, b, c}, {1, 2, 3});
          (%o1)                         true
          (%i2) disjointp ({a, b, 3}, {1, 2, 3});
          (%o2)                         false

 -- Função: divisors (<n>)

     Representa o conjunto dos divisores de <n>.

     'divisors(<n>)' simplifica para um conjunto de inteiros quando <n>
     for um inteiro não nulo.  O cojunto dos divisores inclui os
     elementos 1 e <n>.  Os divisores de um inteiro negativo são os
     divisores de seu valor absoluto.

     'divisors' distribui sobre equações, listas, matrizes, e conjuntos.

     Exemplos:

     Podemos verificar que 28 é um número perfeito: a adição de seus
     divisores (exceto o próprio 28) é 28.

          (%i1) s: divisors(28);
          (%o1)                 {1, 2, 4, 7, 14, 28}
          (%i2) lreduce ("+", args(s)) - 28;
          (%o2)                          28

     'divisors' é uma função de simplificação.  Substituindo 8 por 'a'
     em 'divisors(a)' retorna os divisores sem fazer a reavaliação de
     'divisors(8)'.

          (%i1) divisors (a);
          (%o1)                      divisors(a)
          (%i2) subst (8, a, %);
          (%o2)                     {1, 2, 4, 8}

     'divisors' distribui sobre equações, listas, matrizes, e conjuntos.

          (%i1) divisors (a = b);
          (%o1)               divisors(a) = divisors(b)
          (%i2) divisors ([a, b, c]);
          (%o2)        [divisors(a), divisors(b), divisors(c)]
          (%i3) divisors (matrix ([a, b], [c, d]));
                            [ divisors(a)  divisors(b) ]
          (%o3)             [                          ]
                            [ divisors(c)  divisors(d) ]
          (%i4) divisors ({a, b, c});
          (%o4)        {divisors(a), divisors(b), divisors(c)}

 -- Função: elementp (<x>, <a>)
     Retorna 'true' se e somente se <x> for um elemento do conjunto <a>.

     'elementp' reclama se <a> não for um conjunto literal.

     Exemplos:

          (%i1) elementp (sin(1), {sin(1), sin(2), sin(3)});
          (%o1)                         true
          (%i2) elementp (sin(1), {cos(1), cos(2), cos(3)});
          (%o2)                         false

 -- Função: emptyp (<a>)
     Retorna 'true' se e somente se <a> for o conjunto vazio ou a lista
     vazia.

     Exemplos:

          (%i1) map (emptyp, [{}, []]);
          (%o1)                     [true, true]
          (%i2) map (emptyp, [a + b, {{}}, %pi]);
          (%o2)                 [false, false, false]

 -- Função: equiv_classes (<s>, <F>)
     Retorna um conjunto das classes de equivalências do conjunto <s>
     com relação à relação de equivalência <F>.

     <F> é uma função de duas variáveis definida sobre o produto
     cartesiano <s> por <s>.  O valor de retorno de <F> é ou 'true' ou
     'false', ou uma expressão <expr> tal que 'is(<expr>)' é ou 'true'
     ou 'false'.

     Quando <F> nõ for um relação de equivalência, 'equiv_classes'
     aceita sem reclamação, mas o resultado é geralmente incorreto nesse
     caso.

     Exemplos:

     A relação de equivalência é uma expressão lambda a qual retorna
     'true' ou 'false'.

          (%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, lambda ([x, y], is (equal (x, y))));
          (%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}

     A relação de equivalência é o nome de uma função relacional que
     avalia para 'true' ou 'false'.

          (%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, equal);
          (%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}

     As classes de equivalência são números que diferem por um multiplo
     de 3.

          (%i1) equiv_classes ({1, 2, 3, 4, 5, 6, 7}, lambda ([x, y], remainder (x - y, 3) = 0));
          (%o1)              {{1, 4, 7}, {2, 5}, {3, 6}}

 -- Função: every (<f>, <s>)
 -- Função: every (<f>, <L_1>, ..., <L_n>)

     Retorna 'true' se o predicado <f> for 'true' para todos os
     argumentos fornecidos.

     Dado um conjunto como sgundo argumento, 'every(<f>, <s>)' retorna
     'true' se 'is(<f>(<a_i>))' retornar 'true' para todos os <a_i> em
     <s>.  'every' pode ou não avaliar <f> para todos os <a_i> em <s>.
     Uma vez que conjuntos são desordenados, 'every' pode avaliar
     '<f>(<a_i>)' em qualquer ordem.

     Dada uma ou mais listas como argumentos, 'every(<f>, <L_1>, ...,
     <L_n>)' retorna 'true' se 'is(<f>(<x_1>, ..., <x_n>))' retornar
     'true' para todos os <x_1>, ..., <x_n> em <L_1>, ..., <L_n>,
     respectivamente.  'every' pode ou não avaliar <f> para toda
     combinação <x_1>, ..., <x_n>.  'every' avalia listas na ordem de
     incremento do índice.

     Dado um conjunto vazio '{}' ou uma lista vazia '[]' como
     argumentos, 'every' retorna 'false'.

     Quando o sinalizador global 'maperror' for 'true', todas as listas
     <L_1>, ..., <L_n> devem ter o mesmo comprimento.  Quando 'maperror'
     for 'false', argumentos listas são efetivamente truncados para o
     comprimento da menor lista.

     Retorna valores do predicado <f> que avaliam (via 'is') para alguma
     coisa outra que não 'true' ou 'false' são governados através do
     sinalizador global 'prederror'.  Quando 'prederror' for 'true',
     tais valores são tratados como 'false', e o valor de retorno de
     'every' é 'false'.  Quando 'prederror' for 'false', tais valores
     são tratados como 'unknown', e o valor de retorno de 'every' é
     'unknown'.

     Exemplos:

     'every' aplicada a um conjunto simples.  O predicado é uma função
     de um argumento.

          (%i1) every (integerp, {1, 2, 3, 4, 5, 6});
          (%o1)                         true
          (%i2) every (atom, {1, 2, sin(3), 4, 5 + y, 6});
          (%o2)                         false

     'every' aplicada a duas listas.  O predicado é uma função de dois
     argumentos.

          (%i1) every ("=", [a, b, c], [a, b, c]);
          (%o1)                         true
          (%i2) every ("#", [a, b, c], [a, b, c]);
          (%o2)                         false

     Retorna valores do predicado <f> que avalia para alguma coisa outra
     que não 'true' ou 'false' são governados por meio do sinalizador
     global 'prederror'.

          (%i1) prederror : false;
          (%o1)                         false
          (%i2) map (lambda ([a, b], is (a < b)), [x, y, z], [x^2, y^2, z^2]);
          (%o2)              [unknown, unknown, unknown]
          (%i3) every ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o3)                        unknown
          (%i4) prederror : true;
          (%o4)                         true
          (%i5) every ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o5)                         false

 -- Função: extremal_subset (<s>, <f>, max)
 -- Função: extremal_subset (<s>, <f>, min)

     Retorna o subconjunto de <s> para o qual a função <f> toma valore
     máximos ou mínimos.

     'extremal_subset(<s>, <f>, max)' retorna o subconjunto do conjunto
     ou lista <s> para os quais a função real <f> assume valor maximo.

     'extremal_subset(<s>, <f>, min)' retorna o subconjuno do conjunto
     ou lista <s> para a qual a função real <f> assume valor mínimo.

     Exemplos:

          (%i1) extremal_subset ({-2, -1, 0, 1, 2}, abs, max);
          (%o1)                       {- 2, 2}
          (%i2) extremal_subset ({sqrt(2), 1.57, %pi/2}, sin, min);
          (%o2)                       {sqrt(2)}

 -- Função: flatten (<expr>)

     Recebe argumentos de subexpressões que possuem o mesmo operator
     como <expr> e constrói uma expressão a partir desses argumentos
     coletados.

     subexpressões nas quais o operador é diferente do operador
     principal de 'expr' são copiadas sem modificação, mesmo se elas, in
     turn, contiverem a mesma subexpressão na qual o operador seja o
     mesmo que em 'expr'.

     Pode ser possível para 'flatten' construir expressões nas quais o
     número de argumentos difira dos argumentos declarados para um
     operador; isso pode provocar uma mensagem de erro do simplificador
     ou do avaliador.  'flatten' não tenta detectar tais situações.

     Expressões com representações especiais, por exemplo, expressãoes
     racionais canônicas (CRE), não podem usar a função 'flatten';
     nesses casos, 'flatten' retorna seus argumentos sem modificação.

     Exemplos:

     Aplicado a uma lista, 'flatten' reune todos os elementos de lista
     que são listas.

          (%i1) flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
          (%o1)            [a, b, c, d, e, f, g, h, i, j]

     Aplicado a um conjunto, 'flatten' reune todos os elementos de
     conjunto que são conjuntos.

          (%i1) flatten ({a, {b}, {{c}}});
          (%o1)                       {a, b, c}
          (%i2) flatten ({a, {[a], {a}}});
          (%o2)                       {a, [a]}

     'flatten' é similar ao efeito de declarar o operador principal para
     ser enário.  Todavia, 'flatten' não faz efeito sobre subexpressões
     que possuem um operador diferente do operador principal, enquanto
     uma declaração enária faz efeito.

          (%i1) expr: flatten (f (g (f (f (x)))));
          (%o1)                     f(g(f(f(x))))
          (%i2) declare (f, nary);
          (%o2)                         done
          (%i3) ev (expr);
          (%o3)                      f(g(f(x)))

     'flatten' trata funções subscritas da mesma forma que qualquer
     outro operador.

          (%i1) flatten (f[5] (f[5] (x, y), z));
          (%o1)                      f (x, y, z)
                                      5

     Pode ser possível para 'flatten' construir expressões nas quais o
     número de argumentos difira dos argumentos declarados para um
     operador;

          (%i1) 'mod (5, 'mod (7, 4));
          (%o1)                   mod(5, mod(7, 4))
          (%i2) flatten (%);
          (%o2)                     mod(5, 7, 4)
          (%i3) ''%, nouns;
          Wrong number of arguments to mod
           -- an error.  Quitting.  To debug this try debugmode(true);

 -- Função: full_listify (<a>)
     Substitui todo oeradr de conjutno em <a> por um operadro de lista,
     e retorna o resultado.  'full_listify' substitui operadores de
     conjunto em subexpressões restantes, mesmo se o operadro principal
     não for conjunto ('set').

     'listify' substitui somente o operador principal.

     Exemplos:

          (%i1) full_listify ({a, b, {c, {d, e, f}, g}});
          (%o1)               [a, b, [c, [d, e, f], g]]
          (%i2) full_listify (F (G ({a, b, H({c, d, e})})));
          (%o2)              F(G([a, b, H([c, d, e])]))

 -- Função: fullsetify (<a>)
     Quando <a> for uma lista, substitui o operador de lista por um
     operador de conjunto, e aplica 'fullsetify' a cada elemento que for
     um conjunto.  Quando <a> não for uma lista, essa não lista é
     retornada em sua forma original e sem modificações.

     'setify' substitui somente o operador principal.

     Exemplos:

     Na linha (%o2), o argumento de 'f' não é convertido para um
     conjunto porque o operador principal de 'f([b])' não é uma lista.

          (%i1) fullsetify ([a, [a]]);
          (%o1)                       {a, {a}}
          (%i2) fullsetify ([a, f([b])]);
          (%o2)                      {a, f([b])}

 -- Função: identity (<x>)

     Retorna <x> para qualquer argumento <x>.

     Exemplos:

     'identity' pode ser usado como um predicado quando os argumentos
     forem valores Booleanos.

          (%i1) every (identity, [true, true]);
          (%o1)                         true

 -- Função: integer_partitions (<n>)
 -- Função: integer_partitions (<n>, <len>)

     Retorna partições inteiras de <n>, isto é, listas de inteiros cuja
     soma dos elementos de cada lista é <n>.

     'integer_partitions(<n>)' retorna o conjunto de todas as partições
     do inteiro <n>.  Cada partição é uma lista ordenada do maior para o
     menor.

     'integer_partitions(<n>, <len>)' retorna todas as partições que
     possuem comprimento <len> ou menor; nesse caso, zeros são anexado
     ao final de cada partição de comprimento menor que <len> terms to
     make each partition have exactly <len> terms.  Each partition is a
     list sorted from greatest to least.

     Uma lista [a_1, ..., a_m] é uma partição de inteiros não negativos
     n quando (1) cada a_i é um inteiro não nulo, e (2) a_1 + ... + a_m
     = n. Dessa forma 0 não tem partiçãoes.

     Exemplos:

          (%i1) integer_partitions (3);
          (%o1)               {[1, 1, 1], [2, 1], [3]}
          (%i2) s: integer_partitions (25)$
          (%i3) cardinality (s);
          (%o3)                         1958
          (%i4) map (lambda ([x], apply ("+", x)), s);
          (%o4)                         {25}
          (%i5) integer_partitions (5, 3);
          (%o5) {[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]}
          (%i6) integer_partitions (5, 2);
          (%o6)               {[3, 2], [4, 1], [5, 0]}

     Para encontrar todas as partições que satisfazem uma condição, use
     a função 'subset'; aqui está um exemplo que encontra todas as
     partições de 10 cujos elementos da lista são números primos.

          (%i1) s: integer_partitions (10)$
          (%i2) cardinality (s);
          (%o2)                          42
          (%i3) xprimep(x) := integerp(x) and (x > 1) and primep(x)$
          (%i4) subset (s, lambda ([x], every (xprimep, x)));
          (%o4) {[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]}

 -- Função: intersect (<a_1>, ..., <a_n>)

     'intersect' é o mesmo que 'intersection', como veremos.

 -- Função: intersection (<a_1>, ..., <a_n>)
     Retorna um conjunto contendo os elementos que são comuns aos
     conjuntos <a_1> até <a_n>.

     'intersection' reclama se qualquer argumento não for um conjunto
     literal.

     Exemplos:

          (%i1) S_1 : {a, b, c, d};
          (%o1)                     {a, b, c, d}
          (%i2) S_2 : {d, e, f, g};
          (%o2)                     {d, e, f, g}
          (%i3) S_3 : {c, d, e, f};
          (%o3)                     {c, d, e, f}
          (%i4) S_4 : {u, v, w};
          (%o4)                       {u, v, w}
          (%i5) intersection (S_1, S_2);
          (%o5)                          {d}
          (%i6) intersection (S_2, S_3);
          (%o6)                       {d, e, f}
          (%i7) intersection (S_1, S_2, S_3);
          (%o7)                          {d}
          (%i8) intersection (S_1, S_2, S_3, S_4);
          (%o8)                          {}

 -- Função: kron_delta (<x>, <y>)

     Representa a função delta de Kronecker.

     'kron_delta' simplifica para 1 quando <x> e <y> forem identicos ou
     demonstadamente equivalentes, e simplifica para 0 quando <x> e <y>
     demonstradamente não equivalentes.  De outra forma, se não for
     certo que <x> e <y> são equivalentes, e 'kron_delta' simplifica
     para uma expressão substantiva.  'kron_delta' implementa uma
     política de segurança para expressões em ponto flutuante: se a
     diferença '<x> - <y>' for um número em ponto flutuante,
     'kron_delta' simplifica para uma expressão substantiva quando <x>
     for aparentemente equivalente a <y>.

     Specificamente, 'kron_delta(<x>, <y>)' simplifica para 1 quando
     'is(x = y)' for 'true'.  'kron_delta' também simplifica para 1
     quando 'sign(abs(<x> - <y>))' for 'zero' e '<x> - <y>' não for um
     número em ponto flutuante (e também não for um número de precisão
     simples em ponto flutuante e também não for um número de precisão
     dupla em poto flutuante, isto é, não for um bigfloat).
     'kron_delta' simplifica para 0 quando 'sign(abs(<x> - <y>))' for
     'pos'.

     De outra forma, 'sign(abs(<x> - <y>))' é alguma coisa outra que não
     'pos' ou 'zero', ou se for 'zero' e '<x> - <y>' for umnúmero em
     ponto flutuante.  Nesses casos, 'kron_delta' retorna um expressão
     substantiva.

     'kron_delta' é declarada para ser simétrica.  Isto é,
     'kron_delta(<x>, <y>)' é igual a 'kron_delta(<y>, <x>)'.

     Exemplos:

     Os argumentos de 'kron_delta' são identicos.  'kron_delta'
     simplifica para 1.

          (%i1) kron_delta (a, a);
          (%o1)                           1
          (%i2) kron_delta (x^2 - y^2, x^2 - y^2);
          (%o2)                           1
          (%i3) float (kron_delta (1/10, 0.1));
          (%o3)                           1

     Os argumentos de 'kron_delta' são equivalentes, e a diferença entre
     eles não é um número em ponto flutuante.  'kron_delta' simplifica
     para 1.

          (%i1) assume (equal (x, y));
          (%o1)                     [equal(x, y)]
          (%i2) kron_delta (x, y);
          (%o2)                           1

     Os argumentos de 'kron_delta' não são equivalentes.  'kron_delta'
     simplifica para 0.

          (%i1) kron_delta (a + 1, a);
          (%o1)                           0
          (%i2) assume (a > b)$
          (%i3) kron_delta (a, b);
          (%o3)                           0
          (%i4) kron_delta (1/5, 0.7);
          (%o4)                           0

     Os argumentos de 'kron_delta' podem ou não serem equivalentes.
     'kron_delta' simplifica para uma expressão substantiva.

          (%i1) kron_delta (a, b);
          (%o1)                   kron_delta(a, b)
          (%i2) assume(x >= y)$
          (%i3) kron_delta (x, y);
          (%o3)                   kron_delta(x, y)

     Os argumentos de 'kron_delta' são equivalentes, mas a diferença
     entre eles é um número em ponto flutuante.  'kron_delta' simplifica
     para uma expressão substantiva.

          (%i1) 1/4 - 0.25;
          (%o1)                          0.0
          (%i2) 1/10 - 0.1;
          (%o2)                          0.0
          (%i3) 0.25 - 0.25b0;
          Warning:  Float to bigfloat conversion of 0.25
          (%o3)                         0.0b0
          (%i4) kron_delta (1/4, 0.25);
                                            1
          (%o4)                  kron_delta(-, 0.25)
                                            4
          (%i5) kron_delta (1/10, 0.1);
                                            1
          (%o5)                  kron_delta(--, 0.1)
                                            10
          (%i6) kron_delta (0.25, 0.25b0);
          Warning:  Float to bigfloat conversion of 0.25
          (%o6)               kron_delta(0.25, 2.5b-1)

     'kron_delta' é simétrica.

          (%i1) kron_delta (x, y);
          (%o1)                   kron_delta(x, y)
          (%i2) kron_delta (y, x);
          (%o2)                   kron_delta(x, y)
          (%i3) kron_delta (x, y) - kron_delta (y, x);
          (%o3)                           0
          (%i4) is (equal (kron_delta (x, y), kron_delta (y, x)));
          (%o4)                         true
          (%i5) is (kron_delta (x, y) = kron_delta (y, x));
          (%o5)                         true

 -- Função: listify (<a>)

     Retorna uma lista contendo os elementos de <a> quando <a> for um
     conjunto.  De outra forma, 'listify' retorna <a>.

     'full_listify' substitui todos os operadores de conjunto em <a> por
     operadores de lista.

     Exemplos:

          (%i1) listify ({a, b, c, d});
          (%o1)                     [a, b, c, d]
          (%i2) listify (F ({a, b, c, d}));
          (%o2)                    F({a, b, c, d})

 -- Função: lreduce (<F>, <s>)
 -- Função: lreduce (<F>, <s>, <s_0>)

     Extende a função de dois operadores <F> para uma função de 'n'
     operadores usando composição, onde <s> é uma lista.

     'lreduce(<F>, <s>)' returns 'F(... F(F(s_1, s_2), s_3), ... s_n)'.
     Quando o argumento opcional <s_0> estiver presente, o resultado é
     equivalente a 'lreduce(<F>, cons(<s_0>, <s>))'.

     A função <F> é primeiramente aplicada à lista de elementos leftmost
     - mais à esquerda, daí o nome "lreduce".

     Veja também 'rreduce', 'xreduce', e 'tree_reduce'.

     Exemplos:

     'lreduce' sem o argumento opcional.

          (%i1) lreduce (f, [1, 2, 3]);
          (%o1)                     f(f(1, 2), 3)
          (%i2) lreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(f(f(1, 2), 3), 4)

     'lreduce' com o argumento opcional.

          (%i1) lreduce (f, [1, 2, 3], 4);
          (%o1)                  f(f(f(4, 1), 2), 3)

     'lreduce' aplicada a operadores de dois argumentos internos (já
     definidos por padrão) do Maxima.  '/' é o operador de divisão.

          (%i1) lreduce ("^", args ({a, b, c, d}));
                                         b c d
          (%o1)                       ((a ) )
          (%i2) lreduce ("/", args ({a, b, c, d}));
                                          a
          (%o2)                         -----
                                        b c d

 -- Função: makeset (<expr>, <x>, <s>)

     Retorna um conjunto com elementos gerados a partir da expressão
     <expr>, onde <x> é uma lista de variáveis em <expr>, e <s>é um
     conjunto ou lista de listas.  Para gerar cada elemento do conjunto,
     <expr> é avaliada com as variáveis <x> paralelamente a um elemento
     de <s>.

     Cada elemento de <s> deve ter o mesmo comprimento que <x>.  A lista
     de variáveis <x> deve ser uma lista de símbolos, sem subscritos.
     Mesmo se existir somente um símbolo, <x> deve ser uma lista de um
     elemento, e cada elemento de <s> deve ser uma lista de um elemento.

     Veja também 'makelist'.

     Exemplos:

          (%i1) makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
                                     1  2  3  4
          (%o1)                     {-, -, -, -}
                                     a  b  c  d
          (%i2) S : {x, y, z}$
          (%i3) S3 : cartesian_product (S, S, S);
          (%o3) {[x, x, x], [x, x, y], [x, x, z], [x, y, x], [x, y, y],
          [x, y, z], [x, z, x], [x, z, y], [x, z, z], [y, x, x],
          [y, x, y], [y, x, z], [y, y, x], [y, y, y], [y, y, z],
          [y, z, x], [y, z, y], [y, z, z], [z, x, x], [z, x, y],
          [z, x, z], [z, y, x], [z, y, y], [z, y, z], [z, z, x],
          [z, z, y], [z, z, z]}
          (%i4) makeset (i + j + k, [i, j, k], S3);
          (%o4) {3 x, 3 y, y + 2 x, 2 y + x, 3 z, z + 2 x, z + y + x,
                                                 z + 2 y, 2 z + x, 2 z + y}
          (%i5) makeset (sin(x), [x], {[1], [2], [3]});
          (%o5)               {sin(1), sin(2), sin(3)}

 -- Função: moebius (<n>)

     Representa a função de Moebius.

     Quando <n> for o produto de k primos distintos, 'moebius(<n>)'
     simplifica para (-1)^k; quando <n> = 1, simplifica para 1; e
     simplifica para 0 para todos os outros inteiros positivos.

     'moebius' distribui sobre equações, listas, matrizes, e conjuntos.

     Exemplos:

          (%i1) moebius (1);
          (%o1)                           1
          (%i2) moebius (2 * 3 * 5);
          (%o2)                          - 1
          (%i3) moebius (11 * 17 * 29 * 31);
          (%o3)                           1
          (%i4) moebius (2^32);
          (%o4)                           0
          (%i5) moebius (n);
          (%o5)                      moebius(n)
          (%i6) moebius (n = 12);
          (%o6)                    moebius(n) = 0
          (%i7) moebius ([11, 11 * 13, 11 * 13 * 15]);
          (%o7)                      [- 1, 1, 1]
          (%i8) moebius (matrix ([11, 12], [13, 14]));
                                     [ - 1  0 ]
          (%o8)                      [        ]
                                     [ - 1  1 ]
          (%i9) moebius ({21, 22, 23, 24});
          (%o9)                      {- 1, 0, 1}

 -- Função: multinomial_coeff (<a_1>, ..., <a_n>)
 -- Função: multinomial_coeff ()

     Retorna o coeficiente multinomial.

     Quando cada <a_k> for um inteiro não negativo, o coeficiente
     multinomial fornece o número de formas possíveis de colocar '<a_1>
     + ... + <a_n>' objetos distintos em n caixas com <a_k> elementos na
     k'ésima caixa.  Em geral, 'multinomial_coeff (<a_1>, ..., <a_n>)'
     avalia para '(<a_1> + ... + <a_n>)!/(<a_1>! ... <a_n>!)'.

     'multinomial_coeff()' (sem argumentos) avalia para 1.

     'minfactorial' pode estar apta a simplificar o valor retornado por
     'multinomial_coeff'.

     Exemplos:

          (%i1) multinomial_coeff (1, 2, x);
                                      (x + 3)!
          (%o1)                       --------
                                        2 x!
          (%i2) minfactorial (%);
                               (x + 1) (x + 2) (x + 3)
          (%o2)                -----------------------
                                          2
          (%i3) multinomial_coeff (-6, 2);
                                       (- 4)!
          (%o3)                       --------
                                      2 (- 6)!
          (%i4) minfactorial (%);
          (%o4)                          10

 -- Função: num_distinct_partitions (<n>)
 -- Função: num_distinct_partitions (<n>, list)

     Retorna o n;umero de partições de inteiros distintos de <n> quando
     <n> for um inteiro não negativo.  De outra forma,
     'num_distinct_partitions' retorna uma expressão substantiva.

     'num_distinct_partitions(<n>, list)' retorna uma lista do número de
     partições distintas de 1, 2, 3, ..., <n>.

     Uma partição distinta de <n> é uma lista de inteiros positivos
     distintos k_1, ..., k_m tais que <n> = k_1 + ... + k_m.

     Exemplos:

          (%i1) num_distinct_partitions (12);
          (%o1)                          15
          (%i2) num_distinct_partitions (12, list);
          (%o2)      [1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 12, 15]
          (%i3) num_distinct_partitions (n);
          (%o3)              num_distinct_partitions(n)

 -- Função: num_partitions (<n>)
 -- Função: num_partitions (<n>, list)

     Retorna o número das partições inteiras de <n> quando <n> for um
     inteiro não negativo.  De outra forma, 'num_partitions' retorna uma
     expressão substantiva.

     'num_partitions(<n>, list)' retorna uma lista do número de
     partições inteiras de 1, 2, 3, ..., <n>.

     Para um inteiro não negativo <n>, 'num_partitions(<n>)' é igual a
     'cardinality(integer_partitions(<n>))'; todavia, 'num_partitions'
     não constrói atualmente o conjunto das partições, nesse sentido
     'num_partitions' é mais rápida.

     Exemplos:

          (%i1) num_partitions (5) = cardinality (integer_partitions (5));
          (%o1)                         7 = 7
          (%i2) num_partitions (8, list);
          (%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
          (%i3) num_partitions (n);
          (%o3)                   num_partitions(n)

 -- Função: partition_set (<a>, <f>)

     Partições do conjunto <a> que satisfazem o predicado <f>.

     'partition_set' retorna uma lista de dois conjuntos.  O primeiro
     conjunto compreende os elementos de <a> para os quais <f> avalia
     para 'false', e o segundo conjunto compreende quaisquer outros
     elementos de <a>.  'partition_set' não aplica 'is' ao valor de
     retorno de <f>.

     'partition_set' reclama se <a> não for um conjunto literal.

     Veja também 'subset'.

     Exemplos:

          (%i1) partition_set ({2, 7, 1, 8, 2, 8}, evenp);
          (%o1)                   [{1, 7}, {2, 8}]
          (%i2) partition_set ({x, rat(y), rat(y) + z, 1}, lambda ([x], ratp(x)));
          (%o2)/R/              [{1, x}, {y, y + z}]

 -- Função: permutations (<a>)

     Retorna um conjunto todas as permutações distintas dos elementos da
     lista ou do conjunto <a>.  Cada permutação é uma lista, não um
     conjunto.

     Quando <a> for uma lista, elementos duplicados de <a> são incluídos
     nas permutações.

     'permutations' reclama se <a> não for um conjunto literal ou uma
     lista literal.

     Veja também 'random_permutation'.

     Exemplos:

          (%i1) permutations ([a, a]);
          (%o1)                       {[a, a]}
          (%i2) permutations ([a, a, b]);
          (%o2)           {[a, a, b], [a, b, a], [b, a, a]}

 -- Função: powerset (<a>)
 -- Função: powerset (<a>, <n>)

     Retorna o conjunto de todos os dubconjuntos de <a>, ou um
     subconjunto de <a>.

     'powerset(<a>)' retorna o conjunto de todos os subconjuntos do
     conjunto <a>.  'powerset(<a>)' tem '2^cardinality(<a>)' elementos.

     'powerset(<a>, <n>)' retorna o conjunto de todos os subconjuntos de
     <a> que possuem cardinalidade <n>.

     'powerset' reclama se <a> não for um conjunto literal, ou se <n>
     não for um inteiro não negativo.

     Exemplos:

          (%i1) powerset ({a, b, c});
          (%o1) {{}, {a}, {a, b}, {a, b, c}, {a, c}, {b}, {b, c}, {c}}
          (%i2) powerset ({w, x, y, z}, 4);
          (%o2)                    {{w, x, y, z}}
          (%i3) powerset ({w, x, y, z}, 3);
          (%o3)     {{w, x, y}, {w, x, z}, {w, y, z}, {x, y, z}}
          (%i4) powerset ({w, x, y, z}, 2);
          (%o4)   {{w, x}, {w, y}, {w, z}, {x, y}, {x, z}, {y, z}}
          (%i5) powerset ({w, x, y, z}, 1);
          (%o5)                 {{w}, {x}, {y}, {z}}
          (%i6) powerset ({w, x, y, z}, 0);
          (%o6)                         {{}}

 -- Função: random_permutation (<a>)

     Retorna uma permutação aleatória do conjunto ou da lista <a>, como
     construído pelo algorítimo de embaralhar desenvolvido por Knuth.

     O valor de retorno é uma nova lista, que é diferente da
     lista/conjunto original podendo inclusive ser a propria lista
     repetida.  Todavia, os elementos do argumento não são copiados.

     Exemplos:

          (%i1) random_permutation ([a, b, c, 1, 2, 3]);
          (%o1)                  [c, 1, 2, 3, a, b]
          (%i2) random_permutation ([a, b, c, 1, 2, 3]);
          (%o2)                  [b, 3, 1, c, a, 2]
          (%i3) random_permutation ({x + 1, y + 2, z + 3});
          (%o3)                 [y + 2, z + 3, x + 1]
          (%i4) random_permutation ({x + 1, y + 2, z + 3});
          (%o4)                 [x + 1, y + 2, z + 3]

 -- Função: rreduce (<F>, <s>)
 -- Função: rreduce (<F>, <s>, <s_{n + 1}>)

     Extende a função de dois argumentos <F> para uma função de <n>
     argumentos usando composição de funções, onde <s> é uma lista.

     'rreduce(<F>, <s>)' retorna 'F(s_1, ... F(s_{n - 2}, F(s_{n - 1},
     s_n)))'.  Quando o argumetno opcional <s_{n + 1}> estiver presente,
     o resultado é equivalente a 'rreduce(<F>, endcons(<s_{n + 1}>,
     <s>))'.

     A função <F> é primeiro aplicada à lista de elementos mais à
     direita - rightmost, daí o nome "rreduce".

     Veja também 'lreduce', 'tree_reduce', e 'xreduce'.

     Exemplos:

     'rreduce' sem o argumento opcional.

          (%i1) rreduce (f, [1, 2, 3]);
          (%o1)                     f(1, f(2, 3))
          (%i2) rreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(1, f(2, f(3, 4)))

     'rreduce' com o argumetno opcional.

          (%i1) rreduce (f, [1, 2, 3], 4);
          (%o1)                  f(1, f(2, f(3, 4)))

     'rreduce' aplicada a operadores de dois argumentos internos (
     definidos por padrão) ao Maxima.  '/' é o operadro de divisão.

          (%i1) rreduce ("^", args ({a, b, c, d}));
                                           d
                                          c
                                         b
          (%o1)                         a
          (%i2) rreduce ("/", args ({a, b, c, d}));
                                         a c
          (%o2)                          ---
                                         b d

 -- Função: setdifference (<a>, <b>)

     Retorna um conjunto contendo os elementos no conjunto <a> que não
     estãono conjunto <b>.

     'setdifference' reclama se ou <a> ou <b> não for um conjunto
     literal.

     Exemplos:

          (%i1) S_1 : {a, b, c, x, y, z};
          (%o1)                  {a, b, c, x, y, z}
          (%i2) S_2 : {aa, bb, c, x, y, zz};
          (%o2)                 {aa, bb, c, x, y, zz}
          (%i3) setdifference (S_1, S_2);
          (%o3)                       {a, b, z}
          (%i4) setdifference (S_2, S_1);
          (%o4)                     {aa, bb, zz}
          (%i5) setdifference (S_1, S_1);
          (%o5)                          {}
          (%i6) setdifference (S_1, {});
          (%o6)                  {a, b, c, x, y, z}
          (%i7) setdifference ({}, S_1);
          (%o7)                          {}

 -- Função: setequalp (<a>, <b>)

     Retorna 'true' se os conjuntos <a> e <b> possuirem o mesmo número
     de elementos e 'is(<x> = <y>)' for 'true' para 'x' nos elementos de
     <a> e 'y' nos elementos de <b>, considerados na ordem determinada
     por 'listify'.  De outra forma, 'setequalp' retorna 'false'.

     Exemplos:

          (%i1) setequalp ({1, 2, 3}, {1, 2, 3});
          (%o1)                         true
          (%i2) setequalp ({a, b, c}, {1, 2, 3});
          (%o2)                         false
          (%i3) setequalp ({x^2 - y^2}, {(x + y) * (x - y)});
          (%o3)                         false

 -- Função: setify (<a>)

     Constrói um conjunto de elementos a partir da lista <a>.  Elementos
     duplicados da lista <a> são apagados e os elementos são ordenados
     de acordo com o predicado 'orderlessp'.

     'setify' reclama se <a> não for uma lista literal.

     Exemplos:

          (%i1) setify ([1, 2, 3, a, b, c]);
          (%o1)                  {1, 2, 3, a, b, c}
          (%i2) setify ([a, b, c, a, b, c]);
          (%o2)                       {a, b, c}
          (%i3) setify ([7, 13, 11, 1, 3, 9, 5]);
          (%o3)                {1, 3, 5, 7, 9, 11, 13}

 -- Função: setp (<a>)

     Retorna 'true' se e somente se <a> for um conjunto na interpretação
     do Maxima.

     'setp' retorna 'true' para conjuntos não simplificados (isto é,
     conjuntos com elementos redundantes) e também para conjuntos
     simplificados.

     'setp' é equivalente à função do Maxima 'setp(a) := not atom(a) and
     op(a) = 'set'.

     Exemplos:

          (%i1) simp : false;
          (%o1)                         false
          (%i2) {a, a, a};
          (%o2)                       {a, a, a}
          (%i3) setp (%);
          (%o3)                         true

 -- Função: set_partitions (<a>)
 -- Função: set_partitions (<a>, <n>)

     Retorna o conjunto de todas as partições de <a>, ou um subconjunto
     daquele conjunto de partições.

     'set_partitions(<a>, <n>)' retorna um conjunto de todas as
     decomposições de <a> em <n> subconjutnos disjuntos não vazios.

     'set_partitions(<a>)' retorna o conjunto de todas as partições.

     'stirling2' retorna a cardinalidade de um conjuntode partições de
     um conjunto.

     Um conjunto de conjuntos P é uma partição de um conjunto S quando

       1. cada elemento de P é um conjunto não vazio,
       2. elementos distintos de P são disjuntos,
       3. a união dos elementos de P é igual a S.

     Exemplos:

     O conjunto vazio é uma partição de si mesmo, as ondições 1 e 2 são
     "vaziamente" verdadeiras.

          (%i1) set_partitions ({});
          (%o1)                         {{}}

     A cardinalidade do conjunto de partições de um conjunto pode ser
     encontrada usando 'stirling2'.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) cardinality(p) = stirling2 (6, 3);
          (%o3)                        90 = 90

     Cada elemento de 'p' pode ter <n> = 3 elementos; vamos verificar.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) map (cardinality, p);
          (%o3)                          {3}

     Finalmente, para cada elementos de 'p', a união de seus elementos
     possivelmente será igua a 's'; novamente vamos comprovar.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) map (lambda ([x], apply (union, listify (x))), p);
          (%o3)                 {{0, 1, 2, 3, 4, 5}}

 -- Função: some (<f>, <a>)
 -- Função: some (<f>, <L_1>, ..., <L_n>)

     Retorna 'true' se o predicado <f> for 'true' para um ou mais
     argumentos dados.

     Given one set as the second argument, 'some(<f>, <s>)' returns
     'true' if 'is(<f>(<a_i>))' returns 'true' for one or more <a_i> in
     <s>.  'some' may or may not evaluate <f> for all <a_i> in <s>.
     Since sets are unordered, 'some' may evaluate '<f>(<a_i>)' in any
     order.

     Dadas uma ou mais listas como argumentos, 'some(<f>, <L_1>, ...,
     <L_n>)' retorna 'true' se 'is(<f>(<x_1>, ..., <x_n>))' retornar
     'true' para um ou mais <x_1>, ..., <x_n> em <L_1>, ..., <L_n>,
     respectivamente.  'some' pode ou não avaliar <f> para algumas
     combinações <x_1>, ..., <x_n>.  'some' avalia listas na ordem do
     índice de incremento.

     Dado um conjunto vazio '{}' ou uma lista vazia '[]' como
     argumentos, 'some' retorna 'false'.

     Quando o sinalizador global 'maperror' for 'true', todas as listas
     <L_1>, ..., <L_n> devem ter obrigatóriamente comprimentos iguais.
     Quando 'maperror' for 'false', argumentos do tipo lista são
     efetivamente truncados para o comprimento da menor lista.

     Retorna o valor de um predicado <f> o qual avalia (por meio de
     'is') para alguma coisa outra que não 'true' ou 'false' e são
     governados pelo sinalizador global 'prederror'.  Quando 'prederror'
     for 'true', tais valores são tratados como 'false'.  Quando
     'prederror' for 'false', tais valores são tratados como 'unknown'
     (desconhecidos).

     Exemplos:

     'some' aplicado a um conjunto simples.  O predicado é uma função de
     um argumento.

          (%i1) some (integerp, {1, 2, 3, 4, 5, 6});
          (%o1)                         true
          (%i2) some (atom, {1, 2, sin(3), 4, 5 + y, 6});
          (%o2)                         true

     'some' aplicada a duas listas.  O predicado é uma função de dois
     argumentos.

          (%i1) some ("=", [a, b, c], [a, b, c]);
          (%o1)                         true
          (%i2) some ("#", [a, b, c], [a, b, c]);
          (%o2)                         false

     Retorna o valor do predicado <f> o qual avalia para alguma coisa
     que não 'true' ou 'false' e são governados através do sinalizador
     global 'prederror'.

          (%i1) prederror : false;
          (%o1)                         false
          (%i2) map (lambda ([a, b], is (a < b)), [x, y, z], [x^2, y^2, z^2]);
          (%o2)              [unknown, unknown, unknown]
          (%i3) some ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o3)                        unknown
          (%i4) some ("<", [x, y, z], [x^2, y^2, z + 1]);
          (%o4)                         true
          (%i5) prederror : true;
          (%o5)                         true
          (%i6) some ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o6)                         false
          (%i7) some ("<", [x, y, z], [x^2, y^2, z + 1]);
          (%o7)                         true

 -- Função: stirling1 (<n>, <m>)

     Representa o número de Stirling de primeiro tipo.

     Quando <n> e <m> forem não negativos inteiros, a magnitude de
     'stirling1 (<n>, <m>)' é o número de permutações de um conjunto com
     <n> elementos que possui <m> ciclos.  Para detalhes, veja Graham,
     Knuth e Patashnik Concrete Mathematics.  Maxima utiliza uma relação
     recursiva para definir 'stirling1 (<n>, <m>)' para <m> menor que 0;
     'stirling1' não é definida para <n> menor que 0 e para argumetnos
     não inteiros.

     'stirling1' é uma função de simplificação.  Maxima conhece as
     seguintes identidades:

       1. stirling1(0, n) = kron_delta(0, n) (Ref.  [1])
       2. stirling1(n, n) = 1 (Ref.  [1])
       3. stirling1(n, n - 1) = binomial(n, 2) (Ref.  [1])
       4. stirling1(n + 1, 0) = 0 (Ref.  [1])
       5. stirling1(n + 1, 1) = n! (Ref.  [1])
       6. stirling1(n + 1, 2) = 2^n - 1 (Ref.  [1])

     Essas identidades são aplicadas quando os argumentos forem inteiros
     literais ou símbolos declarados como inteiros, e o primeiro
     argumento for não negativo.  'stirling1' não simplififca para
     argumentos não inteiros.

     Referências:

     [1] Donald Knuth, The Art of Computer Programming, terceira edição,
     Volume 1, Seção 1.2.6, Equações 48, 49, e 50.

     Exemplos:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n, n);
          (%o3)                           1

     'stirling1' não simplifica para argumentos não inteiros.

          (%i1) stirling1 (sqrt(2), sqrt(2));
          (%o1)              stirling1(sqrt(2), sqrt(2))

     Maxima aplica identidades a 'stirling1'.

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n + 1, n);
                                      n (n + 1)
          (%o3)                       ---------
                                          2
          (%i4) stirling1 (n + 1, 1);
          (%o4)                          n!

 -- Função: stirling2 (<n>, <m>)

     Representa o número de Stirling de segundo tipo.

     Quando <n> e <m> forem inteiros não negativos, 'stirling2 (<n>,
     <m>)' é o número de maneiras através dos quais um conjunto com
     cardinalidade <n> pode ser particionado em <m> subconjuntos
     disjuntos.  Maxima utiliza uma relação recursiva para definir
     'stirling2 (<n>, <m>)' para <m> menor que 0; 'stirling2' é
     indefinida para <n> menor que 0 e para argumentos não inteiros.

     'stirling2' é uma função de simplificação.  Maxima conhece as
     seguintes identidades.

       1. stirling2(0, n) = kron_delta(0, n) (Ref.  [1])
       2. stirling2(n, n) = 1 (Ref.  [1])
       3. stirling2(n, n - 1) = binomial(n, 2) (Ref.  [1])
       4. stirling2(n + 1, 1) = 1 (Ref.  [1])
       5. stirling2(n + 1, 2) = 2^n - 1 (Ref.  [1])
       6. stirling2(n, 0) = kron_delta(n, 0) (Ref.  [2])
       7. stirling2(n, m) = 0 when m > n (Ref.  [2])
       8. stirling2(n, m) = sum((-1)^(m - k) binomial(m k) k^n,i,1,m) /
          m! onde m e n são inteiros, e n é não negativo.  (Ref.  [3])

     Essas identidades são aplicadas quando os argumentos forem inteiros
     literais ou símbolos declarados como inteiros, e o primeiro
     argumento for não negativo.  'stirling2' não simplifica para
     argumentos não inteiros.

     Referências:

     [1] Donald Knuth.  The Art of Computer Programming, terceira
     edição, Volume 1, Seção 1.2.6, Equações 48, 49, e 50.

     [2] Graham, Knuth, e Patashnik.  Concrete Mathematics, Tabela 264.

     [3] Abramowitz e Stegun.  Handbook of Mathematical Funçãos, Seção
     24.1.4.

     Exemplos:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n, n);
          (%o3)                           1

     'stirling2' não simplifica para argumentos não inteiros.

          (%i1) stirling2 (%pi, %pi);
          (%o1)                  stirling2(%pi, %pi)

     Maxima aplica identidades a 'stirling2'.

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n + 9, n + 8);
                                   (n + 8) (n + 9)
          (%o3)                    ---------------
                                          2
          (%i4) stirling2 (n + 1, 2);
                                        n
          (%o4)                        2  - 1

 -- Função: subset (<a>, <f>)

     Retorna o subconjuntode um conjunto <a> que satisfaz o predicado
     <f>.

     'subset' returns um conjunto which comprises the elements of <a>
     for which <f> returns anything other than 'false'.  'subset' does
     not apply 'is' to the return value of <f>.

     'subset' reclama se <a> não for um conjunto literal.

     See also 'partition_set'.

     Exemplos:

          (%i1) subset ({1, 2, x, x + y, z, x + y + z}, atom);
          (%o1)                     {1, 2, x, z}
          (%i2) subset ({1, 2, 7, 8, 9, 14}, evenp);
          (%o2)                      {2, 8, 14}

 -- Função: subsetp (<a>, <b>)

     Retorna 'true' se e somente se o conjunto <a> for um subconjunto de
     <b>.

     'subsetp' reclama se ou <a> ou <b> não forem um conjunto literal.

     Exemplos:

          (%i1) subsetp ({1, 2, 3}, {a, 1, b, 2, c, 3});
          (%o1)                         true
          (%i2) subsetp ({a, 1, b, 2, c, 3}, {1, 2, 3});
          (%o2)                         false

 -- Função: symmdifference (<a_1>, ..., <a_n>)

     Retorna a diferença simétrica, isto é, o conjunto dos elemetnos que
     ocorrem em exatamente um conjunto <a_k>.

     Given two arguments, 'symmdifference(<a>, <b>)' is the same as
     'union(setdifference(<a>, <b>), setdifference(<b>, <a>))'.

     'symmdifference' reclama se any argument não for um conjunto
     literal.

     Exemplos:

          (%i1) S_1 : {a, b, c};
          (%o1)                       {a, b, c}
          (%i2) S_2 : {1, b, c};
          (%o2)                       {1, b, c}
          (%i3) S_3 : {a, b, z};
          (%o3)                       {a, b, z}
          (%i4) symmdifference ();
          (%o4)                          {}
          (%i5) symmdifference (S_1);
          (%o5)                       {a, b, c}
          (%i6) symmdifference (S_1, S_2);
          (%o6)                        {1, a}
          (%i7) symmdifference (S_1, S_2, S_3);
          (%o7)                        {1, z}
          (%i8) symmdifference ({}, S_1, S_2, S_3);
          (%o8)                        {1, z}

 -- Função: tree_reduce (<F>, <s>)
 -- Função: tree_reduce (<F>, <s>, <s_0>)

     Extende a função binária <F> a uma função enária através de
     composição, onde <s> é um conjunto ou uma lista.

     'tree_reduce' é equivalente ao seguinte: Aplicar <F> a sucessivos
     pares de elementos para formar uma nova lista '[<F>(<s_1>, <s_2>),
     <F>(<s_3>, <s_4>), ...]', mantendo o elemento final inalterado caso
     haja um número ímpar de elementos.  Repetindo então o processo até
     que a lista esteja reduzida a um elemento simples, o qual é o valor
     de retorno da função.

     Quando o argumento opcional <s_0> estiver presente, o resultado é
     equivalente a 'tree_reduce(<F>, cons(<s_0>, <s>)'.

     Para adições em ponto flutuante, 'tree_reduce' pode retornar uma
     soma que possui um menor ero de arredondamento que 'rreduce' ou
     'lreduce'.

     Os elementos da lista <s> e os resultados parciais podem ser
     arranjados em uma árvore binária de profundidade mínima, daí o nome
     "tree_reduce".

     Exemplos:

     'tree_reduce' aplicada a uma lista com um número par de elementos.

          (%i1) tree_reduce (f, [a, b, c, d]);
          (%o1)                  f(f(a, b), f(c, d))

     'tree_reduce' aplicada a uma lista com um número ímpar de
     elementos.

          (%i1) tree_reduce (f, [a, b, c, d, e]);
          (%o1)               f(f(f(a, b), f(c, d)), e)

 -- Função: union (<a_1>, ..., <a_n>)
     Retorna a união dos conjuntos de <a_1> a <a_n>.

     'union()' (sem argumentos) retorna o conjunto vazio.

     'union' reclama se qualquer argumento não for um conjunto literal.

     Exemplos:

          (%i1) S_1 : {a, b, c + d, %e};
          (%o1)                   {%e, a, b, d + c}
          (%i2) S_2 : {%pi, %i, %e, c + d};
          (%o2)                 {%e, %i, %pi, d + c}
          (%i3) S_3 : {17, 29, 1729, %pi, %i};
          (%o3)                {17, 29, 1729, %i, %pi}
          (%i4) union ();
          (%o4)                          {}
          (%i5) union (S_1);
          (%o5)                   {%e, a, b, d + c}
          (%i6) union (S_1, S_2);
          (%o6)              {%e, %i, %pi, a, b, d + c}
          (%i7) union (S_1, S_2, S_3);
          (%o7)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}
          (%i8) union ({}, S_1, S_2, S_3);
          (%o8)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}

 -- Função: xreduce (<F>, <s>)
 -- Função: xreduce (<F>, <s>, <s_0>)

     Extendendo a função <F> para uma função enária por composição, ou,
     se <F> já for enária, aplica-se <F> a <s>.  Quando <F> não for
     enária, 'xreduce' funciona da mesma forma que 'lreduce'.  O
     argumento <s> é uma lista.

     Funções sabidamente enárias inclui adição '+', multiplicação '*',
     'and', 'or', 'max', 'min', e 'append'.  Funções podem também serem
     declaradas enárias por meio de 'declare(<F>, nary)'.  Para essas
     funções, é esperado que 'xreduce' seja mais rápida que ou 'rreduce'
     ou 'lreduce'.

     Quando o argumento opcional <s_0> estiver presente, o resultado é
     equivalente a 'xreduce(<s>, cons(<s_0>, <s>))'.

     Adições em ponto flutuante não são exatamente associativas; quando
     a associatividade ocorrer, 'xreduce' aplica a adição enária do
     Maxima quando <s> contiver números em ponto flutuante.

     Exemplos:

     'xreduce' aplicada a uma função sabidamente enária.  'F' é chamada
     uma vez, com todos os argumentos.

          (%i1) declare (F, nary);
          (%o1)                         done
          (%i2) F ([L]) := L;
          (%o2)                      F([L]) := L
          (%i3) xreduce (F, [a, b, c, d, e]);
          (%o3)         [[[[[("[", simp), a], b], c], d], e]

     'xreduce' aplicada a uma função não sabidamente enária.  'G' é
     chamada muitas vezes, com dois argumentos de cada vez.

          (%i1) G ([L]) := L;
          (%o1)                      G([L]) := L
          (%i2) xreduce (G, [a, b, c, d, e]);
          (%o2)         [[[[[("[", simp), a], b], c], d], e]
          (%i3) lreduce (G, [a, b, c, d, e]);
          (%o3)                 [[[[a, b], c], d], e]


File: maxima.info,  Node: Definição de Função,  Next: Fluxo de Programa,  Prev: Conjuntos,  Up: Top

39 Definição de Função
**********************

* Menu:

* Introdução a Definição de Função::  
* Função::                    
* Macros::                      
* Funções e Variáveis para Definição de Função::  


File: maxima.info,  Node: Introdução a Definição de Função,  Next: Função,  Prev: Definição de Função,  Up: Definição de Função

39.1 Introdução a Definição de Função
=====================================


File: maxima.info,  Node: Função,  Next: Macros,  Prev: Introdução a Definição de Função,  Up: Definição de Função

39.2 Função
===========

39.2.1 Ordinary functions
-------------------------

Para definir uma função no Maxima você usa o operador ':='.  E.g.

     f(x) := sin(x)

define uma função 'f'.  Funções anônimas podem também serem criadas
usando 'lambda'.  Por exemplo

     lambda ([i, j], ...)

pode ser usada em lugar de 'f' onde

     f(i,j) := block ([], ...);
     map (lambda ([i], i+1), l)

retornará uma lista com 1 adicionado a cada termo.

   Você pode também definir uma função com um número variável de
argumentos, teno um argumento final que é atribuído para uma lista de
argumentos extras:

     (%i1) f ([u]) := u;
     (%o1)                      f([u]) := u
     (%i2) f (1, 2, 3, 4);
     (%o2)                     [1, 2, 3, 4]
     (%i3) f (a, b, [u]) := [a, b, u];
     (%o3)               f(a, b, [u]) := [a, b, u]
     (%i4) f (1, 2, 3, 4, 5, 6);
     (%o4)                 [1, 2, [3, 4, 5, 6]]

   O lado direito de uma função é uma expressão.  Desse modo Se você
quer uma seqüência de expressões, você faz

     f(x) := (expr1, expr2, ...., exprn);

   e o valor de <exprn> é que é retornado pela função.

   Se você deseja fazer um 'return' de alguma expressão dentro da função
então você deve usar 'block' e 'return'.

     block ([], expr1, ..., if (a > 10) then return(a), ..., exprn)

   é em si mesma uma expressão, e então poderá ocupar o lugar do lado
direito de uma definição de função.  Aqui pode acontecer que o retorno
aconteça mais facilmente que no exemplo anterior a essa última
expressão.

   O primeiro '[]' no bloco, pode conter uma lista de variáveis e
atribuições de variáveis, tais como '[a: 3, b, c: []]', que farão com
que as três variáveis 'a','b',e 'c' não se refiram a seus valores
globais, mas ao contrário tenham esses valores especiais enquanto o
código estiver executando a parte dentro do bloco 'block', ou dentro da
funções chamadas de dentro do bloco 'block'.  Isso é chamado associação
dynamic, uma vez que as variáveis permanecem do início do bloco pelo
tempo que ele existir.  Uma vez que você retorna do 'block', ou
descarta-o, os valores antigos (quaisquer que sejam) das variáveis serão
restaurados.  É certamente uma boa idéia para proteger suas variáveis
nesse caminho.  Note que as atribuições em variáveis do bloco, são
concluídas em paralelo.  Isso significa, que se tiver usado 'c: a'
acima, o valor de 'c' será o valor de 'a' a partir do momento em que
vocêntrou no bloco, mas antes 'a' foi associado.  Dessa forma fazendo
alguma coisa como

     block ([a: a], expr1, ...  a: a+3, ..., exprn)

   protegerá o valor externo de 'a' de ser alterado, mas impedirá você
acessar o valor antigo.  Dessa forma o lado direito de atribuições, é
avaliado no contexto inserido, antes que qualquer avaliação ocorra.
Usando apenas 'block ([x], ...' faremos com que o 'x' tenha a si mesmo
como valor, apenas como x teria se você tivesse entrado numa breve
sessão do Maxima.

   Os atuais argumentos para uma função são tratados exatamente da mesma
que as variáveis em um bloco.  Dessa forma em

     f(x) := (expr1, ..., exprn);

   e

     f(1);

   teremos um contexto similar para avaliação de expressões como se
tivéssemos concluído

     block ([x: 1], expr1, ..., exprn)

   Dentro de funções, quando o lado direito de uma definição, pode ser
calculado em tempo de execução, isso é úti para usar 'define' e
possivelmente 'buildq'.

39.2.2 Função de Array
----------------------

Uma função de Array armazena o valor da função na primeira vez que ela
for chamada com um argumento dado, e retorna o valor armazenado, sem
recalcular esse valor, quando o mesmo argumento for fornecido.  De modo
que uma função é muitas vezes chamada uma função de memorização.

   Nomes de funções de Array são anexados ao final da lista global
'arrays' (não na lista global 'functions').  O comando 'arrayinfo'
retorna a lista de argumentos para os quais exite valores armazenados, e
'listarray' retorna os valores armazenados.  Os comandos 'dispfun' e
'fundef' retornam a definição da função de array.

   O comando 'arraymake' contrói uma chamada de função de array,
análogamente a 'funmake' para funções comuns.  O comando 'arrayapply'
aplica uma função de array a seus argmentos, análogamente a 'apply' para
funções comuns.  Não existe nada exatamente análogo a 'map' para funções
de array, embora 'map(lambda([<x>], <a>[<x>]), <L>)' ou
'makelist(<a>[<x>], <x>, <L>)', onde <L> é uma lista, não estejam tão
longe disso.

   O comando 'remarray' remove uma definição de função de array
(incluindo qualquer valor armazenado pela função removida), análogo a
'remfunction' para funções comuns.

   o comando 'kill(<a>[<x>])' remove o valor da função de array <a>
armazenado para o argumento <x>; a próxima vez que <a> foor chamada com
o argumento <x>, o valor da função é recomputado.  Todavia, não exite
caminho para remover todos os valores armazenados de uma vez, exceto
para 'kill(<a>)' ou 'remarray(<a>)', o qual remove também remove a
definição da função de array.


File: maxima.info,  Node: Macros,  Next: Funções e Variáveis para Definição de Função,  Prev: Função,  Up: Definição de Função

39.3 Macros
===========

 -- Função: buildq (<L>, <expr>)
     Substitue variáveis nomeadas pela lista <L> dentro da expressão
     <expr>, paralelamente, sem avaliar <expr>.  A expressão resultante
     é simplificada, mas não avaliada, após 'buildq' realizar a
     substituição.

     Os elementos de <L> são símbolos ou expressões de atribuição
     '<símbolo>: <valor>', avaliadas paralelamente.  Isto é, a
     associação de uma variável sobre o lado direito de uma atribuição é
     a associação daquela variável no contexto do qual 'buildq' for
     chamada, não a associação daquela variável na lista <L> de
     variáveis.  Se alguma variável em <L> não dada como uma atribuição
     explícita, sua associação em 'buildq' é a mesma que no contexto no
     qual 'buildq' for chamada.

     Então as variáveis nomeadas em <L> são substituidas em <expr>
     paralelamente.  Isto é, a substituição para cada variável é
     determinada antes que qualquer substituição seja feita, então a
     substituição para uma variável não tem efeito sobre qualquer outra.

     Se qualquer variável <x> aparecer como 'splice (<x>)' em <expr>,
     então <x> deve estar associada para uma lista, e a lista recebe uma
     aplicação da função 'splice' (é interpolada) na <expr> em lugar de
     substituída.

     Quaisquer variáveis em <expr> não aparecendo em <L> são levados no
     resultado tal como foram escritos, mesmo se elas tiverem
     associações no contexto do qual 'buildq' tiver sido chamada.

     Exemplos

     'a' é explicitamente associada a 'x', enquanto 'b' tem a mesma
     associação (nomeadamente 29) como no contexto chamado, e 'c' é
     levada do começo ao fim da forma como foi escrita.  A expressão
     resultante não é avaliada até a avaliação explícita ( com duplo
     apóstrofo - não com aspas - '''%'.

          (%i1) (a: 17, b: 29, c: 1729)$
          (%i2) buildq ([a: x, b], a + b + c);
          (%o2)                      x + c + 29
          (%i3) ''%;
          (%o3)                       x + 1758

     'e' está associado a uma lista, a qual aparece também como tal nos
     argumentos de 'foo', e interpolada nos argumentos de 'bar'.

          (%i1) buildq ([e: [a, b, c]], foo (x, e, y));
          (%o1)                 foo(x, [a, b, c], y)
          (%i2) buildq ([e: [a, b, c]], bar (x, splice (e), y));
          (%o2)                  bar(x, a, b, c, y)

     O resultado é simplificado após substituição.  Se a simplificação
     for aplicada antes da substituição, esses dois resultados podem ser
     iguais.
          (%i1) buildq ([e: [a, b, c]], splice (e) + splice (e));
          (%o1)                    2 c + 2 b + 2 a
          (%i2) buildq ([e: [a, b, c]], 2 * splice (e));
          (%o2)                        2 a b c

     As variáveis em <L> são associadas em paralelo; se associadas
     seqüêncialmente, o primeiro resultado pode ser 'foo (b, b)'.
     Substituições são realizadas em paralelo; compare o segundo
     resultado com o resultado de 'subst', que realiza substituições
     seqüêncialmente.

          (%i1) buildq ([a: b, b: a], foo (a, b));
          (%o1)                       foo(b, a)
          (%i2) buildq ([u: v, v: w, w: x, x: y, y: z, z: u], bar (u, v, w, x, y, z));
          (%o2)                 bar(v, w, x, y, z, u)
          (%i3) subst ([u=v, v=w, w=x, x=y, y=z, z=u], bar (u, v, w, x, y, z));
          (%o3)                 bar(u, u, u, u, u, u)

     Constrói uma lista de euqções com algumas variáveis ou expressões
     sobre o lado esquerdo e seus valores sobre o lado direito.
     'macroexpand' mostra a expressão retornada por 'show_values'.

          (%i1) show_values ([L]) ::= buildq ([L], map ("=", 'L, L));
          (%o1)   show_values([L]) ::= buildq([L], map("=", 'L, L))
          (%i2) (a: 17, b: 29, c: 1729)$
          (%i3) show_values (a, b, c - a - b);
          (%o3)          [a = 17, b = 29, c - b - a = 1683]
          (%i4) macroexpand (show_values (a, b, c - a - b));
          (%o4)    map(=, '([a, b, c - b - a]), [a, b, c - b - a])

 -- Função: macroexpand (<expr>)
     Retorna a expansão da macro de <expr> sem avaliar a expressão,
     quando 'expr' for uma chamada de função de macro.  De outra forma,
     'macroexpand' retorna <expr>.

     Se a expansão de <expr> retorna outra chamada de função de macro,
     aquela chamada de função de macro é também expandida.

     'macroexpand' coloca apóstrofo em seus argumentos, isto é, não os
     avalia.  Todavia, se a expansão de uma chamada de função de macro
     tiver algum efeito, esse efeito colateral é executado.

     Veja também '::=', 'macros', e 'macroexpand1'.

     Exemplos

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a));
          (%o2)            h(x) ::= buildq([x], g(x - a))
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand (h (y));
                                        y - a
          (%o4)                         -----
                                         99
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99

 -- Função: macroexpand1 (<expr>)
     Retorna a expansão de macro de <expr> sem avaliar a expressão,
     quando 'expr' for uma chamada de função de macro.  De outra forma,
     'macroexpand1' retorna <expr>.

     'macroexpand1' não avalia seus argumentos.  Todavia, se a expansão
     de uma chamada de função de macro tiver algum efeito, esse efeito
     colateral é executado.

     Se a expansão de <expr> retornar outra chamada de função de macro,
     aquela chamada de função de macro não é expandida.

     Veja também '::=', 'macros', e 'macroexpand'.

     Exemplos

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a));
          (%o2)            h(x) ::= buildq([x], g(x - a))
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand1 (h (y));
          (%o4)                       g(y - a)
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99

 -- Global variable: macros
     Default value: '[]'

     'macros' é a lista de funções de macro definidas pelo usuário.  O
     operador de definição de função de macro '::=' coloca uma nova
     função de macro nessa lista, e 'kill', 'remove', e 'remfunction'
     removem funções de macro da lista.

     Veja também 'infolists'.

 -- Função: splice (<a>)
     Une como se fosse um elo de ligação (interpola) a lista nomeada
     através do átomo <a> em uma expressão, mas somente se 'splice'
     aparecer dentro de 'buildq'; de outra forma, 'splice' é tratada
     como uma função indefinida.  Se aparecer dentro de 'buildq' com <a>
     sozinho (sem 'splice'), <a> é substituido (não interpolado) como
     uma lista no resultado.  O argumento de 'splice' pode somente ser
     um átomo; não pode ser uma lista lateral ou uma expressão que
     retorna uma lista.

     Tipicamente 'splice' fornece os argumentos para uma função ou
     operador.  Para uma função 'f', a expressão 'f (splice (<a>))'
     dentro de 'buildq' expande para 'f (<a>[1], <a>[2], <a>[3], ...)'.
     Para um operador 'o', a expressão '"o" (splice (<a>)' dentro de
     'buildq' expande para '"o" (<a>[1], <a>[2], <a>[3], ...)', onde 'o'
     pode ser qualquer tipo de operador (tipicamente um que toma
     multiplos argumentos).  Note que o operador deve ser contido dentro
     de aspas duplas '"'.

     Exemplos

          (%i1) buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
                                 foo(1, %pi, z - y)
          (%o1)                -----------------------
                               length([1, %pi, z - y])
          (%i2) buildq ([x: [1, %pi]], "/" (splice (x)));
                                          1
          (%o2)                          ---
                                         %pi
          (%i3) matchfix ("<>", "<>");
          (%o3)                          <>
          (%i4) buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
          (%o4)                   <>1, %pi, z - y<>


File: maxima.info,  Node: Funções e Variáveis para Definição de Função,  Prev: Macros,  Up: Definição de Função

39.4 Funções e Variáveis para Definição de Função
=================================================

 -- Função: apply (<F>, [<x_1>, ..., <x_n>])
     Constrói e avalia uma expressãp '<F>(<arg_1>, ..., <arg_n>)'.

     'apply' não tenta distinguir funções de array de funções comuns;
     quando <F> for o nome de uma função de array, 'apply' avalia
     '<F>(...)' (isto é, uma chamada de função com parêntesis em lugar
     de colchêtes).  'arrayapply' avalia uma chamada de função com
     colchêtes nesse caso.

     Exemplos:

     'apply' avalia seus argumentos.  Nesse exemplo, 'min' é aplicado a
     'L'.

          (%i1) L : [1, 5, -10.2, 4, 3];
          (%o1)                 [1, 5, - 10.2, 4, 3]
          (%i2) apply (min, L);
          (%o2)                        - 10.2

     'apply' avalia argumentos, mesmo se a função <F> disser que os
     argumentos não devem ser avaliados.

          (%i1) F (x) := x / 1729;
                                             x
          (%o1)                     F(x) := ----
                                            1729
          (%i2) fname : F;
          (%o2)                           F
          (%i3) dispfun (F);
                                             x
          (%t3)                     F(x) := ----
                                            1729

          (%o3)                         [%t3]
          (%i4) dispfun (fname);
          fname is not the name of a user function.
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) apply (dispfun, [fname]);
                                             x
          (%t5)                     F(x) := ----
                                            1729

          (%o5)                         [%t5]

     'apply' avalia o nome de função <F>.  Apóstrofo ''' evita
     avaliação.  'demoivre' é o nome de uma variável global e também de
     uma função.

          (%i1) demoivre;
          (%o1)                         false
          (%i2) demoivre (exp (%i * x));
          (%o2)                  %i sin(x) + cos(x)
          (%i3) apply (demoivre, [exp (%i * x)]);
          demoivre evaluates to false
          Improper name or value in functional position.
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) apply ('demoivre, [exp (%i * x)]);
          (%o4)                  %i sin(x) + cos(x)

 -- Função: block ([<v_1>, ..., <v_m>], <expr_1>, ..., <expr_n>)
 -- Função: block (<expr_1>, ..., <expr_n>)
     'block' avalia <expr_1>, ..., <expr_n> em seqüência e retorna o
     valor da última expressão avaliada.  A seqüência pode ser
     modificada pelas funções 'go', 'throw', e 'return'.  A última
     expressão é <expr_n> a menos que 'return' ou uma expressão contendo
     'throw' seja avaliada.  Algumas variáveis <v_1>, ..., <v_m> podem
     ser declaradas locais para o bloco; essas são distinguidas das
     variáveis globais dos mesmos nomes.  Se variáveis não forem
     declaradas locais então a lista pode ser omitida.  Dentro do bloco,
     qualquer variável que não <v_1>, ..., <v_m> é uma variável global.

     'block' salva os valores correntes das variáveis <v_1>, ..., <v_m>
     (quaisquer valores) na hora da entrada para o bloco, então libera
     as variáveis dessa forma eles avaliam para si mesmos.  As variáveis
     locais podem ser associadas a valores arbitrários dentro do bloco
     mas quando o bloco é encerrado o valores salvos são restaurados, e
     os valores atribuídos dentro do bloco são perdidos.

     'block' pode aparecer dentro de outro 'block'.  Variáveis locais
     são estabelecidas cada vez que um novo 'block' é avaliado.
     Variáveis locais parecem ser globais para quaisquer blocos
     fechados.  Se uma variável é não local em um bloco, seu valor é o
     valor mais recentemente atribuído por um bloco fechado, quaisquer
     que sejam, de outra forma, seu valor é o valor da variável no
     ambiente global.  Essa política pode coincidir com o entendimento
     usual de "escopo dinâmico".

     Se isso for desejado para salvar e restaurar outras propriedades
     locais ao lado de 'value', por exemplo 'array' (exceto para arrays
     completos), 'function', 'dependencies', 'atvalue', 'matchdeclare',
     'atomgrad', 'constant', e 'nonscalar' então a função 'local' pode
     ser usada dentro do bloco com argumentos sendo o nome das
     variáveis.

     O valor do bloco é o valor da última declaração ou o valor do
     argumento para a função 'return' que pode ser usada para sair
     explicitamente do bloco.  A função 'go' pode ser usada para
     transferir o controle para a declaração do bloco que é identificada
     com o argumento para 'go'.  Para identificar uma declaração,
     coloca-se antes dela um argumento atômico como outra declaração no
     bloco.  Por exemplo: 'block ([x], x:1, loop, x: x+1, ..., go(loop),
     ...)'.  O argumento para 'go' deve ser o nome de um identificador
     que aparece dentro do bloco.  Não se deve usar 'go' para transferir
     para um identificador em um outro bloco a não ser esse que contém o
     'go'.

     Blocos tipicamente aparecem do lado direito de uma definição de
     função mas podem ser usados em outros lugares também.

 -- Função: break (<expr_1>, ..., <expr_n>)
     Avalia e imprime <expr_1>, ..., <expr_n> e então causa uma parada
     do Maxima nesse ponto e o usuário pode examinar e alterar seu
     ambiente.  Nessa situação digite 'exit;' para que o cálculo seja
     retomado.

 -- Função: catch (<expr_1>, ..., <expr_n>)
     Avalia <expr_1>, ..., <expr_n> uma por uma; se qualquer avaliação
     levar a uma avaliação de uma expressão da forma 'throw (arg)',
     então o valor de 'catch' é o valor de 'throw (arg)', e expressões
     adicionais não são avaliadas.  Esse "retorno não local" atravessa
     assim qualquer profundidade de aninhar para o mais próximo contendo
     'catch'.  Se não existe nenhum 'catch' contendo um 'throw', uma
     mensagem de erro é impressa.

     Se a avaliação de argumentos não leva para a avaliação de qualquer
     'throw' então o valor de 'catch' é o valor de <expr_n>.

          (%i1) lambda ([x], if x < 0 then throw(x) else f(x))$
          (%i2) g(l) := catch (map (''%, l))$
          (%i3) g ([1, 2, 3, 7]);
          (%o3)               [f(1), f(2), f(3), f(7)]
          (%i4) g ([1, 2, -3, 7]);
          (%o4)                          - 3

     A função 'g' retorna uma lista de 'f' de cada elemento de 'l' se
     'l' consiste somente de números não negativos; de outra forma, 'g'
     "captura" o primeiro elemento negativo de 'l' e "arremessa-o".

 -- Função: compfile (<nomearquivo>, <f_1>, ..., <f_n>)
 -- Função: compfile (<nomearquivo>, funções)
 -- Função: compfile (<nomearquivo>, all)

     Traduz fuções Maxima para Lisp e escreve o código traduzido no
     arquivo <nomearquivo>.

     'compfile(<nomearquivo>, <f_1>, ..., <f_n>)' traduz as funções
     especificadas.  'compfile(<nomearquivo>, functions)' e
     'compfile(<nomearquivo>, all)' traduz todas as funções definidas
     pelo usuário.

     As traduções Lisp não são avaliadas, nem é o arquivo de saída
     processado pelo compilador Lisp.  'translate' cria e avalia
     traduções Lisp.  'compile_file' traduz Maxima para Lisp, e então
     executa o compilador Lisp.

     Veja também 'translate', 'translate_file', e 'compile_file'.

 -- Função: compile (<f_1>, ..., <f_n>)
 -- Função: compile (funções)
 -- Função: compile (all)
     Traduz funções Maxima <f_1>, ..., <f_n> para Lisp, avalia a
     tradução Lisp, e chama a função Lisp 'COMPILE' sobre cada função
     traduzida.  'compile' retorna uma lista de nomes de funções
     compiladas.

     'compile (all)' ou 'compile (funções)' compila todas as funções
     definidas pelo usuário.

     'compile' não avalia seus argumentos; o operador
     apóstrofo-apóstrofo '''' faz com que ocorra avaliação sobrepondo-se
     ao apóstrofo.

 -- Função: define (<f>(<x_1>, ..., <x_n>), <expr>)
 -- Função: define (<f>[<x_1>, ..., <x_n>], <expr>)
 -- Função: define (funmake (<f>, [<x_1>, ..., <x_n>]), <expr>)
 -- Função: define (arraymake (<f>, [<x_1>, ..., <x_n>]), <expr>)
 -- Função: define (ev (<expr_1>), <expr_2>)

     Define uma função chamada <f> com argumentos <x_1>, ..., <x_n> e
     corpo da função <expr>.  'define' sempre avalia seu segundo
     argumento (a menos que explícitamente receba um apostrofo de forma
     a evitar a avaliação).  A função então definida pode ser uma função
     comum do Maxima (com argumentos contidos entre parêtesis) ou uma
     função de array (com argumentos contidos entre colchêtes).

     Quando o último ou único argumento da função <x_n> for uma lista de
     um elemento, a função definida por 'define' aceita um número
     variável de argumentos.  Os argumentos atuais são atribuídos um a
     um a argumentos formais <x_1>, ..., <x_(n - 1)>, e quaisquer
     argumentos adicionais atuais, se estiverem presentes, são
     atribuídos a <x_n> como uma lista.

     Quando o primeiro argumento de 'define' for uma expressão da forma
     '<f>(<x_1>, ..., <x_n>)' or '<f>[<x_1>, ..., <x_n>]', os argumentos
     são avaliados mas <f> não é avaliada, mesmo se já existe
     anteriormente uma função ou variável com aquele nome.

     Quando o primeiro argumento for uma expressão com operador
     'funmake', 'arraymake', ou 'ev', o primeiro argumento será
     avaliado; isso permite para o nome da função seja calculado, também
     como o corpo.

     Todas as definições de função aparecem no mesmo nível de escopo e
     visibilidade; definindo uma função 'f' dentro de outra função 'g'
     não limita o escopo de 'f' a 'g'.

     Se algum argumento formal <x_k> for um símbolo com apóstrofo (após
     ter sido feita uma avaliação), a função definida por 'define' não
     avalia o correspondente atual argumento.  de outra forma todos os
     argumentos atuais são avaliados.

     Veja também ':=' and '::='.

     Exemplos:

     'define' sempre avalia seu segundo argumento (a menos que
     explícitamente receba um apostrofo de forma a evitar a avaliação).

          (%i1) expr : cos(y) - sin(x);
          (%o1)                    cos(y) - sin(x)
          (%i2) define (F1 (x, y), expr);
          (%o2)              F1(x, y) := cos(y) - sin(x)
          (%i3) F1 (a, b);
          (%o3)                    cos(b) - sin(a)
          (%i4) F2 (x, y) := expr;
          (%o4)                   F2(x, y) := expr
          (%i5) F2 (a, b);
          (%o5)                    cos(y) - sin(x)

     A função definida por 'define' pode ser uma função comum do Maxima
     ou uma função de array.

          (%i1) define (G1 (x, y), x.y - y.x);
          (%o1)               G1(x, y) := x . y - y . x
          (%i2) define (G2 [x, y], x.y - y.x);
          (%o2)                G2     := x . y - y . x
                                 x, y

     Quando o último ou único argumento da função <x_n> for uma lista de
     um único elemento, a função definida por 'define' aceita um número
     variável de argumentos.

          (%i1) define (H ([L]), '(apply ("+", L)));
          (%o1)                H([L]) := apply("+", L)
          (%i2) H (a, b, c);
          (%o2)                       c + b + a

     When the first argument is an expression with operator 'funmake',
     'arraymake', or 'ev', the first argument is evaluated.

          (%i1) [F : I, u : x];
          (%o1)                        [I, x]
          (%i2) funmake (F, [u]);
          (%o2)                         I(x)
          (%i3) define (funmake (F, [u]), cos(u) + 1);
          (%o3)                  I(x) := cos(x) + 1
          (%i4) define (arraymake (F, [u]), cos(u) + 1);
          (%o4)                   I  := cos(x) + 1
                                   x
          (%i5) define (foo (x, y), bar (y, x));
          (%o5)                foo(x, y) := bar(y, x)
          (%i6) define (ev (foo (x, y)), sin(x) - cos(y));
          (%o6)             bar(y, x) := sin(x) - cos(y)

 -- Função: define_variable (<name>, <default_value>, <mode>)

     Introduz uma variável global dentro do ambiente Maxima.
     'define_variable' é útil em pacotes escritos pelo usuário, que são
     muitas vezes traduzidos ou compilados.

     'define_variable' realiza os seguintes passos:

       1. 'mode_declare (<name>, <mode>)' declara o modo de <name> para
          o tradutor.  Veja 'mode_declare' para uma lista dos modos
          possíveis.

       2. Se a variável é não associada, <default_value> é atribuído
          para <name>.

       3. 'declare (<name>, special)' declara essa variável especial.

       4. Associa <name> com uma função de teste para garantir que a
          <name> seja somente atribuído valores do modo declarado.

     A propriedade 'value_check' pode ser atribuída a qualquer variável
     que tenha sido definida via 'define_variable' com um outro modo que
     não 'any'.  A propriedade 'value_check' é uma expressão lambda ou o
     nome de uma função de uma variável, que é chamada quando uma
     tentativa é feita para atribuir um valor a uma variável.  O
     argumento da função 'value_check' é o valor que será atribuído.

     'define_variable' avalia 'default_value', e não avalia 'name' e
     'mode'.  'define_variable' retorna o valor corrente de 'name', que
     é 'default_value' se 'name' não tiver sido associada antes, e de
     outra forma isso é o valor prévio de 'name'.

     Exemplos:

     'foo' é uma variável Booleana, com o valor inicial 'true'.

          (%i1) define_variable (foo, true, boolean);
          (%o1)                         true
          (%i2) foo;
          (%o2)                         true
          (%i3) foo: false;
          (%o3)                         false
          (%i4) foo: %pi;
          Error: foo was declared mode boolean, has value: %pi
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) foo;
          (%o5)                         false

     'bar' é uma variável inteira, que deve ser um número primo.

          (%i1) define_variable (bar, 2, integer);
          (%o1)                           2
          (%i2) qput (bar, prime_test, value_check);
          (%o2)                      prime_test
          (%i3) prime_test (y) := if not primep(y) then error (y, "is not prime.");
          (%o3) prime_test(y) := if not primep(y)

                                             then error(y, "is not prime.")
          (%i4) bar: 1439;
          (%o4)                         1439
          (%i5) bar: 1440;
          1440 é not prime.
          #0: prime_test(y=1440)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i6) bar;
          (%o6)                         1439

     'baz_quux' é uma variável que não pode receber a atribuição de um
     valor.  O modo 'any_check' é como 'any', mas 'any_check' habilita o
     mecanismo 'value_check', e 'any' não habilita.

          (%i1) define_variable (baz_quux, 'baz_quux, any_check);
          (%o1)                       baz_quux
          (%i2) F: lambda ([y], if y # 'baz_quux then error ("Cannot assign to `baz_quux'."));
          (%o2) lambda([y], if y # 'baz_quux

                                  then error(Cannot assign to `baz_quux'.))
          (%i3) qput (baz_quux, ''F, value_check);
          (%o3) lambda([y], if y # 'baz_quux

                                  then error(Cannot assign to `baz_quux'.))
          (%i4) baz_quux: 'baz_quux;
          (%o4)                       baz_quux
          (%i5) baz_quux: sqrt(2);
          Cannot assign to `baz_quux'.
          #0: lambda([y],if y # 'baz_quux then error("Cannot assign to `baz_quux'."))(y=sqrt(2))
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i6) baz_quux;
          (%o6)                       baz_quux

 -- Função: dispfun (<f_1>, ..., <f_n>)
 -- Função: dispfun (all)
     Mostra a definição de funções definidas pelo usuário <f_1>, ...,
     <f_n>.  Cada argumento pode ser o nome de uma macro (definida com
     '::='), uma função comum (definida com ':=' ou 'define'), uma
     função array (definida com ':=' ou com 'define', mas contendo
     argumentos entre colchêtes '[ ]'), uma função subscrita, (definida
     com ':=' ou 'define', mas contendo alguns argumentos entre
     colchêtes e outros entre parêntesis '( )') uma da família de
     funções subscritas selecionadas por um valor subscrito particular,
     ou uma função subscrita definida com uma constante subscrita.

     'dispfun (all)' mostra todas as funções definidas pelo usuário como
     dadas pelas 'functions', 'arrays', e listas de 'macros', omitindo
     funções subscritas definidas com constantes subscritas.

     'dispfun' cria um Rótulo de expressão intermediária ('%t1', '%t2',
     etc.)  para cada função mostrada, e atribui a definição de função
     para o rótulo.  Em contraste, 'fundef' retorna a definição de
     função.

     'dispfun' não avalia seus argumentos; O operador
     apóstrofo-apóstrofo '''' faz com que ocorra avaliação.  'dispfun'
     retorna a lista de rótulos de expressões intermediárias
     correspondendo às funções mostradas.

     Exemplos:

          (%i1) m(x, y) ::= x^(-y);
                                               - y
          (%o1)                   m(x, y) ::= x
          (%i2) f(x, y) :=  x^(-y);
                                               - y
          (%o2)                    f(x, y) := x
          (%i3) g[x, y] :=  x^(-y);
                                              - y
          (%o3)                     g     := x
                                     x, y
          (%i4) h[x](y) :=  x^(-y);
                                              - y
          (%o4)                     h (y) := x
                                     x
          (%i5) i[8](y) :=  8^(-y);
                                              - y
          (%o5)                     i (y) := 8
                                     8
          (%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                               - y
          (%t6)                   m(x, y) ::= x

                                               - y
          (%t7)                    f(x, y) := x

                                              - y
          (%t8)                     g     := x
                                     x, y

                                              - y
          (%t9)                     h (y) := x
                                     x

                                              1
          (%t10)                     h (y) := --
                                      5        y
                                              5

                                               1
          (%t11)                    h  (y) := ---
                                     10         y
                                              10

                                              - y
          (%t12)                    i (y) := 8
                                     8

          (%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
          (%i12) ''%;
                               - y              - y            - y
          (%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   ,
                                                      x, y
                            - y           1              1             - y
                  h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
                   x              5        y   10         y   8
                                          5             10

 -- Variável de sistema: functions
     Valor padrão: '[]'

     'functions' é a lista de todas as funções comuns do Maxima na
     sessão corrente.  Uma função comum é uma função construída através
     de 'define' ou de ':=' e chamada com parêntesis '()'.  Uma função
     pode ser definida pela linha de comando do Maxima de forma
     interativa com o usuário ou em um arquivo Maxima chamado por 'load'
     ou 'batch'.

     Funções de array (chamadas com colchêtes, e.g., 'F[x]') e funções
     com subscritos (chamadas com colchêtes e parêntesis, e.g.,
     'F[x](y)') são lsitados através da variável global 'arrays', e não
     por meio de 'functions'.

     Funções Lisp não são mantidas em nenhuma lista.

     Exemplos:

          (%i1) F_1 (x) := x - 100;
          (%o1)                   F_1(x) := x - 100
          (%i2) F_2 (x, y) := x / y;
                                                x
          (%o2)                    F_2(x, y) := -
                                                y
          (%i3) define (F_3 (x), sqrt (x));
          (%o3)                   F_3(x) := sqrt(x)
          (%i4) G_1 [x] := x - 100;
          (%o4)                    G_1  := x - 100
                                      x
          (%i5) G_2 [x, y] := x / y;
                                               x
          (%o5)                     G_2     := -
                                       x, y    y
          (%i6) define (G_3 [x], sqrt (x));
          (%o6)                    G_3  := sqrt(x)
                                      x
          (%i7) H_1 [x] (y) := x^y;
                                                y
          (%o7)                     H_1 (y) := x
                                       x
          (%i8) functions;
          (%o8)              [F_1(x), F_2(x, y), F_3(x)]
          (%i9) arrays;
          (%o9)                 [G_1, G_2, G_3, H_1]

 -- Função: fundef (<f>)
     Retorna a definição da função <f>.

     O argumento pode ser o nome de uma macro (definida com '::='), uma
     função comum (definida com ':=' ou 'define'), uma função array
     (definida com ':=' ou 'define', mas contendo argumentos entre
     colchêtes '[ ]'), Uma função subscrita, (definida com ':=' ou
     'define', mas contendo alguns argumentos entre colchêtes e
     parêntesis '( )') uma da família de funções subscritas selecionada
     por um valor particular subscrito, ou uma função subscrita definida
     com uma constante subscrita.

     'fundef' não avalia seu argumento; o operador apóstrofo-apóstrofo
     '''' faz com que ocorra avaliação.

     'fundef (<f>)' retorna a definição de <f>.  Em contraste, 'dispfun
     (<f>)' cria um rótulo de expressão intermediária e atribui a
     definição para o rótulo.

 -- Função: funmake (<F>, [<arg_1>, ..., <arg_n>])
     Retorna uma expressão '<F>(<arg_1>, ..., <arg_n>)'.  O valor de
     retorno é simplificado, mas não avaliado, então a função <F> não é
     chamada, mesmo se essa função <F> existir.

     'funmake' não tenta distinguir funções de array de funções comuns;
     quando <F> for o nome de uma função de array, 'funmake' retorna
     '<F>(...)' (isto é, uma chamada de função com parêntesis em lugar
     de colchêtes).  'arraymake' retorna uma chamada de função com
     colchêtes nesse caso.

     'funmake' avalia seus argumentos.

     Exemplos:

     'funmake' aplicada a uma função comum do Maxima.

          (%i1) F (x, y) := y^2 - x^2;
                                             2    2
          (%o1)                  F(x, y) := y  - x
          (%i2) funmake (F, [a + 1, b + 1]);
          (%o2)                    F(a + 1, b + 1)
          (%i3) ''%;
                                        2          2
          (%o3)                  (b + 1)  - (a + 1)

     'funmake' aplicada a uma macro.

          (%i1) G (x) ::= (x - 1)/2;
                                            x - 1
          (%o1)                    G(x) ::= -----
                                              2
          (%i2) funmake (G, [u]);
          (%o2)                         G(u)
          (%i3) ''%;
                                        u - 1
          (%o3)                         -----
                                          2

     'funmake' aplicada a uma função subscrita.

          (%i1) H [a] (x) := (x - 1)^a;
                                                  a
          (%o1)                   H (x) := (x - 1)
                                   a
          (%i2) funmake (H [n], [%e]);
                                                 n
          (%o2)               lambda([x], (x - 1) )(%e)
          (%i3) ''%;
                                              n
          (%o3)                       (%e - 1)
          (%i4) funmake ('(H [n]), [%e]);
          (%o4)                        H (%e)
                                        n
          (%i5) ''%;
                                              n
          (%o5)                       (%e - 1)

     'funmake' aplicada a um símbolo que não é uma função definida de
     qualquer tipo.

          (%i1) funmake (A, [u]);
          (%o1)                         A(u)
          (%i2) ''%;
          (%o2)                         A(u)

     'funmake' avalia seus argumentos, mas não o valor de retorno.

          (%i1) det(a,b,c) := b^2 -4*a*c;
                                              2
          (%o1)              det(a, b, c) := b  - 4 a c
          (%i2) (x : 8, y : 10, z : 12);
          (%o2)                          12
          (%i3) f : det;
          (%o3)                          det
          (%i4) funmake (f, [x, y, z]);
          (%o4)                    det(8, 10, 12)
          (%i5) ''%;
          (%o5)                         - 284

     Maxima simplifica o valor de retorno de 'funmake'.

          (%i1) funmake (sin, [%pi / 2]);
          (%o1)                           1

 -- Função: lambda ([<x_1>, ..., <x_m>], <expr_1>, ..., <expr_n>)
 -- Função: lambda ([[<L>]], <expr_1>, ..., <expr_n>)
 -- Função: lambda ([<x_1>, ..., <x_m>, [<L>]], <expr_1>, ..., <expr_n>)
     Define e retorna uma expressão lambda (que é, uma função anônima) A
     função pode ter argumentos que sejam necessários <x_1>, ..., <x_m>
     e/ou argumentos opcionais <L>, os quais aparecem dentro do corpo da
     função como uma lista.  O valor de retorno da função é <expr_n>.
     Uma expressão lambda pode ser atribuída para uma variável e
     avaliada como uma função comum.  Uma expressão lambda pode aparecer
     em alguns contextos nos quais um nome de função é esperado.

     Quando a função é avaliada, variáveis locais não associadas <x_1>,
     ..., <x_m> são criadas.  'lambda' pode aparecer dentro de 'block'
     ou outra função 'lambda'; variáveis locais são estabelecidas cada
     vez que outro 'block' ou função 'lambda' é avaliada.  Variáveis
     locais parecem ser globais para qualquer coisa contendo 'block' ou
     'lambda'.  Se uma variável é não local, seu valor é o valor mais
     recentemente atribuído em alguma coisa contendo 'block' ou
     'lambda', qualquer que seja, de outra forma, seu valor é o valor da
     variável no ambiente global.  Essa política pode coincidir com o
     entendimento usual de "escopo dinâmico".

     Após variáveis locais serem estabelecidas, <expr_1> até <expr_n>
     são avaliadas novamente.  a variável especial '%%', representando o
     valor da expressão precedente, é reconhecida.  'throw' e 'catch'
     pode também aparecer na lista de expressões.

     'return' não pode aparecer em uma expressão lambda a menos que
     contendo 'block', nesse caso 'return' define o valor de retorno do
     bloco e não da expressão lambda, a menos que o bloco seja <expr_n>.
     Da mesma forma, 'go' não pode aparecer em uma expressão lambda a
     menos que contendo 'block'.

     'lambda' não avalia seus argumentos; o operador apóstrofo-apóstrofo
     '''' faz com que ocorra avaliação.

     Exemplos:

        * A expressão lambda pode ser atribuída para uma variável e
          avaliada como uma função comum.
          (%i1) f: lambda ([x], x^2);
                                                2
          (%o1)                    lambda([x], x )
          (%i2) f(a);
                                          2
          (%o2)                          a
        * Uma expressão lambda pode aparecer em contextos nos quais uma
          avaliação de função é esperada como resposta.
          (%i3) lambda ([x], x^2) (a);
                                          2
          (%o3)                          a
          (%i4) apply (lambda ([x], x^2), [a]);
                                          2
          (%o4)                          a
          (%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                                  2   2   2   2   2
          (%o5)                 [a , b , c , d , e ]
        * Variáveis argumento são variáveis locais.  Outras variáveis
          aparecem para serem variáveis globais.  Variáveis globais são
          avaliadas ao mesmo tempo em que a expressão lambda é avaliada,
          a menos que alguma avaliação especial seja forçada por alguns
          meios, tais como ''''.
          (%i6) a: %pi$
          (%i7) b: %e$
          (%i8) g: lambda ([a], a*b);
          (%o8)                   lambda([a], a b)
          (%i9) b: %gamma$
          (%i10) g(1/2);
                                       %gamma
          (%o10)                       ------
                                         2
          (%i11) g2: lambda ([a], a*''b);
          (%o11)                lambda([a], a %gamma)
          (%i12) b: %e$
          (%i13) g2(1/2);
                                       %gamma
          (%o13)                       ------
                                         2
        * Expressões lambda podem ser aninhadas.  Variáveis locais
          dentro de outra expressão lambda parece ser global para a
          expressão interna a menos que mascarada por variáveis locais
          de mesmos nomes.
          (%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                             1
          (%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                             2
          (%i15) h(%pi, %gamma);
                                       %gamma
          (%o15)                       ------
                                         2
        * Uma vez que 'lambda' não avalia seus argumentos, a expressão
          lambda 'i' abaixo não define uma função "multiplicação por
          'a'".  Tanto uma função pode ser definida via 'buildq', como
          na expressão lambda 'i2' abaixo.
          (%i16) i: lambda ([a], lambda ([x], a*x));
          (%o16)            lambda([a], lambda([x], a x))
          (%i17) i(1/2);
          (%o17)                  lambda([x], a x)
          (%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
          (%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
          (%i19) i2(1/2);
                                               x
          (%o19)                   lambda([x], -)
                                               2
          (%i20) i2(1/2)(%pi);
                                         %pi
          (%o20)                         ---
                                          2
        * Uma expressão lambda pode receber um número variável de
          argumentos, os quais são indicados por meio de '[<L>]' como o
          argumento único ou argumento final.  Os argumentos aparecem
          dentro do corpo da função como uma lista.
          (%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
          (%o1)          lambda([aa, bb, [cc]], aa cc + bb)
          (%i2) f (foo, %i, 17, 29, 256);
          (%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
          (%i3) g : lambda ([[aa]], apply ("+", aa));
          (%o3)             lambda([[aa]], apply(+, aa))
          (%i4) g (17, 29, x, y, z, %e);
          (%o4)                  z + y + x + %e + 46

 -- Função: local (<v_1>, ..., <v_n>)
     Declara as variáveis <v_1>, ..., <v_n> para serem locais com
     relação a todas as propriedades na declaração na qual essa função é
     usada.

     'local' não avalia seus argumentos.  'local' retorna 'done'.

     'local' pode somente ser usada em 'block', no corpo de definições
     de função ou expressões 'lambda', ou na função 'ev', e somente uma
     ocorrêcia é permitida em cada.

     'local' é independente de 'context'.

 -- Variável de opção: macroexpansion
     Valor padrão: 'false'

     'macroexpansion' controla se a expansão (isto é, o valor de
     retorno) de uma função de macro é substituído pela chamada à função
     de macro.  Uma substituição pode aumentar a velocidade de
     subseqüênte avaliações da expressão, ao custo de armazenar a
     expansão.

     'false'
          A expansão de uma função de macro não é substituída pela
          chamada de função de macro.
     'expand'
          Da primeira vez que a função de macro é avaliada, a expansão é
          armazenada.  A expansão não é recalculada sobre chamadas
          subseqüêntes; qualquer efeito colateral (tais como 'print' ou
          atribuições a variáveis globais) ocorrem somente quando
          chamadas à função de macro forem avaliadas primeiramente.
          Expansões em uma expressão não afetam outras expressões que
          possuem a mesma chamada à função de macro.
     'displace'
          Na primeira vez que uma função de macro é avaliada, a expansão
          é substituída pela chamada, dessa forma modificando a
          expressão a partir da qual a função de macro foi chamada.  A
          expansão não é recalculada nas chamadas subseqüêntes; qualquer
          efeito colateral acontece somente quando a chamada à função de
          macro for avaliada primeiramente.  Expansões na expressão não
          afetam outras expressões que possuem a mesma chamada à função
          de macro.

     Exemplos

     Quandon 'macroexpansion' for 'false', uma função de macro é chamada
     a cada vez que a expressão que está chamando é avaliada, e a
     expressão que está chamandonão é modificada.

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: false;
          (%o4)                         false
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                            h(x)
          (%t6)                     f(x) := ----
                                            g(x)

          (%o6)                         done
          (%i7) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o7)                       --------
                                      a b + 99

     Quando 'macroexpansion' for 'expand', uma função de macro é chamada
     uma única vez, e a expressão que está chamando não é modificada.

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: expand;
          (%o4)                        expand
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                            h(x)
          (%t6)                     f(x) := ----
                                            g(x)

          (%o6)                         done
          (%i7) f (a * b);
                                      a b - 99
          (%o7)                       --------
                                      a b + 99

     Quando 'macroexpansion' for 'expand', uma função de macro é chamada
     uma única vez, e a expressão que está chamando é modificada.

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: displace;
          (%o4)                       displace
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                           x - 99
          (%t6)                    f(x) := ------
                                           x + 99

          (%o6)                         done
          (%i7) f (a * b);
                                      a b - 99
          (%o7)                       --------
                                      a b + 99

 -- Variável de opção: mode_checkp
     Valor padrão: 'true'

     Quando 'mode_checkp' é 'true', 'mode_declare' verifica os modos de
     associação de variáveis.

 -- Variável de opção: mode_check_errorp
     Valor padrão: 'false'

     Quando 'mode_check_errorp' é 'true', 'mode_declare' chama a função
     "error".

 -- Variável de opção: mode_check_warnp
     Valor padrão: 'true'

     Quando 'mode_check_warnp' é 'true', modo "errors" são descritos.

 -- Função: mode_declare (<y_1>, <mode_1>, ..., <y_n>, <mode_n>)
     'mode_declare' é usado para declarar os modos de variáveis e
     funções para subseqüênte tradução ou compilação das funções.
     'mode_declare' é tipicamente colocada no início de uma definição de
     função, no início de um script Maxima, ou executado através da
     linha de comando de forma interativa.

     Os argumentos de 'mode_declare' são pares consistindo de uma
     variável e o modo que é um de 'boolean', 'fixnum', 'number',
     'rational', ou 'float'.  Cada variável pode também ser uma lista de
     variáveis todas as quais são declaradas para ter o mesmo modo.

     Se uma variável é um array, e se todo elemento do array que é
     referenciado tiver um valor então 'array (yi, complete, dim1, dim2,
     ...)' em lugar de
          array(yi, dim1, dim2, ...)
     deverá ser usado primeiro declarando as associações do array.  Se
     todos os elementos do array estão no modo 'fixnum' ('float'), use
     'fixnum' ('float') em lugar de 'complete'.  Também se todo elemento
     do array está no mesmo modo, digamos 'm', então

          mode_declare (completearray (yi), m))

     deverá ser usado para uma tradução eficiente.

     Código numéricos usando arrays podem rodar mais rápidamente se for
     decladado o tamanho esperado do array, como em:

          mode_declare (completearray (a [10, 10]), float)

     para um array numérico em ponto flutuante que é 10 x 10.

     Pode-se declarar o modo do resultado de uma função usando 'function
     (f_1, f_2, ...)' como um argumento; aqui 'f_1', 'f_2', ...  são
     nomes de funções.  Por exemplo a expressão,

          mode_declare ([function (f_1, f_2, ...)], fixnum)

     declara que os valores retornados por 'f_1', 'f_2', ...  são
     inteiros palavra simples.

     'modedeclare' é um sinônimo para 'mode_declare'.

 -- Função: mode_identity (<arg_1>, <arg_2>)
     Uma forma especial usada com 'mode_declare' e 'macros' para
     declarar, e.g., uma lista de listas de números em ponto flutuante
     ou outros objetos de dados.  O primeiro argumento para
     'mode_identity' é um valor primitivo nome de modo como dado para
     'mode_declare' (i.e., um de 'float', 'fixnum', 'number', 'list', ou
     'any'), e o segundo argumento é uma expressão que é avaliada e
     retornada com o valor de 'mode_identity'.  Todavia, se o valor de
     retorno não é permitido pelo modo declarado no primeiro argumento,
     um erro ou alerta é sinalizado.  Um ponto importante é que o modo
     da expressão como determinado pelo Maxima para o tradutor Lisp,
     será aquele dado como o primeiro argumento, independente de
     qualquer coisa que vá no segundo argumento.  E.g., 'x: 3.3;
     mode_identity (fixnum, x);' retorna um erro.  'mode_identity
     (flonum, x)' returns 3.3 .  Isso tem númerosas utilidades, e.g., se
     você soube que 'first (l)' retornou um número então você pode
     escrever 'mode_identity (number, first (l))'.  Todavia, um mais
     eficiente caminho para fazer isso é definir uma nova primitiva,

          firstnumb (x) ::= buildq ([x], mode_identity (number, first(x)));

     e usar 'firstnumb' toda vez que você pegar o primeiro de uma lista
     de números.

 -- Variável de opção: transcompile
     Valor padrão: 'true'

     Quando 'transcompile' é 'true', 'translate' e 'translate_file'
     geram declarações para fazer o código traduzido mais adequado para
     compilação.

     'compfile' escolhe 'transcompile: true' para a duração.

 -- Função: translate (<f_1>, ..., <f_n>)
 -- Função: translate (funções)
 -- Função: translate (all)
     Traduz funções definidas pelo usuário <f_1>, ..., <f_n> da
     linguagem de Maxima para Lisp e avalia a tradução Lisp.
     Tipicamente as funções traduzidas executam mais rápido que as
     originais.

     'translate (all)' ou 'translate (funções)' traduz todas as funções
     definidas pelo usuário.

     Funções a serem traduzidas incluir~ao uma chamada para
     'mode_declare' no início quando possível com o objetivo de produzir
     um código mais eficiente.  Por exemplo:

          f (x_1, x_2, ...) := block ([v_1, v_2, ...],
              mode_declare (v_1, mode_1, v_2, mode_2, ...), ...)

     quando <x_1>, <x_2>, ...  são parâmetros para a função e <v_1>,
     <v_2>, ...  são variáveis locais.

     Os nomes de funções traduzidas são removidos da lista 'functions'
     se 'savedef' é 'false' (veja abaixo) e são adicionados nas listas
     'props'.

     Funções não poderão ser traduzidas a menos que elas sejam
     totalmente depuradas.

     Expressões são assumidas simplificadas; se não forem, um código
     correto será gerado mas não será um código ótimo.  Dessa forma, o
     usuário não poderá escolher o comutador 'simp' para 'false' o qual
     inibe simplificação de expressões a serem traduzidas.

     O comutador 'translate', se 'true', causa tradução automatica de
     uma função de usuário para Lisp.

     Note que funções traduzidas podem não executar identicamente para o
     caminho que elas faziam antes da tradução como certas
     incompatabilidades podem existir entre o Lisp e versões do Maxima.
     Principalmente, a função 'rat' com mais de um argumento e a função
     'ratvars' não poderá ser usada se quaisquer variáveis são
     declaradas com 'mode_declare' como sendo expressões rotacionais
     canônicas(CRE). Também a escolha 'prederror: false' não traduzirá.

     'savedef' - se 'true' fará com que a versão Maxima de uma função
     usuário permaneça quando a função é traduzida com 'translate'.
     Isso permite a que definição seja mostrada por 'dispfun' e autoriza
     a função a ser editada.

     'transrun' - se 'false' fará com que a versão interpretada de todas
     as funções sejam executadas (desde que estejam ainda disponíveis)
     em lugar da versão traduzida.

     O resultado retornado por 'translate' é uma lista de nomes de
     funções traduzidas.

 -- Função: translate_file (<maxima_nomearquivo>)
 -- Função: translate_file (<maxima_nomearquivo>, <lisp_nomearquivo>)
     Traduz um arquivo com código Maxima para um arquivo com código
     Lisp.  'translate_file' retorna uma lista de três nomes de arquivo:
     O nome do arquivo Maxima, o nome do arquivo Lisp, e o nome do
     arquivo contendo informações adicionais sobre a tradução.
     'translate_file' avalia seus argumentos.

     'translate_file ("foo.mac"); load("foo.LISP")' é o mesmo que 'batch
     ("foo.mac")' exceto por certas restrições, o uso de '''' e '%', por
     exemplo.

     'translate_file (<maxima_nomearquivo>)' traduz um arquivo Maxima
     <maxima_nomearquivo> para um similarmente chamado arquivo Lisp.
     Por exemplo, 'foo.mac' é traduzido em 'foo.LISP'.  O nome de
     arquivo Maxima pod incluir nome ou nomes de diretório(s), nesse
     caso o arquivo de saída Lisp é escrito para o mesmo diretório que a
     entrada Maxima.

     'translate_file (<maxima_nomearquivo>, <lisp_nomearquivo>)' traduz
     um arquivo Maxima <maxima_nomearquivo> em um arquivo Lisp
     <lisp_nomearquivo>.  'translate_file' ignora a extensão do nome do
     arquivo, se qualquer, de 'lisp_nomearquivo'; a extensão do arquivo
     de saída Lisp é sempre 'LISP'.  O nome de arquivo Lisp pode incluir
     um nome ou nomes de diretórios), nesse caso o arquivo de saída Lisp
     é escrito para o diretório especificado.

     'translate_file' também escreve um arquivo de mensagens de alerta
     do tradutor em vários graus de severidade.  A extensão do nome de
     arquivo desse arquivo é 'UNLISP'.  Esse arquivo pode conter
     informação valiosa, apesar de possivelmente obscura, para rastrear
     erros no código traduzido.  O arquivo 'UNLISP' é sempre escrito
     para o mesmo diretório que a entrada Maxima.

     'translate_file' emite código Lisp o qual faz com que algumas
     definições tenham efeito tão logo o código Lisp é compilado.  Veja
     'compile_file' para mais sobre esse tópico.

     Veja também 'tr_array_as_ref', 'tr_bound_function_applyp',
     'tr_exponent', 'tr_file_tty_messagesp',
     'tr_float_can_branch_complex', 'tr_function_call_default',
     'tr_numer', 'tr_optimize_max_loop', 'tr_semicompile',
     'tr_state_vars', 'tr_warnings_get', 'tr_warn_bad_function_calls',
     'tr_warn_fexpr', 'tr_warn_meval', 'tr_warn_mode',
     'tr_warn_undeclared', e 'tr_warn_undefined_variable'.

 -- Variável de opção: transrun
     Valor padrão: 'true'

     Quando 'transrun' é 'false' fará com que a versão interpretada de
     todas as funções sejam executadas (desde que estejam ainda
     disponíveis) em lugar de versão traduzidas.

 -- Variável de opção: tr_array_as_ref
     Valor padrão: 'true'

     Se 'translate_fast_arrays' for 'false', referências a arrays no
     Código Lisp emitidas por 'translate_file' são afetadas por
     'tr_array_as_ref'.  Quando 'tr_array_as_ref' é 'true', nomes de
     arrays são avaliados, de outra forma nomes de arrays aparecem como
     símbolos literais no código traduzido.

     'tr_array_as_ref' não terão efeito se 'translate_fast_arrays' for
     'true'.

 -- Variável de opção: tr_bound_function_applyp
     Valor padrão: 'true'

     Quando 'tr_bound_function_applyp' for 'true', Maxima emite um
     alerta se uma associação de variável (tal como um argumento de
     função) é achada sendo usada como uma função.
     +'tr_bound_function_applyp' não afeta o código gerado em tais
     casos.

     Por exemplo, uma expressão tal como 'g (f, x) := f (x+1)' irá
     disparar a mensagem de alerta.

 -- Variável de opção: tr_file_tty_messagesp
     Valor padrão: 'false'

     Quando 'tr_file_tty_messagesp' é 'true', messagens geradas por
     'translate_file' durante a tradução de um arquivo são mostradas
     sobre o console e inseridas dentro do arquivo UNLISP. Quando
     'false', messagens sobre traduções de arquivos são somente
     inseridas dentro do arquivo UNLISP.

 -- Variável de opção: tr_float_can_branch_complex
     Valor padrão: 'true'

     Diz ao tradutor Maxima-para-Lisp assumir que as funções 'acos',
     'asin', 'asec', e 'acsc' podem retornar resultados complexos.

     O efeito ostensivo de 'tr_float_can_branch_complex' é mostrado
     adiante.  Todavia, parece que esse sinalizador não tem efeito sobre
     a saída do tradutor.

     Quando isso for 'true' então 'acos(x)' será do modo 'any' sempre
     que 'x' for do modo 'float' (como escolhido por 'mode_declare').
     Quando 'false' então 'acos(x)' será do modo 'float' se e somente se
     'x' for do modo 'float'.

 -- Variável de opção: tr_function_call_default
     Valor padrão: 'general'

     'false' significa abandonando e chamando 'meval', 'expr' significa
     que Lisp assume função de argumento fixado.  'general', o código
     padrão dado como sendo bom para 'mexprs' e 'mlexprs' mas não
     'macros'.  'general' garante que associações de variável são
     corretas em códigos compilados.  No modo 'general', quando
     traduzindo F(X), se F for uma variável associada, então isso
     assumirá que 'apply (f, [x])' é significativo, e traduz como tal,
     com o alerta apropriado.  Não é necessário desabilitar isso.  Com
     as escolhas padrão, sem mensagens de alerta implica compatibilidade
     total do código traduzido e compilado com o interpretador Maxima.

 -- Variável de opção: tr_numer
     Valor padrão: 'false'

     Quando 'tr_numer' for 'true' propriedades 'numer' são usadas para
     átomos que possuem essa propriedade, e.g.  '%pi'.

 -- Variável de opção: tr_optimize_max_loop
     Valor padrão: 100

     'tr_optimize_max_loop' é número máximo de vezes do passo de
     macro-expansão e otimização que o tradutor irá executar
     considerando uma forma.  Isso é para capturar erros de expansão de
     macro, e propriedades de otimização não terminadas.

 -- Variável de opção: tr_semicompile
     Valor padrão: 'false'

     Quando 'tr_semicompile' for 'true', as formas de saída de
     'translate_file' e 'compfile' serão macroexpandidas mas não
     compiladas em código de máquina pelo compilador Lisp.

 -- Variável de sistema: tr_state_vars
     Valor padrão:
          [transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
          tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
          tr_function_call_default, tr_array_as_ref,tr_numer]

     A lista de comutadores que afetam a forma de saída da tradução.
     Essa informação é útil para sistemas populares quando tentam
     depurar o tradutor.  Comparando o produto traduzido para o qual
     pode ter sido produzido por um dado estado, isso é possível para
     rastrear erros.

 -- Função: tr_warnings_get ()
     Imprime uma lista de alertas que podem ter sido dadas pelo tradutor
     durante a tradução corrente.

 -- Variável de opção: tr_warn_bad_function_calls
     Valor padrão: 'true'

     - Emite um alerta quando chamadas de função estão sendo feitas por
     um caminho que pode não ser correto devido a declarações impróprias
     que foram feitas em tempo de tradução.

 -- Variável de opção: tr_warn_fexpr
     Valor padrão: 'compfile'

     - Emite um alerta se quaisquer FEXPRs forem encontradas.  FEXPRs
     não poderão normalmente ser saída em código traduzido, todas as
     formas de programa especial legítimo são traduzidas.

 -- Variável: tr_warn_meval
     Valor padrão: 'compfile'

     - Emite um alerta se a função 'meval' recebe chamadas.  Se 'meval'
     é chamada isso indica problemas na tradução.

 -- Variável: tr_warn_mode
     Valor padrão: 'all'

     - Emite um alerta quando a variáveis forem atribuídos valores
     inapropriados para seu modo.

 -- Variável de opção: tr_warn_undeclared
     Valor padrão: 'compile'

     - Determina quando enviar alertas sobre variáveis não declaradas
     para o TTY.

 -- Variável de opção: tr_warn_undefined_variable
     Valor padrão: 'all'

     - Emite um alerta quando variáveis globais indefinidas forem
     vistas.

 -- Função: compile_file (<nomearquivo>)
 -- Função: compile_file (<nomearquivo>, <nomearquivo_compilado>)
 -- Função: compile_file (<nomearquivo>, <nomearquivo_compilado>,
          <lisp_nomearquivo>)
     Traduz o arquivo Maxima <nomearquivo> para Lisp, executa o
     compilador Lisp, e, se a tradução e a compilação obtiverem sucesso,
     chama o código compilado dentro do Maxima.

     'compile_file' retorna uma lista dos nomes de quatro arquivos: o
     arquivo original do Maxima, o nome da tradução Lisp, uma arquivo de
     notas sobre a tradução, e o nome do arquivo que contém o código
     compilado.  Se a compilação falhar, o quarto item é 'false'.

     Algumas declarações e definições passam a ter efeito tão logo o
     código Lisp seja compilado (sem que seja necessário chamar o código
     compilado).  Isso inclui funções definidas com o operador ':=',
     macros definidas com o operador '::=', 'alias', 'declare',
     'define_variable', 'mode_declare', e 'infix', 'matchfix', 'nofix',
     'postfix', 'prefix', e 'compfile'.

     Atribuições e chamadas de função não serão avaliadas até que o
     código compilado seja carregado.  Em particular, dentro do arquivo
     Maxima, atribuições para sinalizadores traduzidos ('tr_numer',
     etc.)  não têm efeito sobre a tradução.

     <nomearquivo> pode não conter declarações ':lisp'.

     'compile_file' avalia seus argumentos.

 -- Função: declare_translated (<f_1>, <f_2>, ...)
     Quando traduzindo um arquivo do código Maxima para Lisp, é
     importante para o programa tradutor saber quais funções no arquivo
     são para serem chamadas como funções traduzidas ou compiladas, e
     quais outras são apenas funções Maxima ou indefinidas.  Colocando
     essa declaração no topo do arquivo, faremos conhecido que embora um
     símbolo diga que não temos ainda um valor de função Lisp, teremos
     uma em tempo de chamada.  '(MFUNCTION-CALL fn arg1 arg2 ...)' é
     gerado quando o tradutor n~ao sabe que 'fn' está sendo compilada
     para ser uma função Lisp.


File: maxima.info,  Node: Fluxo de Programa,  Next: Depurando,  Prev: Definição de Função,  Up: Top

40 Fluxo de Programa
********************

* Menu:

* Introdução a Fluxo de Programa::  
* Funções e Variáveis Definidas para Fluxo de Programa::  


File: maxima.info,  Node: Introdução a Fluxo de Programa,  Next: Funções e Variáveis Definidas para Fluxo de Programa,  Prev: Fluxo de Programa,  Up: Fluxo de Programa

40.1 Introdução a Fluxo de Programa
===================================

Maxima fornece um 'do' para ciclos iterativos, também contruções mais
primitivas tais como 'go'.


File: maxima.info,  Node: Funções e Variáveis Definidas para Fluxo de Programa,  Prev: Introdução a Fluxo de Programa,  Up: Fluxo de Programa

40.2 Funções e Variáveis Definidas para Fluxo de Programa
=========================================================

 -- Função: backtrace ()
 -- Função: backtrace (<n>)
     Imprime a pilha de chamadas, que é, a lista de funções que foram
     chamadas pela função correntemente ativa.

     'backtrace()' imprime toda a pilha de chamadas.

     'backtrace (<n>)' imprime as <n> mais recentes chamadas a funções,
     incluindo a função correntemente ativa.

     'backtrace' pode ser chamada por um script, uma função, ou a partir
     da linha de comando interativa (não somente em um contexto de
     depuração).

     Exemplos:

        * 'backtrace()' imprime toda a pilha de chamadas.

               (%i1) h(x) := g(x/7)$
               (%i2) g(x) := f(x-11)$
               (%i3) f(x) := e(x^2)$
               (%i4) e(x) := (backtrace(), 2*x + 13)$
               (%i5) h(10);
               #0: e(x=4489/49)
               #1: f(x=-67/7)
               #2: g(x=10/7)
               #3: h(x=10)
                                             9615
               (%o5)                         ----
                                              49

        * 'backtrace (<n>)' imprime as <n> mais recentes chamadas a
          funções, incluindo a função correntemente ativa.

               (%i1) h(x) := (backtrace(1), g(x/7))$
               (%i2) g(x) := (backtrace(1), f(x-11))$
               (%i3) f(x) := (backtrace(1), e(x^2))$
               (%i4) e(x) := (backtrace(1), 2*x + 13)$
               (%i5) h(10);
               #0: h(x=10)
               #0: g(x=10/7)
               #0: f(x=-67/7)
               #0: e(x=4489/49)
                                             9615
               (%o5)                         ----
                                              49

 -- Operador especial: do
     A declaração 'do' é usada para executar iteração.  Devido à sua
     grande generalidade a declaração 'do' será descrita em duas partes.
     Primeiro a forma usual será dada que é análoga à forma que é usada
     em muitas outras linguagens de programação (Fortran, Algol, PL/I,
     etc.); em segundo lugar os outros recursos serão mencionados.

     Existem três variantes do operador especial 'do' que diferem
     somente por suas condições de encerramento.  São elas:

        * 'for <Variável>: <valor_inicial> step <incremento> thru
          <limite> do <corpo>'
        * 'for <Variável>: <valor_inicial> step <incremento> while
          <condição> do <corpo>'
        * 'for <Variável>: <valor_inicial> step <incremento> unless
          <condição> do <corpo>'

     (Alternativamente, o 'step' pode ser dado após a <condição> de
     encerramento ou limite.)

     <valor_inicial>, <incremento>, <limite>, e <corpo> podem ser
     quaisquer expressões.  Se o incremento for 1 então "'step 1'" pode
     ser omitido.

     A execução da declaração 'do' processa-se primeiro atribuindo o
     'valor_inicial' para a variável (daqui em diante chamada a variável
     de controle).  Então: (1) Se a variável de controle excede o limite
     de uma especificação 'thru', ou se a condição de 'unless' for
     'true', ou se a condição de 'while' for 'false' então o 'do' será
     encerrado.  (2) O <corpo> é avaliado.  (3) O incremento é
     adicionado à variável de controle.  O processo de (1) a (3) é
     executado repetidamente até que a condição de encerramento seja
     satisfeita.  Pode-se também dar muitas condições de encerramento e
     nesse caso o 'do' termina quando qualquer delas for satisfeita.

     Em geral o teste 'thru' é satisfeito quando a variável de controle
     for maior que o <limite> se o incremento for não negativo, ou
     quando a variável de controle for menor que o <limite> se o
     <incremento> for negativo.  O <incremento> e o <limite> podem ser
     expressões não numéricas enquanto essa desigualdade puder ser
     determinada.  Todavia, a menos que o <incremento> seja
     sintaticamente negativo (e.g.  for um número negativo) na hora em
     que a declaração 'do' for iniciada, Maxima assume que o incremento
     e o limite serão positivos quando o 'do' for executado.  Se o
     limite e o incremento não forem positivos, então o 'do' pode não
     terminar propriamente.

     Note que o <limite>, <incremento>, e <condição> de encerramento são
     avaliados cada vez que ocorre um ciclo.  Dessa forma se qualquer
     desses for responsável por muitos cálculos, e retornar um resultado
     que não muda durante todas as execuções do <corpo>, então é mais
     eficiente escolher uma variável para seu valor prévio para o 'do' e
     usar essa variável na forma 'do'.

     O valor normalmente retornado por uma declaração 'do' é o átomo
     'done'.  Todavia, a função 'return' pode ser usada dentro do
     <corpo> para sair da delcaração 'do' prematuramente e dar a isso
     qualquer valor desejado.  Note todavia que um 'return' dentro de um
     'do' que ocorre em um 'block' encerrará somente o 'do' e não o
     'block'.  Note também que a função 'go' não pode ser usada para
     sair de dentro de um 'do' dentro de um 'block' que o envolve.

     A variável de controle é sempre local para o 'do' e dessa forma
     qualquer variável pode ser usada sem afetar o valor de uma variável
     com o mesmo nome fora da declaração 'do'.  A variável de controle é
     liberada após o encerramento da declaração 'do'.

          (%i1) for a:-3 thru 26 step 7 do display(a)$
                                       a = - 3

                                        a = 4

                                       a = 11

                                       a = 18

                                       a = 25

          (%i1) s: 0$
          (%i2) for i: 1 while i <= 10 do s: s+i;
          (%o2)                         done
          (%i3) s;
          (%o3)                          55

     Note que a condição 'while i <= 10' é equivalente a 'unless i > 10'
     e também 'thru 10'.

          (%i1) series: 1$
          (%i2) term: exp (sin (x))$
          (%i3) for p: 1 unless p > 7 do
                    (term: diff (term, x)/p,
                     series: series + subst (x=0, term)*x^p)$
          (%i4) series;
                            7    6     5    4    2
                           x    x     x    x    x
          (%o4)            -- - --- - -- - -- + -- + x + 1
                           90   240   15   8    2

     que fornece 8 termos da série de Taylor para 'e^sin(x)'.

          (%i1) poly: 0$
          (%i2) for i: 1 thru 5 do
                    for j: i step -1 thru 1 do
                        poly: poly + i*x^j$
          (%i3) poly;
                            5      4       3       2
          (%o3)          5 x  + 9 x  + 12 x  + 14 x  + 15 x
          (%i4) guess: -3.0$
          (%i5) for i: 1 thru 10 do
                    (guess: subst (guess, x, 0.5*(x + 10/x)),
                     if abs (guess^2 - 10) < 0.00005 then return (guess));
          (%o5)                  - 3.162280701754386

     Esse exemplo calcula a raíz quadrada negativa de 10 usando a
     iteração de Newton- Raphson um maximum de 10 vezes.  Caso o
     critério de convergêcia não tenha sido encontrado o valor retornado
     pode ser 'done'.  Em lugar de sempre adicionar uma quantidade à
     variável de controle pode-se algumas vezes desejar alterar isso de
     alguma outra forma para cada iteração.  Nesse caso pode-se usar
     'next <expressão>' em lugar de 'step <incremento>'.  Isso fará com
     que a variável de controle seja escolhida para o resultado de
     avaliação da <expressão> cada vez que o ciclo de repetição for
     executado.

          (%i6) for count: 2 next 3*count thru 20 do display (count)$
                                      count = 2

                                      count = 6

                                     count = 18

     Como uma alternativa para 'for <Variável>: <valor> ...do...' a
     sintaxe 'for <Variável> from <valor> ...do...' pode ser usada.
     Isso permite o 'from <valor>' ser colocado após o 'step' ou após o
     <next> valor ou após a <condição> de encerramento.  Se 'from
     <valor>' for omitido então 1 é usado como o valor inicial.

     Algumas vezes se pode estar interessado em executar uma iteração
     onde a variável de controle nunca seja usada.  Isso é permissível
     para dar somente as condições de encerramento omitindo a
     inicialização e a informação de atualização como no exemplo
     seguinte para para calcular a raíz quadrada de 5 usando uma fraca
     suposição inicial.

          (%i1) x: 1000$
          (%i2) thru 20 do x: 0.5*(x + 5.0/x)$
          (%i3) x;
          (%o3)                   2.23606797749979
          (%i4) sqrt(5), numer;
          (%o4)                   2.23606797749979

     Se isso for desejado pode-se sempre omitir as condições de
     encerramento inteiramente e apenas dar o 'do <corpo>' que o <corpo>
     continuará a ser avaliado indefinidamente.  Nesse caso a função
     'return' será usada para encerrar a execução da declaração 'do'.

          (%i1) newton (f, x):= ([y, df, dfx], df: diff (f ('x), 'x),
                    do (y: ev(df), x: x - f(x)/y,
                        if abs (f (x)) < 5e-6 then return (x)))$
          (%i2) sqr (x) := x^2 - 5.0$
          (%i3) newton (sqr, 1000);
          (%o3)                   2.236068027062195

     (Note que 'return', quando executado, faz com que o valor corrente
     de 'x' seja retornado como o valor da declaração 'do'.  O 'block' é
     encerrado e esse valor da declaração 'do' é retornado como o valor
     do 'block' porque o 'do' é a última declaração do 'block'.)

     Uma outra forma de 'do' é disponível no Maxima.  A sintaxe é:

          for <Variável> in <list> <end_tests> do <corpo>

     Os elementos de <list> são quaisquer expressões que irão
     sucessivamente ser atribuídas para a <variável> a cada iteração do
     <corpo>.  O teste opcional <end_tests> pode ser usado para encerrar
     a execução da declaração 'do'; de outra forma o 'do' terminará
     quando a <lista> for exaurida ou quando um 'return' for executado
     no <corpo>.  (De fato, a <lista> pode ser qualquer expressão não
     atômica, e partes sucessivas são usadas.)

          (%i1)  for f in [log, rho, atan] do ldisp(f(1))$
          (%t1)                                  0
          (%t2)                                rho(1)
                                               %pi
          (%t3)                                 ---
                                                4
          (%i4) ev(%t3,numer);
          (%o4)                             0.78539816

 -- Função: errcatch (<expr_1>, ..., <expr_n>)
     Avalia <expr_1>, ..., <expr_n> uma por uma e retorna '[<expr_n>]'
     (uma lista) se nenhum erro ocorrer.  Se um erro ocorrer na
     avaliação de qualquer argumento, 'errcatch' evita que o erro se
     propague e retorna a lista vazia '[]' sem avaliar quaisquer mais
     argumentos.

     'errcatch' é útil em arquivos 'batch' onde se suspeita que um erro
     possa estar ocorrendo o 'errcatch' terminará o 'batch' se o erro
     não for detectado.

 -- Função: error (<expr_1>, ..., <expr_n>)
 -- Variável de sistema: error
     Avalia e imprime <expr_1>, ..., <expr_n>, e então causa um retorno
     de erro para o nível mais alto do Maxima ou para o mais próximo
     contendo 'errcatch'.

     A variável 'error' é escolhida para uma lista descrevendo o erro.
     O primeiro elemento de 'error' é uma seqüência de caracteres de
     formato, que junta todas as seqüências de caracteres entre os
     argumentos <expr_1>, ..., <expr_n>, e os elementos restantes são os
     valores de quaisquer argumentos que não são seqüências de
     caracteres.

     'errormsg()' formata e imprime 'error'.  Isso efetivamente
     reimprime a mais recente mensagem de erro.

 -- Função: errormsg ()
     Reimprime a mais recente mensagem de erro.  A variável 'error'
     recebe a mensagem, e 'errormsg' formata e imprime essa mensagem.

 -- Operador especial: for
     Usado em iterações.  Veja 'do' para uma descrição das facilidades
     de iteração do Maxima.

 -- Função: go (<tag>)
     é usada dentro de um 'block' para transferir o controle para a
     declaração do bloco que for identificada com o argumento para 'go'.
     Para identificar uma declaração, coloque antes dessa declaração um
     argumento atômico como outra declaração no 'block'.  Por exemplo:

          block ([x], x:1, loop, x+1, ..., go(loop), ...)

     O argumento para 'go' deve ser o nome de um identificardor
     aparecendo no mesmo 'block'.  Não se pode usar 'go' para transferir
     para um identificador em um outro 'block' que não seja o próprio
     contendo o 'go'.

 -- Operador especial: if
     Representa avaliação condicional.  Várias formas de expressões 'if'
     são reconhecidas.  'if <cond_1> then <expr_1> else <expr_0>' avalia
     para <expr_1> se <cond_1> avaliar para 'true', de outra forma a
     expressão avalia para 'expr_0'.

     'if <cond_1> then <expr_1> elseif <cond_2> then <expr_2> elseif ...
     else <expr_0>' avalia para <expr_k> se <cond_k> for 'true' e todas
     as condições precedentes forem 'false'.  Se nenhuma das condições
     forem 'true', a expressão avalia para 'expr_0'.

     O comportamento 'else false' é assumido se 'else' for omitido.
     Isso é, 'if <cond_1> then <expr_1>' é equivalente a 'if <cond_1>
     then <expr_1> else false', e 'if <cond_1> then <expr_1> elseif ...
     elseif <cond_n> then <expr_n>' é equivalente a 'if <cond_1> then
     <expr_1> elseif ... elseif <cond_n> then <expr_n> else false'.

     As alternativas <expr_0>, ..., <expr_n> podem ser quaisquer
     expressões do Maxima, incluíndo expressões 'if' aninhadas ( if
     dentro de if).  As alternativas não são nem simplificadas nem
     avaliadas a menos que a correspondente condição seja 'true'.

     As condições <cond_1>, ..., <cond_n> são expressões as quais
     potencialmente ou atualmente avaliem para 'true' ou para 'false'.
     Quando uma condição não avalia atualmente para para 'true' ou para
     'false', o comportamento de 'if' é governado pelo sinalizador
     global 'prederror'.  Quando 'prederror' for 'true', isso é um erro
     se qualquer condição avaliada não avaliar para 'true' ou 'false'.
     De outra forma, condições que não avaliem para 'true' ou 'false'
     são aceitas, e o resultado é uma expressão condicional.

     Entre outros elementos, condições podem compreender operadores
     lógicos e relacionais como segue.

          Operação             Símbolo      Tipo

          menor que            <           infixo relacional
          menor que            <=
            ou igual a                     infixo relacional
          igualdade            =
            (sintática)                    infixo relacional
          negação de =         #           infixo relacional
          igualdade (valor)    equal       função relacional
          negação de           notequal
            igualdade                      função relacional
          maior que            >=
            ou igual a                     infixo relacional
          maior que            >           infixo relacional
          e                    and         infixo lógico
          ou                   or          infixo lógico
          não                  not         prefixo lógico

 -- Função: map (<f>, <expr_1>, ..., <expr_n>)
     Retorna uma expressão cujo operador principal é o mesmo que o das
     expressões <expr_1>, ..., <expr_n> mas cujas subpartes são os
     resultados da aplicação de <f> nas correspondentes subpartes das
     expressões.  <f> é ainda o nome de uma função de n argumentos ou é
     uma forma 'lambda' de n argumentos.

     'maperror' - se 'false' fará com que todas as funções mapeadas (1)
     parem quando elas terminarem retornando a menor <exp_i> se não
     forem todas as <exp_i> do mesmo comprimento e (2) aplique fn a
     [exp1, exp2,...]  se <exp_i> não forem todas do mesmo tipo de
     objeto.  Se 'maperror' for 'true' então uma mensagem de erro será
     dada nas duas instâncias acima.

     Um dos usos dessa função é para mapear ('map') uma função (e.g.
     'partfrac') sobre cada termo de uma expressão muito larga onde isso
     comumente não poderia ser possível usar a função sobre a expressão
     inteira devido a uma exaustão de espaço da lista de armazenamento
     no decorrer da computação.

          (%i1) map(f,x+a*y+b*z);
          (%o1)                        f(b z) + f(a y) + f(x)
          (%i2) map(lambda([u],partfrac(u,x)),x+1/(x^3+4*x^2+5*x+2));
                                     1       1        1
          (%o2)                     ----- - ----- + -------- + x
                                   x + 2   x + 1          2
                                                   (x + 1)
          (%i3) map(ratsimp, x/(x^2+x)+(y^2+y)/y);
                                                1
          (%o3)                            y + ----- + 1
                                              x + 1
          (%i4) map("=",[a,b],[-0.5,3]);
          (%o4)                          [a = - 0.5, b = 3]


 -- Função: mapatom (<expr>)
     Retorna 'true' se e somente se <expr> for tratada pelas rotinas de
     mapeamento como um átomo.  "Mapatoms" são átomos, números
     (incluíndo números racioanais), e variáveis subscritas.

 -- Variável de opção: maperror
     Valor padrão: 'true'

     Quando 'maperror' é 'false', faz com que todas as funções mapeadas,
     por exemplo

          map (f, <expr_1>, <expr_2>, ...)

     para (1) parar quando elas terminarem retornando a menor <exp_i> se
     não forem todas as <exp_i> do mesmo comprimento e (2) aplique 'f' a
     '[<expr_1>, <expr_2>, ...]' se 'expr_i' não forem todas do mesmo
     tipo de objeto.

     Se 'maperror' for 'true' então uma ,mensagem de erro é mostrada nas
     duas instâncias acima.

 -- Função: maplist (<f>, <expr_1>, ..., <expr_n>)
     Retorna uma lista de aplicações de <f> em todas as partes das
     expressões <expr_1>, ..., <expr_n>.  <f> é o nome de uma função, ou
     uma expressão lambda.

     'maplist' difere de 'map (<f>, <expr_1>, ..., <expr_n>)' que
     retorna uma expressão com o mesmo operador principal que <expr_i>
     tem (exceto para simplificações e o caso onde 'map' faz um
     'apply').

 -- Variável de opção: prederror
     Valor padrão: 'true'

     Quando 'prederror' for 'true', uma mensagem de erro é mostrada
     sempre que o predicado de uma declaração 'if' ou uma função 'is'
     falha em avaliar ou para 'true' ou para 'false'.

     Se 'false', 'unknown' é retornado no lugar nesse caso.  O modo
     'prederror: false' não é suportado no código traduzido; todavia,
     'maybe' é suportado no código traduzido.

     Veja também 'is' e 'maybe'.

 -- Função: return (<valor>)
     Pode ser usada para sair explicitamente de um bloco, levando seu
     argumento.  Veja 'block' para mais informação.

 -- Função: scanmap (<f>, <expr>)
 -- Função: scanmap (<f>, <expr>, bottomup)
     Recursivamente aplica <f> a <expr>, de cima para baixo.  Isso é
     muito útil quando uma fatoração completa é desejada, por exemplo:

          (%i1) exp:(a^2+2*a+1)*y + x^2$
          (%i2) scanmap(factor,exp);
                                              2      2
          (%o2)                         (a + 1)  y + x

     Note o caminho através do qual 'scanmap' aplica a dada função
     'factor' para as subexpressões constituintes de <expr>; se outra
     forma de <expr> é apresentada para 'scanmap' então o resultado pode
     ser diferente.  Dessa forma, '%o2' não é recuperada quando
     'scanmap' é aplicada para a forma expandida de <exp>:

          (%i3) scanmap(factor,expand(exp));
                                     2                  2
          (%o3)                      a  y + 2 a y + y + x

     Aqui está um outro exemplo do caminho no qual 'scanmap' aplica
     recursivamente uma função dada para todas as subexpressões,
     incluindo expoentes:

          (%i4) expr : u*v^(a*x+b) + c$
          (%i5) scanmap('f, expr);
                              f(f(f(a) f(x)) + f(b))
          (%o5) f(f(f(u) f(f(v)                      )) + f(c))

     'scanmap (<f>, <expr>, bottomup)' aplica <f> a <expr> de baixo para
     cima.  E.g., para 'f' indefinida,

          scanmap(f,a*x+b) ->
             f(a*x+b) -> f(f(a*x)+f(b)) -> f(f(f(a)*f(x))+f(b))
          scanmap(f,a*x+b,bottomup) -> f(a)*f(x)+f(b)
              -> f(f(a)*f(x))+f(b) ->
               f(f(f(a)*f(x))+f(b))

     Nesse caso, você pega a mesma resposta em ambos os caminhos.

 -- Função: throw (<expr>)
     Avalia <expr> e descarta o valor retornado para o mais recente
     'catch'.  'throw' é usada com 'catch' como um mecanismo de retorno
     não local.

 -- Operador especial: while
     Veja 'do'.

 -- Função: outermap (<f>, <a_1>, ..., <a_n>)
     Aplica a função <f> para cada um dos elementos do produto externo
     <a_1> vezes <a_2> ...  vezes <a_n>.

     <f> é o nome de uma função de n argumentos ou uma expressão lambda
     de n argumentos.  Cada argumento <a_k> pode ser uma lista simples
     ou lista aninhada ( lista contendo listas como elementos ), ou uma
     matrz, ou qualquer outro tip de expressão.

     O valor de retorno de 'outermap' é uma estrutura aninhada.  Tomemos
     <x> como sendo o valor de retorno.  Então <x> tem a mesma estrutura
     da primeira lista, lista aninhada, ou argumento matriz,
     '<x>[i_1]...[i_m]' tem a mesma estrutura que a segunda lista, lista
     aninhada, ou argumento matriz, '<x>[i_1]...[i_m][j_1]...[j_n]' tem
     a mesma estrutura que a terceira lista, lista aninhada, ou
     argumento matriz, e assim por diante, onde <m>, <n>, ...  são os
     números dos índices requeridos para acessar os elementos de cada
     argumento (um para uma lista, dois para uma matriz, um ou mais para
     uma lista aninhada).  Argumentos que não forem listas ou matrizes
     não afetam a estrutura do valor de retorno.

     Note que o efeito de 'outermap' é diferente daquele de aplicar <f>
     a cada um dos elementos do produto externo retornado por
     'cartesian_product'.  'outermap' preserva a estrutura dos
     argumentos no valor de retorno, enquanto 'cartesian_product' não
     reserva essa mesma estrutura.

     'outermap' avalia seus argumentos.

     Veja também 'map', 'maplist', e 'apply'.

     Exemplos: Exemplos elementares de 'outermap'.  Para mostrar a a
     combinação de argumentos mais claramente, 'F' está indefinida à
     esquerda.

          (%i1) outermap (F, [a, b, c], [1, 2, 3]);
          (%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)],
                                               [F(c, 1), F(c, 2), F(c, 3)]]
          (%i2) outermap (F, matrix ([a, b], [c, d]), matrix ([1, 2], [3, 4]));
                   [ [ F(a, 1)  F(a, 2) ]  [ F(b, 1)  F(b, 2) ] ]
                   [ [                  ]  [                  ] ]
                   [ [ F(a, 3)  F(a, 4) ]  [ F(b, 3)  F(b, 4) ] ]
          (%o2)    [                                            ]
                   [ [ F(c, 1)  F(c, 2) ]  [ F(d, 1)  F(d, 2) ] ]
                   [ [                  ]  [                  ] ]
                   [ [ F(c, 3)  F(c, 4) ]  [ F(d, 3)  F(d, 4) ] ]
          (%i3) outermap (F, [a, b], x, matrix ([1, 2], [3, 4]));
                 [ F(a, x, 1)  F(a, x, 2) ]  [ F(b, x, 1)  F(b, x, 2) ]
          (%o3) [[                        ], [                        ]]
                 [ F(a, x, 3)  F(a, x, 4) ]  [ F(b, x, 3)  F(b, x, 4) ]
          (%i4) outermap (F, [a, b], matrix ([1, 2]), matrix ([x], [y]));
                 [ [ F(a, 1, x) ]  [ F(a, 2, x) ] ]
          (%o4) [[ [            ]  [            ] ],
                 [ [ F(a, 1, y) ]  [ F(a, 2, y) ] ]
                                        [ [ F(b, 1, x) ]  [ F(b, 2, x) ] ]
                                        [ [            ]  [            ] ]]
                                        [ [ F(b, 1, y) ]  [ F(b, 2, y) ] ]
          (%i5) outermap ("+", [a, b, c], [1, 2, 3]);
          (%o5) [[a + 1, a + 2, a + 3], [b + 1, b + 2, b + 3],
                                                     [c + 1, c + 2, c + 3]]

     Uma explanação final do valor de retorno de 'outermap'.  Os
     argumentos primeiro, segundo, e terceiro são matriz, lista, e
     matriz, respectivamente.  O valor de retorno é uma matriz.  Cada
     elementos daquela matriz é uma lista, e cada elemento de cada lista
     é uma matriz.

          (%i1) arg_1 :  matrix ([a, b], [c, d]);
                                      [ a  b ]
          (%o1)                       [      ]
                                      [ c  d ]
          (%i2) arg_2 : [11, 22];
          (%o2)                       [11, 22]
          (%i3) arg_3 : matrix ([xx, yy]);
          (%o3)                      [ xx  yy ]
          (%i4) xx_0 : outermap (lambda ([x, y, z], x / y + z), arg_1, arg_2, arg_3);
                         [  [      a        a  ]  [      a        a  ]  ]
                         [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                         [  [      11       11 ]  [      22       22 ]  ]
          (%o4)  Col 1 = [                                              ]
                         [  [      c        c  ]  [      c        c  ]  ]
                         [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                         [  [      11       11 ]  [      22       22 ]  ]
                           [  [      b        b  ]  [      b        b  ]  ]
                           [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                           [  [      11       11 ]  [      22       22 ]  ]
                   Col 2 = [                                              ]
                           [  [      d        d  ]  [      d        d  ]  ]
                           [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                           [  [      11       11 ]  [      22       22 ]  ]
          (%i5) xx_1 : xx_0 [1][1];
                     [      a        a  ]  [      a        a  ]
          (%o5)     [[ xx + --  yy + -- ], [ xx + --  yy + -- ]]
                     [      11       11 ]  [      22       22 ]
          (%i6) xx_2 : xx_0 [1][1] [1];
                                [      a        a  ]
          (%o6)                 [ xx + --  yy + -- ]
                                [      11       11 ]
          (%i7) xx_3 : xx_0 [1][1] [1] [1][1];
                                            a
          (%o7)                        xx + --
                                            11
          (%i8) [op (arg_1), op (arg_2), op (arg_3)];
          (%o8)                  [matrix, [, matrix]
          (%i9) [op (xx_0), op (xx_1), op (xx_2)];
          (%o9)                  [matrix, [, matrix]

     'outermap' preserves the structure of the arguments in the return
     value, while 'cartesian_product' does not.

          (%i1) outermap (F, [a, b, c], [1, 2, 3]);
          (%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)],
                                               [F(c, 1), F(c, 2), F(c, 3)]]
          (%i2) setify (flatten (%));
          (%o2) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3),
                                                 F(c, 1), F(c, 2), F(c, 3)}
          (%i3) map (lambda ([L], apply (F, L)), cartesian_product ({a, b, c}, {1, 2, 3}));
          (%o3) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3),
                                                 F(c, 1), F(c, 2), F(c, 3)}
          (%i4) is (equal (%, %th (2)));
          (%o4)                         true


File: maxima.info,  Node: Depurando,  Next: augmented_lagrangian,  Prev: Fluxo de Programa,  Up: Top

41 Depurando
************

* Menu:

* Depurando o Código Fonte::
* Comandos Palavra Chave::
* Funções e Variáveis Definidas para Depuração::   


File: maxima.info,  Node: Depurando o Código Fonte,  Next: Comandos Palavra Chave,  Up: Depurando

41.1 Depurando o Código Fonte
=============================

Maxima tem um depurador interno de código fonte.  O usuário pode
escolher um ponto de parada em uma função, e então caminhar linha por
linha a partir daí.  A pilha de chamadas po ser examinada, juntamente
com as variáveis associadas àquele nível.

   O comando ':help' ou ':h' mostra a lista de comando de depuração.
(Em geral, comandos podem ser abreviados se a abreviação for única.  Se
não for única, as alternativas podem ser listadas.)  Dentro do
depurador, o usuário pode também usar qualquer funções comuns do Maxima
para examinar, definir, e manipular variáveis e expressões.

   Um ponto de parada é escolhido através do comando ':br' na linha de
comando do Maxima.  Dentro do depurador, o usuário pode avançar uma
linha de cada vez usando o comando ':n' ("next").  o comando ':bt'
("backtrace") mostra uma lista da pilha de frames.  O comando ':r'
("resume") sai do depurador e continua com a execução.  Esses comandos
são demostrados no exemplo abaixo.

     (%i1) load ("/tmp/foobar.mac");

     (%o1)                           /tmp/foobar.mac

     (%i2) :br foo
     Turning on debugging debugmode(true)
     Bkpt 0 for foo (in /tmp/foobar.mac line 1)

     (%i2) bar (2,3);
     Bkpt 0:(foobar.mac 1)
     /tmp/foobar.mac:1::

     (dbm:1) :bt                        <-- :bt digitado aqui lista os frames
     #0: foo(y=5)(foobar.mac line 1)
     #1: bar(x=2,y=3)(foobar.mac line 9)

     (dbm:1) :n                         <-- Aqui digite :n para avançar linha
     (foobar.mac 2)
     /tmp/foobar.mac:2::

     (dbm:1) :n                         <-- Aqui digite :n para avançar linha
     (foobar.mac 3)
     /tmp/foobar.mac:3::

     (dbm:1) u;                         <-- Investiga o valor de u
     28

     (dbm:1) u: 33;                     <-- Altera u para ser 33
     33

     (dbm:1) :r                         <-- Digite :r para retomar a computação

     (%o2)                                1094

   O arquivo '/tmp/foobar.mac' é o seguinte:

     foo(y) := block ([u:y^2],
       u: u+3,
       u: u^2,
       u);

     bar(x,y) := (
       x: x+2,
       y: y+2,
       x: foo(y),
       x+y);

   USO DO DEPURADOR ATRAVÉS DO EMACS

   Se o usuário estiver rodando o código sob o GNU emacs em uma janela
shell (shell dbl), ou está rodando a versão de interface gráfica,
Xmaxima, então se ele para em um ponto de parada, ele verá sua posição
corrente no arquivo fonte a qua será mostrada na outra metade da janela,
ou em vermelho brilhante, ou com um pequeno seta apontando na direita da
linha.  Ele pode avançar uma linha por vez digitando M-n (Alt-n).

   Sob Emacs você pode executar em um shell 'dbl', o qual requer o
arquivo 'dbl.el' no diretório elisp.  Tenha certeza que instalou os
arquivos elisp ou adicionou o diretório elisp do Macima ao seu caminho:
e.g., adicione o seguinte ao seu arquivo '.emacs' ou ao seu arquivo
'site-init.el'

     (setq load-path (cons "/usr/share/maxima/5.9.1/emacs" load-path))
     (autoload 'dbl "dbl")

   então no emacs

     M-x dbl

   pode iniciar uma janela shell na qual você pode executar programas,
por exemplo Maxima, gcl, gdb etc.  Essa janela de shell também reconhece
informações sobre depuração de código fonte, e mostra o código fonte em
outra janela.

   O usuário pode escolher um ponto de parada em certa linha do arquivo
digitando 'C-x space'.  Isso encontra qual a função que o cursor está
posicionado, e então mostra qual a linha daquela função que o cursor
está habilitado.  Se o cursor estiver habilitado, digamos, na linha 2 de
'foo', então isso irá inserir na outra janela o comando, "':br foo 2'",
para parar 'foo' nessa segunda linha.  Para ter isso habilitado, o
usuário deve ter maxima-mode.el habilitado na janela na qual o arquivo
'foobar.mac' estiver interagindo.  Existe comandos adicional disponíveis
naquela janela de arquivo, tais como avaliando a função dentro do
Maxima, através da digitação de 'Alt-Control-x'.


File: maxima.info,  Node: Comandos Palavra Chave,  Next: Funções e Variáveis Definidas para Depuração,  Prev: Depurando o Código Fonte,  Up: Depurando

41.2 Comandos Palavra Chave
===========================

Comandos palavra chave são palavras chaves especiais que não são
interpretadas como expressões do Maxima.  Um comando palavra chave pode
ser inserido na linha de comando do Maxima ou na linha de comando do
depurador, embora não possa ser inserido na linha de comando de parada.
Comandos palavra chave iniciam com um dois pontos, ':'.  Por exemplo,
para avaliar uma forma Lisp você pode digitar ':lisp' seguido pela forma
a ser avaliada.

     (%i1) :lisp (+ 2 3)
     5

   O número de argumentos tomados depende do comando em particular.
Também, você não precisa digitar o comando completo, apenas o suficiente
para ser único no meio das palavras chave de parada.  Dessa forma ':br'
será suficiente para ':break'.

   Os comandos de palavra chave são listados abaixo.

':break F n'
     Escolhe um ponto de parada em uma função 'F' na linha 'n' a partir
     do início da função.  Se 'F' for dado como uma seqüência de
     caracteres, então essa seqüência de caracteres é assumida
     referir-se a um arquivo, e 'n' é o deslocamente a partir do início
     do arquivo.  O deslocamento é opcional.  Se for omitido, é assumido
     ser zero (primeira linha da função ou do arquivo).
':bt'
     Imprime na tela uma lista da pilha de frames
':continue'
     Continua a computação
':delete'
     Remove o ponto de parada selecionado, ou todos se nenum for
     especificado
':disable'
     Desabilita os pontos de parada selecionados, ou todos se nenhum for
     especificado
':enable'
     Habilita os pontos de de parada especificados, ou todos se nenhum
     for especificado
':frame n'
     Imprime na tela a pilha de frame 'n', ou o corrente frame se nenhum
     for especificado
':help'
     Imprime na tela a ajuda sobre um comando do depurador, ou todos os
     comandos se nenhum for especificado
':info'
     Imprime na tela informações sobre um item
':lisp alguma-forma'
     Avalia 'alguma-forma' como uma forma Lisp
':lisp-quiet alguma-forma'
     Avalia a forma Lisp 'alguma-forma' sem qualquer saída
':next'
     Como ':step', exceto ':next' passos sobre chamadas de fução
':quit'
     Sai do nível corrente do depurador sem concluir a computação
':resume'
     Continua a computação
':step'
     Continua a computação até encontraruma nova linha de códico
':top'
     Retorne para a linha de comando do Maxima (saindo de qualquer nível
     do depurador) sem completar a computação


File: maxima.info,  Node: Funções e Variáveis Definidas para Depuração,  Prev: Comandos Palavra Chave,  Up: Depurando

41.3 Funções e Variáveis Definidas para Depuração
=================================================

 -- Variável de opção: refcheck
     Valor padrão: 'false'

     Quando 'refcheck' for 'true', Maxima imprime uma mensagem cada vez
     que uma variável associada for usada pela primeira vez em uma
     computação.

 -- Variável de opção: setcheck
     Valor padrão: 'false'

     Se 'setcheck' for escolhido para uma lista de variáveis (as quais
     podem ser subscritas), Maxima mostra uma mensagem quando as
     variáveis, ou ocorrências subscritas delas, forem associadas com o
     operador comum de atribuição ':', o operador '::' de atribuição, ou
     associando argumentos de função, mas não com o operador de
     atribuição de função ':=' nem o operador de atribuição '::=' de
     macro.  A mensagem compreende o nome das variáveis e o valor
     associado a ela.

     'setcheck' pode ser escolhida para 'all' ou 'true' incluindo desse
     modo todas as variáveis.

     Cada nova atribuição de 'setcheck' estabelece uma nova lista de
     variáveis para verificar, e quaisquer variáveis previamente
     atribuídas a 'setcheck' são esquecidas.

     Os nomes atribuídos a 'setcheck' devem ter um apóstrofo no início
     se eles forem de outra forma avaliam para alguma outra coisa que
     não eles mesmo.  Por exemplo, se 'x', 'y', e 'z' estiverem
     atualmente associados, então digite

          setcheck: ['x, 'y, 'z]$

     para colocá-los na lista de variáveis monitoradas.

     Nenhuma saída é gerada quando uma variável na lista 'setcheck' for
     atribuída a sí mesma, e.g., 'X: 'X'.

 -- Variável de opção: setcheckbreak
     Valor padrão: 'false'

     Quando 'setcheckbreak' for 'true', Maxima mostrará um ponto de
     parada quando uma variável sob a lista 'setcheck' for atribuída a
     um novo valor.  A parada ocorre antes que a atribuíção seja
     concluída.  Nesse ponto, 'setval' retém o valor para o qual a
     variável está para ser atribuída.  Conseqüentemente, se pode
     atribuir um valor diferente através da atribuição a 'setval'.

     Veja também 'setcheck' e 'setval'.

 -- Variável de sistema: setval
     Mantém o valor para o qual a variável está para ser escolhida
     quando um 'setcheckbreak' ocorrer.  Conseqüentemente, se pode
     atribuir um valor diferente através da atribuição a 'setval'.

     Veja também 'setcheck' e 'setcheckbreak'.

 -- Função: timer (<f_1>, ..., <f_n>)
 -- Função: timer (all)
 -- Função: timer ()
     Dadas as funções <f_1>, ..., <f_n>, 'timer' coloca cada uma na
     lista de funções para as quais cronometragens estatísticas são
     coletadas.  'timer(f)$ timer(g)$' coloca 'f' e então 'g' sobre a
     lista; a lista acumula de uma chamada para a chamada seguinte.

     'timer(all)' coloca todas as funções definidas pelo usuário (a
     saber pela variável global 'functions') na lista de funções
     monitoradas pela função 'time'.

     Sem argumentos, 'timer' retorna a lista das funções tempo
     estatisticamente monitoradas.

     Maxima armazena quanto tempo é empregado executando cada função na
     lista de funções tempo estatisticamente monitoradas.  'timer_info'
     retorna a coronometragem estatística, incluindo o tempo médio
     decorrido por chamada de função, o número de chamadas, e o tempo
     total decorrido.  'untimer' remove funções da lista de funções
     tempo estatisticamente monitoradas.

     'timer' não avalia seus argumentos.  'f(x) := x^2$ g:f$ timer(g)$'
     não coloca 'f' na lista de funções estatisticamente monitoradas.

     Se 'trace(f)' está vigorando, então 'timer(f)' não tem efeito;
     'trace' e 'timer' não podem ambas atuarem ao mesmo tempo.

     Veja também 'timer_devalue'.

 -- Função: untimer (<f_1>, ..., <f_n>)
 -- Função: untimer ()
     Dadas as funções <f_1>, ..., <f_n>, 'untimer' remove cada uma das
     funções listadas da lista de funções estatisticamente monitoradas.

     Sem argumentos, 'untimer' remove todas as funções atualmente na
     lista de funções estatisticamente monitoradas.

     Após 'untimer (f)' ser executada, 'timer_info (f)' ainda retorna
     estatisticas de tempo previamente coletadas, embora 'timer_info()'
     (sem argumentos) não retorna informações sobre qualquer função que
     não estiver atualmente na lista de funções tempo estatisticamente
     monitoradas.  'timer (f)' reposiciona todas as estatisticas de
     tempo para zero e coloca 'f' na lista de funções estatisticamente
     monitoradas novamente.

 -- Variável de opção: timer_devalue
     Valor Padrão: 'false'

     Quando 'timer_devalue' for 'true', Maxima subtrai de cada função
     estatisticamente monitorada o tempo empregado em ou funções
     estatisticamente monitoradas.  De outra forma, o tempo reportado
     para cada função inclui o tempo empregado em outras funções.  Note
     que tempo empregado em funções não estatisticamente monitoradas não
     é subtraído do tempo total.

     Veja também 'timer' e 'timer_info'.

 -- Função: timer_info (<f_1>, ..., <f_n>)
 -- Função: timer_info ()
     Dadas as funções <f_1>, ..., <f_n>, 'timer_info' retorna uma matriz
     contendo informações de cronometragem para cada função.  Sem
     argumentos, 'timer_info' retorna informações de cronometragem para
     todas as funções atualmente na lista de funções estatisticamente
     monitoradas.

     A matriz retornada através de 'timer_info' contém o nome da função,
     tempo por chamda de função, número de chamadas a funções,tempo
     total, e 'gctime', cujja forma "tempo de descarte" no Macsyma
     original mas agora é sempre zero.

     Os dados sobre os quais 'timer_info' constrói seu valor de retorno
     podem também serem obtidos através da função 'get':

          get(f, 'calls);  get(f, 'runtime);  get(f, 'gctime);

     Veja também 'timer'.

 -- Função: trace (<f_1>, ..., <f_n>)
 -- Função: trace (all)
 -- Função: trace ()
     Dadas as funções <f_1>, ..., <f_n>, 'trace' instrui Maxima para
     mostrar informações de depuração quando essas funções forem
     chamadas.  'trace(f)$ trace(g)$' coloca 'f' e então 'g' na lista de
     funções para serem colocadas sob a ação de 'trace'; a lista acumula
     de uma chamada para a seguinte.

     'trace(all)' coloca todas as funções definidas pelo usuário (a
     saber pela variável global 'functions') na lista de funções a serem
     monitoradas pela função 'trace'.

     Sem argumentos, 'trace' retorna uma lista de todas as funções
     atualmente sob a ação de 'trace'.

     A função 'untrace' desabilita a ação de 'trace'.  Veja também
     'trace_options'.

     'trace' não avalia seus argumentos.  Dessa forma, 'f(x) := x^2$
     g:f$ trace(g)$' não coloca 'f' sobre a lista de funções monitoradas
     pela função 'trace'.

     Quando uma função for redefinida, ela é removida da lista de
     'timer'.  Dessa forma após 'timer(f)$ f(x) := x^2$', a função 'f'
     não mais está na lista de 'timer'.

     Se 'timer (f)' estiver em efeito, então 'trace (f)' não está
     agindo; 'trace' e 'timer' não podem ambas estar agindo para a mesma
     função.

 -- Função: trace_options (<f>, <option_1>, ..., <option_n>)
 -- Função: trace_options (<f>)
     Escolhe as opções de 'trace' para a função <f>.  Quaisquer opções
     anteriores são substituídas.  'trace_options (<f>, ...)' não tem
     efeito a menos que 'trace (<f>)' tenha sido também chamada (ou
     antes ou após 'trace_options').

     'trace_options (<f>)' reposiciona todas as opções para seus valores
     padrão.

     As opções de palavra chave são:

        * 'noprint' Não mostre uma mensagem na entrada da função e saia.
        * 'break' Coloque um ponto de parada antes da função ser
          inserida, e após a funçãos er retirada.  Veja 'break'.
        * 'lisp_print' Mostre argumentos e valores de retorno com
          objetos Lisp.
        * 'info' Mostre '-> true' na entrada da funçào e saia.
        * 'errorcatch' Capture os erros, fornecendo a opção para
          sinalizar um erro, tentar novamente a chamada de função, ou
          especificar um valor de retorno.

     Opções para 'trace' são especificadas em duas formas.  A presença
     da palavra chave de opção sozinha coloca a opção para ter efeito
     incondicionalmente.  (Note que opção <foo> não coloca para ter
     efeito especificando '<foo>: true' ou uma forma similar; note
     também que palavras chave não precisam estar com apóstrofo.)
     Especificando a opção palavra chave com uma função predicado torna
     a opção condicional sobre o predicado.

     A lista de argumentos para a função predicado é sempre '[level,
     direction, function, item]' onde 'level' é o nível rerecursão para
     a função, 'direction' é ou 'enter' ou 'exit', 'function' é o nome
     da função, e 'item' é a lista de argumentos (sobre entrada) ou o
     valor de retorno (sobre a saída).

     Aqui está um exemplo de opções incondicionais de 'trace':

          (%i1) ff(n) := if equal(n, 0) then 1 else n * ff(n - 1)$

          (%i2) trace (ff)$

          (%i3) trace_options (ff, lisp_print, break)$

          (%i4) ff(3);

     Aqui está a mesma função, com a opção 'break' condicional sobre um
     predicado:

          (%i5) trace_options (ff, break(pp))$

          (%i6) pp (level, direction, function, item) := block (print (item),
              return (function = 'ff and level = 3 and direction = exit))$

          (%i7) ff(6);

 -- Função: untrace (<f_1>, ..., <f_n>)
 -- Função: untrace ()
     Dadas as funções <f_1>, ..., <f_n>, 'untrace' desabilita a a
     monitoração habilitada pela função 'trace'.  Sem argumentos,
     'untrace' desabilita a atuação da função 'trade' para todas as
     funções.

     'untrace' retorne uma lista das funções para as quais 'untrace'
     desabilita a atuação de 'trace'.


File: maxima.info,  Node: augmented_lagrangian,  Next: bode,  Prev: Depurando,  Up: Top

42 augmented_lagrangian
***********************

* Menu:

* Funções e Variáveis Definidas para augmented_lagrangian::


File: maxima.info,  Node: Funções e Variáveis Definidas para augmented_lagrangian,  Prev: augmented_lagrangian,  Up: augmented_lagrangian

42.1 Funções e Variáveis Definidas para augmented_lagrangian
============================================================

 -- Função: augmented_lagrangian_method (<FOM>, <xx>, <C>, <yy>)
 -- Função: augmented_lagrangian_method (<FOM>, <xx>, <C>, <yy>,
          args_opcionais)

     Retorna um mínimo aproximado da expressão <FOM> com relação às
     variáveis <xx>, mantendo restrito o valor de <C> a zero.  <yy> é
     uma lista de suposições iniciais para <xx>.  O método utilizado é o
     método do Lagrangiano aumentado (veja referências [1] e [2]).

     'args_opcionais' representam argumentos adicionais, especificados
     como '<símbolo> = <valor>'.  Os argumentos opcionais que podem ser
     colocados no lugar de <símbolo>:

     'niter'
          Número de iterações do algorítmo do Langrangiano aumentado
     'lbfgs_tolerance'
          Tolerância forneceida a LBFGS (Limited-memory, Broyden,
          Fletcher, Goldfarb, Shanno)
     'iprint'
          Parâmetro IPRINT (uma lista de dois inteiros que controlam o
          nível de informação) fornecido a LBFGS
     '%lambda'
          Valor inicial de '%lambda' a ser usado durante o cálculo do
          Lagrangiano aumentado

     Essa implementação minimiza o Lagrangiano aumentado pela pela
     aplicação do algorítmo de memória limitada BFGS (LBFGS), que é um
     algorítmo quasi-Newton.

     'load(augmented_lagrangian)' chama essa função.

     Veja também 'lbfgs'.

     References:

     [1]
     http://www-fp.mcs.anl.gov/otc/Guide/OptWeb/continuous/constrained/nonlinearcon/auglag.html

     [2] http://www.cs.ubc.ca/spider/ascher/542/chap10.pdf

     Exemplo:

          (%i2) load (augmented_lagrangian);
          (%o2) /home/robert/tmp/maxima-release-branch/maxima/share/contri\
          b/augmented_lagrangian.mac
          (%i3) FOM: x^2 + 2*y^2;
                                         2    2
          (%o3)                       2 y  + x
          (%i4) xx: [x, y];
          (%o4)                        [x, y]
          (%i5) C: [x + y - 1];
          (%o5)                      [y + x - 1]
          (%o6)                        [1, 1]
          (%i7) augmented_lagrangian_method (FOM, xx, C, yy, iprint = [-1, 0]);
          (%o7) [[x = 0.6478349888525, y = 0.32391749442625],
                                           %lambda = [- 1.267422460983745]]


File: maxima.info,  Node: bode,  Next: contrib_ode,  Prev: augmented_lagrangian,  Up: Top

43 bode
*******

* Menu:

* Funções e Variáveis Definidas para bode::


File: maxima.info,  Node: Funções e Variáveis Definidas para bode,  Prev: bode,  Up: bode

43.1 Funções e Variáveis Definidas para bode
============================================

 -- Função: bode_gain (<H>, <range>, ...<plot_opts>...)
     Função para desenhar gráficos de ganho para Bode.

     Exemplos (1 a 7 provenientes de
          http://www.swarthmore.edu/NatSci/echeeve1/Ref/Bode/BodeHow.html,
     8 proveniente de Ron Crummett):
          (%i1) load("bode")$

          (%i2) H1 (s) := 100 * (1 + s) / ((s + 10) * (s + 100))$

          (%i3) bode_gain (H1 (s), [w, 1/1000, 1000])$

          (%i4) H2 (s) := 1 / (1 + s/omega0)$

          (%i5) bode_gain (H2 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i6) H3 (s) := 1 / (1 + s/omega0)^2$

          (%i7) bode_gain (H3 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i8) H4 (s) := 1 + s/omega0$

          (%i9) bode_gain (H4 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i10) H5 (s) := 1/s$

          (%i11) bode_gain (H5 (s), [w, 1/1000, 1000])$

          (%i12) H6 (s) := 1/((s/omega0)^2 + 2 * zeta * (s/omega0) + 1)$

          (%i13) bode_gain (H6 (s), [w, 1/1000, 1000]),
                            omega0 = 10, zeta = 1/10$

          (%i14) H7 (s) := (s/omega0)^2 + 2 * zeta * (s/omega0) + 1$

          (%i15) bode_gain (H7 (s), [w, 1/1000, 1000]),
                            omega0 = 10, zeta = 1/10$

          (%i16) H8 (s) := 0.5 / (0.0001 * s^3 + 0.002 * s^2 + 0.01 * s)$

          (%i17) bode_gain (H8 (s), [w, 1/1000, 1000])$

     Para usar essa função escreva primeiramente 'load("bode")'.  Veja
     também 'bode_phase'

 -- Função: bode_phase (<H>, <range>, ...<plot_opts>...)
     Função para desenhar gráficos de fase para Bode

     Exemplos (1 a 7 provenientes de
          http://www.swarthmore.edu/NatSci/echeeve1/Ref/Bode/BodeHow.html,
     8 proveniente de Ron Crummett):
          (%i1) load("bode")$

          (%i2) H1 (s) := 100 * (1 + s) / ((s + 10) * (s + 100))$

          (%i3) bode_phase (H1 (s), [w, 1/1000, 1000])$

          (%i4) H2 (s) := 1 / (1 + s/omega0)$

          (%i5) bode_phase (H2 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i6) H3 (s) := 1 / (1 + s/omega0)^2$

          (%i7) bode_phase (H3 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i8) H4 (s) := 1 + s/omega0$

          (%i9) bode_phase (H4 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i10) H5 (s) := 1/s$

          (%i11) bode_phase (H5 (s), [w, 1/1000, 1000])$

          (%i12) H6 (s) := 1/((s/omega0)^2 + 2 * zeta * (s/omega0) + 1)$

          (%i13) bode_phase (H6 (s), [w, 1/1000, 1000]),
                             omega0 = 10, zeta = 1/10$

          (%i14) H7 (s) := (s/omega0)^2 + 2 * zeta * (s/omega0) + 1$

          (%i15) bode_phase (H7 (s), [w, 1/1000, 1000]),
                             omega0 = 10, zeta = 1/10$

          (%i16) H8 (s) := 0.5 / (0.0001 * s^3 + 0.002 * s^2 + 0.01 * s)$

          (%i17) bode_phase (H8 (s), [w, 1/1000, 1000])$

          (%i18) block ([bode_phase_unwrap : false],
                        bode_phase (H8 (s), [w, 1/1000, 1000]));

          (%i19) block ([bode_phase_unwrap : true],
                        bode_phase (H8 (s), [w, 1/1000, 1000]));

     Para usar essa função escreva primeiramente 'load("bode")'.  Veja
     também 'bode_gain'


File: maxima.info,  Node: contrib_ode,  Next: descriptive,  Prev: bode,  Up: Top

44 contrib_ode
**************

* Menu:

* Introdução a contrib_ode::
* Funções e Variáveis Definidas para contrib_ode::
* Possibilidades de melhorias em contrib_ode::
* Casos de teste para contrib_ode::
* Referências bibliográficas para contrib_ode::


File: maxima.info,  Node: Introdução a contrib_ode,  Next: Funções e Variáveis Definidas para contrib_ode,  Prev: contrib_ode,  Up: contrib_ode

44.1 Introdução a contrib_ode
=============================

O resolvedor de equações diferenciais ordinárias (EDO) do MAXIMA, o
'ode2', resolve EDO's elementares de primeira e segunda ordem.  A função
'contrib_ode' extende 'ode2' com métodos adicionais para EDO's lineares
e EDO's não lineares de primeira ordem e EDO's lineares homogêneas de
segunda ordem.  O código está ainda em desenvolvimemto e a seqüência de
chamada da função pode mudar em futuras versões.  Uma vez que o código
estiver estabilizado essa função pode ser movida do diretório contrib e
integrada dentro do MAXIMA.

   Esse pacote deve torna-se disponível para uso com o comando
'load('contrib_ode)' em primeiro lugar.

   A convenção de chamada para 'contrib_ode' é idêntica a 'ode2'.  Toma
três argumentos: uma EDO (somente o lado esquerdo precisa ser fornecido
se o lado direito for 0), a variável dependente, e a variável
independente.  Quando 'contrib_ode' obtiver sucesso, retorna uma lista
de soluções.

   A forma de retorno da lista de solução difere de 'ode2'.  Como
equações não lineares podem ter múltiplas soluções, 'contrib_ode'
retorna uma lista de soluções.  Cada solução pode ter várias formas:
   * uma solução explícita para a variável dependente,

   * uma solução implícita para a variável dependente,

   * uma solução paramétrica em termos de variável %t, ou

   * uma transfrmação em outra EDO na variável %u.

   '%c' é usado para representar a constante de integração para equações
de primeira ordem.  '%k1' e '%k2' são constantes para equações de
segunda ordem.  Se 'contrib_ode' não puder obter uma solução por
qualquer razão, 'false' é retornado, após talvez mostrar uma mensagem de
erro.

   Isso é necessário para retornar uma lista de soluções, como mesmo
EDO's de primeira ordem não lineares podem ter soluções multiplas.  Por
exemplo:

     (%i1) load('contrib_ode)$

     (%i2) eqn:x*'diff(y,x)^2-(1+x*y)*'diff(y,x)+y=0;

                         dy 2             dy
     (%o2)            x (--)  - (x y + 1) -- + y = 0
                         dx               dx
     (%i3) contrib_ode(eqn,y,x);

                                                  x
     (%o3)             [y = log(x) + %c, y = %c %e ]
     (%i4) method;

     (%o4)                        factor

   EDO's não lineares podem ter soluções singulares sem constantes de
integração, como na segunda solução do seguinte exemplo:

     (%i1) load('contrib_ode)$

     (%i2) eqn:'diff(y,x)^2+x*'diff(y,x)-y=0;

                            dy 2     dy
     (%o2)                 (--)  + x -- - y = 0
                            dx       dx
     (%i3) contrib_ode(eqn,y,x);

                                                2
                                      2        x
     (%o3)              [y = %c x + %c , y = - --]
                                               4
     (%i4) method;

     (%o4)                       clairault

   A seguinte EDO possui duas soluções paramétricas em termos da
variável fictícia %t.  Nesse caso as soluções paramétricaspodem ser
manipuladas para fornecer soluções explícitas.

     (%i1) load('contrib_ode)$

     (%i2) eqn:'diff(y,x)=(x+y)^2;

                               dy          2
     (%o2)                     -- = (y + x)
                               dx
     (%i3) contrib_ode(eqn,y,x);

     (%o3) [[x = %c - atan(sqrt(%t)), y = - x - sqrt(%t)],
                          [x = atan(sqrt(%t)) + %c, y = sqrt(%t) - x]]
     (%i4) method;

     (%o4)                       lagrange

   O seguinte exemplo (Kamke 1.112) demonstra uma solução implícita.

     (%i1) load('contrib_ode)$

     (%i2) assume(x>0,y>0);

     (%o2)                    [x > 0, y > 0]
     (%i3) eqn:x*'diff(y,x)-x*sqrt(y^2+x^2)-y;

                          dy           2    2
     (%o3)              x -- - x sqrt(y  + x ) - y
                          dx
     (%i4) contrib_ode(eqn,y,x);

                                       y
     (%o4)                  [x - asinh(-) = %c]
                                       x
     (%i5) method;

     (%o5)                          lie

   A seguinte equação de Riccati é transformada em uma EDO linear de
segunda ordem na variável %u.  MAXIMA não está apto a resolver a nova
EDO, de forma que essa nova EDO é retornada sem avaliação.
     (%i1) load('contrib_ode)$

     (%i2) eqn:x^2*'diff(y,x)=a+b*x^n+c*x^2*y^2;

                         2 dy      2  2      n
     (%o2)              x  -- = c x  y  + b x  + a
                           dx
     (%i3) contrib_ode(eqn,y,x);

                    d%u
                    ---                            2
                    dx        2     n - 2   a     d %u
     (%o3)  [[y = - ----, %u c  (b x      + --) + ---- c = 0]]
                    %u c                     2      2
                                            x     dx
     (%i4) method;

     (%o4)                        riccati

   Para EDO's de primeira ordem 'contrib_ode' chama 'ode2'.  'ode2'
tenta então os seguintes métodos: fatoração, Clairault, Lagrange,
Riccati, Abel e os métodos de simetria de Lie.  O método de Lie não é
tentado sobre equações de Abel se o método de Abel falhar, mas é tendado
se o método de Riccati uma EDO de segunda ordem não resolvida.

   Para EDO's de segunda ordem 'contrib_ode' chama 'ode2' e em seguida
'odelin'.

   Rastros extensivos de depuração mensagens são mostradas se o comando
'put('contrib_ode,true,'verbose)' for executado.

