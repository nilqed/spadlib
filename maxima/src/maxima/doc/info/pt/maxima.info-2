This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.


File: maxima.info,  Node: Ponto Flutuante,  Next: Contextos,  Prev: Entrada e Saída,  Up: Top

10 Ponto Flutuante
******************

* Menu:

* Definições para ponto Flutuante::  


File: maxima.info,  Node: Definições para ponto Flutuante,  Prev: Ponto Flutuante,  Up: Ponto Flutuante

10.1 Definições para ponto Flutuante
====================================

 -- Função: bffac (<expr>, <n>)
     Versão para grandes números em ponto flutuante da função
     'factorial' (usa o artifício gamma).  O segundo argumento informa
     quantos dígitos reter e retornar, isso é uma boa idéia para
     requisitar precisão adicional.

     'load ("bffac")' chama essa função.

 -- Variável de Opção: algepsilon
     Valor por omissão: 10^8

     'algepsilon' é usada por 'algsys'.

 -- Função: bfloat (<expr>)
     Converte todos os números e funções de números em <expr> para
     grandes números em ponto flutuante (bigfloat).  O número de
     algarismos significativos no grande número em ponto flutuante
     resultante é especificado através da variável global 'fpprec'.

     Quando 'float2bf' for 'false' uma mensagem de alerta é mostrada
     quando uma número em ponto flutuante (float) é convertido em um
     grande número em ponto flutuante (bigfloat - uma vez que isso pode
     resultar em perda de precisão).

 -- Função: bfloatp (<expr>)
     Retorna 'true' se a avaliação da <expr> resultar em um grande
     número em ponto flutuante, de outra forma retorna 'false'.

 -- Função: bfpsi (<n>, <z>, <fpprec>)
 -- Função: bfpsi0 (<z>, <fpprec>)
     'bfpsi' é a função 'polygamma' de argumentos reais <z> e ordem de
     inteiro <n>.  'bfpsi0' é a função 'digamma'.  'bfpsi0 (<z>,
     <fpprec>)' é equivalente a 'bfpsi (0, <z>, <fpprec>)'.

     Essas funções retornam valores em grandes números em ponto
     flutuante.  <fpprec> é a precisão do valor de retorno dos grandes
     números em ponto flutuante.

     'load ("bffac")' chama essas funções.

 -- Variável de Opção: bftorat
     Valor por omissão: 'false'

     'bftorat' controla a conversão de 'bfloats' para números racionais.
     Quando 'bftorat' for 'false', 'ratepsilon' será usada para
     controlar a conversão (isso resulta em números racionais
     relativametne pequenos).  Quando 'bftorat' for 'true', o número
     racional gerado irá representar precisamente o 'bfloat'.

 -- Variável de Opção: bftrunc
     Valor por omissão: 'true'

     'bftrunc' faz com que tilhas de zeros em grandes números em ponto
     flutuante diferentes de zero sejam ocultadas.  Desse modo, se
     'bftrunc' for 'false', 'bfloat (1)' será mostrado como
     '1.000000000000000B0'.  De outra forma, será mostrado como '1.0B0'.

 -- Função: cbffac (<z>, <fpprec>)
     Factorial complexo de grandes números em ponto flutuante.

     'load ("bffac")' chama essa função.

 -- Função: float (<expr>)
     Converte inteiros, números racionais e grandes números em ponto
     flutuante em <expr> para números em ponto flutuante.  Da mesma
     forma um 'evflag', 'float' faz com que números racionais
     não-inteiros e grandes números em ponto flutuante sejam convertidos
     para ponto flutuante.

 -- Variável de Opção: float2bf
     Valor por omissão: 'false'

     Quando 'float2bf' for 'false', uma mensagem de alerta é mostrada
     quando um número em ponto flutuante é convertido em um grande
     número em ponto flutuante (uma vez que isso pode resultar em perda
     de precisão).

 -- Função: floatnump (<expr>)
     Retorna 'true' se <expr> for um número em ponto flutuante, de outra
     forma retorna 'false'.

 -- Variável de Opção: fpprec
     Valor por omissão: 16

     'fpprec' é o número de algarismos significativos para aritmética
     sobre grandes números em ponto flutuante 'fpprec' não afecta
     cálculos sobre números em ponto flutuante comuns.

     Veja também 'bfloat' e 'fpprintprec'.

 -- Variável de Opção: fpprintprec
     Valor por omissão: 0

     'fpprintprec' é o n;umero de dígitos a serem mostrados na tela
     quando no caso de nuúmeros em ponto flutuante e no caso de grandes
     números em ponto flutuante.

     Para números em ponto flutuante comuns, quando 'fpprintprec' tiver
     um valor entre 2 e 16 (inclusive), o n;umero de dígitos mostrado na
     tela é igual a 'fpprintprec'.  De outra forma, 'fpprintprec' é 0,
     ou maior que 16, e o número de dígitos mostrados é 16.

     Para grandes números em ponto flutuante, quando 'fpprintprec' tiver
     um valor entre 2 e 'fpprec' (inclusive), o n;umero de dígitos
     mostrados é giaul a 'fpprintprec'.  De outra forma, 'fpprintprec' é
     0, ou maior que 'fpprec', e o n;umero de dígitos mostrados é igual
     a 'fpprec'.

     'fpprintprec' não pode ser 1.


File: maxima.info,  Node: Contextos,  Next: Polinómios,  Prev: Ponto Flutuante,  Up: Top

11 Contextos
************

* Menu:

* Definições para Contextos::    


File: maxima.info,  Node: Definições para Contextos,  Prev: Contextos,  Up: Contextos

11.1 Definições para Contextos
==============================

 -- Função: activate (<context_1>, ..., <context_n>)
     Ativa os contextos <context_1>, ..., <context_n>.  Os factos nesses
     contextos estão então disponíveis para fazer deduções e recuperar
     informação.  Os factos nesses contextos não são listadas através de
     'facts ()'.

     A variável 'activecontexts' é a lista de contextos que estão
     activos pelo caminho da função 'activate'.

 -- Variável de sistema: activecontexts
     Valor por omissão: '[]'

     'activecontexts' é a lista de contextos que estão activos pelo
     caminho da função 'activate', em oposição a sendo activo porque
     eles são subcontextos do contexto corrente.

 -- Função: assume (<pred_1>, ..., <pred_n>)
     Adiciona predicados <pred_1>, ..., <pred_n> ao contexto corrente.
     Se um predicado for incossistente ou redundante com os predicados
     no contexto corrente, esses predicados não são adicionados ao
     contexto.  O contexto acumula predicados de cada chamada a
     'assume'.

     'assume' retorna uma lista cujos elementos são os predicados
     adicionados ao contexto ou os átomos 'redundant' ou 'inconsistent'
     onde for aplicável.

     Os predicados <pred_1>, ..., <pred_n> podem somente ser expressões
     com os operadores relacionais '< <= equal notequal >=' e '>'.
     Predicados não podem ser expressões de igualdades literais '=' ou
     expressões de desigualdades literais '#', nem podem elas serem
     funções de predicado tais como 'integerp'.

     Predicados combinados da forma '<pred_1> and ... and <pred_n>' são
     reconhecidos, mas não '<pred_1> or ... or <pred_n>'.  'not
     <pred_k>' é reconhecidos se <pred_k> for um predicado relacional.
     Expressões da forma 'not (<pred_1> e <pred_2>)' and 'not (<pred_1>
     or <pred_2>)' não são reconhecidas.

     O mecanismo de dedução do Maxima não é muito forte; exitem
     consequências muito óbvias as quais não podem ser determinadas por
     meio de 'is'.  Isso é uma fraqueza conhecida.

     'assume' avalia seus argumentos.

     Veja também 'is', 'facts', 'forget', 'context', e 'declare'.

     Exemplos:

          (%i1) assume (xx > 0, yy < -1, zz >= 0);
          (%o1)              [xx > 0, yy < - 1, zz >= 0]
          (%i2) assume (aa < bb and bb < cc);
          (%o2)                  [bb > aa, cc > bb]
          (%i3) facts ();
          (%o3)     [xx > 0, - 1 > yy, zz >= 0, bb > aa, cc > bb]
          (%i4) is (xx > yy);
          (%o4)                         true
          (%i5) is (yy < -yy);
          (%o5)                         true
          (%i6) is (sinh (bb - aa) > 0);
          (%o6)                         true
          (%i7) forget (bb > aa);
          (%o7)                       [bb > aa]
          (%i8) prederror : false;
          (%o8)                         false
          (%i9) is (sinh (bb - aa) > 0);
          (%o9)                        unknown
          (%i10) is (bb^2 < cc^2);
          (%o10)                       unknown

 -- Variável de opção: assumescalar
     Valor por omissão: 'true'

     'assumescalar' ajuda a governar se expressões 'expr' para as quais
     'nonscalarp (expr)' for 'false' são assumidas comportar-se como
     escalares para certas transformações.

     Tomemos 'expr' representando qualquer expressão outra que não uma
     lista ou uma matriz, e tomemos '[1, 2, 3]' representando qualquer
     lista ou matriz.  Então 'expr . [1, 2, 3]' retorna '[expr, 2 expr,
     3 expr]' se 'assumescalar' for 'true', ou 'scalarp (expr)' for
     'true', ou 'constantp (expr)' for 'true'.

     Se 'assumescalar' for 'true', tais expressões irão comportar-se
     como escalares somente para operadores comutativos, mas não para
     multiplicação não comutativa '.'.

     Quando 'assumescalar' for 'false', tais expressões irão
     comportar-se como não escalares.

     Quando 'assumescalar' for 'all', tais expressões irão comportar-se
     como escalares para todos os operadores listados acima.

 -- Variável de opção: assume_pos
     Valor por omissão: 'false'

     Quando 'assume_pos' for 'true' e o sinal de um parâmetro <x> não
     pode ser determinado a partir do contexto corrente ou outras
     considerações, 'sign' e 'asksign (<x>)' retornam 'true'.  Isso pode
     impedir algum questionamento de 'asksign' gerado automaticamente,
     tal como pode surgir de 'integrate' ou de outros cálculos.

     Por padrão, um parâmetro é <x> tal como 'symbolp (<x>)' or 'subvarp
     (<x>)'.  A classe de expressões consideradas parâmetros pode ser
     modificada para alguma abrangência através da variável
     'assume_pos_pred'.

     'sign' e 'asksign' tentam deduzir o sinal de expressões a partir de
     sinais de operandos dentro da expressão.  Por exemplo, se 'a' e 'b'
     são ambos positivos, então 'a + b' é também positivo.

     Todavia, não existe caminho para desviar todos os questionamentos
     de 'asksign'.  Particularmente, quando o argumento de 'asksign' for
     uma diferença '<x> - <y>' ou um logaritmo 'log(<x>)', 'asksign'
     sempre solicita uma entrada ao utilizador, mesmo quando
     'assume_pos' for 'true' e 'assume_pos_pred' for uma função que
     retorna 'true' para todos os argumentos.

 -- Variável de opção: assume_pos_pred
     Valor por omissão: 'false'

     Quando 'assume_pos_pred' for atribuído o nome de uma função ou uma
     expressão lambda de um argumento <x>, aquela função é chamada para
     determinar se <x> é considerado um parâmetro para o propósito de
     'assume_pos'.  'assume_pos_pred' é ignorado quando 'assume_pos' for
     'false'.

     A função 'assume_pos_pred' é chamada através de 'sign' e de
     'asksign' com um argumento <x> que é ou um átomo, uma variável
     subscrita, ou uma expressão de chamada de função.  Se a função
     'assume_pos_pred' retorna 'true', <x> é considerado um parâmetro
     para o propósito de 'assume_pos'.

     Por padrão, um parâmetro é <x> tal que 'symbolp (x)' ou 'subvarp
     (x)'.

     Veja também 'assume' e 'assume_pos'.

     Exemplos:

          (%i1) assume_pos: true$
          (%i2) assume_pos_pred: symbolp$
          (%i3) sign (a);
          (%o3)                          pos
          (%i4) sign (a[1]);
          (%o4)                          pnz
          (%i5) assume_pos_pred: lambda ([x], display (x), true)$
          (%i6) asksign (a);
                                        x = a

          (%o6)                          pos
          (%i7) asksign (a[1]);
                                       x = a
                                            1

          (%o7)                          pos
          (%i8) asksign (foo (a));
                                     x = foo(a)

          (%o8)                          pos
          (%i9) asksign (foo (a) + bar (b));
                                     x = foo(a)

                                     x = bar(b)

          (%o9)                          pos
          (%i10) asksign (log (a));
                                        x = a

          Is  a - 1  positive, negative, or zero?

          p;
          (%o10)                         pos
          (%i11) asksign (a - b);
                                        x = a

                                        x = b

                                        x = a

                                        x = b

          Is  b - a  positive, negative, or zero?

          p;
          (%o11)                         neg

 -- Variável de opção: context
     Valor por omissão: 'initial'

     'context' nomeia a colecção de factos mantida através de 'assume' e
     'forget'.  'assume' adiciona factos à colecção nomeada através de
     'context', enquanto 'forget' remove factos.

     Associando 'context' para um nome <foo> altera o contexto corrente
     para <foo>.  Se o contexto especificado <foo> não existe ainda, ele
     é criado automaticamente através de uma chamada a 'newcontext'.  O
     contexto especificado é activado automaticamente.

     Veja 'contexts' para uma descrição geral do mecanismo de contexto.

 -- Variável de opção: contexts
     Valor por omissão: '[initial, global]'

     'contexts' é uma lista dos contextos que existem actualmente,
     incluindo o contexto activo actualmente.

     O mecanismo de contexto torna possível para um utilizador associar
     e nomear uma porção seleccionada de factos, chamada um contexto.
     Assim que isso for concluído, o utilizador pode ter o Maxima
     assumindo ou esquecendo grande quantidade de factos meramente
     através da activação ou desativação seu contexto.

     Qualquer átomo simbólico pode ser um contexto, e os factos contidos
     naquele contexto irão ser retidos em armazenamento até que sejam
     destruídos um por um através de chamadas a 'forget' ou destruídos
     com um conjunto através de uma chamada a 'kill' para destruir o
     contexto que eles pertencem.

     Contextos existem em uma hierarquía, com o raíz sempre sendo o
     contexto 'global', que contém informações sobre Maxima que alguma
     função precisa.  Quando em um contexto dado, todos os factos
     naquele contexto estão "ativos" (significando que eles são usados
     em deduções e recuperados) como estão também todos os factos em
     qualquer contexto que for um subcontexto do contexto activo.

     Quando um novo Maxima for iniciado, o utilizador está em um
     contexto chamado 'initial', que tem 'global' como um subcontexto.

     Veja também 'facts', 'newcontext', 'supcontext', 'killcontext',
     'activate', 'deactivate', 'assume', e 'forget'.

 -- Função: deactivate (<context_1>, ..., <context_n>)
     Desativa os contextos especificados <context_1>, ..., <context_n>.

 -- Função: facts (<item>)
 -- Função: facts ()
     Se <item> for o nome de um contexto, 'facts (<item>)' retorna uma
     lista de factos no contexto especificado.

     Se <item> não for o nome de um contexto, 'facts (<item>)' retorna
     uma lista de factos conhecidos sobre <item> no contexto actual.
     Fatos que estão atuvos, mas em um diferente contexto, não são
     listados.

     'facts ()' (i.e., sem argumento) lista o contexto actual.

 -- Declaração: features
     Maxima recnhece ceertas propriedades matemáticas de funções e
     variáveis.  Essas são chamadas "recursos".

     'declare (<x>, <foo>)' fornece a propriedade <foo> para a função ou
     variável <x>.

     'declare (<foo>, recurso)' declara um novo recurso <foo>.  Por
     exemplo, 'declare ([red, green, blue], feature)' declara três novos
     recursos, 'red', 'green', e 'blue'.

     O predicado 'featurep (<x>, <foo>)' retorna 'true' se <x> possui a
     propriedade <foo>, e 'false' de outra forma.

     A infolista 'features' é uma lista de recursos conhecidos.  São
     esses 'integer', 'noninteger', 'even', 'odd', 'rational',
     'irrational', 'real', 'imaginary', 'complex', 'analytic',
     'increasing', 'decreasing', 'oddfun', 'evenfun', 'posfun',
     'commutative', 'lassociative', 'rassociative', 'symmetric', e
     'antisymmetric', mais quaisquer recursos definidos pelo utilizador.

     'features' é uma lista de recursos matemáticos.  Existe também uma
     lista de recursos não matemáticos, recursos dependentes do sistema.
     Veja 'status'.

 -- Função: forget (<pred_1>, ..., <pred_n>)
 -- Função: forget (<L>)
     Remove predicados estabelecidos através de 'assume'.  Os predicados
     podem ser expressões equivalentes a (mas não necessáriamente
     idênticas a) esses prevamentes assumidos.

     'forget (<L>)', onde <L> é uma lista de predicados, esquece cada
     item da lista.

 -- Função: killcontext (<context_1>, ..., <context_n>)
     Mata os contextos <context_1>, ..., <context_n>.

     Se um dos contextos estiver for o contexto actual, o novo contexto
     actual irá tornar-se o primeiro subcontexto disponível do contexto
     actual que não tiver sido morto.  Se o primeiro contexto disponível
     não morto for 'global' então 'initial' é usado em seu lugar.  Se o
     contexto 'initial' for morto, um novo, porém vazio contexto
     'initial' é criado.

     'killcontext' recusa-se a matar um contexto que estiver ativo
     actualmente, ou porque ele é um subcontexto do contexto actual, ou
     através do uso da função 'activate'.

     'killcontext' avalia seus argumentos.  'killcontext' retorna
     'done'.

 -- Função: newcontext (<nome>)
     Cria um novo contexto, porém vazio, chamado <nome>, que tem
     'global' como seu único subcontexto.  O contexto recentemente
     criado torna-se o contexto activo actualmente.

     'newcontext' avalia seu argumento.  'newcontext' retorna <nome>.

 -- Função: supcontext (<nome>, <context>)
 -- Função: supcontext (<nome>)
     Cria um novo contexto, chamado <nome>, que tem <context> como um
     subcontexto.  <context> deve existir.

     Se <context> não for especificado, o contexto actual é assumido.


File: maxima.info,  Node: Polinómios,  Next: Constantes,  Prev: Contextos,  Up: Top

12 Polinómios
*************

* Menu:

* Introdução a Polinómios::  
* Definições para Polinómios::  


File: maxima.info,  Node: Introdução a Polinómios,  Next: Definições para Polinómios,  Prev: Polinómios,  Up: Polinómios

12.1 Introdução a Polinómios
============================

Polinómios são armazenados no Maxima ou na forma geral ou na forma de
Expressões Racionais Canónicas (CRE). Essa última é uma forma padrão, e
é usada internamente por operações tais como 'factor', 'ratsimp', e
assim por diante.

Expressões Racionais Canónicas constituem um tipo de representação que é
especialmente adequado para polinómios expandidos e funções racionais
(também para polinómios parcialmente factorizados e funções racionais
quando RATFAC for escolhida para 'true').  Nessa forma CRE uma ordenação
de variáveis (da mais para a menos importante) é assumida para cada
expressão.  Polinómios são representados recursivamente por uma lista
consistindo da variável principal seguida por uma série de pares de
expressões, uma para cada termo do polinómio.  O primeiro membro de cada
par é o expoente da variável principal naquele termo e o segundo membro
é o coeficiente daquele termo que pode ser um número ou um polinómio em
outra variável novamente respresentado nessa forma.  Sendo assim a parte
principal da forma CRE de 3*X^2-1 é (X 2 3 0 -1) e que a parte principal
da forma CRE de 2*X*Y+X-3 é (Y 1 (X 1 2) 0 (X 1 1 0 -3)) assumindo Y
como sendo a variável principal, e é (X 1 (Y 1 2 0 1) 0 -3) assumindo X
como sendo a variável principal.  A variável principal é usualmente
determineda pela ordem alfabética reversa.  As "variáveis" de uma
expressão CRE não necessariamente devem ser atômicas.  De facto qualquer
subexpressão cujo principal operador não for + - * / or ^ com expoente
inteiro será considerado uma "variável" da expressão (na forma CRE) na
qual essa ocorrer.  Por exemplo as variáveis CRE da expressão
X+SIN(X+1)+2*SQRT(X)+1 são X, SQRT(X), e SIN(X+1).  Se o utilizador não
especifica uma ordem de variáveis pelo uso da função RATVARS Maxima
escolherá a alfabética por conta própria.  Em geral, CREs representam
expressões racionais, isto é, razões de polinómios, onde o numerador e o
denominador não possuem factores comuns, e o denominador for positivo.
A forma interna é essencialmente um par de polinómios (o numerador e o
denominador) precedidos pela lista de ordenação de variável.  Se uma
expressão a ser mostrada estiver na forma CRE ou se contiver quaisquer
subexpressões na forma CRE, o símbolo /R/ seguirá o rótulo da linha.
Veja a função RAT para saber como converter uma expressão para a forma
CRE. Uma forma CRE extendida é usada para a representação de séries de
Taylor.  A noção de uma expressão racional é extendida de modo que os
expoentes das variáveis podem ser números racionais positivos ou
negativos em lugar de apenas inteiros positivos e os coeficientes podem
eles mesmos serem expressões racionais como descrito acima em lugar de
apenas polinómios.  Estes são representados internamente por uma forma
polinomial recursiva que é similar à forma CRE e é a generalização dessa
mesma forma CRE, mas carrega informação adicional tal com o grau de
truncação.  Do mesmo modo que na forma CRE, o símbolo /T/ segue o rótulo
de linha que contém as tais expressões.


File: maxima.info,  Node: Definições para Polinómios,  Prev: Introdução a Polinómios,  Up: Polinómios

12.2 Definições para Polinómios
===============================

 -- Variável de opção: algebraic
     Valor Padrão: 'false'

     'algebraic' deve ser escolhida para 'true' com o objectivo de que a
     simplificação de inteiros algébricos tenha efeito.

 -- Variável de opção: berlefact
     Valor Padrão: 'true'

     Quando 'berlefact' for 'false' então o algoritmo de factorização de
     Kronecker será usado.  De outra forma o algoritmo de Berlekamp, que
     é o padrão, será usado.

 -- Função: bezout (<p1>, <p2>, <x>)
     uma alternativa para o comando 'resultant'.  Isso retorna uma
     matriz.  'determinant' dessa matriz é o resultante desejado.

 -- Função: bothcoef (<expr>, <x>)
     Retorna uma lista da qual o primeiro membro é o coeficiente de <x>
     em <expr> (como achado por 'ratcoef' se <expr> está na forma CRE de
     outro modo por 'coeff') e cujo segundo membro é a parte restante de
     <expr>.  Isto é, '[A, B]' onde '<expr> = A*<x> + B'.

     Exemplo:

          (%i1) islinear (expr, x) := block ([c],
                  c: bothcoef (rat (expr, x), x),
                  é (freeof (x, c) and c[1] # 0))$
          (%i2) islinear ((r^2 - (x - r)^2)/x, x);
          (%o2)                         true

 -- Função: coeff (<expr>, <x>, <n>)
     Retorna o coeficiente de '<x>^<n>' em <expr>.  <n> pode ser omitido
     se for 1.  <x> pode ser um átomo, ou subexpressão completa de
     <expr> e.g., 'sin(x)', 'a[i+1]', 'x + y', etc.  (No último caso a
     expressão '(x + y)' pode ocorrer em <expr>).  Algumas vezes isso
     pode ser necessário para expandir ou factorizar <expr> com o
     objectivo de fazer '<x>^<n>' explicito.  Isso não é realizado por
     'coeff'.

     Exemplos:

          (%i1) coeff (2*a*tan(x) + tan(x) + b = 5*tan(x) + 3, tan(x));
          (%o1)                      2 a + 1 = 5
          (%i2) coeff (y + x*%e^x + 1, x, 0);
          (%o2)                         y + 1

 -- Função: combine (<expr>)
     Simplifica a adição <expr> por termos combinados com o mesmo
     denominador dentro de um termo simples.

 -- Função: content (<p_1>, <x_1>, ..., <x_n>)
     Retorna uma lista cujo primeiro elemento é o máximo divisor comum
     dos coeficientes dos termos do polinómio <p_1> na variável <x_n>
     (isso é o conteúdo) e cujo segundo elemento é o polinómio <p_1>
     dividido pelo conteúdo.

     Exemplos:

          (%i1) content (2*x*y + 4*x^2*y^2, y);
                                             2
          (%o1)                   [2 x, 2 x y  + y]

 -- Função: denom (<expr>)
     Retorna o denominador da expressão racional <expr>.

 -- Função: divide (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     calcula o quocietne e o resto do polinómio <p_1> dividido pelo
     polinómio <p_2>, na variável principal do polinómio, <x_n>.  As
     outras variáveis são como na função 'ratvars'.  O resultado é uma
     lista cujo primeiro elemento é o quociente e cujo segundo elemento
     é o resto.

     Exemplos:

          (%i1) divide (x + y, x - y, x);
          (%o1)                       [1, 2 y]
          (%i2) divide (x + y, x - y);
          (%o2)                      [- 1, 2 x]

     Note que 'y' é a variável principal no segundo exemplo.

 -- Função: eliminate ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_k>])
     Elimina variáveis de equações (ou expressões assumidas iguais a
     zero) obtendo resultantes sucessivos.  Isso retorna uma lista de
     '<n> - <k>' expressões com <k> variáveis <x_1>, ..., <x_k>
     eliminadas.  Primeiro <x_1> é eliminado retornando '<n> - 1'
     expressões, então 'x_2' é eliminado, etc.  Se '<k> = <n>' então uma
     expressão simples em uma lista é retornada livre das variáveis
     <x_1>, ..., <x_k>.  Nesse caso 'solve' é chamado para resolver a
     última resultante para a última variável.

     Exemplo:

          (%i1) expr1: 2*x^2 + y*x + z;
                                                2
          (%o1)                    z + x y + 2 x
          (%i2) expr2: 3*x + 5*y - z - 1;
          (%o2)                  - z + 5 y + 3 x - 1
          (%i3) expr3: z^2 + x - y^2 + 5;
                                    2    2
          (%o3)                    z  - y  + x + 5
          (%i4) eliminate ([expr3, expr2, expr1], [y, z]);
                       8         7         6          5          4
          (%o4) [7425 x  - 1170 x  + 1299 x  + 12076 x  + 22887 x

                                              3         2
                                      - 5154 x  - 1291 x  + 7688 x + 15376]

 -- Função: ezgcd (<p_1>, <p_2>, <p_3>, ...)
     Retorna uma lista cujo primeiro elemento é o m.d.c.  dos polinómios
     <p_1>, <p_2>, <p_3>, ...  e cujos restantes elementos são os
     polinómios divididos pelo mdc.  Isso sempre usa o algoritmo
     'ezgcd'.

 -- Variável de opção: facexpand
     Valor Padrão: 'true'

     'facexpand' controla se os factores irredutíveis retornados por
     'factor' estão na forma expandida (o padrão) ou na forma recursiva
     (CRE normal).

 -- Função: factcomb (<expr>)
     Tenta combinar os coeficientes de factoriais em <expr> com os
     próprios factoriais convertendo, por exemplo, '(n + 1)*n!' em '(n +
     1)!'.

     'sumsplitfact' se escolhida para 'false' fará com que
     'minfactorial' seja aplicado após um 'factcomb'.

 -- Função: factor (<expr>)
 -- Função: factor (<expr>, <p>)

     Factoriza a expressão <expr>, contendo qualquer número de variáveis
     ou funções, em factores irredutíveis sobre os inteiros.  'factor
     (<expr>, <p>)' factoriza <expr> sobre o campo dos inteiros com um
     elemento adjunto cujo menor polinómio é <p>.

     'factor' usa a função 'ifactors' para factorizar inteiros.

     'factorflag' se 'false' suprime a factorização de factores inteiros
     de expressões racionais.

     'dontfactor' pode ser escolhida para uma lista de variáveis com
     relação à qual factorização não é para ocorrer.  (Essa é
     inicialmente vazia).  Factorização também não acontece com relação
     a quaisquer variáveis que são menos importantes (usando a ordenação
     de variável assumida pela forma CRE) como essas na lista
     'dontfactor'.

     'savefactors' se 'true' faz com que os factores de uma expressão
     que é um produto de factores seja guardada por certas funções com o
     objectivo de aumentar a velocidade de futuras factorizações de
     expressões contendo alguns dos mesmos factores.

     'berlefact' se 'false' então o algoritmo de factorização de
     Kronecker será usado de outra forma o algoritmo de Berlekamp, que é
     o padrão, será usado.

     'intfaclim' se 'true' maxima irá interromper a factorização de
     inteiros se nenhum factor for encontrado após tentar divisões e o
     método rho de Pollard.  Se escolhida para 'false' (esse é o caso
     quando o utilizador chama 'factor' explicitamente), a factorização
     completa do inteiro será tentada.  A escolha do utilizador para
     'intfaclim' é usada para chamadas internas a 'factor'.  Dessa
     forma, 'intfaclim' pode ser resetada para evitar que o Maxima gaste
     um tempo muito longo factorizando inteiros grandes.

     Exemplos:

          (%i1) factor (2^63 - 1);
                              2
          (%o1)              7  73 127 337 92737 649657
          (%i2) factor (-8*y - 4*x + z^2*(2*y + x));
          (%o2)               (2 y + x) (z - 2) (z + 2)
          (%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                          2  2        2    2    2
          (%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
          (%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                                 2
                               (x  + 2 x + 1) (y - 1)
          (%o4)                ----------------------
                                     36 (y + 1)
          (%i5) factor (1 + %e^(3*x));
                                x         2 x     x
          (%o5)              (%e  + 1) (%e    - %e  + 1)
          (%i6) factor (1 + x^4, a^2 - 2);
                              2              2
          (%o6)             (x  - a x + 1) (x  + a x + 1)
          (%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                                 2
          (%o7)              - (y  + x) (z - x) (z + x)
          (%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                                       x + 2
          (%o8)               ------------------------
                                                     2
                              (x + 3) (x + b) (x + c)
          (%i9) ratsimp (%);
                          4                  3
          (%o9) (x + 2)/(x  + (2 c + b + 3) x

               2                       2             2                   2
           + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
          (%i10) partfrac (%, x);
                     2                   4                3
          (%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

               2              2         2                2
           + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                           c - 2
           - ---------------------------------
               2                             2
             (c  + (- b - 3) c + 3 b) (x + c)

                                   b - 2
           + -------------------------------------------------
                       2             2       3      2
             ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                                   1
           - ----------------------------------------------
                       2
             ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
          (%i11) map ('factor, %);
                        2
                       c  - 4 c - b + 6                 c - 2
          (%o11) - ------------------------- - ------------------------
                          2        2                                  2
                   (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                                 b - 2                        1
                      + ------------------------ - ------------------------
                                       2                          2
                        (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
          (%i12) ratsimp ((x^5 - 1)/(x - 1));
                                 4    3    2
          (%o12)                x  + x  + x  + x + 1
          (%i13) subst (a, x, %);
                                 4    3    2
          (%o13)                a  + a  + a  + a + 1
          (%i14) factor (%th(2), %);
                                 2        3        3    2
          (%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
          (%i15) factor (1 + x^12);
                                 4        8    4
          (%o15)               (x  + 1) (x  - x  + 1)
          (%i16) factor (1 + x^99);
                           2            6    3
          (%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

             10    9    8    7    6    5    4    3    2
           (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

             20    19    17    16    14    13    11    10    9    7    6
           (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

              4    3            60    57    51    48    42    39    33
           - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

              30    27    21    18    12    9    3
           - x   - x   + x   + x   - x   - x  + x  + 1)

 -- Variável de opção: factorflag
     Valor Padrão: 'false'

     Quando 'factorflag' for 'false', suprime a factorização de factores
     inteiros em expressões racionais.

 -- Função: factorout (<expr>, <x_1>, <x_2>, ...)
     Rearranja a adição <expr> em uma adição de parcelas da forma 'f
     (<x_1>, <x_2>, ...)*g' onde 'g' é um produto de expressões que não
     possuem qualquer <x_i> e 'f' é factorizado.

 -- Função: factorsum (<expr>)
     Tenta agrupar parcelas em factores de <expr> que são adições em
     grupos de parcelas tais que sua adição é factorável.  'factorsum'
     pode recuperar o resultado de 'expand ((x + y)^2 + (z + w)^2)' mas
     não pode recuperar 'expand ((x + 1)^2 + (x + y)^2)' porque os
     termos possuem variáveis em comum.

     Exemplo:

          (%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
                     2      2                            2      2
          (%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                               2        2    2            2
                                  + 2 u v x + u  x + a w  + v  + 2 u v + u
          (%i2) factorsum (%);
                                             2          2
          (%o2)            (x + 1) (a (z + w)  + (v + u) )

 -- Função: fasttimes (<p_1>, <p_2>)
     Retorna o produto dos polinómios <p_1> e <p_2> usando um algoritmo
     especial para a multiplicação de polinómios.  'p_1' e 'p_2' podem
     ser de várias variáveis, densos, e aproximadamente do mesmo
     tamanho.  A multiplicação clássica é de ordem 'n_1 n_2' onde 'n_1'
     é o grau de 'p_1' and 'n_2' é o grau de 'p_2'.  'fasttimes' é da
     ordem 'max (n_1, n_2)^1.585'.

 -- Função: fullratsimp (<expr>)
     'fullratsimp' aplica repetidamente 'ratsimp' seguido por
     simplificação não racional a uma expressão até que nenhuma mudança
     adicional ocorra, e retorna o resultado.

     Quando expressões não racionais estão envolvidas, uma chamada a
     'ratsimp' seguida como é usual por uma simplificação não racional
     ("geral") pode não ser suficiente para retornar um resultado
     simplificado.  Algumas vezes, mais que uma tal chamada pode ser
     necessária.  'fullratsimp' faz esse processo convenientemente.

     'fullratsimp (<expr>, <x_1>, ..., <x_n>)' aceita um ou mais
     argumentos similar a 'ratsimp' e 'rat'.

     Exemplo:

          (%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                                 a/2     2   a/2     2
                               (x    - 1)  (x    + 1)
          (%o1)                -----------------------
                                        a
                                       x  - 1
          (%i2) ratsimp (expr);
                                    2 a      a
                                   x    - 2 x  + 1
          (%o2)                    ---------------
                                        a
                                       x  - 1
          (%i3) fullratsimp (expr);
                                        a
          (%o3)                        x  - 1
          (%i4) rat (expr);
                                 a/2 4       a/2 2
                               (x   )  - 2 (x   )  + 1
          (%o4)/R/             -----------------------
                                        a
                                       x  - 1

 -- Função: fullratsubst (<a>, <b>, <c>)
     é o mesmo que 'ratsubst' excepto que essa chama a si mesma
     recursivamente sobre esse resultado até que o resultado para de
     mudar.  Essa função é útil quando a expressão de substituição e a
     expressão substituída tenham uma ou mais variáveis em comum.

     'fullratsubst' irá também aceitar seus argumentos no formato de
     'lratsubst'.  Isto é, o primeiro argumento pode ser uma
     substituição simples de equação ou uma lista de tais equações,
     enquanto o segundo argumento é a expressão sendo processada.

     'load ("lrats")' chama 'fullratsubst' e 'lratsubst'.

     Exemplos:

          (%i1) load ("lrats")$
        * 'subst' pode realizar multiplas substituições.  'lratsubst' é
          analogo a 'subst'.
          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c
        * Se somente uma substituição é desejada, então uma equação
          simples pode ser dada como primeiro argumento.
          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b
        * 'fullratsubst' é equivalente a 'ratsubst' excepto que essa
          executa recursivamente até que seu resultado para de mudar.
          (%i5) ratsubst (b*a, a^2, a^3);
                                         2
          (%o5)                         a  b
          (%i6) fullratsubst (b*a, a^2, a^3);
                                           2
          (%o6)                         a b
        * 'fullratsubst' também aceita uma lista de equações ou uma
          equação simples como primeiro argumento.
          (%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
          (%o7)                           b
          (%i8) fullratsubst (a^2 = b*a, a^3);
                                           2
          (%o8)                         a b
        * 'fullratsubst' pode causar uma recursão infinita.
          (%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

          *** - Lisp stack overflow. RESET

 -- Função: gcd (<p_1>, <p_2>, <x_1>, ...)
     Retorna o máximo divisor comum entre <p_1> e <p_2>.  O sinalizador
     'gcd' determina qual algoritmo é empregado.  Escolhendo 'gcd' para
     'ez', 'subres', 'red', ou 'spmod' selecciona o algoritmo 'ezgcd',
     subresultante 'prs', reduzido, ou modular, respectivamente.  Se
     'gcd' for 'false' então 'gcd (<p_1>, <p_2>, <x>)' sempre retorna 1
     para todo <x>.  Muitas funções (e.g.  'ratsimp', 'factor', etc.)
     fazem com que mdc's sejam feitos implicitamente.  Para polinómios
     homogêneos é recomendado que 'gcd' igual a 'subres' seja usado.
     Para obter o mdc quando uma expressão algébrica está presente, e.g.
     'gcd (<x>^2 - 2*sqrt(2)*<x> + 2, <x> - sqrt(2))', 'algebraic' deve
     ser 'true' e 'gcd' não deve ser 'ez'.  'subres' é um novo
     algoritmo, e pessoas que tenham estado usando a opção 'red' podem
     provavelmente alterar isso para 'subres'.

     O sinalizador 'gcd', padrão: 'subres', se 'false' irá também evitar
     o máximo divisor comum de ser usado quando expressões são
     convertidas para a forma de expressão racional canónica (CRE). Isso
     irá algumas vezes aumentar a velocidade dos cálculos se mdc's não
     são requeridos.

 -- Função: gcdex (<f>, <g>)
 -- Função: gcdex (<f>, <g>, <x>)
     Retornam uma lista '[<a>, <b>, <u>]' onde <u> é o máximo divisor
     comum (mdc) entre <f> e <g>, e <u> é igual a '<a> <f> + <b> <g>'.
     Os argumentos <f> e <g> podem ser polinómios de uma variável, ou de
     outra forma polinómios em <x> uma main(principal) variável suprida
     desde que nós precisamos estar em um domínio de ideal principal
     para isso trabalhar.  O mdc significa o mdc considerando <f> e <g>
     como polinómios de uma única variável com coeficientes sendo
     funções racionais em outras variáveis.

     'gcdex' implementa o algoritmo Euclideano, onde temos a sequência
     of 'L[i]: [a[i], b[i], r[i]]' que são todos perpendiculares a '[f,
     g, -1]' e o próximo se é construído como se 'q =
     quotient(r[i]/r[i+1])' então 'L[i+2]: L[i] - q L[i+1]', e isso
     encerra em 'L[i+1]' quando o resto 'r[i+2]' for zero.

          (%i1) gcdex (x^2 + 1, x^3 + 4);
                                 2
                                x  + 4 x - 1  x + 4
          (%o1)/R/           [- ------------, -----, 1]
                                     17        17
          (%i2) % . [x^2 + 1, x^3 + 4, -1];
          (%o2)/R/                        0

     Note que o mdc adiante é '1' uma vez que trabalhamos em 'k(y)[x]',
     o 'y+1' não pode ser esperado em 'k[y, x]'.

          (%i1) gcdex (x*(y + 1), y^2 - 1, x);
                                         1
          (%o1)/R/                 [0, ------, 1]
                                        2
                                       y  - 1

 -- Função: gcfactor (<n>)
     Factoriza o inteiro Gaussiano <n> sobre os inteiros Gaussianos,
     i.e., números da forma '<a> + <b> %i' onde <a> e <b> são inteiros
     raconais (i.e., inteiros comuns).  Factorizações são normalizadas
     fazendo <a> e <b> não negativos.

 -- Função: gfactor (<expr>)
     Factoriza o polinómio <expr> sobre os inteiros de Gauss (isto é, os
     inteiros com a unidade imaginária '%i' adjunta).  Isso é como
     'factor (<expr>, <a>^2+1)' trocando <a> por '%i'.

     Exemplo:

          (%i1) gfactor (x^4 - 1);
          (%o1)           (x - 1) (x + 1) (x - %i) (x + %i)

 -- Função: gfactorsum (<expr>)
     é similar a 'factorsum' mas aplica 'gfactor' em lugar de 'factor'.

 -- Função: hipow (<expr>, <x>)
     Retorna o maior expoente explícito de <x> em <expr>.  <x> pode ser
     uma variável ou uma expressão geral.  Se <x> não aparece em <expr>,
     'hipow' retorna '0'.

     'hipow' não considera expressões equivalentes a 'expr'.  Em
     particular, 'hipow' não expande 'expr', então 'hipow (<expr>, <x>)'
     e 'hipow (expand (<expr>, <x>))' podem retornar diferentes
     resultados.

     Exemplos:

          (%i1) hipow (y^3 * x^2 + x * y^4, x);
          (%o1)                           2
          (%i2) hipow ((x + y)^5, x);
          (%o2)                           1
          (%i3) hipow (expand ((x + y)^5), x);
          (%o3)                           5
          (%i4) hipow ((x + y)^5, x + y);
          (%o4)                           5
          (%i5) hipow (expand ((x + y)^5), x + y);
          (%o5)                           0

 -- Variável de opção: intfaclim
     Valor por omissão: true

     Se 'true', maxima irá interromper a factorização de inteiros se
     nenhum factor for encontrado após tentar divisões e o método rho de
     Pollard e a factorização não será completada.

     Quando 'intfaclim' for 'false' (esse é o caso quando o utilizador
     chama 'factor' explicitamente), a factorização completa será
     tentada.  'intfaclim' é escolhida para 'false' quando factores são
     calculados em 'divisors', 'divsum' e 'totient'.

     Chamadas internas a 'factor' respeitam o valor especificado pelo
     utilizador para 'intfaclim'.  Setting 'intfaclim' to 'true' may
     reduce 'intfaclim'.  Escolhendo 'intfaclim' para 'true' podemos
     reduzir o tempo gasto factorizando grandes inteiros.

 -- Variável de opção: keepfloat
     Valor Padrão: 'false'

     Quando 'keepfloat' for 'true', evitamos que números em ponto
     flutuante sejam racionalizados quando expressões que os possuem são
     então convertidas para a forma de expressão racional canónica
     (CRE).

 -- Função: lratsubst (<L>, <expr>)
     é análogo a 'subst (<L>, <expr>)' excepto que esse usa 'ratsubst'
     em lugar de 'subst'.

     O primeiro argumento de 'lratsubst' é uma equação ou uma lista de
     equações idênticas em formato para que sejam aceitas por 'subst'.
     As substituições são feitas na ordem dada pela lista de equações,
     isto é, da esquerda para a direita.

     'load ("lrats")' chama 'fullratsubst' e 'lratsubst'.

     Exemplos:

          (%i1) load ("lrats")$
        * 'subst' pode realizar multiplas substituições.  'lratsubst' é
          analoga a 'subst'.
          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c
        * Se somente uma substituição for desejada, então uma equação
          simples pode ser dada como primeiro argumento.
          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b

 -- Variável de opção: modulus
     Valor Padrão: 'false'

     Quando 'modulus' for um número positivo <p>, operações sobre os
     números racionais (como retornado por 'rat' e funções relacionadas)
     são realizadas módulo <p>, usando o então chamado sistema de módulo
     "balanceado" no qual '<n> módulo <p>' é definido como um inteiro
     <k> em '[-(<p>-1)/2, ..., 0, ..., (<p>-1)/2]' quando <p> for ímpar,
     ou '[-(<p>/2 - 1), ..., 0, ...., <p>/2]' quando <p> for par, tal
     que '<a> <p> + <k>' seja igual a <n> para algum inteiro <a>.

     Se <expr> já estiver na forma de expressão racional canónica (CRE)
     quando 'modulus' for colocado no seu valor original, então pode
     precisar repetir o rat <expr>, e.g., 'expr: rat (ratdisrep
     (expr))', com o objectivo de obter resultados correctos.

     Tipicamente 'modulus' é escolhido para um número primo.  Se
     'modulus' for escolhido para um inteiro não primo positivo, essa
     escolha é aceita, mas uma mensagem de alerta é mostrada.  Maxima
     permitirá que zero ou um inteiro negativo seja atribuído a
     'modulus', embora isso não seja limpo se aquele tiver quaisquer
     consequências úteis.

 -- Função: num (<expr>)
     Retorna o numerador de <expr> se isso for uma razão.  Se <expr> não
     for uma razão, <expr> é retornado.

     'num' avalia seu argumento.

 -- Função: polydecomp (<p>, <x>)

     Decompões o polinómio <p> na variável <x> em uma composição
     funcional de polinómios em <x>.  'polydecomp' retorna uma lista
     '[<p_1>, ..., <p_n>]' tal que

          lambda ([x], p_1) (lambda ([x], p_2) (... (lambda ([x], p_n) (x)) ...))

     seja igual a <p>.  O grau de <p_i> é maior que 1 para <i> menor que
     <n>.

     Tal decomposição não é única.

     Exemplos:

          (%i1) polydecomp (x^210, x);
                                    7   5   3   2
          (%o1)                   [x , x , x , x ]
          (%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                          6      4      3    2
          (%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
          (%i3) polydecomp (p, x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     As seguintes funções compõem 'L = [e_1, ..., e_n]' como funções em
     'x'; essa funçào é a inversa de 'polydecomp':

          compose (L, x) :=
            block ([r : x], for e in L do r : subst (e, x, r), r) $

     Re-exprimindo o exemplo acima usando 'compose':

          (%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     Note que apesar de 'compose (polydecomp (<p>, <x>), <x>)' sempre
     retornar <p> (não expandido), 'polydecomp (compose ([<p_1>, ...,
     <p_n>], <x>), <x>)' não necessáriamente retorna '[<p_1>, ...,
     <p_n>]':

          (%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                                    2       2
          (%o4)                   [x  + 2, x  + 1]
          (%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
                                2       2
                               x  + 3  x  + 5
          (%o5)               [------, ------, 2 x + 1]
                                 4       2

 -- Função: quotient (<p_1>, <p_2>)
 -- Função: quotient (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Retorna o polinómio <p_1> dividido pelo polinómio <p_2>.  Os
     argumentos <x_1>, ..., <x_n> são interpretados como em 'ratvars'.

     'quotient' retorna o primeiro elemento de uma lista de dois
     elementos retornada por 'divide'.

 -- Função: rat (<expr>)
 -- Função: rat (<expr>, <x_1>, ..., <x_n>)
     Converte <expr> para a forma de expressão racional canónica (CRE)
     expandindo e combinando todos os termos sobre um denominador comum
     e cancelando para fora o máximo divisor comum entre o numerador e o
     denominador, também convertendo números em ponto flutuante para
     números racionais dentro da tolerância de 'ratepsilon'.  As
     variáveis são ordenadas de acordo com <x_1>, ..., <x_n>, se
     especificado, como em 'ratvars'.

     'rat' geralmente não simplifica funções outras que não sejam adição
     '+', subtração '-', multiplicação '*', divisão '/', e exponenciação
     com expoente inteiro, uma vez que 'ratsimp' não manuseia esses
     casos.  Note que átomos (números e variáveis) na forma CRE não são
     os mesmos que eles são na forma geral.  Por exemplo, 'rat(x)- x'
     retorna 'rat(0)' que tem uma representação interna diferente de 0.

     Quando 'ratfac' for 'true', 'rat' retorna uma forma parcialmente
     factorizada para CRE. Durante operações racionais a expressão é
     mantida como totalmente factorizada como possível sem uma chamada
     ao pacote de factorização ('factor').  Isso pode sempre economizar
     espaço de memória e algum tempo em algumas computações.  O
     numerador e o denominador são ainda tidos como relativamente primos
     (e.g.  'rat ((x^2 - 1)^4/(x + 1)^2)' retorna '(x - 1)^4 (x +
     1)^2)', mas os factores dentro de cada parte podem não ser
     relativamente primos.

     'ratprint' se 'false' suprime a impressão de mensagens informando o
     utilizador de conversões de números em ponto flutuante para números
     racionais.

     'keepfloat' se 'true' evita que números em ponto flutuante sejam
     convertidos para números racionais.

     Veja também 'ratexpand' e 'ratsimp'.

     Exemplos:

          (%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /(4*y^2 + x^2);
                                                     4
                                            (x - 2 y)
                        (y + a) (2 y + x) (------------ + 1)
                                             2      2 2
                                           (x  - 4 y )
          (%o1)         ------------------------------------
                                        2    2
                                     4 y  + x
          (%i2) rat (%, y, a, x);
                                      2 a + 2 y
          (%o2)/R/                    ---------
                                       x + 2 y

 -- Variável de opção: ratalgdenom
     Valor Padrão: 'true'

     Quando 'ratalgdenom' for 'true', permite racionalização de
     denominadores com respeito a radicais tenham efeito.  'ratalgdenom'
     tem efeito somente quando expressões racionais canónicas (CRE)
     forem usadas no modo algébrico.

 -- Função: ratcoef (<expr>, <x>, <n>)
 -- Função: ratcoef (<expr>, <x>)
     Retorna o coeficiente da expressão '<x>^<n>' dentro da expressão
     <expr>.  Se omitido, <n> é assumido ser 1.

     O valor de retorno está livre (excepto possivelmente em um senso
     não racional) das variáveis em <x>.  Se nenhum coeficiente desse
     tipo existe, 0 é retornado.

     'ratcoef' expande e simplifica racionalmente seu primeiro argumento
     e dessa forma pode produzir respostas diferentes das de 'coeff' que
     é puramente sintática.  Dessa forma 'ratcoef ((x + 1)/y + x, x)'
     retorna '(y + 1)/y' ao passo que 'coeff' retorna 1.

     'ratcoef (<expr>, <x>, 0)', visualiza <expr> como uma adição,
     retornando uma soma desses termos que não possuem <x>.  portanto se
     <x> ocorre para quaisquer expoentes negativos, 'ratcoef' pode não
     ser usado.

     Uma vez que <expr> é racionalmente simplificada antes de ser
     examinada, coeficientes podem não aparecer inteiramente no caminho
     que eles foram pensados.

     Exemplo:

          (%i1) s: a*x + b*x + 5$
          (%i2) ratcoef (s, a + b);
          (%o2)                           x

 -- Função: ratdenom (<expr>)
     Retorna o denominador de <expr>, após forçar a conversão de <expr>
     para expressão racional canónica (CRE). O valor de retorno é a CRE.

     <expr> é forçada para uma CRE por 'rat' se não for já uma CRE. Essa
     conversão pode mudar a forma de <expr> colocando todos os termos
     sobre um denominador comum.

     'denom' é similar, mas retorna uma expressão comum em lugar de uma
     CRE. Também, 'denom' não tenta colocar todos os termos sobre um
     denominador comum, e dessa forma algumas expressões que são
     consideradas razões por 'ratdenom' não são consideradas razões por
     'denom'.

 -- Variável de opção: ratdenomdivide
     Valor Padrão: 'true'

     Quando 'ratdenomdivide' for 'true', 'ratexpand' expande uma razão
     cujo o numerador for uma adição dentro de uma soma de razões, tendo
     todos um denominador comum.  De outra forma, 'ratexpand' colapsa
     uma adição de razões dentro de uma razão simples, cujo numerador
     seja a adição dos numeradores de cada razão.

     Exemplos:

          (%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                                      2
                                     x  + x + 1
          (%o1)                      ----------
                                        2
                                       y  + 7
          (%i2) ratdenomdivide: true$
          (%i3) ratexpand (expr);
                                 2
                                x        x        1
          (%o3)               ------ + ------ + ------
                               2        2        2
                              y  + 7   y  + 7   y  + 7
          (%i4) ratdenomdivide: false$
          (%i5) ratexpand (expr);
                                      2
                                     x  + x + 1
          (%o5)                      ----------
                                        2
                                       y  + 7
          (%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
                                               2
                                     b        a
          (%o6)                    ------ + ------
                                    2        2
                                   b  + 3   b  + 3
          (%i7) ratexpand (expr2);
                                            2
                                       b + a
          (%o7)                        ------
                                        2
                                       b  + 3

 -- Função: ratdiff (<expr>, <x>)
     Realiza a derivação da expressão racional <expr> com relação a <x>.
     <expr> deve ser uma razão de polinómios ou um polinómio em <x>.  O
     argumento <x> pode ser uma variável ou uma subexpressão de <expr>.

     O resultado é equivalente a 'diff', embora talvez em uma forma
     diferente.  'ratdiff' pode ser mais rápida que 'diff', para
     expressões racionais.

     'ratdiff' retorna uma expressão racional canónica (CRE) se 'expr'
     for uma CRE. De outra forma, 'ratdiff' retorna uma expressão geral.

     'ratdiff' considera somente as dependências de <expr> sobre <x>, e
     ignora quaisquer dependências estabelecidas por 'depends'.

     Exemplo:

          (%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                                     3
                                  4 x  + 10 x - 11
          (%o1)                   ----------------
                                        5
                                       x  + 5
          (%i2) ratdiff (expr, x);
                              7       5       4       2
                           8 x  + 40 x  - 55 x  - 60 x  - 50
          (%o2)          - ---------------------------------
                                    10       5
                                   x   + 10 x  + 25
          (%i3) expr: f(x)^3 - f(x)^2 + 7;
                                   3       2
          (%o3)                   f (x) - f (x) + 7
          (%i4) ratdiff (expr, f(x));
                                     2
          (%o4)                   3 f (x) - 2 f(x)
          (%i5) expr: (a + b)^3 + (a + b)^2;
                                        3          2
          (%o5)                  (b + a)  + (b + a)
          (%i6) ratdiff (expr, a + b);
                              2                    2
          (%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a

 -- Função: ratdisrep (<expr>)
     Retorna seu argumento como uma expressão geral.  Se <expr> for uma
     expressão geral, é retornada inalterada.

     Tipicamente 'ratdisrep' é chamada para converter uma expressão
     racional canónica (CRE) em uma expressão geral.  Isso é algumas
     vezes conveniente se deseja-se parar o "contágio", ou caso se
     esteja usando funções racionais em contextos não racionais.

     Veja também 'totaldisrep'.

 -- Variável de opção: ratepsilon
     Valor Padrão: 2.0e-8

     'ratepsilon' é a tolerância usada em conversões de números em ponto
     flutuante para números racionais.

 -- Função: ratexpand (<expr>)
 -- Variável de opção: ratexpand
     Expande <expr> multiplicando para fora produtos de somas e somas
     exponenciadas, combinando frações sobre um denominador comum,
     cancelando o máximo divisor comum entre entre o numerador e o
     denominador, então quebrando o numerador (se for uma soma) dentro
     de suas respectivas parcelas divididas pelo denominador.

     O valor de retorno de 'ratexpand' é uma expressão geral, mesmo se
     <expr> for uma expressão racional canónica (CRE).

     O comutador 'ratexpand' se 'true' fará com que expressões CRE sejam
     completamente expandidas quando forem convertidas de volta para a
     forma geral ou mostradas, enquanto se for 'false' então elas serão
     colocadas na forma recursiva.  Veja também 'ratsimp'.

     Quando 'ratdenomdivide' for 'true', 'ratexpand' expande uma razão
     na qual o numerador é uma adição dentro de uma adição de razões,
     todas tendo um denominador comum.  De outra forma, 'ratexpand'
     contrai uma soma de razões em uma razão simples, cujo numerador é a
     soma dos numeradores de cada razão.

     Quando 'keepfloat' for 'true', evita que números em ponto flutuante
     sejam racionalizados quando expressões que contenham números em
     ponto flutuante forem convertidas para a forma de expressão
     racional canónica (CRE).

     Exemplos:

          (%i1) ratexpand ((2*x - 3*y)^3);
                               3         2       2        3
          (%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
          (%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                                   x - 1       1
          (%o2)                   -------- + -----
                                         2   x - 1
                                  (x + 1)
          (%i3) expand (expr);
                              x              1           1
          (%o3)          ------------ - ------------ + -----
                          2              2             x - 1
                         x  + 2 x + 1   x  + 2 x + 1
          (%i4) ratexpand (expr);
                                  2
                               2 x                 2
          (%o4)           --------------- + ---------------
                           3    2            3    2
                          x  + x  - x - 1   x  + x  - x - 1

 -- Variável de opção: ratfac
     Valor Padrão: 'false'

     Quando 'ratfac' for 'true', expressões racionais canónicas (CRE)
     são manipuladas na forma parcialmente factorizada.

     Durante operações racionais a expressão é mantida como
     completamente factorizada como foi possível sem chamadas a
     'factor'.  Isso pode sempre economizar espaço e pode economizar
     tempo em algumas computações.  O numerador e o denominador são
     feitos relativamente primos, por exemplo 'rat ((x^2 - 1)^4/(x +
     1)^2)' retorna '(x - 1)^4 (x + 1)^2)', mas o factor dentro de cada
     parte pode não ser relativamente primo.

     No pacote 'ctensor' (Manipulação de componentes de tensores),
     tensores de Ricci, Einstein, Riemann, e de Weyl e a curvatura
     escalar são factorizados automaticamente quando 'ratfac' for
     'true'.  'ratfac' pode somente ser escolhido para casos onde as
     componentes tensoriais sejam sabidametne consistidas de poucos
     termos.

     Os esquemas de 'ratfac' e de 'ratweight' são incompatíveis e não
     podem ambos serem usados ao mesmo tempo.

 -- Função: ratnumer (<expr>)
     Retorna o numerador de <expr>, após forçar <expr> para uma
     expressão racional canónica (CRE). O valor de retorno é uma CRE.

     <expr> é forçada para uma CRE por 'rat' se isso não for já uma CRE.
     Essa conversão pode alterar a forma de <expr> pela colocação de
     todos os termos sobre um denominador comum.

     'num' é similar, mas retorna uma expressão comum em lugar de uma
     CRE. Também, 'num' não tenta colocar todos os termos sobre um
     denominador comum, e dessa forma algumas expressões que são
     consideradas razões por 'ratnumer' não são consideradas razões por
     'num'.

 -- Função: ratnump (<expr>)
     Retorna 'true' se <expr> for um inteiro literal ou razão de
     inteiros literais, de outra forma retorna 'false'.

 -- Função: ratp (<expr>)
     Retorna 'true' se <expr> for uma expressão racional canónica (CRE)
     ou CRE extendida, de outra forma retorna 'false'.

     CRE são criadas por 'rat' e funções relacionadas.  CRE extendidas
     são criadas por 'taylor' e funções relacionadas.

 -- Variável de opção: ratprint
     Valor Padrão: 'true'

     Quando 'ratprint' for 'true', uma mensagem informando ao utilizador
     da conversão de números em ponto flutuante para números racionais é
     mostrada.

 -- Função: ratsimp (<expr>)
 -- Função: ratsimp (<expr>, <x_1>, ..., <x_n>)
     Simplifica a expressão <expr> e todas as suas subexpressões,
     incluindo os argumentos para funções não racionais.  O resultado é
     retornado como o quociente de dois polinómios na forma recursiva,
     isto é, os coeficientes de variável principal são polinómios em
     outras variáveis.  Variáveis podem incluir funções não racionais
     (e.g., 'sin (x^2 + 1)') e os argumentos para quaisquer tais funções
     são também simplificados racionalmente.

     'ratsimp (<expr>, <x_1>, ..., <x_n>)' habilita simplificação
     racional com a especiicação de variável ordenando como em
     'ratvars'.

     Quando 'ratsimpexpons' for 'true', 'ratsimp' é aplicado para os
     expoentes de expressões durante a simplificação.

     Veja também 'ratexpand'.  Note que 'ratsimp' é afectado por algum
     dos sinalizadores que afectam 'ratexpand'.

     Exemplos:

          (%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                                   2      2
                             x         (log(x) + 1)  - log (x)
          (%o1)        sin(------) = %e
                            2
                           x  + x
          (%i2) ratsimp (%);
                                       1          2
          (%o2)                  sin(-----) = %e x
                                     x + 1
          (%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                                 3/2
                          (x - 1)    - sqrt(x - 1) (x + 1)
          (%o3)           --------------------------------
                               sqrt((x - 1) (x + 1))
          (%i4) ratsimp (%);
                                     2 sqrt(x - 1)
          (%o4)                    - -------------
                                           2
                                     sqrt(x  - 1)
          (%i5) x^(a + 1/a), ratsimpexpons: true;
                                         2
                                        a  + 1
                                        ------
                                          a
          (%o5)                        x

 -- Variável de opção: ratsimpexpons
     Valor Padrão: 'false'

     Quando 'ratsimpexpons' for 'true', 'ratsimp' é aplicado para os
     expoentes de expressões durante uma simplificação.

 -- Função: ratsubst (<a>, <b>, <c>)
     Substitue <a> por <b> em <c> e retorna a expressão resultante.  <b>
     pode também ser uma adição, produto, expoente, etc.

     'ratsubst' sabe alguma coisa do significado de expressões uma vez
     que 'subst' não é uma substituição puramente sintática.  Dessa
     forma 'subst (a, x + y, x + y + z)' retorna 'x + y + z' ao passo
     que 'ratsubst' retorna 'z + a'.

     Quando 'radsubstflag' for 'true', 'ratsubst' faz substituição de
     radicais em expressões que explicitamente não possuem esses
     radicais.

     Exemplos:

          (%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                                        3      4
          (%o1)                      a x  y + a
          (%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
                         4         3         2
          (%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
          (%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
                      4           2                     2
          (%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
          (%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                                  4           2
          (%o4)                cos (x) - 2 cos (x) + 1
          (%i5) radsubstflag: false$
          (%i6) ratsubst (u, sqrt(x), x);
          (%o6)                           x
          (%i7) radsubstflag: true$
          (%i8) ratsubst (u, sqrt(x), x);
                                          2
          (%o8)                          u

 -- Função: ratvars (<x_1>, ..., <x_n>)
 -- Função: ratvars ()
 -- Variável de sistema: ratvars
     Declara variáveis principais <x_1>, ..., <x_n> para expressões
     racionais.  <x_n>, se presente em uma expressão racional, é
     considerada a variável principal.  De outra forma, <x_[n-1]> é
     considerada a variável principal se presente, e assim por diante
     até as variáveis precedentes para <x_1>, que é considerada a
     variável principal somente se nenhuma das variáveis que a sucedem
     estiver presente.

     Se uma variável em uma expressão racional não está presente na
     lista 'ratvars', a ela é dada uma prioridade menor que <x_1>.

     Os argumentos para 'ratvars' podem ser ou variáveis ou funções não
     racionais tais como 'sin(x)'.

     A variável 'ratvars' é uma lista de argumentos da função 'ratvars'
     quando ela foi chamada mais recentemente.  Cada chamada para a
     função 'ratvars' sobre-grava a lista apagando seu conteúdo
     anterior.  'ratvars ()' limpa a lista.

 -- Função: ratweight (<x_1>, <w_1>, ..., <x_n>, <w_n>)
 -- Função: ratweight ()
     Atribui um peso <w_i> para a variável <x_i>.  Isso faz com que um
     termo seja substituído por 0 se seu peso exceder o valor da
     variável 'ratwtlvl' (o padrão retorna sem truncação).  O peso de um
     termo é a soma dos produtos dos pesos de uma variável no termo
     vezes seu expoente.  Por exemplo, o peso de '3 x_1^2 x_2' é '2 w_1
     + w_2'.  A truncação de acordo com 'ratwtlvl' é realizada somente
     quando multiplicando ou exponencializando expressões racionais
     canónicas (CRE).

     'ratweight ()' retorna a lista cumulativa de atribuições de pesos.

     Nota: Os esquemas de 'ratfac' e 'ratweight' são incompatíveis e não
     podem ambo serem usados ao mesmo tempo.

     Exemplos:

          (%i1) ratweight (a, 1, b, 1);
          (%o1)                     [a, 1, b, 1]
          (%i2) expr1: rat(a + b + 1)$
          (%i3) expr1^2;
                            2                  2
          (%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
          (%i4) ratwtlvl: 1$
          (%i5) expr1^2;
          (%o5)/R/                  2 b + 2 a + 1

 -- Variável de sistema: ratweights
     Valor Padrão: '[]'

     'ratweights' é a lista de pesos atribuídos por 'ratweight'.  A
     lista é cumulativa: cada chamada a 'ratweight' coloca ítens
     adicionais na lista.

     'kill (ratweights)' e 'save (ratweights)' ambos trabalham como
     esperado.

 -- Variável de opção: ratwtlvl
     Valor Padrão: 'false'

     'ratwtlvl' é usada em combinação com a função 'ratweight' para
     controlar a truncação de expressão racionais canónicas (CRE). Para
     o valor padrão 'false', nenhuma truncação ocorre.

 -- Função: remainder (<p_1>, <p_2>)
 -- Função: remainder (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Retorna o resto do polinómio <p_1> dividido pelo polinómio <p_2>.
     Os argumentos <x_1>, ..., <x_n> são interpretados como em
     'ratvars'.

     'remainder' retorna o segundo elemento de uma lista de dois
     elementos retornada por 'divide'.

 -- Função: resultant (<p_1>, <p_2>, <x>)
 -- Variável: resultant
     Calcula o resultante de dois polinómios <p_1> e <p_2>, eliminando a
     variável <x>.  O resultante é um determinante dos coeficientes de
     <x> em <p_1> e <p_2>, que é igual a zero se e somente se <p_1> e
     <p_2> tiverem um factor em comum não constante.

     Se <p_1> ou <p_2> puderem ser factorizados, pode ser desejável
     chamar 'factor' antes de chamar 'resultant'.

     A variável 'resultant' controla que algoritmo será usado para
     calcular o resultante.  'subres' para o prs subresultante, 'mod'
     para o algoritmo resultante modular, e 'red' para prs reduzido.
     Para muitos problemas 'subres' pode ser melhor.  Para alguns
     problemas com valores grandes de grau de uma única variável ou de
     duas variáveis 'mod' pode ser melhor.

     A função 'bezout' aceita os mesmos argumentos que 'resultant' e
     retorna uma matriz.  O determinante do valor de retorno é o
     resultante desejado.

 -- Variável de opção: savefactors
     Valor Padrão: 'false'

     Quando 'savefactors' for 'true', faz com que os factores de uma
     expressão que é um produto de factores sejam gravados por certas
     funções com o objectivo de aumentar a velocidade em posteriores
     factorizações de expressões contendo algum desses mesmos factores.

 -- Função: sqfr (<expr>)
     é similar a 'factor' excepto que os factores do polinómio são
     "livres de raízes".  Isto é, eles possuem factores somente de grau
     um.  Esse algoritmo, que é também usado no primeiro estágio de
     'factor', utiliza o facto que um polinómio tem em comum com sua
     n'ésima derivada todos os seus factores de grau maior que n.  Dessa
     forma obtendo o maior divisor comum com o polinómio das derivadas
     com relação a cada variável no polinómio, todos os factores de grau
     maior que 1 podem ser achados.

     Exemplo:

          (%i1) sqfr (4*x^4 + 4*x^3 - 3*x^2 - 4*x - 1);
                                          2   2
          (%o1)                  (2 x + 1)  (x  - 1)

 -- Função: tellrat (<p_1>, ..., <p_n>)
 -- Função: tellrat ()
     Adiciona ao anel dos inteiros algébricos conhecidos do Maxima os
     elementos que são as soluções dos polinómios <p_1>, ..., <p_n>.
     Cada argumento <p_i> é um polinómio concoeficientes inteiros.

     'tellrat (<x>)' efectivamente significa substituir 0 por <x> em
     funções racionais.

     'tellrat ()' retorna uma lista das substituições correntes.

     'algebraic' deve ser escolhida para 'true' com o objectivo de que a
     simplificação de inteiros algébricos tenha efeito.

     Maxima inicialmente sabe sobre a unidade imaginária '%i' e todas as
     raízes de inteiros.

     Existe um comando 'untellrat' que recebe núcleos e remove
     propriedades 'tellrat'.

     Quando fazemos 'tellrat' em um polinómio de várias variáveis, e.g.,
     'tellrat (x^2 - y^2)', pode existir uma ambiguidade como para ou
     substituir '<y>^2' por '<x>^2' ou vice-versa.  Maxima selecciona
     uma ordenação particular, mas se o utilizador desejar especificar
     qual e.g.  'tellrat (y^2 = x^2)' forneçe uma sintaxe que diga para
     substituir '<y>^2' por '<x>^2'.

     Exemplos:

          (%i1) 10*(%i + 1)/(%i + 3^(1/3));
                                     10 (%i + 1)
          (%o1)                      -----------
                                            1/3
                                      %i + 3
          (%i2) ev (ratdisrep (rat(%)), algebraic);
                       2/3      1/3              2/3      1/3
          (%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
          (%i3) tellrat (1 + a + a^2);
                                      2
          (%o3)                     [a  + a + 1]
          (%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                                1                 a
          (%o4)           ------------- + -----------------
                          sqrt(2) a - 1   sqrt(3) + sqrt(2)
          (%i5) ev (ratdisrep (rat(%)), algebraic);
                   (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
          (%o5)    ----------------------------------------------
                                         7
          (%i6) tellrat (y^2 = x^2);
                                  2    2   2
          (%o6)                 [y  - x , a  + a + 1]

 -- Função: totaldisrep (<expr>)
     Converte toda subexpressão de <expr> da forma de expressão
     racionais canónicas (CRE) para a forma geral e retorna o resultado.
     Se <expr> é em sí mesma na forma CRE então 'totaldisrep' é identica
     a 'ratdisrep'.

     'totaldisrep' pode ser usada para fazer um 'ratdisrep' em
     expressões tais como equações, listas, matrizes, etc., que tiverem
     algumas subexpressões na forma CRE.

 -- Função: untellrat (<x_1>, ..., <x_n>)
     Remove propriedades 'tellrat' de <x_1>, ..., <x_n>.


File: maxima.info,  Node: Constantes,  Next: Logaritmos,  Prev: Polinómios,  Up: Top

13 Constantes
*************

* Menu:

* Definições para Constantes::


File: maxima.info,  Node: Definições para Constantes,  Prev: Constantes,  Up: Constantes

13.1 Definições para Constantes
===============================

 -- Constante: %e
     '%e' representa a base do logaritmo natural, também conhecido como
     constante de Euler.  O valor numérico de '%e' é um número em ponto
     flutuante de precisão dupla 2.718281828459045d0.

 -- Constante: %i
     '%i' representa a unidade imaginária, sqrt(- 1).

 -- Constante: false
     'false' representa a constante Booleana falso.  Maxima implementa
     'false' através do valor 'NIL' no Lisp.

 -- Constante: inf
     'inf' representa o infinito positivo real.

 -- Constante: infinity
     'infinity' representa o infinito complexo.

 -- Constante: minf
     'minf' representa o menos infinito (i.e., negativo) real.

 -- Constante: %phi

     '%phi' representa o então chamado número áureo, (1 + sqrt(5))/2.  O
     valor numérico de '%phi' é o número em ponto flutuante de de dupla
     precisão 1.618033988749895d0.

     'fibtophi' expressa números de Fibonacci 'fib(n)' em termos de
     '%phi'.

     Por padrão, Maxima não conhece as propriedade algébricas de '%phi'.
     Após avaliar 'tellrat(%phi^2 - %phi - 1)' e 'algebraic: true',
     'ratsimp' pode simplificar algumas expressãoes contendo '%phi'.

     Exemplos:

     'fibtophi' expresses Fibonacci numbers 'fib(n)' in terms of '%phi'.

          (%i1) fibtophi (fib (n));
                                     n             n
                                 %phi  - (1 - %phi)
          (%o1)                  -------------------
                                     2 %phi - 1
          (%i2) fib (n-1) + fib (n) - fib (n+1);
          (%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
          (%i3) fibtophi (%);
                      n + 1             n + 1       n             n
                  %phi      - (1 - %phi)        %phi  - (1 - %phi)
          (%o3) - --------------------------- + -------------------
                          2 %phi - 1                2 %phi - 1
                                                    n - 1             n - 1
                                                %phi      - (1 - %phi)
                                              + ---------------------------
                                                        2 %phi - 1
          (%i4) ratsimp (%);
          (%o4)                           0

     Por padrão, Maxima não conhece as propriedade algébricas de '%phi'.
     Após avaliar 'tellrat(%phi^2 - %phi - 1)' e 'algebraic: true',
     'ratsimp' pode simplificar algumas expressãoes contendo '%phi'.

          (%i1) e : expand ((%phi^2 - %phi - 1) * (A + 1));
                           2                      2
          (%o1)        %phi  A - %phi A - A + %phi  - %phi - 1
          (%i2) ratsimp (e);
                            2                     2
          (%o2)        (%phi  - %phi - 1) A + %phi  - %phi - 1
          (%i3) tellrat (%phi^2 - %phi - 1);
                                      2
          (%o3)                  [%phi  - %phi - 1]
          (%i4) algebraic : true;
          (%o4)                         true
          (%i5) ratsimp (e);
          (%o5)                           0

 -- Constante: %pi
     '%pi' representa a razão do perímetro de um círculo para seu
     diâmetro.  O valor numérico de '%pi' é o n;umero em ponto flutuante
     de dupla precisão 3.141592653589793d0.

 -- Constante: true
     'true' representa a constante Booleana verdadeiro.  Maxima
     implementa 'true' através do valor 'T' no Lisp.


File: maxima.info,  Node: Logaritmos,  Next: Trigonometria,  Prev: Constantes,  Up: Top

14 Logaritmos
*************

* Menu:

* Definições para Logaritmos::


File: maxima.info,  Node: Definições para Logaritmos,  Prev: Logaritmos,  Up: Logaritmos

14.1 Definições para Logaritmos
===============================

 -- Variável de opção: %e_to_numlog
     Valor por omissão: 'false'

     Quando 'true', sendo 'r' algum número racional, e 'x' alguma
     expressão, '%e^(r*log(x))' será simplificado em 'x^r' .  Note-se
     que o comando 'radcan' também faz essa transformação, assim como
     algumas transformações mais complicadas.  O comando 'logcontract'
     _contrai_ expressões contendo 'log'.

 -- Função: li [<s>] (<z>)
     Representa a função polilogaritmo de ordem <s> e argumento <z>,
     definida por meio da série infinita

                                           inf
                                           ====   k
                                           \     z
                                  Li (z) =  >    --
                                    s      /      s
                                           ====  k
                                           k = 1

     'li [1]' é '- log (1 - z)'.  'li [2]' e 'li [3]' são as funções
     dilogaritmo e trilogaritmo, respectivamente.

     Quando a ordem for 1, o polilogaritmo simplifica para '- log (1 -
     z)', o qual por sua vez simplifica para um valor numérico se <z>
     for um número em ponto flutuante real ou complexo ou o sinalizador
     de avaliação 'numer' estiver presente.

     Quando a ordem for 2 ou 3, o polilogaritmo simplifica para um valor
     numérico se <z> for um número real em ponto flutuante ou o
     sinalizador de avaliação 'numer' estiver presente.

     Exemplos:

          (%i1) assume (x > 0);
          (%o1)                        [x > 0]
          (%i2) integrate ((log (1 - t)) / t, t, 0, x);
          (%o2)                       - li (x)
                                          2
          (%i3) li [2] (7);
          (%o3)                        li (7)
                                         2
          (%i4) li [2] (7), numer;
          (%o4)        1.24827317833392 - 6.113257021832577 %i
          (%i5) li [3] (7);
          (%o5)                        li (7)
                                         3
          (%i6) li [2] (7), numer;
          (%o6)        1.24827317833392 - 6.113257021832577 %i
          (%i7) L : makelist (i / 4.0, i, 0, 8);
          (%o7)   [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]
          (%i8) map (lambda ([x], li [2] (x)), L);
          (%o8) [0, .2676526384986274, .5822405249432515,
          .9784693966661848, 1.64493407, 2.190177004178597
           - .7010261407036192 %i, 2.374395264042415
           - 1.273806203464065 %i, 2.448686757245154
           - 1.758084846201883 %i, 2.467401098097648
           - 2.177586087815347 %i]
          (%i9) map (lambda ([x], li [3] (x)), L);
          (%o9) [0, .2584613953442624, 0.537213192678042,
          .8444258046482203, 1.2020569, 1.642866878950322
           - .07821473130035025 %i, 2.060877505514697
           - .2582419849982037 %i, 2.433418896388322
           - .4919260182322965 %i, 2.762071904015935
           - .7546938285978846 %i]

 -- Função: log (<x>)
     Representa o logaritmo natural (base e) de <x>.

     Maxima não possui uma função interna para logaritmo de base 10 ou
     de outras bases.  'log10(x) := log(x) / log(10)' é uma definição
     útil.

     A simplificação e avaliação de logaritmos são governadas por vários
     sinalizadores globais:

     'logexpand' - faz com que 'log(a^b)' se transfome em 'b*log(a)'.
     Se 'logexpand' tiver o valor 'all', 'log(a*b)' irá também
     simplificar para 'log(a)+log(b)'.  Se 'logexpand' for igual a
     'super', então 'log(a/b)' irá também simplificar para
     'log(a)-log(b)' para números racionais 'a/b', 'a#1' ('log(1/b)',
     para 'b' inteiro, sempre simplifica).  Se 'logexpand' for igaul a
     'false', todas essas simplificações irão ser desabilitadas.

     'logsimp' - se tiver valor 'false', não será feita nenhuma
     simplificação de '%e' para um expoente contendo 'log''s.

     'lognumer' - se tiver valor 'true', os argumentos negativos em
     ponto flutuante para 'log' irá sempre ser convertidos para seu
     valor absoluto antes que 'log' seja calculado.  Se 'numer' for
     também 'true', então argumentos negativos inteiros para 'log' irão
     também ser convertidos para os seus valores absolutos.

     'lognegint' - se tiver valor 'true', implementa a regra 'log(-n)'
     -> 'log(n)+%i*%pi' para 'n' um inteiro positivo.

     '%e_to_numlog' - quando for igual a 'true', '%e^(r*log(x))', sendo
     'r' algum número racional, e 'x' alguma expressão, será
     simplificado para 'x^r'.  Note-se que o comando 'radcan' também faz
     essa transformação, e outras transformações mais complicadas desse
     género.

     O comando 'logcontract' "contrai" expressões contendo 'log'.

 -- Variável de opção: logabs
     Valor por omissão: 'false'

     No cálculo de primitivas em que sejam gerados logaritmos, por
     exemplo, 'integrate(1/x,x)', a resposta será dada em termos de
     'log(abs(...))' se 'logabs' for 'true', mas em termos de 'log(...)'
     se 'logabs' for 'false'.  Para integrais definidos, usa-se
     'logabs:true', porque nesse caso muitas vezes é necessário calcular
     a primitiva nos extremos.

 -- Variável de opção: logarc
 -- Função: logarc (<expr>)

     Quando a variável global 'logarc' for igual a 'true', as funções
     trigononométricas inversas, circulares e hiperbólicas, serão
     substituídas por suas funções logarítmicas equivalentes.  O valor
     padrão de 'logarc' é 'false'.

     A função 'logarc(<expr>)' realiza essa substituição para uma
     expressão <expr> sem modificar o valor da variável global 'logarc'.

 -- Variável de opção: logconcoeffp
     Valor por omissão: 'false'

     Controla quais coeficientes são contraídos quando se usa
     'logcontract'.  Poderá ser igual ao nome de uma função de um
     argumento.  Por exemplo, se quiser gerar raízes quadradas, pode
     fazer 'logconcoeffp:'logconfun$ logconfun(m):=featurep(m,integer)
     or ratnump(m)$'.  E assim, 'logcontract(1/2*log(x));' produzirá
     'log(sqrt(x))'.

 -- Função: logcontract (<expr>)
     Examina recursivamente a expressão <expr>, transformando
     subexpressões da forma 'a1*log(b1) + a2*log(b2) + c' em
     'log(ratsimp(b1^a1 * b2^a2)) + c'

          (%i1) 2*(a*log(x) + 2*a*log(y))$
          (%i2) logcontract(%);
                                           2  4
          (%o2)                     a log(x  y )

     Se fizer 'declare(n,integer);' então 'logcontract(2*a*n*log(x));'
     produzirá 'a*log(x^(2*n))'.  Os coeficientes que _contraem_ dessa
     maneira são os que, tal como 2 e 'n' neste exemplo, satisfazem
     'featurep(coeficiente,integer)'.  O utilizador pode controlar quais
     coeficientes são contraídos, dando à variável 'logconcoeffp' o nome
     de uma função de um argumento.  Por exemplo, se quiser gerar raízes
     quadradas, pode fazer 'logconcoeffp:'logconfun$
     logconfun(m):=featurep(m,integer) or ratnump(m)$'.  E assim,
     'logcontract(1/2*log(x));' produzirá 'log(sqrt(x))'.

 -- Variável de opção: logexpand
     Valor por omissão: 'true'

     Faz com que 'log(a^b)' se transfome em 'b*log(a)'.  Se 'logexpand'
     tiver o valor 'all', 'log(a*b)' irá também simplificar para
     'log(a)+log(b)'.  Se 'logexpand' for igual a 'super', então
     'log(a/b)' irá também simplificar para 'log(a)-log(b)' para números
     racionais 'a/b', 'a#1' ('log(1/b)', para 'b' inteiro, sempre
     simplifica).  Se 'logexpand' for igaul a 'false', todas essas
     simplificações irão ser desabilitadas.

 -- Variável de opção: lognegint
     Valor por omissão: 'false'

     Se for igual a 'true', implementa a regra 'log(-n)' ->
     'log(n)+%i*%pi' para 'n' um inteiro positivo.

 -- Variável de opção: lognumer
     Valor por omissão: 'false'

     Se tiver valor 'true', os argumentos negativos em ponto flutuante
     para 'log' irá sempre ser convertidos para seu valor absoluto antes
     que 'log' seja calculado.  Se 'numer' for também 'true', então
     argumentos negativos inteiros para 'log' irão também ser
     convertidos para os seus valores absolutos.

 -- Variável de opção: logsimp
     Valor por omissão: 'true'

     Se tiver valor 'false', não será feita nenhuma simplificação de
     '%e' para um expoente contendo 'log''s.

 -- Função: plog (<x>)
     Representa o ramo principal dos logaritmos naturais no plano
     complexo, com '-%pi' < 'carg(<x>)' <= '+%pi'.


File: maxima.info,  Node: Trigonometria,  Next: Funções Especiais,  Prev: Logaritmos,  Up: Top

15 Trigonometria
****************

* Menu:

* Introdução ao Pacote Trigonométrico::  
* Definições para Trigonometria::  


File: maxima.info,  Node: Introdução ao Pacote Trigonométrico,  Next: Definições para Trigonometria,  Prev: Trigonometria,  Up: Trigonometria

15.1 Introdução ao Pacote Trigonométrico
========================================

Maxima tem muitas funções trigonométricas definidas.  Não todas as
identidades trigonometricas estão programadas, mas isso é possível para
o utilizador adicionar muitas delas usando a compatibilidade de
correspondência de modelos do sistema.  As funções trigonométricas
definidas no Maxima são: 'acos', 'acosh', 'acot', 'acoth', 'acsc',
'acsch', 'asec', 'asech', 'asin', 'asinh', 'atan', 'atanh', 'cos',
'cosh', 'cot', 'coth', 'csc', 'csch', 'sec', 'sech', 'sin', 'sinh',
'tan', e 'tanh'.  Existe uma colecção de comandos especialmente para
manusear funções trigonométricas, veja 'trigexpand', 'trigreduce', e o
comutador 'trigsign'.  Dois pacotes compartilhados extendem as regras de
simplificação construídas no Maxima, 'ntrig' e 'atrig1'.  Faça
'describe(<comando>)' para detalhes.


File: maxima.info,  Node: Definições para Trigonometria,  Prev: Introdução ao Pacote Trigonométrico,  Up: Trigonometria

15.2 Definições para Trigonometria
==================================

 -- Função: acos (<x>)
     - Arco Cosseno.

 -- Função: acosh (<x>)
     - Arco Cosseno Hiperbólico.

 -- Função: acot (<x>)
     - Arco Cotangente.

 -- Função: acoth (<x>)
     - Arco Cotangente Hiperbólico.

 -- Função: acsc (<x>)
     - Arco Cossecante.

 -- Função: acsch (<x>)
     - Arco Cossecante Hiperbólico.

 -- Função: asec (<x>)
     - Arco Secante.

 -- Função: asech (<x>)
     - Arco Secante Hiperbólico.

 -- Função: asin (<x>)
     - Arco Seno.

 -- Função: asinh (<x>)
     - Arco Seno Hiperbólico.

 -- Função: atan (<x>)
     - Arco Tangente.

 -- Função: atan2 (<y>, <x>)
     - retorna o valor de 'atan(<y>/<x>)' no intervalo de '-%pi' a
     '%pi'.

 -- Função: atanh (<x>)
     - Arco tangente Hiperbólico.

 -- Pacote: atrig1
     O pacote 'atrig1' contém muitas regras adicionais de simplificação
     para funções trigonométricas inversas.  Junto com regras já
     conhecidas para Maxima, os seguintes ângulos estão completamente
     implementados: '0', '%pi/6', '%pi/4', '%pi/3', e '%pi/2'.  Os
     ângulos correspondentes nos outros três quadrantes estão também
     disponíveis.  Faça 'load(atrig1);' para usá-lo.

 -- Função: cos (<x>)
     - Cosseno.

 -- Função: cosh (<x>)
     - Cosseno hiperbólico.

 -- Função: cot (<x>)
     - Cotangente.

 -- Função: coth (<x>)
     - Cotangente Hyperbólica.

 -- Função: csc (<x>)
     - Cossecante.

 -- Função: csch (<x>)
     - Cossecante Hyperbólica.

 -- Variável de opção: halfangles
     Default value: 'false'

     Quando 'halfangles' for 'true', meios-ângulos são simplificados
     imediatamente.

 -- Pacote: ntrig
     O pacote 'ntrig' contém um conjunto de regras de simplificação que
     são usadas para simplificar função trigonométrica cujos argumentos
     estão na forma '<f>(<n> %pi/10)' onde <f> é qualquer das funções
     'sin', 'cos', 'tan', 'csc', 'sec' e 'cot'.

 -- Função: sec (<x>)
     - Secante.

 -- Função: sech (<x>)
     - Secante Hyperbólica.

 -- Função: sin (<x>)
     - Seno.

 -- Função: sinh (<x>)
     - Seno Hyperbólico.

 -- Função: tan (<x>)
     - Tangente.

 -- Função: tanh (<x>)
     - Tangente Hyperbólica.

 -- Função: trigexpand (<expr>)
     Expande funções trigonometricas e hyperbólicas de adições de
     ângulos e de ângulos multiplos que ocorram em <expr>.  Para
     melhores resultados, <expr> deve ser expandida.  Para intensificar
     o controle do utilizador na simplificação, essa função expande
     somente um nível de cada vez, expandindo adições de ângulos ou
     ângulos multiplos.  Para obter expansão completa dentro de senos e
     co-senos imediatamente, escolha o comutador 'trigexpand: true'.

     'trigexpand' é governada pelos seguintes sinalizadores globais:

     'trigexpand'
          Se 'true' causa expansão de todas as expressões contendo senos
          e co-senos ocorrendo subsequêntemente.
     'halfangles'
          Se 'true' faz com que meios-ângulos sejam simplificados
          imediatamente.
     'trigexpandplus'
          Controla a regra "soma" para 'trigexpand', expansão de adições
          (e.g.  'sin(x + y)') terão lugar somente se 'trigexpandplus'
          for 'true'.
     'trigexpandtimes'
          Controla a regra "produto" para 'trigexpand', expansão de
          produtos (e.g.  'sin(2 x)') terão lugar somente se
          'trigexpandtimes' for 'true'.

     Exemplos:

          (%i1) x+sin(3*x)/sin(x),trigexpand=true,expand;
                                   2           2
          (%o1)               - sin (x) + 3 cos (x) + x
          (%i2) trigexpand(sin(10*x+y));
          (%o2)          cos(10 x) sin(y) + sin(10 x) cos(y)

 -- Variável de opção: trigexpandplus
     Valor por omissão: 'true'

     'trigexpandplus' controla a regra da "soma" para 'trigexpand'.
     Dessa forma, quando o comando 'trigexpand' for usado ou o comutador
     'trigexpand' escolhido para 'true', expansão de adições (e.g.
     'sin(x+y))' terão lugar somente se 'trigexpandplus' for 'true'.

 -- Variável de opção: trigexpandtimes
     Valor por omissão: 'true'

     'trigexpandtimes' controla a regra "produto" para 'trigexpand'.
     Dessa forma, quando o comando 'trigexpand' for usado ou o comutador
     'trigexpand' escolhido para 'true', expansão de produtos (e.g.
     'sin(2*x)') terão lugar somente se 'trigexpandtimes' for 'true'.

 -- Variável de opção: triginverses
     Valor por omissão: 'all'

     'triginverses' controla a simplificação de composições de funções
     trigonométricas e hiperbólicas com suas funções inversas.

     Se 'all', ambas e.g.  'atan(tan(<x>))' e 'tan(atan(<x>))'
     simplificarão para <x>.

     Se 'true', a simplificação de '<arcfun>(<fun>(<x>))' é
     desabilitada.

     Se 'false', ambas as simplificações '<arcfun>(<fun>(<x>))' e
     '<fun>(<arcfun>(<x>))' são desabilitadas.

 -- Função: trigreduce (<expr>, <x>)
 -- Função: trigreduce (<expr>)
     Combina produtos e expoentes de senos e cossenso trigonométricos e
     hiperbólicos de <x> dentro daqueles de múltiplos de <x>.  Também
     tenta eliminar essas funções quando elas ocorrerem em
     denominadores.  Se <x> for omitido então todas as variáveis em
     <expr> são usadas.

     Veja também 'poissimp'.

          (%i1) trigreduce(-sin(x)^2+3*cos(x)^2+x);
                         cos(2 x)      cos(2 x)   1        1
          (%o1)          -------- + 3 (-------- + -) + x - -
                            2             2       2        2

     As rotinas de simplificação trigonométrica irão usar informações
     declaradas em alguns casos simples.  Declarações sobre variáveis
     são usadas como segue, e.g.

          (%i1) declare(j, integer, e, even, o, odd)$
          (%i2) sin(x + (e + 1/2)*%pi);
          (%o2)                        cos(x)
          (%i3) sin(x + (o + 1/2)*%pi);
          (%o3)                       - cos(x)

 -- Variável de opção: trigsign
     Valor por omissão: 'true'

     Quando 'trigsign' for 'true', permite simplificação de argumentos
     negativos para funções trigonométricas.  E.g., 'sin(-x)'
     transformar-se-á em '-sin(x)' somente se 'trigsign' for 'true'.

 -- Função: trigsimp (<expr>)
     Utiliza as identidades sin(x)^2 + cos(x)^2 = 1 and cosh(x)^2 -
     sinh(x)^2 = 1 para simplificar expressões contendo 'tan', 'sec',
     etc., para 'sin', 'cos', 'sinh', 'cosh'.

     'trigreduce', 'ratsimp', e 'radcan' podem estar habilitadas a
     adicionar simplificações ao resultado.

     'demo ("trgsmp.dem")' mostra alguns exemplos de 'trigsimp'.

 -- Função: trigrat (<expr>)
     Fornece uma forma quase-linear simplificada canónica de uma
     expressão trigonométrica; <expr> é uma fração racional de muitos
     'sin', 'cos' ou 'tan', os argumentos delas são formas lineares em
     algumas variáveis (ou kernels-núcleos) e '%pi/<n>' (<n> inteiro)
     com coeficientes inteiros.  O resultado é uma fração simplificada
     com numerador e denominador ambos lineares em 'sin' e 'cos'.  Dessa
     forma 'trigrat' lineariza sempre quando isso for passível.

          (%i1) trigrat(sin(3*a)/sin(a+%pi/3));
          (%o1)            sqrt(3) sin(2 a) + cos(2 a) - 1

     O seguinte exemplo encontra-se em Davenport, Siret, and Tournier,
     Calcul Formel, Masson (ou em inglês, Addison-Wesley), secção 1.5.5,
     teorema de Morley.

          (%i1) c: %pi/3 - a - b;
                                              %pi
          (%o1)                     - b - a + ---
                                               3
          (%i2) bc: sin(a)*sin(3*c)/sin(a+b);
                                sin(a) sin(3 b + 3 a)
          (%o2)                 ---------------------
                                     sin(b + a)
          (%i3) ba: bc, c=a, a=c$
          (%i4) ac2: ba^2 + bc^2 - 2*bc*ba*cos(b);
                   2       2
                sin (a) sin (3 b + 3 a)
          (%o4) -----------------------
                         2
                      sin (b + a)

                                                  %pi
             2 sin(a) sin(3 a) cos(b) sin(b + a - ---) sin(3 b + 3 a)
                                                   3
           - --------------------------------------------------------
                                     %pi
                             sin(a - ---) sin(b + a)
                                      3

                2         2         %pi
             sin (3 a) sin (b + a - ---)
                                     3
           + ---------------------------
                       2     %pi
                    sin (a - ---)
                              3
          (%i5) trigrat (ac2);
          (%o5) - (sqrt(3) sin(4 b + 4 a) - cos(4 b + 4 a)

           - 2 sqrt(3) sin(4 b + 2 a) + 2 cos(4 b + 2 a)

           - 2 sqrt(3) sin(2 b + 4 a) + 2 cos(2 b + 4 a)

           + 4 sqrt(3) sin(2 b + 2 a) - 8 cos(2 b + 2 a) - 4 cos(2 b - 2 a)

           + sqrt(3) sin(4 b) - cos(4 b) - 2 sqrt(3) sin(2 b) + 10 cos(2 b)

           + sqrt(3) sin(4 a) - cos(4 a) - 2 sqrt(3) sin(2 a) + 10 cos(2 a)

           - 9)/4


File: maxima.info,  Node: Funções Especiais,  Next: Funções Elípticas,  Prev: Trigonometria,  Up: Top

16 Funções Especiais
********************

* Menu:

* Introdução a Funções Especiais::  
* Definições para Funções Especiais::  


File: maxima.info,  Node: Introdução a Funções Especiais,  Next: Definições para Funções Especiais,  Prev: Funções Especiais,  Up: Funções Especiais

16.1 Introdução a Funções Especiais
===================================

A notação de função especial segue adiante:

     bessel_j (index, expr)         Função de Bessel, primeiro tipo
     bessel_y (index, expr)         Função de Bessel, segundo tipo
     bessel_i (index, expr)         Função de Bessel modificada, primeiro tipo
     bessel_k (index, expr)         Função de Bessel modificada, segundo tipo
     %he[n] (z)                     Polinómio de Hermite (Note bem: he, não h. Veja A&S 22.5.18)
     %p[u,v] (z)                    Função de Legendre
     %q[u,v] (z)                    Função de Legendre, segundo tipo
     hstruve[n] (z)                 Função H de Struve H
     lstruve[n] (z)                 Função de L Struve
     %f[p,q] ([], [], expr)         Função Hipergeométrica Generalizada
     gamma()                        Função Gamma
     gamma_incomplete_lower(a,z)    Função gama incompleta inferior
     gammaincomplete(a,z)           Final da função gama incompleta
     slommel
     %m[u,k] (z)                    Função de Whittaker, primeiro tipo
     %w[u,k] (z)                    Função de Whittaker, segundo tipo
     erfc (z)                       Complemento da função erf (função de erros - integral da distribuição normal)
     ei (z)                         Integral de exponencial (?)
     kelliptic (z)                  integral eliptica completa de primeiro tipo (K)
     %d [n] (z)                     Função cilíndrica parabólica


File: maxima.info,  Node: Definições para Funções Especiais,  Prev: Introdução a Funções Especiais,  Up: Funções Especiais

16.2 Definições para Funções Especiais
======================================

 -- Função: airy_ai (<x>)
     A função de Airy Ai, como definida em Abramowitz e Stegun, Handbook
     of Mathematical Functions, Sessão 10.4.

     A equação de Airy 'diff (y(x), x, 2) - x y(x) = 0' tem duas
     soluções linearmente independentes, 'y = Ai(x)' e 'y = Bi(x)'.  A
     derivada de 'diff (airy_ai(x), x)' é 'airy_dai(x)'.

     Se o argumento 'x' for um número real ou um número complexo
     qualquer deles em ponto flutuante , o valor numérico de 'airy_ai' é
     retornado quando possível.

     Veja também 'airy_bi', 'airy_dai', 'airy_dbi'.

 -- Função: airy_dai (<x>)
     A derivada da função de Airy Ai 'airy_ai(x)'.

     Veja 'airy_ai'.

 -- Função: airy_bi (<x>)
     A função de Airy Bi, como definida em Abramowitz e Stegun, Handbook
     of Mathematical Functions, Sessão 10.4, é a segunda solução da
     equação de Airy 'diff (y(x), x, 2) - x y(x) = 0'.

     Se o argumento 'x' for um número real ou um número complexo
     qualquer deles em ponto flutuante, o valor numérico de 'airy_bi' é
     retornado quando possível.  Em outros casos a expressão não
     avaliada é retornada.

     A derivada de 'diff (airy_bi(x), x)' é 'airy_dbi(x)'.

     Veja 'airy_ai', 'airy_dbi'.

 -- Função: airy_dbi (<x>)
     A derivada de função de Airy Bi 'airy_bi(x)'.

     Veja 'airy_ai' e 'airy_bi'.

 -- Função: asympa
     'asympa' é um pacote para análise assintótica.  O pacote contém
     funções de simplificação para análise assintótica, incluindo as
     funções "grande O" e "pequeno o" que são largamente usadas em
     análises de complexidade e análise numérica.

     'load ("asympa")' chama esse pacote.

 -- Função: bessel (<z>, <a>)
     A função de Bessel de primeiro tipo.

     Essa função está desactualizada.  Escreva 'bessel_j (<z>, <a>)' em
     lugar dessa.

 -- Função: bessel_j (<v>, <z>)
     A função de Bessel do primeiro tipo de ordem v e argumento z.

     'bessel_j' calcula o array 'besselarray' tal que 'besselarray [i] =
     bessel_j [i + v - int(v)] (z)' para 'i' de zero a 'int(v)'.

     'bessel_j' é definida como
                          inf
                          ====       k  - v - 2 k  v + 2 k
                          \     (- 1)  2          z
                           >    --------------------------
                          /        k! gamma(v + k + 1)
                          ====
                          k = 0

     todavia séries infinitas não são usadas nos cálculos.

 -- Função: bessel_y (<v>, <z>)
     A função de Bessel do segundo tipo de ordem v e argumento z.

     'bessel_y' calcula o array 'besselarray' tal que 'besselarray [i] =
     bessel_y [i + v - int(v)] (z)' para 'i' de zero a 'int(v)'.

     'bessel_y' é definida como
                        cos(%pi v) bessel_j(v, z) - bessel_j(-v, z)
                        -------------------------------------------
                                       sin(%pi v)

     quando v não for um inteiro.  Quando v for um inteiro n, o limite
     com v aprocimando-se de n é tomado.

 -- Função: bessel_i (<v>, <z>)
     A função de Bessel modificada de primeiro tipo de ordem v e
     argumento z.

     'bessel_i' calcula o array 'besselarray' tal que 'besselarray [i] =
     bessel_i [i + v - int(v)] (z)' para 'i' de zero a 'int(v)'.

     'bessel_i' é definida como
                              inf
                              ====   - v - 2 k  v + 2 k
                              \     2          z
                               >    -------------------
                              /     k! gamma(v + k + 1)
                              ====
                              k = 0

     todavia séries infinitas não são usadas nos cálculos.

 -- Função: bessel_k (<v>, <z>)
     A função de Bessel modificada de segundo tipo de ordem v e
     argumento z.

     'bessel_k' calcula o array 'besselarray' tal que 'besselarray [i] =
     bessel_k [i + v - int(v)] (z)' para 'i' de zero a 'int(v)'.

     'bessel_k' é definida como
                     %pi csc(%pi v) (bessel_i(-v, z) - bessel_i(v, z))
                     -------------------------------------------------
                                            2

     quando v não for inteiro.  Se v for um inteiro n, então o limite
     com v aproximando-se de n é tomado.

 -- Variável de opção: besselexpand
     Valor por omissão: 'false'

     Expansões de controle de funções de Bessel quando a ordem for a
     metade de um inteiro ímpar.  Nesse caso, as funções de Bessel podem
     ser expandidas em termos de outras funções elementares.  Quando
     'besselexpand' for 'true', a função de Bessel é expandida.

          (%i1) besselexpand: false$
          (%i2) bessel_j (3/2, z);
                                              3
          (%o2)                      bessel_j(-, z)
                                              2
          (%i3) besselexpand: true$
          (%i4) bessel_j (3/2, z);
                                    2 z   sin(z)   cos(z)
          (%o4)                sqrt(---) (------ - ------)
                                    %pi      2       z
                                            z

 -- Função: scaled_bessel_i (<v>, <z>)

     A função homotética modificada de Bessel de primeiro tipo de ordem
     v e argumento z.  Isto é, scaled_bessel_i(v,z) =
     exp(-abs(z))*bessel_i(v, z).  Essa função é particularmente útil
     para calcular bessel_i para grandes valores de z.  Todavia, maxima
     não conhece outra forma muito mais sobre essa função.  Para
     computação simbólica, é provavelmete preferível trabalhar com a
     expressão 'exp(-abs(z))*bessel_i(v, z)'.

 -- Função: scaled_bessel_i0 (<z>)

     Idêntica a 'scaled_bessel_i(0,z)'.

 -- Função: scaled_bessel_i1 (<z>)

     Idêntica a 'scaled_bessel_i(1,z)'.

 -- Função: beta (<x>, <y>)
     A função beta, definida como 'gamma(x) gamma(y)/gamma(x + y)'.

 -- Função: gamma (<x>)
     A função gama.

     Veja também 'makegamma'.

     A variável 'gammalim' controla a simplificação da função gama.

     A constante de Euler-Mascheroni é '%gamma'.

 -- Variável de opção: gammalim
     Valor por omissão: 1000000

     'gammalim' controla a simplificação da função gama para integral e
     argumentos na forma de números racionais.  Se o valor absoluto do
     argumento não for maior que 'gammalim', então a simplificação
     ocorrerá.  Note que 'factlim' comuta controle de simplificaçcão do
     resultado de 'gamma' de um argumento inteiro também.

 -- Função: intopois (<a>)
     Converte <a> em um código de Poisson.

 -- Função: makefact (<expr>)
     Transforma instâncias de funções binomiais, gama, e beta em <expr>
     para factoriais.

     Veja também 'makegamma'.

 -- Função: makegamma (<expr>)
     Transforma instâncias de funções binomiais, factorial, e beta em
     <expr> para funções gama.

     Veja também 'makefact'.

 -- Função: numfactor (<expr>)
     Retorna o factor numérico multiplicando a expressão <expr>, que
     pode ser um termo simples.

     'content' retorna o máximo divisor comum (mdc) de todos os termos
     em uma adição.

          (%i1) gamma (7/2);
                                    15 sqrt(%pi)
          (%o1)                     ------------
                                         8
          (%i2) numfactor (%);
                                         15
          (%o2)                          --
                                         8

 -- Função: outofpois (<a>)
     Converte <a> de um código de Poisson para uma representação geral.
     Se <a> não for uma forma de Poisson, 'outofpois' realiza a
     conversão, i.e., o valor de retorno é 'outofpois (intopois (<a>))'.
     Essa função é desse modo um simplificador canónico para adições e
     potências de termos de seno e co-seno de um tipo particular.

 -- Função: poisdiff (<a>, <b>)
     Deriva <a> com relação a <b>.  <b> deve ocorrer somente nos
     argumentos trigonométricos ou somente nos coeficientes.

 -- Função: poisexpt (<a>, <b>)
     Funcionalmente identica a 'intopois (<a>^<b>)'.  <b> deve ser um
     inteiro positico.

 -- Função: poisint (<a>, <b>)
     Integra em um senso restrito similarmente (para 'poisdiff').
     Termos não periódicos em <b> são diminuídos se <b> estiver em
     argumentos trigonométricos.

 -- Variável de opção: poislim
     Valor por omissão: 5

     'poislim' determina o domínio dos coeficientes nos argumentos de
     funções trigonométricas.  O valor inicial de 5 corresponde ao
     intervalo [-2^(5-1)+1,2^(5-1)], ou [-15,16], mas isso pode ser
     alterado para [-2^(n-1)+1, 2^(n-1)].

 -- Função: poismap (<series>, <sinfn>, <cosfn>)
     mapeará as funções <sinfn> sobre os termos de seno e <cosfn> ssobre
     os termos de co-seno das séries de Poisson dadas.  <sinfn> e
     <cosfn> são funções de dois argumentos que são um coeficiente e uma
     parte trigonométrica de um termo em séries respectivamente.

 -- Função: poisplus (<a>, <b>)
     É funcionalmente identica a 'intopois (a + b)'.

 -- Função: poissimp (<a>)
     Converte <a> em séries de Poisson para <a> em representação geral.

 -- Símbolo especial: poisson
     O símbolo '/P/' segue o rótulo de linha de uma expressão contendo
     séries de Poisson.

 -- Função: poissubst (<a>, <b>, <c>)
     Substitue <a> por <b> em <c>.  <c> é uma série de Poisson.

     (1) Quando <B> é uma variável <u>, <v>, <w>, <x>, <y>, ou <z>,
     então <a> deve ser uma expressão linear nessas variáveis (e.g.,
     '6*u + 4*v').

     (2) Quando <b> for outra que não essas variáveis, então <a> deve
     também ser livre dessas variáveis, e além disso, livre de senos ou
     co-senos.

     'poissubst (<a>, <b>, <c>, <d>, <n>)' é um tipo especial d
     substituição que opera sobre <a> e <b> como no tipo (1) acima, mas
     onde <d> é uma série de Poisson, expande 'cos(<d>)' e 'sin(<d>)'
     para a ordem <n> como provendo o resultado da substituição '<a> +
     <d>' por <b> em <c>.  A idéia é que <d> é uma expansão em termos de
     um pequeno parâmetro.  Por exemplo, 'poissubst (u, v, cos(v), %e,
     3)' retorna 'cos(u)*(1 - %e^2/2) - sin(u)*(%e - %e^3/6)'.

 -- Função: poistimes (<a>, <b>)
     É funcionalmente idêntica a 'intopois (<a>*<b>)'.

 -- Função: poistrim ()
     é um nome de função reservado que (se o utilizador tiver definido
     uma função com esse nome) é aplicada durante multiplicação de
     Poisson.  Isso é uma função predicada de 6 argumentos que são os
     coeficientes de <u>, <v>, ..., <z> em um termo.  Termos para os
     quais 'poistrim' for 'true' (para os coeficientes daquele termo)
     são eliminados durante a multiplicação.

 -- Função: printpois (<a>)
     Mostra uma série de Poisson em um formato legível.  Em comum com
     'outofpois', essa função converterá <a> em um código de Poisson
     primeiro, se necessário.

 -- Função: psi [<n>](<x>)

     A derivada de 'log (gamma (<x>))' de ordem '<n>+1'.  Dessa forma,
     'psi[0](<x>)' é a primeira derivada, 'psi[1](<x>)' é a segunda
     derivada, etc.

     Maxima não sabe como, em geral, calcular um valor numérico de
     'psi', mas Maxima pode calcular alguns valores exatos para
     argumentos racionais.  Muitas variáveis controlam qual intervalo de
     argumentos racionais 'psi' irá retornar um valor exato, se
     possível.  Veja 'maxpsiposint', 'maxpsinegint', 'maxpsifracnum', e
     'maxpsifracdenom'.  Isto é, <x> deve localizar-se entre
     'maxpsinegint' e 'maxpsiposint'.  Se o valor absoluto da parte
     facionária de <x> for racional e tiver um numerador menor que
     'maxpsifracnum' e tiver um denominador menor que 'maxpsifracdenom',
     'psi' irá retornar um valor exato.

     A função 'bfpsi' no pacote 'bffac' pode calcular valores numéricos.

 -- Variável de opção: maxpsiposint
     Valor por omissão: 20

     'maxpsiposint' é o maior valor positivo para o qual 'psi[n](x)' irá
     tentar calcular um valor exato.

 -- Variável de opção: maxpsinegint
     Valor por omissão: -10

     'maxpsinegint' é o valor mais negativo para o qual 'psi[n](x)' irá
     tentar calcular um valor exato.  Isto é, se <x> for menor que
     'maxnegint', 'psi[n](<x>)' não irá retornar resposta simplificada,
     mesmo se isso for possível.

 -- Variável de opção: maxpsifracnum
     Valor por omissão: 4

     Tomemos <x> como sendo um número racional menor que a unidade e da
     forma 'p/q'.  Se 'p' for menor que 'maxpsifracnum', então
     'psi[<n>](<x>)' não irá tentar retornar um valor simplificado.

 -- Função: specint (exp(- s*<t>) * <expr>, <t>)

     Calcula a transformada de Laplace de <expr> com ralação à variável
     <t>.  O integrando <expr> pode conter funções especiais.

     Se 'specint' não puder calcular a integral, o valore de retorno
     pode conter vários símbolos do Lisp, incluindo
     'other-defint-to-follow-negtest', 'other-lt-exponential-to-follow',
     'product-of-y-with-nofract-indices', etc.; isso é um erro.

     'demo(hypgeo)' mostra muitos exemplos de transformadas de Laplace
     calculados por 'specint'.

     Exemplos:

          (%i1) assume (p > 0, a > 0);
          (%o1)                    [p > 0, a > 0]
          (%i2) specint (t^(1/2) * exp(-a*t/4) * exp(-p*t), t);
                                     sqrt(%pi)
          (%o2)                     ------------
                                           a 3/2
                                    2 (p + -)
                                           4
          (%i3) specint (t^(1/2) * bessel_j(1, 2 * a^(1/2) * t^(1/2)) * exp(-p*t), t);
                                             - a/p
                                   sqrt(a) %e
          (%o3)                    ---------------
                                          2
                                         p

 -- Variável de opção: maxpsifracdenom
     Valor por omissão: 4

     Tomemos <x> como sendo um número racional menor que a unidade e da
     forma 'p/q'.  Se 'q' for maior que 'maxpsifracdeonm', então
     'psi[<n>](<x>)' não irá tentar retornar um valor simplificado.


File: maxima.info,  Node: Funções Elípticas,  Next: Limites,  Prev: Funções Especiais,  Up: Top

17 Funções Elípticas
********************

* Menu:

* Introdução a Funções Elípticas e Integrais::
* Definições para Funções Elípticas::
* Definições para Integrais Elípticas::


File: maxima.info,  Node: Introdução a Funções Elípticas e Integrais,  Next: Definições para Funções Elípticas,  Up: Top

17.1 Introdução a Funções Elípticas e Integrais
===============================================

Maxima inclui suporte a funções elípticas Jacobianas e a integrais
elípticas completas e incompletas.  Isso inclui manipulação simbólica
dessas funções e avaliação numérica também.  Definições dessas funções e
muitas de suas propriedades podem ser encontradas em Abramowitz e
Stegun, Capítulos 16-17.  Tanto quanto possível, usamos as definições e
relações dadas aí.

Em particular, todas as funções elípticas e integrais elípticas usam o
parâmetro m em lugar de módulo k ou o ângulo modular \alpha.  Isso é uma
área onde discordamos de Abramowitz e Stegun que usam o ângulo modular
para as funções elípticas.  As seguintes relações são verdadeiras: m =
k^2 e k = \sin(\alpha)

As funções elípticas e integrais elípticas estão primariamente
tencionando suportar computação simbólica.  Portanto, a maiora das
derivadas de funções e integrais são conhecidas.  Todavia, se valores em
ponto flutuante forem dados, um resultado em ponto flutuante é
retornado.

Suporte para a maioria de outras propriedades das funções elípticas e
integrais elípticas além das derivadas não foram ainda escritas.

Alguns exemplos de funções elípticas:

     (%i1) jacobi_sn (u, m);
     (%o1)                    jacobi_sn(u, m)
     (%i2) jacobi_sn (u, 1);
     (%o2)                        tanh(u)
     (%i3) jacobi_sn (u, 0);
     (%o3)                        sin(u)
     (%i4) diff (jacobi_sn (u, m), u);
     (%o4)            jacobi_cn(u, m) jacobi_dn(u, m)
     (%i5) diff (jacobi_sn (u, m), m);
     (%o5) jacobi_cn(u, m) jacobi_dn(u, m)

           elliptic_e(asin(jacobi_sn(u, m)), m)
      (u - ------------------------------------)/(2 m)
                          1 - m

                 2
        jacobi_cn (u, m) jacobi_sn(u, m)
      + --------------------------------
                   2 (1 - m)

Alguns exemplos de integrais elípticas:

     (%i1) elliptic_f (phi, m);
     (%o1)                  elliptic_f(phi, m)
     (%i2) elliptic_f (phi, 0);
     (%o2)                          phi
     (%i3) elliptic_f (phi, 1);
                                    phi   %pi
     (%o3)                  log(tan(--- + ---))
                                     2     4
     (%i4) elliptic_e (phi, 1);
     (%o4)                       sin(phi)
     (%i5) elliptic_e (phi, 0);
     (%o5)                          phi
     (%i6) elliptic_kc (1/2);
                                          1
     (%o6)                    elliptic_kc(-)
                                          2
     (%i7) makegamma (%);
                                      2 1
                                 gamma (-)
                                        4
     (%o7)                      -----------
                                4 sqrt(%pi)
     (%i8) diff (elliptic_f (phi, m), phi);
                                     1
     (%o8)                 ---------------------
                                         2
                           sqrt(1 - m sin (phi))
     (%i9) diff (elliptic_f (phi, m), m);
            elliptic_e(phi, m) - (1 - m) elliptic_f(phi, m)
     (%o9) (-----------------------------------------------
                                   m

                                      cos(phi) sin(phi)
                                  - ---------------------)/(2 (1 - m))
                                                  2
                                    sqrt(1 - m sin (phi))

Suporte a funções elípticas e integrais elípticas foi escrito por
Raymond Toy.  Foi colocado sob os termos da Licençã Pública Geral (GPL)
que governa a distribuição do Maxima.


File: maxima.info,  Node: Definições para Funções Elípticas,  Next: Definições para Integrais Elípticas,  Prev: Introdução a Funções Elípticas e Integrais,  Up: Top

17.2 Definições para Funções Elípticas
======================================

 -- Função: jacobi_sn (<u>, <m>)
     A Função elíptica Jacobiana sn(u,m).

 -- Função: jacobi_cn (<u>, <m>)
     A função elíptica Jacobiana cn(u,m).

 -- Função: jacobi_dn (<u>, <m>)
     A função elíptica Jacobiana dn(u,m).

 -- Função: jacobi_ns (<u>, <m>)
     A função elíptica Jacobiana ns(u,m) = 1/sn(u,m).

 -- Função: jacobi_sc (<u>, <m>)
     A função elíptica Jacobiana sc(u,m) = sn(u,m)/cn(u,m).

 -- Função: jacobi_sd (<u>, <m>)
     A função elíptica Jacobiana sd(u,m) = sn(u,m)/dn(u,m).

 -- Função: jacobi_nc (<u>, <m>)
     A função elíptica Jacobiana nc(u,m) = 1/cn(u,m).

 -- Função: jacobi_cs (<u>, <m>)
     A função elíptica Jacobiana cs(u,m) = cn(u,m)/sn(u,m).

 -- Função: jacobi_cd (<u>, <m>)
     A função elíptica Jacobiana cd(u,m) = cn(u,m)/dn(u,m).

 -- Função: jacobi_nd (<u>, <m>)
     A função elíptica Jacobiana nc(u,m) = 1/cn(u,m).

 -- Função: jacobi_ds (<u>, <m>)
     A função elíptica Jacobiana ds(u,m) = dn(u,m)/sn(u,m).

 -- Função: jacobi_dc (<u>, <m>)
     A função elíptica Jacobiana dc(u,m) = dn(u,m)/cn(u,m).

 -- Função: inverse_jacobi_sn (<u>, <m>)
     A inversa da função elíptica Jacobiana sn(u,m).

 -- Função: inverse_jacobi_cn (<u>, <m>)
     A inversa da função elíptica Jacobiana cn(u,m).

 -- Função: inverse_jacobi_dn (<u>, <m>)
     A inversa da função elíptica Jacobiana dn(u,m).

 -- Função: inverse_jacobi_ns (<u>, <m>)
     A inversa da função elíptica Jacobiana ns(u,m).

 -- Função: inverse_jacobi_sc (<u>, <m>)
     A inversa da função elíptica Jacobiana sc(u,m).

 -- Função: inverse_jacobi_sd (<u>, <m>)
     A inversa da função elíptica Jacobiana sd(u,m).

 -- Função: inverse_jacobi_nc (<u>, <m>)
     A inversa da função elíptica Jacobiana nc(u,m).

 -- Função: inverse_jacobi_cs (<u>, <m>)
     A inversa da função elíptica Jacobiana cs(u,m).

 -- Função: inverse_jacobi_cd (<u>, <m>)
     A inversa da função elíptica Jacobiana cd(u,m).

 -- Função: inverse_jacobi_nd (<u>, <m>)
     A inversa da função elíptica Jacobiana nc(u,m).

 -- Função: inverse_jacobi_ds (<u>, <m>)
     A inversa da função elíptica Jacobiana ds(u,m).

 -- Função: inverse_jacobi_dc (<u>, <m>)
     A inversa da função elíptica Jacobiana dc(u,m).


File: maxima.info,  Node: Definições para Integrais Elípticas,  Prev: Definições para Funções Elípticas,  Up: Top

17.3 Definições para Integrais Elípticas
========================================

 -- Função: elliptic_f (<phi>, <m>)
     A integral elíptica incompleta de primeiro tipo, definida como

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, phi)

     Veja também _elliptic_e_ e _elliptic_kc_.

 -- Função: elliptic_e (<phi>, <m>)
     A integral elíptica incompleta de segundo tipo, definida como

     elliptic_e(u, m) = integrate(sqrt(1 - m*sin(x)^2), x, 0, phi) Veja
     também _elliptic_e_ e _elliptic_ec_.

 -- Função: elliptic_eu (<u>, <m>)
     A integral elíptica incompleta de segundo tipo, definida como
     integrate(dn(v,m)^2,v,0,u) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),
     t, 0, tau)

     onde tau = sn(u,m)

     Isso é relacionado a elliptic_e através de elliptic_eu(u, m) =
     elliptic_e(asin(sn(u,m)),m) Veja também _elliptic_e_.

 -- Função: elliptic_pi (<n>, <phi>, <m>)
     A integral elíptica incompleta de terceiro tipo, definida como

     integrate(1/(1-n*sin(x)^2)/sqrt(1 - m*sin(x)^2), x, 0, phi)

     Somente a derivada em relação a phi é conhecida pelo Maxima.

 -- Função: elliptic_kc (<m>)
     A integral elíptica completa de primeiro tipo, definida como

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     Para certos valores de m, o valor da integral é conhecido em termos
     de funções Gama.  Use 'makegamma' para avaliar esse valor.

 -- Função: elliptic_ec (<m>)
     A integral elíptica completa de segundo tipo, definida como

     integrate(sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     Para certos valores de m, o valor da integral é conhecido em termos
     de funções Gama.  Use 'makegamma' para avaliar esse valor.


File: maxima.info,  Node: Limites,  Next: Diferenciação,  Prev: Funções Elípticas,  Up: Top

18 Limites
**********

* Menu:

* Definições para Limites::


File: maxima.info,  Node: Definições para Limites,  Prev: Limites,  Up: Limites

18.1 Definições para Limites
============================

 -- Variável de Opção: lhospitallim
     Valor por omissão: 4

     'lhospitallim' é o máximo número de vezes que a regra L'Hospital é
     usada em 'limit'.  Isso evita ciclos infinitos em casos como 'limit
     (cot(x)/csc(x), x, 0)'.

 -- Função: limit (<expr>, <x>, <val>, <dir>)
 -- Função: limit (<expr>, <x>, <val>)
 -- Função: limit (<expr>)
     Calcula o limite de <expr> com a variável real <x> aproximando-se
     do valor <val> pela direção <dir>.  <dir> pode ter o valor 'plus'
     para um limite pela direita, 'minus' para um limite pela esquerda,
     ou pode ser omitido (implicando em um limite em ambos os lados é
     para ser computado).

     'limit' usa os seguintes símbolos especiais: 'inf' (infinito
     positivo) e 'minf' (infinito negativo).  Em saídas essa função pode
     também usar 'und' (undefined - não definido), 'ind' (indefinido mas
     associado) e 'infinity' (infinito complexo).

     'lhospitallim' é o máximo número de vezes que a regra L'Hospital é
     usada em 'limit'.  Isso evita ciclos infinitos em casos como 'limit
     (cot(x)/csc(x), x, 0)'.

     'tlimswitch' quando 'true' fará o pacote 'limit' usar série de
     Taylor quando possível.

     'limsubst' evita que 'limit' tente substituições sobre formas
     desconhecidas.  Isso é para evitar erros como 'limit (f(n)/f(n+1),
     n, inf)' dando igual a 1.  Escolhendo 'limsubst' para 'true'
     permitirá tais substituições.

     'limit' com um argumento é muitas vezes chamado em ocasiões para
     simplificar expressões de constantes, por exemplo, 'limit (inf-1)'.

     'example (limit)' mostra alguns exemplos.

     Para saber sobre o método utilizado veja Wang, P., "Evaluation of
     Definite Integrals by Symbolic Manipulation", tese de Ph.D., MAC
     TR-92, Outubro de 1971.

 -- Variável de Opção: limsubst
     valor padrão: 'false' - evita que 'limit' tente substituições sobre
     formas desconhecidas.  Isso é para evitar erros como 'limit
     (f(n)/f(n+1), n, inf)' dando igual a 1.  Escolhendo 'limsubst' para
     'true' permitirá tais substituições.

 -- Função: tlimit (<expr>, <x>, <val>, <dir>)
 -- Função: tlimit (<expr>, <x>, <val>)
 -- Função: tlimit (<expr>)
     Retorna 'limit' com 'tlimswitch' escolhido para 'true'.

 -- Variável de Opção: tlimswitch
     Valor por omissão: 'false'

     Quando 'tlimswitch' for 'true', fará o pacote 'limit' usar série de
     Taylor quando possível.


File: maxima.info,  Node: Diferenciação,  Next: Integração,  Prev: Limites,  Up: Top

19 Diferenciação
****************

* Menu:

* Definições para Diferenciação::  


File: maxima.info,  Node: Definições para Diferenciação,  Prev: Diferenciação,  Up: Diferenciação

19.1 Definições para Diferenciação
==================================

 -- Função: antid (<expr>, <x>, <u(x)>)
     Retorna uma lista de dois elementos, tais que uma antiderivada de
     <expr> com relação a <x> pode ser constuída a partir da lista.  A
     expressão <expr> pode conter uma função desconhecida <u> e suas
     derivadas.

     Tome <L>, uma lista de dois elementos, como sendo o valor de
     retorno de 'antid'.  Então '<L>[1] + 'integrate (<L>[2], <x>)' é
     uma antiderivada de <expr> com relação a <x>.

     Quando 'antid' obtém sucesso inteiramente, o segundo elemento do
     valor de retorno é zero.  De outra forma, o segundo elemento é não
     zero, e o primeiro elemento não zero ou zero.  Se 'antid' não pode
     fazer nenhum progresso, o primeiro elemento é zero e o segundo não
     zero.

     'load ("antid")' chama essa função.  O pacote 'antid' também define
     as funções 'nonzeroandfreeof' e 'linear'.

     'antid' está relacionada a 'antidiff' como segue.  Tome <L>, uma
     lista de dois elementos, que é o valor de retorno de 'antid'.
     Então o valor de retorno de 'antidiff' é igual a '<L>[1] +
     'integrate (<L>[2], <x>)' onde <x> é a variável de integração.

     Exemplos:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /

 -- Função: antidiff (<expr>, <x>, <u>(<x>))
     Retorna uma antiderivada de <expr> com relação a <x>.  A expressão
     <expr> pode conter uma função desconhecida <u> e suas derivadas.

     Quando 'antidiff' obtém sucesso inteiramente, a expressão
     resultante é livre do sinal de integral (isto é, livre do
     substantivo 'integrate').  De outra forma, 'antidiff' retorna uma
     expressão que é parcialmente ou inteiramente dentro de um sinal de
     um sinal de integral.  Se 'antidiff' não pode fazer qualquer
     progresso, o valor de retorno é inteiramente dentro de um sinal de
     integral.

     'load ("antid")' chama essa função.  O pacote 'antid' também define
     as funções 'nonzeroandfreeof' e 'linear'.

     'antidiff' é relacionada a 'antid' como segue.  Tome <L>, uma lista
     de dois elementos, como sendo o valor de retorno de 'antid'.  Então
     o valor de retorno de 'antidiff' é igual a '<L>[1] + 'integrate
     (<L>[2], <x>)' onde <x> é a variável de integração.

     Exemplos:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /

 -- propriedade: atomgrad

     'atomgrad' é a propriedade do gradiente atômico de uma expressão.
     Essa propriedade é atribuída por 'gradef'.

 -- Função: atvalue (<expr>, [<x_1> = <a_1>, ..., <x_m> = <a_m>], <c>)
 -- Função: atvalue (<expr>, <x_1> = <a_1>, <c>)
     Atribui o valor <c> a <expr> no ponto '<x> = <a>'.  Tipicamente
     valores de extremidade são estabelecidos por esse mecanismo.

     <expr> é a função de avaliação, '<f>(<x_1>, ..., <x_m>)', ou uma
     derivada, 'diff (<f>(<x_1>, ..., <x_m>), <x_1>, <n_1>, ..., <x_n>,
     <n_m>)' na qual os argumentos da função explicitamente aparecem.
     <n_i> é a ordem de diferenciação com relação a <x_i>.

     O ponto no qual o 'atvalue' é estabelecido é dado pela lista de
     equações '[<x_1> = <a_1>, ..., <x_m> = <a_m>]'.  Se existe uma
     variável simples <x_1>, uma única equação pode ser dada sem ser
     contida em uma lista.

     'printprops ([<f_1>, <f_2>, ...], atvalue)' mostra os 'atvalues'
     das funções '<f_1>, <f_2>, ...' como especificado por chamadas a
     'atvalue'.  'printprops (<f>, atvalue)' mostra os 'atvalues' de uma
     função <f>.  'printprops (all, atvalue)' mostra os 'atvalue's de
     todas as funções para as quais 'atvalue's são definidos.

     Os simbolos '@1', '@2', ...  representam as variáveis <x_1>, <x_2>,
     ...  quando 'atvalue's são mostrados.

     'atvalue' avalia seus argumentos.  'atvalue' retorna <c>, o
     'atvalue'.

     Exemplos:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x,y)^2 - u(x,y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1

 -- Função: cartan -
     O cálculo exterior de formas diferenciais é uma ferramenta básica
     de geometria diferencial desenvolvida por Elie Cartan e tem
     importantes aplicações na teoria das equações diferenciais
     parciais.  O pacote 'cartan' implementa as funções 'ext_diff' e
     'lie_diff', juntamente com os operadores '~' (produto da cunha) e
     '|' (contração de uma forma com um vector.)  Digite 'demo (tensor)'
     para ver uma breve descrição desses comandos juntamente com
     exemplos.

     'cartan' foi implementado por F.B. Estabrook e H.D. Wahlquist.

 -- Função: del (<x>)
     'del (<x>)' representa a diferencial da variável x.

     'diff' retorna uma expressão contendo 'del' se uma variável
     independente não for especificada.  Nesse caso, o valor de retorno
     é a então chamada "diferencial total".

     Exemplos:

          (%i1) diff (log (x));
                                       del(x)
          (%o1)                        ------
                                         x
          (%i2) diff (exp (x*y));
                               x y              x y
          (%o2)            x %e    del(y) + y %e    del(x)
          (%i3) diff (x*y*z);
          (%o3)         x y del(z) + x z del(y) + y z del(x)

 -- Função: delta (<t>)
     A função Delta de Dirac.

     Correntemente somente 'laplace' sabe sobre a função 'delta'.

     Exemplo:

          (%i1) laplace (delta (t - a) * sin(b*t), t, s);
          Is  a  positive, negative, or zero?

          p;
                                             - a s
          (%o1)                   sin(a b) %e

 -- Variável: dependencies
     Valor por omissão: '[]'

     'dependencies' é a lista de átomos que possuem dependências
     funcionais, atribuídas por 'depends' ou 'gradef'.  A lista
     'dependencies' é cumulativa: cada chamada a 'depends' ou a 'gradef'
     anexa ítens adicionais.

     Veja 'depends' e 'gradef'.

 -- Função: depends (<f_1>, <x_1>, ..., <f_n>, <x_n>)
     Declara dependêcias funcionais entre variáveis para o propósito de
     calcular derivadas.  Na ausência de dependêcias declaradas, 'diff
     (f, x)' retorna zero.  Se 'depends (f, x)' for declarada, 'diff (f,
     x)' retorna uma derivada simbólica (isto é, um substantivo 'diff').

     Cada argumento <f_1>, <x_1>, etc., pode ser o nome de uma variável
     ou array, ou uma lista de nomes.  Todo elemento de <f_i> (talvez
     apenas um elemento simples) é declarado para depender de todo
     elemento de <x_i> (talvez apenas um elemento simples).  Se algum
     <f_i> for o nome de um array ou contém o nome de um array, todos os
     elementos do array dependem de <x_i>.

     'diff' reconhece dependências indirectas estabelecidas por
     'depends' e aplica a regra da cadeia nesses casos.

     'remove (<f>, dependency)' remove todas as dependências declaradas
     para <f>.

     'depends' retorna uma lista de dependências estabelecidas.  As
     dependências são anexadas à variável global 'dependencies'.
     'depends' avalia seus argumentos.

     'diff' é o único comando Maxima que reconhece dependências
     estabelecidas por 'depends'.  Outras funções ('integrate',
     'laplace', etc.)  somente reconhecem dependências explicitamente
     representadas por seus argumentos.  Por exemplo, 'integrate' não
     reconhece a dependência de 'f' sobre 'x' a menos que explicitamente
     representada como 'integrate (f(x), x)'.

          (%i1) depends ([f, g], x);
          (%o1)                     [f(x), g(x)]
          (%i2) depends ([r, s], [u, v, w]);
          (%o2)               [r(u, v, w), s(u, v, w)]
          (%i3) depends (u, t);
          (%o3)                        [u(t)]
          (%i4) dependencies;
          (%o4)      [f(x), g(x), r(u, v, w), s(u, v, w), u(t)]
          (%i5) diff (r.s, u);
                                   dr           ds
          (%o5)                    -- . s + r . --
                                   du           du

          (%i6) diff (r.s, t);
                                dr du           ds du
          (%o6)                 -- -- . s + r . -- --
                                du dt           du dt

          (%i7) remove (r, dependency);
          (%o7)                         done
          (%i8) diff (r.s, t);
                                          ds du
          (%o8)                       r . -- --
                                          du dt

 -- Variável de opção: derivabbrev
     Valor por omissão: 'false'

     Quando 'derivabbrev' for 'true', derivadas simbólicas (isto é,
     substantivos 'diff') são mostradas como subscritos.  De outra
     forma, derivadas são mostradas na notação de Leibniz 'dy/dx'.

 -- Função: derivdegree (<expr>, <y>, <x>)
     Retorna o maior grau de uma derivada da variável dependente <y> com
     relação à variável independente <x> ocorrendo em <expr>.

     Exemplo:
          (%i1) 'diff (y, x, 2) + 'diff (y, z, 3) + 'diff (y, x) * x^2;
                                   3     2
                                  d y   d y    2 dy
          (%o1)                   --- + --- + x  --
                                    3     2      dx
                                  dz    dx
          (%i2) derivdegree (%, y, x);
          (%o2)                           2

 -- Função: derivlist (<var_1>, ..., <var_k>)
     Causa somente diferenciações com relação às variáveis indicadas,
     dentro do comando 'ev'.

 -- Variável de opção: derivsubst
     Valor por omissão: 'false'

     Quando 'derivsubst' for 'true', uma substiruíção não sintática tais
     como 'subst (x, 'diff (y, t), 'diff (y, t, 2))' retorna ''diff (x,
     t)'.

 -- Função: diff (<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)
 -- Função: diff (<expr>, <x>, <n>)
 -- Função: diff (<expr>, <x>)
 -- Função: diff (<expr>)
     Retorna uma derivada ou diferencial de <expr> com relação a alguma
     ou todas as variáveis em <expr>.

     'diff (<expr>, <x>, <n>)' retorna a <n>'ésima derivada de <expr>
     com relação a <x>.

     'diff (<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)' retorna a derivada
     parcial mista de <expr> com relação a <x_1>, ..., <x_m>.  Isso é
     equivalente a 'diff (... (diff (<expr>, <x_m>, <n_m>) ...), <x_1>,
     <n_1>)'.

     'diff (<expr>, <x>)' retorna a primeira derivada de <expr> com
     relação a uma variável <x>.

     'diff (<expr>)' retorna a diferencial total de <expr>, isto é, a
     soma das derivadas de <expr> com relação a cada uma de suas
     variáveis vezes a diferencial 'del' de cada variável.  Nenhuma
     simplificação adicional de 'del' é oferecida.

     A forma substantiva de 'diff' é requerida em alguns contextos, tal
     como declarando uma equação diferencial.  Nesses casos, 'diff' pode
     ser colocado apóstrofo (com ''diff') para retornar a forma
     substantiva em lugar da realização da diferenciação.

     Quando 'derivabbrev' for 'true', derivadas são mostradas como
     subscritos.  De outra forma, derivadas são mostradas na notação de
     Leibniz, 'dy/dx'.

     Exemplos:

          (%i1) diff (exp (f(x)), x, 2);
                               2
                        f(x)  d               f(x)  d         2
          (%o1)       %e     (--- (f(x))) + %e     (-- (f(x)))
                                2                   dx
                              dx
          (%i2) derivabbrev: true$
          (%i3) 'integrate (f(x, y), y, g(x), h(x));
                                   h(x)
                                  /
                                  [
          (%o3)                   I     f(x, y) dy
                                  ]
                                  /
                                   g(x)
          (%i4) diff (%, x);
                 h(x)
                /
                [
          (%o4) I     f(x, y)  dy + f(x, h(x)) h(x)  - f(x, g(x)) g(x)
                ]            x                     x                  x
                /
                 g(x)

     Para o pacote tensor, as seguintes modificações foram incorporadas:

     (1) As derivadas de quaisquer objectos indexados em <expr> terão as
     variáveis <x_i> anexadas como argumentos adicionais.  Então todos
     os índices de derivada serão ordenados.

     (2) As variáveis <x_i> podem ser inteiros de 1 até o valor de uma
     variável 'dimension' [valor padrão: 4].  Isso fará com que a
     diferenciação seja concluída com relação aos <x_i>'ésimos membros
     da lista 'coordinates' que pode ser escolhida para uma lista de
     nomes de coordenadas, e.g., '[x, y, z, t]'.  Se 'coordinates' for
     associada a uma variável atômica, então aquela variável subscrita
     por <x_i> será usada para uma variável de diferenciação.  Isso
     permite um array de nomes de coordenadas ou nomes subscritos como
     'X[1]', 'X[2]', ...  sejam usados.  Se 'coordinates' não foram
     atribuídas um valor, então as variáveis seram tratadas como em (1)
     acima.

 -- Símbolo especial: diff

     Quando 'diff' está presente como um 'evflag' em chamadas para 'ev',
     Todas as diferenciações indicadas em 'expr' são realizdas.

 -- Função: dscalar (<f>)
     Aplica o d'Alembertiano escalar para a função escalar <f>.

     'load ("ctensor")' chama essa função.

 -- Função: express (<expr>)

     Expande o substantivo do operador diferencial em expressões em
     termos de derivadas parciais.  'express' reconhece os operadores
     'grad', 'div', 'curl', 'laplacian'.  'express' também expande o
     produto do X '~'.

     Derivadas simbólicas (isto é, substantivos 'diff') no valor de
     retorno de 'express' podem ser avaliadas incluíndo 'diff' na
     chamada à função 'ev' ou na linha de comando.  Nesse contexto,
     'diff' age como uma 'evfun'.

     'load ("vect")' chama essa função.

     Exemplos:

          (%i1) load ("vect")$
          (%i2) grad (x^2 + y^2 + z^2);
                                        2    2    2
          (%o2)                  grad (z  + y  + x )
          (%i3) express (%);
                 d    2    2    2   d    2    2    2   d    2    2    2
          (%o3) [-- (z  + y  + x ), -- (z  + y  + x ), -- (z  + y  + x )]
                 dx                 dy                 dz
          (%i4) ev (%, diff);
          (%o4)                    [2 x, 2 y, 2 z]
          (%i5) div ([x^2, y^2, z^2]);
                                        2   2   2
          (%o5)                   div [x , y , z ]
          (%i6) express (%);
                             d    2    d    2    d    2
          (%o6)              -- (z ) + -- (y ) + -- (x )
                             dz        dy        dx
          (%i7) ev (%, diff);
          (%o7)                    2 z + 2 y + 2 x
          (%i8) curl ([x^2, y^2, z^2]);
                                         2   2   2
          (%o8)                   curl [x , y , z ]
          (%i9) express (%);
                 d    2    d    2   d    2    d    2   d    2    d    2
          (%o9) [-- (z ) - -- (y ), -- (x ) - -- (z ), -- (y ) - -- (x )]
                 dy        dz       dz        dx       dx        dy
          (%i10) ev (%, diff);
          (%o10)                      [0, 0, 0]
          (%i11) laplacian (x^2 * y^2 * z^2);
                                            2  2  2
          (%o11)                laplacian (x  y  z )
          (%i12) express (%);
                   2                2                2
                  d     2  2  2    d     2  2  2    d     2  2  2
          (%o12)  --- (x  y  z ) + --- (x  y  z ) + --- (x  y  z )
                    2                2                2
                  dz               dy               dx
          (%i13) ev (%, diff);
                                2  2      2  2      2  2
          (%o13)             2 y  z  + 2 x  z  + 2 x  y
          (%i14) [a, b, c] ~ [x, y, z];
          (%o14)                [a, b, c] ~ [x, y, z]
          (%i15) express (%);
          (%o15)          [b z - c y, c x - a z, a y - b x]

 -- Função: gradef (<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)
 -- Função: gradef (<a>, <x>, <expr>)
     Define as derivadas parciais (i.e., os componentes do gradiente) da
     função <f> ou variável <a>.

     'gradef (<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)' define
     'd<f>/d<x_i>' como <g_i>, onde <g_i> é uma expressão; <g_i> pode
     ser uma chamada de função, mas não o nome de uma função.  O número
     de derivadas parciais <m> pode ser menor que o número de argumentos
     <n>, nesses casos derivadas são definidas com relação a <x_1> até
     <x_m> somente.

     'gradef (<a>, <x>, <expr>)' define uma derivada de variável <a> com
     relação a <x> como <expr>.  Isso também estabelece a dependência de
     <a> sobre <x> (via 'depends (<a>, <x>)').

     O primeiro argumento '<f>(<x_1>, ..., <x_n>)' ou <a> é acompanhado
     de apóstrofo, mas os argumentos restantes <g_1>, ..., <g_m> são
     avaliados.  'gradef' retorna a função ou variável para as quais as
     derivadas parciais são definidas.

     'gradef' pode redefinir as derivadas de funções internas do Maxima.
     Por exemplo, 'gradef (sin(x), sqrt (1 - sin(x)^2))' redefine uma
     derivada de 'sin'.

     'gradef' não pode definir derivadas parciais para um função
     subscrita.

     'printprops ([<f_1>, ..., <f_n>], gradef)' mostra as derivadas
     parciais das funções <f_1>, ..., <f_n>, como definidas por
     'gradef'.

     'printprops ([<a_n>, ..., <a_n>], atomgrad)' mostra as derivadas
     parciais das variáveis <a_n>, ..., <a_n>, como definidas por
     'gradef'.

     'gradefs' é a lista de funções para as quais derivadas parciais
     foram definidas por 'gradef'.  'gradefs' não inclui quaisquer
     variáveis para quais derivadas parciais foram definidas por
     'gradef'.

     Gradientes são necessários quando, por exemplo, uma função não é
     conhecida explicitamente mas suas derivadas primeiras são e isso é
     desejado para obter derivadas de ordem superior.

 -- Variável de sistema: gradefs
     Valor por omissão: '[]'

     'gradefs' é a lista de funções para as quais derivadas parciais
     foram definidas por 'gradef'.  'gradefs' não inclui quaisquer
     variáveis para as quais derivadas parciais foram deinidas por
     'gradef'.

 -- Função: laplace (<expr>, <t>, <s>)
     Tenta calcular a transformada de Laplace de <expr> com relação a
     uma variável <t> e parâmetro de transformação <s>.  Se 'laplace'
     não pode achar uma solução, um substantivo ''laplace' é retornado.

     'laplace' reconhece em <expr> as funções 'delta', 'exp', 'log',
     'sin', 'cos', 'sinh', 'cosh', e 'erf', também 'derivative',
     'integrate', 'sum', e 'ilt'.  Se algumas outras funções estiverem
     presente, 'laplace' pode não ser habilitada a calcular a
     tranformada.

     <expr> pode também ser uma equação linear, diferencial de
     coeficiente contante no qual caso o 'atvalue' da variável
     dependente é usado.  O requerido 'atvalue' pode ser fornecido ou
     antes ou depois da transformada ser calculada.  Uma vez que as
     condições iniciais devem ser especificadas em zero, se um teve
     condições de limite impostas em qualquer outro lugar ele pode impor
     essas sobre a solução geral e eliminar as constantes resolvendo a
     solução geral para essas e substituindo seus valores de volta.

     'laplace' reconhece integrais de convolução da forma 'integrate
     (f(x) * g(t - x), x, 0, t)'; outros tipos de convoluções não são
     reconhecidos.

     Relações funcionais devem ser explicitamente representadas em
     <expr>; relações implícitas, estabelecidas por 'depends', não são
     reconhecidas.  Isto é, se <f> depende de <x> e <y>, 'f (x, y)' deve
     aparecer em <expr>.

     Veja também 'ilt', a transformada inversa de Laplace.

     Exemplos:

          (%i1) laplace (exp (2*t + a) * sin(t) * t, t, s);
                                      a
                                    %e  (2 s - 4)
          (%o1)                    ---------------
                                     2           2
                                   (s  - 4 s + 5)
          (%i2) laplace ('diff (f (x), x), x, s);
          (%o2)             s laplace(f(x), x, s) - f(0)
          (%i3) diff (diff (delta (t), t), t);
                                    2
                                   d
          (%o3)                    --- (delta(t))
                                     2
                                   dt
          (%i4) laplace (%, t, s);
                                      !
                         d            !         2
          (%o4)        - -- (delta(t))!      + s  - delta(0) s
                         dt           !
                                      !t = 0


File: maxima.info,  Node: Integração,  Next: Equações,  Prev: Diferenciação,  Up: Top

20 Integração
*************

* Menu:

* Introdução a Integração::  
* Definições para Integração::  
* Introdução a QUADPACK::
* Definições para QUADPACK::


File: maxima.info,  Node: Introdução a Integração,  Next: Definições para Integração,  Prev: Integração,  Up: Integração

20.1 Introdução a Integração
============================

Maxima tem muitas rotinas para realizar integração.  A função
'integrate' faz uso de muitas dessas.  Exite também o pacote 'antid',
que manuseia uma função não especificada (e suas derivadas, certamente).
Para usos numericos, existe um conjunto de integradores adaptativos de
QUADPACK, a saber 'quad_qag', 'quad_qags', etc., os quais são descritos
sob o tópico 'QUADPACK'.  Funções hipergeométricas estão sendo
trabalhadas, veja 'specint' para detalhes.  Geralmente falando, Maxima
somente calcula integrais que sejam integráveis em termos de "funções
elementares" (funções racionais, trigonometricas, logarítmicas,
exponenciais, radicais, etc.)  e umas poucas extensões (função de erro,
dilogaritmo).  Nã consegue calcular integrais em termos de funções
desconhecidas tais como 'g(x)' e 'h(x)'.


File: maxima.info,  Node: Definições para Integração,  Next: Introdução a QUADPACK,  Prev: Introdução a Integração,  Up: Integração

20.2 Definições para Integração
===============================

 -- Função: changevar (<expr>, <f(x,y)>, <y>, <x>)
     Faz a mudança de variável dada por '<f(x,y)> = 0' em todos os
     integrais que existam em <expr> com integração em relação a <x>.  A
     nova variável é <y>.

          (%i1) assume(a > 0)$
          (%i2) 'integrate (%e**sqrt(a*y), y, 0, 4);
                                4
                               /
                               [    sqrt(a) sqrt(y)
          (%o2)                I  %e                dy
                               ]
                               /
                                0
          (%i3) changevar (%, y-z^2/a, z, y);
                                0
                               /
                               [                abs(z)
                             2 I            z %e       dz
                               ]
                               /
                                - 2 sqrt(a)
          (%o3)            - ----------------------------
                                          a

     Uma expressão contendo uma forma substantiva, tais como as
     instâncias de ''integrate' acima, pode ser avaliada por 'ev' com o
     sinalizador 'nouns'.  Por exemplo, a expressão retornada por
     'changevar' acima pode ser avaliada por 'ev (%o3, nouns)'.

     'changevar' pode também ser usada para alterações nos índices de
     uma soma ou de um produto.  No entanto, é de salientar que quando
     seja feita uma alteração a uma soma ou produto, essa mudança deverá
     ser apenas uma deslocação do índice, nomeadamente, 'i = j+ ...', e
     não uma função de grau superior.  Por exemplo,

          (%i4) sum (a[i]*x^(i-2), i, 0, inf);
                                   inf
                                   ====
                                   \         i - 2
          (%o4)                     >    a  x
                                   /      i
                                   ====
                                   i = 0
          (%i5) changevar (%, i-2-n, n, i);
                                  inf
                                  ====
                                  \               n
          (%o5)                    >      a      x
                                  /        n + 2
                                  ====
                                  n = - 2

 -- Função: dblint (<f>, <r>, <s>, <a>, <b>)
     Esta é uma rotina de integral duplo que foi escrita na linguagem de
     alto nível do Maxima sendo logo traduzida e compilada para
     linguagem de máquina.  Use 'load (dblint)' para poder usar este
     pacote.  Esta função usa o método da regra de Simpson em ambas as
     direções x e y para calcular

          /b /s(x)
          |  |
          |  |    f(x,y) dy dx
          |  |
          /a /r(x)

     A função <f> deve ser uma função traduzida ou compilada de duas
     variáveis, e <r> e <s> devem cada uma ser uma função traduzida ou
     compilada de uma variável, enquanto <a> e <b> devem ser números em
     ponto flutuante.  A rotina tem duas variáveis globais que
     determinam o número de divisões dos intervalos x e y: 'dblint_x' e
     'dblint_y', ambas as quais são inicialmente 10, e podem ser
     alteradas independentemente para outros valores inteiros (existem
     '2*dblint_x+1' pontos calculados na direção x , e '2*dblint_y+1' na
     direção y).  A rotina subdivide o eixo X e então para cada valor de
     X primeiro calcula '<r>(x)' e '<s>(x)'; então o eixo Y entre
     '<r>(x)' e '<s>(x)' é subdividido e o integral ao longo do eixo Y é
     executado usando a regra de Simpson; então o integral ao longo do
     eixo X é concluído usando a regra de Simpson com os valores da
     função sendo os integrais em Y. Esse procedimento pode ser
     numericamente instável por várias razões, mas razoávelmente rápido:
     evite usar este progrma sobre funções altamente oscilatórias e
     funções com singularidades (pólos ou pontos de ramificação na
     região).  Os integrais em Y dependem de quanto fragmentados
     '<r>(x)' e '<s>(x)' sejam; assim, se a distância '<s>(x) - <r>(x)'
     variar rapidamente com X, nesse ponto podrão surgir erros
     substanciais provenientes de truncação com saltos de diferentes
     tamanhos nos vários integrais Y. Pode incrementar-se 'dblint_x' e
     'dblint_y' numa tentativa para melhorar a convergência da região,
     com um aumento no tempo de computação.  Os valores da função não
     são guardados, portanto se a função desperdiçr muito tempo, terá de
     esperar pela re-computação cada vez que mudar qualquer coisa
     (pedimos desculpa por esse facto).  É necessário que as funções
     <f>, <r>, e <s> sejam ainda traduzidas ou compiladas previamente
     chamando 'dblint'.  Isso resultará em ordens de magnitude de
     melhoramentos de velocidade sobre o código interpretado em muitos
     casos!

     'demo (dblint)' executa uma demonstração de 'dblint' aplicado a um
     problema exemplo.

 -- Função: defint (<expr>, <x>, <a>, <b>)
     Tenta calcular um integral definido.  'defint' é chamada por
     'integrate' quando limites de integração são especificados, i.e.,
     quando 'integrate' é chamado como 'integrate (<expr>, <x>, <a>,
     <b>)'.  Dessa forma do ponto de vista do utilizador, isso é
     suficiente para chamar 'integrate'.

     'defint' retorna uma expressão simbólica, e executa um dos dois: ou
     calcula o integral ou a forma substantiva do integral.  Veja
     'quad_qag' e funções rellacionadas para aproximação numérica de
     integrais definidos.

 -- Função: erf (<x>)
     Representa a função de erro, cuja derivada é:
     '2*exp(-x^2)/sqrt(%pi)'.

 -- Variável de opção: erfflag
     Valor por omissão: 'true'

     Quando 'erfflag' é 'false', previne 'risch' da introdução da função
     'erf' na resposta se não houver nenhum no integrando para começar.

 -- Função: ilt (<expr>, <t>, <s>)
     Calcula a transformação inversa de Laplace de <expr> em relação a
     <t> e parâmetro <s>.  <expr> deve ser uma razão de polinómios cujo
     denominador tem somente factores lineares e quadráticos.  Usando a
     funções 'laplace' e 'ilt' juntas com as funções 'solve' ou
     'linsolve' o utilizador pode resolver uma diferencial simples ou
     uma equação integral de convolução ou um conjunto delas.

          (%i1) 'integrate (sinh(a*x)*f(t-x), x, 0, t) + b*f(t) = t**2;
                        t
                       /
                       [                                    2
          (%o1)        I  f(t - x) sinh(a x) dx + b f(t) = t
                       ]
                       /
                        0
          (%i2) laplace (%, t, s);
                                         a laplace(f(t), t, s)   2
          (%o2)  b laplace(f(t), t, s) + --------------------- = --
                                                 2    2           3
                                                s  - a           s
          (%i3) linsolve ([%], ['laplace(f(t), t, s)]);
                                                  2      2
                                               2 s  - 2 a
          (%o3)     [laplace(f(t), t, s) = --------------------]
                                              5         2     3
                                           b s  + (a - a  b) s
          (%i4) ilt (rhs (first (%)), s, t);
          Is  a b (a b - 1)  positive, negative, or zero?

          pos;
                         sqrt(a b (a b - 1)) t
                  2 cosh(---------------------)       2
                                   b               a t
          (%o4) - ----------------------------- + -------
                        3  2      2               a b - 1
                       a  b  - 2 a  b + a

                                                                 2
                                                       + ------------------
                                                          3  2      2
                                                         a  b  - 2 a  b + a

 -- Função: integrate (<expr>, <x>)
 -- Função: integrate (<expr>, <x>, <a>, <b>)
     Tenta símbolicamente calcular o integral de <expr> em relação a
     <x>.  'integrate (<expr>, <x>)' é um integral indefinido, enquanto
     'integrate (<expr>, <x>, <a>, <b>)' é um integral definido, com
     limites de integração <a> e <b>.  Os limites não poderam conter
     <x>, embora 'integrate' não imponha essa restrição.  <a> não
     precisa ser menor que <b>.  Se <b> é igual a <a>, 'integrate'
     retorna zero.

     Veja 'quad_qag' e funções relacionadas para aproximação numérica de
     integrais definidos.  Veja 'residue' para computação de resíduos
     (integração complexa).  Veja 'antid' para uma forma alternativa de
     calcular integrais indefinidos.

     O integral (uma expressão livre de 'integrate') é calculado se
     'integrate' for bem sucedido.  De outra forma o valor de retorno é
     a forma substantiva do integral (o operador com apóstrofo
     ''integrate') ou uma expressão contendo uma ou mais formas
     substantivas.  A forma substantiva de 'integrate' é apresentada com
     um símbolo de integração.

     Em algumas circunstâncias isso é útil para construir uma forma
     substantiva manualmente, colocando em 'integrate' um apóstrofo,
     e.g., ''integrate (<expr>, <x>)'.  Por exemplo, o integral pode
     depender de alguns parâmetos que não estão ainda calculados.  A
     forma substantiva pode ser aplicada a seus argumentos por 'ev (<i>,
     nouns)' onde <i> é a forma substantiva de interesse.

     'integrate' calcula integrais definidos separadamente dos
     indefinidos, e utiliza uma gama de heurísticas para simplificar
     cada caso.  Casos especiais de integrais definidos incluem limites
     de integração iguais a zero ou infinito ('inf' ou 'minf'), funções
     trigonométricas com limites de integração iguais a zero e '%pi' ou
     '2 %pi', funções racionais, integrais relacionados com as
     definições das funções 'beta' e 'psi', e alguns integrais
     logarítmicos e trigonométricos.  O processamento de funções
     racionais pode incluir cálculo de resíduos.  Se um caso especial
     aplicável não for encontrado, será feita uma tentativa para
     calcular o integral indefinido e avaliá-lo nos limites de
     integração.  Isso pode incluir o cálculo de um limite nos casos em
     que um dos limites do integral for para infinito ou menos infinito;
     veja também 'ldefint'.

     Casos especiais de integrais indefinidos incluem funções
     trigonométricas, exponenciais e funções logarítmicas, e funções
     racionais.  'integrate' pode também fazer uso de uma pequena tabela
     de integais elementares.

     'integrate' pode realizar uma mudança de variável se o integrando
     tiver a forma 'f(g(x)) * diff(g(x), x)'.  'integrate' tenta achar
     uma subexpressão 'g(x)' de forma que a derivada de 'g(x)' divida o
     integrando.  Essa busca pode fazer uso de derivadas definidas pela
     função 'gradef'.  Veja também 'changevar' e 'antid'.

     Se nenhum dos procedimentos heurísticos conseguir calcular o
     integral indefinido, o algoritmo de Risch é executado.  O
     sinalizador 'risch' pode ser utilizado como um parâmetro para 'ev',
     ou na linha de comando, nomeadamente, 'ev (integrate (<expr>, <x>),
     risch)' ou 'integrate (<expr>, <x>), risch'.  Se 'risch' estiver
     presente, 'integrate' chamará a função 'risch' sem tentar
     heurísticas primeiro.  Veja também 'risch'.

     'integrate' trabalha somente com relações funcionais representadas
     explicitamente com a notação 'f(x)'.  'integrate' não respeita
     dependências implicitas estabelecidas pela função 'depends'.
     'integrate' pode necessitar conhecer alguma propriedade de um
     parâmetro no integrando.  'integrate' irá primeiro consultar a base
     de dados do 'assume', e , se a variável de interesse não está lá,
     'integrate' perguntará ao utilizador.  Dependendo da pergunta,
     respostas adequadas são 'yes;' ou 'no;', ou 'pos;', 'zero;', ou
     'neg;'.

     'integrate' não é, por padrão, declarada ser linear.  Veja
     'declare' e 'linear'.

     'integrate' tenta integração por partes somente em uns poucos casos
     especiais.

     Exemplos:

        * Integrais definidos e indefinidos elementares.

               (%i1) integrate (sin(x)^3, x);
                                          3
                                       cos (x)
               (%o1)                   ------- - cos(x)
                                          3
               (%i2) integrate (x/ sqrt (b^2 - x^2), x);
                                                2    2
               (%o2)                    - sqrt(b  - x )
               (%i3) integrate (cos(x)^2 * exp(x), x, 0, %pi);
                                              %pi
                                          3 %e      3
               (%o3)                      ------- - -
                                             5      5
               (%i4) integrate (x^2 * exp(-x^2), x, minf, inf);
                                           sqrt(%pi)
               (%o4)                       ---------
                                               2

        * Uso de 'assume' e dúvida interativa.

               (%i1) assume (a > 1)$
               (%i2) integrate (x**a/(x+1)**(5/2), x, 0, inf);
                   2 a + 2
               Is  -------  an integer?
                      5

               no;
               Is  2 a - 3  positive, negative, or zero?

               neg;
                                                  3
               (%o2)                  beta(a + 1, - - a)
                                                  2

        * Mudança de variável.  Existem duas mudanças de variável nesse
          exemplo: uma usando a derivada estabelecida por 'gradef', e
          uma usando a derivação 'diff(r(x))' de uma função não
          especificada 'r(x)'.

               (%i3) gradef (q(x), sin(x**2));
               (%o3)                         q(x)
               (%i4) diff (log (q (r (x))), x);
                                     d               2
                                    (-- (r(x))) sin(r (x))
                                     dx
               (%o4)                ----------------------
                                           q(r(x))
               (%i5) integrate (%, x);
               (%o5)                     log(q(r(x)))

        * O resultado contém a forma substantiva ''integrate'.  Neste
          exemplo, Maxima pode extrair um factor do denominador de uma
          função racional, mas não pode factorizar o restante ou de
          outra forma achar o seu integral.  'grind' mostra a forma
          substantiva ''integrate' no resultado.  Veja também
          'integrate_use_rootsof' para mais informaçes sobre integrais
          de funções racionais.

               (%i1) expand ((x-4) * (x^3+2*x+1));
                                   4      3      2
               (%o1)              x  - 4 x  + 2 x  - 7 x - 4
               (%i2) integrate (1/%, x);
                                             /  2
                                             [ x  + 4 x + 18
                                             I ------------- dx
                                             ]  3
                                log(x - 4)   / x  + 2 x + 1
               (%o2)            ---------- - ------------------
                                    73               73
               (%i3) grind (%);
               log(x-4)/73-('integrate((x^2+4*x+18)/(x^3+2*x+1),x))/73$

        * Definindo uma função em termos de um integral.  O corpo de uma
          função não é avaliado quando a função é definida.  Dessa forma
          o corpo de 'f_1' nesse exemplo contém a forma substantiva de
          'integrate'.  O operador de doi apóstrofos seguidos '''' faz
          com que o integral seja avaliado, e o resultado se
          transforme-se no corpo de 'f_2'.

               (%i1) f_1 (a) := integrate (x^3, x, 1, a);
                                                    3
               (%o1)           f_1(a) := integrate(x , x, 1, a)
               (%i2) ev (f_1 (7), nouns);
               (%o2)                          600
               (%i3) /* Note parentheses around integrate(...) here */
                     f_2 (a) := ''(integrate (x^3, x, 1, a));
                                                  4
                                                 a    1
               (%o3)                   f_2(a) := -- - -
                                                 4    4
               (%i4) f_2 (7);
               (%o4)                          600

 -- Variável de sistema: integration_constant_counter
     Valor por omissão: 0

     'integration_constant_counter' é um contador que é actualizado a
     cada vez que uma constante de integração (nomeada pelo Maxima, por
     exemplo, 'integrationconstant1') é introduzida numa expressão
     obtida após a integração indefinida de uma equação.

 -- Variável de opção: integrate_use_rootsof
     Valor por omissão: 'false'

     Quando 'integrate_use_rootsof' é 'true' e o denominador de uma
     função racional não pode ser factorizado, 'integrate' retorna o
     integral em uma forma que é uma soma sobre as raízes (não
     conhecidas ainda) do denominador.

     Por exemplo, com 'integrate_use_rootsof' escolhido para 'false',
     'integrate' retorna um integral não resolvido de uma função
     racional na forma substantiva:

          (%i1) integrate_use_rootsof: false$
          (%i2) integrate (1/(1+x+x^5), x);
                  /  2
                  [ x  - 4 x + 5
                  I ------------ dx                            2 x + 1
                  ]  3    2                2            5 atan(-------)
                  / x  - x  + 1       log(x  + x + 1)          sqrt(3)
          (%o2)   ----------------- - --------------- + ---------------
                          7                 14             7 sqrt(3)

     Agora vamos escolher o sinalizador para ser true e a parte não
     resolvida do integral será escrito como uma soma sobre as raízes do
     denominador da função racional:

          (%i3) integrate_use_rootsof: true$
          (%i4) integrate (1/(1+x+x^5), x);
                ====        2
                \       (%r4  - 4 %r4 + 5) log(x - %r4)
                 >      -------------------------------
                /                    2
                ====            3 %r4  - 2 %r4
                                  3      2
                %r4 in rootsof(%r4  - %r4  + 1, %r4)
          (%o4) ----------------------------------------------------------
                         7

                                                                       2 x + 1
                                                   2            5 atan(-------)
                                              log(x  + x + 1)          sqrt(3)
                                            - --------------- + ---------------
                                                    14             7 sqrt(3)

     Alternativamente o utilizador pode calcular as raízes do
     denominador separadamente, e então expressar o integrando em termos
     dessas raízes, e.g., '1/((x - a)*(x - b)*(x - c))' ou '1/((x^2 -
     (a+b)*x + a*b)*(x - c))' se o denominador for um polinómio cúbico.
     Algumas vezes isso ajudará Maxima a obter resultados mais úteis.

 -- Função: ldefint (<expr>, <x>, <a>, <b>)
     Tenta calcular o integral definido de <expr> pelo uso de 'limit'
     para avaliar o integral indefinido <expr> em relação a <x> no
     limite superior <b> e no limite inferior <a>.  Se isso falha para
     calcular o integral definido, 'ldefint' retorna uma expressão
     contendo limites como formas substantivas.

     'ldefint' não é chamada por 'integrate', então executando 'ldefint
     (<expr>, <x>, <a>, <b>)' pode retornar um resultado diferente de
     'integrate (<expr>, <x>, <a>, <b>)'.  'ldefint' sempre usa o mesmo
     método para avaliar o integral definido, enquanto 'integrate' pode
     utilizar várias heurísticas e pode reconhecer alguns casos
     especiais.

 -- Função: potential (<givengradient>)
     O cálculo faz uso da variável global 'potentialzeroloc[0]' que deve
     ser 'nonlist' ou da forma

          [indeterminatej=expressãoj, indeterminatek=expressãok, ...]

     O formador sendo equivalente para a expressão nonlist para todos os
     lados direitos-manuseados mais tarde.  Os lados direitos indicados
     são usados como o limite inferior de integração.  O sucesso das
     integrações pode depender de seus valores e de sua ordem.
     'potentialzeroloc' é inicialmente escolhido para 0.

 -- Função: residue (<expr>, <z>, <z_0>)
     Calcula o resíduo no plano complexo da expressão <expr> quando a
     variável <z> assumes o valor <z_0>.  O resíduo é o coeficiente de
     '(<z> - <z_0>)^(-1)' nas séries de Laurent para <expr>.

          (%i1) residue (s/(s**2+a**2), s, a*%i);
                                          1
          (%o1)                           -
                                          2
          (%i2) residue (sin(a*x)/x**4, x, 0);
                                           3
                                          a
          (%o2)                         - --
                                          6

 -- Função: risch (<expr>, <x>)
     Integra <expr> em relação a <x> usando um caso transcendental do
     algoritmo de Risch.  (O caso algébrico do algoritmo de Risch foi
     implementado.)  Isso actualmente manuseia os casos de exponenciais
     aninhadas e logaritmos que a parte principal de 'integrate' não
     pode fazer.  'integrate' irá aplicar automaticamente 'risch' se
     dados esses casos.

     'erfflag', se 'false', previne 'risch' da introdução da função
     'erf' na resposta se não for achado nenhum no integrando para
     começar.

          (%i1) risch (x^2*erf(x), x);
                                                                  2
                       3                      2                - x
                  %pi x  erf(x) + (sqrt(%pi) x  + sqrt(%pi)) %e
          (%o1)   -------------------------------------------------
                                        3 %pi
          (%i2) diff(%, x), ratsimp;
                                       2
          (%o2)                       x  erf(x)

 -- Função: tldefint (<expr>, <x>, <a>, <b>)
     Equivalente a 'ldefint' com 'tlimswitch' escolhido para 'true'.


File: maxima.info,  Node: Introdução a QUADPACK,  Next: Definições para QUADPACK,  Prev: Definições para Integração,  Up: Integração

20.3 Introdução a QUADPACK
==========================

QUADPACK é uma colecção de funções para aálculo numérico de integrais
definidos unidimensionais.  O pacote QUADPACK resultou da junção de um
projeto de R. Piessens (1), E. de Doncker (2), C. Ueberhuber (3), e D.
Kahaner (4).

A biblioteca QUADPACK inclída no Maxima é uma tradução automática (feita
através do programa 'f2cl') do código fonte em de QUADPACK como aparece
na SLATEC Common Mathematical Library, Versão 4.1 (5).  A biblioteca
Fortran SLATEC é datada de Julho de 1993, mas as funções QUADPACK foram
escritas alguns anos antes.  Existe outra versão de QUADPACK em Netlib
(6); não está claro no que aquela versão difere da versão existente em
SLATEC.

As funções QUADPACK incluídas no Maxima são toda automáticas, no sentido
de que essas funções tentam calcular um resultado para uma precisão
específica, requerendo um número não especificado de avaliações de
função.  A tradução do Lisp do Maxima da iblioteca QUADPACK também
inclui algumas funçe~s não automáticas, mas elas não são expostas a
nível de Maxima.

Informação adicionalsobre a bilioteca QUADPACK pode ser encontrada no
livro do QUADPACK (7).

20.3.1 Overview
---------------

'quad_qag'
     Integração de uma função genérica sobre um intervalo finito.
     'quad_qag' implementa um integrador adaptativo globalmente simples
     usando a estratégia de Aind (Piessens, 1973).  O chamador pode
     escolher entre 6 pares de formulas da quadratura de Gauss-Kronrod
     para a componente de avaliação da regra.  As regras de alto grau
     são adequadas para integrandos fortemente oscilantes.

'quad_qags'
     Integração de uma função genérica sob um intervalo finito.
     'quad_qags' implementa subdivisão de intervalos globalmente
     adaptativos com extrapolação (de Doncker, 1978) por meio do
     algoritmo de Epsilon (Wynn, 1956).

'quad_qagi'
     Integração de uma função genérica sobre um intervalo finito ou
     semi-finito.  O intervalo é mapeado sobre um intervalo finito e
     então a mesma estratégia de 'quad_qags' é aplicada.

'quad_qawo'
     Integração de cos(omega x) f(x) ou sin(omega x) f(x) sobre um
     intervalo finito, onde omega é uma constante.  A componente de
     avaliação da regra é baseada na técnica modificada de
     Clenshaw-Curtis.  'quad_qawo' aplica subdivisão adaptativa com
     extrapolação, similar a 'quad_qags'.

'quad_qawf'
     Calcula uma transformação de co-seno de Fourier ou de um seno de
     Fourier sobre um intervalo semi-finito.  O mesmo aproxima como
     'quad_qawo' aplicado sobre intervalos finitos sucessivos, e
     aceleração de convergência por meio d algorítimo de Epsilon (Wynn,
     1956) aplicado a séries de contribuições de integrais.

'quad_qaws'
     Integraçào de w(x) f(x) sobre um intervalo finito [a, b], onde w é
     uma função da forma (x - a)^alpha (b - x)^beta v(x) e v(x) é 1 ou
     log(x - a) ou log(b - x) ou log(x - a) log(b - x), e alpha > -1 e
     beta > -1.  Auma estratégia de subdivisão adaptativa é aplicada,
     com integração modificada de Clenshaw-Curtis sobre os subintervalos
     que possuem a ou b.

'quad_qawc'
     Calcula o valor principal de Cauchy de f(x)/(x - c) sobre um
     intervalo finito (a, b) e um c especificado.  A estratégia é
     globalmente adaptativa, e a integração modificada de
     Clenshaw-Curtis é usada sobre subamplitudes que possuírem o ponto x
     = c.

   ---------- Footnotes ----------

   (1) Applied Mathematics and Programming Division, K.U. Leuven

   (2) Applied Mathematics and Programming Division, K.U. Leuven

   (3) Institut fur Mathematik, T.U. Wien

   (4) National Bureau of Standards, Washington, D.C., U.S.A

   (5) http://www.netlib.org/slatec

   (6) http://www.netlib.org/quadpack

   (7) R. Piessens, E. de Doncker-Kapenga, C.W. Uberhuber, e D.K.
Kahaner.  QUADPACK: A Subroutine Package for Automatic Integration.
Berlin: Springer-Verlag, 1983, ISBN 0387125531.


File: maxima.info,  Node: Definições para QUADPACK,  Prev: Introdução a QUADPACK,  Up: Integração

20.4 Definições para QUADPACK
=============================

 -- Função: quad_qag (<f(x)>, <x>, <a>, <b>, <chave>, <epsrel>,
          <limite>)
 -- Função: quad_qag (<f>, <x>, <a>, <b>, <chave>, <epsrel>, <limite>)

     Integração de uma função genérica sobre um intervalo finito.
     'quad_qag' implementa um integrador adaptativo globalmente simples
     usando a estratégia de Aind (Piessens, 1973).  O chamador pode
     escolher entre 6 pares de fórmulas da quadratura de Gauss-Kronrod
     para a componente de avaliação da regra.  As regras de alto nível
     são adequadas para integrandos fortemente oscilatórios.

     'quad_qag' calcula o integral

     integrate (f(x), x, a, b)

     A função a ser integrada é <f(x)>, com variável dependente <x>, e a
     função é para ser integrada entre os limites <a> e <b>.  <chave> é
     o integrador a ser usado e pode ser um inteiro entre 1 e 6,
     inclusive.  O valor de <chave> selecciona a ordem da regra de
     integração de Gauss-Kronrod.  Regra de alta ordem são adequadas
     para integrandos fortemente oscilatórios.

     O integrando pode ser especidficado como o nome de uma função
     Maxima ou uma função Lisp ou um operador, uma expressão lambda do
     Maxima, ou uma expressão geral do Maxima.

     A integração numérica é concluída adaptativamente pela subdivisão a
     região de integração até que a precisão desejada for completada.

     Os argumentos opcionais <epsrel> e <limite> são o erro relativo
     desejado e o número máximo de subintervalos respectivamente.
     <epsrel> padrão em 1e-8 e <limite> é 200.

     'quad_qag' retorna uma lista de quatro elementos:

        * uma aproximação para o integral,
        * o erro absoluto estimado da aproximação,
        * o número de avaliações do integrando,
        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

     '0'
          se nenhum problema foi encontrado;
     '1'
          se foram utilizados muitos subintervalos;
     '2'
          se for detectato um erro de arredondamento excessivo;
     '3'
          se o integrando se comportar muito mal;
     '6'
          se a entrada não for válida.

     Exemplos:

          (%i1) quad_qag (x^(1/2)*log(1/x), x, 0, 1, 3);
          (%o1)    [.4444444444492108, 3.1700968502883E-9, 961, 0]
          (%i2) integrate (x^(1/2)*log(1/x), x, 0, 1);
                                          4
          (%o2)                           -
                                          9

 -- Função: quad_qags (<f(x)>, <x>, <a>, <b>, <epsrel>, <limite>)
 -- Função: quad_qags (<f>, <x>, <a>, <b>, <epsrel>, <limite>)

     Integração de uma função geral sobre um intervalo finito.
     'quad_qags' implementa subdivisão de intervalo globalmente
     adaptativa com extrapolação (de Doncker, 1978) através do algoritmo
     de (Wynn, 1956).

     'quad_qags' calcula o integral

     integrate (f(x), x, a, b)

     A função a ser integrada é <f(x)>, com variável dependente <x>, e a
     função é para ser integrada entre os limites <a> e <b>.

     O integrando pode ser especidficado como o nome de uma função
     Maxima ou uma função Lisp ou um operador, uma expressão lambda do
     Maxima, ou uma expressão geral do Maxima.

     Os argumentos opcionais <epsrel> e <limite> são o erro relativo
     desejado e o número máximo de subintervalos, respectivamente.
     <epsrel> padrão em 1e-8 e <limite> é 200.

     'quad_qags' retorna uma lista de quatro elementos:

        * uma aproximação para o integral,
        * o erro absoluto estimado da aproximação,
        * o número de avaliações do integrando,
        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

     '0'
          nenhum problema foi encontrado;
     '1'
          foram utilizados muitos subintervalos;
     '2'
          foi detectato um erro de arredondamento excessivo;
     '3'
          o integrando comporta-se muito mal;
     '4'
          não houve convergência
     '5'
          o integral provavelmente é divergente, o converge lentamente
     '6'
          a entrada não foi válida.

     Exemplos:

          (%i1) quad_qags (x^(1/2)*log(1/x), x, 0 ,1);
          (%o1)   [.4444444444444448, 1.11022302462516E-15, 315, 0]

     Note que 'quad_qags' é mais preciso e eficiente que 'quad_qag' para
     esse integrando.

 -- Função: quad_qagi (<f(x)>, <x>, <a>, <inftype>, <epsrel>, <limite>)
 -- Função: quad_qagi (<f>, <x>, <a>, <inftype>, <epsrel>, <limite>)

     Integração de uma função genérica sobre um intervalo finito ou
     semi-finito.  O intervalo é mapeado sobre um intervalo finito e
     então a mesma estratégia que em 'quad_qags' é aplicada.

     'quad_qagi' avalia um dos seguintes integrais

     integrate (f(x), x, minf, inf)

     integrate (f(x), x, minf, a)

     integrate (f(x), x, a, minf, inf)

     usando a rotina Quadpack QAGI. A função a ser integrada é <f(x)>,
     com variável dependente <x>, e a função é para ser integrada sobre
     um intervalo infinito.

     O integrando pode ser especidficado como o nome de uma função
     Maxima ou uma função Lisp ou um operador, uma expressão lambda do
     Maxima, ou uma expressão geral do Maxima.

     O parâmetro <inftype> determina o intervalo de integração como
     segue:

     'inf'
          O intervalo vai de <a> ao infinito positivo.
     'minf'
          O intervalo vai do infinito negativo até <a>.
     'both'
          O intervalo corresponde a toda reta real.

     Os argumentos opcionais <epsrel> e <limite> são o erro relativo
     desejado e o número maximo de subintervalos, respectivamente.
     <epsrel> padrão para 1e-8 e <limite> é 200.

     'quad_qagi' retorna uma lista de quatro elementos:

        * uma aproximação para o integral,
        * o erro absoluto estimado da aproximação,
        * o número de avaliações do integrando,
        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

     '0'
          nenhum problema foi encontrado;
     '1'
          foram utilizados muitos subintervalos;
     '2'
          foi detectato um erro de arredondamento excessivo;
     '3'
          o integrando comporta-se muito mal;
     '4'
          não houve convergência
     '5'
          o integral provavelmente é divergente, o converge lentamente
     '6'
          a entrada não foi válida.

     Exemplos:

          (%i1) quad_qagi (x^2*exp(-4*x), x, 0, inf);
          (%o1)        [0.03125, 2.95916102995002E-11, 105, 0]
          (%i2) integrate (x^2*exp(-4*x), x, 0, inf);
                                         1
          (%o2)                          --
                                         32

 -- Função: quad_qawc (<f(x)>, <x>, <c>, <a>, <b>, <epsrel>, <limite>)
 -- Função: quad_qawc (<f>, <x>, <c>, <a>, <b>, <epsrel>, <limite>)

     Calcula o valor principal de Cauchy de f(x)/(x - c) over a finite
     interval.  A estratégia é globalmente adaptativa, e a integração de
     Clenshaw-Curtis modificada é usada sobre as subamplitudes que
     possuírem o ponto x = c.

     'quad_qawc' calcula o valor principal de Cauchy de

     integrate (f(x)/(x - c), x, a, b)

     usando a rotina Quadpack QAWC. A função a ser integrada é
     '<f(x)>/(<x> - <c>)', com variável dependente <x>, e a função é
     para ser integrada sobre o intervalo que vai de <a> até <b>.

     O integrando pode ser especidficado como o nome de uma função
     Maxima ou uma função Lisp ou um operador, uma expressão lambda do
     Maxima, ou uma expressão geral do Maxima.

     Os argumentos opcionais <epsrel> e <limite> são o erro relativo
     desejado e o máximo número de subintervalos, respectivamente.
     <epsrel> padrão para 1e-8 e <limite> é 200.

     'quad_qawc' retorna uma lista de quatro elementos:

        * uma aproximação para o integral,
        * o erro absoluto estimado da aproximação,
        * o número de avaliações do integrando,
        * um código de erro.

     O código de erro (quarto elemento do valoor de retorno) pode ter os
     valores:

     '0'
          nenhum problema foi encontrado;
     '1'
          foram utilizados muitos subintervalos;
     '2'
          foi detectato um erro de arredondamento excessivo;
     '3'
          o integrando comporta-se muito mal;
     '6'
          a entrada não foi válida.

     Exemplos:

          (%i1) quad_qawc (2^(-5)*((x-1)^2+4^(-5))^(-1), x, 2, 0, 5);
          (%o1)    [- 3.130120337415925, 1.306830140249558E-8, 495, 0]
          (%i2) integrate (2^(-alpha)*(((x-1)^2 + 4^(-alpha))*(x-2))^(-1), x, 0, 5);
          Principal Value
                                 alpha
                  alpha       9 4                 9
                 4      log(------------- + -------------)
                                alpha           alpha
                            64 4      + 4   64 4      + 4
          (%o2) (-----------------------------------------
                                  alpha
                               2 4      + 2

                   3 alpha                       3 alpha
                   -------                       -------
                      2            alpha/2          2          alpha/2
                2 4        atan(4 4       )   2 4        atan(4       )   alpha
              - --------------------------- - -------------------------)/2
                          alpha                        alpha
                       2 4      + 2                 2 4      + 2
          (%i3) ev (%, alpha=5, numer);
          (%o3)                    - 3.130120337415917

 -- Função: quad_qawf (<f(x)>, <x>, <a>, <omega>, <trig>, <epsabs>,
          <limit>, <maxp1>, <limlst>)
 -- Função: quad_qawf (<f>, <x>, <a>, <omega>, <trig>, <epsabs>,
          <limit>, <maxp1>, <limlst>)

     Calcula uma transformação de co-seno de Fourier ou de um seno de
     Fourier sobre um intervalo semi-finito.  usando a função QAWF do
     pacote Quadpack.  A mesma aproxima como em 'quad_qawo' quando
     aplicada sobre intervalos finitos sucessivos, e aceleração de
     convergência por meio d algorítimo de Epsilon (Wynn, 1956) aplicado
     a séries de contribuições de integrais.

     'quad_qawf' calcula o integral

     integrate (f(x)*w(x), x, a, inf)

     A função peso w é seleccionada por <trig>:

     'cos'
          w(x) = cos (omega x)
     'sin'
          w(x) = sin (omega x)

     O integrando pode ser especidficado como o nome de uma função
     Maxima ou uma função Lisp ou um operador, uma expressão lambda do
     Maxima, ou uma expressão geral do Maxima.

     Os argumentos opcionais são:

     'epsabs'
          Erro absoluto de aproximação desejado.  Padrão é 1d-10.
     'limit'
          Tamanho de array interno de trabalho.  (<limit> - <limlst>)/2
          é o maximo número de subintervalos para usar.  O Padrão é 200.
     'maxp1'
          O número máximo dos momentos de Chebyshev.  Deve ser maior que
          0.  O padrão é 100.
     'limlst'
          Limite superior sobre número de ciclos.  Deve ser maior ou
          igual a 3.  O padrão é 10.

     <epsabs> e <limit> são o erro relativo desejado e o número maximo
     de subintervalos, respectivamente.  <epsrel> padrão para 1e-8 e
     <limit> é 200.

     'quad_qawf' retorna uma lista de quatro elementos:

        * uma aproximação para o integral,
        * o erro absoluto estimado da aproximação,
        * o número de avaliações do integrando,
        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

     '0'
          nenhum problema foi encontrado;
     '1'
          foram utilizados muitos subintervalos;
     '2'
          foi detectato um erro de arredondamento excessivo;
     '3'
          o integrando comporta-se muito mal;
     '6'
          a entrada não foi válida.

     Exemplos:

          (%i1) quad_qawf (exp(-x^2), x, 0, 1, 'cos);
          (%o1)   [.6901942235215714, 2.84846300257552E-11, 215, 0]
          (%i2) integrate (exp(-x^2)*cos(x), x, 0, inf);
                                    - 1/4
                                  %e      sqrt(%pi)
          (%o2)                   -----------------
                                          2
          (%i3) ev (%, numer);
          (%o3)                   .6901942235215714

 -- Função: quad_qawo (<f(x)>, <x>, <a>, <b>, <omega>, <trig>, <epsabs>,
          <limite>, <maxp1>, <limlst>)
 -- Função: quad_qawo (<f>, <x>, <a>, <b>, <omega>, <trig>, <epsabs>,
          <limite>, <maxp1>, <limlst>)

     Integração de cos(omega x) f(x) ou sin(omega x) f(x) sobre um
     intervalo finito, onde omega é uma constante.  A componente de
     avaliação da regra é baseada na técnica modificada de
     Clenshaw-Curtis.  'quad_qawo' aplica subdivisão adaptativa com
     extrapolação, similar a 'quad_qags'.

     'quad_qawo' calcula o integral usando a rotina Quadpack QAWO:

     integrate (f(x)*w(x), x, a, b)

     A função peso w é seleccionada por <trig>:

     'cos'
          w(x) = cos (omega x)
     'sin'
          w(x) = sin (omega x)

     O integrando pode ser especidficado como o nome de uma função
     Maxima ou uma função Lisp ou um operador, uma expressão lambda do
     Maxima, ou uma expressão geral do Maxima.

     Os argumentos opcionais são:

     'epsabs'
          Erro absoluto desejado de aproximação.  O Padrão é 1d-10.
     'limite'
          Tamanho do array interno de trabalho.  (<limite> - <limlst>)/2
          é o número máximo de subintervalos a serem usados.  Default é
          200.
     'maxp1'
          Número máximo dos momentos de Chebyshev.  Deve ser maior que
          0.  O padrão é 100.
     'limlst'
          Limite superior sobre o número de ciclos.  Deve ser maior que
          ou igual a 3.  O padrão é 10.

     <epsabs> e <limite> são o erro relativo desejado e o número máximo
     de subintervalos, respectivamente.  <epsrel> o padrão é 1e-8 e
     <limite> é 200.

     'quad_qawo' retorna uma lista de quatro elementos:

        * uma aproximação para o integral,
        * o erro absoluto estimado da aproximação,
        * o número de avaliações do integrando,
        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

     '0'
          nenhum problema foi encontrado;
     '1'
          foram utilizados muitos subintervalos;
     '2'
          foi detectato um erro de arredondamento excessivo;
     '3'
          o integrando comporta-se muito mal;
     '6'
          a entrada não foi válida.

     Exemplos:

          (%i1) quad_qawo (x^(-1/2)*exp(-2^(-2)*x), x, 1d-8, 20*2^2, 1, cos);
          (%o1)     [1.376043389877692, 4.72710759424899E-11, 765, 0]
          (%i2) rectform (integrate (x^(-1/2)*exp(-2^(-alpha)*x) * cos(x), x, 0, inf));
                             alpha/2 - 1/2            2 alpha
                  sqrt(%pi) 2              sqrt(sqrt(2        + 1) + 1)
          (%o2)   -----------------------------------------------------
                                         2 alpha
                                   sqrt(2        + 1)
          (%i3) ev (%, alpha=2, numer);
          (%o3)                     1.376043390090716

 -- Função: quad_qaws (<f(x)>, <x>, <a>, <b>, <alpha>, <beta>, <wfun>,
          <epsabs>, <limite>)
 -- Função: quad_qaws (<f>, <x>, <a>, <b>, <alpha>, <beta>, <wfun>,
          <epsabs>, <limite>)

     Integração de w(x) f(x) sobre um intervalo finito, onde w(x) é uma
     certa função algébrica ou logarítmica.  Uma estratégia de
     subdivisão globalmente adaptativa é aplicada, com integração
     modificada de Clenshaw-Curtis sobre os subintervalos que possuírem
     os pontos finais dos intervalos de integração.

     'quad_qaws' calcula o integral usando a rotina Quadpack QAWS:

     integrate (f(x)*w(x), x, a, b)

     A função peso w é seleccionada por <wfun>:

     '1'
          w(x) = (x - a)^alpha (b - x)^beta
     '2'
          w(x) = (x - a)^alpha (b - x)^beta log(x - a)
     '3'
          w(x) = (x - a)^alpha (b - x)^beta log(b - x)
     '4'
          w(x) = (x - a)^alpha (b - x)^beta log(x - a) log(b - x)

     O integrando pode ser especificado como o nome de uma função Maxima
     ou uma função Lisp ou um operador, uma expressão lambda do Maxima,
     ou uma expressão geral do Maxima.

     O argumentos opcionais são:

     'epsabs'
          Erro absoluto desejado de aproximação.  O padrão é 1d-10.
     'limite'
          Tamanho do array interno de trabalho.  (<limite> - <limlst>)/2
          é o número máximo de subintervalos para usar.  O padrão é 200.

     <epsabs> e <limit> são o erro relativo desejado e o número máximo
     de subintervalos, respectivamente.  <epsrel> o padrão é 1e-8 e
     <limite> é 200.

     'quad_qaws' retorna uma lista de quatro elementos:

        * uma aproximação para o integral,
        * o erro absoluto estimado da aproximação,
        * o número de avaliações do integrando,
        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

     '0'
          nenhum problema foi encontrado;
     '1'
          foram utilizados muitos subintervalos;
     '2'
          foi detectato um erro de arredondamento excessivo;
     '3'
          o integrando comporta-se muito mal;
     '6'
          a entrada não foi válida.

     Exemplos:

          (%i1) quad_qaws (1/(x+1+2^(-4)), x, -1, 1, -0.5, -0.5, 1);
          (%o1)     [8.750097361672832, 1.24321522715422E-10, 170, 0]
          (%i2) integrate ((1-x*x)^(-1/2)/(x+1+2^(-alpha)), x, -1, 1);
                 alpha
          Is  4 2      - 1  positive, negative, or zero?

          pos;
                                    alpha         alpha
                             2 %pi 2      sqrt(2 2      + 1)
          (%o2)              -------------------------------
                                         alpha
                                      4 2      + 2
          (%i3) ev (%, alpha=4, numer);
          (%o3)                     8.750097361672829


File: maxima.info,  Node: Equações,  Next: Equações Diferenciais,  Prev: Integração,  Up: Top

21 Equações
***********

* Menu:

* Definições para Equações::   


File: maxima.info,  Node: Definições para Equações,  Prev: Equações,  Up: Equações

21.1 Definições para Equações
=============================

 -- Variável: %rnum_list
     Valor por omissão: '[]'

     '%rnum_list' é a lista de variáveis introduzidas em soluções por
     'algsys'.  '%r' variáveis São adicionadas a '%rnum_list' na ordem
     em que forem criadas.  Isso é conveniente para fazer substituições
     dentro da solução mais tarde.  É recomendado usar essa lista em
     lugar de fazer 'concat ('%r, j)'.

 -- Variável: algexact
     Valor por omissão: 'false'

     'algexact' afecta o comportamento de 'algsys' como segue:

     Se 'algexact' é 'true', 'algsys' sempre chama 'solve' e então usa
     'realroots' sobre falhas de 'solve'.

     Se 'algexact' é 'false', 'solve' é chamada somente se o eliminante
     não for de uma variável, ou se for uma quadrática ou uma
     biquadrada.

     Dessa forma 'algexact: true' não garante soluções exactas, apenas
     que 'algsys' tentará primeiro pegar soluções exactas, e somente
     retorna aproximações quando tudo mais falha.

 -- Função: algsys ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
 -- Função: algsys ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Resolve polinómios simultâneos <expr_1>, ..., <expr_m> ou equações
     polinômiais <eqn_1>, ..., <eqn_m> para as variáveis <x_1>, ...,
     <x_n>.  Uma expressão <expr> é equivalente a uma equação '<expr> =
     0'.  Pode existir mais equações que variáveis ou vice-versa.

     'algsys' retorna uma lista de soluções, com cada solução dada com
     uma lista de valores de estado das equações das variáveis <x_1>,
     ..., <x_n> que satisfazem o sistema de equações.  Se 'algsys' não
     pode achar uma solução, uma lista vazia '[]' é retornada.

     Os símbolos '%r1', '%r2', ..., são introduzidos tantos quantos
     forem necessários para representar parâmetros arbitrários na
     solução; essas variáveis são também anexadas à lista '%rnum_list'.

     O método usado é o seguinte:

     (1) Primeiro as equações são factorizaadas e quebradas em
     subsistemas.

     (2) Para cada subsistema <S_i>, uma equação <E> e uma variável <x>
     são seleccionados.  A variável é escolhida para ter o menor grau
     não zero.  Então a resultante de <E> e <E_j> em relação a <x> é
     calculada para cada um das equações restantes <E_j> nos subsistemas
     <S_i>.  Isso retorna um novo subsistema <S_i'> em umas poucas
     variáveis, como <x> tenha sido eliminada.  O processo agora retorna
     ao passo (1).

     (3) Eventualmente, um subsistema consistindo de uma equação simples
     é obtido.  Se a equação é de várias variáveis e aproximações na
     forma de números em ponto flutuante nã tenham sido introduzidas,
     então 'solve' é chamada para achar uma solução exacta.

     Em alguns casos, 'solve' não está habilitada a achar uma solução,
     ou se isso é feito a solução pode ser uma expressão expressão muito
     larga.

     Se a equação é de uma única variável e é ou linear, ou quadrática,
     ou biquadrada, então novamente 'solve' é chamada se aproximações
     não tiverem sido introduzidas.  Se aproximações tiverem sido
     introduzidas ou a equação não é de uma única variável e nem tão
     pouco linear, quadratica, ou biquadrada, então o comutador
     'realonly' é 'true', A função 'realroots' é chamada para achar o
     valor real das soluções.  Se 'realonly' é 'false', então 'allroots'
     é chamada a qual procura por soluções reais e complexas.

     Se 'algsys' produz uma solução que tem poucos digitos
     significativos que o requerido, o utilizador pode escolher o valor
     de 'algepsilon' para um valor maior.

     Se 'algexact' é escolhido para 'true', 'solve' será sempre chamada.

     (4) Finalmente, as soluções obtidas no passo (3) são substituídas
     dentro dos níveis prévios e o processo de solução retorna para (1).

     Quando 'algsys' encontrar uma equação de várias variáveis que
     contém aproximações em ponto flutuante (usualmente devido a suas
     falhas em achar soluções exactas por um estágio mais fácil), então
     não tentará aplicar métodos exatos para tais equações e em lugar
     disso imprime a mensagem: "'algsys' cannot solve - system too
     complicated."

     Interações com 'radcan' podem produzir expressões largas ou
     complicadas.  Naquele caso, pode ser possível isolar partes do
     resultado com 'pickapart' ou 'reveal'.

     Ocasionalmente, 'radcan' pode introduzir uma unidade imaginária
     '%i' dentro de uma solução que é actualmente avaliada como real.

     Exemplos:

     ++
          (%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
          (%o1)              2 (1 - a1) x - 2 a2 (x - 1)
          (%i2) e2: a2 - a1;
          (%o2)                        a2 - a1
          (%i3) e3: a1*(-y - x^2 + 1);
                                             2
          (%o3)                   a1 (- y - x  + 1)
          (%i4) e4: a2*(y - (x - 1)^2);
                                                 2
          (%o4)                   a2 (y - (x - 1) )
          (%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
          (%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0],

                                            [x = 1, y = 0, a1 = 1, a2 = 1]]
          (%i6) e1: x^2 - y^2;
                                        2    2
          (%o6)                        x  - y
          (%i7) e2: -1 - y + 2*y^2 - x + x^2;
                                   2        2
          (%o7)                 2 y  - y + x  - x - 1
          (%i8) algsys ([e1, e2], [x, y]);
                           1            1
          (%o8) [[x = - -------, y = -------],
                        sqrt(3)      sqrt(3)

                  1              1             1        1
          [x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
               sqrt(3)        sqrt(3)          3        3

 -- Função: allroots (<expr>)
 -- Função: allroots (<eqn>)
     Calcula aproximações numéricas de raízes reais e complexas do
     polinómio <expr> ou equação polinômial <eqn> de uma variável.

     O sinalizador 'polyfactor' quando 'true' faz com que 'allroots'
     factore o polinómio sobre os números reais se o polinómio for real,
     ou sobre os números complexos, se o polinómio for complexo.

     'allroots' pode retornar resultados imprecisos no caso de múltiplas
     raízes.  Se o polinómio for real, 'allroots (%i*<p>)') pode
     retornar aproximações mais precisas que 'allroots (<p>)', como
     'allroots' invoca um algoritmo diferente naquele caso.

     'allroots' rejeita expressoões que não sejam polinómios.  Isso
     requer que o numerador após a classificação ('rat''ing) poderá ser
     um polinómio, e isso requer que o denominador seja quando muito um
     número complexo.  Com esse tipo resultado 'allroots' irá sempre
     produzir uma expressão equivalente (mas factorizada), se
     'polyfactor' for 'true'.

     Para polinómios complexos um algoritmo por Jenkins e Traub é usado
     (Algorithm 419, Comm.  ACM, vol.  15, (1972), p.  97).  Para
     polinómios reais o algoritmo usado é devido a Jenkins (Algorithm
     493, ACM TOMS, vol.  1, (1975), p.178).

     Exemplos:

          (%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                                      3          5
          (%o1)              (2 x + 1)  = 13.5 (x  + 1)
          (%i2) soln: allroots (eqn);
          (%o2) [x = .8296749902129361, x = - 1.015755543828121,

          x = .9659625152196369 %i - .4069597231924075,

          x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
          (%i3) for e in soln
                  do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                                - 3.5527136788005E-15

                               - 5.32907051820075E-15

                   4.44089209850063E-15 %i - 4.88498130835069E-15

                  - 4.44089209850063E-15 %i - 4.88498130835069E-15

                                 3.5527136788005E-15

          (%o3)                         done
          (%i4) polyfactor: true$
          (%i5) allroots (eqn);
          (%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                                     2
           (x + 1.015755543828121) (x  + .8139194463848151 x

           + 1.098699797110288)

 -- Variável: backsubst
     Valor por omissão: 'true'

     Quando 'backsubst' é 'false', evita substituições em expressões
     anteriores após as equações terem sido triangularizadas.  Isso pode
     ser de grande ajuda em problemas muito grandes onde substituição em
     expressões anteriores pode vir a causar a geração de expressões
     extremamente largas.

 -- Variável: breakup
     Valor por omissão: 'true'

     Quando 'breakup' é 'true', 'solve' expressa soluções de equações
     cúbicas e quárticas em termos de subexpressões comuns, que são
     atribuídas a rótulos de expressões intermédias ('%t1', '%t2',
     etc.).  De outra forma, subexpressões comuns não são identificadas.

     'breakup: true' tem efeito somente quando 'programmode' é 'false'.

     Exemplos:

          (%i1) programmode: false$
          (%i2) breakup: true$
          (%i3) solve (x^3 + x^2 - 1);

                                  sqrt(23)    25 1/3
          (%t3)                  (--------- + --)
                                  6 sqrt(3)   54
          Solution:

                                                sqrt(3) %i   1
                                                ---------- - -
                          sqrt(3) %i   1            2        2   1
          (%t4)    x = (- ---------- - -) %t3 + -------------- - -
                              2        2            9 %t3        3

                                                sqrt(3) %i   1
                                              - ---------- - -
                        sqrt(3) %i   1              2        2   1
          (%t5)    x = (---------- - -) %t3 + ---------------- - -
                            2        2             9 %t3         3

                                             1     1
          (%t6)                  x = %t3 + ----- - -
                                           9 %t3   3
          (%o6)                    [%t4, %t5, %t6]
          (%i6) breakup: false$
          (%i7) solve (x^3 + x^2 - 1);
          Solution:

                       sqrt(3) %i   1
                       ---------- - -
                           2        2        sqrt(23)    25 1/3
          (%t7) x = --------------------- + (--------- + --)
                       sqrt(23)    25 1/3    6 sqrt(3)   54
                    9 (--------- + --)
                       6 sqrt(3)   54

                                                        sqrt(3) %i   1    1
                                                     (- ---------- - -) - -
                                                            2        2    3

                     sqrt(23)    25 1/3  sqrt(3) %i   1
          (%t8) x = (--------- + --)    (---------- - -)
                     6 sqrt(3)   54          2        2

                                                      sqrt(3) %i   1
                                                    - ---------- - -
                                                          2        2      1
                                                + --------------------- - -
                                                     sqrt(23)    25 1/3   3
                                                  9 (--------- + --)
                                                     6 sqrt(3)   54

                      sqrt(23)    25 1/3             1             1
          (%t9)  x = (--------- + --)    + --------------------- - -
                      6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                           9 (--------- + --)
                                              6 sqrt(3)   54
          (%o9)                    [%t7, %t8, %t9]

 -- Função: dimension (<eqn>)
 -- Função: dimension (<eqn_1>, ..., <eqn_n>)
     'dimen' é um pacote de análise dimensional.  'load ("dimen")' chama
     esse pacote.  'demo ("dimen")' mostra uma cura demostração.

 -- Variável: dispflag
     Valor por omissão: 'true'

     Se escolhida para 'false' dentro de um 'block' inibirá a
     visualização da saída gerada pelas funções solve chamadas de dentro
     de 'block'.  Terminando 'block' com um sinal de dolar, $, escolhe
     'dispflag' para 'false'.

 -- Função: funcsolve (<eqn>, <g>(<t>))
     Retorna '[<g>(<t>) = ...]' ou '[]', dependendo de existir ou não
     uma função racional '<g>(<t>)' satisfazendo <eqn>, que deve ser de
     primeira ordem, polinómio linear em (para esse caso) '<g>(<t>)' e
     '<g>(<t>+1)'

          (%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1) = (n - 1)/(n + 2);
                                      (n + 3) f(n + 1)   n - 1
          (%o1)        (n + 1) f(n) - ---------------- = -----
                                           n + 1         n + 2
          (%i2) funcsolve (eqn, f(n));

          Equações dependentes eliminadas:  (4 3)
                                             n
          (%o2)                f(n) = ---------------
                                      (n + 1) (n + 2)

     Atenção: essa é uma implementação muito rudimentar - muitas
     verificações de segurança e obviamente generalizações estão
     ausêntes.

 -- Variável: globalsolve
     Valor por omissão: 'false'

     When 'globalsolve' for 'true', variáveis para as quais as equações
     são resolvidas são atribuidas aos valores da solução encontrados
     por 'linsolve', e por 'solve' quando resolvendo duas ou mais
     equações lineares.  Quando 'globalsolve' for 'false', soluções
     encontradas por 'linsolve' e por 'solve' quando resolvendo duas ou
     mais equações lineares são espressas como equações, e as variáveis
     para as quais a equação foi resolvida não são atribuidas.

     Quando resolvendo qualquer coisa outra que não duas equações
     lineares ou mais, 'solve' ignora 'globalsolve'.  Outras funções que
     resolvem equações (e.g., 'algsys') sempre ignoram 'globalsolve'.

     Exemplos:

          (%i1) globalsolve: true$
          (%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t2)                        x : --
                                           7

                                             1
          (%t3)                        y : - -
                                             7
          (%o3)                     [[%t2, %t3]]
          (%i3) x;
                                         17
          (%o3)                          --
                                         7
          (%i4) y;
                                           1
          (%o4)                          - -
                                           7
          (%i5) globalsolve: false$
          (%i6) kill (x, y)$
          (%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t7)                        x = --
                                           7

                                             1
          (%t8)                        y = - -
                                             7
          (%o8)                     [[%t7, %t8]]
          (%i8) x;
          (%o8)                           x
          (%i9) y;
          (%o9)                           y

 -- Função: ieqn (<ie>, <unk>, <tech>, <n>, <guess>)
     'inteqn' é um pacote para resolver equações integrais.  'load
     ("inteqn")' carrega esse pacote.

     <ie> é a equação integral; <unk> é a função desconhecida; <tech> é
     a técnica a ser tentada nesses dados acima (<tech> = 'first'
     significa: tente a primeira técnica que achar uma solução; <tech> =
     'all' significa: tente todas a técnicas aplicáveis); <n> é o número
     máximo de termos a serem usados de 'taylor', 'neumann',
     'firstkindseries', ou 'fredseries' (isso é também o número máximo
     de ciclos de recurssão para o método de diferenciação); <guess> é o
     inicial suposto para 'neumann' ou 'firstkindseries'.

     Valores padrão do segundo até o quinto parâmetro são:

     <unk>: '<p>(<x>)', onde <p> é a primeira função encontrada em um
     integrando que é desconhecida para Maxima e <x> é a variável que
     ocorre como um argumento para a primeira ocorrência de <p> achada
     fora de uma integral no caso de equações 'secondkind' , ou é
     somente outra variável ao lado da variável de integração em
     equações 'firstkind'.  Se uma tentativa de procurar por <x> falha,
     o utilizador será perguntado para suprir a variável independente.

     tech: 'first'

     n: 1

     guess: 'none' o que fará com que 'neumann' e 'firstkindseries' use
     '<f>(<x>)' como uma suposição inicial.

 -- Variável de opção: ieqnprint
     Valor por omissão: 'true'

     'ieqnprint' governa o comportamento do resultado retornado pelo
     comando 'ieqn'.  Quando 'ieqnprint' é 'false', as listas retornadas
     pela função 'ieqn' são da forma

     [<solução>, <tecnica usada>, <nterms>, <sinalizador>]

     onde <sinalizador> é retirado se a solução for exacta.

     De outra forma, isso é a palavra 'approximate' ou 'incomplete'
     correspondendo à forma inexacta ou forma aberta de solução,
     respectivamente.  Se um método de série foi usado, <nterms> fornece
     o número de termos usados (que poderá ser menor que os n dados para
     'ieqn' se ocorrer um erro evita a geração de termos adicionais).

 -- Função: lhs (<expr>)
     Retorna o lado esquerdo (isto é, o primeiro argumento) da expressão
     <expr>, quando o operador de <expr> for um dos operadores
     relacionais '< <= = # equal notequal >= >', um dos operadores de
     atribuição ':= ::= : ::', ou um operadro infixo definido pelo
     utilizador, como declarado por meio de 'infix'.

     Quando <expr> for um átomo ou seu operador for alguma coisa que não
     esses listados acima, 'lhs' retorna <expr>.

     Veja também 'rhs'.

     Exemplos:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [lhs (aa < bb), lhs (aa <= bb), lhs (aa >= bb), lhs (aa > bb)];
          (%o4)                   [aa, aa, aa, aa]
          (%i5) [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)), lhs (notequal (aa, bb))];
          (%o5)                   [aa, aa, aa, aa]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
          (%o10)               [foo(x), bar(y), x, x]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) lhs (aa ][ bb);
          (%o12)                         aa

 -- Função: linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
     Resolve a lista de equações lineares simultâneas para a lista de
     variáveis.  As expressões devem ser cada uma polinómios nas
     variáveis e podem ser equações.

     Quando 'globalsolve' é 'true' então variáveis que foram resolvidas
     serão escolhidas para a solução do conjunto de equações
     simultâneas.

     Quando 'backsubst' é 'false', 'linsolve' não realiza substituição
     em equações anteriores após as equações terem sido
     triangularizadas.  Isso pode ser necessário em problemas muito
     grandes onde substituição em equações anteriores poderá causar a
     geração de expressões extremamente largas.

     Quando 'linsolve_params' for 'true', 'linsolve' também gera
     símbolos '%r' usados para representar parâmetros arbitrários
     descritos no manual sob 'algsys'.  De outra forma, 'linsolve'
     resolve um menor-determinado sistema de equações com algumas
     variáveis expressas em termos de outras.

     Quando 'programmode' for 'false', 'linsolve' mostra a solução com
     expressões intermédias com rótulos ('%t'), e retorna a lista de
     rótulos.

          (%i1) e1: x + z = y;
          (%o1)                       z + x = y
          (%i2) e2: 2*a*x - y = 2*a^2;
                                                 2
          (%o2)                   2 a x - y = 2 a
          (%i3) e3: y - 2*z = 2;
          (%o3)                      y - 2 z = 2
          (%i4) [globalsolve: false, programmode: true];
          (%o4)                     [false, true]
          (%i5) linsolve ([e1, e2, e3], [x, y, z]);
          (%o5)            [x = a + 1, y = 2 a, z = a - 1]
          (%i6) [globalsolve: false, programmode: false];
          (%o6)                    [false, false]
          (%i7) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t7)                       z = a - 1

          (%t8)                        y = 2 a

          (%t9)                       x = a + 1
          (%o9)                    [%t7, %t8, %t9]
          (%i9) ''%;
          (%o9)            [z = a - 1, y = 2 a, x = a + 1]
          (%i10) [globalsolve: true, programmode: false];
          (%o10)                    [true, false]
          (%i11) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t11)                      z : a - 1

          (%t12)                       y : 2 a

          (%t13)                      x : a + 1
          (%o13)                 [%t11, %t12, %t13]
          (%i13) ''%;
          (%o13)           [z : a - 1, y : 2 a, x : a + 1]
          (%i14) [x, y, z];
          (%o14)                 [a + 1, 2 a, a - 1]
          (%i15) [globalsolve: true, programmode: true];
          (%o15)                    [true, true]
          (%i16) linsolve ([e1, e2, e3], '[x, y, z]);
          (%o16)           [x : a + 1, y : 2 a, z : a - 1]
          (%i17) [x, y, z];
          (%o17)                 [a + 1, 2 a, a - 1]

 -- Variável: linsolvewarn
     Valor por omissão: 'true'

     Quando 'linsolvewarn' é 'true', 'linsolve' imprime uma mensagem
     "Dependent equações eliminated".

 -- Variável: linsolve_params
     Valor por omissão: 'true'

     Quando 'linsolve_params' é 'true', 'linsolve' também gera os
     símbolos '%r' usados para representar parâmetros arbitrários
     descritos no manual sob 'algsys'.  De outra forma, 'linsolve'
     resolve um menor-determinado sistema de equações com algumas
     variáveis expressas em termos e outras.

 -- Variável: multiplicities
     Valor por omissão: 'not_set_yet'

     'multiplicities' é escolhida para uma lista de multiplicidades das
     soluções individuais retornadas por 'solve' ou 'realroots'.

 -- Função: nroots (<p>, <low>, <high>)
     Retorna o número de raízes reais do polinómio real de uma única
     variável <p> no intervalo semi-aberto '(<low>, <high>]'.  Uma
     extremidade do intervalo podem ser 'minf' ou 'inf'.  infinito e
     mais infinito.

     'nroots' usa o método das sequuências de Sturm.

          (%i1) p: x^10 - 2*x^4 + 1/2$
          (%i2) nroots (p, -6, 9.1);
          (%o2)                           4

 -- Função: nthroot (<p>, <n>)
     Onde p é um polinómio com coeficientes inteiros e n é um inteiro
     positivo retorna q, um polinómio sobre os inteiros, tal que q^n=p
     ou imprime uma mensagem de erro indicando que p não é uma potência
     n-ésima perfeita.  Essa rotina é mais rápida que 'factor' ou mesmo
     'sqfr'.

 -- Variável: programmode
     Valor por omissão: 'true'

     Quando 'programmode' é 'true', 'solve', 'realroots', 'allroots', e
     'linsolve' retornam soluções como elementos em uma lista.  (Exceto
     quando 'backsubst' é escolhido para 'false', nesse caso
     'programmode: false' é assumido.)

     Quando 'programmode' é 'false', 'solve', etc.  cria rótulos de
     expressões intermédias '%t1', 't2', etc., e atribui as soluções
     para eles.

 -- Variável: realonly
     Valor por omissão: 'false'

     Quando 'realonly' é 'true', 'algsys' retorna somente aquelas
     soluções que estão livres de '%i'.

 -- Função: realroots (<expr>, <bound>)
 -- Função: realroots (<eqn>, <bound>)
 -- Função: realroots (<expr>)
 -- Função: realroots (<eqn>)
     Calcula aproximações racionais das raízes reais da expressão
     polinomial <expr> ou da equação polinomial <eqn> de uma variável,
     dentro de uma tolerância de <bound>.  coeficientes de <expr> ou de
     <eqn> devem ser números literais; constantes símbolo tais como
     '%pi' são rejeitadas.

     'realroots' atribui as multiplicidades das raízes que encontrar
     para a variável global 'multiplicities'.

     'realroots' constrói uma sequência de Sturm para delimitar cada
     raíz, e então palica a bisecção para redefinir as aproximações.
     Todos os coeficientes são convertidos para os equivalentes
     racionais antes da busca por raízes, e cálculos são realizados por
     meio de aritmética racional exacta.  Mesmo se alguns coeficientes
     forem números em ponto flutuante, os resultados são racionais (a
     menos que forçados a números em ponto flutuante por 'float' ou por
     'numer' flags).

     Quando <bound> for menor que 1, todas as raízes inteiras são
     encontradas exactamente.  Quando <bound> não for especificado, será
     assumido como sendo igual à variável globa 'rootsepsilon'.

     Quando a varável global 'programmode' for 'true', 'realroots'
     retorna uma lista da forma '[x = <x_1>, x = <x_2>, ...]'.  Quando
     'programmode' for 'false', 'realroots' cria rótulos de expressões
     intermédias '%t1', '%t2', ..., atribui os resultados a eles, e
     retorna a lista de rótulos.

     Exemplos:

          (%i1) realroots (-1 - x + x^5, 5e-6);
                                         612003
          (%o1)                     [x = ------]
                                         524288
          (%i2) ev (%[1], float);
          (%o2)                 x = 1.167303085327148
          (%i3) ev (-1 - x + x^5, %);
          (%o3)                - 7.396496210176905E-6

          (%i1) realroots (expand ((1 - x)^5 * (2 - x)^3 * (3 - x)), 1e-20);
          (%o1)                 [x = 1, x = 2, x = 3]
          (%i2) multiplicities;
          (%o2)                       [5, 3, 1]

 -- Função: rhs (<expr>)
     Retorna o lado direito (isto é, o segundo argumento) da expressão
     <expr>, quando o operador de <expr> for um dos operadores
     relacionais '< <= = # equal notequal >= >', um dos operadores de
     atribuição ':= ::= : ::', ou um operador binário infixo definido
     pelo utilizador, como declarado por meio de 'infix'.

     Quando <expr> for um étomo ou seu operadro for alguma coisa que não
     esses listados acima, 'rhs' retorna 0.

     Veja também 'lhs'.

     Exemplos:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [rhs (aa < bb), rhs (aa <= bb), rhs (aa >= bb), rhs (aa > bb)];
          (%o4)                   [bb, bb, bb, bb]
          (%i5) [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)), rhs (notequal (aa, bb))];
          (%o5)                   [bb, bb, bb, bb]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
          (%o10)                  [2 x, 3 y, y, y]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) rhs (aa ][ bb);
          (%o12)                         bb

 -- Variável de opção: rootsconmode
     Valor por omissão: 'true'

     'rootsconmode' governa o comportamento do comando 'rootscontract'.
     Veja 'rootscontract' para detalhes.

 -- Função: rootscontract (<expr>)
     Converte produtos de raízes em raízes de produtos.  Por exemplo,
     'rootscontract (sqrt(x)*y^(3/2))' retorna 'sqrt(x*y^3)'.

     Quando 'radexpand' é 'true' e 'domain' é 'real', 'rootscontract'
     converte 'abs' em 'sqrt', e.g., 'rootscontract (abs(x)*sqrt(y))'
     retorna 'sqrt(x^2*y)'.

     Existe uma opção 'rootsconmode' afectando 'rootscontract' como
     segue:

          Problem            Value of        Result of applying
                            rootsconmode        rootscontract

          x^(1/2)*y^(3/2)      false          (x*y^3)^(1/2)
          x^(1/2)*y^(1/4)      false          x^(1/2)*y^(1/4)
          x^(1/2)*y^(1/4)      true           (x*y^(1/2))^(1/2)
          x^(1/2)*y^(1/3)      true           x^(1/2)*y^(1/3)
          x^(1/2)*y^(1/4)      all            (x^2*y)^(1/4)
          x^(1/2)*y^(1/3)      all            (x^3*y^2)^(1/6)

     Quando 'rootsconmode' é 'false', 'rootscontract' contrai somente
     como relação a expoentes de número racional cujos denominadores são
     os mesmos.  A chave para os exemplos 'rootsconmode: true' é
     simplesmente que 2 divides 4 mas não divide 3.  'rootsconmode: all'
     envolve pegar o menor múltiplo comum dos denominadores dos
     expoentes.

     'rootscontract' usa 'ratsimp' em uma maneira similar a
     'logcontract'.

     Exemplos:

          (%i1) rootsconmode: false$
          (%i2) rootscontract (x^(1/2)*y^(3/2));
                                             3
          (%o2)                      sqrt(x y )
          (%i3) rootscontract (x^(1/2)*y^(1/4));
                                             1/4
          (%o3)                     sqrt(x) y
          (%i4) rootsconmode: true$
          (%i5) rootscontract (x^(1/2)*y^(1/4));
          (%o5)                    sqrt(x sqrt(y))
          (%i6) rootscontract (x^(1/2)*y^(1/3));
                                             1/3
          (%o6)                     sqrt(x) y
          (%i7) rootsconmode: all$
          (%i8) rootscontract (x^(1/2)*y^(1/4));
                                        2   1/4
          (%o8)                       (x  y)
          (%i9) rootscontract (x^(1/2)*y^(1/3));
                                       3  2 1/6
          (%o9)                      (x  y )
          (%i10) rootsconmode: false$
          (%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                              *sqrt(sqrt(1 + x) - sqrt(x)));
          (%o11)                          1
          (%i12) rootsconmode: true$
          (%i13) rootscontract (sqrt(5 + sqrt(5)) - 5^(1/4)*sqrt(1 + sqrt(5)));
          (%o13)                          0

 -- Variável de opção: rootsepsilon
     Valor por omissão: 1.0e-7

     'rootsepsilon' é a tolerância que estabelece o intervalo de
     conficência para as raízes achadas pela função 'realroots'.

 -- Função: solve (<expr>, <x>)
 -- Função: solve (<expr>)
 -- Função: solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     Resolve a equação algébrica <expr> para a variável <x> e retorna
     uma lista de equações solução em <x>.  Se <expr> não é uma equação,
     a equação '<expr> = 0' é assumida em seu lugar.  <x> pode ser uma
     função (e.g.  'f(x)'), ou outra expressão não atômica excepto uma
     adição ou um produto.  <x> pode ser omitido se <expr> contém
     somente uma variável.  <expr> pode ser uma expressão racional, e
     pode conter funções trigonométricas, exponenciais, etc.

     O seguinte método é usado:

     Tome <E> sendo a expressão e <X> sendo a variável.  Se <E> é linear
     em <X> então isso é trivialmente resolvido para <X>.  De outra
     forma se <E> é da forma 'A*X^N + B' então o resultado é
     '(-B/A)^1/N)' vezes as 'N''ésimas raízes da unidade.

     Se <E> não é linear em <X> então o máximo divisor comum (mdc) dos
     expoentes de <X> em <E> (digamos <N>) é dividido dentro dos
     expoentes e a multiplicidade das raízes é multiplicada por <N>.
     Então 'solve' é chamada novamente sobre o resultado.  Se <E> for
     dada em factores então 'solve' é chamada sobre cada um dos
     factores.  Finalmente 'solve' usará as fórmulas quadráticas,
     cúbicas, ou quárticas onde necessário.

     No caso onde <E> for um polinómio em alguma função de variável a
     ser resolvida, digamos 'F(X)', então isso é primeiro resolvida para
     'F(X)' (chama o resultado <C>), então a equação 'F(X)=C' pode ser
     resolvida para <X> fornecendo o inverso da função <F> que é
     conhecida.

     'breakup' se 'false' fará com que 'solve' expresse as soluções de
     equações cúbicas ou quárticas como expressões simples ao invés de
     como feito em cima de várias subexpressões comuns que é o padrão.

     'multiplicities' - será escolhido para uma lista de multiplicidades
     de soluções individuais retornadas por 'solve', 'realroots', ou
     'allroots'.  Tente 'apropos (solve)' para os comutadores que
     afectam 'solve'.  'describe' pode então ser usada sobre o nome do
     comutador individual se seu proprósito não é claro.

     'solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])' resolve um
     sistema de equações polinomiais (lineares ou não-lineares)
     simultâneas por chamada a 'linsolve' ou 'algsys' e retorna uma
     lista de listas solução nas variáveis.  No caso de 'linsolve' essa
     lista conterá uma lista simples de soluções.  Isso pega duas listas
     como argumentos.  A primeira lista representa as equações a serem
     resolvidas; a segunda lista é a lista de desconhecidos a ser
     determinada.  Se o número total de variáveis nas equações é igual
     ao número de equações, a segunda lista-argumento pode ser omitida.
     Para sistemas lineares se as dadas equações não são compatíveis, a
     mensagem 'inconsistent' será mostrada (veja o comutador
     'solve_inconsistent_error' ); se não existe solução única, então
     'singular' será mostrado.

     Exemplos:

          (%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

          SOLVE is using arc-trig functions to get a solution.
          Some soluções will be lost.
                                      %pi
          (%o1)                  [x = ---, f(x) = 1]
                                       6
          (%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                          log(125)
          (%o2)                   [f(x) = --------]
                                           log(5)
          (%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                                2    2
          (%o3)             [4 x  - y  = 12, x y - x = 2]
          (%i4) solve (%, [x, y]);
          (%o4) [[x = 2, y = 2], [x = .5202594388652008 %i

           - .1331240357358706, y = .0767837852378778

           - 3.608003221870287 %i], [x = - .5202594388652008 %i

           - .1331240357358706, y = 3.608003221870287 %i

           + .0767837852378778], [x = - 1.733751846381093,

          y = - .1535675710019696]]
          (%i5) solve (1 + a*x + x^3, x);
                                                 3
                        sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (%o5) [x = (- ---------- - -) (--------------- - -)
                            2        2      6 sqrt(3)      2

                  sqrt(3) %i   1
                 (---------- - -) a
                      2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                                    3
           sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (---------- - -) (--------------- - -)
               2        2      6 sqrt(3)      2

                   sqrt(3) %i   1
                (- ---------- - -) a
                       2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                   3
           sqrt(4 a  + 27)   1 1/3               a
          (--------------- - -)    - --------------------------]
              6 sqrt(3)      2                  3
                                        sqrt(4 a  + 27)   1 1/3
                                     3 (--------------- - -)
                                           6 sqrt(3)      2
          (%i6) solve (x^3 - 1);
                       sqrt(3) %i - 1        sqrt(3) %i + 1
          (%o6)   [x = --------------, x = - --------------, x = 1]
                             2                     2
          (%i7) solve (x^6 - 1);
                     sqrt(3) %i + 1      sqrt(3) %i - 1
          (%o7) [x = --------------, x = --------------, x = - 1,
                           2                   2

                               sqrt(3) %i + 1        sqrt(3) %i - 1
                         x = - --------------, x = - --------------, x = 1]
                                     2                     2
          (%i8) ev (x^6 - 1, %[1]);
                                                6
                                (sqrt(3) %i + 1)
          (%o8)                 ----------------- - 1
                                       64
          (%i9) expand (%);
          (%o9)                           0
          (%i10) x^2 - 1;
                                        2
          (%o10)                       x  - 1
          (%i11) solve (%, x);
          (%o11)                  [x = - 1, x = 1]
          (%i12) ev (%th(2), %[1]);
          (%o12)                          0

 -- Variável de opção: solvedecomposes
     Valor por omissão: 'true'

     Quando 'solvedecomposes' é 'true', 'solve' chama 'polydecomp' se
     perguntado para resolver polinómios.

 -- Variável de opção: solveexplicit
     Valor por omissão: 'false'

     Quando 'solveexplicit' é 'true', inibe 'solve' de retornar soluções
     implícitas, isto é, soluções da forma 'F(x) = 0' onde 'F' é alguma
     função.

 -- Variável de opção: solvefactors
     Valor por omissão: 'true'

     Quando 'solvefactors' é 'false', 'solve' não tenta factorizar a
     expressão.  A escolha do 'false' poderá ser útil em alguns casos
     onde a factorização não é necessária.

 -- Variável de opção: solvenullwarn
     Valor por omissão: 'true'

     Quando 'solvenullwarn' é 'true', 'solve' imprime uma mensagem de
     alerta se chamada com ou uma lista equação ou uma variável lista
     nula.  Por exemplo, 'solve ([], [])' imprimirá duas mensagens de
     alerta e retorna '[]'.

 -- Variável de opção: solveradcan
     Valor por omissão: 'false'

     Quando 'solveradcan' é 'true', 'solve' chama 'radcan' que faz
     'solve' lento mas permitirá certamente que problemas contendo
     exponeniais e logaritmos sejam resolvidos.

 -- Variável de opção: solvetrigwarn
     Valor por omissão: 'true'

     Quando 'solvetrigwarn' é 'true', 'solve' pode imprimir uma mensagem
     dizendo que está usando funções trigonométricas inversas para
     resolver a equação, e desse modo perdendo soluções.

 -- Variável de opção: solve_inconsistent_error
     Valor por omissão: 'true'

     Quando 'solve_inconsistent_error' é 'true', 'solve' e 'linsolve'
     resultam em erro se as equações a serem resolvidas são
     inconsistentes.

     Se 'false', 'solve' e 'linsolve' retornam uma lista vazia '[]' se
     as equações forem inconsistentes.

     Exemplo:

          (%i1) solve_inconsistent_error: true$
          (%i2) solve ([a + b = 1, a + b = 2], [a, b]);
          Inconsistent equações:  (2)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i3) solve_inconsistent_error: false$
          (%i4) solve ([a + b = 1, a + b = 2], [a, b]);
          (%o4)                          []


File: maxima.info,  Node: Equações Diferenciais,  Next: Numérico,  Prev: Equações,  Up: Top

22 Equações Diferenciais
************************

* Menu:

* Introdução às Equações Diferenciais::
* Definições para Equações Diferenciais::  


File: maxima.info,  Node: Introdução às Equações Diferenciais,  Next: Definições para Equações Diferenciais,  Prev: Equações Diferenciais,  Up: Equações Diferenciais

22.1 Introdução às Equações Diferenciais
========================================

Esta secção descreve as funções disponíveis no Maxima para obter a
solução analítica de alguns tipos específicos de equações diferencias de
primeira e segunda ordem.  Para obter a solução numérica dum sistema de
equações diferenciais, consulte o pacote adicional 'dynamics'.  Para
obter representações gráficas no espaço de fase, consulte o pacote
adicional 'plotdf'.


File: maxima.info,  Node: Definições para Equações Diferenciais,  Prev: Introdução às Equações Diferenciais,  Up: Equações Diferenciais

22.2 Definições para Equações Diferenciais
==========================================

 -- Função: bc2 (<solução>, <xval1>, <yval1>, <xval2>, <yval2>)
     Resolve um problema de valores fronteira para uma equação
     diferencial de segunda ordem.  Aqui: <solução> é uma solução geral
     para a equação, calculada por 'ode2'; <xval1> define o valor da
     variável independente, num primeiro ponto, na forma '<x> = <x1>', e
     <yval1> define o valor da variável dependente, no mesmo ponto, na
     forma '<y> = <y1>'.  As expressões <xval2> e <yval2> definem os
     valores das mesmas variáveis, num segundo ponto, usando a mesma
     forma.

     Veja um exemplo da sua utilização na documentação de 'ode2'.

 -- Função: desolve (<eqn>, <x>)
 -- Função: desolve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     A função 'dsolve' resolve sistemas de equações diferenciais
     ordinárias lineares usando transformada de Laplace.  Aqui as
     expressões <eqn> são equações diferenciais nas variáveis
     dependentes <x_1>, ..., <x_n>.  A relação funcional de <x_1>, ...,
     <x_n> na variável independente deve ser indicada explicitamente nas
     variáveis e nas suas derivadas.  Por exemplo, esta forma de definir
     as equações não seria correcta:

          eqn_1: 'diff(f,x,2) = sin(x) + 'diff(g,x);
          eqn_2: 'diff(f,x) + x^2 - f = 2*'diff(g,x,2);

     A forma correcta seria:

          eqn_1: 'diff(f(x),x,2) = sin(x) + 'diff(g(x),x);
          eqn_2: 'diff(f(x),x) + x^2 - f(x) = 2*'diff(g(x),x,2);

     Assim, a chamada à função 'desolve' seria:
          desolve([eqn_1, eqn_2], [f(x),g(x)]);

     Se as condições iniciais em 'x=0' forem conhecidas, poderão ser
     fornecidas antes de usar 'desolve', através de 'atvalue'.

          (%i1) 'diff(f(x),x)='diff(g(x),x)+sin(x);
                           d           d
          (%o1)            -- (f(x)) = -- (g(x)) + sin(x)
                           dx          dx
          (%i2) 'diff(g(x),x,2)='diff(f(x),x)-cos(x);
                            2
                           d            d
          (%o2)            --- (g(x)) = -- (f(x)) - cos(x)
                             2          dx
                           dx
          (%i3) atvalue('diff(g(x),x),x=0,a);
          (%o3)                           a
          (%i4) atvalue(f(x),x=0,1);
          (%o4)                           1
          (%i5) desolve([%o1,%o2],[f(x),g(x)]);
                            x
          (%o5) [f(x) = a %e  - a + 1, g(x) =

                                                          x
                                             cos(x) + a %e  - a + g(0) - 1]
          (%i6) [%o1,%o2],%o5,diff;
                       x       x      x                x
          (%o6)   [a %e  = a %e , a %e  - cos(x) = a %e  - cos(x)]

     Se 'desolve' não pode obter uma solução, retorna 'false'.

 -- Função: ic1 (<solução>, <xval>, <yval>)
     Resolve problemas de valor inicial para equações diferenciais de
     primeira ordem.  Aqui <solução> é uma solução geral para a equação,
     na forma dada por 'ode2', <xval> dá um valor inicial para a
     variável independente, na forma '<x> = <x0>', e <yval> dá o valor
     inicial para a variável dependente, na forma '<y> = <y0>'.

     Veja um exemplo da sua utilização na documentação de 'ode2'.

 -- Função: ic2 (<solução>, <xval>, <yval>, <dval>)
     Resolve problemas de valores iniciais para equações diferenciais de
     segunda ordem.  Aqui <solução> é uma solução geral para a equação,
     na forma dada por 'ode2', <xval> dá um valor inicial para a
     variável independente, na forma '<x> = <x0>', <yval> dá o valor
     inicial para a variável dependente, na forma '<y> = <y0>' e <dval>
     dá o valor inicial para a primeira derivada da variável dependente,
     em função da variável independente, na forma 'diff(<y>,<x>) =
     <dy0>' ('diff' não tem que ser precedido por apóstrofo).

     Veja um exemplo da sua utilização na documentação de 'ode2'.

 -- Função: ode2 (<eqn>, <dvar>, <ivar>)
     A função 'ode2' resolve uma equação diferencial ordinária (EDO) de
     primeira ou de segunda ordem.  Precisa de três argumentos: uma EDO
     dada por <eqn>, a variável dependente <dvar>, e a variável
     independente <ivar>.  Quando conseguir, retorna uma solução para a
     variável dependente, na forma explícita ou implícita.  '%c' é usado
     para representar a constante de integração no caso de equações de
     primeira ordem, e '%k1' e '%k2' as constantes para equações de
     segunda ordem.  A dependência da variável dependente na variável
     independente não tem que ser escrita em forma explícita, como no
     caso de 'desolve', mas a variável independente deverá ser indicada
     sempre no terceiro argumento.

     Se por alguma razão 'ode2' não conseguir encontrar a solução,
     retornará 'false', após talvez mostrar uma mensagem de erro.  Os
     métodos implementados para equações diferenciais de primeira ordem,
     na ordem em que serão testados, são: linear, separável, exacta -
     talvez requerendo um factor de integração, homogénea, equação de
     Bernoulli, homogénea generalizada.  Os tipos de equações de segunda
     ordem que podem ser resolvidas são: coeficientes constantes,
     exactas, linear homogéneas com coeficientes não-constantes que
     possam ser transformados para constates, equação de Euler ou
     equi-dimensional, equações que possam ser resolvidas pelo método de
     variação dos parâmetros, e equações que não dependam ou da variável
     independente ou da variável dependente de modo que possam ser
     reduzidas a duas equações lineares de primeira ordem a serem
     resolvidas sequêncialmente.

     Durante o processo de resolução da EDO, serão dados valores a
     várias variáveis locais, com fins puramente informativos: 'método'
     denota o método de solução usado (por exemplo, 'linear'),
     'intfactor' denota qualquer factor integrante utilizado, 'odeindex'
     denota o índice para o método de Bernoulli ou para o método
     homogéneo generalizado, e 'yp' denota a solução particular no
     método de variação dos parâmetros.

     Para resolver problemas de valores iniciais (PVI) estão disponíveis
     as funções 'ic1' e 'ic2'e, para equações de primeira e segunda
     ordem, e para resolver problemas de valores fronteira (PVF) de
     segunda ordem pode usar-se a função 'bc2'.

     Exemplo:

          (%i1) x^2*'diff(y,x) + 3*y*x = sin(x)/x;
                                2 dy           sin(x)
          (%o1)                x  -- + 3 x y = ------
                                  dx             x
          (%i2) ode2(%,y,x);
                                       %c - cos(x)
          (%o2)                    y = -----------
                                            3
                                           x
          (%i3) ic1(%o2,x=%pi,y=0);
                                        cos(x) + 1
          (%o3)                   y = - ----------
                                             3
                                            x
          (%i4) 'diff(y,x,2) + y*'diff(y,x)^3 = 0;
                                   2
                                  d y      dy 3
          (%o4)                   --- + y (--)  = 0
                                    2      dx
                                  dx
          (%i5) ode2(%,y,x);
                                3
                               y  + 6 %k1 y
          (%o5)                ------------ = x + %k2
                                    6
          (%i6) ratsimp(ic2(%o5,x=0,y=0,'diff(y,x)=2));
                                       3
                                    2 y  - 3 y
          (%o6)                   - ---------- = x
                                        6
          (%i7) bc2(%o5,x=0,y=1,x=1,y=3);
                                   3
                                  y  - 10 y       3
          (%o7)                   --------- = x - -
                                      6           2


File: maxima.info,  Node: Numérico,  Next: Arrays,  Prev: Equações Diferenciais,  Up: Top

23 Numérico
***********

* Menu:

* Introdução a Numérico::
* Pacotes de Fourier::
* Definições para Numérico::
* Definições para Séries de Fourier::


File: maxima.info,  Node: Introdução a Numérico,  Next: Pacotes de Fourier,  Prev: Numérico,  Up: Numérico

23.1 Introdução a Numérico
==========================


File: maxima.info,  Node: Pacotes de Fourier,  Next: Definições para Numérico,  Prev: Introdução a Numérico,  Up: Numérico

23.2 Pacotes de Fourier
=======================

O pacote 'fft' compreende funções para computação numérica (não
simbólica) das transformações rápidas de Fourier.  'load ("fft")' chama
esse pacote.  Veja 'fft'.

O pacote 'fourie' compreende funções para computação simbólica de séries
de Fourier.  'load ("fourie")' chama esse pacote.  Existem funções no
pacote 'fourie' para calcular coeficientes da integral de Fourier e
algumas funções para manipulação de expressões.  Veja 'Definições para
Séries'.


File: maxima.info,  Node: Definições para Numérico,  Next: Definições para Séries de Fourier,  Prev: Pacotes de Fourier,  Up: Numérico

23.3 Definições para Numérico
=============================

 -- Função: polartorect (<magnitude_array>, <phase_array>)

     Traduz valores complexos da forma 'r %e^(%i t)' para a forma 'a + b
     %i'.  'load ("fft")' chama essa função dentro do Maxima.  Veja
     também 'fft'.

     O módulo e a fase, 'r' e 't', São tomados de <magnitude_array> e
     <phase_array>, respectivamente.  Os valores originais de arrays de
     entrada são substituídos pelas partes real e emaginária, 'a' e 'b',
     no retorno.  As saídas são calculadas como

          a: r cos (t)
          b: r sin (t)

     Os arrays de entrada devem ter o mesmo tamanho e ser
     unidimensionais.  O tamanho do array não deve ser uma potência de
     2.

     'polartorect' é a função inversa de 'recttopolar'.

 -- Função: recttopolar (<real_array>, <imaginary_array>)

     Traduz valores complexos da forma 'a + b %i' para a forma 'r %e^(%i
     t)'.  'load ("fft")' chama essa função dentro do Maxima.  Veja
     também 'fft'.

     As partes real e imaginária, 'a' e 'b', são tomadas de <real_array>
     e <imaginary_array>, respectivamente.  Os valores originais dos
     arrays de entrada são substituídos pelo módulo e pelo ângulo, 'r' e
     't', no retorno.  As saídas são calculadas como

          r: sqrt (a^2 + b^2)
          t: atan2 (b, a)

     O ângulo calculado encontra-se no intervalo de '-%pi' a '%pi'.

     Os arrays de entrada devem ter o mesmo tamanho e ser
     unidimensionais.  O tamanho do array não deve ser uma potência de
     2.

     'recttopolar' é a função inversa de 'polartorect'.

 -- Função: ift (<real_array>, <imaginary_array>)

     Transformação rápida inversa discreta de Fourier .  'load ("fft")'
     chama essa função dentro do Maxima.

     'ift' realiza a transformação rápida complexa de Fourier sobre
     arrays em ponto flutuante unidimensionais.  A transformação inversa
     é definida como

          x[j]: sum (y[j] exp (+2 %i %pi j k / n), k, 0, n-1)

     Veja 'fft' para maiores detalhes.

 -- Função: fft (<real_array>, <imaginary_array>)
 -- Função: ift (<real_array>, <imaginary_array>)
 -- Função: recttopolar (<real_array>, <imaginary_array>)
 -- Função: polartorect (<magnitude_array>, <phase_array>)

     Transformação rápidada de Fourier e funções relacionadas.  'load
     ("fft")' chama essas funções dentro do Maxima.

     'fft' e 'ift' realiza transformação rápida complexa de Fourier e a
     transformação inversa, respectivamente, sobre arrays em ponto
     flutuante unidimensionais.  O tamanho de <imaginary_array> deve ser
     igual ao tamanho de <real_array>.

     'fft' e 'ift' operam in-loco.  Isto é, sobre o retorno de 'fft' ou
     de 'ift', O conteúdo original dos arrays de entrada é substituído
     pela saída.  A função 'fillarray' pode fazer uma cópia de um array,
     isso pode ser necessário.

     A transformação discreta de Fourier e sua transformação inversa são
     definidas como segue.  Tome 'x' sendo os dados originais, com

          x[i]: real_array[i] + %i imaginary_array[i]

     Tome 'y' sendo os dados transformados.  A transformação normal e
     sua transformação inversa são

          y[k]: (1/n) sum (x[j] exp (-2 %i %pi j k / n), j, 0, n-1)

          x[j]:       sum (y[j] exp (+2 %i %pi j k / n), k, 0, n-1)

     Arrays adequadas podem ser alocadas pela função 'array'.  Por
     exemplo:

          array (my_array, float, n-1)$

     declara um array unidimensional com n elementos, indexado de 0 a
     n-1 inclusive.  O número de elementos n deve ser igual a 2^m para
     algum m.

     'fft' pode ser aplicada a dados reais (todos os arrays imaginários
     são iguais a zero) para obter coeficientes seno e co-seno.  Após
     chamar 'fft', os coeficientes seno e co-seno, digamos 'a' e 'b',
     podem ser calculados como

          a[0]: real_array[0]
          b[0]: 0

     e

          a[j]: real_array[j] + real_array[n-j]
          b[j]: imaginary_array[j] - imaginary_array[n-j]

     para j variando de 1 a n/2-1, e

          a[n/2]: real_array[n/2]
          b[n/2]: 0

     'recttopolar' traduz valores complexos da forma 'a + b %i' para a
     forma 'r %e^(%i t)'.  Veja 'recttopolar'.

     'polartorect' traduz valores complexos da forma 'r %e^(%i t)' para
     a forma 'a + b %i'.  Veja 'polartorect'.

     'demo ("fft")' exibe uma demonstração do pacote 'fft'.

 -- Variável de opção: fortindent
     Valor por omissão: 0

     'fortindent' controla a margem esquerda de indentação de expressões
     mostradas pelo comando 'fortran'.  0 fornece indentação normal
     (i.e., 6 espaços), e valores positivos farão com que expressões
     sejam mostrados mais além para a direita.

 -- Função: fortran (<expr>)
     Mostra <expr> como uma declaração Fortran.  A linha de saída é
     indentada com espaços.  Se a linha for muito longa, 'fortran'
     imprime linhas de continuação.  'fortran' mostra o operador de
     exponenciação '^' como '**', e mostra um número complexo 'a + b %i'
     na forma '(a,b)'.

     <expr> pode ser uma equação.  Nesse caso, 'fortran' mostra uma
     declaração de atribuição, atribuindo o primeiro membro (esquerda)
     da equação ao segundo membro (direita).  Em particular, se o
     primeiro membro <expr> é um nome de uma matriz, então 'fortran'
     mostra uma declaração de atribuição para cada elemento da matriz.

     Se <expr> não for alguma coisa reconhecida por 'fortran', a
     expressão é mostrada no formato 'grind' sem reclamação.  'fortran'
     não conhece listas, arrays ou funções.

     'fortindent' controla o margem esquerda das linhas mostradas.  0 é
     a margem normal (i.e., indentada 6 espaços).  Incrementando
     'fortindent' faz com que expressões sejam mostradas adiante para a
     direita.

     quando 'fortspaces' for 'true', 'fortran' preenche cada linha
     mostrada com espaços em branco até completar 80 columas.

     'fortran' avalia seus argumentos; colocando um apóstrofo em um
     argumento evita avaliação.  'fortran' sempre retorna 'done'.

     Exemplos:

          (%i1) expr: (a + b)^12$
          (%i2) fortran (expr);
                (b+a)**12
          (%o2)                         done
          (%i3) fortran ('x=expr);
                x = (b+a)**12
          (%o3)                         done
          (%i4) fortran ('x=expand (expr));
                x = b**12+12*a*b**11+66*a**2*b**10+220*a**3*b**9+495*a**4*b**8+792
               1   *a**5*b**7+924*a**6*b**6+792*a**7*b**5+495*a**8*b**4+220*a**9*b
               2   **3+66*a**10*b**2+12*a**11*b+a**12
          (%o4)                         done
          (%i5) fortran ('x=7+5*%i);
                x = (7,5)
          (%o5)                         done
          (%i6) fortran ('x=[1,2,3,4]);
                x = [1,2,3,4]
          (%o6)                         done
          (%i7) f(x) := x^2$
          (%i8) fortran (f);
                f
          (%o8)                         done

 -- Variável de opção: fortspaces
     Valor por omissão: 'false'

     Quando 'fortspaces' for 'true', 'fortran' preenche cada linha
     mostrada com espaços em branco até completar 80 columas.

 -- Função: horner (<expr>, <x>)
 -- Função: horner (<expr>)
     Retorna uma representação rearranjada de <expr> como na regra de
     Horner, usando <x> como variável principal se isso for
     especificado.  'x' pode ser omitido e nesse caso a variável
     principal da forma de expressão racional canónica de <expr> é
     usada.

     'horner' algumas vezes melhora a estabilidade se 'expr' for ser
     numericamente avaliada.  Isso também é útil se Maxima é usado para
     gerar programas para rodar em Fortran.  Veja também 'stringout'.

          (%i1) expr: 1e-155*x^2 - 5.5*x + 5.2e155;
                                     2
          (%o1)            1.0E-155 x  - 5.5 x + 5.2E+155
          (%i2) expr2: horner (%, x), keepfloat: true;
          (%o2)            (1.0E-155 x - 5.5) x + 5.2E+155
          (%i3) ev (expr, x=1e155);
          Maxima encountered a Lisp error:

           floating point overflow

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i4) ev (expr2, x=1e155);
          (%o4)                       7.0E+154

 -- Função: find_root (<f>(<x>), <x>, <a>, <b>)
 -- Função: find_root (<f>, <a>, <b>)
     Encontra a raíz da função <f> com a variável <x> percorrendo o
     intervalo '[<a>, <b>]'.  A função deve ter um sinal diferente em
     cada ponto final.  Se essa condição não for alcançada, a action of
     the function is governed by 'find_root_error'.  If
     'find_root_error' is 'true' then an error occurs, otherwise the
     value of 'find_root_error' is returned (thus for plotting
     'find_root_error' might be set to 0.0).  De outra forma (dado que
     Maxima pode avaliar o primeiro argumento no intervalo especificado,
     e que o intervalo é contínuo) 'find_root' é garantido vir para cima
     com a raíz (ou um deles se existir mais que uma raíz).  A precisão
     de 'find_root' é governada por 'intpolabs' e 'intpolrel' os quais
     devem ser números em ponto flutuante não negativos.  'find_root'
     encerrará quando o primeiro argumento avaliar para alguma coisa
     menor que ou igual a 'intpolabs' ou se sucessivas aproximações da
     raíz diferirem por não mais que 'intpolrel * <um dos
     aproximandos>'.  O valor padrão de 'intpolabs' e 'intpolrel' são
     0.0 de forma que 'find_root' pega como boa uma resposta como for
     possível com a precisão aritmética simples que tivermos.  O
     primeiro argumento pode ser uma equação.  A ordem dos dois últimos
     argumentos é irrelevante.  Dessa forma

          find_root (sin(x) = x/2, x, %pi, 0.1);

     é equivalente a

          find_root (sin(x) = x/2, x, 0.1, %pi);

     O método usado é uma busca binária no intervalo especificado pelos
     últimos dois argumentos.  Quando o resultado da busca for
     encontrado a função é fechada o suficiente para ser linear, isso
     inicia usando interpolação linear.

     Examples:
          (%i1) f(x) := sin(x) - x/2;
                                                  x
          (%o1)                  f(x) := sin(x) - -
                                                  2
          (%i2) find_root (sin(x) - x/2, x, 0.1, %pi);
          (%o2)                   1.895494267033981
          (%i3) find_root (sin(x) = x/2, x, 0.1, %pi);
          (%o3)                   1.895494267033981
          (%i4) find_root (f(x), x, 0.1, %pi);
          (%o4)                   1.895494267033981
          (%i5) find_root (f, 0.1, %pi);
          (%o5)                   1.895494267033981

 -- Variável de opção: find_root_abs
     Valor por omissão: 0.0

     'find_root_abs' é a precisão do comando 'find_root'.  A precisão é
     governada por 'find_root_abs' e 'find_root_rel' que devem ser
     números não negativos em ponto flutuante.  'find_root' terminará
     quando o primeiro argumento avaliar para alguma coisa menor que ou
     igual a 'find_root_abs' ou se sucessivos aproximandos para a raíz
     diferirem por não mais que 'find_root_rel * <um dos aproximandos>'.
     Os valores padrão de 'find_root_abs' e 'find_root_rel' são 0.0 de
     forma que 'find_root' tome como boa uma resposta que for possível
     com a precisão aritmética simples que tivermos.

 -- Variável de opção: find_root_error
     Valor por omissão: 'true'

     'find_root_error' governa o comportamento de 'find_root'.  Quando
     'find_root' for chamada, ela determina se a função a ser resolvida
     satisfaz ou não a condição que os valores da função nos pontos
     finais do intervalo de interpolação são opostos em sinal.  Se eles
     forem de sinais opostos, a interpolação prossegue.  Se eles forem
     de mesmo sinal, e 'find_root_error' for 'true', então um erro é
     sinalizado.  Se eles forem de mesmo sinal e 'find_root_error' não
     for 'true', o valor de 'find_root_error' é retornado.  Dessa forma
     para montagem de gráfico, 'find_root_error' pode ser escolhida para
     0.0.

 -- Variável de opção: find_root_rel
     Valor por omissão: 0.0

     'find_root_rel' é a precisão do comando 'find_root' e é governada
     por 'find_root_abs' e 'find_root_rel' que devem ser números não
     negativos em ponto flutuante.  'find_root' terminará quando o
     primeiro argumento avaliar para alguma coisa menor que ou igual a
     'find_root_abs' ou se sucessivos aproximandos para a raíz diferirem
     de não mais que 'find_root_rel * <um dos aproximandos>'.  Os
     valores padrão de 'find_root_labs' e 'find_root_rel' é 0.0 de forma
     que 'find_root' toma como boa uma resposta que for possível com a
     precisão aritmética simples que tivermos.

 -- Função: newton (<expr>, <x>, <x_0>, <eps>)
     Retorna uma solução aproximada de '<expr> = 0' através do método de
     Newton, considerando <expr> como sendo uma função de uma variável,
     <x>.  A busca pela solução começa com '<x> = <x_0>' e prossegue até
     'abs(<expr>) < <eps>' (com <expr> avaliada para o valor corrente de
     <x>).

     'newton' permite que variáveis indefinidas apareçam em <expr>,
     contanto que o teste de terminação 'abs(<expr>) < <eps>' avalie
     para 'true' ou 'false'.  Dessa forma não é necessário que <expr>
     avalie para um número.

     'load(newton1)' chama essa função.

     Veja também 'realroots', 'allroots', 'find_root', e 'mnewton'.

     Exemplos:

          (%i1) load (newton1);
          (%o1) /usr/share/maxima/5.10.0cvs/share/numeric/newton1.mac
          (%i2) newton (cos (u), u, 1, 1/100);
          (%o2)                   1.570675277161251
          (%i3) ev (cos (u), u = %);
          (%o3)                 1.2104963335033528E-4
          (%i4) assume (a > 0);
          (%o4)                        [a > 0]
          (%i5) newton (x^2 - a^2, x, a/2, a^2/100);
          (%o5)                  1.00030487804878 a
          (%i6) ev (x^2 - a^2, x = %);
                                                     2
          (%o6)                6.098490481853958E-4 a


File: maxima.info,  Node: Definições para Séries de Fourier,  Prev: Definições para Numérico,  Up: Numérico

23.4 Definições para Séries de Fourier
======================================

 -- Função: equalp (<x>, <y>)
     Retorna 'true' se 'equal (<x>, <y>)' de outra forma 'false' (não
     fornece uma mensagem de erro como 'equal (x, y)' poderia fazer
     nesse caso).

 -- Função: remfun (<f>, <expr>)
 -- Função: remfun (<f>, <expr>, <x>)
     'remfun (<f>, <expr>)' substitue todas as ocorrências de '<f>
     (<arg>)' por <arg> em <expr>.

     'remfun (<f>, <expr>, <x>)' substitue todas as ocorrências de '<f>
     (<arg>)' por <arg> em <expr> somente se <arg> contiver a variável
     <x>.

 -- Função: funp (<f>, <expr>)
 -- Função: funp (<f>, <expr>, <x>)
     'funp (<f>, <expr>)' retorna 'true' se <expr> contém a função <f>.

     'funp (<f>, <expr>, <x>)' retorna 'true' se <expr> contém a função
     <f> e a variável <x> em algum lugar no argumento de uma das
     instâncias de <f>.

 -- Função: absint (<f>, <x>, <halfplane>)
 -- Função: absint (<f>, <x>)
 -- Função: absint (<f>, <x>, <a>, <b>)
     'absint (<f>, <x>, <halfplane>)' retorna a integral indefinida de
     <f> com relação a <x> no dado semi-plano ('pos', 'neg', ou 'both').
     <f> pode conter expressões da forma 'abs (x)', 'abs (sin (x))',
     'abs (a) * exp (-abs (b) * abs (x))'.

     'absint (<f>, <x>)' é equivalente a 'absint (<f>, <x>, pos)'.

     'absint (<f>, <x>, <a>, <b>)' retorna a integral definida de <f>
     com relação a <x> de <a> até <b>.  <f> pode incluir valores
     absolutos.

 -- Função: fourier (<f>, <x>, <p>)
     Retorna uma lista de coeficientes de Fourier de '<f>(<x>)'
     definidos sobre o intervalo '[-p, p]'.

 -- Função: foursimp (<l>)
     Simplifica 'sin (n %pi)' para 0 se 'sinnpiflag' for 'true' e 'cos
     (n %pi)' para '(-1)^n' se 'cosnpiflag' for 'true'.

 -- Variável de opção: sinnpiflag
     Valor por omissão: 'true'

     Veja 'foursimp'.

 -- Variável de opção: cosnpiflag
     Valor por omissão: 'true'

     Veja 'foursimp'.

 -- Função: fourexpand (<l>, <x>, <p>, <limit>)
     Constrói e retorna a série de Fourier partindo da lista de
     coeficientes de Fourier <l> até (up through) <limit> termos
     (<limit> pode ser 'inf').  <x> e <p> possuem o mesmo significado
     que em 'fourier'.

 -- Função: fourcos (<f>, <x>, <p>)
     Retorna os coeficientes do co-seno de Fourier para '<f>(<x>)'
     definida sobre '[0, %pi]'.

 -- Função: foursin (<f>, <x>, <p>)
     Retorna os coeficientes do seno de Fourier para '<f>(<x>)' definida
     sobre '[0, <p>]'.

 -- Função: totalfourier (<f>, <x>, <p>)
     Retorna 'fourexpand (foursimp (fourier (<f>, <x>, <p>)), <x>, <p>,
     'inf)'.

 -- Função: fourint (<f>, <x>)
     Constrói e retorna uma lista de coeficientes de integral de Fourier
     de '<f>(<x>)' definida sobre '[minf, inf]'.

 -- Função: fourintcos (<f>, <x>)
     Retorna os coeficientes da integral do co-seno de Fourier para
     '<f>(<x>)' on '[0, inf]'.

 -- Função: fourintsin (<f>, <x>)
     Retorna os coeficientes da integral do seno de Fourier para
     '<f>(<x>)' on '[0, inf]'.


File: maxima.info,  Node: Arrays,  Next: Matrizes e Álgebra Linear,  Prev: Numérico,  Up: Top

24 Arrays
*********

* Menu:

* Definições para Arrays::  


File: maxima.info,  Node: Definições para Arrays,  Prev: Arrays,  Up: Arrays

24.1 Definições para Arrays
===========================

 -- Função: array (<name>, <dim_1>, ..., <dim_n>)
 -- Função: array (<name>, <type>, <dim_1>, ..., <dim_n>)
 -- Função: array ([<nome_1>, ..., <nome_m>], <dim_1>, ..., <dim_n>)

     Cria um array n-dimensional.  n pode ser menor ou igual a 5.  Os
     subscritos para a i'ésima dimensão são inteiros no intervalo de 0 a
     <dim_i>.

     'array (<name>, <dim_1>, ..., <dim_n>)' cria um array genérico.

     'array (<name>, <type>, <dim_1>, ..., <dim_n>)' cria um array, com
     elementos de um tipo especificado.  <type> pode ser 'fixnum' para
     inteiros de tamanho limitado ou 'flonum' para números em ponto
     flutuante.

     'array ([<nome_1>, ..., <nome_m>], <dim_1>, ..., <dim_n>)' cria m
     arrays, todos da mesma dimensão.

     Se o utilizador atribui a uma variável subscrita antes de declarar
     o array correspondente, um array não declarado é criado.  Arrays
     não declarados, também conhecidos como array desordenado (porque o
     codigo desordenado termina nos subscritos), são mais gerais que
     arrays declarados.  O utilizador não declara seu tamanho máximo, e
     ele cresce dinamicamente e desordenadamente à medida que são
     atribuídos valores a mais elementos.  Os subscritos de um array não
     declarado não precisam sempre ser números.  Todavia, excepto para
     um array um tanto quanto esparso, é provavelmente mais eficiente
     declarar isso quando possível que deixar não declarado.  A função
     'array' pode ser usada para transformar um array não declarado em
     um array declarado.

 -- Função: arrayapply (<A>, [<i_1>, ..., <i_n>])
     Avalia '<A> [<i_1>, ..., <i_n>]', quando <A> for um array e <i_1>,
     ..., <i_n> são inteiros.

     Ela é remanescente de 'apply', excepto o primeiro argumento que é
     um array ao invés de uma função.

 -- Função: arrayinfo (<A>)
     Retorna informações sobre o array <A>.  O argumento <A> pode ser um
     array declarado, uma array não declarado ( que sofreu um hash), uma
     função de array, ou uma função que possui subscrito.

     Para arrays declarados, 'arrayinfo' retorna uma lista compreendendo
     o átomo 'declared', o n;umero de dimensões, e o tamanho de cada
     dimensão.  Os elementos do array, ambos associados e não
     associados, são retornados por 'listarray'.

     Para arrays não declarados (arrays que sofreram um hash),
     'arrayinfo' retorna uma lista compreendendo o átomo 'hashed', o
     número de subscritos, e os subscritos de de todo elemento que tiver
     um valor.  Os valores são retornados por meio de 'listarray'.

     Para funções de array, 'arrayinfo' retretorna uma lista
     compreendendo o átomo 'hashed', o número de subscritos, e quaisquer
     valores de subscritos para os quais exista valores funcionais
     armazenados.  Os valores funcionais armazenados são retornados
     através de 'listarray'.

     Para funções que possuem subscritos, 'arrayinfo' retorna uma lista
     compreendendo o átomo 'hashed', o número de subscritos, e qualquer
     valores subscritos para os quais existe uma expressões lambda.  As
     expressões lambda são retornadas por 'listarray'.

     Examples:

     'arrayinfo' e 'listarray' aplicado a um array declarado.

          (%i1) array (aa, 2, 3);
          (%o1)                          aa
          (%i2) aa [2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa [1, 2] : %e;
          (%o3)                          %e
          (%i4) arrayinfo (aa);
          (%o4)                 [declared, 2, [2, 3]]
          (%i5) listarray (aa);
          (%o5) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]

     'arrayinfo' e 'listarray' aplicado a um array não declarado (no
     qual foi aplicado um hash).

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) arrayinfo (bb);
          (%o3)               [hashed, 1, [BAR], [FOO]]
          (%i4) listarray (bb);
                                        3         2
          (%o4)                 [(c - d) , (b + a) ]

     'arrayinfo' e 'listarray' aplicado a uma função de array.

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) arrayinfo (cc);
          (%o4)              [hashed, 2, [4, z], [u, v]]
          (%i5) listarray (cc);
                                        z  v
          (%o5)                        [-, -]
                                        4  u

     'arrayinfo' e 'listarray' aplicadas a funções com subscritos.

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) arrayinfo (dd);
          (%o4)             [hashed, 1, [b + a], [v - u]]
          (%i5) listarray (dd);
                                   b + a                v - u
          (%o5)      [lambda([y], y     ), lambda([y], y     )]

 -- Função: arraymake (<A>, [<i_1>, ..., <i_n>])
     Retorna a expressão '<A>[<i_1>, ..., <i_n>]'.  O resultado é uma
     referência a um array não avaliado.

     'arraymake' é remanicência de 'funmake', excepto o valor retornado
     é um array de referência não avaliado ao invés de uma chamada de
     função não avaliada.

     Exemplos:

          (%i1) arraymake (A, [1]);
          (%o1)                          A
                                          1
          (%i2) arraymake (A, [k]);
          (%o2)                          A
                                          k
          (%i3) arraymake (A, [i, j, 3]);
          (%o3)                       A
                                       i, j, 3
          (%i4) array (A, fixnum, 10);
          (%o4)                           A
          (%i5) fillarray (A, makelist (i^2, i, 1, 11));
          (%o5)                           A
          (%i6) arraymake (A, [5]);
          (%o6)                          A
                                          5
          (%i7) ''%;
          (%o7)                          36
          (%i8) L : [a, b, c, d, e];
          (%o8)                    [a, b, c, d, e]
          (%i9) arraymake ('L, [n]);
          (%o9)                          L
                                          n
          (%i10) ''%, n = 3;
          (%o10)                          c
          (%i11) A2 : make_array (fixnum, 10);
          (%o11)          {Array:  #(0 0 0 0 0 0 0 0 0 0)}
          (%i12) fillarray (A2, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o12)          {Array:  #(1 2 3 4 5 6 7 8 9 10)}
          (%i13) arraymake ('A2, [8]);
          (%o13)                         A2
                                           8
          (%i14) ''%;
          (%o14)                          9

 -- Variável de sistema: arrays
     Valor por omissão: '[]'

     'arrays' é uma lista dos arrays que tiverem sido alocados.  Essa
     lista compreende arrays declarados através de 'array', arrays
     desordenados (hashed) construídos através de definição implícita
     (atribuindo alguma coisa a um elemento de array), e funções de
     array definidas por meio de ':=' e 'define'.  Arrays definidos por
     meio de 'make_array' não estão incluídos.

     Veja também 'array', 'arrayapply', 'arrayinfo', 'arraymake',
     'fillarray', 'listarray', e 'rearray'.

     Exemplos:

          (%i1) array (aa, 5, 7);
          (%o1)                          aa
          (%i2) bb [FOO] : (a + b)^2;
                                             2
          (%o2)                       (b + a)
          (%i3) cc [x] := x/100;
                                             x
          (%o3)                      cc  := ---
                                       x    100
          (%i4) dd : make_array ('any, 7);
          (%o4)       {Array:  #(NIL NIL NIL NIL NIL NIL NIL)}
          (%i5) arrays;
          (%o5)                     [aa, bb, cc]

 -- Função: bashindices (<expr>)
     Transforma a expressão <expr> dando a cada somatório e a cada
     produto um único índice.  Isso dá a 'changevar' grande precisão
     quando se está trabalhando com somatórios e produtos.  A forma do
     único índice é 'j<number>'.  A quantidade <number> é determindad
     por referência a 'gensumnum', que pode ser alterada pelo
     utilizador.  Por exemplo, 'gensumnum:0$' reseta isso.

 -- Função: fillarray (<A>, <B>)
     Preenche o array <A> com <B>, que é uma lista ou um array.

     Se um tipo específico for declarado para <A> no momento de sua
     criação, <A> somente porde ser preenchido com elementos do tipo
     especificado; Constitui um erro alguma tentativa feita para copiar
     um um elemento de um tipo diferente.

     Se as dimensões dos arrays <A> e <B> forem diferents, <A> é
     preenchido no ordem de maior fileira.  Se não existirem elementos
     livres em <B> o último elemento é usado para preencher todo o resto
     de <A>.  Se existirem muitos , esses restantes seram ignorados.

     'fillarray' retorna esse primeiro argumento.

     Exemplos:

     Create an array of 9 elements and fill it from a list.

          (%i1) array (a1, fixnum, 8);
          (%o1)                          a1
          (%i2) listarray (a1);
          (%o2)              [0, 0, 0, 0, 0, 0, 0, 0, 0]
          (%i3) fillarray (a1, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
          (%o3)                          a1
          (%i4) listarray (a1);
          (%o4)              [1, 2, 3, 4, 5, 6, 7, 8, 9]

     Quando existirem poucos elementos para preencher o array, o último
     elemento é repetido.  Quando houverem muitos elementos, os
     elementos extras são ignorados.

          (%i1) a2 : make_array (fixnum, 8);
          (%o1)             {Array:  #(0 0 0 0 0 0 0 0)}
          (%i2) fillarray (a2, [1, 2, 3, 4, 5]);
          (%o2)             {Array:  #(1 2 3 4 5 5 5 5)}
          (%i3) fillarray (a2, [4]);
          (%o3)             {Array:  #(4 4 4 4 4 4 4 4)}
          (%i4) fillarray (a2, makelist (i, i, 1, 100));
          (%o4)             {Array:  #(1 2 3 4 5 6 7 8)}

     Arrays multi-dimensionais são preenchidos em ordem de maior
     fileira.

          (%i1) a3 : make_array (fixnum, 2, 5);
          (%o1)        {Array:  #2A((0 0 0 0 0) (0 0 0 0 0))}
          (%i2) fillarray (a3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o2)        {Array:  #2A((1 2 3 4 5) (6 7 8 9 10))}
          (%i3) a4 : make_array (fixnum, 5, 2);
          (%o3)     {Array:  #2A((0 0) (0 0) (0 0) (0 0) (0 0))}
          (%i4) fillarray (a4, a3);
          (%o4)     {Array:  #2A((1 2) (3 4) (5 6) (7 8) (9 10))}

 -- Função: listarray (<A>)
     Retorna uma lista dos elementos do array <A>.  O argumento <A> pode
     ser um array declarado, um array não declarado (desordenado -
     hashed), uma função de array, ou uma função com subscritos.

     Elementos são listados em ordem de linha maior.  Isto é, elementos
     são ordenados conforme o primeiro índice, en seguida conforme o
     segundo índice, e assim sucessivamente.  A sequuência de ordenação
     por meio dos valores dos índices é a mesma ordem estabelecida por
     meio de 'orderless'.

     Para arrays não declarados , funções de arrays, e funções com
     subscritos, os elementos correspondem aos valores de índice
     retornados através de 'arrayinfo'.

     Elemetos não associados de arrays genéricos declarados (isto é, não
     'fixnum' e não 'flonum') são retornados como '#####'.  Elementos
     não associados de arrays declarados 'fixnum' ou 'flonum' são
     retornados como 0 ou 0.0, respectivamente.  Elementos não
     associados de arrays não declarados, funções de array, e funções
     subscritas não são retornados.

     Exemplos:

     'listarray' e 'arrayinfo' aplicados a um array declarado.

          (%i1) array (aa, 2, 3);
          (%o1)                          aa
          (%i2) aa [2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa [1, 2] : %e;
          (%o3)                          %e
          (%i4) listarray (aa);
          (%o4) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]
          (%i5) arrayinfo (aa);
          (%o5)                 [declared, 2, [2, 3]]

     'listarray' e 'arrayinfo' aplicadas a arrays não declarados (hashed
     - desordenados).

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) listarray (bb);
                                        3         2
          (%o3)                 [(c - d) , (b + a) ]
          (%i4) arrayinfo (bb);
          (%o4)               [hashed, 1, [BAR], [FOO]]

     'listarray' e 'arrayinfo' aplicada a uma função de array.

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) listarray (cc);
                                        z  v
          (%o4)                        [-, -]
                                        4  u
          (%i5) arrayinfo (cc);
          (%o5)              [hashed, 2, [4, z], [u, v]]

     'listarray' e 'arrayinfo' aplicadas a funções com subscritos.

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) listarray (dd);
                                   b + a                v - u
          (%o4)      [lambda([y], y     ), lambda([y], y     )]
          (%i5) arrayinfo (dd);
          (%o5)             [hashed, 1, [b + a], [v - u]]

 -- Função: make_array (<type>, <dim_1>, ..., <dim_n>)
     Cria e retorna um array de Lisp.  <type> pode ser 'any', 'flonum',
     'fixnum', 'hashed' ou 'functional'.  Existem n indices, e o
     i'enésimo indice está no intervalo de 0 a <dim_i> - 1.

     A vantagem de 'make_array' sobre 'array' é que o valor de retorno
     não tem um nome, e uma vez que um ponteiro a ele vai, ele irá
     também.  Por exemplo, se 'y: make_array (...)' então 'y' aponta
     para um objecto que ocupa espaço, mas depois de 'y: false', 'y' não
     mais aponta para aquele objecto, então o objecto pode ser
     descartado.

     Exemplos:

          (%i1) A1 : make_array (fixnum, 10);
          (%o1)           {Array:  #(0 0 0 0 0 0 0 0 0 0)}
          (%i2) A1 [8] : 1729;
          (%o2)                         1729
          (%i3) A1;
          (%o3)          {Array:  #(0 0 0 0 0 0 0 0 1729 0)}
          (%i4) A2 : make_array (flonum, 10);
          (%o4) {Array:  #(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0)}
          (%i5) A2 [2] : 2.718281828;
          (%o5)                      2.718281828
          (%i6) A2;
          (%o6)
               {Array:  #(0.0 0.0 2.718281828 0.0 0.0 0.0 0.0 0.0 0.0 0.0)}
          (%i7) A3 : make_array (any, 10);
          (%o7) {Array:  #(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)}
          (%i8) A3 [4] : x - y - z;
          (%o8)                      - z - y + x
          (%i9) A3;
          (%o9) {Array:  #(NIL NIL NIL NIL ((MPLUS SIMP) $X ((MTIMES SIMP)\
           -1 $Y) ((MTIMES SIMP) -1 $Z))
            NIL NIL NIL NIL NIL)}
          (%i10) A4 : make_array (fixnum, 2, 3, 5);
          (%o10) {Array:  #3A(((0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0)) ((0 0 \
          0 0 0) (0 0 0 0 0) (0 0 0 0 0)))}
          (%i11) fillarray (A4, makelist (i, i, 1, 2*3*5));
          (%o11) {Array:  #3A(((1 2 3 4 5) (6 7 8 9 10) (11 12 13 14 15))
              ((16 17 18 19 20) (21 22 23 24 25) (26 27 28 29 30)))}
          (%i12) A4 [0, 2, 1];
          (%o12)                         12

 -- Função: rearray (<A>, <dim_1>, ..., <dim_n>)
     Altera as dimenções de um array.  O novo array será preenchido com
     os elementos do antigo em ordem da maior linha.  Se o array antigo
     era muito pequeno, os elementos restantes serão preenchidos com
     'false', '0.0' ou '0', dependendo do tipo do array.  O tipo do
     array não pode ser alterado.

 -- Função: remarray (<A_1>, ..., <A_n>)
 -- Função: remarray (all)
     Remove arrays e funções associadas a arrays e libera o espaço
     ocupado.  Os argumentos podem ser arrays declarados, arrays não
     declarados (dsordenados - hashed), funções de array functions, e
     funções com subscritos.

     'remarray (all)' remove todos os ítens na lista global 'arrays'.

     Isso pode ser necessário para usar essa função se isso é desejado
     para redefinir os valores em um array desordenado.

     'remarray' retorna a lista dos arrays removidos.

 -- Função: subvar (<x>, <i>)
     Avalia a expressão subscrita '<x>[<i>]'.

     'subvar' avalia seus argumentos.

     'arraymake (<x>, [<i>]' constrói a expressão '<x>[<i>]', mas não a
     avalia.

     Exemplos:

          (%i1) x : foo $
          (%i2) i : 3 $
          (%i3) subvar (x, i);
          (%o3)                         foo
                                           3
          (%i4) foo : [aa, bb, cc, dd, ee]$
          (%i5) subvar (x, i);
          (%o5)                          cc
          (%i6) arraymake (x, [i]);
          (%o6)                         foo
                                           3
          (%i7) ''%;
          (%o7)                          cc

 -- Variável de pção: use_fast_arrays
     - Se 'true' somente dois tipos de arrays são reconhecidos.

     1) O array art-q (t no Lisp Comum) que pode ter muitas dimensões
     indexadas por inteiros, e pode aceitar qualquer objecto do Lisp ou
     do Maxima como uma entrada.  Para construir assim um array, insira
     'a:make_array(any,3,4);' então 'a' terá como valor, um array com
     doze posições, e o índice é baseado em zero.

     2) O array Hash_table que é o tipo padrão de array criado se um faz
     'b[x+1]:y^2' (e 'b' não é ainda um array, uma lista, ou uma matriz
     - se isso ou um desses ocorrer um erro pode ser causado desde 'x+1'
     não poderá ser um subscrito válido para um array art-q, uma lista
     ou uma matriz).  Esses índices (também conhecidos como chaves)
     podem ser quaisquer objectos.  Isso somente pega uma chave por vez
     a cada vez ('b[x+1,u]:y' ignorará o 'u').  A referência termina em
     'b[x+1] ==> y^2'.  Certamente a chave poe ser uma lista , e.g.
     'b[[x+1,u]]:y' poderá ser válido.  Isso é incompatível com os
     arrays antigos do Maxima, mas poupa recursos.

     Uma vantagem de armazenar os arrays como valores de símbolos é que
     as convenções usuais sobre variáveis locais de uma função
     aplicam-se a arrays também.  O tipo Hash_table também usa menos
     recursos e é mais eficiente que o velho tipo hashar do Maxima.
     Para obter comportamento consistente em códigos traduzidos e
     compilados posicione 'translate_fast_arrays' para ser 'true'.

