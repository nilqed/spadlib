This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.


File: maxima.info,  Node: Grupos,  Next: Ambiente em Tempo de Execução,  Prev: Simetrias,  Up: Top

33 Grupos
*********

* Menu:

* Definições para Grupos::


File: maxima.info,  Node: Definições para Grupos,  Prev: Grupos,  Up: Grupos

33.1 Definições para Grupos
===========================

 -- Função: todd_coxeter (<relação>, <subgroupo>)
 -- Função: todd_coxeter (<relação>)

     Acha a ordem de G/H onde G é o módulo do Grupo Livre <relação>, e H
     é o subgroupo de G gerado por <subgroupo>.  <subgroupo> é um
     argumento opcional, cujo valor padrão é [].  Em fazendo isso a
     função produz uma tabela de multiplicação à direita de G sobre G/H,
     onde os co-conjuntos são enumerados [H,Hg2,Hg3,...].  Isso pode ser
     visto internamente no 'todd_coxeter_state'.

     Exemplo:

          (%i1) symet(n):=create_list(
                  if (j - i) = 1 then (p(i,j))^^3 else
                      if (not i = j) then (p(i,j))^^2 else
                          p(i,i) , j, 1, n-1, i, 1, j);
                                                                 <3>
          (%o1) symet(n) := create_list(if j - i = 1 then p(i, j)

                                          <2>
           else (if not i = j then p(i, j)    else p(i, i)), j, 1, n - 1,

          i, 1, j)
          (%i2) p(i,j) := concat(x,i).concat(x,j);
          (%o2)        p(i, j) := concat(x, i) . concat(x, j)
          (%i3) symet(5);
                   <2>           <3>    <2>           <2>           <3>
          (%o3) [x1   , (x1 . x2)   , x2   , (x1 . x3)   , (x2 . x3)   ,

                      <2>           <2>           <2>           <3>    <2>
                    x3   , (x1 . x4)   , (x2 . x4)   , (x3 . x4)   , x4   ]
          (%i4) todd_coxeter(%o3);

          Rows tried 426
          (%o4)                          120
          (%i5) todd_coxeter(%o3,[x1]);

          Rows tried 213
          (%o5)                          60
          (%i6) todd_coxeter(%o3,[x1,x2]);

          Rows tried 71
          (%o6)                          20


File: maxima.info,  Node: Ambiente em Tempo de Execução,  Next: Opções Diversas,  Prev: Grupos,  Up: Top

34 Ambiente em Tempo de Execução
********************************

* Menu:

* Introdução a Ambiente em Tempo de Execução::  
* Interrupções::                  
* Definições para Ambiente em Tempo de Execução::  


File: maxima.info,  Node: Introdução a Ambiente em Tempo de Execução,  Next: Interrupções,  Prev: Ambiente em Tempo de Execução,  Up: Ambiente em Tempo de Execução

34.1 Introdução a Ambiente em Tempo de Execução
===============================================

'maxima-init.mac' é um ficheiro que é chamado automaticamente quando o
Maxima inicia.  Pode usar 'maxima-init.mac' para personalizar o seu
ambiente no Maxima.  'maxima-init.mac', se existir, é tipicamente
colocado no directório chamado por 'maxima_userdir', embora possa estar
em qualquer outro directório procurado pela função 'file_search'.

Aqui está um exemplo do ficheiro 'maxima-init.mac':

     setup_autoload ("specfun.mac", ultraspherical, assoc_legendre_p);
     showtime:all;

Nesse Exemplo, 'setup_autoload' diz ao Maxima para chamar o ficheiro
especificado ('specfun.mac') se qualquer das funções ('ultraspherical',
'assoc_legendre_p') forem chamadas sem estarem definidas.  Dessa forma,
não precisa de se lembrar de chamar o ficheiro antes das funções.

A declaração 'showtime: all' diz ao Maxima para activar a opção
'showtime'.  O ficheiro 'maxima-init.mac' pode conter quaisquer outras
atribuições ou outras declarações do Maxima.


File: maxima.info,  Node: Interrupções,  Next: Definições para Ambiente em Tempo de Execução,  Prev: Introdução a Ambiente em Tempo de Execução,  Up: Ambiente em Tempo de Execução

34.2 Interrupções
=================

O utilizador pode parar uma computação que consome muito tempo com o
caractere ^C (control-C). A ação padrão é parar a computação e mostrar
outra linha de comando do utilizador.  Nesse caso, não é possível
continuar a computação interrompida.

Se a variável '*debugger-hook*' é escolhida para 'nil', através do
comando

     :lisp (setq *debugger-hook* nil)

então na ocasião do recebimento do ^C, Maxima iniciará o depurador Lisp,
e o utilizador pode usar o depurador para inspecionar o ambiente Lisp.
A computação interrompida pode ser retomada através do comando
'continue' no depurador Lisp.  O método de retorno para ao Maxima
partindo do depurador Lisp (outro como executando a computação para
complementação) é diferente para cada versão do Lisp.

Em sistemas Unix, o caratere ^Z (control-Z) faz com que Maxima pare tudo
e aguarde em segundo plano, e o controle é retornado para a linha de
comando do shell.  O comando 'fg' faz com que o Maxima retorne ao
primeiro plano e continue a partir do ponto no qual foi interrompido.


File: maxima.info,  Node: Definições para Ambiente em Tempo de Execução,  Prev: Interrupções,  Up: Ambiente em Tempo de Execução

34.3 Definições para Ambiente em Tempo de Execução
==================================================

 -- Declaração: feature
     Maxima compreende dois tipos distintos de recurso, recursos do
     sistema e recursos aplicados a expressões matemáticas.  Veja Também
     'status' para informações sobre recursos do sistema.  Veja Também
     'features' e 'featurep' para informações sobre recursos
     matemáticos.

     'feature' por si mesmo não é o nome de uma função ou variável.

 -- Função: featurep (<a>, <f>)
     Tenta determinar se o objecto <a> tem o recurso <f> na base dos
     factos dentro base de dados corrente.  Se possue, é retornado
     'true', de outra forma é retornado 'false'.

     Note que 'featurep' retorna 'false' quando nem <f> nem a negação de
     <f> puderem ser estabelecidas.

     'featurep' avalia seus argumentos.

     Veja também 'declare' e 'features'.

          (%i1) declare (j, even)$
          (%i2) featurep (j, integer);
          (%o2)                           true

 -- Variável de sistema: maxima_tempdir

     'maxima_tempdir' nomeia o directório no qual Maxima cria alguns
     ficheiros temporários.  Em particular, ficheiros temporários para
     impressão são criados no 'maxima_tempdir'.

     O valor inicial de 'maxima_tempdir' é o directório do utilizador,
     se o maxima puder localizá-lo; de outra forma Maxima supõe um
     directório adequado.

     A 'maxima_tempdir' pode ser atribuído uma sequência de caracteres
     que corresponde a um directório.

 -- Variável de sistema: maxima_userdir

     'maxima_userdir' nomeia um directório no qual Maxima espera
     encontrar seus próprios ficheiros e os do ficheiros do Lisp.
     (Maxima procura em alguns outros directórios também;
     'file_search_maxima' e 'file_search_lisp' possuem a lista
     completa.)

     O valor inicial de 'maxima_userdir' é um subdirectório do
     directório do utilizador, se Maxima puder localizá-lo; de outra
     forma Maxima supõe um directório adequado.

     A 'maxima_userdir' pode ser atribuído uma sequência de caracteres
     que corresponde a um directório.  Todavia, fazendo uma atribuição a
     'maxima_userdir' não muda automaticamente o valor de
     'file_search_maxima' e de 'file_search_lisp'; Essas variáveis devem
     ser modificadas separadamente.

 -- Função: room ()
 -- Função: room (true)
 -- Função: room (false)
     Mostra uma descrição do estado de armazenamento e gerenciamento de
     pilha no Maxima.  'room' chama a função Lisp de mesmo nome.

        * 'room ()' mostra uma descrição moderada.
        * 'room (true)' mostra uma descrição detalhada.
        * 'room (false)' mostra uma descrição resumida.

 -- Função: status (feature)
 -- Função: status (feature, <recurso_ativo>)
 -- Função: status (status)
     Retorna informações sobre a presença ou ausência de certos recursos
     dependentes do sistema operacional.

        * 'status (feature)' retorna uma lista dos recursos do sistema.
          Inclui a versão do Lisp, tipo de sistema operacional, etc.  A
          lista pode variar de um tipo de Lisp para outro.
        * 'status (feature, <recurso_ativo>)' retorna 'true' se
          <recurso_ativo> está na lista de ítens retornada através de
          'status (feature)' e 'false' de outra forma.  'status' não
          avalia o argumento <recurso_ativo>.  O operador
          apóstrofo-apóstrofo, '''', evita a avaliação.  Um recurso cujo
          nome contém um caractere especial, tal como um hífem, deve ser
          fornecido como um argumento em forma de sequência de
          caracteres.  Por Exemplo, 'status (feature, "ansi-cl")'.
        * 'status (status)' retorna uma lista de dois elementos
          '[feature, status]'.  'feature' e 'status' são dois argumentos
          aceitos pela função 'status'; Não está claro se essa lista tem
          significância adicional.

     A variável 'features' contém uma lista de recursos que se aplicam a
     expressões matemáticas.  Veja 'features' e 'featurep' para maiores
     informações.

 -- Função: time (%o1, %o2, %o3, ...)
     Retorna uma lista de tempos, em segundos, usados para calcular as
     linhas de saída '%o1', '%o2', '%o3', ....  O tempo retornado é uma
     estimativa do Maxima do tempo interno de computação, não do tempo
     decorrido.  'time' pode somente ser aplicado a variáveis(rótulos)
     de saída de linha; para quaisquer outras variáveis, 'time' retorna
     'unknown' (tempo desconhecido).

     Escolha 'showtime: true' para fazer com que Maxima moste o tempo de
     computação e o tempo decorrido a cada linha de saída.

 -- Função: timedate ()
     Retorna uma sequência de caracteres representando a data e hora
     atuais.  A sequência de caracteres tem o formato 'HH:MM:SS Dia,
     mm/dd/aaaa (GMT-n)', Onde os campos são horas, minutos, segundos,
     dia da semana, mês, dia do mês, ano, e horas que diferem da hora
     GMT.

     O valor de retorno é uma sequência de caracteres Lisp.

     Exemplo:

          (%i1) d: timedate ();
          (%o1) 08:05:09 Wed, 11/02/2005 (GMT-7)
          (%i2) print ("timedate mostra o tempo actual", d)$
          timedate reports current time 08:05:09 Wed, 11/02/2005 (GMT-7)


File: maxima.info,  Node: Opções Diversas,  Next: Regras e Modelos,  Prev: Ambiente em Tempo de Execução,  Up: Top

35 Opções Diversas
******************

* Menu:

* Introdução a Opções Diversas::  
* Compartilhado::                       
* Definições para Opções Diversas::  


File: maxima.info,  Node: Introdução a Opções Diversas,  Next: Compartilhado,  Prev: Opções Diversas,  Up: Opções Diversas

35.1 Introdução a Opções Diversas
=================================

Nessa secção várias opções são tratadas pelo facto de possuirem um
efeito global sobre a operação do Maxima.  Também várias listas tais
como a lista de todas as funções definidas pelo utilizador, são
discutidas.


File: maxima.info,  Node: Compartilhado,  Next: Definições para Opções Diversas,  Prev: Introdução a Opções Diversas,  Up: Opções Diversas

35.2 Compartilhado
==================

O directório "share" do Maxima contém programas e outros ficheiros de
interesse para os utilizadors do Maxima, mas que não são parte da
implementação do núcleo do Maxima.  Esses programas são tipicamente
chamados via 'load' ou 'setup_autoload'.

':lisp *maxima-sharedir*' mostra a localização do directório
compartilhado dentro do sistema de ficheiros do utilizador.

'printfile ("share.usg")' imprime uma lista de pacotes desactualizados
dos pacotes compartilhados.  Usuários podem encontrar isso de forma mais
detalhada navegando no directório compartilhado usando um navegador de
sistema de ficheiro.


File: maxima.info,  Node: Definições para Opções Diversas,  Prev: Compartilhado,  Up: Opções Diversas

35.3 Definições para Opções Diversas
====================================

 -- Variável de sistema: aliases
     Valor por omissão: '[]'

     'aliases' é a lista de átomos que possuem um alias definido pelo
     utilizador (escolhido através das funções 'alias', 'ordergreat',
     'orderless' ou através da declaração do átomo como sendo um 'noun'
     (substantivo) com 'declare').

 -- Declaração: alphabetic
     'alphabetic' é uma declaração reconhecida por 'declare'.  A
     expressão 'declare(<s>, alphabetic)' diz ao Maxima para reconhecer
     como alfabético todos os caracteres em <s>, que deve ser uma
     sequência de caracteres.

     Veja também _Identificadores_.

     Exemplo:

          (%i1) xx\~yy\`\@ : 1729;
          (%o1)                         1729
          (%i2) declare ("~`@", alphabetic);
          (%o2)                         done
          (%i3) xx~yy`@ + @yy`xx + `xx@@yy~;
          (%o3)               `xx@@yy~ + @yy`xx + 1729
          (%i4) listofvars (%);
          (%o4)                  [@yy`xx, `xx@@yy~]

 -- Função: apropos (<string>)
     Procura por nomes Maxima que possuem <string> aparecendo em
     qualquer lugar dentro de seu nome.  Dessa forma, 'apropos (exp)'
     retorna uma lista de todos os sinalizadores e funções que possuem
     'exp' como parte de seus nomes, tais como 'expand', 'exp', e
     'exponentialize'.  Dessa forma, se lembrar apenas uma parte do nome
     de alguma coisa, pode usar este comando para achar o restante do
     nome.  Similarmente, pode dizer 'apropos (tr_)' para achar uma
     lista de muitos dos comutadores relatando para o tradutor, muitos
     dos quais começam com 'tr_'.

 -- Função: args (<expr>)
     Retorna a lista de argumentos de 'expr', que pode ser de qualquer
     tipo de expressão outra como um átomo.  Somente os argumentos do
     operador de nível mais alto são extraídos; subexpressões de 'expr'
     aparecem como elementos ou subexpressões de elementos da lista de
     argumentos.

     A ordem dos ítens na lista pode depender do sinalizador global
     'inflag'.

     'args (<expr>)' é equivalente a 'substpart ("[", <expr>, 0)'.  Veja
     também 'substpart'.

     Veja também 'op'.

 -- Variável de opção: genindex
     Valor por omissão: 'i'

     'genindex' é o prefixo usado para gerar a próxima variável do
     somatório quando necessário.

 -- Variável de opção: gensumnum
     Valor por omissão: 0

     'gensumnum' é o sufixo numérico usado para gerar variável seguinte
     do somatório.  Se isso for escolhido para 'false' então o índice
     consistirá somente de 'genindex' com um sufixo numérico.

 -- Constante: inf
     Infinito positivo real.

 -- Constante: infinity
     Infinito complexo, uma magnitude infinita de ângulo de fase
     arbitrária.  Veja também 'inf' e 'minf'.

 -- Variável de sistema: infolists
     Valor por omissão: '[]'

     'infolists' é uma lista dos nomes de todas as listas de informação
     no Maxima.  São elas:

     'labels'
          Todos associam '%i', '%o', e rótulos '%t'.
     'values'
          Todos associam átomos que são variáveis de utilizador, não
          opções do Maxima ou comutadores, criados através de ':' ou
          '::' ou associando funcionalmente.

     'functions'
          Todas as funções definidas pelo utilizador, criadas através de
          ':=' ou 'define'.

     'arrays'
          Todos os arrays declarados e não declarados, criados através
          de ':', '::', ou ':='.
     'macros'
          Todas as macros definidas pelo utilizador.

     'myoptions'
          Todas as opções alguma vez alteradas pelo utilizador (mesmo
          que tenham ou não elas tenham mais tarde retornadas para seus
          valores padrão).

     'rules'
          Todos os modelos definidos pelo utilizador que coincidirem e
          regras de simplificação, criadas através de 'tellsimp',
          'tellsimpafter', 'defmatch', ou 'defrule'.

     'aliases'
          Todos os átomos que possuem um alias definido pelo utilizador,
          criado através das funções 'alias', 'ordergreat', 'orderless'
          ou declarando os átomos como um 'noun' com 'declare'.

     'dependencies'
          Todos os átomos que possuem dependências funcionais, criadas
          através das funções 'depends' ou 'gradef'.

     'gradefs'
          Todas as funções que possuem derivadas definidas pelo
          utilizador, cridas através da função 'gradef'.

     'props'
          Todos os átomos que possuem quaisquer propriedades outras que
          não essas mencionadas acima, tais como propriedades
          estabelecidas por 'atvalue' , 'matchdeclare', etc., também
          propriedades estabelecidas na função 'declare'.

     'let_rule_packages'
          Todos os pacote de régras em uso definidos pelo utilizador
          mais o pacote especial 'default_let_rule_package'.
          ('default_let_rule_package' é o nome do pacote de régras usado
          quando um não está explicitamente escolhido pelo utilizador.)

 -- Função: integerp (<expr>)
     Retorna 'true' se <expr> é um inteiro numérico literal, de outra
     forma retorna 'false'.

     'integerp' retorna falso se seu argumento for um símbolo, mesmo se
     o argumento for declarado inteiro.

     Exemplos:

          (%i1) integerp (0);
          (%o1)                         true
          (%i2) integerp (1);
          (%o2)                         true
          (%i3) integerp (-17);
          (%o3)                         true
          (%i4) integerp (0.0);
          (%o4)                         false
          (%i5) integerp (1.0);
          (%o5)                         false
          (%i6) integerp (%pi);
          (%o6)                         false
          (%i7) integerp (n);
          (%o7)                         false
          (%i8) declare (n, integer);
          (%o8)                         done
          (%i9) integerp (n);
          (%o9)                         false

 -- Variável de opção: m1pbranch
     Valor por omissão: 'false'

     'm1pbranch' é principal descendente de '-1' a um expoente.
     Quantidades tais como '(-1)^(1/3)' (isto é, um expoente racional
     "ímpar") e '(-1)^(1/4)' (isto é, um expoente racional "par") são
     manuseados como segue:

                        domain:real

          (-1)^(1/3):      -1
          (-1)^(1/4):   (-1)^(1/4)

                       domain:complex
          m1pbranch:false          m1pbranch:true
          (-1)^(1/3)               1/2+%i*sqrt(3)/2
          (-1)^(1/4)              sqrt(2)/2+%i*sqrt(2)/2

 -- Função: numberp (<expr>)
     Retorna 'true' se <expr> for um inteiro literal, número racional,
     número em ponto flutuante, ou um grande número em ponto flutuante,
     de outra forma retorna 'false'.

     'numberp' retorna falso se seu argumento for um símbolo, mesmo se o
     argumento for um número simbólico tal como '%pi' ou '%i', ou
     declarado ser par, ímpar, inteiro, racional, irracional, real,
     imaginário, ou complexo.

     Exemplos:

          (%i1) numberp (42);
          (%o1)                         true
          (%i2) numberp (-13/19);
          (%o2)                         true
          (%i3) numberp (3.14159);
          (%o3)                         true
          (%i4) numberp (-1729b-4);
          (%o4)                         true
          (%i5) map (numberp, [%e, %pi, %i, %phi, inf, minf]);
          (%o5)      [false, false, false, false, false, false]
          (%i6) declare (a, even, b, odd, c, integer, d, rational,
               e, irrational, f, real, g, imaginary, h, complex);
          (%o6)                         done
          (%i7) map (numberp, [a, b, c, d, e, f, g, h]);
          (%o7) [false, false, false, false, false, false, false, false]

 -- Função: properties (<a>)
     Retorna uma lista de nomes de todas as propriedades associadas com
     o átomo <a>.

 -- Símbolo especial: props
     'props' são átomos que possuem qualquer propriedade outra como
     essas explicitamente mencionadas em 'infolists', tais como
     atvalues, matchdeclares, etc., também propriedades especificadas na
     função 'declare'.

 -- Função: propvars (<prop>)
     Retorna uma lista desses átomos sobre a lista 'props' que possui a
     propriedade indicada através de <prop>.  Dessa forma 'propvars
     (atvalue)' retorna uma lista de átomos que possuem atvalues.

 -- Função: put (<átomo>, <valor>, <indicador>)
     Atribui <valor> para a propriedade (especificada através de
     <indicador>) do <átomo>.  <indicador> pode ser o nome de qualquer
     propriedade, não apenas uma propriedade definida pelo sistema.

     'put' avalia seus argumentos.  'put' retorna <valor>.

     Exemplos:

          (%i1) put (foo, (a+b)^5, expr);
                                             5
          (%o1)                       (b + a)
          (%i2) put (foo, "Hello", str);
          (%o2)                         Hello
          (%i3) properties (foo);
          (%o3)            [[user properties, str, expr]]
          (%i4) get (foo, expr);
                                             5
          (%o4)                       (b + a)
          (%i5) get (foo, str);
          (%o5)                         Hello

 -- Função: qput (<átomo>, <valor>, <indicador>)
     Atribui <valor> para a propriedade (especificada através de
     <indicador>) do <átomo>.  Isso é o mesmo que 'put', excepto que os
     argumentos nã são avaliados.

     Exemplo:

          (%i1) foo: aa$
          (%i2) bar: bb$
          (%i3) baz: cc$
          (%i4) put (foo, bar, baz);
          (%o4)                          bb
          (%i5) properties (aa);
          (%o5)                [[user properties, cc]]
          (%i6) get (aa, cc);
          (%o6)                          bb
          (%i7) qput (foo, bar, baz);
          (%o7)                          bar
          (%i8) properties (foo);
          (%o8)            [value, [user properties, baz]]
          (%i9) get ('foo, 'baz);
          (%o9)                          bar

 -- Função: rem (<átomo>, <indicador>)
     Remove a propriedade indicada através de <indicador> do <átomo>.

 -- Função: remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)
 -- Função: remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)
 -- Função: remove ("<a>", operator)
 -- Função: remove (<a>, transfun)
 -- Função: remove (all, <p>)
     Remove propriedades associadas a átomos.

     'remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)' remove a propriedade
     'p_k' do átomo 'a_k'.

     'remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)' remove as
     propriedades '<p_1>, ..., <p_n>' dos átomos <a_1>, ..., <a_m>.
     Pode existir mais que um par de listas.

     'remove (all, <p>)' remove a propriedade <p> de todos os átomos que
     a possuem.

     A propriedade removida pode ser definida pelo sistema tal como
     'function', 'macro' ou 'mode_declare', ou propriedades definidas
     pelo utilizador.

     uma propriedade pode ser 'transfun' para remover a versão traduzida
     Lisp de uma função.  Após executar isso, a versão Maxima da função
     é executada em lugar da versão traduzida.

     'remove ("<a>", operator)' ou, equivalentemente, 'remove ("<a>",
     op)' remove de <a> as propriedades 'operator' declaradas através de
     'prefix', 'infix', 'nary', 'postfix', 'matchfix', ou 'nofix'.  Note
     que o nome do operador deve ser escrito como uma sequência de
     caracteres com apóstofo.

     'remove' sempre retorna 'done' se um átomo possui ou não uma
     propriedade especificada.  Esse comportamento é diferente das
     funções remove mais específicas 'remvalue', 'remarray',
     'remfunction', e 'remrule'.

 -- Função: remvalue (<nome_1>, ..., <nome_n>)
 -- Função: remvalue (all)
     Remove os valores de Variáveis de utilizador <nome_1>, ...,
     <nome_n> (que podem ser subscritas) do sistema.

     'remvalue (all)' remove os valores de todas as variáveis em
     'values', a lista de todas as variáveis nomeadas através do
     utilizador (em oposição a essas que são automaticamente atribuídas
     através do Maxima).

     Veja também 'values'.

 -- Função: rncombine (<expr>)
     Transforma <expr> combinando todos os termos de <expr> que possuem
     denominadores idênticos ou denominadores que diferem de cada um dos
     outros apenas por factores numéricos somente.  Isso é ligeiramente
     diferente do comportamento de de 'combine', que colecta termos que
     possuem denominadores idênticos.

     Escolhendo 'pfeformat: true' e usando 'combine' retorna resultados
     similares a esses que podem ser obtidos com 'rncombine', mas
     'rncombine' pega o passo adicional de multiplicar cruzado factores
     numérios do denominador.  Esses resultados em forma ideal, e a
     possibilidade de reconhecer alguns cancelamentos.

     Para usar essa função escreva primeiramente 'load(rncomb)'.

 -- Função: scalarp (<expr>)
     Retorna 'true' se <expr> for um número, constante, ou variável
     declarada 'scalar' com 'declare', ou composta inteiramente de
     números, constantes, e tais Variáveis, bmas não contendo matrizes
     ou listas.

 -- Função: setup_autoload (<nomeficheiro>, <função_1>, ..., <função_n>)
     Especifica que se qualquer entre <função_1>, ..., <função_n> for
     referenciado e não ainda definido, <nomedeqrquivo> é chamado via
     'load'.  <nomeficheiro> usualmente contém definições para as
     funções especificadas, embora isso não seja obrigatório.

     'setup_autoload' não trabalha para funções array.

     'setup_autoload' não avalia seus argumentos.

     Exemplo:

          (%i1) legendre_p (1, %pi);
          (%o1)                  legendre_p(1, %pi)
          (%i2) setup_autoload ("specfun.mac", legendre_p, ultraspherical);
          (%o2)                         done
          (%i3) ultraspherical (2, 1/2, %pi);
          Warning - you are redefining the Macsyma função ultraspherical
          Warning - you are redefining the Macsyma função legendre_p
                                      2
                           3 (%pi - 1)
          (%o3)            ------------ + 3 (%pi - 1) + 1
                                2
          (%i4) legendre_p (1, %pi);
          (%o4)                          %pi
          (%i5) legendre_q (1, %pi);
                                        %pi + 1
                                %pi log(-------)
                                        1 - %pi
          (%o5)                 ---------------- - 1
                                       2


File: maxima.info,  Node: Regras e Modelos,  Next: Listas,  Prev: Opções Diversas,  Up: Top

36 Regras e Modelos
*******************

* Menu:

* Introdução a Regras e Modelos::  
* Definições para Regras e Modelos::  


File: maxima.info,  Node: Introdução a Regras e Modelos,  Next: Definições para Regras e Modelos,  Prev: Regras e Modelos,  Up: Regras e Modelos

36.1 Introdução a Regras e Modelos
==================================

Essa secção descreve coincidências de modelos definidos pelo utilizador
e regras de simplificação.  Existem dois grupos de funções que
implementam até certo ponto diferentes esquemas de coincidência de
modelo.  Em um grupo estão 'tellsimp', 'tellsimpafter', 'defmatch',
'defrule', 'apply1', 'applyb1', e 'apply2'.  Em outro grupo estão 'let'
e 'letsimp'.  Ambos os esquemas definem modelos em termos de variáveis
de modelo declaradas por 'matchdeclare'.

Regras de coincidência de modelos definidas por 'tellsimp' e
'tellsimpafter' são aplicadas automaticamente através do simplificador
do Maxima.  Regras definidas através de 'defmatch', 'defrule', e 'let'
são aplicadas através de uma chamada explícita de função.

Existe mecanismos adicionais para regras aplicadas a polinómios através
de 'tellrat', e para álgebra comutativa e não comutativa no pacote
'affine'.


File: maxima.info,  Node: Definições para Regras e Modelos,  Prev: Introdução a Regras e Modelos,  Up: Regras e Modelos

36.2 Definições para Regras e Modelos
=====================================

 -- Função: apply1 (<expr>, <rule_1>, ..., <rule_n>)
     Repetidamente aplica <rule_1> a <expr> até que isso falhe, então
     repetidamente aplica a mesma regra a todas as subexpressões de
     <expr>, da esquerda para a direita, até que <rule_1> tenha falhado
     sobre todas as subexpressões.  Chama o resultado da transformação
     de <expr> dessa maneira de <expr_2>.  Então <rule_2> é aplicada no
     mesmo estilo iniciando no topo de <expr_2>.  Quando <rule_n> falhar
     na subexpressão final, o resultado é retornado.

     'maxapplydepth' é a intensidade de nível mais distante de
     subexpressões processadas por 'apply1' e 'apply2'.

     Veja também 'applyb1', 'apply2', e 'let'.

 -- Função: apply2 (<expr>, <rule_1>, ..., <rule_n>)
     Se <rule_1> falhar sobre uma dada subexpressão, então <rule_2> é
     repetidamente aplicada, etc.  Somente se todas as regras falharem
     sobre uma dada subexpressão é que o conjunto completo de regras é
     repetidamente aplicada à próxima subexpressão.  Se uma das regras
     obtém sucesso, então a mesma subexpressão é reprocessada, iniciando
     com a primeira regra.

     'maxapplydepth' é a intensidade do nível mais distante de
     subexpressões processadas através de 'apply1' e 'apply2'.

     Veja também 'apply1' e 'let'.

 -- Função: applyb1 (<expr>, <rule_1>, ..., <rule_n>)
     Repetidamente aplica <rule_1> para a subexpressão mais distante de
     <expr> até falhar, então repetidamente aplica a mesma regra um
     nível mais acima (i.e., subexpressãos mais larga), até que <rule_1>
     tenha falhado sobre a expressão de nível mais alto.  Então <rule_2>
     é aplicada com o mesmo estilo para o resultado de <rule_1>.  após
     <rule_n> ter sido aplicada à expressão de nível mais elevado, o
     resultado é retornado.

     'applyb1' é similar a 'apply1' mas trabalha da base para cima em
     lugar de do topo para baixo.

     'maxapplyheight' é o ápice que 'applyb1' encontra antes de
     interromper.

     Veja também 'apply1', 'apply2', e 'let'.

 -- Variável de opção: current_let_rule_package
     Valor por omissão: 'default_let_rule_package'

     'current_let_rule_package' é o nome do pacote de regras que está
     sendo usado por funções no pacote 'let' ('letsimp', etc.)  se
     nenhum outro pacote de regras for especificado.  A essa variável
     pode ser atribuído o nome de qualquer pacote de regras definido via
     comando 'let'.

     Se uma chamada tal como 'letsimp (expr, nome_pct_regras)' for
     feita, o pacote de regras 'nome_pct_regras' é usado para aquela
     chamada de função somente, e o valor de 'current_let_rule_package'
     não é alterado.

 -- Variável de opção: default_let_rule_package
     Valor por omissão: 'default_let_rule_package'

     'default_let_rule_package' é o nome do pacote de regras usado
     quando um não for explicitamente escolhido pelo utilizador com
     'let' ou através de alteração do valor de
     'current_let_rule_package'.

 -- Função: defmatch (<prognome>, <modelo>, <x_1>, ..., <x_n>)
 -- Função: defmatch (<prognome>, <modelo>)
     Define uma função '<prognome>(<expr>, <x_1>, ..., <x_n>)' que testa
     <expr> para ver se essa expressão coincide com <modelo>.

     <modelo> é uma expressão contendo os argumentos modelo <x_1>, ...,
     <x_n> (se existir algum) e alguns modelos de variáveis (se existir
     algum).  os argumentos modelo são fornecidos explicitamente como
     argumentos para 'defmatch' enquanto os modelos de variáveis são
     declarados através da função 'matchdeclare'.  Qualquer variável não
     declarada como modelo em 'matchdeclare' ou como um argumento modelo
     em 'defmatch' coincide somente com si mesma.

     O primeiro argumento para a função criada <prognome> é uma
     expressão a serem comparadas contra o modelo e os outros argumentos
     são os atuais argumetnos que correspondem às variáveis respectivas
     <x_1>, ..., <x_n> no modelo.

     Se a tentativa de coincidência obtiver sucesso, <prognome> retorna
     uma lista de equações cujos lados esquerdos são os argumetnos de
     modelo e variáveis de modelo, e cujo lado direito forem as
     subexpressões cujos argumentos de modelo e as variáveis coincidem.
     Os modelos de variáveis, mas não tos argumentos de modelo, são
     atribuídos às subexpressões que coincidirem.  Se a coincidência
     falhar, <prognome> retorna 'false'.

     Um modelo literal (isto é, um modelo que não contiver nem
     argumentos de modelo nem variáveis de modelo) retorna 'true' se a
     coincidência ocorrer.

     Veja também 'matchdeclare', 'defrule', 'tellsimp', e
     'tellsimpafter'.

     Exemplos:

     Define uma função 'linearp(expr, x)' que testa 'expr' para ver se
     essa expressão da forma 'a*x + b' tal que 'a' e 'b' não contenham
     'x' e 'a' seja não nulo.  Essa função de coincidência coincide com
     expressões que sejam lineares em qualquer variável, por que o
     argumento de modelo 'x' é fornecido para 'defmatch'.

          (%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b, freeof(x));
          (%o1)                         done
          (%i2) defmatch (linearp, a*x + b, x);
          (%o2)                        linearp
          (%i3) linearp (3*z + (y + 1)*z + y^2, z);
                                   2
          (%o3)              [b = y , a = y + 4, x = z]
          (%i4) a;
          (%o4)                         y + 4
          (%i5) b;
                                          2
          (%o5)                          y
          (%i6) x;
          (%o6)                           x

     Define uma função 'linearp(expr)' que testa 'expr' para ver se essa
     expressão é da forma 'a*x + b' tal que 'a' e 'b' não contenham 'x'
     e 'a' seja não nulo.  Essa função de coincidência somente coincide
     com expressões lineares em 'x', não em qualquer outra variável,
     porque nenhum argumento de modelo é fornecido a 'defmatch'.

          (%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b, freeof(x));
          (%o1)                         done
          (%i2) defmatch (linearp, a*x + b);
          (%o2)                        linearp
          (%i3) linearp (3*z + (y + 1)*z + y^2);
          (%o3)                         false
          (%i4) linearp (3*x + (y + 1)*x + y^2);
                                       2
          (%o4)                  [b = y , a = y + 4]

     Define uma função 'checklimits(expr)' que testa 'expr' para ver se
     essa expressão é uma integral definida.

          (%i1) matchdeclare ([a, f], true);
          (%o1)                         done
          (%i2) constinterval (l, h) := constantp (h - l);
          (%o2)        constinterval(l, h) := constantp(h - l)
          (%i3) matchdeclare (b, constinterval (a));
          (%o3)                         done
          (%i4) matchdeclare (x, atom);
          (%o4)                         done
          (%i5) simp : false;
          (%o5)                         false
          (%i6) defmatch (checklimits, 'integrate (f, x, a, b));
          (%o6)                      checklimits
          (%i7) simp : true;
          (%o7)                         true
          (%i8) 'integrate (sin(t), t, %pi + x, 2*%pi + x);
                                 x + 2 %pi
                                /
                                [
          (%o8)                 I          sin(t) dt
                                ]
                                /
                                 x + %pi
          (%i9) checklimits (%);
          (%o9)    [b = x + 2 %pi, a = x + %pi, x = t, f = sin(t)]

 -- Função: defrule (<nomeregra>, <modelo>, <substituição>)
     Define e nomeia uma regra de substituição para o modelo dado.  Se a
     regra nomeada <nomeregra> for aplicada a uma expressão (através de
     'apply1', 'applyb1', ou 'apply2'), toda subexpressão coincidindo
     com o modelo será substituída por 'substituição'.  Todas as
     variáveis em 'substituição' que tiverem sido atribuidos valores
     pela coincidência com o modelo são atribuidas esses valores na
     'substituição' que é então simplificado.

     As regras por si mesmas podem ser tratadas como funções que
     transforma uma expressão através de uma operação de coincidência de
     modelo e substituição.  Se a coincidência falhar, a função da regra
     retorna 'false'.

 -- Função: disprule (<nomeregra_1>, ..., <nomeregra_2>)
 -- Função: disprule (all)
     Mostra regras com os nomes <nomeregra_1>, ..., <nomeregra_n>, como
     retornado por 'defrule', 'tellsimp', ou 'tellsimpafter', ou um
     modelo definido por meio de 'defmatch'.

     Cada regra é mostrada com um rótulo de expressão intermédia ('%t').

     'disprule (all)' mostra todas as regras.

     'disprule' não avalia seus argumentos.

     'disprule' retorna a lista de rótulos de expressões intermedáirias
     correspondendo às regras mostradas.

     Veja também 'letrules', que mostra regras definidas através de
     'let'.

     Examples:

          (%i1) tellsimpafter (foo (x, y), bar (x) + baz (y));
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (x + y, special_add (x, y));
          (%o2)                   [+rule1, simplus]
          (%i3) defmatch (quux, mumble (x));
          (%o3)                         quux
          (%i4) disprule (foorule1, "+rule1", quux);
          (%t4)        foorule1 : foo(x, y) -> baz(y) + bar(x)

          (%t5)          +rule1 : y + x -> special_add(x, y)

          (%t6)                quux : mumble(x) -> []

          (%o6)                    [%t4, %t5, %t6]
          (%i6) ''%;
          (%o6) [foorule1 : foo(x, y) -> baz(y) + bar(x),
          +rule1 : y + x -> special_add(x, y), quux : mumble(x) -> []]

 -- Função: let (<prod>, <repl>, <prednome>, <arg_1>, ..., <arg_n>)
 -- Função: let ([<prod>, <repl>, <prednome>, <arg_1>, ..., <arg_n>],
          <nome_pacote>)
     Define uma regra de substituição para 'letsimp' tal que <prod> é
     substituído por <repl>.  <prod> é um produto de expoentes positivos
     ou negativos dos seguintes termos:

        * Atomos que 'letsimp' irá procurar literalmente a menos que
          previamente chamando 'letsimp' a função 'matchdeclare' é usada
          para associar um predicado com o átomo.  Nesse caso 'letsimp'
          irá coincidir com o átomo para qualquer termo de um produto
          satisfazendo o predicado.
        * Núcleos tais como 'sin(x)', 'n!', 'f(x,y)', etc.  Como com
          átomos acima 'letsimp' irá olhar um literal coincidente a
          menos que 'matchdeclare' seja usada para associar um predicado
          com o argumento do núcleo.

     Um termo para um expoente positivo irá somente coincidir com um
     termo tendo ao menos aquele expoente.  Um termo para um expoente
     negativo por outro lado irá somente coincidir com um termo com um
     expoente ao menos já negativo.  o caso de expentes negativos em
     <prod> o comutador 'letrat' deve ser escolhido para 'true'.  Veja
     também 'letrat'.

     Se um predicado for incluído na função 'let' seguido por uma lista
     de argumentos, uma tentativa de coincidência (i.e.  uma que pode
     ser aceita se o predicado fosse omitido) é aceita somente se
     'prednome (arg_1', ..., arg_n')' avaliar para 'true' onde <arg_i'>
     é o valor coincidente com <arg_i>.  O <arg_i> pode ser o nome de
     qualquer átomo ou o argumento de qualquer núcleo aparecendo em
     <prod>.  <repl> pode ser qualquer expressão racional.  Se quaisquer
     dos átomos ou argumentos de <prod> aparecer em <repl> a
     substituição é feita.

     O sinalizador global 'letrat' controla a simplificação dos
     quocientes através de 'letsimp'.  Quando 'letrat' for 'false',
     'letsimp' simplifica o numerador e o denominador de <expr>
     separadamente, e não simplifica o quociente.  Substituições tais
     como 'n!/n' vão para '(n-1)!' então falham quando 'letrat' for
     'false'.  Quando 'letrat' for 'true', então o numerador, o
     denominador, e o quociente são simplificados nessa ordem.

     Essas funções de substituição permitem-lhe trabalhar com muitos
     pacotes de regras.  Cada pacote de regras pode conter qualquer
     número de regras 'let' e é referenciado através de um nome definido
     pelo utilizador.  'let ([<prod>, <repl>, <prednome>, <arg_1>, ...,
     <arg_n>], <nome_pacote>)' adiciona a regra <prednome> ao pacote de
     regras <nome_pacote>.  'letsimp (<expr>, <nome_pacote>)' aplica as
     regras em <nome_pacote>.  'letsimp (<expr>, <nome_pacote1>,
     <nome_pacote2>, ...)' é equivalente a 'letsimp (<expr>,
     <nome_pacote1>)' seguido por 'letsimp (%, <nome_pacote2>)', ....

     'current_let_rule_package' é o nome do pacote de regras que está
     actualmente sendo usando.  Essa variável pode receber o nome de
     qualquer pacote de regras definidos via o comando 'let'.  Quando
     qualquer das funções compreendidas no pacote 'let' são chamadas sem
     o nome do pacote, o pacote nomeado por 'current_let_rule_package' é
     usado.  Se uma chamada tal como 'letsimp (<expr>,
     <nome_pct_regras>)' é feita, o pacote de regras <nome_pct_regras> é
     usado somente para aquele comando 'letsimp', e
     'current_let_rule_package' não é alterada.  Se não especificado de
     outra forma, 'current_let_rule_package' avalia de forma padronizada
     para 'default_let_rule_package'.

          (%i1) matchdeclare ([a, a1, a2], true)$
          (%i2) oneless (x, y) := is (x = y-1)$
          (%i3) let (a1*a2!, a1!, oneless, a2, a1);
          (%o3)         a1 a2! --> a1! where oneless(a2, a1)
          (%i4) letrat: true$
          (%i5) let (a1!/a1, (a1-1)!);
                                  a1!
          (%o5)                   --- --> (a1 - 1)!
                                  a1
          (%i6) letsimp (n*m!*(n-1)!/m);
          (%o6)                      (m - 1)! n!
          (%i7) let (sin(a)^2, 1 - cos(a)^2);
                                  2               2
          (%o7)                sin (a) --> 1 - cos (a)
          (%i8) letsimp (sin(x)^4);
                                  4           2
          (%o8)                cos (x) - 2 cos (x) + 1

 -- Variável de opção: letrat
     Valor por omissão: 'false'

     Quando 'letrat' for 'false', 'letsimp' simplifica o numerador e o
     denominador de uma razão separadamente, e não simplifica o
     quociente.

     Quando 'letrat' for 'true', o numerador, o denominador, e seu
     quocienten são simplificados nessa ordem.

          (%i1) matchdeclare (n, true)$
          (%i2) let (n!/n, (n-1)!);
                                   n!
          (%o2)                    -- --> (n - 1)!
                                   n
          (%i3) letrat: false$
          (%i4) letsimp (a!/a);
                                         a!
          (%o4)                          --
                                         a
          (%i5) letrat: true$
          (%i6) letsimp (a!/a);
          (%o6)                       (a - 1)!

 -- Função: letrules ()
 -- Função: letrules (<nome_pacote>)
     Mostra as regras em um pacote de regras.  'letrules ()' mostra as
     regras no pacote de regras corrente.  'letrules (<nome_pacote>)'
     mostra as regras em 'nome_pacote'.

     O pacote de regras corrente é nomeado por
     'current_let_rule_package'.  Se não especificado de outra forma,
     'current_let_rule_package' avalia de forma padrão para
     'default_let_rule_package'.

     Veja também 'disprule', que mostra regras defindas por 'tellsimp' e
     'tellsimpafter'.

 -- Função: letsimp (<expr>)
 -- Função: letsimp (<expr>, <nome_pacote>)
 -- Função: letsimp (<expr>, <nome_pacote_1>, ..., <nome_pacote_n>)
     Repetidamente aplica a substituição definida por 'let' até que
     nenhuma mudança adicional seja feita para <expr>.

     'letsimp (<expr>)' usa as regras de 'current_let_rule_package'.

     'letsimp (<expr>, <nome_pacote>)' usa as regras de <nome_pacote>
     sem alterar 'current_let_rule_package'.

     'letsimp (<expr>, <nome_pacote_1>, ..., <nome_pacote_n>)' é
     equivalente a 'letsimp (<expr>, <nome_pacote_1>', seguido por
     'letsimp (%, <nome_pacote_2>)', e assim sucessivamente.

 -- Variável de opção: let_rule_packages
     Valor por omissão: '[default_let_rule_package]'

     'let_rule_packages' é uma lista de todos os pacotes de regras 'let'
     definidos pelo utilizador mais o pacote padrão
     'default_let_rule_package'.

 -- Função: matchdeclare (<a_1>, <pred_1>, ..., <a_n>, <pred_n>)
     Associa um predicado <pred_k> com uma variável ou lista de
     variáveis <a_k> de forma que <a_k> coincida com expressões para as
     quais o predicado retorne qualquer coisa que não 'false'.

     Umpredicado é o nome de uma função, ou de uma expressão lambda, ou
     uma chamada de função ou chamada de função lambda iomitindo o
     úlltimo argumento, ou 'true' ou 'all'.  Qualquer expressão coincide
     com 'true' ou 'all'.  Se o predicado for especificado como uma
     chamada de função ou chamada de função lambda, a expressão a ser
     testada é anexada ao final da lista de argumentos; os argumentos
     são avaliados ao mesmo tempo que a coincidência é avaliada.  De
     outra forma, o predicado é especificado como um nome de função ou
     expressão lambda, e a expressão a ser testada é o argumento
     sozinho.  Uma função predicado não precisa ser definida quando
     'matchdeclare' for chamada; o predicado não é avaliado até que uma
     coincidência seja tentada.

     Um predicado pode retornar uma expressão Booleana além de 'true' ou
     'false'.  Expressões Booleanas são avaliadas por 'is' dentro da
     função da regra construída, de forma que não é necessário chamar
     'is' dentro do predicado.

     Se uma expressão satisfaz uma coincidência de predicado, a variável
     de coincidência é atribuída à expressão, excepto para variáveis de
     coincidência que são operandos de adição '+' ou multiplicação '*'.
     Somente adição e multiplicação são manuseadas de forma especial;
     outros operadores enários (ambos os definidos internamente e os
     definidos pelo utilizador) são tratados como funções comuns.

     No caso de adição e multiplicação, a variável de coincidência pode
     ser atribuida a uma expressão simples que satisfaz o predicado de
     coincidência, ou uma adição ou um produto (respectivamente) de tais
     expressões.  Tal coincidência de termo multiplo é gulosa:
     predicados são avaliados na ordem em que suas variáveis associadas
     aparecem no modelo de coincidência, e o termo que satisfizer mais
     que um predicado é tomado pelo primeiro predicado que satisfizer.
     Cada predicado é testado contra todos os operandos de adição ou
     produto antes que o próximo predicado seja avaliado.
     Adicionalmente, se 0 ou 1 (respectivamente) satisfazem um predicado
     de coincidência, e não existe outros termos que satisfaçam o
     predicado, 0 ou 1 é atribuído para a variável de coincidência
     associada com o predicado.

     O algoritmo para processar modelos contendo adição e multiplicação
     faz alguns resultados de coincidência (por exemplo, um modelo no
     qual uma variável "coincida com qualquer coisa" aparecer)
     dependerem da ordem dos termos no modelo de coincidência e na
     expressão a ser testada a coincidência.  Todavia, se todos os
     predicados de coincidência são mutuamente exclusivos, o resultado
     de coincidência é insensível a ordenação, como um predicado de
     coincidência não pode aceitar termos de coincidência de outro.

     Chamado 'matchdeclare' com uma variável <a> como um argumento muda
     a propriedade 'matchdeclare' para <a>, se a variável <a> tiver sido
     declarada anteriormente; somente o 'matchdeclare' mais recente está
     em efeito quando uma regra é definida, mudanças posteriores para a
     propriedade 'matchdeclare' (via 'matchdeclare' ou 'remove') não
     afectam regras existentes.

     'propvars (matchdeclare)' retorna a lista de todas as variáveis
     para as quais exista uma propriedade 'matchdeclare'.  'printprops
     (<a>, matchdeclare)' retorna o predicado para a variável 'a'.
     'printprops (all, matchdeclare)' retorna a lista de predicados para
     todas as variáveis 'matchdeclare'.  'remove (<a>, matchdeclare)'
     remove a propriedade 'matchdeclare' da variável <a>.

     As funções 'defmatch', 'defrule', 'tellsimp', 'tellsimpafter', e
     'let' constroem regras que testam expressões contra modelos.

     'matchdeclare' coloca apóstrofo em seus argumentos.  'matchdeclare'
     sempre retorna 'done'.

     Exemplos:

     Um predicado é o nome de uma função, ou uma expressão lambda, ou
     uma chamada de função ou chamada a função lambda omitindo o último
     argumento, or 'true' or 'all'.

          (%i1) matchdeclare (aa, integerp);
          (%o1)                         done
          (%i2) matchdeclare (bb, lambda ([x], x > 0));
          (%o2)                         done
          (%i3) matchdeclare (cc, freeof (%e, %pi, %i));
          (%o3)                         done
          (%i4) matchdeclare (dd, lambda ([x, y], gcd (x, y) = 1) (1728));
          (%o4)                         done
          (%i5) matchdeclare (ee, true);
          (%o5)                         done
          (%i6) matchdeclare (ff, all);
          (%o6)                         done

     Se uma expressão satisfaz um predicado de coincidência, a variável
     de coincidência é atribuída à expressão.

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) defrule (r1, bb^aa, ["integer" = aa, "atom" = bb]);
                              aa
          (%o2)        r1 : bb   -> [integer = aa, atom = bb]
          (%i3) r1 (%pi^8);
          (%o3)               [integer = 8, atom = %pi]

     No caso de adição e multiplicação, à variável de coincidência pode
     ser atribuída uma expressão simples que satisfaz o predicado de
     coincidência, ou um somatório ou produtório (respectivamente) de
     tais expressões.

          (%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
          (%o1)                         done
          (%i2) defrule (r1, aa + bb, ["all atoms" = aa, "all nonatoms" = bb]);
          bb + aa partitions `sum'
          (%o2)  r1 : bb + aa -> [all atoms = aa, all nonatoms = bb]
          (%i3) r1 (8 + a*b + sin(x));
          (%o3)     [all atoms = 8, all nonatoms = sin(x) + a b]
          (%i4) defrule (r2, aa * bb, ["all atoms" = aa, "all nonatoms" = bb]);
          bb aa partitions `product'
          (%o4)   r2 : aa bb -> [all atoms = aa, all nonatoms = bb]
          (%i5) r2 (8 * (a + b) * sin(x));
          (%o5)    [all atoms = 8, all nonatoms = (b + a) sin(x)]

     Quando coincidindo argumentos de '+' e '*', se todos os predicados
     de coincidência forem mutuamente exclusivos, o resultado da
     coincidência é insensíve à ordenação, como um predicado de
     coincidência não pode aceitar termos que coincidiram com outro.

          (%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
          (%o1)                         done
          (%i2) defrule (r1, aa + bb, ["all atoms" = aa, "all nonatoms" = bb]);
          bb + aa partitions `sum'
          (%o2)  r1 : bb + aa -> [all atoms = aa, all nonatoms = bb]
          (%i3) r1 (8 + a*b + %pi + sin(x) - c + 2^n);
                                                               n
          (%o3) [all atoms = %pi + 8, all nonatoms = sin(x) + 2  - c + a b]
          (%i4) defrule (r2, aa * bb, ["all atoms" = aa, "all nonatoms" = bb]);
          bb aa partitions `product'
          (%o4)   r2 : aa bb -> [all atoms = aa, all nonatoms = bb]
          (%i5) r2 (8 * (a + b) * %pi * sin(x) / c * 2^n);
                                                            n
                                                   (b + a) 2  sin(x)
          (%o5) [all atoms = 8 %pi, all nonatoms = -----------------]
                                                           c

     As funções 'propvars' e 'printprops' retornam informações sobre
     variávels de coincidência.

          (%i1) matchdeclare ([aa, bb, cc], atom, [dd, ee], integerp);
          (%o1)                         done
          (%i2) matchdeclare (ff, floatnump, gg, lambda ([x], x > 100));
          (%o2)                         done
          (%i3) propvars (matchdeclare);
          (%o3)             [aa, bb, cc, dd, ee, ff, gg]
          (%i4) printprops (ee, matchdeclare);
          (%o4)                    [integerp(ee)]
          (%i5) printprops (gg, matchdeclare);
          (%o5)              [lambda([x], x > 100, gg)]
          (%i6) printprops (all, matchdeclare);
          (%o6) [lambda([x], x > 100, gg), floatnump(ff), integerp(ee),
                                integerp(dd), atom(cc), atom(bb), atom(aa)]

 -- Função: matchfix (<delimitador_e>, <delimitador_d>)
 -- Função: matchfix (<delimitador_e>, <delimitador_d>, <arg_pos>,
          <pos>)
     Declara um operador 'matchfix' com delimitadores esquerdo e direito
     <delimitador_e> e <delimitador_d>.  Os delimitadores são
     especificados como sequêcias de caracteres.

     Um operador "matchfix" é uma função que aceita qualquer número de
     argumentos, tal que os argumentos ocorram entre os delimitadores
     correspondentes esquerdo e direito.  Os delimitadores podem ser
     quaisquer sequêcias de caracteres, contanto que o analisador de
     expressões do Maxima possa distinguir os delimitadores dos
     operandos e de outras expressões e operadores.  Na prática essas
     regras excluem delimitadores não analisáveis tais como '%', ',',
     '$' e ';', e pode ser necessário isolar os delimitadores com
     espaços em branco.  O delimitador da direita pode ser o mesmo ou
     diferente do delimitador da esquerda.

     Um delimitador esquerdo pode ser associado com somente um
     delimitador direito; dois diferentes operadores 'matchfix' não
     podem ter o mesmo delimitador esquerdo.

     Um operador existente pode ser redeclarado com um operador
     'matchfix' sem alterar suas outras propriedades.  Particularmente,
     operadores internos tais como adição '+' podem ser declarados
     'matchfix', mas funções operadores não podem ser definidas para
     operadores internos.

     'matchfix (<delimitador_e>, <delimitador_d>, <arg_pos>, <pos>)'
     declara o argumento <arg_pos> como sendo um entre: expressão
     lógica, expressão comum do Maxima mas que não seja do tipo
     anterior, e qualquer outro tipo de expressão que não esteja
     incluída nos dois primeiros tipos.  Essa declaração resulta em
     <pos> sendo um entre: expressão lógica, expressão comum do Maxima
     mas que não seja do tipo anterior, e qualquer outro tipo de
     expressão que não esteja incluída nos dois primeiros tipos e os
     delimitadores <delimitador_e> e <delimitador_d>.

     A função para realizar uma operação 'matchfix' é uma função comum
     definida pelo utilizador.  A função operador é definida da forma
     usual com o operador de definição de função ':=' ou 'define'.  Os
     argumentos podem ser escritos entre os delimitadores, ou com o
     delimitador esquerdo com uma sequência de caracteres com apóstrofo
     e os argumentos seguindo entre parêntesis.  'dispfun
     (<delimitador_e>)' mostra a definição da função operador.

     O único operador interno 'matchfix' é o construtor de listas '[ ]'.
     Parêntesis '( )' e aspas duplas '" "' atuam como operadores
     'matchfix', mas não são tratados como tal pelo analisador do
     Maxima.

     'matchfix' avalia seus argumentos.  'matchfix' retorna seu primeiro
     argumento, <delimitador_e>.

     Exemplos:

        * Delimitadores podem ser quase quaisquer sequência de
          caracteres.
          (%i1) matchfix ("@@", "~");
          (%o1)                          @@
          (%i2) @@ a, b, c ~;
          (%o2)                      @@a, b, c~
          (%i3) matchfix (">>", "<<");
          (%o3)                          >>
          (%i4) >> a, b, c <<;
          (%o4)                      >>a, b, c<<
          (%i5) matchfix ("foo", "oof");
          (%o5)                          foo
          (%i6) foo a, b, c oof;
          (%o6)                     fooa, b, coof
          (%i7) >> w + foo x, y oof + z << / @@ p, q ~;
                               >>z + foox, yoof + w<<
          (%o7)                ----------------------
                                      @@p, q~

        * Operadores 'matchfix' são funções comuns definidas pelo
          utilizador.
          (%i1) matchfix ("!-", "-!");
          (%o1)                         "!-"
          (%i2) !- x, y -! := x/y - y/x;
                                              x   y
          (%o2)                   !-x, y-! := - - -
                                              y   x
          (%i3) define (!-x, y-!, x/y - y/x);
                                              x   y
          (%o3)                   !-x, y-! := - - -
                                              y   x
          (%i4) define ("!-" (x, y), x/y - y/x);
                                              x   y
          (%o4)                   !-x, y-! := - - -
                                              y   x
          (%i5) dispfun ("!-");
                                              x   y
          (%t5)                   !-x, y-! := - - -
                                              y   x

          (%o5)                         done
          (%i6) !-3, 5-!;
                                          16
          (%o6)                         - --
                                          15
          (%i7) "!-" (3, 5);
                                          16
          (%o7)                         - --
                                          15

 -- Função: remlet (<prod>, <nome>)
 -- Função: remlet ()
 -- Função: remlet (all)
 -- Função: remlet (all, <nome>)
     Apaga a regra de substituiçao, prod -> repl, mais recentemente
     definida através dea função 'let'.  Se 'nome' for fornecido a regra
     é apagada do pacote de regras chamado 'nome'.

     'remlet()' e 'remlet(all)' apagam todas as regras de substituição
     do pacote de regras corrente.  Se o nome de um pacote de regras for
     fornecido, e.g.  'remlet (all, <nome>)', o pacote de regras <nome>
     é também apagado.

     Se uma substituição é para ser mudada usando o mesmo produto,
     'remlet' não precisa ser chamada, apenas redefina a substituição
     usando o mesmo produto (literalmente) com a função 'let' e a nova
     substituição e/ou nome de predicado.  Pode agora 'remlet (<prod>)'
     ser chamada e a regra de substituição original é ressuscitada.

     Veja também 'remrule', que remove uma regra definida através de
     'tellsimp' ou de 'tellsimpafter'.

 -- Função: remrule (<op>, <nomeregra>)
 -- Função: remrule (<op>, all)
     Remove regras definidas por 'tellsimp', ou 'tellsimpafter'.

     'remrule (<op>, <nomeregra>)' remove a regra com o nome 'nomeregra'
     do operador <op>.  Quando <op> for um operador interno ou um
     operador definido pelo utilizador (como definido por 'infix',
     'prefix', etc.), <op> e <rulename> devem ser colocados entre aspas
     duplas.

     'remrule (<op>, all)' remove todas as regras para o operador <op>.

     Veja também 'remlet', que remove uma regra definida através de
     'let'.

     Examples:

          (%i1) tellsimp (foo (aa, bb), bb - aa);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (aa + bb, special_add (aa, bb));
          (%o2)                   [+rule1, simplus]
          (%i3) infix ("@@");
          (%o3)                          @@
          (%i4) tellsimp (aa @@ bb, bb/aa);
          (%o4)                   [@@rule1, false]
          (%i5) tellsimpafter (quux (%pi, %e), %pi - %e);
          (%o5)                  [quuxrule1, false]
          (%i6) tellsimpafter (quux (%e, %pi), %pi + %e);
          (%o6)             [quuxrule2, quuxrule1, false]
          (%i7) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
                 quux (%e, %pi)];
                                               bb
          (%o7) [bb - aa, special_add(aa, bb), --, %pi - %e, %pi + %e]
                                               aa
          (%i8) remrule (foo, foorule1);
          (%o8)                          foo
          (%i9) remrule ("+", "+rule1");
          (%o9)                           +
          (%i10) remrule ("@@", "@@rule1");
          (%o10)                         @@
          (%i11) remrule (quux, all);
          (%o11)                        quux
          (%i12) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
                  quux (%e, %pi)];
          (%o12) [foo(aa, bb), bb + aa, aa @@ bb, quux(%pi, %e),
                                                   quux(%e, %pi)]

 -- Função: tellsimp (<pattern>, <replacement>)
     é similar a 'tellsimpafter' mas coloca nova informação antes da
     antiga de forma que essa nova regra seja aplicada antes das regras
     de simplificação internas.

     'tellsimp' é usada quando for importante modificar a expressão
     antes que o simplificador trabalhe sobre ela, por exemplo se o
     simplificador "sabe" alguma coisa sobre a expressão, mas o que ele
     retorna não é para sua apreciação.  Se o simplificador "sabe"
     alguma coisa sobre o principal operador da expressão, mas está
     simplesmente a escondê-lo, provavelmente querrá usar
     'tellsimpafter'.

     O modelo pode não ser uma adição, um produto, variável simples, ou
     número.

     'rules' é a lista de regras definidas por 'defrule', 'defmatch',
     'tellsimp', e 'tellsimpafter'.

     Exemplos:

          (%i1) matchdeclare (x, freeof (%i));
          (%o1)                         done
          (%i2) %iargs: false$
          (%i3) tellsimp (sin(%i*x), %i*sinh(x));
          (%o3)                 [sinrule1, simp-%sin]
          (%i4) trigexpand (sin (%i*y + x));
          (%o4)         sin(x) cos(%i y) + %i cos(x) sinh(y)
          (%i5) %iargs:true$
          (%i6) errcatch(0^0);
           0
          0  has been generated
          (%o6)                          []
          (%i7) ev (tellsimp (0^0, 1), simp: false);
          (%o7)                  [^rule1, simpexpt]
          (%i8) 0^0;
          (%o8)                           1
          (%i9) remrule ("^", %th(2)[1]);
          (%o9)                           ^
          (%i10) tellsimp (sin(x)^2, 1 - cos(x)^2);
          (%o10)                 [^rule2, simpexpt]
          (%i11) (1 + sin(x))^2;
                                                2
          (%o11)                    (sin(x) + 1)
          (%i12) expand (%);
                                             2
          (%o12)               2 sin(x) - cos (x) + 2
          (%i13) sin(x)^2;
                                            2
          (%o13)                     1 - cos (x)
          (%i14) kill (rules);
          (%o14)                        done
          (%i15) matchdeclare (a, true);
          (%o15)                        done
          (%i16) tellsimp (sin(a)^2, 1 - cos(a)^2);
          (%o16)                 [^rule3, simpexpt]
          (%i17) sin(y)^2;
                                            2
          (%o17)                     1 - cos (y)

 -- Função: tellsimpafter (<modelo>, <substituição>)
     Define a uma regra de simplificação que o simplificador do Maxima
     aplica após as regras de simplificação internas.  <modelo> é uma
     expressão, compreendendo variáveis de modelo (declaradas através de
     'matchdeclare') e outros átomos e operações, considerados literais
     para o propósito de coincidência de modelos.  <substituição> é
     substituída para uma expressão actual que coincide com <modelo>;
     variáveis de modelo em <substituição> são atribuidas a valores
     coincidentes na expressão actual.

     <modelo> pode ser qualquer expressão não atômica na qual o
     principal operador não é uma variável de modelo; a regra de
     simplificação está associada com o operador principal.  Os nomes de
     funções (com uma excessão, descrita abaixo), listas, e arrays podem
     aparecer em <modelo> como o principal operador somente como
     literais (não variáveis de modelo); essas regras fornecem
     expressões tais como 'aa(x)' e 'bb[y]' como modelos, se 'aa' e 'bb'
     forem variáveis de modelo.  Nomes de funções, listas, e arrays que
     são variáveis de modelo podem aparecer como operadores outros que
     não o operador principal em <modelo>.

     Existe uma excessão para o que foi dito acima com relação a regras
     e nomes de funções.  O nome de uma função subscrita em uma
     expressão tal como 'aa[x](y)' pode ser uma variável de modelo,
     porque o operador principal não é 'aa' mas ao contrário o átomo
     Lisp 'mqapply'.  Isso é uma consequência da representação de
     expressões envolvendo funções subscritas.

     Regras de simplificação são aplicadas após avaliação (se não
     suprimida através de colocação de apóstrofo ou do sinalizador
     'noeval').  Regras estabelecidas por 'tellsimpafter' são aplicadas
     na ordem em que forem definidas, e após quaisquer regras internas.
     Regras são aplicadas de baixo para cima, isto é, aplicadas primeiro
     a subexpressões antes de ser aplicada à expressão completa.  Isso
     pode ser necessário para repetidamente simplificar um resultado
     (por exemplo, via o operador apóstrofo-apóstrofo '''' ou o
     sinalizador 'infeval') para garantir que todas as regras são
     aplicadas.

     Variáveis de modelo são tratadas como variáveis locais em regras de
     simplificação.  Assim que uma regra é definida, o valor de uma
     variável de modelo não afecta a regra, e não é afectado pela regra.
     Uma atribuição para uma variável de modelo que resulta em uma
     coincidência de regra com sucesso não afecta a atribuição corrente
     (ou necessita disso) da variável de modelo.  Todavia, como com
     todos os átomos no Maxima, as propriedades de variáveis de modelo
     (como declarado por 'put' e funções relacionadas) são globais.

     A regra construída por 'tellsimpafter' é nomeada após o operador
     principal de 'modelo'.  Regras para operadores internos, e
     operadores definidos pelo utilizador definidos por meio de 'infix',
     'prefix', 'postfix', 'matchfix', e 'nofix', possuem nomes que são
     sequências de caracteres do Maxima.  Regras para outras funções
     possuem nomes que são identificadores comuns do Maxima.

     O tratamento de substantivos e formas verbais é desprezívelmente
     confuso.  Se uma regra é definida para uma forma substantiva (ou
     verbal) e uma regra para o verbo correspondente (ou substantivo) já
     existe, então a nova regra definida aplica-se a ambas as formas
     (substantiva e verbal).  Se uma regra para a correspondente forma
     verbal (ou substantiva) não existe, a nova regra definida
     aplicar-se-á somente para a forma substantiva (ou verbal).

     A regra construída através de 'tellsimpafter' é uma função Lisp
     comum.  Se o nome da regra for '$foorule1', a construção ':lisp
     (trace $foorule1)' rastreia a função, e ':lisp (symbol-function
     '$foorule1' mostra sua definição.

     'tellsimpafter' não avalia seus argumentos.  'tellsimpafter'
     retorna a lista de regras para o operador principal de <modelo>,
     incluindo a mais recente regra estabelecia.

     Veja também 'matchdeclare', 'defmatch', 'defrule', 'tellsimp',
     'let', 'kill', 'remrule', e 'clear_rules'.

     Exemplos:

     <modelo> pode ser qualquer expressão não atômica na qual o
     principal operador não é uma variável de modelo.

          (%i1) matchdeclare (aa, atom, [ll, mm], listp, xx, true)$
          (%i2) tellsimpafter (sin (ll), map (sin, ll));
          (%o2)                 [sinrule1, simp-%sin]
          (%i3) sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);
                              1  sqrt(2)  sqrt(3)
          (%o3)              [-, -------, -------, 1, 0]
                              2     2        2
          (%i4) tellsimpafter (ll^mm, map ("^", ll, mm));
          (%o4)                  [^rule1, simpexpt]
          (%i5) [a, b, c]^[1, 2, 3];
                                          2   3
          (%o5)                      [a, b , c ]
          (%i6) tellsimpafter (foo (aa (xx)), aa (foo (xx)));
          (%o6)                   [foorule1, false]
          (%i7) foo (bar (u - v));
          (%o7)                    bar(foo(u - v))

     Regras são aplicadas na ordem em que forem definidas.  Se duas
     regras podem coincidir com uma expressão, a regra que foi primeiro
     definida é a que será aplicada.

          (%i1) matchdeclare (aa, integerp);
          (%o1)                         done
          (%i2) tellsimpafter (foo (aa), bar_1 (aa));
          (%o2)                   [foorule1, false]
          (%i3) tellsimpafter (foo (aa), bar_2 (aa));
          (%o3)              [foorule2, foorule1, false]
          (%i4) foo (42);
          (%o4)                       bar_1(42)

     variáveis de modelo são tratadas como variáveis locais em regras de
     simplificação.  (Compare a 'defmatch', que trata variáveis de
     modelo como variáveis globais.)

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) bb: 12345;
          (%o3)                         12345
          (%i4) foo (42, %e);
          (%o4)                 bar(aa = 42, bb = %e)
          (%i5) bb;
          (%o5)                         12345

     Como com todos os átomos, propriedades de variáveis de modelo são
     globais embora valores sejam locais.  Nesse exemplo, uma
     propriedade de atribuição é declarada via 'define_variable'.  Essa
     é a propriedade do átomo 'bb' através de todo o Maxima.

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) foo (42, %e);
          (%o3)                 bar(aa = 42, bb = %e)
          (%i4) define_variable (bb, true, boolean);
          (%o4)                         true
          (%i5) foo (42, %e);
          Error: bb was declared mode boolean, has value: %e
           -- an error.  Quitting.  To debug this try debugmode(true);

     Regras são nomeadas após operadores principais.  Nomes de regras
     para operadores internos e operadores definidos pelo utilizador são
     sequências de caracteres, enquanto nomes para outras funções são
     identificadores comuns.

          (%i1) tellsimpafter (foo (%pi + %e), 3*%pi);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (foo (%pi * %e), 17*%e);
          (%o2)              [foorule2, foorule1, false]
          (%i3) tellsimpafter (foo (%i ^ %e), -42*%i);
          (%o3)         [foorule3, foorule2, foorule1, false]
          (%i4) tellsimpafter (foo (9) + foo (13), quux (22));
          (%o4)                   [+rule1, simplus]
          (%i5) tellsimpafter (foo (9) * foo (13), blurf (22));
          (%o5)                  [*rule1, simptimes]
          (%i6) tellsimpafter (foo (9) ^ foo (13), mumble (22));
          (%o6)                  [^rule1, simpexpt]
          (%i7) rules;
          (%o7) [trigrule0, trigrule1, trigrule2, trigrule3, trigrule4,
          htrigrule1, htrigrule2, htrigrule3, htrigrule4, foorule1,
          foorule2, foorule3, +rule1, *rule1, ^rule1]
          (%i8) foorule_name: first (%o1);
          (%o8)                       foorule1
          (%i9) plusrule_name: first (%o4);
          (%o9)                        +rule1
          (%i10) [?mstringp (foorule_name), symbolp (foorule_name)];
          (%o10)                    [false, true]
          (%i11) [?mstringp (plusrule_name), symbolp (plusrule_name)];
          (%o11)                    [true, true]
          (%i12) remrule (foo, foorule1);
          (%o12)                         foo
          (%i13) remrule ("^", "^rule1");
          (%o13)                          ^

     Um exemplo trabalhado: multiplicação anticomutativa.

          (%i1) gt (i, j) := integerp(j) and i < j;
          (%o1)           gt(i, j) := integerp(j) and i < j
          (%i2) matchdeclare (i, integerp, j, gt(i));
          (%o2)                         done
          (%i3) tellsimpafter (s[i]^^2, 1);
          (%o3)                 [^^rule1, simpncexpt]
          (%i4) tellsimpafter (s[i] . s[j], -s[j] . s[i]);
          (%o4)                   [.rule1, simpnct]
          (%i5) s[1] . (s[1] + s[2]);
          (%o5)                    s  . (s  + s )
                                    1     2    1
          (%i6) expand (%);
          (%o6)                      1 - s  . s
                                          2    1
          (%i7) factor (expand (sum (s[i], i, 0, 9)^^5));
          (%o7) 100 (s  + s  + s  + s  + s  + s  + s  + s  + s  + s )
                      9    8    7    6    5    4    3    2    1    0

 -- Função: clear_rules ()
     Executa 'kill (rules)' e então re-escolhe o próximo número de regra
     para 1 para adição '+', multiplicação '*', e exponenciação '^'.


File: maxima.info,  Node: Listas,  Next: Conjuntos,  Prev: Regras e Modelos,  Up: Top

37 Listas
*********

* Menu:

* Introdução a Listas::
* Definições para Listas::


File: maxima.info,  Node: Introdução a Listas,  Next: Definições para Listas,  Prev: Listas,  Up: Listas

37.1 Introdução a Listas
========================

Listas são o bloco básico de construção para Maxima e Lisp.**Todos os
outros tipos de dado como arrays, tabelas desordenadas, números são
representados como listas Lisp.  Essas listas Lisp possuem a forma

     ((MPLUS) $A 2)

para indicar a expressão 'a+2'.**No nível um do Maxima poderemos ver a
notação infixa 'a+2'.**Maxima também tem listas que foram impressas como

     [1, 2, 7, x+y]

para uma lista com 4 elementos.**Internamente isso corresponde a uma
lista Lisp da forma

     ((MLIST) 1  2  7  ((MPLUS)  $X $Y ))

O sinalizador que denota o tipo campo de uma expressão Maxima é uma
lista em si mesmo, após ter sido adicionado o simplificador a lista
poderá transforma-se

     ((MLIST SIMP) 1 2 7 ((MPLUS SIMP) $X $Y))


File: maxima.info,  Node: Definições para Listas,  Prev: Introdução a Listas,  Up: Listas

37.2 Definições para Listas
===========================

 -- Função: append (<list_1>, ..., <list_n>)
     Retorna uma lista simples dos elementos de <list_1> seguidos pelos
     elementos de <list_2>, ....  'append' também trabalha sobre
     expressões gerais, e.g.  'append (f(a,b), f(c,d,e));' retorna
     'f(a,b,c,d,e)'.

     Faça 'example(append);' para um exemplo.

 -- Função: assoc (<key>, <list>, <default>)
 -- Função: assoc (<key>, <list>)
     Essa função procura pela chave <key> do lado esquerdo da entrada
     <list> que é da forma '[x,y,z,...]' onde cada elemento de <list> é
     uma expressão de um operando binário e 2 elementos.  Por exemplo
     'x=1', '2^3', '[a,b]' etc.  A chave <key> é verificada contra o
     primeiro operando.  'assoc' retorna o segundo operando se 'key' for
     achada.  Se a chave 'key' não for achada isso retorna o valor
     padrão <default>.  <default> é opcional e o padrão é 'false'.

 -- Função: atom (<expr>)
     Retorna 'true' se <expr> for atomica (i.e.  um número, nome ou
     sequência de caracteres) de outra forma retorna 'false'.  Desse
     modo 'atom(5)' é 'true' enquanto 'atom(a[1])' e 'atom(sin(x))' São
     'false' (assumindo 'a[1]' e 'x' não estão associados).

 -- Função: cons (<expr>, <list>)
     Retorna uma nova lista construída do elemento <expr> como seu
     primeiro elemento, seguido por elementos de <list>.  'cons' também
     trabalha sobre outras expressões, e.g.  'cons(x, f(a,b,c));' ->
     'f(x,a,b,c)'.

 -- Função: copylist (<list>)
     Retorna uma cópia da lista <list>.

 -- Função: create_list (<form>, <x_1>, <list_1>, ..., <x_n>, <list_n>)

     Cria uma lista por avaliação de <form> com <x_1> associando a cada
     elemento <list_1>, e para cada tal associação anexa <x_2> para cada
     elemento de <list_2>, ....  O número de elementos no resultado será
     o produto do número de elementos de cada lista.  Cada variável
     <x_i> pode actualmente ser um síbolo -o qual não pode ser avaliado.
     A lista de argumentos será avaliada uma única vez no início do
     bloco de repetição.

          (%i82) create_list1(x^i,i,[1,3,7]);
          (%o82) [x,x^3,x^7]

     Com um bloco de repetição duplo:

          (%i79) create_list([i,j],i,[a,b],j,[e,f,h]);
          (%o79) [[a,e],[a,f],[a,h],[b,e],[b,f],[b,h]]

     Em lugar de <list_i> dois argumentos podem ser fornecidos cada um
     dos quais será avaliado como um número.  Esses podem vir a ser
     inclusive o limite inferior e superior do bloco de repetição.

          (%i81) create_list([i,j],i,[1,2,3],j,1,i);
          (%o81) [[1,1],[2,1],[2,2],[3,1],[3,2],[3,3]]

     Note que os limites ou lista para a variável <j> podem depender do
     valor corrente de <i>.

 -- Função: delete (<expr_1>, <expr_2>)
 -- Função: delete (<expr_1>, <expr_2>, <n>)
     Remove todas as ocorrências de <expr_1> em <expr_2>.  <expr_1> pode
     ser uma parcela de <expr_2> (se isso for uma adição) ou um factor
     de <expr_2> (se isso for um produto).

          (%i1) delete(sin(x), x+sin(x)+y);
          (%o1)                         y + x

     'delete(<expr_1>, <expr_2>, <n>)' remove as primeiras <n>
     ocorrências de <expr_1> em <expr_2>.  Se houver menos que <n>
     ocorrências de <expr_1> em <expr_2> então todas as corrências seram
     excluídas.

          (%i1) delete(a, f(a,b,c,d,a));
          (%o1)                      f(b, c, d)
          (%i2) delete(a, f(a,b,a,c,d,a), 2);
          (%o2)                     f(b, c, d, a)

 -- Função: eighth (<expr>)
     Retorna o oitavo item de uma expressão ou lista <expr>.  Veja
     'first' para maiores detalhes.

 -- Função: endcons (<expr>, <list>)
     Retorna uma nova lista consistindo de elementos de 'list' seguidos
     por <expr>.  'endcons' também trabalha sobre expressões gerais,
     e.g.  'endcons(x, f(a,b,c));' -> 'f(a,b,c,x)'.

 -- Função: fifth (<expr>)
     Retorna o quinto item da expressão ou lista <expr>.  Veja 'first'
     para maiores detalhes.

 -- Função: first (<expr>)
     Retorna a primeira parte de <expr> que pode resultar no primeiro
     elemento de uma lista, a primeira linha de uma matriz, a primeira
     parcela de uma adição, etc.  Note que 'first' e suas funções
     relacionadas, 'rest' e 'last', trabalham sobre a forma de <expr>
     que é mostrada não da forma que é digitada na entrada.  Se a
     variável 'inflag' é escolhida para 'true' todavia, essa funções
     olharão na forma interna de <expr>.  Note que o simplificador
     re-ordena expressões.  Desse modo 'first(x+y)' será 'x' se 'inflag'
     for 'true' e 'y' se 'inflag' for 'false' ('first(y+x)' fornece os
     mesmos resultados).  As funções 'second' ..  'tenth' retornam da
     segunda até a décima parte do seu argumento.

 -- Função: fourth (<expr>)
     Retorna o quarto item da expressõ ou lista <expr>.  Veja 'first'
     para maiores detalhes.

 -- Função: get (<a>, <i>)
     Recupera a propriedade de utilizador indicada por <i> associada com
     o átomo <a> ou retorna 'false' se "a" não tem a propriedade <i>.

     'get' avalia seus argumentos.

          (%i1) put (%e, 'transcendental, 'type);
          (%o1)                    transcendental
          (%i2) put (%pi, 'transcendental, 'type)$
          (%i3) put (%i, 'algebraic, 'type)$
          (%i4) typeof (expr) := block ([q],
                  if numberp (expr)
                  then return ('algebraic),
                  if not atom (expr)
                  then return (maplist ('typeof, expr)),
                  q: get (expr, 'type),
                  if q=false
                  then errcatch (error(expr,"is not numeric.")) else q)$
          (%i5) typeof (2*%e + x*%pi);
          x is not numeric.
          (%o5)  [[transcendental, []], [algebraic, transcendental]]
          (%i6) typeof (2*%e + %pi);
          (%o6)     [transcendental, [algebraic, transcendental]]

 -- Função: join (<l>, <m>)
     Cria uma nova lista contendo os elementos das lista <l> e <m>,
     intercaladas.  O resultado tem os elementos '[<l>[1], <m>[1],
     <l>[2], <m>[2], ...]'.  As listas <l> e <m> podem conter qualquer
     tipo de elementos.

     Se as listas forem de diferentes comprimentos, 'join' ignora
     elementos da lista mais longa.

     Maxima reclama se <L_1> ou <L_2> não for uma lista.

     Exemplos:

          (%i1) L1: [a, sin(b), c!, d - 1];
          (%o1)                [a, sin(b), c!, d - 1]
          (%i2) join (L1, [1, 2, 3, 4]);
          (%o2)          [a, 1, sin(b), 2, c!, 3, d - 1, 4]
          (%i3) join (L1, [aa, bb, cc, dd, ee, ff]);
          (%o3)        [a, aa, sin(b), bb, c!, cc, d - 1, dd]

 -- Função: last (<expr>)
     Retorna a última parte (parcela, linha, elemento, etc.)  de <expr>.

 -- Função: length (<expr>)
     Retorna (por padrão) o número de partes na forma externa (mostrada)
     de <expr>.  Para listas isso é o número de elementos, para matrizes
     isso é o número de linhas, e para adições isso é o número de
     parcelas (veja 'dispform').

     O comando 'length' é afectado pelo comutador 'inflag'.  Então, e.g.
     'length(a/(b*c));' retorna 2 se 'inflag' for 'false' (Assumindo
     'exptdispflag' sendo 'true'), mas 3 se 'inflag' for 'true' (A
     representação interna é essencialmente 'a*b^-1*c^-1').

 -- Variável de opção: listarith
     Valor por omissão: 'true' - se 'false' faz com que quaisquer
     operações aritméticas com listas sejam suprimidas; quando 'true',
     operações lista-matriz são contagiosas fazendo com que listas sejam
     convertidas para matrizes retornando um resultado que é sempre uma
     matriz.  Todavia, operações lista-lista podem retornar listas.

 -- Função: listp (<expr>)
     Retorna 'true' se <expr> for uma lista de outra forma retorna
     'false'.

 -- Função: makelist (<expr>, <i>, <i_0>, <i_1>)
 -- Função: makelist (<expr>, <x>, <list>)
     Constrói e retorna uma lista, cada elemento dessa lista é gerado
     usando <expr>.

     'makelist (<expr>, <i>, <i_0>, <i_1>)' retorna uma lista, o
     'j''ésimo elemento dessa lista é igual a 'ev (<expr>, <i>=j)' para
     'j' variando de <i_0> até <i_1>.

     'makelist (<expr>, <x>, <list>)' retorna uma lista, o 'j''ésimo
     elemento é igual a 'ev (<expr>, <x>=<list>[j])' para 'j' variando
     de 1 até 'length (<list>)'.

     Exemplos:

          (%i1) makelist(concat(x,i),i,1,6);
          (%o1)               [x1, x2, x3, x4, x5, x6]
          (%i2) makelist(x=y,y,[a,b,c]);
          (%o2)                 [x = a, x = b, x = c]

 -- Função: member (<expr_1>, <expr_2>)

     Retorna 'true' se 'is(<expr_1> = <a>)' para algum elemento <a> em
     'args(<expr_2>)', de outra forma retorna 'false'.

     'expr_2' é tipicamente uma lista, nesse caso 'args(<expr_2>) =
     <expr_2>' e 'is(<expr_1> = <a>)' para algum elemento <a> em
     'expr_2' é o teste.

     'member' não inspeciona partes dos argumentos de 'expr_2', então
     'member' pode retornar 'false' mesmo se 'expr_1' for uma parte de
     algum argumento de 'expr_2'.

     Veja também 'elementp'.

     Exemplos:

          (%i1) member (8, [8, 8.0, 8b0]);
          (%o1)                         true
          (%i2) member (8, [8.0, 8b0]);
          (%o2)                         false
          (%i3) member (b, [a, b, c]);
          (%o3)                         true
          (%i4) member (b, [[a, b], [b, c]]);
          (%o4)                         false
          (%i5) member ([b, c], [[a, b], [b, c]]);
          (%o5)                         true
          (%i6) F (1, 1/2, 1/4, 1/8);
                                         1  1  1
          (%o6)                     F(1, -, -, -)
                                         2  4  8
          (%i7) member (1/8, %);
          (%o7)                         true
          (%i8) member ("ab", ["aa", "ab", sin(1), a + b]);
          (%o8)                         true

 -- Função: ninth (<expr>)
     Retorna o nono item da expressão ou lista <expr>.  Veja 'first'
     para maiores detalhes.

 -- Função: rest (<expr>, <n>)
 -- Função: rest (<expr>)
     Retorna <expr> com seus primeiros <n> elementos removidos se <n>
     for positivo e seus últimos '- <n>' elementos removidos se <n> for
     negativo.  Se <n> for 1 isso pode ser omitido.  <expr> pode ser uma
     lista, matriz, ou outra expressão.

 -- Função: reverse (<list>)
     Ordem reversa para os membros de <list> (não os membros em si
     mesmos).  'reverse' também trabalha sobre expressões gerais, e.g.
     'reverse(a=b);' fornece 'b=a'.

 -- Função: second (<expr>)
     Retorna o segundo item da expressão ou lista <expr>.  Veja 'first'
     para maiores detalhes.

 -- Função: seventh (<expr>)
     Retorna o sétimo item da expressão ou lista <expr>.  Veja 'first'
     para maiores detalhes.

 -- Função: sixth (<expr>)
     Retorna o sexto item da expressão ou lista <expr>.  Veja 'first'
     para maiores detalhes.

 -- Função: sublist_indices (<L>, <P>)

     Retorna os índices dos elementos 'x' da lista <L> para os quais o
     predicado 'maybe(<P>(x))' retornar 'true'; isso inclui 'unknown'
     bem como 'false'.  <P> pode ser um nome de função ou uma expressão
     lambda.  <L> deve ser uma lista literal.

     Exemplos:

          (%i1) sublist_indices ('[a, b, b, c, 1, 2, b, 3, b], lambda ([x], x='b));
          (%o1)                     [2, 3, 7, 9]
          (%i2) sublist_indices ('[a, b, b, c, 1, 2, b, 3, b], symbolp);
          (%o2)                  [1, 2, 3, 4, 7, 9]
          (%i3) sublist_indices ([1 > 0, 1 < 0, 2 < 1, 2 > 1, 2 > 0], identity);
          (%o3)                       [1, 4, 5]
          (%i4) assume (x < -1);
          (%o4)                       [x < - 1]
          (%i5) map (maybe, [x > 0, x < 0, x < -2]);
          (%o5)                [false, true, unknown]
          (%i6) sublist_indices ([x > 0, x < 0, x < -2], identity);
          (%o6)                          [2]

 -- Função: tenth (<expr>)
     Retorna o décimo item da expressão ou lista <expr>.  Veja 'first'
     para maiores detalhes.

 -- Função: third (<expr>)
     Retorna o terceiro item da expressão ou lista <expr>.  Veja 'first'
     para maiores detalhes.


File: maxima.info,  Node: Conjuntos,  Next: Definição de Função,  Prev: Listas,  Up: Top

38 Conjuntos
************

* Menu:

* Introdução a Conjuntos::       
* Definições para Conjuntos::       


File: maxima.info,  Node: Introdução a Conjuntos,  Next: Definições para Conjuntos,  Prev: Conjuntos,  Up: Conjuntos

38.1 Introdução a Conjuntos
===========================

Maxima fornece funções de conjunto, tais como intersecção e união, para
conjuntos finitos que são definidos por enumeração explícita.  Maxima
trata listas e conjuntos como objectos distintos.  Este recurso torna
possível trabalhar com conjuntos que possuem elementos que são ou listas
ou conjuntos.

Adicionalmente, para funções de conjuntos finitos, Maxima fornece
algumas funções relacionadas com análise combinatória: números de
Stirling de primeiro e de segundo tipo, números de Bell, coeficientes
multinomiais e partições de inteiros não negativos, entre outras.
Maxima também define a função delta de Kronecker.

38.1.1 Utilização
-----------------

Para construir um conjunto com elementos 'a_1, ..., a_n', escreva
'set(a_1, ..., a_n)' ou '{a_1, ..., a_n}'; para construir o conjunto
vazio, escreva 'set()' ou '{}'.  Para inserção de dados, 'set(...)' e '{
... }' são equivalentes.  Os conjuntos são sempre mostrados entre chaves
('{ ... }').

Se um elemento é listado mais de uma vez, o simplificador do Maxima
elimina o elemento redundante.

     (%i1) set();
     (%o1)                          {}
     (%i2) set(a, b, a);
     (%o2)                        {a, b}
     (%i3) set(a, set(b));
     (%o3)                       {a, {b}}
     (%i4) set(a, [b]);
     (%o4)                       {a, [b]}
     (%i5) {};
     (%o5)                          {}
     (%i6) {a, b, a};
     (%o6)                        {a, b}
     (%i7) {a, {b}};
     (%o7)                       {a, {b}}
     (%i8) {a, [b]};
     (%o8)                       {a, [b]}

Dois elementos <x> e <y> são redundantes (nomeadamente, considerados o
mesmo para propósito de construção de conjuntos) se e somente se 'is(<x>
= <y>)' retornar 'true'.  Note que 'is(equal(<x>, <y>))' pode retornar
'true' enquanto 'is(<x> = <y>)' retorna 'false'; nesse caso os elementos
<x> e <y> são considerados distintos.

     (%i1) x: a/c + b/c;
                                   b   a
     (%o1)                         - + -
                                   c   c
     (%i2) y: a/c + b/c;
                                   b   a
     (%o2)                         - + -
                                   c   c
     (%i3) z: (a + b)/c;
                                   b + a
     (%o3)                         -----
                                     c
     (%i4) is (x = y);
     (%o4)                         true
     (%i5) is (y = z);
     (%o5)                         false
     (%i6) is (equal (y, z));
     (%o6)                         true
     (%i7) y - z;
                                b + a   b   a
     (%o7)                    - ----- + - + -
                                  c     c   c
     (%i8) ratsimp (%);
     (%o8)                           0
     (%i9) {x, y, z};
                               b + a  b   a
     (%o9)                    {-----, - + -}
                                 c    c   c

Para construir um conjunto dos elementos de uma lista, use 'setify'.

     (%i1) setify ([b, a]);
     (%o1)                        {a, b}

Os elementos de conjunto 'x' e 'y' serão considerados iguais se 'is(x =
y)' for avaliando para 'true'.  Dessa forma, 'rat(x)' e 'x' são iguais
como elementos de conjunto; consequentemente,

     (%i1) {x, rat(x)};
     (%o1)                          {x}

Adicionalmente, uma vez que 'is((x - 1)*(x + 1) = x^2 - 1)' avalia para
'false', '(x - 1)*(x + 1)' e 'x^2 - 1' são considerados elementos de
conjunto diferentes; dessa forma

     (%i1) {(x - 1)*(x + 1), x^2 - 1};
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}

Para reduzir esse conjunto a um conjunto simples, apliquemos 'rat' a
cada elemento do conjunto

     (%i1) {(x - 1)*(x + 1), x^2 - 1};
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}
     (%i2) map (rat, %);
                                   2
     (%o2)/R/                    {x  - 1}

Para remover redundâncias em outros conjuntos, poderá ter que usar
outras funções de simplificação.  Aqui está um exemplo que usa
'trigsimp':

     (%i1) {1, cos(x)^2 + sin(x)^2};
                                 2         2
     (%o1)                {1, sin (x) + cos (x)}
     (%i2) map (trigsimp, %);
     (%o2)                          {1}

Um conjunto está simplificado quando os seus elementos não são
redundantes e o conjunto está ordenado.  A versão actual das funções de
conjunto usam a função 'orderlessp' do Maxima para ordenar conjuntos;
contudo, _versões futuras das funções de conjunto poderão vir a usar uma
função de ordenação diferente_.

Algumas operações sobre conjuntos, tais como substituições, forçam
automaticamente a uma re-simplificação; por exemplo,

     (%i1) s: {a, b, c}$
     (%i2) subst (c=a, s);
     (%o2)                        {a, b}
     (%i3) subst ([a=x, b=x, c=x], s);
     (%o3)                          {x}
     (%i4) map (lambda ([x], x^2), set (-1, 0, 1));
     (%o4)                        {0, 1}

Maxima trata listas e conjuntos como objectos distintos; funções tais
como 'union' e 'intersection' produzem um erro se qualquer argumento não
for um conjunto.  se precisar aplicar uma função de conjunto a uma
lista, use a função 'setify' para converter essa lista num conjunto.
Dessa forma

     (%i1) union ([1, 2], {a, b});
     Function union expects a set, instead found [1,2]
      -- an error.  Quitting.  To debug this try debugmode(true);
     (%i2) union (setify ([1, 2]), {a, b});
     (%o2)                     {1, 2, a, b}

Para extrair todos os elementos de um conjunto 's' que satisfazem um
predicado 'f', use 'subset(s, f)'.  (Um predicado é um uma função que
avalia para os valores booleanos 'true'/'false'.)  Por exemplo, para
encontrar as equações num dado conjunto que não depende de uma variável
'z', use

     (%i1) subset ({x + y + z, x - y + 4, x + y - 5}, lambda ([e], freeof (z, e)));
     (%o1)               {- y + x + 4, y + x - 5}

A secção _Definições para Conjuntos_ possui uma lista completa das
funções de conjunto no Maxima.

38.1.2 Iterações entre Elementos de Conjuntos
---------------------------------------------

Existem duas formas de fazer iterações sobre elementos de conjuntos.
Uma forma é usar 'map'; por exemplo:

     (%i1) map (f, {a, b, c});
     (%o1)                  {f(a), f(b), f(c)}

A outra forma consiste em usar 'for <x> in <s> do'

     (%i1) s: {a, b, c};
     (%o1)                       {a, b, c}
     (%i2) for si in s do print (concat (si, 1));
     a1
     b1
     c1
     (%o2)                         done

As funções 'first' e 'rest' do Maxima trabalham actualmente sobre
conjuntos.  Aplicada a um conjunto, 'first' retorna o primeiro elemento
mostrado de um conjunto; qual o élemento que será mostrado dependerá da
implementação.  Se 's' for um conjunto, então 'rest(s)' é equivalente a
'disjoin(first(s), s)'.  Actualmente, existem outras funções do Maxima
que trabalham correctamente sobre conjuntos.  Em versões futuras das
funções de conjunto, 'first' e 'rest' podem vir a funcionar
diferentemente ou deixar de funcionar.

38.1.3 Erros
------------

As funções de conjunto usam a função 'orderlessp' do Maxima para
organizar os elementos dum conjunto e a função (a nível do Lisp) 'like'
para testar a igualdade entre elementos de conjuntos.  Ambas essas
funções possuem falhas conhecidas que podem se manifestar quando tentar
usar conjuntos com elementos que são listas ou matrizes que contenham
expressões na forma racional canónica (CRE). Um exemplo é

     (%i1) {[x], [rat (x)]};
     Maxima encountered a Lisp error:

       The value #:X1440 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

Essa expressão faz com que o Maxima produza um erro (a mensagem de erro
dependerá da versão do Lisp que o Maxima estiver a utilizar).  Outro
exemplo é

     (%i1) setify ([[rat(a)], [rat(b)]]);
     Maxima encountered a Lisp error:

       The value #:A1440 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

Essas falhas são causadas por falhas em 'orderlessp' e 'like', e não por
falhas nas funções de conjunto.  Para ilustrar, experimente as
expressões

     (%i1) orderlessp ([rat(a)], [rat(b)]);
     Maxima encountered a Lisp error:

       The value #:B1441 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.
     (%i2) is ([rat(a)] = [rat(a)]);
     (%o2)                         false

Até que essas falhas forem corrigidas, não construa conjuntos com
elementos que sejam listas ou matrizes contendo expressões na forma
racional canónica (CRE); um conjunto com um elemento na forma CRE,
contudo, pode não ser um problema:

     (%i1) {x, rat (x)};
     (%o1)                          {x}

A 'orderlessp' do Maxima possui outra falha que pode causar problemas
com funções de conjunto; nomeadamente, o predicado de ordenação
'orderlessp' não é transitivo.  O mais simples exemplo conhecido que
mostra isso é

     (%i1) q: x^2$
     (%i2) r: (x + 1)^2$
     (%i3) s: x*(x + 2)$
     (%i4) orderlessp (q, r);
     (%o4)                         true
     (%i5) orderlessp (r, s);
     (%o5)                         true
     (%i6) orderlessp (q, s);
     (%o6)                         false

Essa falha pode causar problemas com todas as funções de conjunto bem
como com funções do Maxima em geral.  É provável, mas não certo, que
essa falha possa ser evitada se todos os elementos do conjunto estiverem
ou na forma CRE ou tiverem sido simplificados usando 'ratsimp'.

Os mecanismos 'orderless' e 'ordergreat' do Maxima são incompatíveis com
as funções de conjunto.  Se precisar usar 'orderless' ou 'ordergrreat',
chame todas essas funções antes de construir quaisquer conjuntos, e não
use 'unorder'.

Se encontrar alguma coisa que pense ser uma falha em alguma funçõ de
conjunto, por favor relate isso para a base de dados de falhas do
Maxima.  Veja 'bug_report'.

38.1.4 Autores
--------------

Stavros Macrakis de Cambridge, Massachusetts e Barton Willis da
Universidade de Nebraska e Kearney (UNK) escreveram as fnções de
conjunto do Maxima e sua documentação.


File: maxima.info,  Node: Definições para Conjuntos,  Prev: Introdução a Conjuntos,  Up: Conjuntos

38.2 Definições para Conjuntos
==============================

 -- Função: adjoin (<x>, <a>)

     Calcula a união do conjunto <a> com '{<x>}'.

     'adjoin' falha se <a> não for um conjunto literal.

     'adjoin(<x>, <a>)' e 'union(set(<x>), <a>)' são equivalentes;
     contudo, 'adjoin' pode ser um pouco mais rápida que 'union'.

     Veja também 'disjoin'.

     Exemplos:

          (%i1) adjoin (c, {a, b});
          (%o1)                       {a, b, c}
          (%i2) adjoin (a, {a, b});
          (%o2)                        {a, b}

 -- Função: belln (<n>)

     Representa o n-ésimo número de Bell.  'belln(n)' é o número de
     partições de um conjunto de <n> elementos.

     Para inteiros não negativos <n>, 'belln(<n>)' simplifica para o
     n-ésimo número de Bell.  'belln' não simplifica para qualquer outro
     tipo de argumento.

     'belln', aplicada a equações, listas, matrizes e conjuntos, é
     calculada em forma distributiva.

     Exemplos:

     'belln' aplicado a inteiros não negativos.

          (%i1) makelist (belln (i), i, 0, 6);
          (%o1)               [1, 1, 2, 5, 15, 52, 203]
          (%i2) is (cardinality (set_partitions ({})) = belln (0));
          (%o2)                         true
          (%i3) is (cardinality (set_partitions ({1, 2, 3, 4, 5, 6})) = belln (6));
          (%o3)                         true

     'belln' aplicado a argumentos que não são inteiros não negativos.

          (%i1) [belln (x), belln (sqrt(3)), belln (-9)];
          (%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]

 -- Função: cardinality (<a>)

     Calcula o número de elementos distintos do conjunto <a>.

     'cardinality' ignora elementos redundantes mesmo quando a
     simplificação não estiver habilitada.

     Exemplos:

          (%i1) cardinality ({});
          (%o1)                           0
          (%i2) cardinality ({a, a, b, c});
          (%o2)                           3
          (%i3) simp : false;
          (%o3)                         false
          (%i4) cardinality ({a, a, b, c});
          (%o4)                           3

 -- Função: cartesian_product (<b_1>, ... , <b_n>)
     Retorna um conjunto de listas da forma '[<x_1>, ..., <x_n>]', onde
     <x_1>, ..., <x_n> são elementos dos conjuntos <b_1>, ...  , <b_n>,
     respectivamente.

     'cartesian_product' falha se qualquer argumento não for um conjunto
     literal.

     Exemplos:

          (%i1) cartesian_product ({0, 1});
          (%o1)                      {[0], [1]}
          (%i2) cartesian_product ({0, 1}, {0, 1});
          (%o2)           {[0, 0], [0, 1], [1, 0], [1, 1]}
          (%i3) cartesian_product ({x}, {y}, {z});
          (%o3)                      {[x, y, z]}
          (%i4) cartesian_product ({x}, {-1, 0, 1});
          (%o4)              {[x, - 1], [x, 0], [x, 1]}

 -- Função: disjoin (<x>, <a>)
     Retorna o conjunto <a> sem o elemento <x>.  Se <x> não for um
     elemento de <a>, retorna <a> sem modificações.

     'disjoin' reclama se <a> não for um conjunto literal.

     'disjoin(<x>, <a>)', 'delete(<x>, <a>)', e 'setdifference(<a>,
     set(<x>))' são todos equivalentes.  Desses, 'disjoin' é geralmente
     mais rápido que os outros.

     Exemplos:

          (%i1) disjoin (a, {a, b, c, d});
          (%o1)                       {b, c, d}
          (%i2) disjoin (a + b, {5, z, a + b, %pi});
          (%o2)                      {5, %pi, z}
          (%i3) disjoin (a - b, {5, z, a + b, %pi});
          (%o3)                  {5, %pi, b + a, z}

 -- Função: disjointp (<a>, <b>)
     Retorna 'true' se e somente se os conjuntos <a> e <b> forem
     disjuntos.

     'disjointp' falha se ou <a> ou <b> não forem conjuntos literais.

     Exemplos:

          (%i1) disjointp ({a, b, c}, {1, 2, 3});
          (%o1)                         true
          (%i2) disjointp ({a, b, 3}, {1, 2, 3});
          (%o2)                         false

 -- Função: divisors (<n>)

     Representa o conjunto dos divisores de <n>.

     'divisors(<n>)' produz um conjunto de divisores inteiros quando <n>
     for um inteiro não nulo.  O conjunto dos divisores inclui os
     elementos 1 e <n>.  Os divisores de um inteiro negativo são os
     divisores do seu valor absoluto.

     'divisors', aplicada a equações, listas, matrizes e conjuntos, é
     calculada em forma distributiva.

     Exemplos:

     Podemos verificar que 28 é um número perfeito: a adição dos seus
     divisores (excepto o próprio 28) é 28.

          (%i1) s: divisors(28);
          (%o1)                 {1, 2, 4, 7, 14, 28}
          (%i2) lreduce ("+", args(s)) - 28;
          (%o2)                          28

     'divisors' é uma função de simplificação.  Substituindo 8 por 'a'
     em 'divisors(a)' calcula os divisores sem ser preciso pedir que
     'divisors(8)' seja reavaliada.

          (%i1) divisors (a);
          (%o1)                      divisors(a)
          (%i2) subst (8, a, %);
          (%o2)                     {1, 2, 4, 8}

     'divisors', aplicada a equações, listas, matrizes e conjuntos, é
     calculada em forma distributiva.

          (%i1) divisors (a = b);
          (%o1)               divisors(a) = divisors(b)
          (%i2) divisors ([a, b, c]);
          (%o2)        [divisors(a), divisors(b), divisors(c)]
          (%i3) divisors (matrix ([a, b], [c, d]));
                            [ divisors(a)  divisors(b) ]
          (%o3)             [                          ]
                            [ divisors(c)  divisors(d) ]
          (%i4) divisors ({a, b, c});
          (%o4)        {divisors(a), divisors(b), divisors(c)}

 -- Função: elementp (<x>, <a>)
     Retorna 'true' se e somente se <x> for um elemento do conjunto <a>.

     'elementp' falha se <a> não for um conjunto literal.

     Exemplos:

          (%i1) elementp (sin(1), {sin(1), sin(2), sin(3)});
          (%o1)                         true
          (%i2) elementp (sin(1), {cos(1), cos(2), cos(3)});
          (%o2)                         false

 -- Função: emptyp (<a>)
     Retorna 'true' se e somente se <a> for o conjunto vazio ou uma
     lista vazia.

     Exemplos:

          (%i1) map (emptyp, [{}, []]);
          (%o1)                     [true, true]
          (%i2) map (emptyp, [a + b, {{}}, %pi]);
          (%o2)                 [false, false, false]

 -- Função: equiv_classes (<s>, <F>)
     Retorna um conjunto das classes de equivalências do conjunto <s>
     com relação à relação de equivalência <F>.

     <F> é uma função de duas variáveis definida sobre o produto
     cartesiano <s> por <s>.  O valor de retorno de <F> é ou 'true' ou
     'false', ou uma expressão <expr> tal que 'is(<expr>)' é ou 'true'
     ou 'false'.

     Quando <F> nõ for uma relação de equivalência, 'equiv_classes'
     aceita-a sem reclamação, mas o resultado é geralmente incorrecto
     nesse caso.

     Exemplos:

     A relação de equivalência é uma expressão lambda a qual retorna
     'true' ou 'false'.

          (%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, lambda ([x, y], is (equal (x, y))));
          (%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}

     A relação de equivalência é o nome de uma função relacional que
     avalia para 'true' ou 'false'.

          (%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, equal);
          (%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}

     As classes de equivalência são números que diferem por um múltiplo
     de 3.

          (%i1) equiv_classes ({1, 2, 3, 4, 5, 6, 7}, lambda ([x, y], remainder (x - y, 3) = 0));
          (%o1)              {{1, 4, 7}, {2, 5}, {3, 6}}

 -- Função: every (<f>, <s>)
 -- Função: every (<f>, <L_1>, ..., <L_n>)

     Retorna 'true' se o predicado <f> for 'true' para todos os
     argumentos fornecidos.

     Dado um conjunto como segundo argumento, 'every(<f>, <s>)' retorna
     'true' se 'is(<f>(<a_i>))' retornar 'true' para todos os <a_i> em
     <s>.  'every' pode ou não avaliar <f> para todos os <a_i> em <s>.
     Uma vez que os conjuntos são desordenados, 'every' pode avaliar
     '<f>(<a_i>)' em qualquer ordem.

     Dada uma ou mais listas como argumentos, 'every(<f>, <L_1>, ...,
     <L_n>)' retorna 'true' se 'is(<f>(<x_1>, ..., <x_n>))' retornar
     'true' para todos os <x_1>, ..., <x_n> em <L_1>, ..., <L_n>,
     respectivamente.  'every' pode ou não avaliar <f> para toda
     combinação <x_1>, ..., <x_n>.  'every' avalia listas na ordem de
     incremento do índice.

     Dado um conjunto vazio '{}' ou uma lista vazia '[]' como
     argumentos, 'every' retorna 'false'.

     Quando o sinalizador global 'maperror' for 'true', todas as listas
     <L_1>, ..., <L_n> deverão ter o mesmo comprimento.  Quando
     'maperror' for falso, as listas dadas como argumentos serão
     efectivamente truncadas para o comprimento da menor lista.

     Os resultados do predicado <f> que avaliarem (via 'is') para algo
     diferente de 'true' ou 'false' são governados através da variável
     global 'prederror'.  Quando 'prederror' for 'true', tais valores
     são tratados como 'false', e o valor de retorno de 'every' é
     'false'.  Quando 'prederror' for 'false', tais valores são tratados
     como 'unknown', e o valor de retorno de 'every' é 'unknown'.

     Exemplos:

     'every' aplicada a um conjunto simples.  O predicado é uma função
     de um argumento.

          (%i1) every (integerp, {1, 2, 3, 4, 5, 6});
          (%o1)                         true
          (%i2) every (atom, {1, 2, sin(3), 4, 5 + y, 6});
          (%o2)                         false

     'every' aplicada a duas listas.  O predicado é uma função de dois
     argumentos.

          (%i1) every ("=", [a, b, c], [a, b, c]);
          (%o1)                         true
          (%i2) every ("#", [a, b, c], [a, b, c]);
          (%o2)                         false

     Predicado <f> que produz resultados diferentes de 'true' ou
     'false', governados por meio da variável global 'prederror'.

          (%i1) prederror : false;
          (%o1)                         false
          (%i2) map (lambda ([a, b], is (a < b)), [x, y, z], [x^2, y^2, z^2]);
          (%o2)              [unknown, unknown, unknown]
          (%i3) every ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o3)                        unknown
          (%i4) prederror : true;
          (%o4)                         true
          (%i5) every ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o5)                         false

 -- Função: extremal_subset (<s>, <f>, max)
 -- Função: extremal_subset (<s>, <f>, min)

     Encontra o subconjunto de <s> para o qual a função <f> toma valores
     máximos ou mínimos.

     'extremal_subset(<s>, <f>, max)' encontra o subconjunto do conjunto
     ou lista <s> para os quais a função real <f> assume um valor
     máximo.

     'extremal_subset(<s>, <f>, min)' encontra o subconjunto do conjunto
     ou lista <s> para a qual a função real <f> assume um valor mínimo.

     Exemplos:

          (%i1) extremal_subset ({-2, -1, 0, 1, 2}, abs, max);
          (%o1)                       {- 2, 2}
          (%i2) extremal_subset ({sqrt(2), 1.57, %pi/2}, sin, min);
          (%o2)                       {sqrt(2)}

 -- Função: flatten (<expr>)

     Colecta argumentos de subexpressões que possuem o mesmo operador
     que <expr> e constrói uma expressão a partir desses argumentos
     colectados.

     Subexpressões nas quais o operador é diferente do operador
     principal de 'expr' são copiadas sem modificação, mesmo se tiverem
     subexpressões com o mesmo operador que 'expr'.

     É possível que 'flatten' construia expressões nas quais o número de
     argumentos difira dos argumentos declarados para um operador; isso
     pode provocar uma mensagem de erro do simplificador ou do
     avaliador.  'flatten' não tenta detectar tais situações.

     Expressões com representações especiais, por exemplo, expressões
     racionais canónicas (CRE), não podem usar a função 'flatten';
     nesses casos, 'flatten' retorna os seus argumentos sem modificação.

     Exemplos:

     Aplicado a uma lista, 'flatten' reúne todos os elementos da lista
     que sejam listas.

          (%i1) flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
          (%o1)            [a, b, c, d, e, f, g, h, i, j]

     Aplicado a um conjunto, 'flatten' reúne todos os elementos do
     conjunto que sejam conjuntos.

          (%i1) flatten ({a, {b}, {{c}}});
          (%o1)                       {a, b, c}
          (%i2) flatten ({a, {[a], {a}}});
          (%o2)                       {a, [a]}

     o efeito de 'flatten' é similar a declarar o operador principal
     para ser enário.  No entanto, 'flatten' não faz efeito sobre
     subexpressões que possuem um operador diferente do operador
     principal, enquanto uma declaração enária faz efeito.

          (%i1) expr: flatten (f (g (f (f (x)))));
          (%o1)                     f(g(f(f(x))))
          (%i2) declare (f, nary);
          (%o2)                         done
          (%i3) ev (expr);
          (%o3)                      f(g(f(x)))

     'flatten' trata funções subscritas da mesma forma que qualquer
     outro operador.

          (%i1) flatten (f[5] (f[5] (x, y), z));
          (%o1)                      f (x, y, z)
                                      5

     É possível que 'flatten' construa expressões nas quais o número de
     argumentos difira dos argumentos declarados para um operador;

          (%i1) 'mod (5, 'mod (7, 4));
          (%o1)                   mod(5, mod(7, 4))
          (%i2) flatten (%);
          (%o2)                     mod(5, 7, 4)
          (%i3) ''%, nouns;
          Wrong number of arguments to mod
           -- an error.  Quitting.  To debug this try debugmode(true);

 -- Função: full_listify (<a>)
     Substitui todo operador de conjunto em <a> por um operador de
     lista, e retorna o resultado.  'fullt_listify' substitui operadores
     de conjunto em subexpressões aninhadas, mesmo se o operador
     principal não for ('set').

     'listify' substitui unicamente o operador principal.

     Exemplos:

          (%i1) full_listify ({a, b, {c, {d, e, f}, g}});
          (%o1)               [a, b, [c, [d, e, f], g]]
          (%i2) full_listify (F (G ({a, b, H({c, d, e})})));
          (%o2)              F(G([a, b, H([c, d, e])]))

 -- Função: fullsetify (<a>)
     Quando <a> for uma lista, substitui o operador de lista por um
     operador de conjunto, e aplica 'fullsetify' a cada elemento que for
     um conjunto.  Quando <a> não for uma lista, o resultado é <a> na
     sua forma original e sem modificações.

     'setify' substitui unicamente o operador principal.

     Exemplos:

     Na linha (%o2), o argumento de 'f' não é convertido para um
     conjunto porque o operador principal de 'f([b])' não é uma lista.

          (%i1) fullsetify ([a, [a]]);
          (%o1)                       {a, {a}}
          (%i2) fullsetify ([a, f([b])]);
          (%o2)                      {a, f([b])}

 -- Função: identity (<x>)

     Retorna <x> para qualquer argumento <x>.

     Exemplos:

     'identity' pode ser usado como um predicado quando os argumentos
     forem valores Booleanos.

          (%i1) every (identity, [true, true]);
          (%o1)                         true

 -- Função: integer_partitions (<n>)
 -- Função: integer_partitions (<n>, <len>)

     Calcula partições inteiras de <n>, isto é, listas de inteiros cuja
     soma dos elementos de cada lista é <n>.

     'integer_partitions(<n>)' encontra o conjunto de todas as partições
     do inteiro <n>.  Cada partição é uma lista ordenada do maior para o
     menor.

     'integer_partitions(<n>, <len>)' encontra todas as partições com
     comprimento <len> ou menor; nesse caso, serão adicionados zeros ao
     final de cada partição de comprimento menor que <len>, para fazer
     com que todas as partições tenham exactamente <len> termos.  Cada
     partição é uma lista ordenada do maior para o menor.

     Uma lista [a_1, ..., a_m] é uma partição de um inteiro não negativo
     n quando: (1) cada a_i é um inteiro não nulo, e (2) a_1 + ... + a_m
     = n. Dessa forma, 0 não tem partições.

     Exemplos:

          (%i1) integer_partitions (3);
          (%o1)               {[1, 1, 1], [2, 1], [3]}
          (%i2) s: integer_partitions (25)$
          (%i3) cardinality (s);
          (%o3)                         1958
          (%i4) map (lambda ([x], apply ("+", x)), s);
          (%o4)                         {25}
          (%i5) integer_partitions (5, 3);
          (%o5) {[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]}
          (%i6) integer_partitions (5, 2);
          (%o6)               {[3, 2], [4, 1], [5, 0]}

     Para encontrar todas as partições que satisfazem uma condição, use
     a função 'subset'; aqui está um exemplo que encontra todas as
     partições de 10 cujos elementos da lista são números primos.

          (%i1) s: integer_partitions (10)$
          (%i2) cardinality (s);
          (%o2)                          42
          (%i3) xprimep(x) := integerp(x) and (x > 1) and primep(x)$
          (%i4) subset (s, lambda ([x], every (xprimep, x)));
          (%o4) {[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]}

 -- Função: intersect (<a_1>, ..., <a_n>)

     'intersect' é o mesmo que 'intersection', como veremos.

 -- Função: intersection (<a_1>, ..., <a_n>)
     Retorna um conjunto contendo os elementos que são comuns aos
     conjuntos <a_1> até <a_n>.

     'intersection' falha se qualquer dos argumentos não for um conjunto
     literal.

     Exemplos:

          (%i1) S_1 : {a, b, c, d};
          (%o1)                     {a, b, c, d}
          (%i2) S_2 : {d, e, f, g};
          (%o2)                     {d, e, f, g}
          (%i3) S_3 : {c, d, e, f};
          (%o3)                     {c, d, e, f}
          (%i4) S_4 : {u, v, w};
          (%o4)                       {u, v, w}
          (%i5) intersection (S_1, S_2);
          (%o5)                          {d}
          (%i6) intersection (S_2, S_3);
          (%o6)                       {d, e, f}
          (%i7) intersection (S_1, S_2, S_3);
          (%o7)                          {d}
          (%i8) intersection (S_1, S_2, S_3, S_4);
          (%o8)                          {}

 -- Função: kron_delta (<x>, <y>)

     Representa a função delta de Kronecker.

     'kron_delta' simplifica para 1 quando <x> e <y> forem idênticos ou
     equivalentes, e simplifica para 0 quando <x> e <y> não forem
     equivalentes.  De outra forma, se não for certo que <x> e <y> são
     equivalentes, 'kron_delta' simplificará para uma expressão
     substantiva.  'kron_delta' implementa uma política de segurança
     para expressões em ponto flutuante: se a diferença '<x> - <y>' for
     um número em ponto flutuante, 'kron_delta' simplifica para uma
     expressão substantiva quando <x> for aparentemente equivalente a
     <y>.

     Especificamente, 'kron_delta(<x>, <y>)' simplifica para 1 quando
     'is(x = y)' for 'true'.  'kron_delta' também simplifica para 1
     quando 'sign(abs(<x> - <y>))' for 'zero' e '<x> - <y>' não for um
     número em ponto flutuante (e também não for um número de precisão
     simples em ponto flutuante nem um número de precisão dupla em poto
     flutuante, isto é, não for um bigfloat).  'kron_delta' simplifica
     para 0 quando 'sign(abs(<x> - <y>))' for 'pos'.

     Caso contrário, 'sign(abs(<x> - <y>))' é diferente de 'pos' ou
     'zero', ou é 'zero' e '<x> - <y>' é um número em ponto flutuante.
     Nesses casos, 'kron_delta' retorna um expressão substantiva.

     'kron_delta' é declarada como sendo simétrica.  Isto é,
     'kron_delta(<x>, <y>)' é igual a 'kron_delta(<y>, <x>)'.

     Exemplos:

     Os argumentos de 'kron_delta' são idênticos.  'kron_delta'
     simplifica para 1.

          (%i1) kron_delta (a, a);
          (%o1)                           1
          (%i2) kron_delta (x^2 - y^2, x^2 - y^2);
          (%o2)                           1
          (%i3) float (kron_delta (1/10, 0.1));
          (%o3)                           1

     Os argumentos de 'kron_delta' são equivalentes, e a diferença entre
     eles não é um número em ponto flutuante.  'kron_delta' simplifica
     para 1.

          (%i1) assume (equal (x, y));
          (%o1)                     [equal(x, y)]
          (%i2) kron_delta (x, y);
          (%o2)                           1

     Os argumentos de 'kron_delta' não são equivalentes.  'kron_delta'
     simplifica para 0.

          (%i1) kron_delta (a + 1, a);
          (%o1)                           0
          (%i2) assume (a > b)$
          (%i3) kron_delta (a, b);
          (%o3)                           0
          (%i4) kron_delta (1/5, 0.7);
          (%o4)                           0

     Os argumentos de 'kron_delta' podem ou não ser equivalentes.
     'kron_delta' simplifica para uma expressão substantiva.

          (%i1) kron_delta (a, b);
          (%o1)                   kron_delta(a, b)
          (%i2) assume(x >= y)$
          (%i3) kron_delta (x, y);
          (%o3)                   kron_delta(x, y)

     Os argumentos de 'kron_delta' são equivalentes, mas a diferença
     entre eles é um número em ponto flutuante.  'kron_delta' simplifica
     para uma expressão substantiva.

          (%i1) 1/4 - 0.25;
          (%o1)                          0.0
          (%i2) 1/10 - 0.1;
          (%o2)                          0.0
          (%i3) 0.25 - 0.25b0;
          Warning:  Float to bigfloat conversion of 0.25
          (%o3)                         0.0b0
          (%i4) kron_delta (1/4, 0.25);
                                            1
          (%o4)                  kron_delta(-, 0.25)
                                            4
          (%i5) kron_delta (1/10, 0.1);
                                            1
          (%o5)                  kron_delta(--, 0.1)
                                            10
          (%i6) kron_delta (0.25, 0.25b0);
          Warning:  Float to bigfloat conversion of 0.25
          (%o6)               kron_delta(0.25, 2.5b-1)

     'kron_delta' é simétrica.

          (%i1) kron_delta (x, y);
          (%o1)                   kron_delta(x, y)
          (%i2) kron_delta (y, x);
          (%o2)                   kron_delta(x, y)
          (%i3) kron_delta (x, y) - kron_delta (y, x);
          (%o3)                           0
          (%i4) is (equal (kron_delta (x, y), kron_delta (y, x)));
          (%o4)                         true
          (%i5) is (kron_delta (x, y) = kron_delta (y, x));
          (%o5)                         true

 -- Função: listify (<a>)

     Retorna uma lista contendo os elementos de <a> quando <a> for um
     conjunto.  De outra forma, 'listify' retorna <a>.

     'full_listify' substitui todos os operadores de conjunto em <a> por
     operadores de lista.

     Exemplos:

          (%i1) listify ({a, b, c, d});
          (%o1)                     [a, b, c, d]
          (%i2) listify (F ({a, b, c, d}));
          (%o2)                    F({a, b, c, d})

 -- Função: lreduce (<F>, <s>)
 -- Função: lreduce (<F>, <s>, <s_0>)

     Extende a função de dois argumentos <F> para uma função de 'n'
     argumentos, usando composição, onde <s> é uma lista.

     'lreduce(<F>, <s>)' retorna 'F(... F(F(s_1, s_2), s_3), ... s_n)'.
     Quando o argumento opcional <s_0> estiver presente, o resultado é
     equivalente a 'lreduce(<F>, cons(<s_0>, <s>))'.

     A função <F> é aplicada primeiro aos elementos mais à _esquerda_ de
     lista; daí o nome "lreduce".

     Veja também 'rreduce', 'xreduce', e 'tree_reduce'.

     Exemplos:

     'lreduce' sem o argumento opcional.

          (%i1) lreduce (f, [1, 2, 3]);
          (%o1)                     f(f(1, 2), 3)
          (%i2) lreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(f(f(1, 2), 3), 4)

     'lreduce' com o argumento opcional.

          (%i1) lreduce (f, [1, 2, 3], 4);
          (%o1)                  f(f(f(4, 1), 2), 3)

     'lreduce' aplicada a operadores binários internos do Maxima '/' é o
     operador de divisão.

          (%i1) lreduce ("^", args ({a, b, c, d}));
                                         b c d
          (%o1)                       ((a ) )
          (%i2) lreduce ("/", args ({a, b, c, d}));
                                          a
          (%o2)                         -----
                                        b c d

 -- Função: makeset (<expr>, <x>, <s>)

     Retorna um conjunto com elementos gerados a partir da expressão
     <expr>, onde <x> é uma lista de variáveis em <expr>, e <s>é um
     conjunto ou lista de listas.  Para gerar cada elemento do conjunto,
     <expr> é avaliada com as variáveis <x> substituídas, em paralelo,
     por elementos de <s>.

     Cada elemento de <s> deve ter o mesmo comprimento que <x>.  A lista
     de variáveis <x> deve ser uma lista de símbolos, sem índices.
     Mesmo se existir somente um símbolo, <x> deve ser uma lista de um
     elemento, e cada elemento de <s> deve ser uma lista de um elemento.

     Veja também 'makelist'.

     Exemplos:

          (%i1) makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
                                     1  2  3  4
          (%o1)                     {-, -, -, -}
                                     a  b  c  d
          (%i2) S : {x, y, z}$
          (%i3) S3 : cartesian_product (S, S, S);
          (%o3) {[x, x, x], [x, x, y], [x, x, z], [x, y, x], [x, y, y],
          [x, y, z], [x, z, x], [x, z, y], [x, z, z], [y, x, x],
          [y, x, y], [y, x, z], [y, y, x], [y, y, y], [y, y, z],
          [y, z, x], [y, z, y], [y, z, z], [z, x, x], [z, x, y],
          [z, x, z], [z, y, x], [z, y, y], [z, y, z], [z, z, x],
          [z, z, y], [z, z, z]}
          (%i4) makeset (i + j + k, [i, j, k], S3);
          (%o4) {3 x, 3 y, y + 2 x, 2 y + x, 3 z, z + 2 x, z + y + x,
                                                 z + 2 y, 2 z + x, 2 z + y}
          (%i5) makeset (sin(x), [x], {[1], [2], [3]});
          (%o5)               {sin(1), sin(2), sin(3)}

 -- Função: moebius (<n>)

     Representa a função de Moebius.

     Quando <n> for o produto de k primos distintos, 'moebius(<n>)'
     simplifica para (-1)^k; quando <n> = 1, simplifica para 1; e
     simplifica para 0 para todos os outros inteiros positivos.

     'moebius', aplicada a equações, listas, matrizes e conjuntos, é
     calculada em forma distributiva.

     Exemplos:

          (%i1) moebius (1);
          (%o1)                           1
          (%i2) moebius (2 * 3 * 5);
          (%o2)                          - 1
          (%i3) moebius (11 * 17 * 29 * 31);
          (%o3)                           1
          (%i4) moebius (2^32);
          (%o4)                           0
          (%i5) moebius (n);
          (%o5)                      moebius(n)
          (%i6) moebius (n = 12);
          (%o6)                    moebius(n) = 0
          (%i7) moebius ([11, 11 * 13, 11 * 13 * 15]);
          (%o7)                      [- 1, 1, 1]
          (%i8) moebius (matrix ([11, 12], [13, 14]));
                                     [ - 1  0 ]
          (%o8)                      [        ]
                                     [ - 1  1 ]
          (%i9) moebius ({21, 22, 23, 24});
          (%o9)                      {- 1, 0, 1}

 -- Função: multinomial_coeff (<a_1>, ..., <a_n>)
 -- Função: multinomial_coeff ()

     Calcula o coeficiente multinomial.

     Quando cada <a_k> for um inteiro não negativo, o coeficiente
     multinomial indica o número de formas possíveis de colocar '<a_1> +
     ... + <a_n>' objectos distintos em n caixas com <a_k> elementos na
     k'ésima caixa.  Em geral, 'multinomial_coeff (<a_1>, ..., <a_n>)'
     calcula '(<a_1> + ... + <a_n>)!/(<a_1>! ... <a_n>!)'.

     'multinomial_coeff()' (sem argumentos) produz 1.

     'minfactorial' poderá conseguir simplificar o valor calculado por
     'multinomial_coeff'.

     Exemplos:

          (%i1) multinomial_coeff (1, 2, x);
                                      (x + 3)!
          (%o1)                       --------
                                        2 x!
          (%i2) minfactorial (%);
                               (x + 1) (x + 2) (x + 3)
          (%o2)                -----------------------
                                          2
          (%i3) multinomial_coeff (-6, 2);
                                       (- 4)!
          (%o3)                       --------
                                      2 (- 6)!
          (%i4) minfactorial (%);
          (%o4)                          10

 -- Função: num_distinct_partitions (<n>)
 -- Função: num_distinct_partitions (<n>, list)

     Calcula o n;umero de partições de inteiros distintos de <n> quando
     <n> for um inteiro não negativo.  De outra forma,
     'num_distinct_partitions' retorna uma expressão substantiva.

     'num_distinct_partitions(<n>, list)' retorna uma lista do número de
     partições distintas de 1, 2, 3, ..., <n>.

     Uma partição distinta de <n> é uma lista de inteiros positivos
     distintos k_1, ..., k_m tais que <n> = k_1 + ... + k_m.

     Exemplos:

          (%i1) num_distinct_partitions (12);
          (%o1)                          15
          (%i2) num_distinct_partitions (12, list);
          (%o2)      [1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 12, 15]
          (%i3) num_distinct_partitions (n);
          (%o3)              num_distinct_partitions(n)

 -- Função: num_partitions (<n>)
 -- Função: num_partitions (<n>, list)

     Calcula o número das partições inteiras de <n> quando <n> for um
     inteiro não negativo.  De outra forma, 'num_partitions' retorna uma
     expressão substantiva.

     'num_partitions(<n>, list)' retorna uma lista do número de
     partições inteiras de 1, 2, 3, ..., <n>.

     Para um inteiro não negativo <n>, 'num_partitions(<n>)' é igual a
     'cardinality(integer_partitions(<n>))'; todavia, 'num_partitions'
     não constrói actualmente o conjunto das partições, nesse sentido
     'num_partitions' é mais rápida.

     Exemplos:

          (%i1) num_partitions (5) = cardinality (integer_partitions (5));
          (%o1)                         7 = 7
          (%i2) num_partitions (8, list);
          (%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
          (%i3) num_partitions (n);
          (%o3)                   num_partitions(n)

 -- Função: partition_set (<a>, <f>)

     Partições do conjunto <a> que satisfazem o predicado <f>.

     'partition_set' retorna uma lista de dois conjuntos.  O primeiro
     conjunto compreende os elementos de <a> para os quais <f> avalia
     para 'false', e o segundo conjunto compreende quaisquer outros
     elementos de <a>.  'partition_set' não aplica 'is' ao valor de
     retorno de <f>.

     'partition_set' reclama se <a> não for um conjunto literal.

     Veja também 'subset'.

     Exemplos:

          (%i1) partition_set ({2, 7, 1, 8, 2, 8}, evenp);
          (%o1)                   [{1, 7}, {2, 8}]
          (%i2) partition_set ({x, rat(y), rat(y) + z, 1}, lambda ([x], ratp(x)));
          (%o2)/R/              [{1, x}, {y, y + z}]

 -- Função: permutations (<a>)

     Retorna um conjunto todas as permutações distintas dos elementos da
     lista ou do conjunto <a>.  Cada permutação é uma lista, não um
     conjunto.

     Quando <a> for uma lista, elementos duplicados de <a> são incluídos
     nas permutações.

     'permutations' reclama se <a> não for um conjunto literal ou uma
     lista literal.

     Exemplos:

          (%i1) permutations ([a, a]);
          (%o1)                       {[a, a]}
          (%i2) permutations ([a, a, b]);
          (%o2)           {[a, a, b], [a, b, a], [b, a, a]}

 -- Função: powerset (<a>)
 -- Função: powerset (<a>, <n>)

     Retorna o conjunto de todos os dubconjuntos de <a>, ou um
     subconjunto de <a>.

     'powerset(<a>)' retorna o conjunto de todos os subconjuntos do
     conjunto <a>.  'powerset(<a>)' tem '2^cardinality(<a>)' elementos.

     'powerset(<a>, <n>)' retorna o conjunto de todos os subconjuntos de
     <a> que possuem cardinalidade <n>.

     'powerset' reclama se <a> não for um conjunto literal, ou se <n>
     não for um inteiro não negativo.

     Exemplos:

          (%i1) powerset ({a, b, c});
          (%o1) {{}, {a}, {a, b}, {a, b, c}, {a, c}, {b}, {b, c}, {c}}
          (%i2) powerset ({w, x, y, z}, 4);
          (%o2)                    {{w, x, y, z}}
          (%i3) powerset ({w, x, y, z}, 3);
          (%o3)     {{w, x, y}, {w, x, z}, {w, y, z}, {x, y, z}}
          (%i4) powerset ({w, x, y, z}, 2);
          (%o4)   {{w, x}, {w, y}, {w, z}, {x, y}, {x, z}, {y, z}}
          (%i5) powerset ({w, x, y, z}, 1);
          (%o5)                 {{w}, {x}, {y}, {z}}
          (%i6) powerset ({w, x, y, z}, 0);
          (%o6)                         {{}}

 -- Função: rreduce (<F>, <s>)
 -- Função: rreduce (<F>, <s>, <s_{n + 1}>)

     Extende a função de dois argumentos <F> para uma função de <n>
     argumentos usando composição de funções, onde <s> é uma lista.

     'rreduce(<F>, <s>)' retorna 'F(s_1, ... F(s_{n - 2}, F(s_{n - 1},
     s_n)))'.  Quando o argumento opcional <s_{n + 1}> estiver presente,
     o resultado é equivalente a 'rreduce(<F>, endcons(<s_{n + 1}>,
     <s>))'.

     A função <F> é primeiro aplicada à lista de elementos mais à
     direita - rightmost, daí o nome "rreduce".

     Veja também 'lreduce', 'tree_reduce', e 'xreduce'.

     Exemplos:

     'rreduce' sem o argumento opcional.

          (%i1) rreduce (f, [1, 2, 3]);
          (%o1)                     f(1, f(2, 3))
          (%i2) rreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(1, f(2, f(3, 4)))

     'rreduce' com o argumento opcional.

          (%i1) rreduce (f, [1, 2, 3], 4);
          (%o1)                  f(1, f(2, f(3, 4)))

     'rreduce' aplicada a operadores de dois argumentos internos (
     definidos por padrão) ao Maxima.  '/' é o operadro de divisão.

          (%i1) rreduce ("^", args ({a, b, c, d}));
                                           d
                                          c
                                         b
          (%o1)                         a
          (%i2) rreduce ("/", args ({a, b, c, d}));
                                         a c
          (%o2)                          ---
                                         b d

 -- Função: setdifference (<a>, <b>)

     Retorna um conjunto contendo os elementos no conjunto <a> que não
     estãono conjunto <b>.

     'setdifference' reclama se ou <a> ou <b> não for um conjunto
     literal.

     Exemplos:

          (%i1) S_1 : {a, b, c, x, y, z};
          (%o1)                  {a, b, c, x, y, z}
          (%i2) S_2 : {aa, bb, c, x, y, zz};
          (%o2)                 {aa, bb, c, x, y, zz}
          (%i3) setdifference (S_1, S_2);
          (%o3)                       {a, b, z}
          (%i4) setdifference (S_2, S_1);
          (%o4)                     {aa, bb, zz}
          (%i5) setdifference (S_1, S_1);
          (%o5)                          {}
          (%i6) setdifference (S_1, {});
          (%o6)                  {a, b, c, x, y, z}
          (%i7) setdifference ({}, S_1);
          (%o7)                          {}

 -- Função: setequalp (<a>, <b>)

     Retorna 'true' se os conjuntos <a> e <b> possuirem o mesmo número
     de elementos e 'is(<x> = <y>)' for 'true' para 'x' nos elementos de
     <a> e 'y' nos elementos de <b>, considerados na ordem determinada
     por 'listify'.  De outra forma, 'setequalp' retorna 'false'.

     Exemplos:

          (%i1) setequalp ({1, 2, 3}, {1, 2, 3});
          (%o1)                         true
          (%i2) setequalp ({a, b, c}, {1, 2, 3});
          (%o2)                         false
          (%i3) setequalp ({x^2 - y^2}, {(x + y) * (x - y)});
          (%o3)                         false

 -- Função: setify (<a>)

     Constrói um conjunto de elementos a partir da lista <a>.  Elementos
     duplicados da lista <a> são apagados e os elementos são ordenados
     de acordo com o predicado 'orderlessp'.

     'setify' reclama se <a> não for uma lista literal.

     Exemplos:

          (%i1) setify ([1, 2, 3, a, b, c]);
          (%o1)                  {1, 2, 3, a, b, c}
          (%i2) setify ([a, b, c, a, b, c]);
          (%o2)                       {a, b, c}
          (%i3) setify ([7, 13, 11, 1, 3, 9, 5]);
          (%o3)                {1, 3, 5, 7, 9, 11, 13}

 -- Função: setp (<a>)

     Retorna 'true' se e somente se <a> for um conjunto na interpretação
     do Maxima.

     'setp' retorna 'true' para conjuntos não simplificados (isto é,
     conjuntos com elementos redundantes) e também para conjuntos
     simplificados.

     'setp' é equivalente à função do Maxima 'setp(a) := not atom(a) and
     op(a) = 'set'.

     Exemplos:

          (%i1) simp : false;
          (%o1)                         false
          (%i2) {a, a, a};
          (%o2)                       {a, a, a}
          (%i3) setp (%);
          (%o3)                         true

 -- Função: set_partitions (<a>)
 -- Função: set_partitions (<a>, <n>)

     Retorna o conjunto de todas as partições de <a>, ou um subconjunto
     daquele conjunto de partições.

     'set_partitions(<a>, <n>)' retorna um conjunto de todas as
     decomposições de <a> em <n> subconjutnos disjuntos não vazios.

     'set_partitions(<a>)' retorna o conjunto de todas as partições.

     'stirling2' retorna a cardinalidade de um conjuntode partições de
     um conjunto.

     Um conjunto de conjuntos P é uma partição de um conjunto S quando

       1. cada elemento de P é um conjunto não vazio,
       2. elementos distintos de P são disjuntos,
       3. a união dos elementos de P é igual a S.

     Exemplos:

     O conjunto vazio é uma partição de si mesmo, as ondições 1 e 2 são
     "vaziamente" verdadeiras.

          (%i1) set_partitions ({});
          (%o1)                         {{}}

     A cardinalidade do conjunto de partições de um conjunto pode ser
     encontrada usando 'stirling2'.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) cardinality(p) = stirling2 (6, 3);
          (%o3)                        90 = 90

     Cada elemento de 'p' pode ter <n> = 3 elementos; vamos verificar.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) map (cardinality, p);
          (%o3)                          {3}

     Finalmente, para cada elementos de 'p', a união de seus elementos
     possivelmente será igua a 's'; novamente vamos comprovar.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) map (lambda ([x], apply (union, listify (x))), p);
          (%o3)                 {{0, 1, 2, 3, 4, 5}}

 -- Função: some (<f>, <a>)
 -- Função: some (<f>, <L_1>, ..., <L_n>)

     Retorna 'true' se o predicado <f> for 'true' para um ou mais
     argumentos dados.

     Given one set as the second argument, 'some(<f>, <s>)' returns
     'true' if 'is(<f>(<a_i>))' returns 'true' for one or more <a_i> in
     <s>.  'some' may or may not evaluate <f> for all <a_i> in <s>.
     Since sets are unordered, 'some' may evaluate '<f>(<a_i>)' in any
     order.

     Dadas uma ou mais listas como argumentos, 'some(<f>, <L_1>, ...,
     <L_n>)' retorna 'true' se 'is(<f>(<x_1>, ..., <x_n>))' retornar
     'true' para um ou mais <x_1>, ..., <x_n> em <L_1>, ..., <L_n>,
     respectivamente.  'some' pode ou não avaliar <f> para algumas
     combinações <x_1>, ..., <x_n>.  'some' avalia listas na ordem do
     índice de incremento.

     Dado um conjunto vazio '{}' ou uma lista vazia '[]' como
     argumentos, 'some' retorna 'false'.

     Quando o sinalizador global 'maperror' for 'true', todas as listas
     <L_1>, ..., <L_n> devem ter obrigatóriamente comprimentos iguais.
     Quando 'maperror' for 'false', argumentos do tipo lista são
     efectivamente truncados para o comprimento da menor lista.

     Retorna o valor de um predicado <f> o qual avalia (por meio de
     'is') para alguma coisa outra que não 'true' ou 'false' e são
     governados pelo sinalizador global 'prederror'.  Quando 'prederror'
     for 'true', tais valores são tratados como 'false'.  Quando
     'prederror' for 'false', tais valores são tratados como 'unknown'
     (desconhecidos).

     Exemplos:

     'some' aplicado a um conjunto simples.  O predicado é uma função de
     um argumento.

          (%i1) some (integerp, {1, 2, 3, 4, 5, 6});
          (%o1)                         true
          (%i2) some (atom, {1, 2, sin(3), 4, 5 + y, 6});
          (%o2)                         true

     'some' aplicada a duas listas.  O predicado é uma função de dois
     argumentos.

          (%i1) some ("=", [a, b, c], [a, b, c]);
          (%o1)                         true
          (%i2) some ("#", [a, b, c], [a, b, c]);
          (%o2)                         false

     Retorna o valor do predicado <f> o qual avalia para alguma coisa
     que não 'true' ou 'false' e são governados através do sinalizador
     global 'prederror'.

          (%i1) prederror : false;
          (%o1)                         false
          (%i2) map (lambda ([a, b], is (a < b)), [x, y, z], [x^2, y^2, z^2]);
          (%o2)              [unknown, unknown, unknown]
          (%i3) some ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o3)                        unknown
          (%i4) some ("<", [x, y, z], [x^2, y^2, z + 1]);
          (%o4)                         true
          (%i5) prederror : true;
          (%o5)                         true
          (%i6) some ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o6)                         false
          (%i7) some ("<", [x, y, z], [x^2, y^2, z + 1]);
          (%o7)                         true

 -- Função: stirling1 (<n>, <m>)

     Representa o número de Stirling de primeiro tipo.

     Quando <n> e <m> forem não negativos inteiros, a magnitude de
     'stirling1 (<n>, <m>)' é o número de permutações de um conjunto com
     <n> elementos que possui <m> ciclos.  Para detalhes, veja Graham,
     Knuth e Patashnik Concrete Mathematics.  Maxima utiliza uma relação
     recursiva para definir 'stirling1 (<n>, <m>)' para <m> menor que 0;
     'stirling1' não é definida para <n> menor que 0 e para argumentos
     não inteiros.

     'stirling1' é uma função de simplificação.  Maxima conhece as
     seguintes identidades:

       1. stirling1(0, n) = kron_delta(0, n) (Ref.  [1])
       2. stirling1(n, n) = 1 (Ref.  [1])
       3. stirling1(n, n - 1) = binomial(n, 2) (Ref.  [1])
       4. stirling1(n + 1, 0) = 0 (Ref.  [1])
       5. stirling1(n + 1, 1) = n! (Ref.  [1])
       6. stirling1(n + 1, 2) = 2^n - 1 (Ref.  [1])

     Essas identidades são aplicadas quando os argumentos forem inteiros
     literais ou símbolos declarados como inteiros, e o primeiro
     argumento for não negativo.  'stirling1' não simplififca para
     argumentos não inteiros.

     Referências:

     [1] Donald Knuth, The Art of Computer Programming, terceira edição,
     Volume 1, Seção 1.2.6, Equações 48, 49, e 50.

     Exemplos:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n, n);
          (%o3)                           1

     'stirling1' não simplifica para argumentos não inteiros.

          (%i1) stirling1 (sqrt(2), sqrt(2));
          (%o1)              stirling1(sqrt(2), sqrt(2))

     Maxima aplica identidades a 'stirling1'.

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n + 1, n);
                                      n (n + 1)
          (%o3)                       ---------
                                          2
          (%i4) stirling1 (n + 1, 1);
          (%o4)                          n!

 -- Função: stirling2 (<n>, <m>)

     Representa o número de Stirling de segundo tipo.

     Quando <n> e <m> forem inteiros não negativos, 'stirling2 (<n>,
     <m>)' é o número de maneiras através dos quais um conjunto com
     cardinalidade <n> pode ser particionado em <m> subconjuntos
     disjuntos.  Maxima utiliza uma relação recursiva para definir
     'stirling2 (<n>, <m>)' para <m> menor que 0; 'stirling2' é
     indefinida para <n> menor que 0 e para argumentos não inteiros.

     'stirling2' é uma função de simplificação.  Maxima conhece as
     seguintes identidades.

       1. stirling2(0, n) = kron_delta(0, n) (Ref.  [1])
       2. stirling2(n, n) = 1 (Ref.  [1])
       3. stirling2(n, n - 1) = binomial(n, 2) (Ref.  [1])
       4. stirling2(n + 1, 1) = 1 (Ref.  [1])
       5. stirling2(n + 1, 2) = 2^n - 1 (Ref.  [1])
       6. stirling2(n, 0) = kron_delta(n, 0) (Ref.  [2])
       7. stirling2(n, m) = 0 when m > n (Ref.  [2])
       8. stirling2(n, m) = sum((-1)^(m - k) binomial(m k) k^n,i,1,m) /
          m! onde m e n são inteiros, e n é não negativo.  (Ref.  [3])

     Essas identidades são aplicadas quando os argumentos forem inteiros
     literais ou símbolos declarados como inteiros, e o primeiro
     argumento for não negativo.  'stirling2' não simplifica para
     argumentos não inteiros.

     Referências:

     [1] Donald Knuth.  The Art of Computer Programming, terceira
     edição, Volume 1, Seção 1.2.6, Equações 48, 49, e 50.

     [2] Graham, Knuth, e Patashnik.  Concrete Mathematics, Tabela 264.

     [3] Abramowitz e Stegun.  Handbook of Mathematical Functions, Seção
     24.1.4.

     Exemplos:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n, n);
          (%o3)                           1

     'stirling2' não simplifica para argumentos não inteiros.

          (%i1) stirling2 (%pi, %pi);
          (%o1)                  stirling2(%pi, %pi)

     Maxima aplica identidades a 'stirling2'.

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n + 9, n + 8);
                                   (n + 8) (n + 9)
          (%o3)                    ---------------
                                          2
          (%i4) stirling2 (n + 1, 2);
                                        n
          (%o4)                        2  - 1

 -- Função: subset (<a>, <f>)

     Retorna o subconjuntode um conjunto <a> que satisfaz o predicado
     <f>.

     'subset' returns um conjunto which comprises the elements of <a>
     for which <f> returns anything other than 'false'.  'subset' does
     not apply 'is' to the return value of <f>.

     'subset' reclama se <a> não for um conjunto literal.

     See also 'partition_set'.

     Exemplos:

          (%i1) subset ({1, 2, x, x + y, z, x + y + z}, atom);
          (%o1)                     {1, 2, x, z}
          (%i2) subset ({1, 2, 7, 8, 9, 14}, evenp);
          (%o2)                      {2, 8, 14}

 -- Função: subsetp (<a>, <b>)

     Retorna 'true' se e somente se o conjunto <a> for um subconjunto de
     <b>.

     'subsetp' reclama se ou <a> ou <b> não forem um conjunto literal.

     Exemplos:

          (%i1) subsetp ({1, 2, 3}, {a, 1, b, 2, c, 3});
          (%o1)                         true
          (%i2) subsetp ({a, 1, b, 2, c, 3}, {1, 2, 3});
          (%o2)                         false

 -- Função: symmdifference (<a_1>, ..., <a_n>)

     Retorna a diferença simétrica, isto é, o conjunto dos elemetnos que
     ocorrem em exactamente um conjunto <a_k>.

     Given two arguments, 'symmdifference(<a>, <b>)' is the same as
     'union(setdifference(<a>, <b>), setdifference(<b>, <a>))'.

     'symmdifference' reclama se any argument não for um conjunto
     literal.

     Exemplos:

          (%i1) S_1 : {a, b, c};
          (%o1)                       {a, b, c}
          (%i2) S_2 : {1, b, c};
          (%o2)                       {1, b, c}
          (%i3) S_3 : {a, b, z};
          (%o3)                       {a, b, z}
          (%i4) symmdifference ();
          (%o4)                          {}
          (%i5) symmdifference (S_1);
          (%o5)                       {a, b, c}
          (%i6) symmdifference (S_1, S_2);
          (%o6)                        {1, a}
          (%i7) symmdifference (S_1, S_2, S_3);
          (%o7)                        {1, z}
          (%i8) symmdifference ({}, S_1, S_2, S_3);
          (%o8)                        {1, z}

 -- Função: tree_reduce (<F>, <s>)
 -- Função: tree_reduce (<F>, <s>, <s_0>)

     Extende a função binária <F> a uma função enária através de
     composição, onde <s> é um conjunto ou uma lista.

     'tree_reduce' é equivalente ao seguinte: Aplicar <F> a sucessivos
     pares de elementos para formar uma nova lista '[<F>(<s_1>, <s_2>),
     <F>(<s_3>, <s_4>), ...]', mantendo o elemento final inalterado caso
     haja um número ímpar de elementos.  Repetindo então o processo até
     que a lista esteja reduzida a um elemento simples, o qual é o valor
     de retorno da função.

     Quando o argumento opcional <s_0> estiver presente, o resultado é
     equivalente a 'tree_reduce(<F>, cons(<s_0>, <s>)'.

     Para adições em ponto flutuante, 'tree_reduce' pode retornar uma
     soma que possui um menor ero de arredondamento que 'rreduce' ou
     'lreduce'.

     Os elementos da lista <s> e os resultados parciais podem ser
     arranjados em uma árvore binária de profundidade mínima, daí o nome
     "tree_reduce".

     Exemplos:

     'tree_reduce' aplicada a uma lista com um número par de elementos.

          (%i1) tree_reduce (f, [a, b, c, d]);
          (%o1)                  f(f(a, b), f(c, d))

     'tree_reduce' aplicada a uma lista com um número ímpar de
     elementos.

          (%i1) tree_reduce (f, [a, b, c, d, e]);
          (%o1)               f(f(f(a, b), f(c, d)), e)

 -- Função: union (<a_1>, ..., <a_n>)
     Retorna a união dos conjuntos de <a_1> a <a_n>.

     'union()' (sem argumentos) retorna o conjunto vazio.

     'union' reclama se qualquer argumento não for um conjunto literal.

     Exemplos:

          (%i1) S_1 : {a, b, c + d, %e};
          (%o1)                   {%e, a, b, d + c}
          (%i2) S_2 : {%pi, %i, %e, c + d};
          (%o2)                 {%e, %i, %pi, d + c}
          (%i3) S_3 : {17, 29, 1729, %pi, %i};
          (%o3)                {17, 29, 1729, %i, %pi}
          (%i4) union ();
          (%o4)                          {}
          (%i5) union (S_1);
          (%o5)                   {%e, a, b, d + c}
          (%i6) union (S_1, S_2);
          (%o6)              {%e, %i, %pi, a, b, d + c}
          (%i7) union (S_1, S_2, S_3);
          (%o7)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}
          (%i8) union ({}, S_1, S_2, S_3);
          (%o8)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}

 -- Função: xreduce (<F>, <s>)
 -- Função: xreduce (<F>, <s>, <s_0>)

     Extendendo a função <F> para uma função enária por composição, ou,
     se <F> já for enária, aplica-se <F> a <s>.  Quando <F> não for
     enária, 'xreduce' funciona da mesma forma que 'lreduce'.  O
     argumento <s> é uma lista.

     Funções sabidamente enárias inclui adição '+', multiplicação '*',
     'and', 'or', 'max', 'min', e 'append'.  Funções podem também serem
     declaradas enárias por meio de 'declare(<F>, nary)'.  Para essas
     funções, é esperado que 'xreduce' seja mais rápida que ou 'rreduce'
     ou 'lreduce'.

     Quando o argumento opcional <s_0> estiver presente, o resultado é
     equivalente a 'xreduce(<s>, cons(<s_0>, <s>))'.

     Adições em ponto flutuante não são exactamente associativas; quando
     a associatividade ocorrer, 'xreduce' aplica a adição enária do
     Maxima quando <s> contiver números em ponto flutuante.

     Exemplos:

     'xreduce' aplicada a uma função sabidamente enária.  'F' é chamada
     uma vez, com todos os argumentos.

          (%i1) declare (F, nary);
          (%o1)                         done
          (%i2) F ([L]) := L;
          (%o2)                      F([L]) := L
          (%i3) xreduce (F, [a, b, c, d, e]);
          (%o3)         [[[[[("[", simp), a], b], c], d], e]

     'xreduce' aplicada a uma função não sabidamente enária.  'G' é
     chamada muitas vezes, com dois argumentos de cada vez.

          (%i1) G ([L]) := L;
          (%o1)                      G([L]) := L
          (%i2) xreduce (G, [a, b, c, d, e]);
          (%o2)         [[[[[("[", simp), a], b], c], d], e]
          (%i3) lreduce (G, [a, b, c, d, e]);
          (%o3)                 [[[[a, b], c], d], e]


File: maxima.info,  Node: Definição de Função,  Next: Fluxo de Programa,  Prev: Conjuntos,  Up: Top

39 Definição de Função
**********************

* Menu:

* Introdução a Definição de Função::  
* Função::                    
* Macros::                      
* Definições para Definição de Função::  


File: maxima.info,  Node: Introdução a Definição de Função,  Next: Função,  Prev: Definição de Função,  Up: Definição de Função

39.1 Introdução a Definição de Função
=====================================


File: maxima.info,  Node: Função,  Next: Macros,  Prev: Introdução a Definição de Função,  Up: Definição de Função

39.2 Função
===========

39.2.1 Ordinary functions
-------------------------

Para definir uma função no Maxima usa-se o operador :=.  Por exemplo,

     f(x) := sin(x)

define uma função 'f'.  Funções anônimas podem também serem criadas
usando 'lambda'.  Por exemplo

     lambda ([i, j], ...)

pode ser usada em lugar de 'f' onde

     f(i,j) := block ([], ...);
     map (lambda ([i], i+1), l)

retornará uma lista com 1 adicionado a cada termo.

Pode também definir uma função com um número variável de argumentos,
usando um argumento final que seja uma lista, na qual serão inseridos
todos os argumentos adicionais:

     (%i1) f ([u]) := u;
     (%o1)                      f([u]) := u
     (%i2) f (1, 2, 3, 4);
     (%o2)                     [1, 2, 3, 4]
     (%i3) f (a, b, [u]) := [a, b, u];
     (%o3)               f(a, b, [u]) := [a, b, u]
     (%i4) f (1, 2, 3, 4, 5, 6);
     (%o4)                 [1, 2, [3, 4, 5, 6]]

O lado direito na definição de uma função é uma expressão.  Assim,
quando quiser que a definição seja uma sequência de expressões, poderá
usar a forma
     f(x) := (expr1, expr2, ...., exprn);

e o valor de <exprn> é que é retornado pela função.

Se quiser introduzir um ponto de 'retorno' em alguma expressão dentro da
função, deverá usar 'block' e 'return'.

     block ([], expr1, ..., if (a > 10) then return(a), ..., exprn)

é em si mesma uma expressão, e então poderá ocupar o lugar do lado
direito de uma definição de função.  Aqui pode acontecer que o retorno
aconteça mais facilmente que no exemplo anterior a essa última
expressão.

O primeiro '[]' no bloco, pode conter uma lista de variáveis e
atribuições de variáveis, tais como '[a: 3, b, c: []]', que farão com
que as três variáveis 'a','b',e 'c' não se refiram a seus valores
globais, mas ao contrário tenham esses valores especiais enquanto o
código estiver executando a parte dentro do bloco 'block', ou dentro da
funções chamadas de dentro do bloco 'block'.  Isso é chamado associação
dynamic, uma vez que as variáveis permanecem do início do bloco pelo
tempo que ele existir.  Quando regressar do bloco 'block', ou o
descartar, os valores antigos (quaisquer que sejam) das variáveis serão
restaurados.  É certamente uma boa idéia para proteger as suas variáveis
nesse caminho.  Note que as atribuições em variáveis do bloco, são
realizadas em paralelo.  Isso significa, que se tivesse usado 'c: a'
acima, o valor de 'c' seria o valor que 'a' tinha antes do bloco, antes
de ter obtido o seu novo valor atribuído no bloco.  Dessa forma fazendo
alguma coisa como

     block ([a: a], expr1, ...  a: a+3, ..., exprn)

protegerá o valor externo de 'a' de ser alterado, mas impedirá aceder ao
valor antigo.  Assim, o lado direito de atribuições, é avaliado no
contexto inserido, antes que qualquer avaliação ocorra.  Usando apenas
'block ([x], ...' faremos com que o 'x' tenho como valor a si próprio;
esse é o mesmo valor que teria no início de uma sessão do Maxima.

Os actuais argumentos para uma função são tratados exactamente da mesma
que as variáveis em um bloco.  Dessa forma em

     f(x) := (expr1, ..., exprn);

e

     f(1);

teremos um contexto similar para avaliação de expressões como se
tivéssemos concluído

     block ([x: 1], expr1, ..., exprn)

Dentro de funções, quando o lado direito de uma definição, pode ser
calculado em tempo de execução, isso é úti para usar 'define' e
possivelmente 'buildq'.

39.2.2 Função de Array
----------------------

Uma função de Array armazena o valor da função na primeira vez que ela
for chamada com um argumento dado, e retorna o valor armazenado, sem
recalcular esse valor, quando o mesmo argumento for fornecido.  De modo
que uma função é muitas vezes chamada uma função de memorização.

Nomes de funções de Array são anexados ao final da lista global 'arrays'
(não na lista global 'functions').  O comando 'arrayinfo' retorna a
lista de argumentos para os quais exite valores armazenados, e
'listarray' retorna os valores armazenados.  Os comandos 'dispfun' e
'fundef' retornam a definição da função de array.

O comando 'arraymake' contrói uma chamada de função de array,
análogamente a 'funmake' para funções comuns.  O comando 'arrayapply'
aplica uma função de array a seus argmentos, análogamente a 'apply' para
funções comuns.  Não existe nada exactamente análogo a 'map' para
funções de array, embora 'map(lambda([<x>], <a>[<x>]), <L>)' ou
'makelist(<a>[<x>], <x>, <L>)', onde <L> é uma lista, não estejam tão
longe disso.

O comando 'remarray' remove uma definição de função de array (incluindo
qualquer valor armazenado pela função removida), análogo a 'remfunction'
para funções comuns.

o comando 'kill(<a>[<x>])' remove o valor da função de array <a>
armazenado para o argumento <x>; a próxima vez que <a> foor chamada com
o argumento <x>, o valor da função é recomputado.  Todavia, não exite
caminho para remover todos os valores armazenados de uma vez, excepto
para 'kill(<a>)' ou 'remarray(<a>)', o qual remove também remove a
definição da função de array.


File: maxima.info,  Node: Macros,  Next: Definições para Definição de Função,  Prev: Função,  Up: Definição de Função

39.3 Macros
===========

 -- Função: buildq (<L>, <expr>)
     Substitue variáveis nomeadas pela lista <L> dentro da expressão
     <expr>, paralelamente, sem avaliar <expr>.  A expressão resultante
     é simplificada, mas não avaliada, após 'buildq' realizar a
     substituição.

     Os elementos de <L> são símbolos ou expressões de atribuição
     '<símbolo>: <valor>', avaliadas paralelamente.  Isto é, a
     associação de uma variável sobre o lado direito de uma atribuição é
     a associação daquela variável no contexto do qual 'buildq' for
     chamada, não a associação daquela variável na lista <L> de
     variáveis.  Se alguma variável em <L> não dada como uma atribuição
     explícita, sua associação em 'buildq' é a mesma que no contexto no
     qual 'buildq' for chamada.

     Então as variáveis nomeadas em <L> são substituidas em <expr>
     paralelamente.  Isto é, a substituição para cada variável é
     determinada antes que qualquer substituição seja feita, então a
     substituição para uma variável não tem efeito sobre qualquer outra.

     Se qualquer variável <x> aparecer como 'splice (<x>)' em <expr>,
     então <x> deve estar associada para uma lista, e a lista recebe uma
     aplicação da função 'splice' (é interpolada) na <expr> em lugar de
     substituída.

     Quaisquer variáveis em <expr> não aparecendo em <L> são levados no
     resultado tal como foram escritos, mesmo se elas tiverem
     associações no contexto do qual 'buildq' tiver sido chamada.

     Exemplos

     'a' é explicitamente associada a 'x', enquanto 'b' tem a mesma
     associação (nomeadamente 29) como no contexto chamado, e 'c' é
     levada do começo ao fim da forma como foi escrita.  A expressão
     resultante não é avaliada até a avaliação explícita ( com duplo
     apóstrofo - não com aspas - '''%'.

          (%i1) (a: 17, b: 29, c: 1729)$
          (%i2) buildq ([a: x, b], a + b + c);
          (%o2)                      x + c + 29
          (%i3) ''%;
          (%o3)                       x + 1758

     'e' está associado a uma lista, a qual aparece também como tal nos
     argumentos de 'foo', e interpolada nos argumentos de 'bar'.

          (%i1) buildq ([e: [a, b, c]], foo (x, e, y));
          (%o1)                 foo(x, [a, b, c], y)
          (%i2) buildq ([e: [a, b, c]], bar (x, splice (e), y));
          (%o2)                  bar(x, a, b, c, y)

     O resultado é simplificado após substituição.  Se a simplificação
     for aplicada antes da substituição, esses dois resultados podem ser
     iguais.
          (%i1) buildq ([e: [a, b, c]], splice (e) + splice (e));
          (%o1)                    2 c + 2 b + 2 a
          (%i2) buildq ([e: [a, b, c]], 2 * splice (e));
          (%o2)                        2 a b c

     As variáveis em <L> são associadas em paralelo; se associadas
     sequêncialmente, o primeiro resultado pode ser 'foo (b, b)'.
     Substituições são realizadas em paralelo; compare o segundo
     resultado com o resultado de 'subst', que realiza substituições
     sequêncialmente.

          (%i1) buildq ([a: b, b: a], foo (a, b));
          (%o1)                       foo(b, a)
          (%i2) buildq ([u: v, v: w, w: x, x: y, y: z, z: u], bar (u, v, w, x, y, z));
          (%o2)                 bar(v, w, x, y, z, u)
          (%i3) subst ([u=v, v=w, w=x, x=y, y=z, z=u], bar (u, v, w, x, y, z));
          (%o3)                 bar(u, u, u, u, u, u)

     Constrói uma lista de euqções com algumas variáveis ou expressões
     sobre o lado esquerdo e seus valores sobre o lado direito.
     'macroexpand' mostra a expressão retornada por 'show_values'.

          (%i1) show_values ([L]) ::= buildq ([L], map ("=", 'L, L));
          (%o1)   show_values([L]) ::= buildq([L], map("=", 'L, L))
          (%i2) (a: 17, b: 29, c: 1729)$
          (%i3) show_values (a, b, c - a - b);
          (%o3)              [a = 17, b = 29, c = 1729]

 -- Função: macroexpand (<expr>)
     Retorna a expansão da macro de <expr> sem avaliar a expressão,
     quando 'expr' for uma chamada de função de macro.  De outra forma,
     'macroexpand' retorna <expr>.

     Se a expansão de <expr> retorna outra chamada de função de macro,
     aquela chamada de função de macro é também expandida.

     'macroexpand' coloca apóstrofo em seus argumentos, isto é, não os
     avalia.  Todavia, se a expansão de uma chamada de função de macro
     tiver algum efeito, esse efeito colateral é executado.

     Veja também '::=', 'macros', e 'macroexpand1'.

     Exemplos

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a));
          (%o2)            h(x) ::= buildq([x], g(x - a))
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand (h (y));
                                        y - a
          (%o4)                         -----
                                         99
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99

 -- Função: macroexpand1 (<expr>)
     Retorna a expansão de macro de <expr> sem avaliar a expressão,
     quando 'expr' for uma chamada de função de macro.  De outra forma,
     'macroexpand1' retorna <expr>.

     'macroexpand1' não avalia seus argumentos.  Todavia, se a expansão
     de uma chamada de função de macro tiver algum efeito, esse efeito
     colateral é executado.

     Se a expansão de <expr> retornar outra chamada de função de macro,
     aquela chamada de função de macro não é expandida.

     Veja também '::=', 'macros', e 'macroexpand'.

     Examples

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a));
          (%o2)            h(x) ::= buildq([x], g(x - a))
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand1 (h (y));
          (%o4)                       g(y - a)
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99

 -- Global variable: macros
     Default value: '[]'

     'macros' é a lista de funções de macro definidas pelo utilizador.
     O operador de definição de função de macro '::=' coloca uma nova
     função de macro nessa lista, e 'kill', 'remove', e 'remfunction'
     removem funções de macro da lista.

     Veja também 'infolists'.

 -- Função: splice (<a>)
     Une como se fosse um elo de ligação (interpola) a lista nomeada
     através do átomo <a> em uma expressão, mas somente se 'splice'
     aparecer dentro de 'buildq'; de outra forma, 'splice' é tratada
     como uma função indefinida.  Se aparecer dentro de 'buildq' com <a>
     sozinho (sem 'splice'), <a> é substituido (não interpolado) como
     uma lista no resultado.  O argumento de 'splice' pode somente ser
     um átomo; não pode ser uma lista lateral ou uma expressão que
     retorna uma lista.

     Tipicamente 'splice' fornece os argumentos para uma função ou
     operador.  Para uma função 'f', a expressão 'f (splice (<a>))'
     dentro de 'buildq' expande para 'f (<a>[1], <a>[2], <a>[3], ...)'.
     Para um operador 'o', a expressão '"o" (splice (<a>)' dentro de
     'buildq' expande para '"o" (<a>[1], <a>[2], <a>[3], ...)', onde 'o'
     pode ser qualquer tipo de operador (tipicamente um que toma
     múltiplos argumentos).  Note que o operador deve ser contido dentro
     de aspas duplas '"'.

     Exemplos

          (%i1) buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
                                 foo(1, %pi, z - y)
          (%o1)                -----------------------
                               length([1, %pi, z - y])
          (%i2) buildq ([x: [1, %pi]], "/" (splice (x)));
                                          1
          (%o2)                          ---
                                         %pi
          (%i3) matchfix ("<>", "<>");
          (%o3)                          <>
          (%i4) buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
          (%o4)                   <>1, %pi, z - y<>


File: maxima.info,  Node: Definições para Definição de Função,  Prev: Macros,  Up: Definição de Função

39.4 Definições para Definição de Função
========================================

 -- Função: apply (<F>, [<x_1>, ..., <x_n>])
     Constrói e avalia uma expressãp '<F>(<arg_1>, ..., <arg_n>)'.

     'apply' não tenta distinguir funções de array de funções comuns;
     quando <F> for o nome de uma função de array, 'apply' avalia
     '<F>(...)' (isto é, uma chamada de função com parêntesis em lugar
     de colchêtes).  'arrayapply' avalia uma chamada de função com
     colchêtes nesse caso.

     Exemplos:

     'apply' avalia seus argumentos.  Nesse exemplo, 'min' é aplicado a
     'L'.

          (%i1) L : [1, 5, -10.2, 4, 3];
          (%o1)                 [1, 5, - 10.2, 4, 3]
          (%i2) apply (min, L);
          (%o2)                        - 10.2

     'apply' avalia argumentos, mesmo se a função <F> disser que os
     argumentos não devem ser avaliados.

          (%i1) F (x) := x / 1729;
                                             x
          (%o1)                     F(x) := ----
                                            1729
          (%i2) fname : F;
          (%o2)                           F
          (%i3) dispfun (F);
                                             x
          (%t3)                     F(x) := ----
                                            1729

          (%o3)                         [%t3]
          (%i4) dispfun (fname);
          fname is not the name of a user function.
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) apply (dispfun, [fname]);
                                             x
          (%t5)                     F(x) := ----
                                            1729

          (%o5)                         [%t5]

     'apply' avalia o nome de função <F>.  Apóstrofo ''' evita
     avaliação.  'demoivre' é o nome de uma variável global e também de
     uma função.

          (%i1) demoivre;
          (%o1)                         false
          (%i2) demoivre (exp (%i * x));
          (%o2)                  %i sin(x) + cos(x)
          (%i3) apply (demoivre, [exp (%i * x)]);
          demoivre evaluates to false
          Improper name or value in functional position.
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) apply ('demoivre, [exp (%i * x)]);
          (%o4)                  %i sin(x) + cos(x)

 -- Função: block ([<v_1>, ..., <v_m>], <expr_1>, ..., <expr_n>)
 -- Função: block (<expr_1>, ..., <expr_n>)
     'block' avalia <expr_1>, ..., <expr_n> em sequência e retorna o
     valor da última expressão avaliada.  A sequência pode ser
     modificada pelas funções 'go', 'throw', e 'return'.  A última
     expressão é <expr_n> a menos que 'return' ou uma expressão contendo
     'throw' seja avaliada.  Algumas variáveis <v_1>, ..., <v_m> podem
     ser declaradas locais para o bloco; essas são distinguidas das
     variáveis globais dos mesmos nomes.  Se variáveis não forem
     declaradas locais então a lista pode ser omitida.  Dentro do bloco,
     qualquer variável que não <v_1>, ..., <v_m> é uma variável global.

     'block' salva os valores correntes das variáveis <v_1>, ..., <v_m>
     (quaisquer valores) na hora da entrada para o bloco, então libera
     as variáveis dessa forma eles avaliam para si mesmos.  As variáveis
     locais podem ser associadas a valores arbitrários dentro do bloco
     mas quando o bloco é encerrado o valores salvos são restaurados, e
     os valores atribuídos dentro do bloco são perdidos.

     'block' pode aparecer dentro de outro 'block'.  Variáveis locais
     são estabelecidas cada vez que um novo 'block' é avaliado.
     Variáveis locais parecem ser globais para quaisquer blocos
     fechados.  Se uma variável é não local em um bloco, seu valor é o
     valor mais recentemente atribuído por um bloco fechado, quaisquer
     que sejam, de outra forma, seu valor é o valor da variável no
     ambiente global.  Essa política pode coincidir com o entendimento
     usual de "escopo dinâmico".

     Se isso for desejado para salvar e restaurar outras propriedades
     locais ao lado de 'value', por exemplo 'array' (excepto para arrays
     completos), 'function', 'dependencies', 'atvalue', 'matchdeclare',
     'atomgrad', 'constant', e 'nonscalar' então a função 'local' pode
     ser usada dentro do bloco com argumentos sendo o nome das
     variáveis.

     O valor do bloco é o valor da última declaração ou o valor do
     argumento para a função 'return' que pode ser usada para sair
     explicitamente do bloco.  A função 'go' pode ser usada para
     transferir o controle para a declaração do bloco que é identificada
     com o argumento para 'go'.  Para identificar uma declaração,
     coloca-se antes dela um argumento atômico como outra declaração no
     bloco.  Por exemplo: 'block ([x], x:1, loop, x: x+1, ..., go(loop),
     ...)'.  O argumento para 'go' deve ser o nome de um identificador
     que aparece dentro do bloco.  Não se deve usar 'go' para transferir
     para um identificador em um outro bloco a não ser esse que contém o
     'go'.

     Blocos tipicamente aparecem do lado direito de uma definição de
     função mas podem ser usados em outros lugares também.

 -- Função: break (<expr_1>, ..., <expr_n>)
     Avalia e imprime <expr_1>, ..., <expr_n> e então causa uma parada
     do Maxima nesse ponto e o utilizador pode examinar e alterar seu
     ambiente.  Nessa situação digite 'exit;' para que o cálculo seja
     retomado.

 -- Função: catch (<expr_1>, ..., <expr_n>)
     Avalia <expr_1>, ..., <expr_n> uma por uma; se qualquer avaliação
     levar a uma avaliação de uma expressão da forma 'throw (arg)',
     então o valor de 'catch' é o valor de 'throw (arg)', e expressões
     adicionais não são avaliadas.  Esse "retorno não local" atravessa
     assim qualquer profundidade de aninhar para o mais próximo contendo
     'catch'.  Se não existe nenhum 'catch' contendo um 'throw', uma
     mensagem de erro é impressa.

     Se a avaliação de argumentos não leva para a avaliação de qualquer
     'throw' então o valor de 'catch' é o valor de <expr_n>.

          (%i1) lambda ([x], if x < 0 then throw(x) else f(x))$
          (%i2) g(l) := catch (map (''%, l))$
          (%i3) g ([1, 2, 3, 7]);
          (%o3)               [f(1), f(2), f(3), f(7)]
          (%i4) g ([1, 2, -3, 7]);
          (%o4)                          - 3

     A função 'g' retorna uma lista de 'f' de cada elemento de 'l' se
     'l' consiste somente de números não negativos; de outra forma, 'g'
     "captura" o primeiro elemento negativo de 'l' e "arremessa-o".

 -- Função: compfile (<nomeficheiro>, <f_1>, ..., <f_n>)
 -- Função: compfile (<nomeficheiro>, funções)
 -- Função: compfile (<nomeficheiro>, all)

     Traduz fuções Maxima para Lisp e escreve o código traduzido no
     ficheiro <nomeficheiro>.

     'compfile(<nomeficheiro>, <f_1>, ..., <f_n>)' traduz as funções
     especificadas.  'compfile(<nomeficheiro>, functions)' e
     'compfile(<nomeficheiro>, all)' traduz todas as funções definidas
     pelo utilizador.

     As traduções Lisp não são avaliadas, nem é o ficheiro de saída
     processado pelo compilador Lisp.  'translate' cria e avalia
     traduções Lisp.  'compile_file' traduz Maxima para Lisp, e então
     executa o compilador Lisp.

     Veja também 'translate', 'translate_file', e 'compile_file'.

 -- Função: compile (<f_1>, ..., <f_n>)
 -- Função: compile (funções)
 -- Função: compile (all)
     Traduz funções Maxima <f_1>, ..., <f_n> para Lisp, avalia a
     tradução Lisp, e chama a função Lisp 'COMPILE' sobre cada função
     traduzida.  'compile' retorna uma lista de nomes de funções
     compiladas.

     'compile (all)' ou 'compile (funções)' compila todas as funções
     definidas pelo utilizador.

     'compile' não avalia seus argumentos; o operador
     apóstrofo-apóstrofo '''' faz com que ocorra avaliação sobrepondo-se
     ao apóstrofo.

 -- Função: define (<f>(<x_1>, ..., <x_n>), <expr>)
 -- Função: define (<f>[<x_1>, ..., <x_n>], <expr>)
 -- Função: define (funmake (<f>, [<x_1>, ..., <x_n>]), <expr>)
 -- Função: define (arraymake (<f>, [<x_1>, ..., <x_n>]), <expr>)
 -- Função: define (ev (<expr_1>), <expr_2>)

     Define uma função chamada <f> com argumentos <x_1>, ..., <x_n> e
     corpo da função <expr>.  'define' sempre avalia seu segundo
     argumento (a menos que explícitamente receba um apostrofo de forma
     a evitar a avaliação).  A função então definida pode ser uma função
     comum do Maxima (com argumentos contidos entre parêtesis) ou uma
     função de array (com argumentos contidos entre colchêtes).

     Quando o último ou único argumento da função <x_n> for uma lista de
     um elemento, a função definida por 'define' aceita um número
     variável de argumentos.  Os argumentos actuais são atribuídos um a
     um a argumentos formais <x_1>, ..., <x_(n - 1)>, e quaisquer
     argumentos adicionais actuais, se estiverem presentes, são
     atribuídos a <x_n> como uma lista.

     Quando o primeiro argumento de 'define' for uma expressão da forma
     '<f>(<x_1>, ..., <x_n>)' or '<f>[<x_1>, ..., <x_n>]', os argumentos
     são avaliados mas <f> não é avaliada, mesmo se já existe
     anteriormente uma função ou variável com aquele nome.  Quando o
     primeiro argumento for uma expressão com operador 'funmake',
     'arraymake', ou 'ev', o primeiro argumento será avaliado; isso
     permite para o nome da função seja calculado, também como o corpo.

     Todas as definições de função aparecem no mesmo nível de escopo e
     visibilidade; definindo uma função 'f' dentro de outra função 'g'
     não limita o escopo de 'f' a 'g'.

     Se algum argumento formal <x_k> for um símbolo com apóstrofo (após
     ter sido feita uma avaliação), a função definida por 'define' não
     avalia o correspondente actual argumento.  de outra forma todos os
     argumentos actuais são avaliados.

     Veja também ':=' and '::='.

     Exemplos:

     'define' sempre avalia seu segundo argumento (a menos que
     explícitamente receba um apostrofo de forma a evitar a avaliação).

          (%i1) expr : cos(y) - sin(x);
          (%o1)                    cos(y) - sin(x)
          (%i2) define (F1 (x, y), expr);
          (%o2)              F1(x, y) := cos(y) - sin(x)
          (%i3) F1 (a, b);
          (%o3)                    cos(b) - sin(a)
          (%i4) F2 (x, y) := expr;
          (%o4)                   F2(x, y) := expr
          (%i5) F2 (a, b);
          (%o5)                    cos(y) - sin(x)

     A função definida por 'define' pode ser uma função comum do Maxima
     ou uma função de array.

          (%i1) define (G1 (x, y), x.y - y.x);
          (%o1)               G1(x, y) := x . y - y . x
          (%i2) define (G2 [x, y], x.y - y.x);
          (%o2)                G2     := x . y - y . x
                                 x, y

     Quando o último ou único argumento da função <x_n> for uma lista de
     um único elemento, a função definida por 'define' aceita um número
     variável de argumentos.

          (%i1) define (H ([L]), '(apply ("+", L)));
          (%o1)                H([L]) := apply("+", L)
          (%i2) H (a, b, c);
          (%o2)                       c + b + a

     When the first argument is an expression with operator 'funmake',
     'arraymake', or 'ev', the first argument is evaluated.

          (%i1) [F : I, u : x];
          (%o1)                        [I, x]
          (%i2) funmake (F, [u]);
          (%o2)                         I(x)
          (%i3) define (funmake (F, [u]), cos(u) + 1);
          (%o3)                  I(x) := cos(x) + 1
          (%i4) define (arraymake (F, [u]), cos(u) + 1);
          (%o4)                   I  := cos(x) + 1
                                   x
          (%i5) define (foo (x, y), bar (y, x));
          (%o5)                foo(x, y) := bar(y, x)
          (%i6) define (ev (foo (x, y)), sin(x) - cos(y));
          (%o6)             bar(y, x) := sin(x) - cos(y)

 -- Função: define_variable (<name>, <default_value>, <mode>)

     Introduz uma variável global dentro do ambiente Maxima.
     'define_variable' é útil em pacotes escritos pelo utilizador, que
     são muitas vezes traduzidos ou compilados.

     'define_variable' realiza os seguintes passos:

       1. 'mode_declare (<name>, <mode>)' declara o modo de <name> para
          o tradutor.  Veja 'mode_declare' para uma lista dos modos
          possíveis.

       2. Se a variável é não associada, <default_value> é atribuído
          para <name>.

       3. 'declare (<name>, special)' declara essa variável especial.

       4. Associa <name> com uma função de teste para garantir que a
          <name> seja somente atribuído valores do modo declarado.

     A propriedade 'value_check' pode ser atribuída a qualquer variável
     que tenha sido definida via 'define_variable' com um outro modo que
     não 'any'.  A propriedade 'value_check' é uma expressão lambda ou o
     nome de uma função de uma variável, que é chamada quando uma
     tentativa é feita para atribuir um valor a uma variável.  O
     argumento da função 'value_check' é o valor que será atribuído.

     'define_variable' avalia 'default_value', e não avalia 'name' e
     'mode'.  'define_variable' retorna o valor corrente de 'name', que
     é 'default_value' se 'name' não tiver sido associada antes, e de
     outra forma isso é o valor prévio de 'name'.

     Exemplos:

     'foo' é uma variável Booleana, com o valor inicial 'true'.

          (%i1) define_variable (foo, true, boolean);
          (%o1)                         true
          (%i2) foo;
          (%o2)                         true
          (%i3) foo: false;
          (%o3)                         false
          (%i4) foo: %pi;
          Error: foo was declared mode boolean, has value: %pi
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) foo;
          (%o5)                         false

     'bar' é uma variável inteira, que deve ser um número primo.

          (%i1) define_variable (bar, 2, integer);
          (%o1)                           2
          (%i2) qput (bar, prime_test, value_check);
          (%o2)                      prime_test
          (%i3) prime_test (y) := if not primep(y) then error (y, "is not prime.");
          (%o3) prime_test(y) := if not primep(y)

                                             then error(y, "is not prime.")
          (%i4) bar: 1439;
          (%o4)                         1439
          (%i5) bar: 1440;
          1440 é not prime.
          #0: prime_test(y=1440)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i6) bar;
          (%o6)                         1439

     'baz_quux' é uma variável que não pode receber a atribuição de um
     valor.  O modo 'any_check' é como 'any', mas 'any_check' habilita o
     mecanismo 'value_check', e 'any' não habilita.

          (%i1) define_variable (baz_quux, 'baz_quux, any_check);
          (%o1)                       baz_quux
          (%i2) F: lambda ([y], if y # 'baz_quux then error ("Cannot assign to `baz_quux'."));
          (%o2) lambda([y], if y # 'baz_quux

                                  then error(Cannot assign to `baz_quux'.))
          (%i3) qput (baz_quux, ''F, value_check);
          (%o3) lambda([y], if y # 'baz_quux

                                  then error(Cannot assign to `baz_quux'.))
          (%i4) baz_quux: 'baz_quux;
          (%o4)                       baz_quux
          (%i5) baz_quux: sqrt(2);
          Cannot assign to `baz_quux'.
          #0: lambda([y],if y # 'baz_quux then error("Cannot assign to `baz_quux'."))(y=sqrt(2))
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i6) baz_quux;
          (%o6)                       baz_quux

 -- Função: dispfun (<f_1>, ..., <f_n>)
 -- Função: dispfun (all)
     Mostra a definição de funções definidas pelo utilizador <f_1>, ...,
     <f_n>.  Cada argumento pode ser o nome de uma macro (definida com
     '::='), uma função comum (definida com ':=' ou 'define'), uma
     função array (definida com ':=' ou com 'define', mas contendo
     argumentos entre colchêtes '[ ]'), uma função subscrita, (definida
     com ':=' ou 'define', mas contendo alguns argumentos entre
     colchêtes e outros entre parêntesis '( )') uma da família de
     funções subscritas seleccionadas por um valor subscrito particular,
     ou uma função subscrita definida com uma constante subscrita.

     'dispfun (all)' mostra todas as funções definidas pelo utilizador
     como dadas pelas 'functions', 'arrays', e listas de 'macros',
     omitindo funções subscritas definidas com constantes subscritas.

     'dispfun' cria um Rótulo de expressão intermédia ('%t1', '%t2',
     etc.)  para cada função mostrada, e atribui a definição de função
     para o rótulo.  Em contraste, 'fundef' retorna a definição de
     função.

     'dispfun' não avalia seus argumentos; O operador
     apóstrofo-apóstrofo '''' faz com que ocorra avaliação.

     'dispfun' retorna a lista de rótulos de expressões intermédias
     correspondendo às funções mostradas.

     Exemplos:

          (%i1) m(x, y) ::= x^(-y);
                                               - y
          (%o1)                   m(x, y) ::= x
          (%i2) f(x, y) :=  x^(-y);
                                               - y
          (%o2)                    f(x, y) := x
          (%i3) g[x, y] :=  x^(-y);
                                              - y
          (%o3)                     g     := x
                                     x, y
          (%i4) h[x](y) :=  x^(-y);
                                              - y
          (%o4)                     h (y) := x
                                     x
          (%i5) i[8](y) :=  8^(-y);
                                              - y
          (%o5)                     i (y) := 8
                                     8
          (%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                               - y
          (%t6)                   m(x, y) ::= x

                                               - y
          (%t7)                    f(x, y) := x

                                              - y
          (%t8)                     g     := x
                                     x, y

                                              - y
          (%t9)                     h (y) := x
                                     x

                                              1
          (%t10)                     h (y) := --
                                      5        y
                                              5

                                               1
          (%t11)                    h  (y) := ---
                                     10         y
                                              10

                                              - y
          (%t12)                    i (y) := 8
                                     8

          (%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
          (%i12) ''%;
                               - y              - y            - y
          (%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   ,
                                                      x, y
                            - y           1              1             - y
                  h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
                   x              5        y   10         y   8
                                          5             10

 -- Variável de sistema: functions
     Valor por omissão: '[]'

     'functions' é uma lista de todas as funções comuns do Maxima na
     sessão corrente.  Uma função comum é uma função construída através
     de 'define' ou de ':=' e chamada com parêntesis '()'.  Uma função
     pode ser definida pela linha de comando do Maxima de forma
     interativa com o utilizador ou em um ficheiro Maxima chamado por
     'load' ou 'batch'.

     Funções de array (chamadas com colchêtes, e.g., 'F[x]') e funções
     com subscritos (chamadas com colchêtes e parêntesis, e.g.,
     'F[x](y)') são lsitados através da variável global 'arrays', e não
     por meio de 'functions'.

     Funções Lisp não são mantidas em nenhuma lista.

     Exemplos:

          (%i1) F_1 (x) := x - 100;
          (%o1)                   F_1(x) := x - 100
          (%i2) F_2 (x, y) := x / y;
                                                x
          (%o2)                    F_2(x, y) := -
                                                y
          (%i3) define (F_3 (x), sqrt (x));
          (%o3)                   F_3(x) := sqrt(x)
          (%i4) G_1 [x] := x - 100;
          (%o4)                    G_1  := x - 100
                                      x
          (%i5) G_2 [x, y] := x / y;
                                               x
          (%o5)                     G_2     := -
                                       x, y    y
          (%i6) define (G_3 [x], sqrt (x));
          (%o6)                    G_3  := sqrt(x)
                                      x
          (%i7) H_1 [x] (y) := x^y;
                                                y
          (%o7)                     H_1 (y) := x
                                       x
          (%i8) functions;
          (%o8)              [F_1(x), F_2(x, y), F_3(x)]
          (%i9) arrays;
          (%o9)                 [G_1, G_2, G_3, H_1]

 -- Função: fundef (<f>)
     Retorna a definição da função <f>.

     O argumento pode ser o nome de uma macro (definida com '::='), uma
     função comum (definida com ':=' ou 'define'), uma função array
     (definida com ':=' ou 'define', mas contendo argumentos entre
     colchêtes '[ ]'), Uma função subscrita, (definida com ':=' ou
     'define', mas contendo alguns argumentos entre colchêtes e
     parêntesis '( )') uma da família de funções subscritas seleccionada
     por um valor particular subscrito, ou uma função subscrita definida
     com uma constante subscrita.

     'fundef' não avalia seu argumento; o operador apóstrofo-apóstrofo
     '''' faz com que ocorra avaliação.

     'fundef (<f>)' retorna a definição de <f>.  Em contraste, 'dispfun
     (<f>)' cria um rótulo de expressão intermédia e atribui a definição
     para o rótulo.

 -- Função: funmake (<F>, [<arg_1>, ..., <arg_n>])
     Retorna uma expressão '<F>(<arg_1>, ..., <arg_n>)'.  O valor de
     retorno é simplificado, mas não avaliado, então a função <F> não é
     chamada, mesmo se essa função <F> existir.

     'funmake' não tenta distinguir funções de array de funções comuns;
     quando <F> for o nome de uma função de array, 'funmake' retorna
     '<F>(...)' (isto é, uma chamada de função com parêntesis em lugar
     de colchêtes).  'arraymake' retorna uma chamada de função com
     colchêtes nesse caso.

     'funmake' avalia seus argumentos.

     Exemplos:

     'funmake' aplicada a uma função comum do Maxima.

          (%i1) F (x, y) := y^2 - x^2;
                                             2    2
          (%o1)                  F(x, y) := y  - x
          (%i2) funmake (F, [a + 1, b + 1]);
          (%o2)                    F(a + 1, b + 1)
          (%i3) ''%;
                                        2          2
          (%o3)                  (b + 1)  - (a + 1)

     'funmake' aplicada a uma macro.

          (%i1) G (x) ::= (x - 1)/2;
                                            x - 1
          (%o1)                    G(x) ::= -----
                                              2
          (%i2) funmake (G, [u]);
          (%o2)                         G(u)
          (%i3) ''%;
                                        u - 1
          (%o3)                         -----
                                          2

     'funmake' aplicada a uma função subscrita.

          (%i1) H [a] (x) := (x - 1)^a;
                                                  a
          (%o1)                   H (x) := (x - 1)
                                   a
          (%i2) funmake (H [n], [%e]);
                                                 n
          (%o2)               lambda([x], (x - 1) )(%e)
          (%i3) ''%;
                                              n
          (%o3)                       (%e - 1)
          (%i4) funmake ('(H [n]), [%e]);
          (%o4)                        H (%e)
                                        n
          (%i5) ''%;
                                              n
          (%o5)                       (%e - 1)

     'funmake' aplicada a um símbolo que não é uma função definida de
     qualquer tipo.

          (%i1) funmake (A, [u]);
          (%o1)                         A(u)
          (%i2) ''%;
          (%o2)                         A(u)

     'funmake' avalia seus argumentos, mas não o valor de retorno.

          (%i1) det(a,b,c) := b^2 -4*a*c;
                                              2
          (%o1)              det(a, b, c) := b  - 4 a c
          (%i2) (x : 8, y : 10, z : 12);
          (%o2)                          12
          (%i3) f : det;
          (%o3)                          det
          (%i4) funmake (f, [x, y, z]);
          (%o4)                    det(8, 10, 12)
          (%i5) ''%;
          (%o5)                         - 284
     Maxima simplifica o valor de retorno de 'funmake'.

          (%i1) funmake (sin, [%pi / 2]);
          (%o1)                           1

 -- Função: lambda ([<x_1>, ..., <x_m>], <expr_1>, ..., <expr_n>)
 -- Função: lambda ([[<L>]], <expr_1>, ..., <expr_n>)
 -- Função: lambda ([<x_1>, ..., <x_m>, [<L>]], <expr_1>, ..., <expr_n>)
     Define e retorna uma expressão lambda (que é, uma função anônima) A
     função pode ter argumentos que sejam necessários <x_1>, ..., <x_m>
     e/ou argumentos opcionais <L>, os quais aparecem dentro do corpo da
     função como uma lista.  O valor de retorno da função é <expr_n>.
     Uma expressão lambda pode ser atribuída para uma variável e
     avaliada como uma função comum.  Uma expressão lambda pode aparecer
     em alguns contextos nos quais um nome de função é esperado.

     Quando a função é avaliada, variáveis locais não associadas <x_1>,
     ..., <x_m> são criadas.  'lambda' pode aparecer dentro de 'block'
     ou outra função 'lambda'; variáveis locais são estabelecidas cada
     vez que outro 'block' ou função 'lambda' é avaliada.  Variáveis
     locais parecem ser globais para qualquer coisa contendo 'block' ou
     'lambda'.  Se uma variável é não local, seu valor é o valor mais
     recentemente atribuído em alguma coisa contendo 'block' ou
     'lambda', qualquer que seja, de outra forma, seu valor é o valor da
     variável no ambiente global.  Essa política pode coincidir com o
     entendimento usual de "escopo dinâmico".

     Após variáveis locais serem estabelecidas, <expr_1> até <expr_n>
     são avaliadas novamente.  a variável especial '%%', representando o
     valor da expressão precedente, é reconhecida.  'throw' e 'catch'
     pode também aparecer na lista de expressões.

     'return' não pode aparecer em uma expressão lambda a menos que
     contendo 'block', nesse caso 'return' define o valor de retorno do
     bloco e não da expressão lambda, a menos que o bloco seja <expr_n>.
     Da mesma forma, 'go' não pode aparecer em uma expressão lambda a
     menos que contendo 'block'.

     'lambda' não avalia seus argumentos; o operador apóstrofo-apóstrofo
     '''' faz com que ocorra avaliação.

     Exemplos:

        * A expressão lambda pode ser atribuída para uma variável e
          avaliada como uma função comum.
          (%i1) f: lambda ([x], x^2);
                                                2
          (%o1)                    lambda([x], x )
          (%i2) f(a);
                                          2
          (%o2)                          a
        * Uma expressão lambda pode aparecer em contextos nos quais uma
          avaliação de função é esperada como resposta.
          (%i3) lambda ([x], x^2) (a);
                                          2
          (%o3)                          a
          (%i4) apply (lambda ([x], x^2), [a]);
                                          2
          (%o4)                          a
          (%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                                  2   2   2   2   2
          (%o5)                 [a , b , c , d , e ]
        * Variáveis argumento são variáveis locais.  Outras variáveis
          aparecem para serem variáveis globais.  Variáveis globais são
          avaliadas ao mesmo tempo em que a expressão lambda é avaliada,
          a menos que alguma avaliação especial seja forçada por alguns
          meios, tais como ''''.
          (%i6) a: %pi$
          (%i7) b: %e$
          (%i8) g: lambda ([a], a*b);
          (%o8)                   lambda([a], a b)
          (%i9) b: %gamma$
          (%i10) g(1/2);
                                       %gamma
          (%o10)                       ------
                                         2
          (%i11) g2: lambda ([a], a*''b);
          (%o11)                lambda([a], a %gamma)
          (%i12) b: %e$
          (%i13) g2(1/2);
                                       %gamma
          (%o13)                       ------
                                         2
        * Expressões lambda podem ser aninhadas.  Variáveis locais
          dentro de outra expressão lambda parece ser global para a
          expressão interna a menos que mascarada por variáveis locais
          de mesmos nomes.
          (%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                             1
          (%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                             2
          (%i15) h(%pi, %gamma);
                                       %gamma
          (%o15)                       ------
                                         2
        * Uma vez que 'lambda' não avalia seus argumentos, a expressão
          lambda 'i' abaixo não define uma função "multiplicação por
          'a'".  Tanto uma função pode ser definida via 'buildq', como
          na expressão lambda 'i2' abaixo.
          (%i16) i: lambda ([a], lambda ([x], a*x));
          (%o16)            lambda([a], lambda([x], a x))
          (%i17) i(1/2);
          (%o17)                  lambda([x], a x)
          (%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
          (%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
          (%i19) i2(1/2);
                                               x
          (%o19)                   lambda([x], -)
                                               2
          (%i20) i2(1/2)(%pi);
                                         %pi
          (%o20)                         ---
                                          2
        * Uma expressão lambda pode receber um número variável de
          argumentos, os quais são indicados por meio de '[<L>]' como o
          argumento único ou argumento final.  Os argumentos aparecem
          dentro do corpo da função como uma lista.
          (%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
          (%o1)          lambda([aa, bb, [cc]], aa cc + bb)
          (%i2) f (foo, %i, 17, 29, 256);
          (%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
          (%i3) g : lambda ([[aa]], apply ("+", aa));
          (%o3)             lambda([[aa]], apply(+, aa))
          (%i4) g (17, 29, x, y, z, %e);
          (%o4)                  z + y + x + %e + 46

 -- Função: local (<v_1>, ..., <v_n>)
     Declara as variáveis <v_1>, ..., <v_n> para serem locais com
     relação a todas as propriedades na declaração na qual essa função é
     usada.

     'local' não avalia seus argumentos.  'local' retorna 'done'.

     'local' pode somente ser usada em 'block', no corpo de definições
     de função ou expressões 'lambda', ou na função 'ev', e somente uma
     ocorrêcia é permitida em cada.

     'local' é independente de 'context'.

 -- Variável de opção: macroexpansion
     Valor por omissão: 'false'

     'macroexpansion' controla recursos avançados que afectam a
     eficiência de macros.  Escolhas possíveis:

        * 'false' - Macros expandem normalmente cada vez que são
          chamadas.
        * 'expand' - A primeira vez de uma chamada particular é
          avaliada, a expansão é lembrada internamente, dessa forma não
          tem como ser recalculada em chamadas subsequênte rapidamente.
          A macro chama ainda chamadas 'grind' e 'display' normalmente.
          Todavia, memória extra é requerida para lembrar todas as
          expansões.
        * 'displace' - A primeira vez de uma chamada particular é
          avaliada, a expansão é substituída pela chamada.  Isso requer
          levemente menos armazenagem que quando 'macroexpansion' é
          escolhida para 'expand' e é razoávelmente rápido, mas tem a
          desvantagem de a macro original ser lentamente lembrada e daí
          a expansão será vista se 'display' ou 'grind' for chamada.
          Veja a documentação para 'translate' e 'macros' para maiores
          detalhes.

 -- Variável de opção: mode_checkp
     Valor por omissão: 'true'

     Quando 'mode_checkp' é 'true', 'mode_declare' verifica os modos de
     associação de variáveis.

 -- Variável de opção: mode_check_errorp
     Valor por omissão: 'false'

     Quando 'mode_check_errorp' é 'true', 'mode_declare' chama a função
     "error".

 -- Variável de opção: mode_check_warnp
     Valor por omissão: 'true'

     Quando 'mode_check_warnp' é 'true', modo "errors" são descritos.

 -- Função: mode_declare (<y_1>, <mode_1>, ..., <y_n>, <mode_n>)
     'mode_declare' é usado para declarar os modos de variáveis e
     funções para subsequênte tradução ou compilação das funções.
     'mode_declare' é tipicamente colocada no início de uma definição de
     função, no início de um script Maxima, ou executado através da
     linha de comando de forma interativa.

     Os argumentos de 'mode_declare' são pares consistindo de uma
     variável e o modo que é um de 'boolean', 'fixnum', 'number',
     'rational', ou 'float'.  Cada variável pode também ser uma lista de
     variáveis todas as quais são declaradas para ter o mesmo modo.

     Se uma variável é um array, e se todo elemento do array que é
     referenciado tiver um valor então 'array (yi, complete, dim1, dim2,
     ...)' em lugar de
          array(yi, dim1, dim2, ...)
     deverá ser usado primeiro declarando as associações do array.  Se
     todos os elementos do array estão no modo 'fixnum' ('float'), use
     'fixnum' ('float') em lugar de 'complete'.  Também se todo elemento
     do array está no mesmo modo, digamos 'm', então

          mode_declare (completearray (yi), m))

     deverá ser usado para uma tradução eficiente.

     Código numéricos usando arrays podem rodar mais rápidamente se for
     decladado o tamanho esperado do array, como em:

          mode_declare (completearray (a [10, 10]), float)

     para um array numérico em ponto flutuante que é 10 x 10.

     Pode-se declarar o modo do resultado de uma função usando 'function
     (f_1, f_2, ...)' como um argumento; aqui 'f_1', 'f_2', ...  são
     nomes de funções.  Por exemplo a expressão,

          mode_declare ([function (f_1, f_2, ...)], fixnum)

     declara que os valores retornados por 'f_1', 'f_2', ...  são
     inteiros palavra simples.

     'modedeclare' é um sinônimo para 'mode_declare'.

 -- Função: mode_identity (<arg_1>, <arg_2>)
     Uma forma especial usada com 'mode_declare' e 'macros' para
     declarar, e.g., uma lista de listas de números em ponto flutuante
     ou outros objectos de dados.  O primeiro argumento para
     'mode_identity' é um valor primitivo nome de modo como dado para
     'mode_declare' (i.e., um de 'float', 'fixnum', 'number', 'list', ou
     'any'), e o segundo argumento é uma expressão que é avaliada e
     retornada com o valor de 'mode_identity'.  No entanto, se o valor
     de retorno não é permitido pelo modo declarado no primeiro
     argumento, um erro ou alerta é sinalizado.  Um ponto importante é
     que o modo da expressão como determinado pelo Maxima para o
     tradutor Lisp, será aquele dado como o primeiro argumento,
     independente de qualquer coisa que vá no segundo argumento.  E.g.,
     'x: 3.3; mode_identity (fixnum, x);' retorna um erro.
     'mode_identity (flonum, x)' returns 3.3 .  Isto tem númerosas
     utilidades, por exemplo, se souber que 'first (l)' retornou um
     número então poderá escrever 'mode_identity (number, first (l))'.
     No entanto, um caminho mais eficiente para fazer a mesma coisa é
     definir uma nova primitiva,

          firstnumb (x) ::= buildq ([x], mode_identity (number, first(x)));

     e usar 'firstnumb' sempre que obtiver o primeiro de uma lista de
     números.

 -- Variável de opção: transcompile
     Valor por omissão: 'true'

     Quando 'transcompile' é 'true', 'translate' e 'translate_file'
     geram declarações para fazer o código traduzido mais adequado para
     compilação.

     'compfile' escolhe 'transcompile: true' para a duração.

 -- Função: translate (<f_1>, ..., <f_n>)
 -- Função: translate (funções)
 -- Função: translate (all)
     Traduz funções definidas pelo utilizador <f_1>, ..., <f_n> da
     linguagem de Maxima para Lisp e avalia a tradução Lisp.
     Tipicamente as funções traduzidas executam mais rápido que as
     originais.

     'translate (all)' ou 'translate (funções)' traduz todas as funções
     definidas pelo utilizador.

     Funções a serem traduzidas incluir~ao uma chamada para
     'mode_declare' no início quando possível com o objectivo de
     produzir um código mais eficiente.  Por exemplo:

          f (x_1, x_2, ...) := block ([v_1, v_2, ...],
              mode_declare (v_1, mode_1, v_2, mode_2, ...), ...)

     quando <x_1>, <x_2>, ...  são parâmetros para a função e <v_1>,
     <v_2>, ...  são variáveis locais.

     Os nomes de funções traduzidas são removidos da lista 'functions'
     se 'savedef' é 'false' (veja abaixo) e são adicionados nas listas
     'props'.

     Funções não poderão ser traduzidas a menos que elas sejam
     totalmente depuradas.

     Expressões são assumidas simplificadas; se não forem, um código
     correcto será gerado mas não será um código óptimo.  Dessa forma, o
     utilizador não poderá escolher o comutador 'simp' para 'false' o
     qual inibe simplificação de expressões a serem traduzidas.

     O comutador 'translate', se 'true', causa tradução automatica de
     uma função de utilizador para Lisp.

     Note que funções traduzidas podem não executar identicamente para o
     caminho que elas faziam antes da tradução como certas
     incompatabilidades podem existir entre o Lisp e versões do Maxima.
     Principalmente, a função 'rat' com mais de um argumento e a função
     'ratvars' não poderá ser usada se quaisquer variáveis são
     declaradas com 'mode_declare' como sendo expressões rotacionais
     canónicas(CRE). Também a escolha 'prederror: false' não traduzirá.

     'savedef' - se 'true' fará com que a versão Maxima de uma função
     utilizador permaneça quando a função é traduzida com 'translate'.
     Isso permite a que definição seja mostrada por 'dispfun' e autoriza
     a função a ser editada.

     'transrun' - se 'false' fará com que a versão interpretada de todas
     as funções sejam executadas (desde que estejam ainda disponíveis)
     em lugar da versão traduzida.

     O resultado retornado por 'translate' é uma lista de nomes de
     funções traduzidas.

 -- Função: translate_file (<maxima_nomeficheiro>)
 -- Função: translate_file (<maxima_nomeficheiro>, <lisp_nomeficheiro>)
     Traduz um ficheiro com código Maxima para um ficheiro com código
     Lisp.  'translate_file' retorna uma lista de três nomes de
     ficheiro: O nome do ficheiro Maxima, o nome do ficheiro Lisp, e o
     nome do ficheiro contendo informações adicionais sobre a tradução.
     'translate_file' avalia seus argumentos.

     'translate_file ("foo.mac"); load("foo.LISP")' é o mesmo que 'batch
     ("foo.mac")' excepto por certas restrições, o uso de '''' e '%',
     por exemplo.

     'translate_file (<maxima_nomeficheiro>)' traduz um ficheiro Maxima
     <maxima_nomeficheiro> para um similarmente chamado ficheiro Lisp.
     Por exemplo, 'foo.mac' é traduzido em 'foo.LISP'.  O nome de
     ficheiro Maxima pod incluir nome ou nomes de directório(s), nesse
     caso o ficheiro de saída Lisp é escrito para o mesmo directório que
     a entrada Maxima.

     'translate_file (<maxima_nomeficheiro>, <lisp_nomeficheiro>)'
     traduz um ficheiro Maxima <maxima_nomeficheiro> em um ficheiro Lisp
     <lisp_nomeficheiro>.  'translate_file' ignora a extensão do nome do
     ficheiro, se qualquer, de 'lisp_nomeficheiro'; a extensão do
     ficheiro de saída Lisp é sempre 'LISP'.  O nome de ficheiro Lisp
     pode incluir um nome ou nomes de directórios), nesse caso o
     ficheiro de saída Lisp é escrito para o directório especificado.

     'translate_file' também escreve um ficheiro de mensagens de alerta
     do tradutor em vários graus de severidade.  A extensão do nome de
     ficheiro desse ficheiro é 'UNLISP'.  Esse ficheiro pode conter
     informação valiosa, apesar de possivelmente obscura, para rastrear
     erros no código traduzido.  O ficheiro 'UNLISP' é sempre escrito
     para o mesmo directório que a entrada Maxima.

     'translate_file' emite código Lisp o qual faz com que algumas
     definições tenham efeito tão logo o código Lisp é compilado.  Veja
     'compile_file' para mais sobre esse tópico.

     Veja também 'tr_array_as_ref', 'tr_bound_function_applyp',
     'tr_exponent', 'tr_file_tty_messagesp',
     'tr_float_can_branch_complex', 'tr_function_call_default',
     'tr_numer', 'tr_optimize_max_loop', 'tr_semicompile',
     'tr_state_vars', 'tr_warnings_get', 'tr_warn_bad_function_calls',
     'tr_warn_fexpr', 'tr_warn_meval', 'tr_warn_mode',
     'tr_warn_undeclared', e 'tr_warn_undefined_variable'.

 -- Variável de opção: transrun
     Valor por omissão: 'true'

     Quando 'transrun' é 'false' fará com que a versão interpretada de
     todas as funções sejam executadas (desde que estejam ainda
     disponíveis) em lugar de versão traduzidas.

 -- Variável de opção: tr_array_as_ref
     Valor por omissão: 'true'

     Se 'translate_fast_arrays' for 'false', referências a arrays no
     Código Lisp emitidas por 'translate_file' são afectadas por
     'tr_array_as_ref'.  Quando 'tr_array_as_ref' é 'true', nomes de
     arrays são avaliados, de outra forma nomes de arrays aparecem como
     símbolos literais no código traduzido.

     'tr_array_as_ref' não terão efeito se 'translate_fast_arrays' for
     'true'.

 -- Variável de opção: tr_bound_function_applyp
     Valor por omissão: 'true'

     Quando 'tr_bound_function_applyp' for 'true', Maxima emite um
     alerta se uma associação de variável (tal como um argumento de
     função) é achada sendo usada como uma função.
     'tr_bound_function_applyp' não afecta o código gerado em tais
     casos.

     Por exemplo, uma expressão tal como 'g (f, x) := f (x+1)' irá
     disparar a mensagem de alerta.

 -- Variável de opção: tr_file_tty_messagesp
     Valor por omissão: 'false'

     Quando 'tr_file_tty_messagesp' é 'true', messagens geradas por
     'translate_file' durante a tradução de um ficheiro são mostradas
     sobre o console e inseridas dentro do ficheiro UNLISP. Quando
     'false', messagens sobre traduções de ficheiros são somente
     inseridas dentro do ficheiro UNLISP.

 -- Variável de opção: tr_float_can_branch_complex
     Valor por omissão: 'true'

     Diz ao tradutor Maxima-para-Lisp assumir que as funções 'acos',
     'asin', 'asec', e 'acsc' podem retornar resultados complexos.

     O efeito ostensivo de 'tr_float_can_branch_complex' é mostrado
     adiante.  Todavia, parece que esse sinalizador não tem efeito sobre
     a saída do tradutor.

     Quando isso for 'true' então 'acos(x)' será do modo 'any' sempre
     que 'x' for do modo 'float' (como escolhido por 'mode_declare').
     Quando 'false' então 'acos(x)' será do modo 'float' se e somente se
     'x' for do modo 'float'.

 -- Variável de opção: tr_function_call_default
     Valor por omissão: 'general'

     'false' significa abandonando e chamando 'meval', 'expr' significa
     que Lisp assume função de argumento fixado.  'general', o código
     padrão dado como sendo bom para 'mexprs' e 'mlexprs' mas não
     'macros'.  'general' garante que associações de variável são
     correctas em códigos compilados.  No modo 'general', quando
     traduzindo F(X), se F for uma variável associada, então isso
     assumirá que 'apply (f, [x])' é significativo, e traduz como tal,
     com o alerta apropriado.  Não é necessário desabilitar isso.  Com
     as escolhas padrão, sem mensagens de alerta implica compatibilidade
     total do código traduzido e compilado com o interpretador Maxima.

 -- Variável de opção: tr_numer
     Valor por omissão: 'false'

     Quando 'tr_numer' for 'true' propriedades 'numer' são usadas para
     átomos que possuem essa propriedade, e.g.  '%pi'.

 -- Variável de opção: tr_optimize_max_loop
     Valor por omissão: 100

     'tr_optimize_max_loop' é número máximo de vezes do passo de
     macro-expansão e optimização que o tradutor irá executar
     considerando uma forma.  Isso é para capturar erros de expansão de
     macro, e propriedades de optimização não terminadas.

 -- Variável de opção: tr_semicompile
     Valor por omissão: 'false'

     Quando 'tr_semicompile' for 'true', as formas de saída de
     'translate_file' e 'compfile' serão macroexpandidas mas não
     compiladas em código de máquina pelo compilador Lisp.

 -- Variável de sistema: tr_state_vars
     Valor por omissão:
          [transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
          tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
          tr_function_call_default, tr_array_as_ref,tr_numer]

     A lista de comutadores que afectam a forma de saída da tradução.
     Essa informação é útil para sistemas populares quando tentam
     depurar o tradutor.  Comparando o produto traduzido para o qual
     pode ter sido produzido por um dado estado, isso é possível para
     rastrear erros.

 -- Função: tr_warnings_get ()
     Imprime uma lista de alertas que podem ter sido dadas pelo tradutor
     durante a tradução corrente.

 -- Variável de opção: tr_warn_bad_function_calls
     Valor por omissão: 'true'

     - Emite um alerta quando chamadas de função estão sendo feitas por
     um caminho que pode não ser correcto devido a declarações
     impróprias que foram feitas em tempo de tradução.

 -- Variável de opção: tr_warn_fexpr
     Valor por omissão: 'compfile'

     - Emite um alerta se quaisquer FEXPRs forem encontradas.  FEXPRs
     não poderão normalmente ser saída em código traduzido, todas as
     formas de programa especial legítimo são traduzidas.

 -- Variável: tr_warn_meval
     Valor por omissão: 'compfile'

     - Emite um alerta se a função 'meval' recebe chamadas.  Se 'meval'
     é chamada isso indica problemas na tradução.

 -- Variável: tr_warn_mode
     Valor por omissão: 'all'

     - Emite um alerta quando a variáveis forem atribuídos valores
     inapropriados para seu modo.

 -- Variável de opção: tr_warn_undeclared
     Valor por omissão: 'compile'

     - Determina quando enviar alertas sobre variáveis não declaradas
     para o TTY.

 -- Variável de opção: tr_warn_undefined_variable
     Valor por omissão: 'all'

     - Emite um alerta quando variáveis globais indefinidas forem
     vistas.

 -- Função: compile_file (<nomeficheiro>)
 -- Função: compile_file (<nomeficheiro>, <nomeficheiro_compilado>)
 -- Função: compile_file (<nomeficheiro>, <nomeficheiro_compilado>,
          <lisp_nomeficheiro>)
     Traduz o ficheiro Maxima <nomeficheiro> para Lisp, executa o
     compilador Lisp, e, se a tradução e a compilação obtiverem sucesso,
     chama o código compilado dentro do Maxima.

     'compile_file' retorna uma lista dos nomes de quatro ficheiros: o
     ficheiro original do Maxima, o nome da tradução Lisp, uma ficheiro
     de notas sobre a tradução, e o nome do ficheiro que contém o código
     compilado.  Se a compilação falhar, o quarto item é 'false'.

     Algumas declarações e definições passam a ter efeito tão logo o
     código Lisp seja compilado (sem que seja necessário chamar o código
     compilado).  Isso inclui funções definidas com o operador ':=',
     macros definidas com o operador '::=', 'alias', 'declare',
     'define_variable', 'mode_declare', e 'infix', 'matchfix', 'nofix',
     'postfix', 'prefix', e 'compfile'.

     Atribuições e chamadas de função não serão avaliadas até que o
     código compilado seja carregado.  Em particular, dentro do ficheiro
     Maxima, atribuições para sinalizadores traduzidos ('tr_numer',
     etc.)  não têm efeito sobre a tradução.

     <nomeficheiro> pode não conter declarações ':lisp'.

     'compile_file' avalia seus argumentos.

 -- Função: declare_translated (<f_1>, <f_2>, ...)
     Quando traduzindo um ficheiro do código Maxima para Lisp, é
     importante para o programa tradutor saber quais funções no ficheiro
     são para serem chamadas como funções traduzidas ou compiladas, e
     quais outras são apenas funções Maxima ou indefinidas.  Colocando
     essa declaração no topo do ficheiro, faremos conhecido que embora
     um símbolo diga que não temos ainda um valor de função Lisp,
     teremos uma em tempo de chamada.  '(MFUNCTION-CALL fn arg1 arg2
     ...)' é gerado quando o tradutor n~ao sabe que 'fn' está sendo
     compilada para ser uma função Lisp.


File: maxima.info,  Node: Fluxo de Programa,  Next: Depuração,  Prev: Definição de Função,  Up: Top

40 Fluxo de Programa
********************

* Menu:

* Introdução a Fluxo de Programa::  
* Definições para Fluxo de Programa::  


File: maxima.info,  Node: Introdução a Fluxo de Programa,  Next: Definições para Fluxo de Programa,  Prev: Fluxo de Programa,  Up: Fluxo de Programa

40.1 Introdução a Fluxo de Programa
===================================

Maxima fornece um 'do' para ciclos iterativos, também contruções mais
primitivas tais como 'go'.


File: maxima.info,  Node: Definições para Fluxo de Programa,  Prev: Introdução a Fluxo de Programa,  Up: Fluxo de Programa

40.2 Definições para Fluxo de Programa
======================================

 -- Função: backtrace ()
 -- Função: backtrace (<n>)
     Imprime a pilha de chamadas, que é, a lista de funções que foram
     chamadas pela função correntemente activa.

     'backtrace()' imprime toda a pilha de chamadas.

     'backtrace (<n>)' imprime as <n> mais recentes chamadas a funções,
     incluindo a função correntemente activa.

     'backtrace' pode ser chamada por um script, uma função, ou a partir
     da linha de comando interativa (não somente em um contexto de
     depuração).

     Exemplos:

        * 'backtrace()' imprime toda a pilha de chamadas.

               (%i1) h(x) := g(x/7)$
               (%i2) g(x) := f(x-11)$
               (%i3) f(x) := e(x^2)$
               (%i4) e(x) := (backtrace(), 2*x + 13)$
               (%i5) h(10);
               #0: e(x=4489/49)
               #1: f(x=-67/7)
               #2: g(x=10/7)
               #3: h(x=10)
                                             9615
               (%o5)                         ----
                                              49

        * 'backtrace (<n>)' imprime as <n> mais recentes chamadas a
          funções, incluindo a função correntemente activa.

               (%i1) h(x) := (backtrace(1), g(x/7))$
               (%i2) g(x) := (backtrace(1), f(x-11))$
               (%i3) f(x) := (backtrace(1), e(x^2))$
               (%i4) e(x) := (backtrace(1), 2*x + 13)$
               (%i5) h(10);
               #0: h(x=10)
               #0: g(x=10/7)
               #0: f(x=-67/7)
               #0: e(x=4489/49)
                                             9615
               (%o5)                         ----
                                              49

 -- Operador especial: do
     A declaração 'do' é usada para executar iteração.  Devido à sua
     grande generalidade a declaração 'do' será descrita em duas partes.
     Primeiro a forma usual será dada que é análoga à forma que é usada
     em muitas outras linguagens de programação (Fortran, Algol, PL/I,
     etc.); em segundo lugar os outros recursos serão mencionados.

     Existem três variantes do operador especial 'do' que diferem
     somente por suas condições de encerramento.  São elas:

        * 'for <Variável>: <valor_inicial> step <incremento> thru
          <limite> do <corpo>'
        * 'for <Variável>: <valor_inicial> step <incremento> while
          <condition> do <corpo>'
        * 'for <Variável>: <valor_inicial> step <incremento> unless
          <condition> do <corpo>'

     (Alternativamente, o 'step' pode ser dado após a condição de
     encerramento ou limite.)

     <valor_inicial>, <incremento>, <limite>, e <corpo> podem ser
     quaisquer expressões.  Se o incremento for 1 então "'step 1'" pode
     ser omitido.

     A execução da declaração 'do' processa-se primeiro atribuindo o
     valor_inicial para a variável (daqui em diante chamada a variável
     de controle).  Então: (1) Se a variável de controle excede o limite
     de uma especificação 'thru', ou se a condição de 'unless' for
     'true', ou se a condição de 'while' for 'false' então o 'do' será
     encerrado.  (2) O corpo é avaliado.  (3) O incremento é adicionado
     à variável de controle.  O processo de (1) a (3) é executado
     repetidamente até que a condição de encerramento seja satisfeita.
     Pode-se também dar muitas condições de encerramento e nesse caso o
     'do' termina quando qualquer delas for satisfeita.

     Em geral o teste 'thru' é satisfeito quando a variável de controle
     for maior que o limite se o incremento for não negativo, ou quando
     a variável de controle for menor que o limite se o incremento for
     negativo.  O incremento e o limite podem ser expressões não
     numéricas enquanto essa desigualdade puder ser determinada.
     Todavia, a menos que o incremento seja sintaticamente negativo
     (e.g.  for um número negativo) na hora em que a declaração 'do' for
     iniciada, Maxima assume que o incremento e o limite serão positivos
     quando o 'do' for executado.  Se o limite e o incremento não forem
     positivos, então o 'do' pode não terminar propriamente.

     Note que o limite, incremento, e condição de encerramento são
     avaliados cada vez que ocorre um ciclo.  Dessa forma se qualquer
     desses for responsável por muitos cálculos, e retornar um resultado
     que não muda durante todas as execuções do corpo, então é mais
     eficiente escolher uma variável para seu valor anterior para o 'do'
     e usar essa variável na forma 'do'.

     O valor normalmente retornado por uma declaração 'do' é o átomo
     'done'.  Todavia, a função 'return' pode ser usada dentro do corpo
     para sair da delcaração 'do' prematuramente e dar a isso qualquer
     valor desejado.  Note todavia que um 'return' dentro de um 'do' que
     ocorre em um 'block' encerrará somente o 'do' e não o 'block'.
     Note também que a função 'go' não pode ser usada para sair de
     dentro de um 'do' dentro de um 'block' que o envolve.

     A variável de controle é sempre local para o 'do' e dessa forma
     qualquer variável pode ser usada sem afectar o valor de uma
     variável com o mesmo nome fora da declaração 'do'.  A variável de
     controle é liberada após o encerramento da declaração 'do'.

          (%i1) for a:-3 thru 26 step 7 do display(a)$
                                       a = - 3

                                        a = 4

                                       a = 11

                                       a = 18

                                       a = 25

          (%i1) s: 0$
          (%i2) for i: 1 while i <= 10 do s: s+i;
          (%o2)                         done
          (%i3) s;
          (%o3)                          55

     Note que a condição 'while i <= 10' é equivalente a 'unless i > 10'
     e também 'thru 10'.

          (%i1) series: 1$
          (%i2) term: exp (sin (x))$
          (%i3) for p: 1 unless p > 7 do
                    (term: diff (term, x)/p,
                     series: series + subst (x=0, term)*x^p)$
          (%i4) series;
                            7    6     5    4    2
                           x    x     x    x    x
          (%o4)            -- - --- - -- - -- + -- + x + 1
                           90   240   15   8    2

     que fornece 8 termos da série de Taylor para 'e^sin(x)'.

          (%i1) poly: 0$
          (%i2) for i: 1 thru 5 do
                    for j: i step -1 thru 1 do
                        poly: poly + i*x^j$
          (%i3) poly;
                            5      4       3       2
          (%o3)          5 x  + 9 x  + 12 x  + 14 x  + 15 x
          (%i4) guess: -3.0$
          (%i5) for i: 1 thru 10 do
                    (guess: subst (guess, x, 0.5*(x + 10/x)),
                     if abs (guess^2 - 10) < 0.00005 then return (guess));
          (%o5)                  - 3.162280701754386

     Esse exemplo calcula a raíz quadrada negativa de 10 usando a
     iteração de Newton- Raphson um maximum de 10 vezes.  Caso o
     critério de convergêcia não tenha sido encontrado o valor retornado
     pode ser 'done'.  Em lugar de sempre adicionar uma quantidade à
     variável de controle pode-se algumas vezes desejar alterar isso de
     alguma outra forma para cada iteração.  Nesse caso pode-se usar
     'next <expressão>' em lugar de 'step <incremento>'.  Isso fará com
     que a variável de controle seja escolhida para o resultado da
     expressão de avaliação cada vez que o ciclo de repetição for
     executado.

          (%i6) for count: 2 next 3*count thru 20 do display (count)$
                                      count = 2

                                      count = 6

                                     count = 18

     Como uma alternativa para 'for <Variável>: <valor> ...do...' a
     sintaxe 'for <Variável> from <valor> ...do...' pode ser usada.
     Isso permite o 'from <valor>' ser colocado após o 'step' ou proximo
     valor ou após a condição de encerramento.  Se 'from <valor>' for
     omitido então 1 é usado como o valor inicial.

     Algumas vezes se pode estar interessado em executar uma iteração
     onde a variável de controle nunca seja usada.  Isso é permissível
     para dar somente as condições de encerramento omitindo a
     inicialização e a informação de actualização como no exemplo
     seguinte para para calcular a raíz quadrada de 5 usando uma fraca
     suposição inicial.

          (%i1) x: 1000$
          (%i2) thru 20 do x: 0.5*(x + 5.0/x)$
          (%i3) x;
          (%o3)                   2.23606797749979
          (%i4) sqrt(5), numer;
          (%o4)                   2.23606797749979

     Se isso for desejado pode-se sempre omitir as condições de
     encerramento inteiramente e apenas dar o corpo 'do <corpo>' que
     continuará a ser avaliado indefinidamente.  Nesse caso a função
     'return' será usada para encerrar a execução da declaração 'do'.

          (%i1) newton (f, x):= ([y, df, dfx], df: diff (f ('x), 'x),
                    do (y: ev(df), x: x - f(x)/y,
                        if abs (f (x)) < 5e-6 then return (x)))$
          (%i2) sqr (x) := x^2 - 5.0$
          (%i3) newton (sqr, 1000);
          (%o3)                   2.236068027062195

     (Note que 'return', quando executado, faz com que o valor corrente
     de 'x' seja retornado como o valor da declaração 'do'.  O 'block' é
     encerrado e esse valor da declaração 'do' é retornado como o valor
     do 'block' porque o 'do' é a última declaração do 'block'.)

     Uma outra forma de 'do' é disponível no Maxima.  A sintaxe é:

          for <Variável> in <list> <end_tests> do <corpo>

     Os elementos de <list> são quaisquer expressões que irão
     sucessivamente ser atribuídas para a variável a cada iteração do
     corpo.  O teste opcional <end_tests> pode ser usado para encerrar a
     execução da declaração 'do'; de outra forma o 'do' terminará quando
     a lista for exaurida ou quando um 'return' for executado no corpo.
     (De facto, a lista pode ser qualquer expressão não atômica, e
     partes sucessivas são usadas.)

          (%i1)  for f in [log, rho, atan] do ldisp(f(1))$
          (%t1)                                  0
          (%t2)                                rho(1)
                                               %pi
          (%t3)                                 ---
                                                4
          (%i4) ev(%t3,numer);
          (%o4)                             0.78539816

 -- Função: errcatch (<expr_1>, ..., <expr_n>)
     Avalia <expr_1>, ..., <expr_n> uma por uma e retorna '[<expr_n>]'
     (uma lista) se nenhum erro ocorrer.  Se um erro ocorrer na
     avaliação de qualquer argumento, 'errcatch' evita que o erro se
     propague e retorna a lista vazia '[]' sem avaliar quaisquer mais
     argumentos.

     'errcatch' é útil em ficheiros 'batch' onde se suspeita que um erro
     possa estar ocorrendo o 'errcatch' terminará o 'batch' se o erro
     não for detectado.

 -- Função: error (<expr_1>, ..., <expr_n>)
 -- Variável de sistema: error
     Avalia e imprime <expr_1>, ..., <expr_n>, e então causa um retorno
     de erro para o nível mais alto do Maxima ou para o mais próximo
     contendo 'errcatch'.

     A variável 'error' é escolhida para uma lista descrevendo o erro.
     O primeiro elemento de 'error' é uma sequência de caracteres de
     formato, que junta todas as sequências de caracteres entre os
     argumentos <expr_1>, ..., <expr_n>, e os elementos restantes são os
     valores de quaisquer argumentos que não são sequências de
     caracteres.

     'errormsg()' formata e imprime 'error'.  Isso efectivamente
     reimprime a mais recente mensagem de erro.

 -- Função: errormsg ()
     Reimprime a mais recente mensagem de erro.  A variável 'error'
     recebe a mensagem, e 'errormsg' formata e imprime essa mensagem.

 -- Operador especial: for
     Usado em iterações.  Veja 'do' para uma descrição das facilidades
     de iteração do Maxima.

 -- Função: go (<tag>)
     é usada dentro de um 'block' para transferir o controle para a
     declaração do bloco que for identificada com o argumento para 'go'.
     Para identificar uma declaração, coloque antes dessa declaração um
     argumento atômico como outra declaração no 'block'.  Por exemplo:

          block ([x], x:1, loop, x+1, ..., go(loop), ...)

     O argumento para 'go' deve ser o nome de um identificardor
     aparecendo no mesmo 'block'.  Não se pode usar 'go' para transferir
     para um identificador em um outro 'block' que não seja o próprio
     contendo o 'go'.

 -- Operador especial: if
     Representa avaliação condicional.  Várias formas de expressões 'if'
     são reconhecidas.  'if <cond_1> then <expr_1> else <expr_0>' avalia
     para <expr_1> se <cond_1> avaliar para 'true', de outra forma a
     expressão avalia para 'expr_0'.

     'if <cond_1> then <expr_1> elseif <cond_2> then <expr_2> elseif ...
     else <expr_0>' avalia para <expr_k> se <cond_k> for 'true' e todas
     as condições precedentes forem 'false'.  Se nenhuma das condições
     forem 'true', a expressão avalia para 'expr_0'.

     O comportamento 'else false' é assumido se 'else' for omitido.
     Isso é, 'if <cond_1> then <expr_1>' é equivalente a 'if <cond_1>
     then <expr_1> else false', e 'if <cond_1> then <expr_1> elseif ...
     elseif <cond_n> then <expr_n>' é equivalente a 'if <cond_1> then
     <expr_1> elseif ... elseif <cond_n> then <expr_n> else false'.

     As alternativas <expr_0>, ..., <expr_n> podem ser quaisquer
     expressões do Maxima, incluíndo expressões 'if' aninhadas ( if
     dentro de if).  As alternativas não são nem simplificadas nem
     avaliadas a menos que a correspondente condição seja 'true'.

     As condições <cond_1>, ..., <cond_n> são expressões tais que
     'is(<cond_k>)' avaliem para 'true' ou para 'false'; de outra forma
     é um erro.  Entre outros elementos, condições podem compreender
     operadores lógicos e relacionais como segue.

          Operação             Símbolo      Tipo

          menor que            <           infixo relacional
          menor que            <=
            ou igual a                     infixo relacional
          igualdade            =
            (sintática)                    infixo relacional
          negação de =         #           infixo relacional
          igualdade (valor)    equal       função relacional
          negação de           notequal
            igualdade                      função relacional
          maior que            >=
            ou igual a                     infixo relacional
          maior que            >           infixo relacional
          e                    and         infixo lógico
          ou                   or          infixo lógico
          não                  not         prefixo lógico

 -- Função: map (<f>, <expr_1>, ..., <expr_n>)
     Retorna uma expressão cujo operador principal é o mesmo que o das
     expressões <expr_1>, ..., <expr_n> mas cujas subpartes são os
     resultados da aplicação de <f> nas correspondentes subpartes das
     expressões.  <f> é ainda o nome de uma função de n argumentos ou é
     uma forma 'lambda' de n argumentos.

     'maperror' - se 'false' fará com que todas as funções mapeadas (1)
     parem quando elas terminarem retornando a menor expi se não forem
     todas as expi do mesmo comprimento e (2) aplique fn a [exp1,
     exp2,...]  se expi não forem todas do mesmo tipo de objecto.  Se
     'maperror' for 'true' então uma mensagem de erro será dada nas duas
     instâncias acima.

     Um dos usos dessa função é para mapear ('map') uma função (e.g.
     'partfrac') sobre cada termo de uma expressão muito larga onde isso
     comumente não poderia ser possível usar a função sobre a expressão
     inteira devido a uma exaustão de espaço da lista de armazenamento
     no decorrer da computação.

          (%i1) map(f,x+a*y+b*z);
          (%o1)                        f(b z) + f(a y) + f(x)
          (%i2) map(lambda([u],partfrac(u,x)),x+1/(x^3+4*x^2+5*x+2));
                                     1       1        1
          (%o2)                     ----- - ----- + -------- + x
                                   x + 2   x + 1          2
                                                   (x + 1)
          (%i3) map(ratsimp, x/(x^2+x)+(y^2+y)/y);
                                                1
          (%o3)                            y + ----- + 1
                                              x + 1
          (%i4) map("=",[a,b],[-0.5,3]);
          (%o4)                          [a = - 0.5, b = 3]


 -- Função: mapatom (<expr>)
     Retorna 'true' se e somente se <expr> for tratada pelas rotinas de
     mapeamento como um átomo.  "Mapatoms" são átomos, números
     (incluíndo números racioanais), e variáveis subscritas.

 -- Variável de opção: maperror
     Valor por omissão: 'true'

     Quando 'maperror' é 'false', faz com que todas as funções mapeadas,
     por exemplo

          map (f, expr_1, expr_2, ...))

     (1) parem quando elas terminarem retornando a menor expi se não
     forem todas as expi do mesmo comprimento e (2) aplique 'f' a
     '[expr_1, expr_2, ...]' se 'expr_i' não forem todas do mesmo tipo
     de objecto.

     Se 'maperror' for 'true' então uma ,mensagem de erro é mostrada nas
     duas instâncias acima.

 -- Função: maplist (<f>, <expr_1>, ..., <expr_n>)
     Retorna uma lista de aplicações de <f> em todas as partes das
     expressões <expr_1>, ..., <expr_n>.  <f> é o nome de uma função, ou
     uma expressão lambda.

     'maplist' difere de 'map (<f>, <expr_1>, ..., <expr_n>)' que
     retorna uma expressão com o mesmo operador principal que <expr_i>
     tem (excepto para simplificações e o caso onde 'map' faz um
     'apply').

 -- Variável de opção: prederror
     Valor por omissão: 'true'

     Quando 'prederror' for 'true', uma mensagem de erro é mostrada
     sempre que o predicado de uma declaração 'if' ou uma função 'is'
     falha em avaliar ou para 'true' ou para 'false'.

     Se 'false', 'unknown' é retornado no lugar nesse caso.  O modo
     'prederror: false' não é suportado no código traduzido; todavia,
     'maybe' é suportado no código traduzido.

     Veja também 'is' e 'maybe'.

 -- Função: return (valor)
     Pode ser usada para sair explicitamente de um bloco, levando seu
     argumento.  Veja 'block' para mais informação.

 -- Função: scanmap (<f>, <expr>)
 -- Função: scanmap (<f>, <expr>, bottomup)
     Recursivamente aplica <f> a <expr>, de cima para baixo.  Isso é
     muito útil quando uma factoração completa é desejada, por exemplo:

          (%i1) exp:(a^2+2*a+1)*y + x^2$
          (%i2) scanmap(factor,exp);
                                              2      2
          (%o2)                         (a + 1)  y + x

     Note o caminho através do qual 'scanmap' aplica a dada função
     'factor' para as subexpressões constituintes de <expr>; se outra
     forma de <expr> é apresentada para 'scanmap' então o resultado pode
     ser diferente.  Dessa forma, '%o2' não é recuperada quando
     'scanmap' é aplicada para a forma expandida de exp:

          (%i3) scanmap(factor,expand(exp));
                                     2                  2
          (%o3)                      a  y + 2 a y + y + x

     Aqui está um outro exemplo do caminho no qual 'scanmap' aplica
     recursivamente uma função dada para todas as subexpressões,
     incluindo expoentes:

          (%i4) expr : u*v^(a*x+b) + c$
          (%i5) scanmap('f, expr);
                              f(f(f(a) f(x)) + f(b))
          (%o5) f(f(f(u) f(f(v)                      )) + f(c))

     'scanmap (<f>, <expr>, bottomup)' aplica <f> a <expr> de baixo para
     cima.  E.g., para 'f' indefinida,

          scanmap(f,a*x+b) ->
             f(a*x+b) -> f(f(a*x)+f(b)) -> f(f(f(a)*f(x))+f(b))
          scanmap(f,a*x+b,bottomup) -> f(a)*f(x)+f(b)
              -> f(f(a)*f(x))+f(b) ->
               f(f(f(a)*f(x))+f(b))

     Neste caso, obtém-se a mesma resposta pelos dois métodos.

 -- Função: throw (<expr>)
     Avalia <expr> e descarta o valor retornado para o mais recente
     'catch'.  'throw' é usada com 'catch' como um mecanismo de retorno
     não local.

 -- Operador especial: while
     Veja 'do'.

 -- Função: outermap (<f>, <a_1>, ..., <a_n>)
     Aplica a função <f> para cada um dos elementos do produto externo
     <a_1> vezes <a_2> ...  vezes <a_n>.

     <f> é o nome de uma função de n argumentos ou uma expressão lambda
     de n argumentos.  Cada argumento <a_k> pode ser uma lista simples
     ou lista aninhada ( lista contendo listas como elementos ), ou uma
     matrz, ou qualquer outro tip de expressão.

     O valor de retorno de 'outermap' é uma estrutura aninhada.  Tomemos
     <x> como sendo o valor de retorno.  Então <x> tem a mesma estrutura
     da primeira lista, lista aninhada, ou argumento matriz,
     '<x>[i_1]...[i_m]' tem a mesma estrutura que a segunda lista, lista
     aninhada, ou argumento matriz, '<x>[i_1]...[i_m][j_1]...[j_n]' tem
     a mesma estrutura que a terceira lista, lista aninhada, ou
     argumento matriz, e assim por diante, onde <m>, <n>, ...  são os
     números dos índices requeridos para acessar os elementos de cada
     argumento (um para uma lista, dois para uma matriz, um ou mais para
     uma lista aninhada).  Argumentos que não forem listas ou matrizes
     não afectam a estrutura do valor de retorno.

     Note que o efeito de 'outermap' é diferente daquele de aplicar <f>
     a cada um dos elementos do produto externo retornado por
     'cartesian_product'.  'outermap' preserva a estrutura dos
     argumentos no valor de retorno, enquanto 'cartesian_product' não
     reserva essa mesma estrutura.

     'outermap' avalia seus argumentos.

     Veja também 'map', 'maplist', e 'apply'.

     Exemplos: Exemplos elementares de 'outermap'.  Para mostrar a a
     combinação de argumentos mais claramente, 'F' está indefinida à
     esquerda.

          (%i1) outermap (F, [a, b, c], [1, 2, 3]);
          (%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)],
                                               [F(c, 1), F(c, 2), F(c, 3)]]
          (%i2) outermap (F, matrix ([a, b], [c, d]), matrix ([1, 2], [3, 4]));
                   [ [ F(a, 1)  F(a, 2) ]  [ F(b, 1)  F(b, 2) ] ]
                   [ [                  ]  [                  ] ]
                   [ [ F(a, 3)  F(a, 4) ]  [ F(b, 3)  F(b, 4) ] ]
          (%o2)    [                                            ]
                   [ [ F(c, 1)  F(c, 2) ]  [ F(d, 1)  F(d, 2) ] ]
                   [ [                  ]  [                  ] ]
                   [ [ F(c, 3)  F(c, 4) ]  [ F(d, 3)  F(d, 4) ] ]
          (%i3) outermap (F, [a, b], x, matrix ([1, 2], [3, 4]));
                 [ F(a, x, 1)  F(a, x, 2) ]  [ F(b, x, 1)  F(b, x, 2) ]
          (%o3) [[                        ], [                        ]]
                 [ F(a, x, 3)  F(a, x, 4) ]  [ F(b, x, 3)  F(b, x, 4) ]
          (%i4) outermap (F, [a, b], matrix ([1, 2]), matrix ([x], [y]));
                 [ [ F(a, 1, x) ]  [ F(a, 2, x) ] ]
          (%o4) [[ [            ]  [            ] ],
                 [ [ F(a, 1, y) ]  [ F(a, 2, y) ] ]
                                        [ [ F(b, 1, x) ]  [ F(b, 2, x) ] ]
                                        [ [            ]  [            ] ]]
                                        [ [ F(b, 1, y) ]  [ F(b, 2, y) ] ]
          (%i5) outermap ("+", [a, b, c], [1, 2, 3]);
          (%o5) [[a + 1, a + 2, a + 3], [b + 1, b + 2, b + 3],
                                                     [c + 1, c + 2, c + 3]]

     Uma explanação final do valor de retorno de 'outermap'.  Os
     argumentos primeiro, segundo, e terceiro são matriz, lista, e
     matriz, respectivamente.  O valor de retorno é uma matriz.  Cada
     elementos daquela matriz é uma lista, e cada elemento de cada lista
     é uma matriz.

          (%i1) arg_1 :  matrix ([a, b], [c, d]);
                                      [ a  b ]
          (%o1)                       [      ]
                                      [ c  d ]
          (%i2) arg_2 : [11, 22];
          (%o2)                       [11, 22]
          (%i3) arg_3 : matrix ([xx, yy]);
          (%o3)                      [ xx  yy ]
          (%i4) xx_0 : outermap (lambda ([x, y, z], x / y + z), arg_1, arg_2, arg_3);
                         [  [      a        a  ]  [      a        a  ]  ]
                         [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                         [  [      11       11 ]  [      22       22 ]  ]
          (%o4)  Col 1 = [                                              ]
                         [  [      c        c  ]  [      c        c  ]  ]
                         [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                         [  [      11       11 ]  [      22       22 ]  ]
                           [  [      b        b  ]  [      b        b  ]  ]
                           [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                           [  [      11       11 ]  [      22       22 ]  ]
                   Col 2 = [                                              ]
                           [  [      d        d  ]  [      d        d  ]  ]
                           [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                           [  [      11       11 ]  [      22       22 ]  ]
          (%i5) xx_1 : xx_0 [1][1];
                     [      a        a  ]  [      a        a  ]
          (%o5)     [[ xx + --  yy + -- ], [ xx + --  yy + -- ]]
                     [      11       11 ]  [      22       22 ]
          (%i6) xx_2 : xx_0 [1][1] [1];
                                [      a        a  ]
          (%o6)                 [ xx + --  yy + -- ]
                                [      11       11 ]
          (%i7) xx_3 : xx_0 [1][1] [1] [1][1];
                                            a
          (%o7)                        xx + --
                                            11
          (%i8) [op (arg_1), op (arg_2), op (arg_3)];
          (%o8)                  [matrix, [, matrix]
          (%i9) [op (xx_0), op (xx_1), op (xx_2)];
          (%o9)                  [matrix, [, matrix]

     'outermap' preserves the structure of the arguments in the return
     value, while 'cartesian_product' does not.

          (%i1) outermap (F, [a, b, c], [1, 2, 3]);
          (%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)],
                                               [F(c, 1), F(c, 2), F(c, 3)]]
          (%i2) setify (flatten (%));
          (%o2) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3),
                                                 F(c, 1), F(c, 2), F(c, 3)}
          (%i3) map (lambda ([L], apply (F, L)), cartesian_product ({a, b, c}, {1, 2, 3}));
          (%o3) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3),
                                                 F(c, 1), F(c, 2), F(c, 3)}
          (%i4) is (equal (%, %th (2)));
          (%o4)                         true


File: maxima.info,  Node: Depuração,  Next: augmented_lagrangian,  Prev: Fluxo de Programa,  Up: Top

41 Depuração
************

* Menu:

* Depuração do Código Fonte::
* Comandos Palavra Chave::
* Definições para Depuração::   


File: maxima.info,  Node: Depuração do Código Fonte,  Next: Comandos Palavra Chave,  Up: Depuração

41.1 Depuração do Código Fonte
==============================

Maxima tem um depurador interno de código fonte.  O utilizador pode
escolher um ponto de parada numa função, e executar o programa linha por
linha a partir daí.  A pilha de chamadas pode ser examinada, juntamente
com as variáveis existentes nesse nível.

O comando ':help' ou ':h' mostra a lista de comandos de depuração.  (Em
geral, os comandos podem ser abreviados se a abreviação for única.  Se
não for única, as alternativas podem ser listadas.)  Dentro do
depurador, o utilizador pode também usar quaisquer funções comuns do
Maxima para examinar, definir, e manipular variáveis e expressões.

Um ponto de parada é escolhido através do comando ':br' na linha de
comando do Maxima.  Dentro do depurador, o utilizador pode avançar uma
linha de cada vez usando o comando ':n' ("next").  o comando ':bt'
("backtrace") mostra uma lista da pilha de frames.  O comando ':r'
("resume") sai do depurador e continua com a execução.  Esses comandos
são demostrados no exemplo a seguir.

     (%i1) load ("/tmp/foobar.mac");

     (%o1)                           /tmp/foobar.mac

     (%i2) :br foo
     Turning on debugging debugmode(true)
     Bkpt 0 for foo (in /tmp/foobar.mac line 1)

     (%i2) bar (2,3);
     Bkpt 0:(foobar.mac 1)
     /tmp/foobar.mac:1::

     (dbm:1) :bt                        <-- :bt digitado aqui lista os frames
     #0: foo(y=5)(foobar.mac line 1)
     #1: bar(x=2,y=3)(foobar.mac line 9)

     (dbm:1) :n                         <-- Aqui digite :n para avançar linha
     (foobar.mac 2)
     /tmp/foobar.mac:2::

     (dbm:1) :n                         <-- Aqui digite :n para avançar linha
     (foobar.mac 3)
     /tmp/foobar.mac:3::

     (dbm:1) u;                         <-- Investiga o valor de u
     28

     (dbm:1) u: 33;                     <-- Altera u para ser 33
     33

     (dbm:1) :r                         <-- Digite :r para retomar a computação

     (%o2)                                1094

O ficheiro '/tmp/foobar.mac' é o seguinte:

     foo(y) := block ([u:y^2],
       u: u+3,
       u: u^2,
       u);

     bar(x,y) := (
       x: x+2,
       y: y+2,
       x: foo(y),
       x+y);

USO DO DEPURADOR ATRAVÉS DO EMACS E DE XMAXIMA

Se o utilizador estiver a executar o código sob o GNU Emacs numa janela
shell (shel dbl), ou estiver usando a interface gráfica, 'xmaxima',
então quando parar num ponto de parada, verá a sua posição actual no
ficheiro fonte apresentada na outra metade da janela, ou em vermelho
brilhante, ou com uma pequena seta apontando na direita da linha.
Poderá avançar uma linha por vez digitando M-n (Alt-n).

No Emacs pode executar o Maxima numa shell 'dbl', o qual requer o
ficheiro 'dbl.el' no directório elisp.  Verifique que tenha instalado os
ficheiros elisp ou adicionado o directório elisp do Maxima ao seu
caminho: e.g., adicione o seguinte ao seu ficheiro '.emacs' ou ao seu
ficheiro 'site-init.el'

     (setq load-path (cons "/usr/share/maxima/5.9.1/emacs" load-path))
     (autoload 'dbl "dbl")

então no Emacs

     M-x dbl

pode iniciar uma janela shell na qual pode executar programas, por
exemplo Maxima, gcl, gdb etc.  Essa janela de shell também reconhece
informações sobre depuração de código fonte, e mostra o código fonte em
outra janela.

O utilizador pode escolher um ponto de parada em certa linha do ficheiro
digitando 'C-x space'.  Isso encontra qual a função onde o cursor está
posicionado, e mostra qual a linha daquela função onde o cursor está
habilitado.  Se o cursor estiver habilitado, digamos, na linha 2 de
'foo', então isso irá inserir na outra janela o comando, "':br foo 2'",
para parar 'foo' nessa segunda linha.  Para ter isso habilitado, o
utilizador deve ter maxima-mode.el habilitado na janela na qual o
ficheiro 'foobar.mac' estiver interagindo.  Existe comandos adicional
disponíveis naquela janela de ficheiro, tais como avaliando a função
dentro do Maxima, através da digitação de 'Alt-Control-x'.


File: maxima.info,  Node: Comandos Palavra Chave,  Next: Definições para Depuração,  Prev: Depuração do Código Fonte,  Up: Depuração

41.2 Comandos Palavra Chave
===========================

Comandos palavra chave são palavras chaves especiais que não são
interpretadas como expressões do Maxima.  Um comando palavra chave pode
ser inserido na linha de comando do Maxima ou na linha de comando do
depurador, embora não possa ser inserido na linha de comando de parada.
Comandos palavra chave iniciam com um dois pontos Keyword commands start
with a colon, ':'.  Por exemplo, para avaliar um comando do Lisp, pode
escrever ':lisp' seguido pelo comando a ser avaliado.

     (%i1) :lisp (+ 2 3)
     5

O número de argumentos necessários depende do comando em particular.
Também, não precisa escrever o comando completo, apenas o suficiente
para ser único no meio das palavras chave de parada.  Dessa forma ':br'
será suficiente para ':break'.

Os comandos de palavra chave são listados abaixo.

':break F n'
     Escolhe um ponto de parada em uma função 'F' na linha 'n' a partir
     do início da função.  Se 'F' for dado como uma sequência de
     caracteres, então essa sequência de caracteres é assumida
     referir-se a um ficheiro, e 'n' é o deslocamente a partir do início
     do ficheiro.  O deslocamento é opcional.  Se for omitido, é
     assumido ser zero (primeira linha da função ou do ficheiro).
':bt'
     Imprime na tela uma lista da pilha de frames
':continue'
     Continua a computação
':delete'
     Remove o ponto de parada seleccionado, ou todos se nenum for
     especificado
':disable'
     Desabilita os pontos de parada seleccionados, ou todos se nenhum
     for especificado
':enable'
     Habilita os pontos de de parada especificados, ou todos se nenhum
     for especificado
':frame n'
     Imprime na tela a pilha de frame 'n', ou o corrente frame se nenhum
     for especificado
':help'
     Imprime na tela a ajuda sobre um comando do depurador, ou todos os
     comandos se nenhum for especificado
':info'
     Imprime na tela informações sobre um item
':lisp alguma-forma'
     Avalia 'alguma-forma' como uma forma Lisp
':lisp-quiet alguma-forma'
     Avalia a forma Lisp 'alguma-forma' sem qualquer saída
':next'
     Como ':step', excepto ':next' passos sobre chamadas de fução
':quit'
     Sai do nível corrente do depurador sem concluir a computação
':resume'
     Continua a computação
':step'
     Continua a computação até encontraruma nova linha de códico
':top'
     Retorne para a linha de comando do Maxima (saindo de qualquer nível
     do depurador) sem completar a computação


File: maxima.info,  Node: Definições para Depuração,  Prev: Comandos Palavra Chave,  Up: Depuração

41.3 Definições para Depuração
==============================

 -- Variável de opção: refcheck
     Valor por omissão: 'false'

     Quando 'refcheck' for 'true', Maxima imprime uma mensagem cada vez
     que uma variável associada for usada pela primeira vez em uma
     computação.

 -- Variável de opção: setcheck
     Valor por omissão: 'false'

     Se 'setcheck' for escolhido para uma lista de variáveis (as quais
     podem ser subscritas), Maxima mostra uma mensagem quando as
     variáveis, ou ocorrências subscritas delas, forem associadas com o
     operador comum de atribuição ':', o operador '::' de atribuição, ou
     associando argumentos de função, mas não com o operador de
     atribuição de função ':=' nem o operador de atribuição '::=' de
     macro.  A mensagem compreende o nome das variáveis e o valor
     associado a ela.

     'setcheck' pode ser escolhida para 'all' ou 'true' incluindo desse
     modo todas as variáveis.

     Cada nova atribuição de 'setcheck' estabelece uma nova lista de
     variáveis para verificar, e quaisquer variáveis previamente
     atribuídas a 'setcheck' são esquecidas.

     Os nomes atribuídos a 'setcheck' devem ter um apóstrofo no início
     se eles forem de outra forma avaliam para alguma outra coisa que
     não eles mesmo.  Por exemplo, se 'x', 'y', e 'z' estiverem
     actualmente associados, então digite

          setcheck: ['x, 'y, 'z]$

     para colocá-los na lista de variáveis monitoradas.

     Nenhuma saída é gerada quando uma variável na lista 'setcheck' for
     atribuída a sí mesma, e.g., 'X: 'X'.

 -- Variável de opção: setcheckbreak
     Valor por omissão: 'false'

     Quando 'setcheckbreak' for 'true', Maxima mostrará um ponto de
     parada quando uma variável sob a lista 'setcheck' for atribuída a
     um novo valor.  A parada ocorre antes que a atribuíção seja
     concluída.  Nesse ponto, 'setval' retém o valor para o qual a
     variável está para ser atribuída.  Consequentemente, se pode
     atribuir um valor diferente através da atribuição a 'setval'.

     Veja também 'setcheck' e 'setval'.

 -- Variável de sistema: setval
     Mantém o valor para o qual a variável está para ser escolhida
     quando um 'setcheckbreak' ocorrer.  Consequentemente, se pode
     atribuir um valor diferente através da atribuição a 'setval'.

     Veja também 'setcheck' e 'setcheckbreak'.

 -- Função: timer (<f_1>, ..., <f_n>)
 -- Função: timer ()
     Dadas as funções <f_1>, ..., <f_n>, 'timer' coloca cada uma na
     lista de funções para as quais cronometragens estatísticas são
     colectadas.  'timer(f)$ timer(g)$' coloca 'f' e então 'g' sobre a
     lista; a lista acumula de uma chamada para a chamada seguinte.

     Sem argumentos, 'timer' retorna a lista das funções tempo
     estatisticamente monitoradas.

     Maxima armazena quanto tempo é empregado executando cada função na
     lista de funções tempo estatisticamente monitoradas.  'timer_info'
     retorna a coronometragem estatística, incluindo o tempo médio
     decorrido por chamada de função, o número de chamadas, e o tempo
     total decorrido.  'untimer' remove funções da lista de funções
     tempo estatisticamente monitoradas.

     'timer' não avalia seus argumentos.  'f(x) := x^2$ g:f$ timer(g)$'
     não coloca 'f' na lista de funções estatisticamente monitoradas.

     Se 'trace(f)' está vigorando, então 'timer(f)' não tem efeito;
     'trace' e 'timer' não podem ambas atuarem ao mesmo tempo.

     Veja também 'timer_devalue'.

 -- Função: untimer (<f_1>, ..., <f_n>)
 -- Função: untimer ()
     Dadas as funções <f_1>, ..., <f_n>, 'untimer' remove cada uma das
     funções listadas da lista de funções estatisticamente monitoradas.

     Sem argumentos, 'untimer' remove todas as funções actualmente na
     lista de funções estatisticamente monitoradas.

     Após 'untimer (f)' ser executada, 'timer_info (f)' ainda retorna
     estatisticas de tempo previamente colectadas, embora 'timer_info()'
     (sem argumentos) não retorna informações sobre qualquer função que
     não estiver actualmente na lista de funções tempo estatisticamente
     monitoradas.  'timer (f)' reposiciona todas as estatisticas de
     tempo para zero e coloca 'f' na lista de funções estatisticamente
     monitoradas novamente.

 -- Variável de opção: timer_devalue
     Valor Padrão: 'false'

     Quando 'timer_devalue' for 'true', Maxima subtrai de cada função
     estatisticamente monitorada o tempo empregado em ou funções
     estatisticamente monitoradas.  De outra forma, o tempo reportado
     para cada função inclui o tempo empregado em outras funções.  Note
     que tempo empregado em funções não estatisticamente monitoradas não
     é subtraído do tempo total.

     Veja também 'timer' e 'timer_info'.

 -- Função: timer_info (<f_1>, ..., <f_n>)
 -- Função: timer_info ()
     Dadas as funções <f_1>, ..., <f_n>, 'timer_info' retorna uma matriz
     contendo informações de cronometragem para cada função.  Sem
     argumentos, 'timer_info' retorna informações de cronometragem para
     todas as funções actualmente na lista de funções estatisticamente
     monitoradas.

     A matriz retornada através de 'timer_info' contém o nome da função,
     tempo por chamda de função, número de chamadas a funções,tempo
     total, e 'gctime', cujja forma "tempo de descarte" no Macsyma
     original mas agora é sempre zero.

     Os dados sobre os quais 'timer_info' constrói seu valor de retorno
     podem também serem obtidos através da função 'get':

          get(f, 'calls);  get(f, 'runtime);  get(f, 'gctime);

     Veja também 'timer'.

 -- Função: trace (<f_1>, ..., <f_n>)
 -- Função: trace ()
     Dadas as funções <f_1>, ..., <f_n>, 'trace' instrui Maxima para
     mostrar informações de depuração quando essas funções forem
     chamadas.  'trace(f)$ trace(g)$' coloca 'f' e então 'g' na lista de
     funções para serem colocadas sob a ação de 'trace'; a lista acumula
     de uma chamada para a seguinte.

     Sem argumentos, 'trace' retorna uma lista de todas as funções
     actualmente sob a ação de 'trace'.

     A função 'untrace' desabilita a ação de 'trace'.  Veja também
     'trace_options'.

     'trace' não avalia seus argumentos.  Dessa forma, 'f(x) := x^2$
     g:f$ trace(g)$' não coloca 'f' sobre a lista de funções monitoradas
     por 'trace'.

     Quando uma função for redefinida, ela é removida da lista de
     'timer'.  Dessa forma após 'timer(f)$ f(x) := x^2$', a função 'f'
     não mais está na lista de 'timer'.

     Se 'timer (f)' estiver em efeito, então 'trace (f)' não está
     agindo; 'trace' e 'timer' não podem ambas estar agindo para a mesma
     função.

 -- Função: trace_options (<f>, <option_1>, ..., <option_n>)
 -- Função: trace_options (<f>)
     Escolhe as opções de 'trace' para a função <f>.  Quaisquer opções
     anteriores são substituídas.  'trace_options (<f>, ...)' não tem
     efeito a menos que 'trace (<f>)' tenha sido também chamada (ou
     antes ou após 'trace_options').

     'trace_options (<f>)' reposiciona todas as opções para seus valores
     padrão.

     As opções de palavra chave são:

        * 'noprint' Não mostre uma mensagem na entrada da função e saia.
        * 'break' Coloque um ponto de parada antes da função ser
          inserida, e após a funçãos er retirada.  Veja 'break'.
        * 'lisp_print' Mostre argumentos e valores de retorno com
          objectos Lisp.
        * 'info' Mostre '-> true' na entrada da funçào e saia.
        * 'errorcatch' Capture os erros, fornecendo a opção para
          sinalizar um erro, tentar novamente a chamada de função, ou
          especificar um valor de retorno.

     Opções para 'trace' são especificadas em duas formas.  A presença
     da palavra chave de opção sozinha coloca a opção para ter efeito
     incondicionalmente.  (Note que opção <foo> não coloca para ter
     efeito especificando '<foo>: true' ou uma forma similar; note
     também que palavras chave não precisam estar com apóstrofo.)
     Especificando a opção palavra chave com uma função predicado torna
     a opção condicional sobre o predicado.

     A lista de argumentos para a função predicado é sempre '[level,
     direction, function, item]' onde 'level' é o nível rerecursão para
     a função, 'direction' é ou 'enter' ou 'exit', 'function' é o nome
     da função, e 'item' é a lista de argumentos (sobre entrada) ou o
     valor de retorno (sobre a saída).

     Aqui está um exemplo de opções incondicionais de 'trace':

          (%i1) ff(n) := if equal(n, 0) then 1 else n * ff(n - 1)$

          (%i2) trace (ff)$

          (%i3) trace_options (ff, lisp_print, break)$

          (%i4) ff(3);

     Aqui está a mesma função, com a opção 'break' condicional sobre um
     predicado:

          (%i5) trace_options (ff, break(pp))$

          (%i6) pp (level, direction, function, item) := block (print (item),
              return (function = 'ff and level = 3 and direction = exit))$

          (%i7) ff(6);

 -- Função: untrace (<f_1>, ..., <f_n>)
 -- Função: untrace ()
     Dadas as funções <f_1>, ..., <f_n>, 'untrace' desabilita a a
     monitoração habilitada pela função 'trace'.  Sem argumentos,
     'untrace' desabilita a atuação da função 'trade' para todas as
     funções.

     'untrace' retorne uma lista das funções para as quais 'untrace'
     desabilita a atuação de 'trace'.


File: maxima.info,  Node: augmented_lagrangian,  Next: bode,  Prev: Depuração,  Up: Top

42 augmented_lagrangian
***********************

* Menu:

* Definições para augmented_lagrangian::


File: maxima.info,  Node: Definições para augmented_lagrangian,  Prev: augmented_lagrangian,  Up: augmented_lagrangian

42.1 Definições para augmented_lagrangian
=========================================

 -- Função: augmented_lagrangian_method (<FOM>, <xx>, <C>, <yy>)
 -- Função: augmented_lagrangian_method (<FOM>, <xx>, <C>, <yy>,
          args_opcionais)

     Retorna um mínimo aproximado da expressão <FOM> com relação às
     variáveis <xx>, mantendo restrito o valor de <C> a zero.  <yy> é
     uma lista de suposições iniciais para <xx>.  O método utilizado é o
     método do Lagrangiano aumentado (veja referências [1] e [2]).

     'args_opcionais' representam argumentos adicionais, especificados
     como '<símbolo> = <valor>'.  Os argumentos opcionais que podem ser
     colocados no lugar de <símbolo>:

     'niter'
          Número de iterações do algoritmo do Langrangiano aumentado
     'lbfgs_tolerance'
          Tolerância forneceida a LBFGS (Limited-memory, Broyden,
          Fletcher, Goldfarb, Shanno)
     'iprint'
          parâmetro IPRINT (uma lista de dois inteiros que controlam o
          nível de informação) fornecido a LBFGS
     '%lambda'
          valor inicial de '%lambda' a ser usado durante o cálculo do
          Lagrangiano aumentado

     Essa implementação minimiza o Lagrangiano aumentado pela pela
     aplicação do algoritmo de memória limitada BFGS (LBFGS), que é um
     algoritmo quasi-Newton.

     'load(augmented_lagrangian)' chama essa função.

     Veja também 'lbfgs'.

     References:

     [1]
     http://www-fp.mcs.anl.gov/otc/Guide/OptWeb/continuous/constrained/nonlinearcon/auglag.html

     [2] http://www.cs.ubc.ca/spider/ascher/542/chap10.pdf

     Exemplo:

          (%i1) load (lbfgs);
          (%o1) /home/robert/tmp/maxima-release-branch/maxima/share/lbfgs/\
          lbfgs.mac
          (%i2) load (augmented_lagrangian);
          (%o2) /home/robert/tmp/maxima-release-branch/maxima/share/contri\
          b/augmented_lagrangian.mac
          (%i3) FOM: x^2 + 2*y^2;
                                         2    2
          (%o3)                       2 y  + x
          (%i4) xx: [x, y];
          (%o4)                        [x, y]
          (%i5) C: [x + y - 1];
          (%o5)                      [y + x - 1]
          (%o6)                        [1, 1]
          (%i7) augmented_lagrangian_method (FOM, xx, C, yy, iprint = [-1, 0]);
          (%o7) [[x = 0.6478349888525, y = 0.32391749442625],
                                           %lambda = [- 1.267422460983745]]


File: maxima.info,  Node: bode,  Next: descriptive,  Prev: augmented_lagrangian,  Up: Top

43 bode
*******

* Menu:

* Definições para bode::


File: maxima.info,  Node: Definições para bode,  Prev: bode,  Up: bode

43.1 Definições para bode
=========================

 -- Função: bode_gain (<H>, <range>, ...<plot_opts>...)
     Função para desenhar gráficos de ganho para Bode.

     Exemplos (1 a 7 provenientes de
          http://www.swarthmore.edu/NatSci/echeeve1/Ref/Bode/BodeHow.html,
     8 proveniente de Ron Crummett):
          (%i1) load("bode")$

          (%i2) H1 (s) := 100 * (1 + s) / ((s + 10) * (s + 100))$

          (%i3) bode_gain (H1 (s), [w, 1/1000, 1000])$

          (%i4) H2 (s) := 1 / (1 + s/omega0)$

          (%i5) bode_gain (H2 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i6) H3 (s) := 1 / (1 + s/omega0)^2$

          (%i7) bode_gain (H3 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i8) H4 (s) := 1 + s/omega0$

          (%i9) bode_gain (H4 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i10) H5 (s) := 1/s$

          (%i11) bode_gain (H5 (s), [w, 1/1000, 1000])$

          (%i12) H6 (s) := 1/((s/omega0)^2 + 2 * zeta * (s/omega0) + 1)$

          (%i13) bode_gain (H6 (s), [w, 1/1000, 1000]),
                            omega0 = 10, zeta = 1/10$

          (%i14) H7 (s) := (s/omega0)^2 + 2 * zeta * (s/omega0) + 1$

          (%i15) bode_gain (H7 (s), [w, 1/1000, 1000]),
                            omega0 = 10, zeta = 1/10$

          (%i16) H8 (s) := 0.5 / (0.0001 * s^3 + 0.002 * s^2 + 0.01 * s)$

          (%i17) bode_gain (H8 (s), [w, 1/1000, 1000])$

     Para usar essa função escreva primeiramente 'load("bode")'.  Veja
     também 'bode_phase'

 -- Função: bode_phase (<H>, <range>, ...<plot_opts>...)
     Função para desenhar gráficos de fase para Bode

     Exemplos (1 a 7 provenientes de
          http://www.swarthmore.edu/NatSci/echeeve1/Ref/Bode/BodeHow.html,
     8 proveniente de Ron Crummett):
          (%i1) load("bode")$

          (%i2) H1 (s) := 100 * (1 + s) / ((s + 10) * (s + 100))$

          (%i3) bode_phase (H1 (s), [w, 1/1000, 1000])$

          (%i4) H2 (s) := 1 / (1 + s/omega0)$

          (%i5) bode_phase (H2 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i6) H3 (s) := 1 / (1 + s/omega0)^2$

          (%i7) bode_phase (H3 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i8) H4 (s) := 1 + s/omega0$

          (%i9) bode_phase (H4 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i10) H5 (s) := 1/s$

          (%i11) bode_phase (H5 (s), [w, 1/1000, 1000])$

          (%i12) H6 (s) := 1/((s/omega0)^2 + 2 * zeta * (s/omega0) + 1)$

          (%i13) bode_phase (H6 (s), [w, 1/1000, 1000]),
                             omega0 = 10, zeta = 1/10$

          (%i14) H7 (s) := (s/omega0)^2 + 2 * zeta * (s/omega0) + 1$

          (%i15) bode_phase (H7 (s), [w, 1/1000, 1000]),
                             omega0 = 10, zeta = 1/10$

          (%i16) H8 (s) := 0.5 / (0.0001 * s^3 + 0.002 * s^2 + 0.01 * s)$

          (%i17) bode_phase (H8 (s), [w, 1/1000, 1000])$

          (%i18) block ([bode_phase_unwrap : false],
                        bode_phase (H8 (s), [w, 1/1000, 1000]));

          (%i19) block ([bode_phase_unwrap : true],
                        bode_phase (H8 (s), [w, 1/1000, 1000]));

     Para usar essa função escreva primeiramente 'load("bode")'.  Veja
     também 'bode_gain'


File: maxima.info,  Node: descriptive,  Next: diag,  Prev: bode,  Up: Top

44 descriptive
**************

* Menu:

* Introdução ao pacote descriptive::
* Definições para manipulação da dados::
* Definições para estatística descritiva::
* Definições específicas para estatística descritiva de várias variáveis::
* Definições para gráficos estatísticos::


File: maxima.info,  Node: Introdução ao pacote descriptive,  Next: Definições para manipulação da dados,  Prev: descriptive,  Up: descriptive

44.1 Introdução ao pacote descriptive
=====================================

O pacote 'descriptive' contém um conjunto de funções para fazer cálculos
de estatística descritiva e desenhar gráficos.  Juntamente com o código
fonte três conjuntos de dados em suar árvore do Maxima: 'pidigits.data',
'wind.data' e 'biomed.data'.  Eles também podem ser baixados a partir de
'www.biomates.net'.

Qualque manual de estatística pode ser usado como referência para as
funções no pacote 'descriptive'.

Para comentários, erros ou sugestões, por favor entre em contato comigo
em <'mario AT edu DOT xunta DOT es'>.

Aqui está um exemplo sobre como as funções de estatística descritiva no
pacote 'descriptive' fazem esse trabalho, dependendo da natureza de seus
argumentos, listas e matrizes,

     (%i1) load (descriptive)$
     (%i2) /* univariate sample */   mean ([a, b, c]);
                                 c + b + a
     (%o2)                       ---------
                                     3
     (%i3) matrix ([a, b], [c, d], [e, f]);
                                 [ a  b ]
                                 [      ]
     (%o3)                       [ c  d ]
                                 [      ]
                                 [ e  f ]
     (%i4) /* amostra de várias variáveis */ mean (%);
                           e + c + a  f + d + b
     (%o4)                [---------, ---------]
                               3          3

Note que em amostras de várias variáveis a média é calculada em cada
coluna.

No caso de muitas amostras amostras com possíveis tamanhos diferentes, A
função do Maxima 'map' pode ser usada para pegar os resultados desejados
de cada amostra,

     (%i1) load (descriptive)$
     (%i2) map (mean, [[a, b, c], [d, e]]);
                             c + b + a  e + d
     (%o2)                  [---------, -----]
                                 3        2

Nesse caso, duas amostras de tamanhos 3 e 2 foram armazenadas em uma
lista.

Amostras de uma única variável devem ser armazenadas em listas como

     (%i1) s1 : [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];
     (%o1)           [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]

e amostras de várias variáveis em matrizes como em

     (%i1) s2 : matrix ([13.17, 9.29], [14.71, 16.88], [18.50, 16.88],
                  [10.58, 6.63], [13.33, 13.25], [13.21,  8.12]);
                             [ 13.17  9.29  ]
                             [              ]
                             [ 14.71  16.88 ]
                             [              ]
                             [ 18.5   16.88 ]
     (%o1)                   [              ]
                             [ 10.58  6.63  ]
                             [              ]
                             [ 13.33  13.25 ]
                             [              ]
                             [ 13.21  8.12  ]

Nesse caso, o número de colunas é igual à dimensão (ao número) de
variáveis e o n;umero de linhas é o tamano da amostra.

Dados podem ser introduzidos manualmente, mas grandes amostras são
usualmente armazenadas em ficheiros no formato texto plano.  Por
exemplo, o ficheiro 'pidigits.data' contém os primeiros 100 dígitos do
número '%pi':
           3
           1
           4
           1
           5
           9
           2
           6
           5
           3 ...

Com o objectivo de chamar esses dígitos no Maxima,

     (%i1) load (numericalio)$
     (%i2) s1 : read_list (file_search ("pidigits.data"))$
     (%i3) length (s1);
     (%o3)                          100

Por outro lado, o ficheiro 'wind.data' contém a média diária de
velocidades do ventoem 5 estações meteorológicas na República da Irlanda
(Esses dados são parte de um conjunto de dados tomados em 12 estações
meteorológicas.  O ficheiro original está disponivel livremente para
download no Repositório de Dados StatLib e sua análise é discutida em
Haslett, J., Raftery, A. E. (1989) <Space-time Modelling with
Long-memory Dependence: Assessing Ireland's Wind Power Resource, with
Discussion>.  Applied Statistics 38, 1-50).  As linhas seguintes mostram
como tornar os dados disponíveis para o Maxima:

     (%i1) load (numericalio)$
     (%i2) s2 : read_matrix (file_search ("wind.data"))$
     (%i3) length (s2);
     (%o3)                          100
     (%i4) s2 [%]; /* last record */
     (%o4)            [3.58, 6.0, 4.58, 7.62, 11.25]

Algumas amostras possuem dados não numéricos.  Como um exemplo, o
ficheiro 'biomed.data' (que é parte de outro grande ficheiro tomado do
Repósitório de Dados StatLib) contém quatro medidas sanguíneas tomadas
de dois grupos de pacientes, 'A' e 'B', de diferentes idades,

     (%i1) load (numericalio)$
     (%i2) s3 : read_matrix (file_search ("biomed.data"))$
     (%i3) length (s3);
     (%o3)                          100
     (%i4) s3 [1]; /* first record */
     (%o4)            [A, 30, 167.0, 89.0, 25.6, 364]

O primeiro indivíduo pertence ao grupo 'A', com 30 anos de idade e suas
medidas sanguíneas foram 167.0, 89.0, 25.6 e 364.

Se deve tomar cuidado quando se trabalha com dados divididos por
categorias.  no exemplo seguinte, ao símbolo 'a' é atribuído um valor em
algum momento anterior e então a amostra com valores divididos por
categoria 'a' é interpretada como,

     (%i1) a : 1$
     (%i2) matrix ([a, 3], [b, 5]);
                                 [ 1  3 ]
     (%o2)                       [      ]
                                 [ b  5 ]


File: maxima.info,  Node: Definições para manipulação da dados,  Next: Definições para estatística descritiva,  Prev: Introdução ao pacote descriptive,  Up: descriptive

44.2 Definições para manipulação da dados
=========================================

 -- Função: continuous_freq (<list>)
 -- Função: continuous_freq (<list>, <m>)
     O argumento de 'continuous_freq' deve ser uma lista de números, que
     serão então agrupadas em intervalos e contado quantos desses dados
     pertencem a cada grupo.  Opcionalmente, a função 'continuous_freq'
     admite um segundo argumento indicando o número de classes, 10 é o
     valor padrão,

          (%i1) load (numericalio)$
          (%i2) load (descriptive)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) continuous_freq (s1, 5);
          (%o4) [[0, 1.8, 3.6, 5.4, 7.2, 9.0], [16, 24, 18, 17, 25]]

     A primeira lista contém os limites de intervalos e o segundo a
     correspondente contagem: existem 16 algarismos da parte decimal de
     '%pi' dentro do intervalo '[0, 1.8]', isto é 0's e 1's, 24
     algarismos em '(1.8, 3.6]', isto é 2's e 3's, e assim por diante.

 -- Função: discrete_freq (<list>)
     Conta as frequências absolutas em amostras discretas, em amostras
     numéricas e em amostras divididas em categorias.  Seu único
     argumento é uma lista,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"));
          (%o3) [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3, 2, 3, 8,
          4, 6, 2, 6, 4, 3, 3, 8, 3, 2, 7, 9, 5, 0, 2, 8, 8, 4, 1, 9, 7,
          1, 6, 9, 3, 9, 9, 3, 7, 5, 1, 0, 5, 8, 2, 0, 9, 7, 4, 9, 4, 4,
          5, 9, 2, 3, 0, 7, 8, 1, 6, 4, 0, 6, 2, 8, 6, 2, 0, 8, 9, 9, 8,
          6, 2, 8, 0, 3, 4, 8, 2, 5, 3, 4, 2, 1, 1, 7, 0, 6, 7]
          (%i4) discrete_freq (s1);
          (%o4) [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
                                       [8, 8, 12, 12, 10, 8, 9, 8, 12, 13]]

     A primeira lista fornece os valores da amostra e a segunda as suas
     frequências absolutas.  Os comandos '? col' e '? transpose' podem
     ajudá-lo a entender o último comando de entrada.

 -- Função: subsample (<matriz_de_dados>, <expressão_lógica>)
 -- Função: subsample (<matriz_de_dados>, <expressão_lógica>, <col_num>,
          <col_num>, ...)
     Essas funções são um tipo de variação da função 'submatrix' do
     Maxima.  O primeiro argumento é o nome da matriz de dados, o
     segundo argumento é uma expressão lógica que recebeu apóstrofo e os
     argumentos opcionais adicionais são o número de colunas a serem
     tomadas.  Esse comportamento é melhor entendido com exemplos,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) subsample (s2, '(%c[1] > 18));
                        [ 19.38  15.37  15.12  23.09  25.25 ]
                        [                                   ]
                        [ 18.29  18.66  19.08  26.08  27.63 ]
          (%o4)         [                                   ]
                        [ 20.25  21.46  19.95  27.71  23.38 ]
                        [                                   ]
                        [ 18.79  18.96  14.46  26.38  21.84 ]

     Existem registros de várias variáveis nos quais a velocidade do
     vento na primeira estação meteorológica foram maiores que 18.  Veja
     que na expressão lógica que recebeu apóstrofo o <i>-ésimo
     componente é referenciado como '%c[i]'.  O símbolo '%c[i]' é usado
     dentro da função 'subsample', portanto quando usado como uma
     variável de uma categoria, Maxima fica confuso.  No seguinte
     exemplo, requisitamos somente o primeiro, o segundo e o quinto
     componentes desses registro com velocidades de vento maiores que ou
     igual a 16 nós na estação meteorológica número 1 e menor que 25 nós
     na estação meteorológica número 4,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) subsample (s2, '(%c[1] >= 16 and %c[4] < 25), 1, 2, 5);
                               [ 19.38  15.37  25.25 ]
                               [                     ]
                               [ 17.33  14.67  19.58 ]
          (%o4)                [                     ]
                               [ 16.92  13.21  21.21 ]
                               [                     ]
                               [ 17.25  18.46  23.87 ]

     Aqui está um exemplo com as variáveis divididas em categorias do
     ficheiro 'biomed.data'.  Queremos os registros correspondentes a
     aqueles pacientes no grupo 'B' que possuem idade maior que 38 anos,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) subsample (s3, '(%c[1] = B and %c[2] > 38));
                          [ B  39  28.0  102.3  17.1  146 ]
                          [                               ]
                          [ B  39  21.0  92.4   10.3  197 ]
                          [                               ]
                          [ B  39  23.0  111.5  10.0  133 ]
                          [                               ]
                          [ B  39  26.0  92.6   12.3  196 ]
          (%o4)           [                               ]
                          [ B  39  25.0  98.7   10.0  174 ]
                          [                               ]
                          [ B  39  21.0  93.2   5.9   181 ]
                          [                               ]
                          [ B  39  18.0  95.0   11.3  66  ]
                          [                               ]
                          [ B  39  39.0  88.5   7.6   168 ]

     Probavelmente, a análise estatística irá envolver somente as
     medidas sanguíneas,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) subsample (s3, '(%c[1] = B and %c[2] > 38), 3, 4, 5, 6);
                             [ 28.0  102.3  17.1  146 ]
                             [                        ]
                             [ 21.0  92.4   10.3  197 ]
                             [                        ]
                             [ 23.0  111.5  10.0  133 ]
                             [                        ]
                             [ 26.0  92.6   12.3  196 ]
          (%o4)              [                        ]
                             [ 25.0  98.7   10.0  174 ]
                             [                        ]
                             [ 21.0  93.2   5.9   181 ]
                             [                        ]
                             [ 18.0  95.0   11.3  66  ]
                             [                        ]
                             [ 39.0  88.5   7.6   168 ]

     Essa é a média de várias variáveis de 's3',

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) mean (s3);
                 65 B + 35 A  317          6 NA + 8145.0
          (%o4) [-----------, ---, 87.178, -------------, 18.123,
                     100      10                100
                                                              3 NA + 19587
                                                              ------------]
                                                                  100
     Aqui, a primeira componente é sem sentido, uma vez que 'A' e 'B'
     são categorias, o segundo componente é a idade média dos indivíduos
     na forma racional, e o quarto eo último valores exibem um
     comportamento estranho.  Isso ocorre porque o símbolo 'NA' é usado
     aqui para indicar dado não disponível (<non available> em inglês),
     e as duas médias são certamente sem sentido.  Uma solução possível
     pode ser jogar fora a matriz cujas linhas possuam símbolos 'NA',
     embora isso cause alguma perda de informação,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) mean (subsample (s3, '(%c[4] # NA and %c[6] # NA), 3, 4, 5, 6));
          (%o4) [79.4923076923077, 86.2032967032967, 16.93186813186813,
                                                                      2514
                                                                      ----]
                                                                       13


File: maxima.info,  Node: Definições para estatística descritiva,  Next: Definições específicas para estatística descritiva de várias variáveis,  Prev: Definições para manipulação da dados,  Up: descriptive

44.3 Definições para estatística descritiva
===========================================

 -- Função: mean (<lista>)
 -- Função: mean (<matriz>)
     Essa função calcula a média de uma amostra, definida como
                                 n
                               ====
                       _   1   \
                       x = -    >    x
                           n   /      i
                               ====
                               i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) mean (s1);
                                         471
          (%o4)                          ---
                                         100
          (%i5) %, numer;
          (%o5)                         4.71
          (%i6) s2 : read_matrix (file_search ("wind.data"))$
          (%i7) mean (s2);
          (%o7)     [9.9485, 10.1607, 10.8685, 15.7166, 14.8441]

 -- Função: var (<list>)
 -- Função: var (<matrix>)
     This is the sample variance, defined as
                               n
                             ====
                     2   1   \          _ 2
                    s  = -    >    (x - x)
                         n   /       i
                             ====
                             i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) var (s1), numer;
          (%o4)                   8.425899999999999

     See also function 'var1'.

 -- Função: var1 (<lista>)
 -- Função: var1 (<matriz>)
     Essa função calcula a variância da amostra, definida como
                               n
                             ====
                         1   \          _ 2
                        ---   >    (x - x)
                        n-1  /       i
                             ====
                             i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) var1 (s1), numer;
          (%o4)                    8.5110101010101
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) var1 (s2);
          (%o6) [17.39586540404041, 15.13912778787879, 15.63204924242424,
                                      32.50152569696971, 24.66977392929294]

     See also function 'var'.

 -- Função: std (<lista>)
 -- Função: std (<matriz>)
     A raíz quadrada da função 'var', a variância com denominador n.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) std (s1), numer;
          (%o4)                   2.902740084816414
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) std (s2);
          (%o6) [4.149928523480858, 3.871399812729241, 3.933920277534866,
                                      5.672434260526957, 4.941970881136392]

     Veja também as funções 'var' e 'std1'.

 -- Função: std1 (<lista>)
 -- Função: std1 (<matriz>)
     É a raíz quadrada da função 'var1', a variância com denominador
     n-1.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) std1 (s1), numer;
          (%o4)                   2.917363553109228
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) std1 (s2);
          (%o6) [4.17083509672109, 3.89090320978032, 3.953738641137555,
                                      5.701010936401517, 4.966867617451963]

     Veja também as funções 'var1' e 'std'.

 -- Função: noncentral_moment (<lista>, <k>)
 -- Função: noncentral_moment (<matriz>, <k>)
     O momento não central de ordem k, definido como
                                 n
                               ====
                           1   \      k
                           -    >    x
                           n   /      i
                               ====
                               i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) noncentral_moment (s1, 1), numer; /* the mean */
          (%o4)                         4.71
          (%i6) s2 : read_matrix (file_search ("wind.data"))$
          (%i7) noncentral_moment (s2, 5);
          (%o7) [319793.8724761506, 320532.1923892463, 391249.5621381556,
                                      2502278.205988911, 1691881.797742255]

     Veja também a função 'central_moment'.

 -- Função: central_moment (<lista>, <k>)
 -- Função: central_moment (<matriz>, <k>)
     O momento central de ordem k, definido como
                              n
                            ====
                        1   \          _ k
                        -    >    (x - x)
                        n   /       i
                            ====
                            i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) central_moment (s1, 2), numer; /* a variância */
          (%o4)                   8.425899999999999
          (%i6) s2 : read_matrix (file_search ("wind.data"))$
          (%i7) central_moment (s2, 3);
          (%o7) [11.29584771375004, 16.97988248298583, 5.626661952750102,
                                       37.5986572057918, 25.85981904394192]

     Veja também as funções 'central_moment' e 'mean'.

 -- Função: cv (<lista>)
 -- Função: cv (<matriz>)
     O coeficiente de variação é o quociente entre o desvio padrão da
     amostra ('std') e a média 'mean',

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) cv (s1), numer;
          (%o4)                   .6193977819764815
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) cv (s2);
          (%o6) [.4192426091090204, .3829365309260502, 0.363779605385983,
                                      .3627381836021478, .3346021393989506]

     Veja também as funções 'std' e 'mean'.

 -- Função: mini (<lista>)
 -- Função: mini (<matriz>)
     É o valor mínimo da amostra <lista>,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) mini (s1);
          (%o4)                           0
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) mini (s2);
          (%o6)             [0.58, 0.5, 2.67, 5.25, 5.17]

     Veja também função 'maxi'.

 -- Função: maxi (<lista>)
 -- Função: maxi (<matriz>)
     É o valor máximo da amostra <lista>,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) maxi (s1);
          (%o4)                           9
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) maxi (s2);
          (%o6)          [20.25, 21.46, 20.04, 29.63, 27.63]

     Veja também a função 'mini'.

 -- Função: range (<lista>)
 -- Função: range (<matriz>)
     A amplitude é a diferença entre os valores de maximo e de mínimo.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) range (s1);
          (%o4)                           9
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) range (s2);
          (%o6)          [19.67, 20.96, 17.37, 24.38, 22.46]

 -- Função: quantile (<lista>, <p>)
 -- Função: quantile (<matriz>, <p>)
     É o <p>-'quantile' (quantil de ordem <p>), com <p> sendo um número
     em [0, 1] (intervalo fechado), da amostra <lista>.  Embora exista
     muitas Definições para quantil de uma amostra (Hyndman, R. J., Fan,
     Y. (1996) <Sample quantiles in statistical packages>.  American
     Statistician, 50, 361-365), aquela que se baseia em interpolação
     linear é a que foi implementada no pacote 'descriptive'.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) /* 1st and 3rd quartiles */ [quantile (s1, 1/4), quantile (s1, 3/4)], numer;
          (%o4)                      [2.0, 7.25]
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) quantile (s2, 1/4);
          (%o6)    [7.2575, 7.477500000000001, 7.82, 11.28, 11.48]

 -- Função: median (<lista>)
 -- Função: median (<matriz>)
     Uma vez que a amostra está ordenada, se o tamanho da amostra for
     ímpar a mediana é o valor central, de outra forma a mediana será a
     média dos dois valores centrais.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) median (s1);
                                          9
          (%o4)                           -
                                          2
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) median (s2);
          (%o6)         [10.06, 9.855, 10.73, 15.48, 14.105]

     A mediana é o 1/2-'quantil'.

     Veja também function 'quantile'.

 -- Função: qrange (<lista>)
 -- Função: qrange (<matriz>)
     A amplitude do interquartil é a diferença entre o terceiro e o
     primeiro quartil, 'quantile(<lista>,3/4) - quantile(<lista>,1/4)',

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) qrange (s1);
                                         21
          (%o4)                          --
                                         4
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) qrange (s2);
          (%o6) [5.385, 5.572499999999998, 6.0225, 8.729999999999999,
                                                         6.650000000000002]

     Veja também a função 'quantile'.

 -- Função: mean_deviation (<lista>)
 -- Função: mean_deviation (<matriz>)
     O desvio médio, definido como
                               n
                             ====
                         1   \          _
                         -    >    |x - x|
                         n   /       i
                             ====
                             i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) mean_deviation (s1);
                                         51
          (%o4)                          --
                                         20
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) mean_deviation (s2);
          (%o6) [3.287959999999999, 3.075342, 3.23907, 4.715664000000001,
                                                         4.028546000000002]

     Veja também a função 'mean'.

 -- Função: median_deviation (<lista>)
 -- Função: median_deviation (<matriz>)
     O desvio da mediana, definido como
                           n
                         ====
                     1   \
                     -    >    |x - med|
                     n   /       i
                         ====
                         i = 1
     onde 'med' é a mediana da <lista>.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) median_deviation (s1);
                                          5
          (%o4)                           -
                                          2
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) median_deviation (s2);
          (%o6)           [2.75, 2.755, 3.08, 4.315, 3.31]

     Veja também a função 'mean'.

 -- Função: harmonic_mean (<lista>)
 -- Função: harmonic_mean (<matriz>)
     A média harmônica, definida como
                            n
                         --------
                          n
                         ====
                         \     1
                          >    --
                         /     x
                         ====   i
                         i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i4) harmonic_mean (y), numer;
          (%o4)                   3.901858027632205
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) harmonic_mean (s2);
          (%o6) [6.948015590052786, 7.391967752360356, 9.055658197151745,
                                      13.44199028193692, 13.01439145898509]

     Veja também as funções 'mean' e 'geometric_mean'.

 -- Função: geometric_mean (<lista>)
 -- Função: geometric_mean (<matriz>)
     A média geométrica, definida como
                           /  n      \ 1/n
                           | /===\   |
                           |  ! !    |
                           |  ! !  x |
                           |  ! !   i|
                           | i = 1   |
                           \         /

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i4) geometric_mean (y), numer;
          (%o4)                   4.454845412337012
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) geometric_mean (s2);
          (%o6) [8.82476274347979, 9.22652604739361, 10.0442675714889,
                                      14.61274126349021, 13.96184163444275]

     Veja também as funções 'mean' e 'harmonic_mean'.

 -- Função: kurtosis (<lista>)
 -- Função: kurtosis (<matriz>)
     O coeficiente de curtose, definido como
                              n
                            ====
                      1     \          _ 4
                     ----    >    (x - x)  - 3
                        4   /       i
                     n s    ====
                            i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) kurtosis (s1), numer;
          (%o4)                  - 1.273247946514421
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) kurtosis (s2);
          (%o6) [- .2715445622195385, 0.119998784429451,
             - .4275233490482866, - .6405361979019522, - .4952382132352935]

     Veja também as funções 'mean', 'var' e 'skewness'.

 -- Função: skewness (<lista>)
 -- Função: skewness (<matriz>)
     O coeficiente de assimetria, definido como
                              n
                            ====
                      1     \          _ 3
                     ----    >    (x - x)
                        3   /       i
                     n s    ====
                            i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) skewness (s1), numer;
          (%o4)                  .009196180476450306
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) skewness (s2);
          (%o6) [.1580509020000979, .2926379232061854, .09242174416107717,
                                      .2059984348148687, .2142520248890832]

     Veja também as funções 'mean', 'var' e 'kurtosis'.

 -- Função: pearson_skewness (<lista>)
 -- Função: pearson_skewness (<matriz>)
     O coeficiente de assimetria de pearson, definido como
                          _
                       3 (x - med)
                       -----------
                            s
     onde <med> é a mediana de <lista>.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) pearson_skewness (s1), numer;
          (%o4)                   .2159484029093895
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) pearson_skewness (s2);
          (%o6) [- .08019976629211892, .2357036272952649,
                   .1050904062491204, .1245042340592368, .4464181795804519]

     Veja também as funções 'mean', 'var' e 'median'.

 -- Função: quartile_skewness (<lista>)
 -- Função: quartile_skewness (<matriz>)
     O coeficiented de assimetria do quartil, definido como
                         c    - 2 c    + c
                          3/4      1/2    1/4
                         --------------------
                             c    - c
                              3/4    1/4
     onde c_p é o quartil de ordem <p> da amostra <lista>.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) quartile_skewness (s1), numer;
          (%o4)                  .04761904761904762
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) quartile_skewness (s2);
          (%o6) [- 0.0408542246982353, .1467025572005382,
                 0.0336239103362392, .03780068728522298, 0.210526315789474]

     Veja também a função 'quantile'.

