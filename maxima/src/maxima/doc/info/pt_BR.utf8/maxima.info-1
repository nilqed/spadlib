This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.

Esse é um Manual do Maxima no formato Texinfo

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Um sistema de álgebra computacional.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Top,  Next: Introdução ao Maxima,  Prev: (dir),  Up: (dir)

Manual do Maxima
****************

Maxima é um sistema de álgebra computacional, implementado em Lisp.

   Maxima é derivado do sistema Macsyma, desenvolvido no MIT nos anos de
1968 a 1982 como parte do Projeto MAC. MIT remanejou uma cópia do código
fonte do Macsyma para o Departamento de Energia em 1982; aquela versão é
agora conhecida como Macsyma DOE. Uma cópia do Macsyma DOE foi mantida
pelo Professor William F. Schelter da Universidade do Texas de 1982 até
sua morte em 2001.  Em 1998, Schelter obteve permissão do Departamento
de Energia para liberar o código fonte do Macsyma DOE sob a Licença
Pública GNU, e em 2000 ele iniciou o projeto Maxima no SourceForge para
manter e desenvolver o Macsyma DOE, agora chamado Maxima.

   Notas de tradução:

   Com o término da tradução inicia-se o processo de revisão da mesma.
Está aberta a temporada de caça aos erros de tradução, erros de
hifenização e de adequação entre a linguagem matemática inglesa e a
linguagem matemática brasileira.  Caso você me envie alguma correção ou
melhoria a comunidade matemática que utiliza o Sofware Livre lhe ficará
muito grata ( e nós, da equipe do Maxima, também).

   O código fonte deste documento encontra-se no formato texinfo.  Para
contribuir com a equipe do Maxima na tarefa de manter a tradução para o
português sempre atualizada envie um e-mail para <maxima at math dot
utexas dot edu>.

   Em caso de dúvida sobre algum trecho deste manual consulte o original
inglês.  Caso sua dúvida persista ou tenha alguma
sugestão/aperfeiçoamento/ crítica mande-nos um e-mail no endereço acima.

   Versão do manual no formato pdf: maxima.pdf

   Versão do manual no formato info: maxima-info.tar.gz

   Veja o arquivo AUTHORS para conhecer todos os mantenedores do Maxima.

* Menu:

Infraestrutura do Maxima

* Introdução ao Maxima::        Exemplo de sessões do Maxima.
* Detecção e Relato de Erros::  Encontrando e relatando erros no Maxima.
* Ajuda::                       Solicitando ajuda de dentro de uma
                                sessão do Maxima.
* Linha de Comando::            Sintaxe de linha de comando do Maxima.
* Operadores::                  Operadores usados em expressões do Maxima.
* Expressões::                  Expressões no Maxima.
* Simplificação::               Simplificando expressões.
* Montando Gráficos::           Saídas gráficas em 2D e 3D.
* Entrada e Saída::             Entrada e saída de arquivos.
* Ponto Flutuante::             Rotinas numéricas de baixo nível.
* Contextos::                   Conjunto de fatos assumidos.

Suporte a áreas específicas da matemática

* Polinômios::                  Formas padrão para polinômios, e
                                funções operando sobre polinômios.
* Constantes::                  Constantes numéricas.
* Logarítmos::                  Manipulação de expressões envolvendo
                                logarítmos.
* Trigonometria::               Manipulando expressões com trigonometria e
                                Funções trigonométricas inversas.
* Funções Especiais::           Funções especiais
* Funções Elípticas::           Funções Elípticas e Integrais
* Limites::                     Limites de expressões.
* Diferenciação::               Cálculo diferencial.
* Integração::                  Cálculo integral.
* Equações::                    Definindo e resolvendo equações.
* Equações Diferenciais::       Definindo e resolvendo equações diferenciais.
* Numérico::                    Integração numérica, transformações
                                de Fourier, etc.
* Arrays ::                     Criando e trabalhando com arrays.
* Matrizes e Álgebra Linear::   Operações com Matrizes.
* Funções Afins::                        
* itensor::                     Manipulação de índice de Tensores.
* ctensor::                     Manipulação de componentes de Tensores.
* Pacote atensor::              Manipulação de Tensores Algébricos.
* Séries::                      Taylor e séries de potência.
* Teoria dos Números::          Teoria dos números.
* Simetrias::                   Polinômios simétricos
* Grupos::                      Álgebra Abstrata.

Facilidades avançadas e programação

* Ambiente em Tempo de Execução:: Customização do ambiente Maxima.
* Opções Diversas::             Opções com efeito global sobre o Maxima.
* Regras e Modelos::            Coincidência de expressões definidas pelo utilizador e regras de simplificação.
* Listas::                      Manipulação de listas.
* Conjuntos::                   Manipulação de conjuntos.
* Definição de Função::         Definindo funções.
* Fluxo de Programa::           Definindo programas do Maxima.
* Depurando::                   Depurando programas do Maxima.

Pacotes Adicionais

* augmented_lagrangian::        Pacote augmented_lagrangian.
* bode::                        Gráficos de ganho e fase de Bode.
* contrib_ode::                 Rotinas adicionais para EDOs
* descriptive::                 Estatística descritiva.
* diag::                        Matrizes de Jordan.
* distrib::                     Distribuições de probabilidade.
* draw::                        Uma interface Maxima-Gnuplot.
* dynamics::                    Gráficos para sistemas dinâmicos e fractais.
* eval_string::                 Expressões do Maxima como cadeias de texto.
* f90::                         Tradutor do Maxima para o fortran.
* ggf::                         Função geradora para sequências.
* grobner::                     Funções para trabalhar com as bases de Groebner.
* impdiff::                     Derivadas implícitas.
* implicit_plot::               Gráficos implítos.
* interpol::                    Pacote de interpolação.
* lbfgs::                       L-BFGS pacote de minimização não limitada.
* lindstedt::                   Pacote Lindstedt.
* linearalgebra::               Funções de álgebra linear.
* lsquares::                    Método dos mínimos quadrados.
* makeOrders::                  Expoentes de polinômios.
* mnewton::                     Método de Newton.
* numericalio::                 Leitura e escritura de arquivos.
* opsubst::                     Comandos para subsituições.
* orthopoly::                   Polinómios ortogonais.
* plotdf::                      Gráficos de campos de direcções.
* romberg::                     Método de Romberg para integração numerica.
* simplex::                     Programação linear.
* simplification::              Funções e regras de simplificação.
* solve_rec::                   Relações de recorrências lineares.
* stats::                       Pacote de inferências estatísticas.
* stirling::                    Fórmula de Stirling.
* stringproc::                  Manipulação de seqüências de caracteres.
* unit::                        Pacote de unidades e dimensões.
* zeilberger::                  Funções para somatórios hipergeométricos.


Índice

* Índice de Funções e Variáveis:: Índice::

 -- Listagem de Nodos Detalhada --

Introdução

* Introdução ao Maxima::

Ajuda

* Lisp e Maxima::            
* Descartando::          
* Documentação::               
* Funções e Variáveis Definidas para Ajuda::        

Linha de Comando

* Introdução a Linha de Comando::  
* Funções e Variáveis Definidas para Linha de Comando::  

Operadores

* N-Argumentos::                        
* Operador não fixado::                       
* Operador Pósfixado::                     
* Operador Préfixado::                      
* Operadores Aritméticos::    
* Operadores Relacionais::   
* Operadores Geral::

Expressões

* Introdução a Expressões::  
* Complexo::                    
* Desigualdade::      
* Sintaxe::                     
* Funções e Variáveis Definidas para Expressões::  

Simplificação

* Funções e Variáveis Definidas para Simplificação::  

Montando Gráficos

* Funções e Variáveis Definidas para Montagem de Gráficos::    

Entrada e Saída

* Comentários::
* Arquivos::                       
* Funções e Variáveis Definidas para Entrada e Saída::  

Ponto Flutuante

* Funções e Variáveis Definidas para ponto Flutuante::  

Contextos

* Funções e Variáveis Definidas para Contextos::    

Polinômios

* Introdução a Polinômios::  
* Funções e Variáveis Definidas para Polinômios::  

Constantes

* Funções e Variáveis Definidas para Constantes::

Logarítmos

* Funções e Variáveis Definidas para Logarítmos::  

Trigonometria

* Introdução ao Pacote Trigonométrico::  
* Funções e Variáveis Definidas para Trigonometria::  

Funções Especiais

* Introdução a Funções Especiais::  
* Funções e Variáveis Definidas para Funções Especiais::  

Funções Elípticas

* Introdução a Funções Elípticas e Integrais::
* Funções e Variáveis Definidas para Funções Elípticas::
* Funções e Variáveis Definidas para Integrais Elípticas::

Limites

* Funções e Variáveis Definidas para Limites::      

Diferenciação

* Funções e Variáveis Definidas para Diferenciação::  

Integração

* Introdução a Integração::  
* Funções e Variáveis Definidas para Integração::  

Equações

* Funções e Variáveis Definidas para Equações::   

Equações Diferenciais

* Introdução a Equações Diferenciais::
* Funções e Variáveis Definidas para Equações Diferenciais::  

Numérico

* Introdução a Numérico::   
* Pacotes de Fourier::                     
* Funções e Variáveis Definidas para Numérico::   
* Funções e Variáveis Definidas para Séries de Fourier::

Arrays

* Funções e Variáveis Definidas para Arrays::  

Matrizes e Álgebra Linear

* Introdução a Matrizes e Álgebra Linear::  
* Ponto::                         
* Vetores::                     
* auto::
* Funções e Variáveis Definidas para Matrizes e Álgebra Linear::  

Funções Afins

* Funções e Variáveis Definidas para Funções Afins::      

itensor

* Introdução a itensor::      
* Funções e Variáveis Definidas para itensor::      

ctensor

* Introdução a ctensor::     
* Funções e Variáveis Definidas para ctensor::     

Pacote atensor

* Introdução ao Pacote atensor::
* Funções e Variáveis Definidas para o Pacote atensor::

Séries

* Introdução a Séries::      
* Funções e Variáveis Definidas para Séries::      

Teoria dos Números

* Funções e Variáveis Definidas para Teoria dos Números::  

Simetrias

* Funções e Variáveis Definidas para Simetrias::  

Grupos

* Funções e Variáveis Definidas para Grupos::      

Ambiente em Tempo de Execução

* Introdução a Ambiente em Tempo de Execução::  
* Interrupções::                  
* Funções e Variáveis Definidas para Ambiente em Tempo de Execução::  

Opções Diversas

* Introdução a Opções Diversas::  
* Compartilhado::                       
* Funções e Variáveis Definidas para Opções Diversas::  

Regras e Modelos

* Introdução a Regras e Modelos::  
* Funções e Variáveis Definidas para Regras e Modelos::  

Listas

* Introdução a Listas::
* Funções e Variáveis Definidas para Listas::

Conjuntos

* Introdução a Conjuntos::       
* Funções e Variáveis Definidas para Conjuntos::       

Definição de Função

* Introdução a Definição de Função::  
* Função::                    
* Macros::                      
* Funções e Variáveis para Definição de Função::  

Fluxo de Programa

* Introdução a Fluxo de Programa::  
* Funções e Variáveis Definidas para Fluxo de Programa::  

Depurando

* Funções e Variáveis Definidas para Depuração::   

augmented_lagrangian

* Funções e Variáveis Definidas para augmented_lagrangian::

bode

* Funções e Variáveis Definidas para bode::

contrib_ode

* Introdução a contrib_ode::
* Funções e Variáveis Definidas para contrib_ode::
* Possibilidades de melhorias em contrib_ode::
* Casos de teste para contrib_ode::
* Referências bibliográficas para contrib_ode::

descriptive

* Introdução ao pacote descriptive::
* Funções e Variáveis Definidas para manipulação da dados::
* Funções e Variáveis Definidas para estatística descritiva::
* Funções e Variáveis Definidas específicas para estatística descritiva de várias variáveis::
* Funções e Variáveis Definidas para gráficos estatísticos::

diag

* Funções e Variáveis Definidas para diag::

distrib

* Introdução a distrib::
* Funções e Variáveis Definidas para distribuições contínuas::
* Funções e Variáveis Definidas para distribuições discretas::

draw

* Introdução a draw::
* Funções e Variáveis Definidas para draw::

dynamics

* Introdução a dynamics::
* Funções e Variáveis Definidas para dynamics::

eval_string

* Funções e Variáveis Definidas para eval_string::

f90

* Funções e Variáveis Definidas para f90::

ggf

* Funções e Variáveis Definidas para ggf::

grobner

* Introdução a grobner::
* Funções e Variáveis Definidas para grobner::

impdiff

* Funções e Variáveis Definidas para impdiff::

implicit_plot

* Funções e Variáveis Definidas para implicit_plot::

interpol

* Introdução a interpol::
* Funções e Variáveis Definidas para interpol::

lbfgs

* Introdução a lbfgs::
* Funções e Variáveis Definidas para lbfgs::

lindstedt

* Funções e Variáveis Definidas para lindstedt::

linearalgebra

* Introdução a linearalgebra::
* Funções e Variáveis Definidas para linearalgebra::

lsquares

* Funções e Variáveis Definidas para lsquares::

makeOrders

* Funções e Variáveis Definidas para makeOrders::

mnewton

* Funções e Variáveis Definidas para mnewton::

numericalio

* Introdução a numericalio::
* Funções e Variáveis Definidas para numericalio::

opsubst

* Funções e Variáveis Definidas para opsubst::

orthopoly

* Introdução a polinômios ortogonais::
* Funções e Variáveis Definidas para polinômios ortogonais::

plotdf

* Introdução a plotdf::
* Funções e Variáveis Definidas para plotdf::

romberg

* Funções e Variáveis Definidas para romberg::

simplex

* Introdução a simplex::
* Funções e Variáveis Definidas para simplex::

simplification

* Introdução a simplification::
* Funções e Variáveis Definidas para simplification::

solve_rec

* Introdução a solve_rec::
* Funções e Variáveis Definidas para solve_rec::

stats

* Introdução a stats::
* Funções e Variáveis Definidas para inference_result::
* Funções e Variáveis Definidas para stats::
* Funções e Variáveis Definidas para distribuições especiais::

stirling

* Funções e Variáveis Definidas para stirling::

stringproc

* Introdução a manipulação de seqüências de caracteres::
* Funções e Variáveis para entrada e saída::
* Funções e Variáveis para caracteres::
* Funções e Variáveis para seqüências de caracteres::

unit

* Introdução a Units::       
* Funções e Variáveis Definidas para Units::

zeilberger

* Introdução a zeilberger::
* Funções e Variáveis Definidas para zeilberger::


File: maxima.info,  Node: Introdução ao Maxima,  Next: Detecção e Relato de Erros,  Prev: Top,  Up: Top

1 Introdução ao Maxima
**********************

Inicie o Maxima com o comando "maxima".  Maxima mostrará a informação de
versão e uma linha de comando.  Termine cada comando Maxima com um ponto
e vírgula.  Termine uma sessão com o comando "quit();".  Aqui está um
exemplo de sessão:

     [wfs@chromium]$ maxima
     Maxima 5.9.1 http://maxima.sourceforge.net
     Using Lisp CMU Common Lisp 19a
     Distributed under the GNU Public License. See the file COPYING.
     Dedicated to the memory of William Schelter.
     This is a development version of Maxima. The function bug_report()
     provides bug reporting information.
     (%i1) factor(10!);
                                 8  4  2
     (%o1)                      2  3  5  7
     (%i2) expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o2) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i3) factor (x^6 - 1);
                                   2            2
     (%o3)       (x - 1) (x + 1) (x  - x + 1) (x  + x + 1)
     (%i4) quit();
     [wfs@chromium]$

   Maxima pode procurar as páginas info.  Use o comando 'describe' para
mostrar informações sobre o comando ou todos os comandos e variáveis
contendo uma seqüência de caracteres.  O ponto de interrogação '?'
(busca exata) e o duplo ponto de interrogação '??' (busca inexata) são
abreviações para 'describe':

     (%i1) ?? integ
      0: Functions and Variables for Elliptic Integrals
      1: Functions and Variables for Integration
      2: Introduction to Elliptic Functions and Integrals
      3: Introduction to Integration
      4: askinteger  (Functions and Variables for Simplification)
      5: integerp  (Functions and Variables for Miscellaneous Options)
      6: integer_partitions  (Functions and Variables for Sets)
      7: integrate  (Functions and Variables for Integration)
      8: integrate_use_rootsof  (Functions and Variables for Integration)
      9: integration_constant_counter  (Functions and Variables for Integration)
      10: nonnegintegerp  (Functions and Variables for linearalgebra)
     Enter space-separated numbers, `all' or `none': 5 4

      -- Function: integerp (<expr>)
          Returns `true' if <expr> is a literal numeric integer, otherwise
          `false'.

          `integerp' returns false if its argument is a symbol, even if the
          argument is declared integer.

          Examples:

               (%i1) integerp (0);
               (%o1)                         true
               (%i2) integerp (1);
               (%o2)                         true
               (%i3) integerp (-17);
               (%o3)                         true
               (%i4) integerp (0.0);
               (%o4)                         false
               (%i5) integerp (1.0);
               (%o5)                         false
               (%i6) integerp (%pi);
               (%o6)                         false
               (%i7) integerp (n);
               (%o7)                         false
               (%i8) declare (n, integer);
               (%o8)                         done
               (%i9) integerp (n);
               (%o9)                         false

      -- Function: askinteger (<expr>, integer)
      -- Function: askinteger (<expr>)
      -- Function: askinteger (<expr>, even)
      -- Function: askinteger (<expr>, odd)
          `askinteger (<expr>, integer)' attempts to determine from the
          `assume' database whether <expr> is an integer.  `askinteger'
          prompts the user if it cannot tell otherwise, and attempt to
          install the information in the database if possible.  `askinteger
          (<expr>)' is equivalent to `askinteger (<expr>, integer)'.

          `askinteger (<expr>, even)' and `askinteger (<expr>, odd)'
          likewise attempt to determine if <expr> is an even integer or odd
          integer, respectively.

     (%o1)                                true

   Para usar um resultado em cálculos posteriores, você pode atribuir
esse valor a uma variável ou referir-se a esse mesmo valor através de
seu rótulo gerado automaticamente.  Adicionalmente, '%' refere-se ao
mais recente resultado calculado:

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (u, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) factor (%o2);
                                         5
     (%o3)                      6 (y + x)

   Maxima tem conhecimento sobre números complexos e constantes
numéricas:

     (%i1) cos(%pi);
     (%o1)                          - 1
     (%i2) exp(%i*%pi);
     (%o2)                          - 1

   Maxima pode fazer cálculos diferenciais e integrais:

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (%, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) integrate (1/(1 + x^3), x);
                                       2 x - 1
                     2            atan(-------)
                log(x  - x + 1)        sqrt(3)    log(x + 1)
     (%o3)    - --------------- + ------------- + ----------
                       6             sqrt(3)          3

   Maxima pode resolver sistemas lineares e equações cúbicas:

     (%i1) linsolve ([3*x + 4*y = 7, 2*x + a*y = 13], [x, y]);
                             7 a - 52        25
     (%o1)              [x = --------, y = -------]
                             3 a - 8       3 a - 8
     (%i2) solve (x^3 - 3*x^2 + 5*x = 15, x);
     (%o2)       [x = - sqrt(5) %i, x = sqrt(5) %i, x = 3]

   Maxima pode resolver sistemas de equações não lineares.  Note que se
você não quer um resultado impresso, você pode encerrar seu comando com
'$' em lugar de encerrar com ';'.

     (%i1) eq_1: x^2 + 3*x*y + y^2 = 0$
     (%i2) eq_2: 3*x + y = 1$
     (%i3) solve ([eq_1, eq_2]);
                   3 sqrt(5) + 7      sqrt(5) + 3
     (%o3) [[y = - -------------, x = -----------],
                         2                 2

                                    3 sqrt(5) - 7        sqrt(5) - 3
                               [y = -------------, x = - -----------]]
                                          2                   2

   Maxima pode gerar gráficos de uma ou mais funções:

     (%i1) eq_1: x^2 + 3*x*y + y^2 = 0$
     (%i2) eq_2: 3*x + y = 1$
     (%i3) solve ([eq_1, eq_2]);
                   3 sqrt(5) + 7      sqrt(5) + 3
     (%o3) [[y = - -------------, x = -----------],
                         2                 2

                                    3 sqrt(5) - 7        sqrt(5) - 3
                               [y = -------------, x = - -----------]]
                                          2                   2
     (%i4) kill(labels);
     (%o0)                         done
     (%i1) plot2d (sin(x)/x, [x, -20, 20]);
     (%o1)
     (%i2) plot2d ([atan(x), erf(x), tanh(x)], [x, -5, 5]);
     (%o2)
     (%i3) plot3d (sin(sqrt(x^2 + y^2))/sqrt(x^2 + y^2), [x, -12, 12], [y, -12, 12]);
     (%o3)


File: maxima.info,  Node: Detecção e Relato de Erros,  Next: Ajuda,  Prev: Introdução ao Maxima,  Up: Top

2 Detecção e Relato de Erros
****************************

* Menu:

* Definições para Detecção e Relato de Erros::  


File: maxima.info,  Node: Definições para Detecção e Relato de Erros,  Up: Detecção e Relato de Erros

2.1 Definições para Detecção e Relato de Erros
==============================================

 -- Função: run_testsuite ()
 -- Função: run_testsuite (<boolean>)
 -- Função: run_testsuite (<boolean>, <boolean>)
 -- Função: run_testsuite (<boolean>, <boolean>, <list>)
     Executa o conjunto de testes do Maxima.  Testes que produzem a
     resposta desejada são considerados "passes," e testes que não
     produzem a resposta desejada, são marcados como erros conhecidos.

     'run_testsuite ()' mostra somente testes que não são aprovados.

     'run_testsuite (true)' mostra somente testes que são marcados como
     erros conhecidos, bem como as falhas.

     'run_testsuite (true, true)' mostra todos os testes.

     Se o terceiro argumento opcional for dado, um subconjunto de testes
     é executado.  O subconjunto de testes para executar é dado como uma
     lista de nomes dos testes.  O conjunto completo de testes é
     especificado por 'testsuite_files'.

     'run_testsuite' altera a variável de ambiente Maxima.  Tipicamente
     um script de teste executa 'kill' para estabelecer uma variável de
     ambiente (uma a saber sem funções definidas pelo usuário e
     variáveis) e então define funções e variáveis apropriadamente para
     o teste.

     'run_testsuite' retorna 'done'.

 -- Variável de opção: testsuite_files

     'testsuite_files' é o conjunto de testes a ser executado por
     'run_testsuite'.  Isso é uma lista de nomes de arquivos contendo os
     testes a executar.  Se alguns dos testes em um arquivo falha de
     forma conhecida, então em lugar de listar o nome do arquivo, uma
     lista contendo o nome do arquivo e o número dos testes que falharam
     é usada.

     por exemplo, a linha adinate é uma parte do conjunto de testes
     padrão:

           ["rtest13s", ["rtest14", 57, 63]]

     Essa linha especifica a suite de testes que consiste dos arquivos
     "rtest13s" e "rtest14", mas "rtest14" contém dois testes que falham
     de forma conhecida: 57 e 63.

 -- Função: bug_report ()
     Imprime os números de versão do Maxima e do Lisp, e chama o link
     para a página web de informação de erros do projeto Maxima.  A
     informação da versão é a mesma reportada por 'build_info'.

     Quando um erro é informado, é muito útil copiar a versão do Maxima
     e do Lisp dentro da informação do erro.

     'bug_report' retorna uma seqüência de caracteres vazia '""'.

 -- Função: build_info ()
     Imprime um sumário de parâmetros da compilação do Maxima.

     'build_info' retorna uma seqüência de caracteres vazia '""'.


File: maxima.info,  Node: Ajuda,  Next: Linha de Comando,  Prev: Detecção e Relato de Erros,  Up: Top

3 Ajuda
*******

* Menu:

* Lisp e Maxima::            
* Descartando::          
* Documentação::               
* Funções e Variáveis Definidas para Ajuda::        


File: maxima.info,  Node: Lisp e Maxima,  Next: Descartando,  Prev: Ajuda,  Up: Ajuda

3.1 Lisp e Maxima
=================

Maxima é escrito na liguagem de programação Lisp, e é fácil acessar
funções Lisp e variáveis a partir do Maxima e vice-versa.  Símbolos Lisp
e Maxima são distingüidos através de uma convenção de nome.  Um símbolo
Lisp que começa com um sinal de dólar '$' corresponde a um símbolo
Maxima sem o sinal de dólar.  Um símbolo Maxima que começa com um ponto
de interrogação '?' corresponde a um símbolo Lisp sem o ponto de
interrogação.  Por exemplo, o símbolo Maxima 'foo' corresponde ao
símbolo Lisp '$foo', enquanto o símbolo Maxima '?foo' corresponde ao
símbolo Lisp 'foo', Note que '?foo' é escrito sem um espaço entre '?' e
'foo'; de outra forma pode ser uma chamada errônea para 'describe
("foo")'.

   Hífen '-', asterisco '*', ou outro caractere especial em símbolos
Lisp deve ser precedido por uma barra invertida '\' onde ele aparecer no
código Maxima.  Por exemplo, o identificador Lisp '*foo-bar*' é escrito
'?\*foo\-bar\*' no Maxima.

   Código Lisp pode ser executado dentro de uma sessão Maxima.  Uma
linha simples de Lisp (contendo uma ou mais formas) pode ser executada
através do comando especial ':lisp'.  Por exemplo,

     (%i1) :lisp (foo $x $y)

chama a função Lisp 'foo' com variáveis Maxima 'x' e 'y' como
argumentos.  A constução ':lisp' pode aparecer na linha de comando
interativa ou em um arquivo processado por 'batch' ou 'demo', mas não em
um arquivo processado por 'load', 'batchload', 'translate_file', ou
'compile_file'.

   A função 'to_lisp()' abre uma sessão interativa Lisp.  Digitando
'(to-maxima)' fecha a sessão Lisp e retorna para o Maxima.

   Funções Lisp e variáveis que são para serem visíveis no Maxima como
funções e variáveis com nomes comuns (sem pontuação especial) devem ter
nomes Lisp começando com o sinal de dólar '$'.

   Maxima é sensível à caixa, distingue entre letras em caixa alta
(maiúsculas) e letras em caixa baixa (minúsculas) em identificadores,
enquanto Lisp não é sensível à caixa.  Existem algumas regras governando
a tradução de nomes entre o Lisp e o Maxima.

  1. Um identificador Lisp não contido entre barras verticais
     corresponde a um identificador Maxima em caixa baixa.  Se o
     identificador Lisp estiver em caixa alta, caixa baixa, ou caixa
     mista, é ignorado.  E.g., Lisp '$foo', '$FOO', e '$Foo' todos
     correspondem a Maxima 'foo'.
  2. Um identificador Lisp que está todo em caixa alta ou todo em caixa
     baixa e contido em barras verticais corresponde a um identificador
     Maxima com caixa invertida.  Isto é, caixa alta é alterada para
     caixa baixa e caixa baixa para caixa alta.  E.g., Lisp '|$FOO|' e
     '|$foo|' corresponde a Maxima 'foo' e 'FOO', respectivamente.
  3. Um identificador Lisp que é misto de caixa alta e caixa baixa e
     contido entre barras verticais corresponde a um identificador
     Maxima com o mesma caixa.  E.g., Lisp '|$Foo|' corresponde a Maxima
     'Foo'.

   A macro Lisp '#$' permite o uso de expressões Maxima em código Lisp.
'#$<expr>$' expande para uma expressão Lisp equivalente à expressão
Maxima <expr>.

     (msetq $foo #$[x, y]$)

Isso tem o mesmo efeito que digitar

     (%i1) foo: [x, y];

A função Lisp 'displa' imprime uma expressão em formato Maxima.

     (%i1) :lisp #$[x, y, z]$
     ((MLIST SIMP) $X $Y $Z)
     (%i1) :lisp (displa '((MLIST SIMP) $X $Y $Z))
     [x, y, z]
     NIL

   Funções definidas em Maxima não são funções comuns em Lisp.  A função
Lisp 'mfuncall' chama uma função Maxima.  Por exemplo:

     (%i1) foo(x,y) := x*y$
     (%i2) :lisp (mfuncall '$foo 'a 'b)
     ((MTIMES SIMP) A B)

   Algumas funções Lisp possuem o mesmo nome que no pacote Maxima, a
saber as seguintes.

   'complement', 'continue', '//', 'float', 'functionp', 'array', 'exp',
'listen', 'signum', 'atan', 'asin', 'acos', 'asinh', 'acosh', 'atanh',
'tanh', 'cosh', 'sinh', 'tan', 'break', e 'gcd'.


File: maxima.info,  Node: Descartando,  Next: Documentação,  Prev: Lisp e Maxima,  Up: Ajuda

3.2 Descartando
===============

Computação simbólica tende a criar um bom volume de arquivos
temporários, e o efetivo manuseio disso pode ser crucial para sucesso
completo de alguns programas.

   Sob GCL, nos sistemas UNIX onde a chamada de sistema mprotect (
controle de acessso autorizado a uma região de memória) está disponível
(incluindo SUN OS 4.0 e algumas variantes de BSD) uma organização de
arquivos temporários estratificada está disponível.  Isso limita a
organização para páginas que tenham sido recentemente escritas.  Veja a
documentação da GCL sob ALLOCATE e GBC. No ambiente Lisp fazendo (setq
si::*notify-gbc* t) irá ajudar você a determinar quais áreas podem
precisar de mais espaço.


File: maxima.info,  Node: Documentação,  Next: Funções e Variáveis Definidas para Ajuda,  Prev: Descartando,  Up: Ajuda

3.3 Documentação
================

O manual on-line de usuário do Maxima pode ser visto em diferentes
formas.  A partir da linha de comando interativa do Maxima, o manual de
usuário é visto em texto plano através do comando '?' (i.e., a função
'describe' ).  O manual de usuário é visto como hipertexto 'info'
através do programa visualizador 'info' e como uma web page através de
qualquer navegador web comum.

   'example' mostra exemplos de muitas funções do Maxima.  Por exemplo,

     (%i1) example (integrate);

   retorna

     (%i2) test(f):=block([u],u:integrate(f,x),ratsimp(f-diff(u,x)))
     (%o2) test(f) := block([u], u : integrate(f, x),

                                              ratsimp(f - diff(u, x)))
     (%i3) test(sin(x))
     (%o3)                           0
     (%i4) test(1/(x+1))
     (%o4)                           0
     (%i5) test(1/(x^2+1))
     (%o5)                           0

   e saída adicional.


File: maxima.info,  Node: Funções e Variáveis Definidas para Ajuda,  Prev: Documentação,  Up: Ajuda

3.4 Funções e Variáveis Definidas para Ajuda
============================================

 -- Função: demo (<nomearquivo>)
     Avalia expressões Maxima em <nomearquivo> e mostra os resultados.
     'demo' faz uma pausa após avaliar cada expressão e continua após a
     conclusão com um enter das entradas de usuário.  (Se executando em
     Xmaxima, 'demo' pode precisar ver um ponto e vírgula ';' seguido
     por um enter.)

     'demo' procura na lista de diretórios 'file_search_demo' para achar
     'nomearquivo'.  Se o arquivo tiver o sufixo 'dem', o sufixo pode
     ser omitido.  Veja também 'file_search'.

     'demo' avalia seus argumento.  'demo' retorna o nome do arquivo de
     demonstração.

     Exemplo:

          (%i1) demo ("disol");

          batching /home/wfs/maxima/share/simplification/disol.dem
           At the _ prompt, type ';' followed by enter to get next demo
          (%i2)                      load(disol)

          _
          (%i3)           exp1 : a (e (g + f) + b (d + c))
          (%o3)               a (e (g + f) + b (d + c))

          _
          (%i4)                disolate(exp1, a, b, e)
          (%t4)                         d + c

          (%t5)                         g + f

          (%o5)                   a (%t5 e + %t4 b)

          _
          (%i5) demo ("rncomb");

          batching /home/wfs/maxima/share/simplification/rncomb.dem
           At the _ prompt, type ';' followed by enter to get next demo
          (%i6)                     load(rncomb)

          _
                                       z         x
          (%i7)               exp1 : ----- + ---------
                                     y + x   2 (y + x)
                                    z         x
          (%o7)                   ----- + ---------
                                  y + x   2 (y + x)

          _
          (%i8)                     combine(exp1)
                                    z         x
          (%o8)                   ----- + ---------
                                  y + x   2 (y + x)

          _
          (%i9)                     rncombine(%)
                                       2 z + x
          (%o9)                       ---------
                                      2 (y + x)

          _
                                       d   c   b   a
          (%i10)                exp2 : - + - + - + -
                                       3   3   2   2
                                    d   c   b   a
          (%o10)                    - + - + - + -
                                    3   3   2   2

          _
          (%i11)                    combine(exp2)
                                2 d + 2 c + 3 (b + a)
          (%o11)                ---------------------
                                          6

          _
          (%i12)                   rncombine(exp2)
                                2 d + 2 c + 3 b + 3 a
          (%o12)                ---------------------
                                          6

          _
          (%i13)

 -- Função: describe (<string>)
 -- Função: describe (<string>, exact)
 -- Função: describe (<string>, inexact)

     'describe(<string>)' é equivalente a 'describe(<string>, exact)'.

     'describe(<string>, exact)' encontra um item com título igual
     (case-insensitive) a <string>, se existir tal item.

     'describe(<string>, inexact)' encontra todos os itens documentados
     que contiverem <string> em seus títulos.  Se existe mais de um de
     tal item, Maxima solicita ao usuário selecionar um item ou ítens
     para mostrar.

     Na linha de comando interativa, '? foo' (com um espaço entre '?' e
     'foo') é equivalente a 'describe("foo", exact)'.  e '?? foo' é
     equivalente a 'describe("foo", inexact)'.

     'describe("", inexact)' retorna uma lista de todos os tópicos
     documentados no manual on-line.

     'describe' não avalia seu argumento.  'describe' retorna 'true' se
     alguma documentação for encontrada, de outra forma retorna 'false'.

     Veja também *note Documentação::.

     Exemplo:

          (%i1) ?? integ
           0: Functions and Variables for Elliptic Integrals
           1: Functions and Variables for Integration
           2: Introduction to Elliptic Functions and Integrals
           3: Introduction to Integration
           4: askinteger  (Functions and Variables for Simplification)
           5: integerp  (Functions and Variables for Miscellaneous Options)
           6: integer_partitions  (Functions and Variables for Sets)
           7: integrate  (Functions and Variables for Integration)
           8: integrate_use_rootsof  (Functions and Variables for Integration)
           9: integration_constant_counter  (Functions and Variables for Integration)
           10: nonnegintegerp  (Functions and Variables for linearalgebra)
          Enter space-separated numbers, `all' or `none': 7 8

           -- Function: integrate (<expr>, <x>)
           -- Function: integrate (<expr>, <x>, <a>, <b>)
               Attempts to symbolically compute the integral of <expr> with
               respect to <x>.  `integrate (<expr>, <x>)' is an indefinite
               integral, while `integrate (<expr>, <x>, <a>, <b>)' is a definite
               integral, [...]

           -- Option variable: integrate_use_rootsof
               Default value: `false'

               When `integrate_use_rootsof' is `true' and the denominator of a
               rational function cannot be factored, `integrate' returns the
               integral in a form which is a sum over the roots (not yet known)
               of the denominator.
               [...]

     Nesse exemplo, ítens 7 e 8 foram selecionados (a saída foi
     encurtada por razões tipográficas e economico-financeiras como
     indicado por '[...]'.  Todos ou nenhum dos ítens poderia ter sido
     selecionado através da inserção de 'all' ou 'none', que podem ser
     abreviado para 'a' ou para 'n', respectivamente.

 -- Função: example (<tópico>)
 -- Função: example ()
     'example (<topic>)' mostra alguns exemplos de <tópico>, que é um
     símbolo (não uma seqüência de caracteres).  A maioria dos tópicos
     são nomes de função.  'example ()' retorna a lista de todos os
     tópicos reconhecidos.

     O nome do arquivo contendo os exemplos é dado pela variável global
     'manual_demo', cujo valor padrão é '"manual.demo"'.

     'example' não avalia seu argumento.  'example' retorna 'done' a
     menos que ocorra um erro ou não exista o argumento fornecido pelo
     usuário, nesse caso 'example' retorna uma lista de todos os tópicos
     reconhecidos.

     Exemplos:

          (%i1) example (append);
          (%i2) append([x+y,0,-3.2],[2.5E+20,x])
          (%o2)             [y + x, 0, - 3.2, 2.5E+20, x]
          (%o2)                         done
          (%i3) example (coeff);
          (%i4) coeff(b+tan(x)+2*a*tan(x) = 3+5*tan(x),tan(x))
          (%o4)                      2 a + 1 = 5
          (%i5) coeff(1+x*%e^x+y,x,0)
          (%o5)                         y + 1
          (%o5)                         done


File: maxima.info,  Node: Linha de Comando,  Next: Operadores,  Prev: Ajuda,  Up: Top

4 Linha de Comando
******************

* Menu:

* Introdução a Linha de Comando::  
* Funções e Variáveis Definidas para Linha de Comando::  


File: maxima.info,  Node: Introdução a Linha de Comando,  Next: Funções e Variáveis Definidas para Linha de Comando,  Prev: Linha de Comando,  Up: Linha de Comando

4.1 Introdução a Linha de Comando
=================================

 -- Operador: '
     O operador apóstrofo ''' evita avaliação.

     Aplicado a um símbolo, o apóstrofo evita avaliação do símbolo.

     Aplicado a uma chamada de função, o apóstrofo evita avaliação da
     chamada de função, embora os argumentos da função sejam ainda
     avaliados (se a avaliação não for de outra forma evitada).  O
     resultado é a forma substantiva da chamada de função.

     Aplicada a uma espressão com parêntesis, o apóstrofo evita
     avaliação de todos os símbolos e chamadas de função na expressão.
     E.g., ''(f(x))' significa não avalie a expressão 'f(x)'.  ''f(x)'
     (com apóstrofo aplicado a 'f' em lugar de 'f(x)') retorna a forma
     substantiva de 'f' aplicada a '[x]'.

     O apóstrofo nao evita simplificação.

     Quando o sinalizador global 'noundisp' for 'true', substantivos são
     mostrados com um apóstrofo.  Esse comutador é sempre 'true' quando
     mostrando definições de funções.

     Veja também operador apóstrofo-apóstrofo '''' e 'nouns'.

     Exemplos:

     Aplicado a um símbolo, o apóstrofo evita avaliação do símbolo.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) aa^2;
          (%o2)                        1048576
          (%i3) 'aa^2;
                                           2
          (%o3)                          aa
          (%i4) ''%;
          (%o4)                        1048576

     Aplicado a uma chamada de função, o apóstrofo evita avaliação da
     chamada de função.  O resultado é a forma substantiva da chamada de
     função.

          (%i1) x0: 5;
          (%o1)                           5
          (%i2) x1: 7;
          (%o2)                           7
          (%i3) integrate (x^2, x, x0, x1);
                                         218
          (%o3)                          ---
                                          3
          (%i4) 'integrate (x^2, x, x0, x1);
                                       7
                                      /
                                      [   2
          (%o4)                       I  x  dx
                                      ]
                                      /
                                       5
          (%i5) %, nouns;
                                         218
          (%o5)                          ---
                                          3

     Aplicado a uma expressão com parêntesis, o apóstrofo evita
     avaliação de todos os símbolos e chamadas de função na expressão.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) bb: 19;
          (%o2)                          19
          (%i3) sqrt(aa) + bb;
          (%o3)                          51
          (%i4) '(sqrt(aa) + bb);
          (%o4)                     bb + sqrt(aa)
          (%i5) ''%;
          (%o5)                          51

     O apóstrofo não evita simplificação.

          (%i1) sin (17 * %pi) + cos (17 * %pi);
          (%o1)                          - 1
          (%i2) '(sin (17 * %pi) + cos (17 * %pi));
          (%o2)                          - 1

 -- Operador: ''
     O operador apóstrofo-apóstrofo '''' (dois apóstrofost) modifica
     avaliação em expressões de entrada.

     Aplicado a uma expressão geral <expr>, apóstrofo-apóstrofo faz com
     que o valor de <expr> seja substituído por <expr> na expressão de
     entrada.

     Aplicado ao operadro de uma expressão, apóstrofo-apóstrofo modifica
     o operadro de um susbstantivo para um verbo (se esse operador não
     for já um verbo).

     O operador apóstrofo-apóstrofo é aplicado através do passador de
     entrada; o apóstrofo-apóstrofo não é armazenado como parte de uma
     expressão de entrada passada.  O operador apóstrofo-apóstrofo é
     sempre aplicado tão rapidamente quanto for passado, e não pode
     receber um terceiro apóstrofo.  Dessa forma faz com que ocorra
     avaliação quando essa avaliação for de outra forma suprimida, da
     mesma forma que em definições de função, definições de expressãoes
     lambda, e expressões que recebem um apóstrofo simples '''.

     Apóstrofo-apóstrofo é reconhecido por 'batch' e 'load'.

     Veja também o operador apóstrofo ''' e 'nouns'.

     Exemplos:

     Aplicado a uma expressão geral <expr>, apóstrofo-apóstrofo fazem
     com que o valor de <expr> seja substituido por <expr> na expressão
     de entrada.

          (%i1) expand ((a + b)^3);
                               3        2      2      3
          (%o1)               b  + 3 a b  + 3 a  b + a
          (%i2) [_, ''_];
                                   3    3        2      2      3
          (%o2)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
          (%i3) [%i1, ''%i1];
                                   3    3        2      2      3
          (%o3)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
          (%i4) [aa : cc, bb : dd, cc : 17, dd : 29];
          (%o4)                   [cc, dd, 17, 29]
          (%i5) foo_1 (x) := aa - bb * x;
          (%o5)                 foo_1(x) := aa - bb x
          (%i6) foo_1 (10);
          (%o6)                      cc - 10 dd
          (%i7) ''%;
          (%o7)                         - 273
          (%i8) ''(foo_1 (10));
          (%o8)                         - 273
          (%i9) foo_2 (x) := ''aa - ''bb * x;
          (%o9)                 foo_2(x) := cc - dd x
          (%i10) foo_2 (10);
          (%o10)                        - 273
          (%i11) [x0 : x1, x1 : x2, x2 : x3];
          (%o11)                    [x1, x2, x3]
          (%i12) x0;
          (%o12)                         x1
          (%i13) ''x0;
          (%o13)                         x2
          (%i14) '' ''x0;
          (%o14)                         x3

     Aplicado ao operador de uma expressão, apóstrofo-apóstrofo muda o
     operadro de um substantivo para um verbo (se esse operadro não for
     já um verbo).

          (%i1) sin (1);
          (%o1)                        sin(1)
          (%i2) ''sin (1);
          (%o2)                    0.8414709848079
          (%i3) declare (foo, noun);
          (%o3)                         done
          (%i4) foo (x) := x - 1729;
          (%o4)                 ''foo(x) := x - 1729
          (%i5) foo (100);
          (%o5)                       foo(100)
          (%i6) ''foo (100);
          (%o6)                        - 1629

     O operador apóstrofo-apóstrofo é aplicado por meio de um passador
     de entrada; operador-apóstrofo não é armazenado como parte da
     expressão de entrada.

          (%i1) [aa : bb, cc : dd, bb : 1234, dd : 5678];
          (%o1)                 [bb, dd, 1234, 5678]
          (%i2) aa + cc;
          (%o2)                        dd + bb
          (%i3) display (_, op (_), args (_));
                                     _ = cc + aa

                                   op(cc + aa) = +

                              args(cc + aa) = [cc, aa]

          (%o3)                         done
          (%i4) ''(aa + cc);
          (%o4)                         6912
          (%i5) display (_, op (_), args (_));
                                     _ = dd + bb

                                   op(dd + bb) = +

                              args(dd + bb) = [dd, bb]

          (%o5)                         done

     Apóstrofo apóstrofo faz com que ocorra avaliação quando a avaliação
     tiver sido de outra forma suprimida, da mesma forma que em
     definições de função, da mesma forma que em definições de função
     lambda expressions, E expressões que recebem o apóstrofo simples
     '''.

          (%i1) foo_1a (x) := ''(integrate (log (x), x));
          (%o1)               foo_1a(x) := x log(x) - x
          (%i2) foo_1b (x) := integrate (log (x), x);
          (%o2)           foo_1b(x) := integrate(log(x), x)
          (%i3) dispfun (foo_1a, foo_1b);
          (%t3)               foo_1a(x) := x log(x) - x

          (%t4)           foo_1b(x) := integrate(log(x), x)

          (%o4)                      [%t3, %t4]
          (%i4) integrate (log (x), x);
          (%o4)                     x log(x) - x
          (%i5) foo_2a (x) := ''%;
          (%o5)               foo_2a(x) := x log(x) - x
          (%i6) foo_2b (x) := %;
          (%o6)                    foo_2b(x) := %
          (%i7) dispfun (foo_2a, foo_2b);
          (%t7)               foo_2a(x) := x log(x) - x

          (%t8)                    foo_2b(x) := %

          (%o8)                      [%t7, %t8]
          (%i8) F : lambda ([u], diff (sin (u), u));
          (%o8)             lambda([u], diff(sin(u), u))
          (%i9) G : lambda ([u], ''(diff (sin (u), u)));
          (%o9)                  lambda([u], cos(u))
          (%i10) '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
          (%o10)         sum(b , k, 1, 3) + sum(a , k, 1, 3)
                              k                  k
          (%i11) '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
          (%o11)             b  + a  + b  + a  + b  + a
                              3    3    2    2    1    1


File: maxima.info,  Node: Funções e Variáveis Definidas para Linha de Comando,  Prev: Introdução a Linha de Comando,  Up: Linha de Comando

4.2 Funções e Variáveis Definidas para Linha de Comando
=======================================================

 -- Função: alias (<new_name_1>, <old_name_1>, ..., <new_name_n>,
          <old_name_n>)
     provê um nome alternativo para uma função (de usuário ou de
     sistema), variável, array, etc.  Qualquer número de argumentos pode
     ser usado.

 -- Variável de opção: debugmode
     Valor padrão: 'false'

     Quando um erro do Maxima ocorre, Maxima iniciará o depurador se
     'debugmode' for 'true'.  O usuário pode informar comandos para
     examinar o histórico de chamadas, marcar pontos de parada,
     percorrer uma linha por vez o código do Maxima, e assim por diante.
     Veja 'debugging' para uma lista de opções do depurador.

     Habilitando 'debugmode' por meio da alteração de seu valor para
     'true', não serão capturados erros do Lisp.

 -- Função: ev (<expr>, <arg_1>, ..., <arg_n>)
     Avalia a expressão <expr> no ambiente especificado pelos argumentos
     <arg_1>, ..., <arg_n>.  Os argumentos são comutadores
     (sinalizadores Booleanos), atribuições, equações, e funções.  'ev'
     retorna o resultado (outra expressão) da avaliação.

     A avaliação é realizada em passos, como segue.

       1. Primeiro o ambiente é preparado examinando os argumentos que
          podem ser quaisquer ou todos os seguintes.

             * 'simp' faz com que <expr> seja simplificado
               independentemente da posição do comutador 'simp' que
               inibe simplificação se 'false'.
             * 'noeval' suprime a fase de avaliação de 'ev' (veja passo
               (4) adiante).  Isso é útil juntamente com outros
               comutadores e faz com que <expr> seja simplificado
               novamente sem ser reavaliado.
             * 'nouns' causa a avaliação de formas substantivas
               (tipicamente funções não avaliadas tais como ''integrate'
               ou ''diff') em <expr>.
             * 'expand' causa expansão.
             * 'expand (<m>, <n>)' causa expansão, alterando os valores
               de 'maxposex' e 'maxnegex' para <m> e <n>
               respectivamente.
             * 'detout' faz com que qualquer matriz inversa calculada em
               <expr> tenha seu determinante mantido fora da inversa ao
               invés de dividindo a cada elemento.
             * 'diff' faz com que todas as diferenciações indicadas em
               <expr> sejam executadas.
             * 'derivlist (<x>, <y>, <z>, ...)' causa somente
               diferenciações referentes às variáveis indicadas.
             * 'float' faz com que números racionais não inteiros sejam
               convertidos para ponto flutuante.
             * 'numer' faz com que algumas funções matemáticas
               (incluindo a exponenciação) com argumentos sejam valiadas
               em ponto flutuante.  Isso faz com que variávels em <expr>
               que tenham sido dados numervals (valores numéricos) sejam
               substituídas por seus valores.  Isso também modifica o
               comutador 'float' para ativado.
             * 'pred' faz com que predicados (expressões que podem ser
               avaliados em 'true' ou 'false') sejam avaliadas.
             * 'eval' faz com que uma avaliação posterior de <expr>
               ocorra.  (Veja passo (5) adiante.)  'eval' pode ocorrer
               multiplas vezes.  Para cada instância de 'eval', a
               expressão é avaliada novamente.
             * 'A' onde 'A' é um átomo declarado seja um sinalizador de
               avaliação (veja 'evflag') faz com que 'A' seja associado
               a 'true' durante a avaliação de <expr>.
             * 'V: expresão' (ou alternativamente 'V=expressão') faz com
               que 'V' seja associado ao valor de 'expressão' durante a
               avaliação de <expr>.  Note que se 'V' é uma opção do
               Maxima, então 'expression' é usada para seu valor durante
               a avaliação de <expr>.  Se mais que um argumento para
               'ev' é desse tipo então a associação termina em paralelo.
               Se 'V' é uma expressão não atômica então a substituição,
               ao invés de uma associação, é executada.
             * 'F' onde 'F', um nome de função, tenha sido declarado
               para ser uma função de avaliação (veja 'evfun') faz com
               que 'F' seja aplicado a <expr>.
             * Qualquer outro nome de função (e.g., 'sum') causa a
               avaliação de ocorrências desses nomes em <expr> mesmo que
               eles tenham sido verbos.
             * De forma adicional uma função ocorrendo em <expr>
               (digamos 'F(x)') pode ser definida localmente para o
               propósito dessa avaliação de <expr> dando 'F(x) :=
               expressão' como um argumento para 'ev'.
             * Se um átomo não mensionado acima ou uma variável
               subscrita ou expressão subscrita for dada como um
               argumento, isso é avaliado e se o resultado for uma
               equação ou uma atribuição então a associação indicada ou
               substituição é executada.  Se o resultado for uma lista
               então os membros da lista serão tratados como se eles
               fossem argumentos adicionais dados para 'ev'.  Isso
               permite que uma lista de equações seja dada (e.g.  '[X=1,
               Y=A**2]') ou que seja dado uma lista de nomes de equações
               (e.g., '[%t1, %t2]' onde '%t1' e '%t2' são equações) tais
               como aquelas listas retornadas por 'solve'.

          Os argumentos de 'ev' podem ser dados em qualquer ordem com
          exceção de substituições de equações que são manuseadas em
          seqüência, da esquerda para a direita, e funções de avaliação
          que são compostas, e.g., 'ev (<expr>, ratsimp, realpart)' são
          manuseadas como 'realpart (ratsimp (<expr>))'.

          Os comutadores 'simp', 'numer', 'float', e 'pred' podem também
          ser alterados localmente em um bloco, ou globalmente no Maxima
          dessa forma eles irã permanecer em efeito até serem resetados
          ao término da execução do bloco.

          Se <expr> for uma expressão racional canônica (CRE), então a
          expressão retornada por 'ev' é também uma CRE, contanto que os
          comutadores 'numer' e 'float' não sejam ambos 'true'.

       2. Durante o passo (1), é feito uma lista de variáveis não
          subscritas aparecendo do lado esquerdo das equações nos
          argumentos ou nos valores de alguns argumentos se o valor for
          uma equação.  As variáveis (variáveis subscritas que não
          possuem funções array associadas bem como variáveis não
          subscritas) na expressão <expr> são substituídas por seus
          valores globais, exceto para esse aparecendo nessa lista.
          Usualmente, <expr> é apenas um rótulo ou '%' (como em '%i2' no
          exemplo adiante), então esse passo simplesmente repete a
          expressão nomeada pelo rótulo, de modo que 'ev' possa
          trabalhar sobre isso.

       3. Se quaisquer substituições tiveem sido indicadas pelos
          argumentos, elas serão realizadas agora.

       4. A expressão resultante é então reavaliada (a menos que um dos
          argumentos seja 'noeval') e simplificada conforme os
          argumentos.  Note que qualquer chamada de função em <expr>
          será completada depois das variáveis nela serem avalidas e que
          'ev(F(x))' dessa forma possa comportar-se como 'F(ev(x))'.

       5. Para cada instância de 'eval' nos argumentos, os passos (3) e
          (4) são repetidos.

     Exemplos

          (%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                               d                    2
          (%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                               dw
          (%i2) ev (%, sin, expand, diff, x=2, y=1);
                                    2
          (%o2)           cos(w) + w  + 2 w + cos(1) + 1.909297426825682

     Uma sintaxe alternativa de alto nível tem sido provida por 'ev',
     por meio da qual se pode apenas digitar seus argumentos, sem o
     'ev()'.  Isto é, se pode escrever simplesmente

          <expr>, <arg_1>, ..., <arg_n>

     Isso não é permitido como parte de outra expressão, e.g., em
     funções, blocos, etc.

     Observe o processo de associação paralela no seguinte exemplo.

          (%i3) programmode: false;
          (%o3)                                false
          (%i4) x+y, x: a+y, y: 2;
          (%o4)                              y + a + 2
          (%i5) 2*x - 3*y = 3$
          (%i6) -3*x + 2*y = -4$
          (%i7) solve ([%o5, %o6]);
          Solution

                                                    1
          (%t7)                               y = - -
                                                    5

                                                   6
          (%t8)                                x = -
                                                   5
          (%o8)                            [[%t7, %t8]]
          (%i8) %o6, %o8;
          (%o8)                              - 4 = - 4
          (%i9) x + 1/x > gamma (1/2);
                                             1
          (%o9)                          x + - > sqrt(%pi)
                                             x
          (%i10) %, numer, x=1/2;
          (%o10)                      2.5 > 1.772453850905516
          (%i11) %, pred;
          (%o11)                               true

 -- Propriedade: evflag
     Quando um símbolo <x> tem a propriedade 'evflag', as expressões
     'ev(<expr>, <x>)' e '<expr>, <x>' (na linha de comando interativa)
     são equivalentes a 'ev(<expr>, <x> = true)'.  Isto é, <x> está
     associada a 'true' enquanto <expr> for avaliada.

     A expressão 'declare(<x>, evflag)' fornece a propriedade 'evflag'
     para a variável <x>.

     Os sinalizadores que possuem a propriedade 'evflag' por padrão são
     os seguintes: 'algebraic', 'cauchysum', 'demoivre', 'dotscrules',
     '%emode', '%enumer', 'exponentialize', 'exptisolate', 'factorflag',
     'float', 'halfangles', 'infeval', 'isolate_wrt_times', 'keepfloat',
     'letrat', 'listarith', 'logabs', 'logarc', 'logexpand',
     'lognegint', 'lognumer', 'm1pbranch', 'numer_pbranch',
     'programmode', 'radexpand', 'ratalgdenom', 'ratfac', 'ratmx',
     'ratsimpexpons', 'simp', 'simpsum', 'sumexpand', e 'trigexpand'.

     Exemplos:

          (%i1) sin (1/2);
                                           1
          (%o1)                        sin(-)
                                           2
          (%i2) sin (1/2), float;
          (%o2)                   0.479425538604203
          (%i3) sin (1/2), float=true;
          (%o3)                   0.479425538604203
          (%i4) simp : false;
          (%o4)                         false
          (%i5) 1 + 1;
          (%o5)                         1 + 1
          (%i6) 1 + 1, simp;
          (%o6)                           2
          (%i7) simp : true;
          (%o7)                         true
          (%i8) sum (1/k^2, k, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o8)                        >    --
                                      /      2
                                      ====  k
                                      k = 1
          (%i9) sum (1/k^2, k, 1, inf), simpsum;
                                           2
                                        %pi
          (%o9)                         ----
                                         6
          (%i10) declare (aa, evflag);
          (%o10)                        done
          (%i11) if aa = true then SIM else NÃO;
          (%o11)                         NÃO
          (%i12) if aa = true then SIM else NÃO, aa;
          (%o12)                         SIM

 -- Propriedade: evfun
     Quando uma função <F> tem a propriedade 'evfun', as expressões
     'ev(<expr>, <F>)' e '<expr>, <F>' (na linha de comando interativa)
     são equivalentes a '<F>(ev(<expr>))'.

     Se duas ou mais funções <F>, <G>, etc., que possuem a propriedade
     'evfun' forem especificadas, as funções serão aplicadas na ordem em
     que forem especificadas.

     A expressão 'declare(<F>, evfun)' fornece a propriedade 'evfun'
     para a função <F>.

     As funções que possuem a propriedade 'evfun' por padrão são as
     seguintes: 'bfloat', 'factor', 'fullratsimp', 'logcontract',
     'polarform', 'radcan', 'ratexpand', 'ratsimp', 'rectform',
     'rootscontract', 'trigexpand', e 'trigreduce'.

     Exemplos:

          (%i1) x^3 - 1;
                                        3
          (%o1)                        x  - 1
          (%i2) x^3 - 1, factor;
                                          2
          (%o2)                 (x - 1) (x  + x + 1)
          (%i3) factor (x^3 - 1);
                                          2
          (%o3)                 (x - 1) (x  + x + 1)
          (%i4) cos(4 * x) / sin(x)^4;
                                      cos(4 x)
          (%o4)                       --------
                                         4
                                      sin (x)
          (%i5) cos(4 * x) / sin(x)^4, trigexpand;
                           4           2       2         4
                        sin (x) - 6 cos (x) sin (x) + cos (x)
          (%o5)         -------------------------------------
                                          4
                                       sin (x)
          (%i6) cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
                                     2         4
                                6 cos (x)   cos (x)
          (%o6)               - --------- + ------- + 1
                                    2          4
                                 sin (x)    sin (x)
          (%i7) ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
                                     2         4
                                6 cos (x)   cos (x)
          (%o7)               - --------- + ------- + 1
                                    2          4
                                 sin (x)    sin (x)
          (%i8) declare ([F, G], evfun);
          (%o8)                         done
          (%i9) (aa : bb, bb : cc, cc : dd);
          (%o9)                          dd
          (%i10) aa;
          (%o10)                         bb
          (%i11) aa, F;
          (%o11)                        F(cc)
          (%i12) F (aa);
          (%o12)                        F(bb)
          (%i13) F (ev (aa));
          (%o13)                        F(cc)
          (%i14) aa, F, G;
          (%o14)                      G(F(cc))
          (%i15) G (F (ev (aa)));
          (%o15)                      G(F(cc))

 -- Variável de opção: infeval
     Habilita o modo "avaliação infinita".  'ev' repetidamente avalia
     uma expressão até que ela permaneça invariante.  Para prevenir uma
     variável, digamos 'X', seja demoradamente avaliada nesso modo,
     simplesmente inclua 'X='X' como um argumento para 'ev'.  Certamente
     expressões tais como 'ev (X, X=X+1, infeval)' irão gerar um ciclo
     infinito.

 -- Função: kill (<a_1>, ..., <a_n>)
 -- Função: kill (labels)
 -- Função: kill (inlabels, outlabels, linelabels)
 -- Função: kill (<n>)
 -- Função: kill ([<m>, <n>])
 -- Função: kill (values, functions, arrays, ...)
 -- Função: kill (all)
 -- Função: kill (allbut (<a_1>, ..., <a_n>))

     Remove todas as associações (valor, funções, array, ou regra) dos
     argumentos <a_1>, ..., <a_n>.  Um argumento <a_k> pode ser um
     símbolo ou um elemento de array simples.  Quando <a_k> for um
     elemento de array simples, 'kill' remove a associação daquele
     elemento sem afetar qualquer outro elemento do array.

     Muitos argumentos especiais são reconhecidos.  Diferentes famílias
     de argumentos podem ser combinadas, e.g., 'kill (inlabels,
     functions, allbut (foo, bar))'

     todos os rótulos de entrada, de saída, e de expressões
     intermediárias criados até então.  'kill (inlabels)' libera somente
     rótudos de entrada que começam com o valor corrente de 'inchar'.
     De forma semelhante, 'kill (outlabels)' libera somente rótulos de
     saída que começam com o valor corrente de 'outchar', e 'kill
     (linelabels)' libera somente rótulos de expressões intermediárias
     que começam com o valor corrente de 'linechar'.

     'kill (<n>)', onde <n> é um inteiro, libera os <n> mais recentes
     rótulos de entrada e saída.

     'kill ([<m>, <n>])' libera rótulos de entrada e saída de <m> até
     <n>.

     'kill (<infolist>)', onde <infolist> é um item em 'infolists' (tais
     como 'values', 'functions', ou 'arrays') libera todos os ítens em
     <infolist>.  Veja também 'infolists'.

     'kill (all)' liberar todos os ítens em todas as infolists.  'kill
     (all)' não retorna variáveis globais para seus valores padrões;
     Veja 'reset' sobre esse ponto.

     'kill (allbut (<a_1>, ..., <a_n>))' remove a associação de todos os
     itens sobre todas as infolistas exceto para <a_1>, ..., <a_n>.
     'kill (allbut (<infolist>))' libera todos os ítens exceto para si
     próprio em <infolist>, onde <infolist> é 'values', 'functions',
     'arrays', etc.

     A memória usada por uma propriedade de associação não será liberada
     até que todos os símbolos sejam liberados disso.  Em particular,
     para liberar a memória usada pelo valor de um símbolo, deve-se
     liberar o rótulo de saída que mosta o valor associado, bem como
     liberando o próprio símbolo.

     'kill' coloca um apóstro em seus argumentos (não os avalia).  O
     operador apóstrofo-apóstrofo, '''', faz com que ocorra avaliação.

     'kill (<símbolo>)' libera todas as propriedades de <símbolo>.  Em
     oposição, 'remvalue', 'remfunction', 'remarray', e 'remrule'
     liberam uma propriedade específica.

     'kill' sempre retorna 'done', igualmente se um argumento não tem
     associações.

 -- Função: labels (<símbolo>)
 -- Variável de sistema: labels
     Retorna a lista de rótulos de entradas, de saída, de expressões
     intermediárias que começam com <símbolo>.  Tipicamente <símbolo> é
     o valor de 'inchar', 'outchar', ou 'linechar'.  O caracter rótulo
     pode ser dado com ou sem o sinal de porcentagem, então, por
     exemplo, 'i' e '%i' retornam o mesmo resultado.

     Se nenhum rótulo começa com <símbolo>, 'labels' retorna uma lista
     vazia.

     A função 'labels' não avalia seu argumento.  O operador
     apóstrofo-apóstrofo '''' faz com que ocorra avaliação.  Por
     exemplo, 'labels (''inchar)' retorna os rótulos de entrada que
     começam com o caractere corrente do rótulo de entrada.

     A variável 'labels' é uma lista de rótulos de entrada, saída, e de
     expressões intermediárias, incluindo todos os rótulos anteriores se
     'inchar', 'outchar', ou 'linechar' que tiverem sido redefinidos.

     Por padrão, Maxima mostra o resultado de cada expressão de entrada
     do usuário, dando ao resultado um rótulo de saída.  A exibição da
     saída é suprimida pelo encerramento da entrada com '$' (sinal de
     dolar) em lugar de ';' (ponto e vírgula).  Um rótulo de saída é
     construido e associado ao resultado, mas não é mostrado, e o rótulo
     pode ser referenciado da mesma forma que rótulos de saída
     mostrados.  Veja também '%', '%%', e '%th'.

     Rótulos de expressões intermediárias podem ser gerados por algumas
     funções.  O sinalizador 'programmode' controla se 'solve' e algumas
     outras funções geram rótulos de expressões intermediárias em lugar
     de retornar uma lista de expressões.  Algumas outras funções, tais
     como 'ldisplay', sempre geram rótulos de expressões intermediárias.

     Veja também 'inchar', 'outchar', 'linechar', e 'infolists'.

 -- Variável de sistema: linenum
     Retorna o número da linha do par corrente de expressões de entrada
     e saída.

 -- Variável de sistema: myoptions
     Valor padrão: '[]'

     'myoptions' é a lista de todas as opções alguma vez alteradas pelo
     usuário, tenha ou não ele retornado a alteração para o seu valor
     padrão.

 -- Variável de opção: nolabels
     Valor padrão: 'false'

     Quando 'nolabels' for 'true', rótulos de entrada e saída ('%i' e
     '%o', respectivamente) são mostrados, mas os rótulos não são
     associados aos resultados, e os rótulos não são anexados ao final
     da lista 'labels'.  Uma vez que rótulos não são associados aos
     resultados, a reciclagem pode recuperar a memória tomada pelos
     resultados.

     De outra forma rótulos de entrada e saída são associados aos
     resultados, e os rótulos são anexados ao final da lista 'labels'.

     Veja também 'batch', 'batchload', e 'labels'.

 -- Variável de opção: optionset
     Valor padrão: 'false'

     Quando 'optionset' for 'true', Maxima mostrará uma mensagem sempre
     que uma opção do Maxima for alterada.  Isso é útil se o usuário
     está incerto sobre a ortografia de alguma opção e quer ter certeza
     que a variável por ele atribuído um valor foi realmente uma
     variável de opção.

 -- Função: playback ()
 -- Função: playback (<n>)
 -- Função: playback ([<m>, <n>])
 -- Função: playback ([<m>])
 -- Função: playback (input)
 -- Função: playback (slow)
 -- Função: playback (time)
 -- Função: playback (grind)
     Mostra expressões de entrada, de saída, e expressões
     intermediárias, sem refazer os cálculos.  'playback' somente mostra
     as expressões associadas a rótulos; qualquer outra saída (tais como
     textos impressos por 'print' ou 'describe', ou messagens de erro)
     não é mostrada.  Veja também 'labels'.

     'playback' não avalia seus argumentos.  O operador
     apóstrofo-apóstrofo, '''', sobrepõe-se às aspas.  'playback' sempre
     retorna 'done'.

     'playback ()' (sem argumentos) mostra todas as entradas, saídas e
     expressões intermediárias geradas até então.  Uma expressão de
     saída é mostrada mesmo se for suprimida pelo terminador '$' quando
     ela tiver sido originalmente calculada.

     'playback (<n>)' mostra as mais recentes <n> expressões.  Cada
     entrada, saída e expressão intermediária conta como um.

     'playback ([<m>, <n>])' mostra entradas, saídas e expressões
     intermediárias com os números de <m> até <n>, inclusive.

     'playback ([<m>])' é equivalente a 'playback ([<m>, <m>])'; isso
     usualmente imprime um par de expressões de entrada e saída.

     'playback (input)' mostra todas as expressões de entrada geradas
     até então.

     'playback (slow)' insere pausas entre expressões e espera que o
     usuário pressione 'enter'.  Esse comportamento é similar a 'demo'.
     'playback (slow)' é útil juntamente com 'save' ou 'stringout'
     quando criamos um arquivo secundário de armazenagem com a
     finalidade de capturar expressões úteis.

     'playback (time)' mostra o tempo de computação de cada expressão.

     'playback (grind)' mostra expressões de entrada no mesmo formato da
     função 'grind'.  Expressões de saída não são afetadas pela opção
     'grind'.  Veja 'grind'.

     Argumentos podem ser combinados, e.g., 'playback ([5, 10], grind,
     time, slow)'.

 -- Função: printprops (<a>, <i>)
 -- Função: printprops ([<a_1>, ..., <a_n>], <i>)
 -- Função: printprops (all, <i>)
     Mostra a propriedade como o indicador <i> associada com o átomo
     <a>.  <a> pode também ser uma lista de átomos ou o átomo 'all'
     nesse caso todos os átomos com a propriedade dada serão usados.
     Por exemplo, 'printprops ([f, g], atvalue)'.  'printprops' é para
     propriedades que não podem ser mostradas de outra forma, i.e.  para
     'atvalue', 'atomgrad', 'gradef', e 'matchdeclare'.

 -- Variável de opção: prompt
     Valor padrão: '_'

     'prompt' é o símbolo de linha de comando da função 'demo', modo
     'playback (slow)', e da interrupção de ciclos do Maxima (como
     invocado por 'break').

 -- Função: quit ()
     Encerra a sessão do Maxima.  Note que a função pode ser invocada
     como 'quit();' ou 'quit()$', não por sí mesma 'quit'.

     Para parar um cálculo muito longo, digite 'control-C'.  A ação
     padrão é retornar à linha de comando do Maxima.  Se
     '*debugger-hook*' é 'nil', 'control-C' abre o depurador Lisp.  Veja
     também 'debugging'.

 -- Função: remfunction (<f_1>, ..., <f_n>)
 -- Função: remfunction (all)
     Desassocia as definições de função dos síbolos <f_1>, ..., <f_n>.
     Os argumentos podem ser os nomes de funções comuns (criadas por
     meio de ':=' ou 'define') ou funções macro (criadas por meio de
     '::=').

     'remfunction (all)' desassocia todas as definições de funcção.

     'remfunction' coloca um ap'ostrofo em seus argumentos (não os
     avalia).

     'remfunction' retorna uma lista de símbolos para a qual a definição
     de função foi desassociada.  'false' é retornado em lugar de
     qualquer símbolo para o qual não exista definição de função.

 -- Função: reset ()
     Retorna muitas variáveis globais e opções, e algumas outras
     variáveis, para seus valores padrões.

     'reset' processa as variáveis na lista Lisp
     '*variable-initial-values*'.  A macro Lisp 'defmvar' coloca
     variáveis nessa lista (entre outras ações).  Muitas, mas não todas,
     variáveis globais e opções são definidas por 'defmvar', e algumas
     variáveis definidas por 'defmvar' não são variáveis globais ou
     variáveis de opção.

 -- Variável de opção: showtime
     Valor padrão: 'false'

     Quando 'showtime' for 'true', o tempo de computação e o tempo
     decorrido são impressos na tela com cada expressão de saída.

     O tempo de cálculo é sempre gravado, então 'time' e 'playback'
     podem mostrar o tempo de cálculo mesmo quando 'showtime' for
     'false'.

     Veja também 'timer'.

 -- Função: sstatus (<recurso>, <pacote>)
     Altera o status de <recurso> em <pacote>.  Após 'sstatus
     (<recurso>, <pacote>)' ser executado, 'status (<recurso>,
     <pacote>)' retorna 'true'.  Isso pode ser útil para quem escreve
     pacotes, para manter um registro de quais recursos os pacotes usam.

 -- Função: to_lisp ()
     Insere o sistema Lisp dentro do Maxima.  '(to-maxima)' retorna para
     o Maxima.

 -- Variável de sistema: values
     Valor inicial: '[]'

     'values' é uma lista de todas as varáveis de usuário associadas
     (não opções Maxima ou comutadores).  A lista compreende símbolos
     associados por ':' , '::', ou ':='.


File: maxima.info,  Node: Operadores,  Next: Expressões,  Prev: Linha de Comando,  Up: Top

5 Operadores
************

* Menu:

* N-Argumentos::                        
* Operador não fixado::                       
* Operador Pósfixado::                     
* Operador Préfixado::                      
* Operadores Aritméticos::   
* Operadores Relacionais::   
* Operadores Geral::   


File: maxima.info,  Node: N-Argumentos,  Next: Operador não fixado,  Prev: Operadores,  Up: Operadores

5.1 N-Argumentos
================

Um operador 'nary' é usado para denotar uma função com qualquer número
de argumentos, cada um dos quais é separado por uma ocorrência do
operador, e.g.  A+B ou A+B+C. A função 'nary("x")' é uma função de
extensão sintática para declarar x como sendo um operador 'nary'.
Funções podem ser declaradas para serem 'nary'.  Se 'declare(j,nary);' é
concluída, diz ao simplicador para simplificar, e.g.  'j(j(a,b),j(c,d))'
para 'j(a, b, c, d)'.

   Veja também 'syntax'.


File: maxima.info,  Node: Operador não fixado,  Next: Operador Pósfixado,  Prev: N-Argumentos,  Up: Operadores

5.2 Operador não fixado
=======================

Operadores 'nofix' são usados para denotar funções sem argumentos.  A
mera presença de tal operador em um comando fará com que a função
correspondente seja avaliada.  Por exemplo, quando se digita "exit;"
para sair de uma parada do Maxima, "exit" tem comportamento similar a um
operador 'nofix'.  A função 'nofix("x")' é uma função de extensão
sintática que declara x como sendo um operador 'nofix'.

   Veja também 'syntax'.


File: maxima.info,  Node: Operador Pósfixado,  Next: Operador Préfixado,  Prev: Operador não fixado,  Up: Operadores

5.3 Operador Pósfixado
======================

Operadores 'postfix' como a variedade 'prefix' denotam funções de um
argumento simples, mas nesse caso o argumento sucede imediatamente uma
ocorrência do operador na seqüência de caracteres de entrada, e.g.  3!
.  Uma função 'postfix("x")' é uma função de extensão sintática que
declara x como sendo um operador 'postfix'.

   Veja também 'syntax'.


File: maxima.info,  Node: Operador Préfixado,  Next: Operadores Aritméticos,  Prev: Operador Pósfixado,  Up: Operadores

5.4 Operador Préfixado
======================

Um operador 'prefix' é um que significa uma função de um argumento, o
qual imediatamente segue uma ocorrência do operador.  'prefix("x")' é
uma função de extensão sintática que declara x como sendo um operador
'prefix'.

   Veja também 'syntax'.


File: maxima.info,  Node: Operadores Aritméticos,  Next: Operadores Relacionais,  Prev: Operador Préfixado,  Up: Operadores

5.5 Operadores Aritméticos
==========================

 -- Operador: +
 -- Operador: -
 -- Operador: *
 -- Operador: /
 -- Operador: ^

     Os símbolos '+' '*' '/' e '^' representam adição, multiplicação,
     divisão, e exponenciação, respectivamente.  O nome desses
     operadores são '"+"' '"*"' '"/"' e '"^"', os quais podem aparecer
     em lugares onde o nome da função ou operador é requerido.

     Os símbolos '+' e '-' representam a adição unária e a negação
     unária, respectivamente, e os nomes desses operadores são '"+"' e
     '"-"', respectivamente.

     A subtração 'a - b' é representada dentro do Maxima como a adição,
     'a + (- b)'.  Expressões tais como 'a + (- b)' são mostradas como
     subtração.  Maxima reconhece '"-"' somente como o nome do operador
     unário de negação, e não como o nome do operador binário de
     subração.

     A divisão 'a / b' é representada dentro do Maxima como
     multiplicação, 'a * b^(- 1)'.  Expressões tais como 'a * b^(- 1)'
     são mostradas como divisão.  Maxima reconhece '"/"' como o nome do
     operador de divisão.

     A adição e a multiplicação são operadores enários e comutativos.  a
     divisão e a exponenciação são operadores binários e não
     comutativos.

     Maxima ordena os operandos de operadores não comutativos para
     construir uma representação canônica.  Para armazenamento interno,
     a ordem é determinada por 'orderlessp'.  Para mostrar na tela, a
     ordem para adição é determinada por 'ordergreatp', e para a
     multiplicação, a ordem é a mesma da ordenação para armazenamento
     interno.

     Computações aritiméticas são realizadas sobre números literais
     (inteiro, racionais, números comuns em ponto flutuante, e grandes
     números em ponto flutuante de dupla precisão).  Execto a
     exponenciação, todas as operações aritméticas sobre números são
     simplificadas para números.  A exponenciação é simplificada para um
     número se ou o operando é um número comum em ponto flutuante ou um
     grande número em ponto flutuante de dupla precisão ou se o
     resultado for um inteiro exato ou um racional exato; de outra forma
     uma exponenciação pode ser simplificada para 'sqrt' ou outra
     exponenciação ou permanecer inalterada.

     A propagação de números em ponto flutuante aplica-se a computações
     aritiméticas: Se qualquer operando for um grande número em ponto
     flutuante, o resultado é um grande número em ponto flutuante; de
     outra forma, se qualquer operando for um número em ponto flutuante
     comum, o resultado é um número comum em ponto flutuante; de outra
     forma, se os operandos forem racioanis ou inteiros e o resultado
     será um racional ou inteiro.

     Computaçãoes aritiméticas são uma simplificação, não uma avaliação.
     Dessa forma a aritmética é realizada em expressões com apóstrofo
     (mas simplificadas).

     Operações aritméticas são aplicadas elemento-por-elemento para
     listas quando a variável global 'listarith' for 'true', e sempre
     aplicada elemento-por-elemento para matrizes.  Quando um operando
     for uma lista ou uma matriz e outro for um operando de algum outro
     tipo, o outro operando é combinado com cada um dos elementos da
     lista ou matriz.

     Exemplos:

     Adição e multiplicação são opeadores enários comutativos.  Maxima
     ordena os operandos para construir uma representação canônica.  Os
     nomes desses operadores são '"+"' e '"*"'.

          (%i1) c + g + d + a + b + e + f;
          (%o1)               g + f + e + d + c + b + a
          (%i2) [op (%), args (%)];
          (%o2)              [+, [g, f, e, d, c, b, a]]
          (%i3) c * g * d * a * b * e * f;
          (%o3)                     a b c d e f g
          (%i4) [op (%), args (%)];
          (%o4)              [*, [a, b, c, d, e, f, g]]
          (%i5) apply ("+", [a, 8, x, 2, 9, x, x, a]);
          (%o5)                    3 x + 2 a + 19
          (%i6) apply ("*", [a, 8, x, 2, 9, x, x, a]);
                                           2  3
          (%o6)                       144 a  x

     Divisão e exponenciação são operadores binários e não comutativos.
     Os nomes desses operadores são '"/"' e '"^"'.

          (%i1) [a / b, a ^ b];
                                        a   b
          (%o1)                        [-, a ]
                                        b
          (%i2) [map (op, %), map (args, %)];
          (%o2)              [[/, ^], [[a, b], [a, b]]]
          (%i3) [apply ("/", [a, b]), apply ("^", [a, b])];
                                        a   b
          (%o3)                        [-, a ]
                                        b

     Subtração e divisão são representados internamente em termos de
     adição e multiplicação, respectivamente.

          (%i1) [inpart (a - b, 0), inpart (a - b, 1), inpart (a - b, 2)];
          (%o1)                      [+, a, - b]
          (%i2) [inpart (a / b, 0), inpart (a / b, 1), inpart (a / b, 2)];
                                             1
          (%o2)                       [*, a, -]
                                             b

     Cálculos são realizados sobre números lterais.  A propagação de
     números em poto flutuante aplica-se.

          (%i1) 17 + b - (1/2)*29 + 11^(2/4);
                                                 5
          (%o1)                   b + sqrt(11) + -
                                                 2
          (%i2) [17 + 29, 17 + 29.0, 17 + 29b0];
          (%o2)                   [46, 46.0, 4.6b1]

     Computações aritméticas são uma simplificação, não uma avaliação.

          (%i1) simp : false;
          (%o1)                         false
          (%i2) '(17 + 29*11/7 - 5^3);
                                        29 11    3
          (%o2)                    17 + ----- - 5
                                          7
          (%i3) simp : true;
          (%o3)                         true
          (%i4) '(17 + 29*11/7 - 5^3);
                                          437
          (%o4)                         - ---
                                           7

     A aritmética é realizada elemento-por-elemento para listas lists
     (dependendo de 'listarith') e dependendo de matrizes.

          (%i1) matrix ([a, x], [h, u]) - matrix ([1, 2], [3, 4]);
                                  [ a - 1  x - 2 ]
          (%o1)                   [              ]
                                  [ h - 3  u - 4 ]
          (%i2) 5 * matrix ([a, x], [h, u]);
                                    [ 5 a  5 x ]
          (%o2)                     [          ]
                                    [ 5 h  5 u ]
          (%i3) listarith : false;
          (%o3)                         false
          (%i4) [a, c, m, t] / [1, 7, 2, 9];
                                    [a, c, m, t]
          (%o4)                     ------------
                                    [1, 7, 2, 9]
          (%i5) [a, c, m, t] ^ x;
                                                x
          (%o5)                     [a, c, m, t]
          (%i6) listarith : true;
          (%o6)                         true
          (%i7) [a, c, m, t] / [1, 7, 2, 9];
                                        c  m  t
          (%o7)                     [a, -, -, -]
                                        7  2  9
          (%i8) [a, c, m, t] ^ x;
                                    x   x   x   x
          (%o8)                   [a , c , m , t ]

 -- Operador: **

     Operador de exponenciação.  Maxima reconhece '**' como o mesmo
     operador que '^' em entrada, e '**' é mostrado como '^' em saída
     unidimensional, ou colocando o expoente como sobrescrito em saída
     bidimensional.

     A função 'fortran' mostra o operador de exponenciação com como
     '**', independente de a entrada ter sido na forma '**' ou a forma
     '^'.

     Exemplos:

          (%i1) is (a**b = a^b);
          (%o1)                         true
          (%i2) x**y + x^z;
                                        z    y
          (%o2)                        x  + x
          (%i3) string (x**y + x^z);
          (%o3)                        x^z+x^y
          (%i4) fortran (x**y + x^z);
                x**z+x**y
          (%o4)                         done


File: maxima.info,  Node: Operadores Relacionais,  Next: Operadores Geral,  Prev: Operadores Aritméticos,  Up: Operadores

5.6 Operadores Relacionais
==========================

 -- Operador: <
 -- Operador: <=
 -- Operador: >=
 -- Operador: >


File: maxima.info,  Node: Operadores Geral,  Prev: Operadores Relacionais,  Up: Operadores

5.7 Operadores Geral
====================

 -- Operador: ^^

 -- Operador: !
     O operador fatorial.  Para qualquer número complexo 'x' (incluíndo
     números inteiros, racionais, e reais) exceto para inteiros
     negativos, 'x!' é definido como 'gamma(x+1)'.

     Para um inteiro 'x', 'x!' simplifica para o produto de inteiros de
     1 a 'x' inclusive.  '0!' simplifica para 1.  Para um número em
     ponto flutuante 'x', 'x!' simplifica para o valor de 'gamma (x+1)'.
     Para 'x' igual a 'n/2' onde 'n' é um inteiro ímpar, 'x!' simplifica
     para um fator racional vezes 'sqrt (%pi)' (uma vez que 'gamma
     (1/2)' é igual a 'sqrt (%pi)').  Se 'x' for qualquer outra coisa,
     'x!' não é simplificado.

     As variáveis 'factlim', 'minfactorial', e 'factcomb' controlam a
     simplificação de expressões contendo fatoriais.

     As funções 'gamma', 'bffac', e 'cbffac' são variedades da função
     'gamma'.  'makegamma' substitui 'gamma' para funções relacionadas a
     fatoriais.

     Veja também 'binomial'.

     O fatorial de um inteiro, inteiro dividido por dois, ou argumento
     em ponto flutuante é simplificado a menos que o operando seja maior
     que 'factlim'.

          (%i1) factlim : 10;
          (%o1)                          10
          (%i2) [0!, (7/2)!, 4.77!, 8!, 20!];
          +            105 sqrt(%pi)
          +(%o2)   [1, -------------, 81.44668037931199, 40320, 20!]
          +                 16

     O fatorial de um número complexo, constante conhecida, ou expressão
     geral não é simplificado.  Ainda assim pode ser possível
     simplificar o fatorial após avaliar o operando.

          (%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
          (%o1)      [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
          (%i2) ev (%, numer, %enumer);
          (%o2) [(%i + 1)!, 7.188082728976037, 4.260820476357,
                                                         1.227580202486819]

     O fatorial de um símbolo não associado não é simplificado.

          (%i1) kill (foo);
          (%o1)                         done
          (%i2) foo!;
          (%o2)                         foo!

     Fatoriais são simplificados, não avaliados.  Dessa forma 'x!' pode
     ser substituído mesmo em uma expressão com apóstrofo.

          (%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
                    105 sqrt(%pi)
          (%o1) [1, -------------, 81.44668037931199, 40320,
                         16
                                                       2432902008176640000]

 -- Operador: !!
     O operador de duplo fatorial.

     Para um número inteiro, número em ponto flutuante, ou número
     racional 'n', 'n!!' avalia para o produto 'n (n-2) (n-4) (n-6) ...
     (n - 2 (k-1))' onde 'k' é igual a 'entier (n/2)', que é, o maior
     inteiro menor que ou igual a 'n/2'.  Note que essa definição não
     coincide com outras definições publicadas para argumentos que não
     são inteiros.

     Para um inteiro par (ou ímpar) 'n', 'n!!' avalia para o produto de
     todos os inteiros consecutivos pares (ou ímpares) de 2 (ou 1) até
     'n' inclusive.

     Para um argumento 'n' que não é um número inteiro, um número em
     ponto flutuante, ou um número racional, 'n!!' retorna uma forma
     substantiva 'genfact (n, n/2, 2)'.

 -- Operador: #
     Representa a negação da igualdade sintática '='.

     Note que pelo fato de as regras de avaliação de expressões
     predicadas (em particular pelo fato de 'not <expr>' fazer com que
     ocorra a avaliação de <expr>), a forma 'not <a> = <b>' não é
     equivalente à forma '<a> # <b>' em alguns casos.

     Note que devido às regras para avaliação de expressões predicadas
     (em particular devido a 'not <expr>' fazer com que a avaliação de
     <expr> ocorra), 'not <a> = <b>' é equivalente a 'is(<a> # <b>)', em
     lugar de ser equivalente a '<a> # <b>'.

     Exemplos:
          (%i1) a = b;
          (%o1)                         a = b
          (%i2) é (a = b);
          (%o2)                         false
          (%i3) a # b;
          (%o3)                         a # b
          (%i4) not a = b;
          (%o4)                         true
          (%i5) é (a # b);
          (%o5)                         true
          (%i6) é (not a = b);
          (%o6)                         true

 -- Operador: .
     O operador ponto, para multiplicação (não comutativa) de matrizes.
     Quando "."  é usado com essa finalidade, espaços devem ser
     colocados em ambos os lados desse operador, e.g.  A .  B. Isso
     distingüe o operador ponto plenamente de um ponto decimal em um
     número em ponto flutuante.

     Veja também 'dot', 'dot0nscsimp', 'dot0simp', 'dot1simp',
     'dotassoc', 'dotconstrules', 'dotdistrib', 'dotexptsimp',
     'dotident', e 'dotscrules'.

 -- Operador: :
     O operador de atribuição.  E.g.  A:3 escolhe a variável A para 3.

 -- Operador: ::
     Operador de atribuição.  :: atribui o valor da expressão em seu
     lado direito para o valor da quantidade na sua esquerda, que pode
     avaliar para uma variável atômica ou variável subscrita.

 -- Operador: ::=
     Operador de definição de função de macro.  '::=' define uma função
     (chamada uma "macro" por razões históricas) que coloca um apóstrofo
     em seus argumentos (evitando avaliação), e a expressão que é
     retornada (chamada a "expansão de macro") é avaliada no contexto a
     partir do qual a macro foi chamada.  Uma função de macro é de outra
     forma o mesmo que uma função comum.

     'macroexpand' retorna uma expansão de macro (sem avaliar a
     expansão).  'macroexpand (foo (x))' seguida por '''%' é equivalente
     a 'foo (x)' quando 'foo' for uma função de macro.

     '::=' coloca o nome da nova função de macro dentro da lista global
     'macros'.  'kill', 'remove', e 'remfunction' desassocia definições
     de função de macro e remove nomes de 'macros'.

     'fundef' e 'dispfun' retornam respectivamente uma definição de
     função de macro e uma atribuição dessa definição a um rótulo,
     respectivamente.

     Funções de macro comumente possuem expressões 'buildq' e 'splice'
     para construir uma expressão, que é então avaliada.

     Exemplos

     Uma função de macro coloca um apóstrofo em seus argumentos evitando
     então a avaliação, então mensagem (1) mostra 'y - z', não o valor
     de 'y - z'.  A expansão de macro (a expressão com apóstrofo
     ''(print ("(2) x is equal to", x))' é avaliada no contexto a partir
     do qual a macro for chamada, mostrando a mensagem (2).

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) printq1 (x) ::= block (print ("(1) x é igual a", x), '(print ("(2) x é igual a", x)));
          (%o4) printq1(x) ::= block(print("(1) x é igual a", x),
                                          '(print("(2) x é igual a", x)))
          (%i5) printq1 (y - z);
          (1) x é igual a y - z
          (2) x é igual a %pi
          (%o5)                          %pi

     Uma função comum avalia seus argumentos, então message (1) mostra o
     valor de 'y - z'.  O valor de retorno não é avaliado, então
     mensagem (2) não é mostrada até a avaliação explícita '''%'.

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) printe1 (x) := block (print ("(1) x é igual a", x), '(print ("(2) x é igual a", x)));
          (%o4) printe1(x) := block(print("(1) x é igual a", x),
                                          '(print("(2) x é igual a", x)))
          (%i5) printe1 (y - z);
          (1) x é igual a 1234 - 1729 w
          (%o5)              print((2) x é igual a, x)
          (%i6) ''%;
          (2) x é igual a %pi
          (%o6)                          %pi

     'macroexpand' retorna uma expansão de macro.  'macroexpand (foo
     (x))' seguido por '''%' é equivalente a 'foo (x)' quando 'foo' for
     uma função de macro.

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) g (x) ::= buildq ([x], print ("x é igual a", x));
          (%o4)    g(x) ::= buildq([x], print("x é igual a", x))
          (%i5) macroexpand (g (y - z));
          (%o5)              print(x é igual a, y - z)
          (%i6) ''%;
          x é igual a 1234 - 1729 w
          (%o6)                     1234 - 1729 w
          (%i7) g (y - z);
          x é igual a 1234 - 1729 w
          (%o7)                     1234 - 1729 w

 -- Operador: :=
     O operador de definição de função.  E.g.  'f(x):=sin(x)' define uma
     função 'f'.

 -- Operador: =
     O operador de equação.

     Uma expressão '<a> = <b>', por si mesma, representa uma equação não
     avaliada, a qual pode ou não se manter.  Equações não avaliadas
     podem aparecer como argumentos para 'solve' e 'algsys' ou algumas
     outras funções.

     A função 'is' avalia '=' para um valor Booleano.  'is(<a> = <b>)'
     avalia '<a> = <b>' para 'true' quando <a> e <b> forem idênticos.
     Isto é, <a> e <b> forem átomos que são idênticos, ou se eles não
     forem átomos e seus operadores forem idênticos e seus argumentos
     forem idênticos.  De outra forma, 'is(<a> = <b>)' avalia para
     'false'; 'is(<a> = <b>)' nunca avalia para 'unknown'.  Quando
     'is(<a> = <b>)' for 'true', <a> e <b> são ditos para serem
     sintaticamente iguais, em contraste para serem expressões
     equivalentes, para as quais 'is(equal(<a>, <b>))' é 'true'.
     Expressões podem ser equivalentes e não sintáticamente iguais.

     A negação de '=' é representada por '#'.  Da mesma forma que com
     '=', uma expressão '<a> # <b>', por si mesma, não é avaliada.
     'is(<a> # <b>)' avalia '<a> # <b>' para 'true' ou 'false'.

     Complementando a função 'is', alguns outros operadores avaliam '='
     e '#' para 'true' ou 'false', a saber 'if', 'and', 'or', e 'not'.

     Note que pelo fato de as regras de avaliação de expressões
     predicadas (em particular pelo fato de 'not <expr>' fazer com que
     ocorra a avaliação de <expr>), a forma 'not <a> = <b>' é
     equivalente a 'is(<a> # <b>)', em lugar de ser equivalente a '<a> #
     <b>'.

     'rhs' e 'lhs' retornam o primeiro membro e o segundo membro de uma
     equação, respectivamente, de uma equação ou inequação.

     Veja também 'equal' e 'notequal'.

     Exemplos:

     Uma expressão '<a> = <b>', por si mesma, representa uma equação não
     avaliada, a qual pode ou não se manter.

          (%i1) eq_1 : a * x - 5 * y = 17;
          (%o1)                    a x - 5 y = 17
          (%i2) eq_2 : b * x + 3 * y = 29;
          (%o2)                    3 y + b x = 29
          (%i3) solve ([eq_1, eq_2], [x, y]);
                                  196         29 a - 17 b
          (%o3)          [[x = ---------, y = -----------]]
                               5 b + 3 a       5 b + 3 a
          (%i4) subst (%, [eq_1, eq_2]);
                   196 a     5 (29 a - 17 b)
          (%o4) [--------- - --------------- = 17,
                 5 b + 3 a      5 b + 3 a
                                            196 b     3 (29 a - 17 b)
                                          --------- + --------------- = 29]
                                          5 b + 3 a      5 b + 3 a
          (%i5) ratsimp (%);
          (%o5)                  [17 = 17, 29 = 29]

     'is(<a> = <b>)' avalia '<a> = <b>' para 'true' quando <a> e <b> são
     sintaticamente iguais (isto é, identicos).  Expressões podem ser
     equivalentes e não sintaticamente iguais.

          (%i1) a : (x + 1) * (x - 1);
          (%o1)                    (x - 1) (x + 1)
          (%i2) b : x^2 - 1;
                                        2
          (%o2)                        x  - 1
          (%i3) [is (a = b), is (a # b)];
          (%o3)                     [false, true]
          (%i4) [is (equal (a, b)), is (notequal (a, b))];
          (%o4)                     [true, false]

     Alguns operadores avaliam '=' e '#' para 'true' ou 'false'.

          (%i1) if expand ((x + y)^2) = x^2 + 2 * x * y + y^2 then FOO else BAR;
          (%o1)                          FOO
          (%i2) eq_3 : 2 * x = 3 * x;
          (%o2)                       2 x = 3 x
          (%i3) eq_4 : exp (2) = %e^2;
                                        2     2
          (%o3)                       %e  = %e
          (%i4) [eq_3 and eq_4, eq_3 or eq_4, not eq_3];
          (%o4)                  [false, true, true]

     Devido a 'not <expr>' fazer com que a avaliação de <expr> ocorra,
     'not <a> = <b>' é equivalente a 'is(<a> # <b>)'.

          (%i1) [2 * x # 3 * x, not (2 * x = 3 * x)];
          (%o1)                   [2 x # 3 x, true]
          (%i2) is (2 * x # 3 * x);
          (%o2)                         true

 -- Operador: and
     O operador lógico de conjunção.  'and' é um operador n-ário infixo;
     seus operandos são expressões Booleanas, e seu resultado é um valor
     Booleano.

     'and' força avaliação (como 'is') de um ou mais operandos, e pode
     forçar a avaliação de todos os operandos.

     Operandos são avaliados na ordem em que aparecerem.  'and' avalia
     somente quantos de seus operandos forem necessários para determinar
     o resultado.  Se qualquer operando for 'false', o resultado é
     'false' e os operandos restantes não são avaliados.

     O sinalizador global 'prederror' governa o comportamento de 'and'
     quando um operando avaliado não pode ser determinado como sendo
     'true' ou 'false'.  'and' imprime uma mensagem de erro quando
     'prederror' for 'true'.  De outra forma, operandos que não avaliam
     para 'true' ou para 'false' são aceitos, and o resultado é uma
     expressão Booleana.

     'and' não é comutativo: 'a and b' pode não ser igual a 'b and a'
     devido ao tratamento de operandos indeterminados.

 -- Operador: or
     O operador lógico de disjunção.  'or' é um operador n-ário infixo;
     seus operandos são expressões Booleanas, e seu resultado é um valor
     Booleano.

     'or' força avaliação (como 'is') de um ou mais operandos, e pode
     forçar a avaliação de todos os operandos.

     Operandos são avaliados na ordem em que aparecem.  'or' avalia
     somente quantos de seus operandos forem necessários para determinar
     o resultado.  Se qualquer operando for 'true', o resultado é 'true'
     e os operandos restantes não são avaliados.

     O sinalizador global 'prederror' governa o comportamento de 'or'
     quando um operando avaliado não puder ser determinado como sendo
     'true' ou 'false'.  'or' imprime uma mensagem de erro quando
     'prederror' for 'true'.  De outra forma, operandos que não avaliam
     para 'true' ou para 'false' são aceitos, E o resultado é uma
     expressão Booleana.

     'or' não é comutativo: 'a or b' pode não ser igual a 'b or a'
     devido ao tratamento de operando indeterminados.

 -- Operador: not
     O operador lógico de negação.  'not' é operador prefixado; Seu
     operando é uma expressão Booleana, e seu resultado é um valor
     Booleano.

     'not' força a avaliação (como 'is') de seu operando.

     O sinalizador global 'prederror' governa o comportamento de 'not'
     quando seu operando não pode ser determinado em termos de 'true' ou
     'false'.  'not' imprime uma mensagem de erro quando 'prederror' for
     'true'.  De outra forma, operandos que não avaliam para 'true' ou
     para 'false' são aceitos, e o resultado é uma expressão Booleana.

 -- Função: abs (<expr>)
     Retorna o valor absoluto de <expr>.  Se <expr> for um número
     complexo, retorna o módulo complexo de <expr>.

 -- Palavra chave: additive
     Se 'declare(f,additive)' tiver sido executado, então:

     (1) Se 'f' for uma função de uma única variável, sempre que o
     simplificador encontrar 'f' aplicada a uma adição, 'f' será
     distribuído sobre aquela adição.  I.e.  'f(y+x)' irá simplificar
     para 'f(y)+f(x)'.

     (2) Se 'f' for uma função de 2 ou mais argumentos, a adição é
     definida como adição no primeiro argumento para 'f', como no caso
     de 'sum' ou 'integrate', i.e.  'f(h(x)+g(x),x)' irá simplificar
     para 'f(h(x),x)+f(g(x),x)'.  Essa simplificação não ocorre quando
     'f' é aplicada para expressões da forma
     'sum(x[i],i,lower-limit,upper-limit)'.

 -- Palavra chave: allbut
     trabalha com os comandos 'part' (i.e.  'part', 'inpart',
     'substpart', 'substinpart', 'dpart', e 'lpart').  Por exemplo,

          (%i1) expr : e + d + c + b + a;
          (%o1)                   e + d + c + b + a
          (%i2) part (expr, [2, 5]);
          (%o2)                         d + a

     enquanto

          (%i1) expr : e + d + c + b + a;
          (%o1)                   e + d + c + b + a
          (%i2) part (expr, allbut (2, 5));
          (%o2)                       e + c + b

     'allbut' é também reconhecido por 'kill'.

          (%i1) [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
          (%o1)                 [11, 22, 33, 44, 55]
          (%i2) kill (allbut (cc, dd));
          (%o0)                         done
          (%i1) [aa, bb, cc, dd];
          (%o1)                   [aa, bb, 33, 44]

     'kill(allbut(<a_1>, <a_2>, ...))' tem o mesmo efeito que
     'kill(all)' exceto que não elimina os símbolos <a_1>, <a_2>, ...  .

 -- Declaração: antisymmetric
     Se 'declare(h,antisymmetric)' é concluída, diz ao simplicador que
     'h' é uma função antisimétrica.  E.g.  'h(x,z,y)' simplificará para
     '- h(x, y, z)'.  Isto é, dará (-1)^n vezes o resultado dado por
     'symmetric' ou 'commutative', quando n for o número de
     interescolhas de dois argumentos necessários para converter isso
     naquela forma.

 -- Função: cabs (<expr>)
     Retorna o valor absoluto complexo (o módulo complexo) de <expr>.

 -- Função: ceiling (<x>)

     Quando <x> for um número real, retorna o último inteiro que é maior
     que ou igual a <x>.

     Se <x> for uma expressão constante ('10 * %pi', por exemplo),
     'ceiling' avalia <x> usando grandes números em ponto flutuante, e
     aplica 'ceiling' para o grande número em ponto flutuante
     resultante.  Porque 'ceiling' usa avaliação de ponto flutuante, é
     possível, embora improvável, que 'ceiling' possa retornar uma valor
     errôneo para entradas constantes.  Para prevenir erros, a avaliação
     de ponto flutuante é concluída usando três valores para 'fpprec'.

     Para entradas não constantes, 'ceiling' tenta retornar um valor
     simplificado.  Aqui está um exemplo de simplificações que 'ceiling'
     conhece:

          (%i1) ceiling (ceiling (x));
          (%o1)                      ceiling(x)
          (%i2) ceiling (floor (x));
          (%o2)                       floor(x)
          (%i3) declare (n, integer)$
          (%i4) [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
          (%o4)                [n, abs(n), max(n, 6)]
          (%i5) assume (x > 0, x < 1)$
          (%i6) ceiling (x);
          (%o6)                           1
          (%i7) tex (ceiling (a));
          $$\left \lceil a \right \rceil$$
          (%o7)                         false

     A função 'ceiling' não mapeia automaticamente sobre listas ou
     matrizes.  Finalmente, para todas as entradas que forem
     manifestamente complexas, 'ceiling' retorna uma forma substantiva.

     Se o intervalo de uma função é um subconjunto dos inteiros, o
     intervalo pode ser declarado 'integervalued'.  Ambas as funções
     'ceiling' e 'floor' podem usar essa informação; por exemplo:

          (%i1) declare (f, integervalued)$
          (%i2) floor (f(x));
          (%o2)                         f(x)
          (%i3) ceiling (f(x) - 1);
          (%o3)                       f(x) - 1

 -- Função: charfun (<p>)

     Retorna 0 quando o predicado <p> avaliar para 'false'; retorna 1
     quando o predicado avaliar para 'true'.  Quando o predicado avaliar
     para alguma coisa que não 'true' ou 'false' ('unknown'), retorna
     uma forma substantiva.

     Exemplos:

          (%i1) charfun (x < 1);
          (%o1)                    charfun(x < 1)
          (%i2) subst (x = -1, %);
          (%o2)                           1
          (%i3) e : charfun ('"and" (-1 < x, x < 1))$
          (%i4) [subst (x = -1, e), subst (x = 0, e), subst (x = 1, e)];
          (%o4)                       [0, 1, 0]

 -- Declaração: commutative
     Se 'declare(h,commutative)' é concluída, diz ao simplicador que 'h'
     é uma função comutativa.  E.g.  'h(x,z,y)' irá simplificar para
     'h(x, y, z)'.  Isto é o mesmo que 'symmetric'.

 -- Função: compare (<x>, <y>)

     Retorna um operador de comparação <op> ('<', '<=', '>', '>=', '=',
     ou '#') tal que 'is (<x> <op> <y>)' avalia para 'true'; quando ou
     <x> ou <y> dependendo de '%i' e '<x> # <y>', retorna
     'notcomparable'; Quando não existir tal operador ou Maxima não
     estiver apto a determinar o operador, retorna 'unknown'.

     Exemplos:

          (%i1) compare (1, 2);
          (%o1)                           <
          (%i2) compare (1, x);
          (%o2)                        unknown
          (%i3) compare (%i, %i);
          (%o3)                           =
          (%i4) compare (%i, %i + 1);
          (%o4)                     notcomparable
          (%i5) compare (1/x, 0);
          (%o5)                           #
          (%i6) compare (x, abs(x));
          (%o6)                          <=

     A função 'compare' não tenta de terminar se o domínio real de seus
     argumentos é não vazio; dessa forma

          (%i1) compare (acos (x^2 + 1), acos (x^2 + 1) + 1);
          (%o1)                           <

     O domínio real de 'acos (x^2 + 1)' é vazio.

 -- Função: entier (<x>)
     Retorna o último inteiro menor que ou igual a <x> onde <x> é
     numérico.  'fix' (como em 'fixnum') é um sinônimo disso, então
     'fix(<x>)' é precisamente o mesmo.

 -- Função: equal (<a>, <b>)

     Representa a equivalência, isto é, valor igual.

     Por si mesma, 'equal' não avalia ou simplifica.  A função 'is'
     tenta avaliar 'equal' para um valor Booleano.  'is(equal(<a>,
     <b>))' retorna 'true' (ou 'false') se e somente se <a> e <b> forem
     iguais (ou não iguais) para todos os possíveis valores de suas
     variáveis, como determinado através da avaliação de 'ratsimp(<a> -
     <b>)'; se 'ratsimp' retornar 0, as duas expressões são consideradas
     equivalentes.  Duas expressões podem ser equivalentes mesmo se
     mesmo se elas não forem sintaticamente iguais (i.e., identicas).

     Quando 'is' falhar em reduzir 'equal' a 'true' ou 'false', o
     resultado é governado através do sinalizador global 'prederror'.
     Quando 'prederror' for 'true', 'is' reclama com uma mensagem de
     erro.  De outra forma, 'is' retorna 'unknown'.

     Complementando 'is', alguns outros operadores avaliam 'equal' e
     'notequal' para 'true' ou 'false', a saber 'if', 'and', 'or', e
     'not'.

     A negação de 'equal' é 'notequal'.

     Exemplos:

     Por si mesmo, 'equal' não avalia ou simplifica.

          (%i1) equal (x^2 - 1, (x + 1) * (x - 1));
                                  2
          (%o1)            equal(x  - 1, (x - 1) (x + 1))
          (%i2) equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) equal (x, y);
          (%o3)                      equal(x, y)

     A função 'is' tenta avaliar 'equal' para um valor Booleano.
     'is(equal(<a>, <b>))' retorna 'true' quando 'ratsimp(<a> - <b>)'
     retornar 0.  Duas expressões podem ser equivalentes mesmo se não
     forem sintaticamente iguais (i.e., identicas).

          (%i1) ratsimp (x^2 - 1 - (x + 1) * (x - 1));
          (%o1)                           0
          (%i2) is (equal (x^2 - 1, (x + 1) * (x - 1)));
          (%o2)                         true
          (%i3) is (x^2 - 1 = (x + 1) * (x - 1));
          (%o3)                         false
          (%i4) ratsimp (x - (x + 1));
          (%o4)                          - 1
          (%i5) is (equal (x, x + 1));
          (%o5)                         false
          (%i6) is (x = x + 1);
          (%o6)                         false
          (%i7) ratsimp (x - y);
          (%o7)                         x - y
          (%i8) is (equal (x, y));
          (%o8)                        unknown
          (%i9) is (x = y);
          (%o9)                         false

     Quando 'is' falha em reduzir 'equal' a 'true' ou 'false', o
     resultado é governado através do sinalizador global 'prederror'.

          (%i1) [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
                              2             2
          (%o1)             [x  + 2 x + 1, x  - 2 x - 1]
          (%i2) ratsimp (aa - bb);
          (%o2)                        4 x + 2
          (%i3) prederror : true;
           (%o3)                         true
          (%i4) is (equal (aa, bb));
          Maxima was unable to evaluate the predicate:
                 2             2
          equal(x  + 2 x + 1, x  - 2 x - 1)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) prederror : false;
          (%o5)                         false
          (%i6) is (equal (aa, bb));
          (%o6)                        unknown

     Alguns operadores avaliam 'equal' e 'notequal' para 'true' ou
     'false'.

          (%i1) if equal (y, y - 1) then FOO else BAR;
          (%o1)                          BAR
          (%i2) eq_1 : equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
                                   2                   2
          (%o3)             equal(y  + 2 y + 1, (y + 1) )
          (%i4) [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
          (%o4)                  [false, true, true]

     Devido a 'not <expr>' fazer com que ocorra a avaliação de <expr>,
     'not equal(<a>, <b>)' é equivalente a 'is(notequal(<a>, <b>))'.

          (%i1) [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
          (%o1)            [notequal(2 z, 2 z - 1), true]
          (%i2) is (notequal (2*z, 2*z - 1));
          (%o2)                         true

 -- Função: floor (<x>)

     Quando <x> for um número real, retorna o maior inteiro que é menor
     que ou igual a <x>.

     Se <x> for uma expressão constante ('10 * %pi', for exemplo),
     'floor' avalia <x> usando grandes números em ponto flutuante, e
     aplica 'floor' ao grande número em ponto flutuante resultante.
     Porque 'floor' usa avaliação em ponto flutuante, é possível, embora
     improvável, que 'floor' não possa retornar um valor errôneo para
     entradas constantes.  Para prevenir erros, a avaliação de ponto
     flutuante é concluída usando três valores para 'fpprec'.

     Para entradas não constantes, 'floor' tenta retornar um valor
     simplificado.  Aqui está exemplos de simplificações que 'floor'
     conhece:

          (%i1) floor (ceiling (x));
          (%o1)                      ceiling(x)
          (%i2) floor (floor (x));
          (%o2)                       floor(x)
          (%i3) declare (n, integer)$
          (%i4) [floor (n), floor (abs (n)), floor (min (n, 6))];
          (%o4)                [n, abs(n), min(n, 6)]
          (%i5) assume (x > 0, x < 1)$
          (%i6) floor (x);
          (%o6)                           0
          (%i7) tex (floor (a));
          $$\left \lfloor a \right \rfloor$$
          (%o7)                         false

     A função 'floor' não mapeia automaticamente sobre listas ou
     matrizes.  Finalmente, para todas as entradas que forem
     manifestamente complexas, 'floor' retorna uma forma substantiva.

     Se o intervalo de uma função for um subconjunto dos inteiros, o
     intervalo pode ser declarado 'integervalued'.  Ambas as funções
     'ceiling' e 'floor' podem usar essa informação; por exemplo:

          (%i1) declare (f, integervalued)$
          (%i2) floor (f(x));
          (%o2)                         f(x)
          (%i3) ceiling (f(x) - 1);
          (%o3)                       f(x) - 1

 -- Função: notequal (<a>, <b>)
     Represents the negation of 'equal(<a>, <b>)'.

     Exemplos:

          (%i1) equal (a, b);
          (%o1)                      equal(a, b)
          (%i2) maybe (equal (a, b));
          (%o2)                        unknown
          (%i3) notequal (a, b);
          (%o3)                    notequal(a, b)
          (%i4) not equal (a, b);
          (%o4)                    notequal(a, b)
          (%i5) maybe (notequal (a, b));
          (%o5)                        unknown
          (%i6) assume (a > b);
          (%o6)                        [a > b]
          (%i7) equal (a, b);
          (%o7)                      equal(a, b)
          (%i8) maybe (equal (a, b));
          (%o8)                         false
          (%i9) notequal (a, b);
          (%o9)                    notequal(a, b)
          (%i10) maybe (notequal (a, b));
          (%o10)                        true

 -- Operador: eval
     Como um argumento em uma chamada a 'ev (<expr>)', 'eval' causa uma
     avaliação extra de <expr>.  Veja 'ev'.

 -- Função: evenp (<expr>)
     Retorna 'true' se <expr> for um inteiro sempre.  'false' é
     retornado em todos os outros casos.

 -- Função: fix (<x>)
     Um sinônimo para 'entier (<x>)'.

 -- Função: fullmap (<f>, <expr_1>, ...)
     Similar a 'map', mas 'fullmap' mantém mapeadas para baixo todas as
     subexpressões até que os operadores principais não mais sejam os
     mesmos.

     'fullmap' é usada pelo simplificador do Maxima para certas
     manipulações de matrizes; dessa forma, Maxima algumas vezes gera
     uma mensagem de erro concernente a 'fullmap' mesmo apesar de
     'fullmap' não ter sido explicitamente chamada pelo usuário.

     Exemplos:

          (%i1) a + b * c;
          (%o1)                        b c + a
          (%i2) fullmap (g, %);
          (%o2)                   g(b) g(c) + g(a)
          (%i3) map (g, %th(2));
          (%o3)                     g(b c) + g(a)

 -- Função: fullmapl (<f>, <list_1>, ...)
     Similar a 'fullmap', mas 'fullmapl' somente mapeia sobre listas e
     matrizes.

     Exemplo:

          (%i1) fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
          (%o1)                [[a + 3, 4], [4, 3.5]]

 -- Função: is (<expr>)
     Tenta determinar se a <expr> predicada (expressões que avaliam para
     'true' ou 'false') é dedutível de fatos localizados na base de
     dados de 'assume'.

     Se a dedutibilidade do predicado for 'true' ou 'false', 'is'
     retorna 'true' ou 'false', respectivamente.  De outra forma, o
     valor de retorno é governado através do sinalizador global
     'prederror'.  Quando 'prederror' for 'true', 'is' reclama com uma
     mensagem de erro.  De outra forma, 'is' retorna 'unknown'.

     'ev(<expr>, pred)' (que pode ser escrita da forma '<expr>, pred' na
     linha de comando interativa) é equivalente a 'is(<expr>)'.

     Veja também 'assume', 'facts', e 'maybe'.

     Exemplos:

     'is' causa avaliação de predicados.

          (%i1) %pi > %e;
          (%o1)                       %pi > %e
          (%i2) é (%pi > %e);
          (%o2)                         true

     'is' tenta derivar predicados da base de dados do 'assume'.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) assume (b > c);
          (%o2)                        [b > c]
          (%i3) é (a < b);
          (%o3)                         false
          (%i4) é (a > c);
          (%o4)                         true
          (%i5) é (equal (a, c));
          (%o5)                         false

     Se 'is' não puder nem comprovar nem refutar uma forma predicada a
     partir da base de dados de 'assume', o sinalizador global
     'prederror' governa o comportamento de 'is'.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) prederror: true$
          (%i3) é (a > 0);
          Maxima was unable to evaluate the predicate:
          a > 0
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) prederror: false$
          (%i5) é (a > 0);
          (%o5)                        unknown

 -- Função: maybe (<expr>)
     Tenta determinar se a <expr> predicada é dedutível dos fatos na
     base de dados de 'assume'.

     Se a dedutibilidade do predicado for 'true' ou 'false', 'maybe'
     retorna 'true' ou 'false', respectivamente.  De outra forma,
     'maybe' retorna 'unknown'.

     'maybe' é funcinalmente equivalente a 'is' com 'prederror: false',
     mas o resultado é computado sem atualmente atribuir um valor a
     'prederror'.

     Veja também 'assume', 'facts', e 'is'.

     Exemplos:

          (%i1) maybe (x > 0);
          (%o1)                        unknown
          (%i2) assume (x > 1);
          (%o2)                        [x > 1]
          (%i3) maybe (x > 0);
          (%o3)                         true

 -- Função: isqrt (<x>)
     Retorna o "inteiro raíz quadrada" do valor absoluto de <x>, que é
     um inteiro.

 -- Função: lmax (<L>)

     Quando <L> for uma lista ou um conjunto, retorna 'apply ('max, args
     (<L>))'.  Quando <L> não for uma lista ou também não for um
     conjunto, sinaliza um erro.

 -- Função: lmin (<L>)

     Quando <L> for uma lista ou um conjunto, retorna 'apply ('min, args
     (<L>))'.  Quando <L> não for uma lista ou ou também não for um
     conjunto, sinaliza um erro.

 -- Função: max (<x_1>, ..., <x_n>)

     Retorna um valor simplificado para o máximo entre as expressões
     <x_1> a <x_n>.  Quando 'get (trylevel, maxmin)', for dois ou mais,
     'max' usa a simplificação 'max (e, -e) --> |e|'.  Quando 'get
     (trylevel, maxmin)' for 3 ou mais, <max> tenta eliminar expressões
     que estiverem entre dois outros argumentos; por exemplo, 'max (x,
     2*x, 3*x) --> max (x, 3*x)'.  Para escolher o valor de 'trylevel'
     para 2, use 'put (trylevel, 2, maxmin)'.

 -- Função: min (<x_1>, ..., <x_n>)

     Retorna um valor simplificado para o mínimo entre as expressões
     'x_1' até 'x_n'.  Quando 'get (trylevel, maxmin)', for 2 ou mais,
     'min' usa a simplificação 'min (e, -e) --> -|e|'.  Quando 'get
     (trylevel, maxmin)' for 3 ou mais, 'min' tenta eliminar expressões
     que estiverem entre dois outros argumentos; por exemplo, 'min (x,
     2*x, 3*x) --> min (x, 3*x)'.  Para escolher o valor de 'trylevel'
     para 2, use 'put (trylevel, 2, maxmin)'.

 -- Função: polymod (<p>)
 -- Função: polymod (<p>, <m>)
     Converte o polinômio <p> para uma representação modular com relação
     ao módulo corrente que é o valor da variável 'modulus'.

     'polymod (<p>, <m>)' especifica um módulo <m> para ser usado em
     lugar do valor corrente de 'modulus'.

     Veja 'modulus'.

 -- Função: mod (<x>, <y>)

     Se <x> e <y> forem números reais e <y> for não nulo, retorna '<x> -
     <y> * floor(<x> / <y>)'.  Adicionalmente para todo real <x>, nós
     temos 'mod (<x>, 0) = <x>'.  Para uma discursão da definição 'mod
     (<x>, 0) = <x>', veja a Seção 3.4, de "Concrete Mathematics," por
     Graham, Knuth, e Patashnik.  A função 'mod (<x>, 1)' é uma função
     dente de serra com período 1 e com 'mod (1, 1) = 0' e 'mod (0, 1) =
     0'.

     Para encontrar o argumento (um número no intervalo '(-%pi, %pi]')
     de um número complexo, use a função '<x> |-> %pi - mod (%pi - <x>,
     2*%pi)', onde <x> é um argumento.

     Quando <x> e <y> forem expressões constantes ('10 * %pi', por
     exemplo), 'mod' usa o mesmo esquema de avaliação em ponto flutuante
     que 'floor' e 'ceiling' usam.  Novamente, é possível, embora
     improvável, que 'mod' possa retornar um valor errôneo nesses casos.

     Para argumentos não numéricos <x> ou <y>, 'mod 'conhece muitas
     regras de simplificação:

          (%i1) mod (x, 0);
          (%o1)                           x
          (%i2) mod (a*x, a*y);
          (%o2)                      a mod(x, y)
          (%i3) mod (0, x);
          (%o3)                           0

 -- Função: oddp (<expr>)
     é 'true' se <expr> for um inteiro ímpar.  'false' é retornado em
     todos os outros casos.

 -- Operador: pred
     Como um argumento em uma chamada a 'ev (<expr>)', 'pred' faz com
     que predicados (expressões que avaliam para 'true' ou 'false')
     sejam avaliados.  Veja 'ev'.

 -- Função: make_random_state (<n>)
 -- Função: make_random_state (<s>)
 -- Função: make_random_state (true)
 -- Função: make_random_state (false)
     Um objeto de estado randômico representa o estado do gerador de
     números randômicos (aleatórios).  O estado compreende 627 palavras
     de 32 bits.

     'make_random_state (<n>)' retorna um novo objeto de estado
     randômico criado de um valor inteiro semente igual a <n> modulo
     2^32.  <n> pode ser negativo.

     'make_random_state (<s>)' retorna uma copia do estado randômico
     <s>.

     'make_random_state (true)' retorna um novo objeto de estado
     randômico, usando a hora corrente do relógio do computador como
     semente.

     'make_random_state (false)' retorna uma cópia do estado corrente do
     gerador de números randômicos.

 -- Função: set_random_state (<s>)
     Copia <s> para o estado do gerador de números randômicos.

     'set_random_state' sempre retorna 'done'.

 -- Função: random (<x>)
     Retorna um número pseudorandômico.  Se <x> é um inteiro, 'random
     (<x>)' retorna um inteiro de 0 a '<x> - 1' inclusive.  Se <x> for
     um número em ponto flutuante, 'random (<x>)' retorna um número não
     negativo em ponto flutuante menor que <x>.  'random' reclama com um
     erro se <x> não for nem um inteiro nem um número em ponto
     flutuante, ou se <x> não for positivo.

     As funções 'make_random_state' e 'set_random_state' mantém o estado
     do gerador de números randômicos.

     O gerador de números randômicos do Maxima é uma implementação do
     algorítmo de Mersenne twister MT 19937.

     Exemplos:

          (%i1) s1: make_random_state (654321)$
          (%i2) set_random_state (s1);
          (%o2)                         done
          (%i3) random (1000);
          (%o3)                          768
          (%i4) random (9573684);
          (%o4)                        7657880
          (%i5) random (2^75);
          (%o5)                11804491615036831636390
          (%i6) s2: make_random_state (false)$
          (%i7) random (1.0);
          (%o7)                   .2310127244107132
          (%i8) random (10.0);
          (%o8)                   4.394553645870825
          (%i9) random (100.0);
          (%o9)                   32.28666704056853
          (%i10) set_random_state (s2);
          (%o10)                        done
          (%i11) random (1.0);
          (%o11)                  .2310127244107132
          (%i12) random (10.0);
          (%o12)                  4.394553645870825
          (%i13) random (100.0);
          (%o13)                  32.28666704056853

 -- Função: rationalize (<expr>)

     Converte todos os números em ponto flutuante de precisão dupla e
     grandes números em ponto flutuante na expressão do Maxima <expr>
     para seus exatos equivalentes racionais.  Se você não estiver
     faminilarizado com a representação binária de números em ponto
     flutuante, você pode se surpreender que 'rationalize (0.1)' não
     seja igual a 1/10.  Esse comportamento não é especial para o Maxima
     - o número 1/10 tem uma representação binária repetitiva e não
     terminada.

          (%i1) rationalize (0.5);
                                          1
          (%o1)                           -
                                          2
          (%i2) rationalize (0.1);
                                         1
          (%o2)                          --
                                         10
           (%i3) fpprec : 5$
          (%i4) rationalize (0.1b0);
                                       209715
          (%o4)                        -------
                                       2097152
          (%i5) fpprec : 20$
          (%i6) rationalize (0.1b0);
                               236118324143482260685
          (%o6)                ----------------------
                               2361183241434822606848
          (%i7) rationalize (sin (0.1*x + 5.6));
                                        x    28
          (%o7)                     sin(-- + --)
                                        10   5

     Exemplo de utilização:

          (%i1) unitfrac(r) := block([uf : [], q],
              if not(ratnump(r)) then error("The input to 'unitfrac' must be a rational number"),
              while r # 0 do (
                  uf : cons(q : 1/ceiling(1/r), uf),
                  r : r - q),
              reverse(uf));
          (%o1) unitfrac(r) := block([uf : [], q],
          if not ratnump(r) then error("The input to 'unitfrac' must be a rational number"
                                               1
          ), while r # 0 do (uf : cons(q : ----------, uf), r : r - q),
                                                   1
                                           ceiling(-)
                                                   r
          reverse(uf))
          (%i2) unitfrac (9/10);
                                      1  1  1
          (%o2)                      [-, -, --]
                                      2  3  15
          (%i3) apply ("+", %);
                                         9
          (%o3)                          --
                                         10
          (%i4) unitfrac (-9/10);
                                            1
          (%o4)                       [- 1, --]
                                            10
          (%i5) apply ("+", %);
                                          9
          (%o5)                         - --
                                          10
          (%i6) unitfrac (36/37);
                                  1  1  1  1    1
          (%o6)                  [-, -, -, --, ----]
                                  2  3  8  69  6808
          (%i7) apply ("+", %);
                                         36
          (%o7)                          --
                                         37

 -- Função: sign (<expr>)
     Tenta determinar o sinal de <expr> a partir dos fatos na base de
     dados corrente.  Retorna uma das seguintes respostar: 'pos'
     (positivo), 'neg' (negativo), 'zero', 'pz' (positivo ou zero), 'nz'
     (negativo ou zero), 'pn' (positivo ou negativo), ou 'pnz'
     (positivo, negativo, ou zero, i.e.  nada se sabe sobre o sinal da
     epressão).

 -- Função: signum (<x>)
     Para um <x> numérico retorna 0 se <x> for 0, de outra forma retorna
     -1 ou +1 à medida que <x> seja menor ou maior que 0,
     respectivamente.

     Se <x> não for numérico então uma forma simplificada mas
     equivalente é retornada.  Por exemplo, 'signum(-x)' fornece
     '-signum(x)'.

 -- Função: sort (<L>, <P>)
 -- Função: sort (<L>)
     Organiza uma lista <L> coforme o predicado 'P' de dois argumentos,
     de forma que '<P> (<L>[k], <L>[k + 1])' seja 'true' para qualquer
     dois elementos sucessivos.  O predicado pode ser especificado como
     o nome de uma função ou operador binário infixo, ou como uma
     expressão 'lambda'.  Se especificado como o nome de um operador, o
     nome deve ser contido entre "aspas duplas".

     A lista ordenada é retornada como novo objeto; o argumento <L> não
     é modificado.  Para construir o valor de retorno, 'sort' faz uma
     cópia superficial dos elementos de <L>.  Se o predicado <P> não for
     uma ordem total sobre os elementos de <L>, então 'sort'
     possivelvente pode executar para concluir sem error, mas os
     resultados são indefinidos.  'sort' reclama se o predicado avaliar
     para alguma outra coisa que não seja 'true' ou 'false'.

     'sort (<L>)' é equivalente a 'sort (<L>, orderlessp)'.  Isto é, a
     ordem padrão de organização é ascendente, como determinado por
     'orderlessp'.  Todos os átomos do Maxima e expressões são
     comparáveis sob 'orderlessp', embora exista exemplos isolados de
     expressões para as quais 'orderlessp' não é transitiva; isso é uma
     falha.

     Exemplos:

          (%i1) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x]);
                         5
          (%o1) [- 17, - -, 3, 7.55, 11, 2.9b1, b + a, 9 c, 19 - 3 x]
                         2
          (%i2) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x], ordergreatp);
                                                             5
          (%o2) [19 - 3 x, 9 c, b + a, 2.9b1, 11, 7.55, 3, - -, - 17]
                                                             2
          (%i3) sort ([%pi, 3, 4, %e, %gamma]);
          (%o3)                [3, 4, %e, %gamma, %pi]
          (%i4) sort ([%pi, 3, 4, %e, %gamma], "<");
          (%o4)                [%gamma, %e, 3, %pi, 4]
          (%i5) my_list : [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]];
          (%o5) [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]]
          (%i6) sort (my_list);
          (%o6) [[%pi, %e], [aa, hh, uu], [ee, cc], [zz, xx, mm, cc]]
          (%i7) sort (my_list, lambda ([a, b], orderlessp (reverse (a), reverse (b))));
          (%o7) [[%pi, %e], [ee, cc], [zz, xx, mm, cc], [aa, hh, uu]]

 -- Função: sqrt (<x>)
     A raíz quadrada de <x>.  É representada internamente por
     '<x>^(1/2)'.  Veja também 'rootscontract'.

     'radexpand' se 'true' fará com que n-ésimas raízes de fatores de um
     produto que forem potências de n sejam colocados fora do radical,
     e.g.  'sqrt(16*x^2)' retonará '4*x' somente se 'radexpand' for
     'true'.

 -- Variável de opção: sqrtdispflag
     Valor padrão: 'true'

     Quando 'sqrtdispflag' for 'false', faz com que 'sqrt' seja mostrado
     como expoente 1/2.

 -- Função: sublis (<lista>, <expr>)
     Faz multiplas substituições paralelas dentro de uma expressão.

     A variável 'sublis_apply_lambda' controla a simplificação após
     'sublis'.

     Exemplo:

 -- Função: sublist (<lista>, <p>)
     Retorna a lista de elementos da <lista> da qual o predicado 'p'
     retornar 'true'.

     Exemplo:

          (%i1) L: [1, 2, 3, 4, 5, 6];
          (%o1)                  [1, 2, 3, 4, 5, 6]
          (%i2) sublist (L, evenp);
          (%o2)                       [2, 4, 6]

 -- Variável de opção: sublis_apply_lambda
     Valor padrão: 'true' - controla se os substitutos de 'lambda' são
     aplicados na simplificação após as 'sublis' serem usadas ou se você
     tem que fazer um 'ev' para pegar coisas para aplicar.  'true'
     significa faça a aplicação.

 -- Função: subst (<a>, <b>, <c>)
     Substitue <a> por <b> em <c>.  <b> deve ser um átomo ou uma
     subexpressão completa de <c>.  Por exemplo, 'x+y+z' é uma
     subexpressão completa de '2*(x+y+z)/w' enquanto 'x+y' não é.
     Quando <b> não tem essas características, pode-se algumas vezes
     usar 'substpart' ou 'ratsubst' (veja abaixo).  Alternativamente, se
     <b> for da forma de 'e/f' então se poderá usar 'subst (a*f, e, c)'
     enquanto se <b> for da forma 'e^(1/f)' então se poderá usar 'subst
     (a^f, e, c)'.  O comando 'subst' também discerne o 'x^y' de 'x^-y'
     de modo que 'subst (a, sqrt(x), 1/sqrt(x))' retorna '1/a'.  <a> e
     <b> podem também ser operadores de uma expressão contida entre
     aspas duplas '"' ou eles podem ser nomes de função.  Se se desejar
     substituir por uma variável independente em formas derivadas então
     a função 'at' (veja abaixo) poderá ser usada.

     'subst' é um álias para 'substitute'.

     'subst (<eq_1>, <expr>)' ou 'subst ([<eq_1>, ..., <eq_k>], <expr>)'
     são outras formas permitidas.  As <eq_i> são equações indicando
     substituições a serem feitas.  Para cada equação, o lado direito
     será substituído pelo lado esquerdo na expressão <expr>.

     'exptsubst' se 'true' permite que substituições como 'y' por '%e^x'
     em '%e^(a*x)' ocorram.

     Quando 'opsubst' for 'false', 'subst' tentará substituir dentro do
     operador de uma expressão.  E.g.  '(opsubst: false, subst (x^2, r,
     r+r[0]))' trabalhará.

     Exemplos:

          (%i1) subst (a, x+y, x + (x+y)^2 + y);
                                              2
          (%o1)                      y + x + a
          (%i2) subst (-%i, %i, a + b*%i);
          (%o2)                       a - %i b

     Para exemplos adicionais, faça 'example (subst)'.

 -- Função: substinpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Similar a 'substpart', mas 'substinpart' trabalha sobre a
     representação interna de <expr>.

     Exemplos:

          (%i1) x . 'diff (f(x), x, 2);
                                        2
                                       d
          (%o1)                   x . (--- (f(x)))
                                         2
                                       dx
          (%i2) substinpart (d^2, %, 2);
                                            2
          (%o2)                        x . d
          (%i3) substinpart (f1, f[1](x + 1), 0);
          (%o3)                       f1(x + 1)

     Se o último argumento para a função 'part' for uma lista de índices
     então muitas subexpressões são escolhidas, cada uma correspondendo
     a um índice da lista.  Dessa forma

          (%i1) part (x + y + z, [1, 3]);
          (%o1)                         z + x

     'piece' recebe o valor da última expressão selecionada quando
     usando as funções 'part'.  'piece' é escolhida durante a execução
     da função e dessa forma pode ser referenciada para a própria função
     como mostrado abaixo.  Se 'partswitch' for escolhida para 'true'
     então 'end' é retornado quando uma parte selecionada de uma
     expressão não existir, de outra forma uma mensagem de erro é
     fornecida.

          (%i1) expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
                        3         2       2            3
          (%o1)     27 y  + 54 x y  + 36 x  y + y + 8 x  + x + 1
          (%i2) part (expr, 2, [1, 3]);
                                            2
          (%o2)                         54 y
          (%i3) sqrt (piece/54);
          (%o3)                        abs(y)
          (%i4) substpart (factor (piece), expr, [1, 2, 3, 5]);
                                         3
          (%o4)               (3 y + 2 x)  + y + x + 1
          (%i5) expr: 1/x + y/x - 1/z;
                                       1   y   1
          (%o5)                      - - + - + -
                                       z   x   x
          (%i6) substpart (xthru (piece), expr, [2, 3]);
                                      y + 1   1
          (%o6)                       ----- - -
                                        x     z

     Também, escolhendo a opção 'inflag' para 'true' e chamando 'part'
     ou 'substpart' é o mesmo que chamando 'inpart' ou 'substinpart'.

 -- Função: substpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Substitue <x> para a subexpressão selecionada pelo resto dos
     argumentos como em 'part'.  Isso retorna o novo valor de <expr>.
     <x> pode ser algum operador a ser substituído por um operador de
     <expr>.  Em alguns casos <x> precisa ser contido em aspas duplas
     '"' (e.g.  'substpart ("+", a*b, 0)' retorna 'b + a').

          (%i1) 1/(x^2 + 2);
                                         1
          (%o1)                        ------
                                        2
                                       x  + 2
          (%i2) substpart (3/2, %, 2, 1, 2);
                                         1
          (%o2)                       --------
                                       3/2
                                      x    + 2
          (%i3) a*x + f (b, y);
          (%o3)                     a x + f(b, y)
          (%i4) substpart ("+", %, 1, 0);
          (%o4)                    x + f(b, y) + a

     Também, escolhendo a opção 'inflag' para 'true' e chamando 'part'
     ou 'substpart' é o mesmo que chamando 'inpart' ou 'substinpart'.

 -- Função: subvarp (<expr>)
     Retorna 'true' se <expr> for uma variável subscrita (i.e.  que
     possui índice ou subscrito em sua grafia), por exemplo 'a[i]'.

 -- Função: symbolp (<expr>)
     Retorna 'true' se <expr> for um símbolo, de outra forma retorna
     'false'.  com efeito, 'symbolp(x)' é equivalente ao predicado
     'atom(x) and not numberp(x)'.

     Veja também *note Identificadores::

 -- Função: unorder ()
     Disabilita a ação de alias criada pelo último uso dos comandos de
     ordenação 'ordergreat' e 'orderless'.  'ordergreat' e 'orderless'
     não podem ser usados mais que uma vez cada sem chamar 'unorder'.
     Veja também 'ordergreat' e 'orderless'.

     Exemplos:

          (%i1) unorder();
          (%o1)                          []
          (%i2) b*x + a^2;
                                             2
          (%o2)                       b x + a
          (%i3) ordergreat (a);
          (%o3)                         done
          (%i4) b*x + a^2;
           %th(1) - %th(3);
                                       2
          (%o4)                       a  + b x
          (%i5) unorder();
                                        2    2
          (%o5)                        a  - a

 -- Função: vectorpotential (<givencurl>)
     Retorna o potencial do vetor de um dado vetor de torção, no sistema
     de coordenadas corrente.  'potentialzeroloc' tem um papel similar
     ao de 'potential', mas a ordem dos lados esquerdos das equações
     deve ser uma permutação cíclica das variáveis de coordenadas.

 -- Função: xthru (<expr>)
     Combina todos os termos de <expr> (o qual pode ser uma adição)
     sobre um denominador comum sem produtos e somas exponenciadas como
     'ratsimp' faz.  'xthru' cancela fatores comuns no numerador e
     denominador de expressões racionais mas somente se os fatores são
     explícitos.

     Algumas vezes é melhor usar 'xthru' antes de 'ratsimp' em uma
     expressão com o objetivo de fazer com que fatores explicitos do
     máximo divisor comum entre o numerador e o denominador seja
     cancelado simplificando dessa forma a expressão a ser aplicado o
     'ratsimp'.

          (%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
                                          20
                           1       (x + 2)   - 2 y       x
          (%o1)        --------- + --------------- - ---------
                              19             20             20
                       (y + x)        (y + x)        (y + x)
          (%i2) xthru (%);
                                           20
                                    (x + 2)   - y
          (%o2)                     -------------
                                             20
                                      (y + x)

 -- Função: zeroequiv (<expr>, <v>)
     Testa se a expressão <expr> na variável <v> é equivalente a zero,
     retornando 'true', 'false', ou 'dontknow' (não sei).

     'zeroequiv' Tem essas restrições:
       1. Não use funções que o Maxima não sabe como diferenciar e
          avaliar.
       2. Se a expressão tem postes sobre o eixo real, podem existir
          erros no resultado (mas isso é improvável ocorrer).
       3. Se a expressão contem funções que não são soluções para
          equações diferenciais de primeira ordem (e.g.  funções de
          Bessel) pode ocorrer resultados incorretos.
       4. O algorítmo usa avaliação em pontos aleatóriamente escolhidos
          para subexpressões selecionadas cuidadosamente.  Isso é sempre
          negócio um tanto quanto perigoso, embora o algorítmo tente
          minimizar o potencial de erro.

     Por exemplo 'zeroequiv (sin(2*x) - 2*sin(x)*cos(x), x)' retorna
     'true' e 'zeroequiv (%e^x + x, x)' retorna 'false'.  Por outro lado
     'zeroequiv (log(a*b) - log(a) - log(b), a)' retorna 'dontknow'
     devido à presença de um parâmetro extra 'b'.


File: maxima.info,  Node: Expressões,  Next: Simplificação,  Prev: Operadores,  Up: Top

6 Expressões
************

* Menu:

* Introdução a Expressões::  
* Complexo::                     
* Substantivos e Verbos::
* Identificadores::
* Seqüências de caracteres::
* Desigualdade::                  
* Sintaxe::                      
* Funções e Variáveis Definidas para Expressões::  


File: maxima.info,  Node: Introdução a Expressões,  Next: Complexo,  Prev: Expressões,  Up: Expressões

6.1 Introdução a Expressões
===========================

Existe um conjunto de palavras reservadas que não pode ser usado como
nome de variável.  Seu uso pode causar um possível erro crítico de
sintaxe.

     integrate            next           from                 diff
     in                   at             limit                sum
     for                  and            elseif               then
     else                 do             or                   if
     unless               product        while                thru
     step

   Muitas coisas em Maxima são expressões.  Uma seqüência de expressões
pode ser feita dentro de uma expressão maior através da separação dessas
através de vírgulas e colocando parêntesis em torno dela.  Isso é
similar ao C expressão com vírgula.

     (%i1) x: 3$
     (%i2) (x: x+1, x: x^2);
     (%o2)                          16
     (%i3) (if (x > 17) then 2 else 4);
     (%o3)                           4
     (%i4) (if (x > 17) then x: 2 else y: 4, y+x);
     (%o4)                          20

   Mesmo ciclos em Maxima são expressões, embora o valor de retorno
desses ciclos não seja muito útil (eles retornam sempre 'done').

     (%i1) y: (x: 1, for i from 1 thru 10 do (x: x*i))$
     (%i2) y;
     (%o2)                         done

   contanto que o que você realmente queira seja provavelmente incluir
um terceiro termo na expressão com vírgula que fornece de volta o valor
atualizado.

     (%i3) y: (x: 1, for i from 1 thru 10 do (x: x*i), x)$
     (%i4) y;
     (%o4)                        3628800


File: maxima.info,  Node: Complexo,  Next: Substantivos e Verbos,  Prev: Introdução a Expressões,  Up: Expressões

6.2 Complexo
============

Uma expressão complexa é especificada no Maxima através da adição da
parte real da expressão a '%i' vezes a parte imaginária.  Dessa forma as
raízes da equação 'x^2 - 4*x + 13 = 0' são '2 + 3*%i' e '2 - 3*%i'.
Note que produtos de simplificação de expressões complexas podem ser
efetuadas através da expansão do produto.  Simplificação de quocientes,
raízes, e outras funções de expressões complexas podem usualmente serem
realizadas através do uso das funções 'realpart', 'imagpart',
'rectform', 'polarform', 'abs', 'carg'.


File: maxima.info,  Node: Substantivos e Verbos,  Next: Identificadores,  Prev: Complexo,  Up: Expressões

6.3 Substantivos e Verbos
=========================

Maxima distingue entre operadores que são "substantivos" e operadores
que são "verbos".  Um verbo é um operador que pode ser executado.  Um
substantivo é um operador que aparece como um símbolo em uma expressão,
sem ser executado.  Por padrão, nomes de função são verbos.  Um verbo
pode ser mudado em um substantivo através da adição de um apóstrofo no
início do nome da função ou aplicando a função 'nounify'.  Um
substantivo pode ser mudado em um verbo através da aplicação da função
'verbify'.  O sinalizador de avaliação 'nouns' faz com que 'ev' avalie
substantivos em uma expressão.

   A forma verbal é distinguida através de um sinal de dólar '$' no
início do símbolo Lisp correspondente.  De forma oposta, a forma
substantiva é distinguida através de um sinal de '%' no início do
símbolo Lisp correspondente.  Alguns substantivos possuem propriedades
especiais de exibição, tais como ''integrate' e ''derivative' (retornado
por 'diff'), mas muitos não.  Por padrão, as formas substantiva e verbal
de uma função são idênticas quando mostradas.  O sinalizador global
'noundisp' faz com que Maxima mostre substantivos com um apóstrofo no
início '''.

   Veja também 'noun', 'nouns', 'nounify', e 'verbify'.

   Exemplos:

     (%i1) foo (x) := x^2;
                                          2
     (%o1)                     foo(x) := x
     (%i2) foo (42);
     (%o2)                         1764
     (%i3) 'foo (42);
     (%o3)                        foo(42)
     (%i4) 'foo (42), nouns;
     (%o4)                         1764
     (%i5) declare (bar, noun);
     (%o5)                         done
     (%i6) bar (x) := x/17;
                                          x
     (%o6)                    ''bar(x) := --
                                          17
     (%i7) bar (52);
     (%o7)                        bar(52)
     (%i8) bar (52), nouns;
                                    52
     (%o8)                          --
                                    17
     (%i9) integrate (1/x, x, 1, 42);
     (%o9)                        log(42)
     (%i10) 'integrate (1/x, x, 1, 42);
                                  42
                                 /
                                 [   1
     (%o10)                      I   - dx
                                 ]   x
                                 /
                                  1
     (%i11) ev (%, nouns);
     (%o11)                       log(42)


File: maxima.info,  Node: Identificadores,  Next: Seqüências de caracteres,  Prev: Substantivos e Verbos,  Up: Expressões

6.4 Identificadores
===================

Identificadores do Maxima podem compreender caracteres alfabéticos, mais
os numerais de 0 a 9, mais qualquer caractere especial precedido por um
caractere contra-barra '\'.

   Um numeral pode ser o primeiro caractere de um identificador se esse
numeral for precedido por uma contra-barra.  Numerais que forem o
segundo ou o último caractere não precisam ser precedidos por uma contra
barra.

   Caracteres podem ser declarados para serem alfabéticos por meio da
função 'declare'.  Se então declarados alfabéticos, eles não precisam
serem precedidos de uma contrabarra em um identificador.  Os caracteres
alfabéticos vão inicialmente de 'A' a 'Z', de 'a' a 'z', '%', e '_'.

   Maxima é sensível à caixa .  Os identificadores 'algumacoisa',
'ALGUMACOISA', e 'Algumacoisa' são distintos.  Veja *note Lisp e
Maxima:: para mais sobre esse ponto.

   Um identificador Maxima é um símbolo Lisp que começa com um sinal de
dólar '$'.  Qualquer outro símbolo Lisp é precedido por um ponto de
interrogação '?' quando aparecer no Maxima.  Veja *note Lisp e Maxima::
para maiores detalhes sobre esse ponto.

   Exemplos:

     (%i1) %an_ordinary_identifier42;
     (%o1)               %an_ordinary_identifier42
     (%i2) embedded\ spaces\ in\ an\ identifier;
     (%o2)           embedded spaces in an identifier
     (%i3) symbolp (%);
     (%o3)                         true
     (%i4) [foo+bar, foo\+bar];
     (%o4)                 [foo + bar, foo+bar]
     (%i5) [1729, \1729];
     (%o5)                     [1729, 1729]
     (%i6) [symbolp (foo\+bar), symbolp (\1729)];
     (%o6)                     [true, true]
     (%i7) [is (foo\+bar = foo+bar), is (\1729 = 1729)];
     (%o7)                    [false, false]
     (%i8) baz\~quux;
     (%o8)                       baz~quux
     (%i9) declare ("~", alphabetic);
     (%o9)                         done
     (%i10) baz~quux;
     (%o10)                      baz~quux
     (%i11) [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
     (%o11)                [false, false, false]
     (%i12) :lisp (defvar *my-lisp-variable* '$foo)
     *MY-LISP-VARIABLE*
     (%i12) ?\*my\-lisp\-variable\*;
     (%o12)                         foo


File: maxima.info,  Node: Seqüências de caracteres,  Next: Desigualdade,  Prev: Identificadores,  Up: Expressões

6.5 Seqüências de caracteres
============================

Strings (seqüências de caracteres) são contidas entre aspas duplas '"'
em entradas de dados usados pelo Maxima, e mostradas com ou sem as aspas
duplas, dependendo do valor escolhido para a variável global
'stringdisp'.

   Seqüências de caracteres podem conter quaisquer caracteres, incluindo
tabulações (tab), nova linha (ou fim de linha), e caracteres de retorno
da cabeça de impressão (carriage return).  A seqüência '\"' é
reconhecida com uma aspa dupla literal, e '\\' como uma contrabarra
literal.  Quando a contrabarra aparecer no final de uma linha, a
contrabarra e a terminação de linha (ou nova linha ou retorno de carro e
nova linha) são ignorados, de forma que a seqüência de caracteres
continue na próxima linha.  Nenhuma outra combinação especial de
contrabarra com outro caractere é reconhecida; quando a contrabarra
aparecer antes de qualquer outro caractere que não seja '"', '\', ou um
fim de linha, a contrabarra é ignorada.  Não exite caminho para
representar um caractere especial (tal como uma tabulação, nova linha,
ou retorno da cabeça de impressão) exceto através de encaixar o
caractere literal na seqüência de caracteres.

   Não existe tipo de caractere no Maxima; um caractere simples é
representado como uma seqüência de caracteres de um único caractere.

   Seqüências de caracteres no Maxima são implementadas como símbolos do
Lisp, não como seqüencias de caracteres do not Lisp; o que pode mudar em
futuras versões do Maxima.  Maxima pode mostrar seqüências de caracteres
do Lisp e caracteres do Lisp, embora algumas outras operações (por
exemplo, testes de igualdade) possam falhar.

   O pacote adicional 'stringproc' contém muitas funções que trabalham
com seqüências de caracteres.

   Exemplos:

     (%i1) s_1 : "Isso é uma seqüência de caracteres  do Maxima.";
     (%o1)               Isso é uma seqüência de caracteres  do Maxima.
     (%i2) s_2 : "Caracteres \"aspas duplas\" e contrabarras \\ encaixados em uma seqüência de caracteres.";
     (%o2) Caracteres "aspas duplas" e contrabarra \ encaixados em uma seqüência de caracteres.
     (%i3) s_3 : "Caractere de fim de linha encaixado
     nessa seqüência de caracteres.";
     (%o3) Caractere de fim de linha encaixado
     nessa seqüência de caracteres.
     (%i4) s_4 : "Ignore o \
     caractere de \
     fim de linha nessa \
     seqüência de caracteres.";
     (%o4) Ignore o caractere de fim de linha nessa seqüência de caracteres.
     (%i5) stringdisp : false;
     (%o5)                         false
     (%i6) s_1;
     (%o6)               Isso é uma seqüência de caracteres  do Maxima.
     (%i7) stringdisp : true;
     (%o7)                         true
     (%i8) s_1;
     (%o8)              "Isso é uma seqüência de caracteres  do Maxima."


File: maxima.info,  Node: Desigualdade,  Next: Sintaxe,  Prev: Seqüências de caracteres,  Up: Expressões

6.6 Desigualdade
================

Maxima tem os operadores de desigualdade '<', '<=', '>=', '>', '#', e
'notequal'.  Veja 'if' para uma descrição de expressões condicionais.


File: maxima.info,  Node: Sintaxe,  Next: Funções e Variáveis Definidas para Expressões,  Prev: Desigualdade,  Up: Expressões

6.7 Sintaxe
===========

É possível definir novos operadores com precedência especificada,
remover a definição de operadores existentes, ou redefinir a precedência
de operadores existentes.  Um operador pode ser unário prefixado ou
unário pósfixado, binario infixado, n-ário infixado, matchfix, ou nofix.
"Matchfix" significa um par de símbolos que abraçam seu argumento ou
seus argumentos, e "nofix" significa um operador que não precisa de
argumentos.  Como exemplos dos diferentes tipos de operadores, existe o
seguinte.

unário prefixado
     negação '- a'
unário posfixado
     fatorial 'a!'
binário infixado
     exponenciação 'a^b'
n-ário infixado
     adição 'a + b'
matchfix
     construção de lista '[a, b]'

   (Não existe operadores internos nofix; para um exemplo de tal
operador, veja 'nofix'.)

   O mecanismo para definir um novo operador é direto.  Somente é
necessário declarar uma função como um operador; a função operador pode
ou não estar definida previamente.

   Um exemplo de operadores definidos pelo usuário é o seguinte.  Note
que a chamada explícita de função '"dd" (a)' é equivalente a 'dd a', da
mesma forma '"<-" (a, b)' é equivalente a 'a <- b'.  Note também que as
funções '"dd"' e '"<-"' são indefinidas nesse exemplo.

     (%i1) prefix ("dd");
     (%o1)                          dd
     (%i2) dd a;
     (%o2)                         dd a
     (%i3) "dd" (a);
     (%o3)                         dd a
     (%i4) infix ("<-");
     (%o4)                          <-
     (%i5) a <- dd b;
     (%o5)                      a <- dd b
     (%i6) "<-" (a, "dd" (b));
     (%o6)                      a <- dd b

   As funções máxima que definem novos operadores estão sumarizadas
nessa tabela, equilibrando expoente associado esquerdo (padrão) e o
expoente associado direito ("eae" e "ead", respectivamente).
(Associação de expoentes determina a precedência do operador.  todavia,
uma vez que os expoentes esquerdo e direito podem ser diferentes,
associação de expoentes é até certo ponto mais complicado que
precedência.)  Alguma das funções de definição de operações tomam
argumentos adicionais; veja as descrições de função para maiores
detalhes.

'prefixado'
     ead=180
'posfixado'
     eae=180
'infixado'
     eae=180, ead=180
'nário'
     eae=180, ead=180
'matchfix'
     (associação de expoentes não é aplicável)
'nofix'
     (associação de expoentes não é aplicável)

   Para comparação, aqui está alguns operadores internos e seus
expoentes associados esquerdo e direito.

     Operador   eae     ead

       :        180     20
       ::       180     20
       :=       180     20
       ::=      180     20
       !        160
       !!       160
       ^        140     139
       .        130     129
       *        120
       /        120     120
       +        100     100
       -        100     134
       =        80      80
       #        80      80
       >        80      80
       >=       80      80
       <        80      80
       <=       80      80
       not              70
       and      65
       or       60
       ,        10
       $        -1
       ;        -1

   'remove' e 'kill' removem propriedades de operador de um átomo.
'remove ("<a>", op)' remove somente as propriedades de operador de <a>.
'kill ("<a>")' remove todas as propriedades de <a>, incluindo as
propriedades de operador.  Note que o nome do operador dever estar
abraçado por aspas duplas.

     (%i1) infix ("##");
     (%o1)                          ##
     (%i2) "##" (a, b) := a^b;
                                          b
     (%o2)                     a ## b := a
     (%i3) 5 ## 3;
     (%o3)                          125
     (%i4) remove ("##", op);
     (%o4)                         done
     (%i5) 5 ## 3;
     Incorrect syntax: # is not a prefix operator
     5 ##
       ^
     (%i5) "##" (5, 3);
     (%o5)                          125
     (%i6) infix ("##");
     (%o6)                          ##
     (%i7) 5 ## 3;
     (%o7)                          125
     (%i8) kill ("##");
     (%o8)                         done
     (%i9) 5 ## 3;
     Incorrect syntax: # is not a prefix operator
     5 ##
       ^
     (%i9) "##" (5, 3);
     (%o9)                       ##(5, 3)


File: maxima.info,  Node: Funções e Variáveis Definidas para Expressões,  Prev: Sintaxe,  Up: Expressões

6.8 Funções e Variáveis Definidas para Expressões
=================================================

 -- Função: at (<expr>, [<eqn_1>, ..., <eqn_n>])
 -- Função: at (<expr>, <eqn>)
     Avalia a expressão <expr> com as variáveis assumindo os valores
     como especificado para elas na lista de equações '[<eqn_1>, ...,
     <eqn_n>]' ou a equação simples <eqn>.

     Se uma subexpressão depender de qualquer das variáveis para a qual
     um valor foi especificado mas não existe 'atvalue' especificado e
     essa subexpressão não pode ser avaliada de outra forma, então uma
     forma substantiva de 'at' é retornada que mostra em uma forma
     bidimensional.

     'at' realiza múltiplas substituições em série, não em paralelo.

     Veja também 'atvalue'.  Para outras funções que realizam
     substituições, veja também 'subst' e 'ev'.

     Exemplos:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x, y)^2 - u(x, y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1

 -- Função: box (<expr>)
 -- Função: box (<expr>, <a>)
     Retorna <expr> dentro de uma caixa.  O valor de retorno é uma
     expressão com 'box' como o operador e <expr> como o argumento.  Uma
     caixa é desenhada sobre a tela quando 'display2d' for 'true'.

     'box (<expr>, <a>)' Empacota <expr> em uma caixa rotulada pelo
     símbolo <a>.  O rótulo é truncado se for maior que a largura da
     caixa.

     'box' avalia seu argumento.  Todavia, uma expressão dentro de uma
     caixa não avalia para seu conteúdo, então expressões dentro de
     caixas são efetivamente excluídas de cálculos.

     'boxchar' é o caractere usado para desenhar a caixa em 'box' e nas
     funções 'dpart' e 'lpart'.

     Exemplos:

          (%i1) box (a^2 + b^2);
                                      """""""""
                                      " 2    2"
          (%o1)                       "b  + a "
                                      """""""""
          (%i2) a : 1234;
          (%o2)                         1234
          (%i3) b : c - d;
          (%o3)                         c - d
          (%i4) box (a^2 + b^2);
                                """"""""""""""""""""
                                "       2          "
          (%o4)                 "(c - d)  + 1522756"
                                """"""""""""""""""""
          (%i5) box (a^2 + b^2, term_1);
                                term_1""""""""""""""
                                "       2          "
          (%o5)                 "(c - d)  + 1522756"
                                """"""""""""""""""""
          (%i6) 1729 - box (1729);
                                           """"""
          (%o6)                     1729 - "1729"
                                           """"""
          (%i7) boxchar: "-";
          (%o7)                           -
          (%i8) box (sin(x) + cos(y));
                                  -----------------
          (%o8)                   -cos(y) + sin(x)-
                                  -----------------

 -- Variável de opção: boxchar
     Valor padrão: '"'

     'boxchar' é o caractere usado para desenhar a caixa por 'box' e nas
     funções 'dpart' e 'lpart'.

     Todas as caixas em uma expressão são desenhadas com o valor atual
     de 'boxchar'; o caractere de desenho não é armazenado com a
     expressão de caixa.  Isso quer dizer que se você desenhar uma caixa
     e em seguida mudar o caractere de desenho a caixa anteriormente
     desenhada será redesenhada com o caractere mudado caso isso seja
     solicitado.

 -- Função: carg (<z>)
     Retorna o argumento complexo de <z>.  O argumento complexo é um
     ângulo 'theta' no intervalo de '(-%pi, %pi]' tal que 'r exp (theta
     %i) = <z>' onde 'r' é o módulo de <z>.

     'carg' é uma função computacional, não uma função de simplificação.

     'carg' ignora a declaração 'declare (<x>, complex)', e trata <x>
     como uma variável real.  Isso é um erro.

     Veja também 'abs' (módulo de número complexo), 'polarform',
     'rectform', 'realpart', e 'imagpart'.

     Exemplos:

          (%i1) carg (1);
          (%o1)                           0
          (%i2) carg (1 + %i);
                                         %pi
          (%o2)                          ---
                                          4
          (%i3) carg (exp (%i));
          (%o3)                           1
          (%i4) carg (exp (%pi * %i));
          (%o4)                          %pi
          (%i5) carg (exp (3/2 * %pi * %i));
                                          %pi
          (%o5)                         - ---
                                           2
          (%i6) carg (17 * exp (2 * %i));
          (%o6)                           2

 -- Opereador especial: constant
     'declare (<a>, constant)' declara <a> para ser uma constante.  Veja
     'declare'.

 -- Função: constantp (<expr>)
     Retorna 'true' se <expr> for uma expressão constante, de outra
     forma retorna 'false'.

     Uma expressão é considerada uma expressão constante se seus
     argumentos forem números (incluindo números racionais, como
     mostrado com '/R/'), constantes simbólicas como '%pi', '%e', e
     '%i', variáveis associadas a uma constante ou constante declarada
     através de 'declare', ou funções cujos argumentos forem constantes.

     'constantp' avalia seus argumentos.

     Exemplos:

          (%i1) constantp (7 * sin(2));
          (%o1)                                true
          (%i2) constantp (rat (17/29));
          (%o2)                                true
          (%i3) constantp (%pi * sin(%e));
          (%o3)                                true
          (%i4) constantp (exp (x));
          (%o4)                                false
          (%i5) declare (x, constant);
          (%o5)                                done
          (%i6) constantp (exp (x));
          (%o6)                                true
          (%i7) constantp (foo (x) + bar (%e) + baz (2));
          (%o7)                                false
          (%i8)

 -- Função: declare (<a_1>, <p_1>, <a_2>, <p_2>, ...)
     Atribui aos átomos ou lista de átomos <a_i> a propriedade ou lista
     de propriedades <p_i>.  Quando <a_i> e/ou <p_i> forem listas, cada
     um dos átomos recebe todas as propriedades.

     'declare' não avalia seus argumentos.  'declare' sempre retorna
     'done'.

     Como colocado na descrição para cada sinalizador de declaração,
     para alguns sinalizadores 'featurep(<objeto>, <recurso>)' retorna
     'true' se <objeto> tiver sido declarado para ter <recurso>.
     Todavia, 'featurep' não reconhece alguns sinalizadores; isso é um
     erro.

     Veja também 'features'.

     'declare' reconhece as seguintes propriedades:

     'evfun'
          Torna <a_i> conhecido para 'ev' de forma que a função nomeada
          por <a_i> é aplicada quando <a_i> aparece como um sinalizador
          argumento de 'ev'.  Veja 'evfun'.

     'evflag'
          Torna <a_i> conhecido para a função 'ev' de forma que <a_i> é
          associado a 'true' durante a execução de 'ev' quando <a_i>
          aparece como um sinalizador argumento de 'ev'.  Veja 'evflag'.

     'bindtest'
          Diz ao Maxima para disparar um erro quando <a_i> for avaliado
          como sendo livre de associação.

     'noun'
          Diz ao Maxima para passar <a_i> como um substantivo.  O efeito
          disso é substituir intâncias de <a_i> com ''<a_i>' ou
          'nounify(<a_i>)', ependendo do contexto.

     'constant'
          Diz ao Maxima para considerar <a_i> uma constante simbólica.

     'scalar'
          Diz ao Maxima para considerar <a_i> uma variável escalar.

     'nonscalar'
          Diz ao Maxima para considerar <a_i> uma variável não escalar.
          The usual application is to declare a variable as a symbolic
          vector or matrix.

     'mainvar'
          Diz ao Maxima para considerar <a_i> uma "variável principal"
          ('mainvar').  'ordergreatp' determina a ordenação de átomos
          como segue:

          (variáveis principais) > (outras variáveis) > (variáveis
          escalares) > (constantes) > (números)

     'alphabetic'
          Diz ao Maxima para reconhecer todos os caracteres em <a_i>
          (que deve ser uma seqüência de caracteres) como caractere
          alfabético.

     'feature'
          Diz ao Maxima para reconhecer <a_i> como nome de um recurso.
          Other atoms may then be declared to have the <a_i> property.

     'rassociative', 'lassociative'
          Diz ao Maxima para reconhecer <a_i> como uma funcão
          associativa a direita ou associativa a esquerda.

     'nary'
          Diz ao Maxima para reconhecer <a_i> como uma função n-ária
          (com muitos argumentos).

          A declaração 'nary' não tem o mesmo objetivo que uma chamada à
          função 'nary'.  O único efeito de 'declare(foo, nary)' é para
          instruir o simplificador do Maxima a melhorar as próximas
          expressões, por exemplo, para simplificar 'foo(x, foo(y, z))'
          para 'foo(x, y, z)'.

     'symmetric', 'antisymmetric', 'commutative'
          Diz ao Maxima para reconhecer <a_i> como uma função simétrica
          ou antisimétrica.  'commutative' é o mesmo que 'symmetric'.

     'oddfun', 'evenfun'
          Diz ao Maxima para reconhecer <a_i> como uma função par ou uma
          função ímpar.

     'outative'
          Diz ao Maxima para simplificar expressões <a_i> colocando
          fatores constantes em evidência no primeiro argumento.

          Quando <a_i> tiver um argumento, um fator é onsiderado
          constante se for um literal ou se for declarado como sendo
          constante.

          Quando <a_i> tiver dois ou mais argumentos, um fator é
          considerado constante se o segundo argumento for um símbolo e
          o fator estiver livre do segundo argumento.

     'multiplicative'
          Diz ao Maxima para simplificar expressões do tipo <a_i>
          através da substituição '<a_i>(x * y * z * ...)'  '-->'
          '<a_i>(x) * <a_i>(y) * <a_i>(z) * ...'.  A substituição é
          realizada no primeiro argumento somente.

     'additive'
          Diz ao Maxima para simplificar expressões do tipo <a_i>
          através da substituição '<a_i>(x + y + z + ...)'  '-->'
          '<a_i>(x) + <a_i>(y) + <a_i>(z) + ...'.  A substituição é
          realizada no primeiro argumento somente.

     'linear'
          Equivalente a declarar <a_i> ao mesmo tempo 'outative' e
          'additive'.

     'integer', 'noninteger'
          Diz ao Maxima para reconhecer <a_i> como como uma variável
          inteira ou como uma variável não inteira.

          Maxima reconhece os seguintes recursos de objetos:

     'even', 'odd'
          Diz ao Maxima para reconhecer <a_i> como uma variável inteira
          par ou como uma variável inteira ímpar.

     'rational', 'irrational'
          Diz ao Maxima para reconhecer <a_i> como uma variável real e
          racional ou como uma variável real e irracional.

     'real', 'imaginary', 'complex'
          Dia ao Maxima para reconhecer <a_i> como uma variável real,
          imaginária pura ou complexa.

     'increasing', 'decreasing'
          Dia ao Maxima para reconhecer <a_i> como uma função de
          incremento ou decremento.

     'posfun'
          Diz ao Maxima para reconhecer <a_i> como uma função positiva.

     'integervalued'
          Diz ao Maxima para reconhecer <a_i> como uma função de valores
          inteiros.

     Exemplos:

     Declarações 'evfun' e 'evflag'.
          (%i1) declare (expand, evfun);
          (%o1)                         done
          (%i2) (a + b)^3;
                                             3
          (%o2)                       (b + a)
          (%i3) (a + b)^3, expand;
                               3        2      2      3
          (%o3)               b  + 3 a b  + 3 a  b + a
          (%i4) declare (demoivre, evflag);
          (%o4)                         done
          (%i5) exp (a + b*%i);
                                       %i b + a
          (%o5)                      %e
          (%i6) exp (a + b*%i), demoivre;
                                a
          (%o6)               %e  (%i sin(b) + cos(b))

     Declaração 'bindtest'.
          (%i1) aa + bb;
          (%o1)                        bb + aa
          (%i2) declare (aa, bindtest);
          (%o2)                         done
          (%i3) aa + bb;
          aa unbound variable
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) aa : 1234;
          (%o4)                         1234
          (%i5) aa + bb;
          (%o5)                       bb + 1234

     Declaração 'noun'.
          (%i1) factor (12345678);
                                       2
          (%o1)                     2 3  47 14593
          (%i2) declare (factor, noun);
          (%o2)                         done
          (%i3) factor (12345678);
          (%o3)                   factor(12345678)
          (%i4) ''%, nouns;
                                       2
          (%o4)                     2 3  47 14593

     Declarações 'constant', 'scalar', 'nonscalar', e 'mainvar'.

     Declaração 'alphabetic'.
          (%i1) xx\~yy\`\@ : 1729;
          (%o1)                         1729
          (%i2) declare ("~`@", alphabetic);
          (%o2)                         done
          (%i3) xx~yy`@ + @yy`xx + `xx@@yy~;
          (%o3)               `xx@@yy~ + @yy`xx + 1729
          (%i4) listofvars (%);
          (%o4)                  [@yy`xx, `xx@@yy~]

     Declaração 'feature'.
          (%i1) declare (FOO, feature);
          (%o1)                         done
          (%i2) declare (x, FOO);
          (%o2)                         done
          (%i3) featurep (x, FOO);
          (%o3)                         true

     Declarações 'rassociative' e 'lassociative'.

     Declaração 'nary'.
          (%i1) H (H (a, b), H (c, H (d, e)));
          (%o1)               H(H(a, b), H(c, H(d, e)))
          (%i2) declare (H, nary);
          (%o2)                         done
          (%i3) H (H (a, b), H (c, H (d, e)));
          (%o3)                   H(a, b, c, d, e)

     Declarações 'symmetric' e 'antisymmetric'.
          (%i1) S (b, a);
          (%o1)                        S(b, a)
          (%i2) declare (S, symmetric);
          (%o2)                         done
          (%i3) S (b, a);
          (%o3)                        S(a, b)
          (%i4) S (a, c, e, d, b);
          (%o4)                   S(a, b, c, d, e)
          (%i5) T (b, a);
          (%o5)                        T(b, a)
          (%i6) declare (T, antisymmetric);
          (%o6)                         done
          (%i7) T (b, a);
          (%o7)                       - T(a, b)
          (%i8) T (a, c, e, d, b);
          (%o8)                   T(a, b, c, d, e)

     Declarações 'oddfun' e 'evenfun'.
          (%i1) o (- u) + o (u);
          (%o1)                     o(u) + o(- u)
          (%i2) declare (o, oddfun);
          (%o2)                         done
          (%i3) o (- u) + o (u);
          (%o3)                           0
          (%i4) e (- u) - e (u);
          (%o4)                     e(- u) - e(u)
          (%i5) declare (e, evenfun);
          (%o5)                         done
          (%i6) e (- u) - e (u);
          (%o6)                           0

     Declaração 'outative'.
          (%i1) F1 (100 * x);
          (%o1)                       F1(100 x)
          (%i2) declare (F1, outative);
          (%o2)                         done
          (%i3) F1 (100 * x);
          (%o3)                       100 F1(x)
          (%i4) declare (zz, constant);
          (%o4)                         done
          (%i5) F1 (zz * y);
          (%o5)                       zz F1(y)

     Declaração 'multiplicative'.
          (%i1) F2 (a * b * c);
          (%o1)                       F2(a b c)
          (%i2) declare (F2, multiplicative);
          (%o2)                         done
          (%i3) F2 (a * b * c);
          (%o3)                   F2(a) F2(b) F2(c)

     Declaração 'additive'.
          (%i1) F3 (a + b + c);
          (%o1)                     F3(c + b + a)
          (%i2) declare (F3, additive);
          (%o2)                         done
          (%i3) F3 (a + b + c);
          (%o3)                 F3(c) + F3(b) + F3(a)

     Declaração 'linear'.
          (%i1) 'sum (F(k) + G(k), k, 1, inf);
                                 inf
                                 ====
                                 \
          (%o1)                   >    (G(k) + F(k))
                                 /
                                 ====
                                 k = 1
          (%i2) declare (nounify (sum), linear);
          (%o2)                         done
          (%i3) 'sum (F(k) + G(k), k, 1, inf);
                               inf          inf
                               ====         ====
                               \            \
          (%o3)                 >    G(k) +  >    F(k)
                               /            /
                               ====         ====
                               k = 1        k = 1

 -- Função: disolate (<expr>, <x_1>, ..., <x_n>)
     é similar a 'isolate (<expr>, <x>)' exceto que essa função habilita
     ao usuário isolar mais que uma variável simultâneamente.  Isso pode
     ser útil, por exemplo, se se tiver tentado mudar variáveis em uma
     integração múltipla, e em mudança de variável envolvendo duas ou
     mais das variáveis de integração.  Essa função é chamada
     automaticamente de 'simplification/disol.mac'.  Uma demostração
     está disponível através de 'demo("disol")$'.

 -- Função: dispform (<expr>)
     Retorna a representação externa de <expr> com relação a seu
     principal operador.  Isso pode ser útil em conjunção com 'part' que
     também lida com a representação externa.  Suponha que <expr> seja
     -A .  Então a representação interna de <expr> é "*"(-1,A), enquanto
     que a representação externa é "-"(A). 'dispform (<expr>, all)'
     converte a expressão inteira (não apenas o nível mais alto) para o
     formato externo.  Por exemplo, se 'expr: sin (sqrt (x))', então
     'freeof (sqrt, expr)' e 'freeof (sqrt, dispform (expr))' fornece
     'true', enquanto 'freeof (sqrt, dispform (expr, all))' fornece
     'false'.

 -- Função: distrib (<expr>)
     Distribue adições sobre produtos.  'distrib' difere de 'expand' no
     fato de que 'distrib' trabalha em somente no nível mais alto de uma
     expressão, i.e., 'distrib' não é recursiva e 'distrib' é mais
     rápida que 'expand'.  'distrib' difere de 'multthru' no que
     'distrib' expande todas as adições naquele nível.

     Exemplos:

          (%i1) distrib ((a+b) * (c+d));
          (%o1)                 b d + a d + b c + a c
          (%i2) multthru ((a+b) * (c+d));
          (%o2)                 (b + a) d + (b + a) c
          (%i3) distrib (1/((a+b) * (c+d)));
                                          1
          (%o3)                    ---------------
                                   (b + a) (d + c)
          (%i4) expand (1/((a+b) * (c+d)), 1, 0);
                                          1
          (%o4)                 ---------------------
                                b d + a d + b c + a c

 -- Função: dpart (<expr>, <n_1>, ..., <n_k>)
     Seleciona a mesma subexpressão que 'part', mas em lugar de apenas
     retornar aquela subexpressão como seu valor, isso retorna a
     expressão completa com a subexpressão selecionada mostrada dentro
     de uma caixa.  A caixa é atualmente parte da expressão.

          (%i1) dpart (x+y/z^2, 1, 2, 1);
                                       y
          (%o1)                       ---- + x
                                         2
                                      """
                                      "z"
                                      """

 -- Função: exp (<x>)
     Representa função exponencial.  Instâncias de 'exp (<x>)' em uma
     entrada são simplificadas para '%e^<x>'; 'exp' não aparece em
     expressões simplificadas.

     'demoivre' se 'true' faz com que '%e^(a + b %i)' simplificar para
     '%e^(a (cos(b) + %i sin(b)))' se 'b' for livre de '%i'.  veja
     'demoivre'.

     '%emode', quando 'true', faz com que '%e^(%pi %i x)' seja
     simplificado.  Veja '%emode'.

     '%enumer', quando 'true' faz com que '%e' seja substituído por
     2.718...  quando 'numer' for 'true'.  Veja '%enumer'.

 -- Variável de opção: %emode
     Valor padrão: 'true'

     Quando '%emode' for 'true', '%e^(%pi %i x)' é simplificado como
     segue.

     '%e^(%pi %i x)' simplifica para 'cos (%pi x) + %i sin (%pi x)' se
     'x' for um inteiro ou um multiplo de 1/2, 1/3, 1/4, ou 1/6, e então
     é adicionalmente simplificado.

     Para outro 'x' numérico, '%e^(%pi %i x)' simplifica para '%e^(%pi
     %i y)' onde 'y' é 'x - 2 k' para algum inteiro 'k' tal que 'abs(y)
     < 1'.

     Quando '%emode' for 'false', nenhuma simplificação adicional de
     '%e^(%pi %i x)' é realizada.

 -- Variável de opção: %enumer
     Valor padrão: 'false'

     Quando '%enumer' for 'true', '%e' é substituido por seu valor
     numérico 2.718...  mesmo que 'numer' seja 'true'.

     Quando '%enumer' for 'false', essa substituição é realizada somente
     se o expoente em '%e^x' avaliar para um número.

     Veja também 'ev' e 'numer'.

 -- Variável de opção: exptisolate
     Valor padrão: 'false'

     'exptisolate', quando 'true', faz com que 'isolate (expr, var)'
     examine expoentes de átomos (tais como '%e') que contenham 'var'.

 -- Variável de opção: exptsubst
     Valor padrão: 'false'

     'exptsubst', quando 'true', permite substituições tais como 'y'
     para '%e^x' em '%e^(a x)'.

 -- Função: freeof (<x_1>, ..., <x_n>, <expr>)
     'freeof (<x_1>, <expr>)' Retorna 'true' se nenhuma subexpressão de
     <expr> for igual a <x_1> ou se <x_1> ocorrer somente uma variável
     que não tenha associação fora da expressão <expr>, e retorna
     'false' de outra forma.

     'freeof (<x_1>, ..., <x_n>, <expr>)' é equivalente a 'freeof
     (<x_1>, <expr>) and ... and freeof (<x_n>, <expr>)'.

     Os argumentos <x_1>, ..., <x_n> podem ser nomes de funções e
     variáveis, nomes subscritos, operadores (empacotados em aspas
     duplas), ou expressões gerais.  'freeof' avalia seus argumentos.

     'freeof' opera somente sobre <expr> como isso representa (após
     simplificação e avaliação) e não tenta determinar se alguma
     expressão equivalente pode fornecer um resultado diferente.  Em
     particular, simplificação pode retornar uma expressão equivalente
     mas diferente que compreende alguns diferentes elementos da forma
     original de <expr>.

     Uma variável é uma variável dummy em uma expressão se não tiver
     associação fora da expressão.  Variáveis dummy recoreconhecidas
     através de 'freeof' são o índice de um somatório ou produtório, o
     limite da variável em 'limit', a variável de integração na forma de
     integral definida de 'integrate', a variável original em 'laplace',
     variáveis formais em expressoes 'at', e argumentos em expressões
     'lambda'.  Variáveis locais em 'block' não são reconhecidas por
     'freeof' como variáveis dummy; isso é um bug.

     A forma indefinida de 'integrate' not é livre de suas variáveis de
     integração.

        * Argumentos são nomes de funções, variáveis, nomes subscritos,
          operadores, e expressões.  'freeof (a, b, expr)' é equivalente
          a 'freeof (a, expr) and freeof (b, expr)'.

               (%i1) expr: z^3 * cos (a[1]) * b^(c+d);
                                                d + c  3
               (%o1)                   cos(a ) b      z
                                            1
               (%i2) freeof (z, expr);
               (%o2)                         false
               (%i3) freeof (cos, expr);
               (%o3)                         false
               (%i4) freeof (a[1], expr);
               (%o4)                         false
               (%i5) freeof (cos (a[1]), expr);
               (%o5)                         false
               (%i6) freeof (b^(c+d), expr);
               (%o6)                         false
               (%i7) freeof ("^", expr);
               (%o7)                         false
               (%i8) freeof (w, sin, a[2], sin (a[2]), b*(c+d), expr);
               (%o8)                         true

        * 'freeof' avalia seus argumentos.

               (%i1) expr: (a+b)^5$
               (%i2) c: a$
               (%i3) freeof (c, expr);
               (%o3)                         false

        * 'freeof' não considera expressões equivalentes.  Simplificação
          pode retornar uma expressão equivalente mas diferente.

               (%i1) expr: (a+b)^5$
               (%i2) expand (expr);
                         5        4       2  3       3  2      4      5
               (%o2)    b  + 5 a b  + 10 a  b  + 10 a  b  + 5 a  b + a
               (%i3) freeof (a+b, %);
               (%o3)                         true
               (%i4) freeof (a+b, expr);
               (%o4)                         false
               (%i5) exp (x);
                                                x
               (%o5)                          %e
               (%i6) freeof (exp, exp (x));
               (%o6)                         true

        * Um somatório ou uma integral definida está livre de uma
          variável dummy.  Uma integral indefinida não é livre de suas
          variáveis de integração.

               (%i1) freeof (i, 'sum (f(i), i, 0, n));
               (%o1)                         true
               (%i2) freeof (x, 'integrate (x^2, x, 0, 1));
               (%o2)                         true
               (%i3) freeof (x, 'integrate (x^2, x));
               (%o3)                         false

 -- Função: genfact (<x>, <y>, <z>)
     Retorna o fatorial generalizado, definido como 'x (x-z) (x - 2 z)
     ... (x - (y - 1) z)'.  Dessa forma, para integral <x>, 'genfact (x,
     x, 1) = x!' e 'genfact (x, x/2, 2) = x!!'.

 -- Função: imagpart (<expr>)
     Retorna a parte imaginária da expressão <expr>.

     'imagpart' é uma função computacional, não uma função de
     simplificação.

     Veja também 'abs', 'carg', 'polarform', 'rectform', e 'realpart'.

 -- Função: infix (<op>)
 -- Função: infix (<op>, <lbp>, <rbp>)
 -- Função: infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)
     Declara <op> para ser um operador infixo.  Um operador infixo é uma
     função de dois argumentos, com o nome da função escrito entre os
     argumentos.  Por exemplo, o operador de subtração '-' é um operador
     infixo.

     'infix (<op>)' declara <op> para ser um operador infixo com
     expoentes associados padrão (esquerdo e direito ambos iguais a 180)
     e podendo ser qualquer entre prefixado, infixado, posfixado, nário,
     matchfix e nofix (esquerdo e direito ambos iguais a 'any').

     'infix (<op>, <lbp>, <rbp>)' declara <op> para ser um operador
     infixo com expoentes associados esquerdo e diretio equilibrados e
     podendo ser qualquer entre prefixado, infixado, posfixado, nário,
     matchfix e nofix (esquerdo e direito ambos iguais a 'any').

     'infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)' declara <op>
     para ser um operdor infixo com expoentes associados padrão e
     podendo ser um entre prefixado, infixado, posfixado, nário,
     matchfix e nofix.

     A precedência de <op> com relação a outros operadores derivam dos
     expoentes associados diretiro e esquerdo dos operadores em questão.
     Se os expoentes associados esquerdo e direito de <op> forem ambos
     maiores que o expoente associado esquerdo e o direito de algum
     outro operador, então <op> tem prededência sobre o outro operador.
     Se os expoentes associados não forem ambos maior ou menor, alguma
     relação mais complicada ocorre.

     A associatividade de <op> depende de seus expoentes associados.
     Maior expoente associado esquerdo (<eae>) implica uma instância de
     <op> é avaliadas antes de outros operadores para sua esquerda em
     uma expressão, enquanto maior expoente associado direito (<ead>)
     implica uma instância de <op> é avaliada antes de outros operadores
     para sua direita em uma expressão.  Dessa forma maior <eae> torna
     <op> associativo à direita, enquanto maior <ead> torna <op>
     associativa à esquerda.  Se <eae> for igual a <ead>, <op> é
     associativa à esquerda.

     Veja também 'Syntax'.

     Exemplos:

     Se os expoentes associados esquerdo e direito de <op> forem ambos
     maiores que os expoentes associados à direita e à esquerda de algum
     outro operador, então <op> tem precedência sobre o outro operador.

          (%i1) :lisp (get '$+ 'lbp)
          100
          (%i1) :lisp (get '$+ 'rbp)
          100
          (%i1) infix ("##", 101, 101);
          (%o1)                          ##
          (%i2) "##"(a, b) := sconcat("(", a, ",", b, ")");
          (%o2)       (a ## b) := sconcat("(", a, ",", b, ")")
          (%i3) 1 + a ## b + 2;
          (%o3)                       (a,b) + 3
          (%i4) infix ("##", 99, 99);
          (%o4)                          ##
          (%i5) 1 + a ## b + 2;
          (%o5)                       (a+1,b+2)

     grande <eae> torna <op> associativa à direita, enquanto grande
     <ead> torna <op> associativa à esquerda.

          (%i1) infix ("##", 100, 99);
          (%o1)                          ##
          (%i2) "##"(a, b) := sconcat("(", a, ",", b, ")")$
          (%i3) foo ## bar ## baz;
          (%o3)                    (foo,(bar,baz))
          (%i4) infix ("##", 100, 101);
          (%o4)                          ##
          (%i5) foo ## bar ## baz;
          (%o5)                    ((foo,bar),baz)

 -- Variável de opção: inflag
     Velor padrão: 'false'

     Quando 'inflag' for 'true', funções para extração de partes
     inspecionam a forma interna de 'expr'.

     Note que o simplificador re-organiza expressões.  Dessa forma
     'first (x + y)' retorna 'x' se 'inflag' for 'true' e 'y' se
     'inflag' for 'false'.  ('first (y + x)' fornece os mesmos
     resultados.)

     Também, escolhendo 'inflag' para 'true' e chamando 'part' ou
     'substpart' é o mesmo que chamar 'inpart' ou 'substinpart'.

     As funções afetadas pela posição do sinalizador 'inflag' são:
     'part', 'substpart', 'first', 'rest', 'last', 'length', a estrutura
     'for' ...  'in', 'map', 'fullmap', 'maplist', 'reveal' e
     'pickapart'.

 -- Função: inpart (<expr>, <n_1>, ..., <n_k>)
     É similar a 'part' mas trabalha sobre a representação interna da
     expressão em lugar da forma de exibição e dessa forma pode ser mais
     rápida uma vez que nenhuma formatação é realizada.  Cuidado deve
     ser tomado com relação à ordem de subexpressões em adições e
     produtos (uma vez que a ordem das variáveis na forma interna é
     muitas vezes diferente daquela na forma mostrada) e no manuseio com
     menos unário, subtração, e divisão (uma vez que esses operadores
     são removidos da expressão).  'part (x+y, 0)' ou 'inpart (x+y, 0)'
     retorna '+', embora com o objetivo de referirse ao operador isso
     deva ser abraçado por aspas duplas.  Por exemplo '... if inpart
     (%o9,0) = "+" then ...'.

     Exemplos:

          (%i1) x + y + w*z;
          (%o1)                      w z + y + x
          (%i2) inpart (%, 3, 2);
          (%o2)                           z
          (%i3) part (%th (2), 1, 2);
          (%o3)                           z
          (%i4) 'limit (f(x)^g(x+1), x, 0, minus);
                                            g(x + 1)
          (%o4)                 limit   f(x)
                                x -> 0-
          (%i5) inpart (%, 1, 2);
          (%o5)                       g(x + 1)

 -- Função: isolate (<expr>, <x>)
     Retorna <expr> com subexpressões que são adições e que não possuem
     <x> substituido por rótulos de expressão intermediária (esses sendo
     símbolos atômicos como '%t1', '%t2', ...).  Isso é muitas vezes
     útil para evitar expansões desnecessárias de subexpressões que não
     possuam a variável de interesse.  Uma vez que os rótulos
     intermediários são associados às subexpressões eles podem todos ser
     substituídos de volta por avaliação da expressão em que ocorrerem.

     'exptisolate' (valor padrão: 'false') se 'true' fará com que
     'isolate' examine expoentes de átomos (como '%e') que contenham
     <x>.

     'isolate_wrt_times' se 'true', então 'isolate' irá também isolar
     com relação a produtos.  Veja 'isolate_wrt_times'.

     Faça 'example (isolate)' para exemplos.

 -- Variável de opção: isolate_wrt_times
     Valor padrão: 'false'

     Quando 'isolate_wrt_times' for 'true', 'isolate' irá também isolar
     com relação a produtos.  E.g.  compare ambas as escolhas do
     comutador em

          (%i1) isolate_wrt_times: true$
          (%i2) isolate (expand ((a+b+c)^2), c);

          (%t2)                          2 a


          (%t3)                          2 b


                                    2            2
          (%t4)                    b  + 2 a b + a

                               2
          (%o4)               c  + %t3 c + %t2 c + %t4
          (%i4) isolate_wrt_times: false$
          (%i5) isolate (expand ((a+b+c)^2), c);
                               2
          (%o5)               c  + 2 b c + 2 a c + %t4

 -- Variável de opção: listconstvars
     Valor padrão: 'false'

     Quando 'listconstvars' for 'true', isso fará com que 'listofvars'
     inclua '%e', '%pi', '%i', e quaisquer variáveis declaradas
     contantes na lista seja retornado se aparecer na expressão que
     chamar 'listofvars'.  O comportamento padrão é omitir isso.

 -- Variável de opção: listdummyvars
     Valor padrão: 'true'

     Quando 'listdummyvars' for 'false', "variáveis dummy" na expressão
     não serão incluídas na lista retornada por 'listofvars'.  (O
     significado de "variável dummy" é o mesmo que em 'freeof'.
     "Variáveis dummy" são conceitos matemáticos como o índice de um
     somatório ou produtório, a variável limite, e a variável da
     integral definida.)  Exemplo:

          (%i1) listdummyvars: true$
          (%i2) listofvars ('sum(f(i), i, 0, n));
          (%o2)                        [i, n]
          (%i3) listdummyvars: false$
          (%i4) listofvars ('sum(f(i), i, 0, n));
          (%o4)                          [n]

 -- Função: listofvars (<expr>)
     Retorna uma lista de variáveis em <expr>.

     'listconstvars' se 'true' faz com que 'listofvars' inclua '%e',
     '%pi', '%i', e quaisquer variáveis declaradas constantes na lista é
     retornada se aparecer em <expr>.  O comportamento padrão é omitir
     isso.

          (%i1) listofvars (f (x[1]+y) / g^(2+a));
          (%o1)                     [g, a, x , y]
                                            1

 -- Função: lfreeof (<lista>, <expr>)
     Para cada um dos membros <m> de lista, chama 'freeof (<m>,
     <expr>)'.  Retorna 'false' se qualquer chamada a 'freeof' for feita
     e 'true' de outra forma.

 -- Função: lopow (<expr>, <x>)
     Retorna o menor expoente de <x> que explicitamente aparecer em
     <expr>.  Dessa forma

          (%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
          (%o1)                       min(a, 2)

 -- Função: lpart (<rótulo>, <expr>, <n_1>, ..., <n_k>)
     é similar a 'dpart' mas usa uma caixa rotulada.  Uma moldura
     rotulada é similar à que é produzida por 'dpart' mas a produzida
     por 'lpart' tem o nome na linha do topo.

 -- Função: multthru (<expr>)
 -- Função: multthru (<expr_1>, <expr_2>)
     Multiplica um fator (que pode ser uma adição) de <expr> pelos
     outros fatores de <expr>.  Isto é, <expr> é '<f_1> <f_2> ... <f_n>'
     onde ao menos um fator, digamos <f_i>, é uma soma de termos.  Cada
     termo naquela soma é multiplicado por outros fatores no produto.
     (A saber todos os fatores exceto <f_i>).  'multthru' não expande
     somas exponenciais.  Essa função é o caminho mais rápido para
     distribuir produtos (comutativos ou não) sobre adições.  Uma vez
     que quocientes são representados como produtos 'multthru' podem ser
     usados para dividir adições por produtos também.

     'multthru (<expr_1>, <expr_2>)' multiplica cada termo em <expr_2>
     (que pode ser uma adição ou uma equção) por <expr_1>.  Se <expr_1>
     não for por si mesmo uma adição então essa forma é equivalente a
     'multthru (<expr_1>*<expr_2>)'.

          (%i1) x/(x-y)^2 - 1/(x-y) - f(x)/(x-y)^3;
                                1        x         f(x)
          (%o1)             - ----- + -------- - --------
                              x - y          2          3
                                      (x - y)    (x - y)
          (%i2) multthru ((x-y)^3, %);
                                     2
          (%o2)             - (x - y)  + x (x - y) - f(x)
          (%i3) ratexpand (%);
                                     2
          (%o3)                   - y  + x y - f(x)
          (%i4) ((a+b)^10*s^2 + 2*a*b*s + (a*b)^2)/(a*b*s^2);
                                  10  2              2  2
                           (b + a)   s  + 2 a b s + a  b
          (%o4)            ------------------------------
                                            2
                                       a b s
          (%i5) multthru (%);  /* note que isso não expande (b+a)^10 */
                                                  10
                                 2   a b   (b + a)
          (%o5)                  - + --- + ---------
                                 s    2       a b
                                     s
          (%i6) multthru (a.(b+c.(d+e)+f));
          (%o6)            a . f + a . c . (e + d) + a . b
          (%i7) expand (a.(b+c.(d+e)+f));
          (%o7)         a . f + a . c . e + a . c . d + a . b

 -- Função: nounify (<f>)
     Retorna a forma substantiva do nome da função <f>.  Isso é
     necessário se se quer referir ao nome de uma função verbo como se
     esse nome fosse um substantivo.  Note que algumas funções verbos
     irão retornar sua forma substantiva senão puderem ser avaliadas
     para certos argumentos.  A forma substantiva é também a forma
     retornada se uma chamada de função é precedida por um apóstrofo.

 -- Função: nterms (<expr>)
     Retorna o número de termos que <expr> pode ter se for completamente
     expandida e nenhum cancelamento ou combinação de termos acontecer.
     Note expressões como 'sin (<expr>)', 'sqrt (<expr>)', 'exp
     (<expr>)', etc.  contam como apenas um termo independentemente de
     quantos termos <expr> tenha (se <expr> for uma adição).

 -- Função: op (<expr>)
     Retorna o operador principal da expressão <expr>.  'op (<expr>)' é
     equivalente a 'part (<expr>, 0)'.

     'op' retorna uma seqüência de caracteres se o operador principal
     for uma operador interno ou definido pelo usuário como prefixado,
     binário ou n-ário infixo, posfixado, matchfix ou nofix.  De outra
     forma, se <expr> for uma expressão de função subscrita, 'op'
     retorna uma função subscrita; nesse caso o valor de retorno não é
     um átomo.  De outro modo, <expr> é uma função de array ou uma
     expressão de função comum, e 'op' retorna um símbolo.

     'op' observa o valor do sinalizador global 'inflag'.

     'op' avalia seus argumentos.

     Veja também 'args'.

     Exemplos:

          (%i1) stringdisp: true$
          (%i2) op (a * b * c);
          (%o2)                          "*"
          (%i3) op (a * b + c);
          (%o3)                          "+"
          (%i4) op ('sin (a + b));
          (%o4)                          sin
          (%i5) op (a!);
          (%o5)                          "!"
          (%i6) op (-a);
          (%o6)                          "-"
          (%i7) op ([a, b, c]);
          (%o7)                          "["
          (%i8) op ('(if a > b then c else d));
          (%o8)                         "if"
          (%i9) op ('foo (a));
          (%o9)                          foo
          (%i10) prefix (foo);
          (%o10)                        "foo"
          (%i11) op (foo a);
          (%o11)                        "foo"
          (%i12) op (F [x, y] (a, b, c));
          (%o12)                        F
                                         x, y
          (%i13) op (G [u, v, w]);
          (%o13)                          G

 -- Função: operatorp (<expr>, <op>)
 -- Função: operatorp (<expr>, [<op_1>, ..., <op_n>])

     'operatorp (<expr>, <op>)' retorna 'true' se <op> for igual ao
     operador de <expr>.

     'operatorp (<expr>, [<op_1>, ..., <op_n>])' retorna 'true' se algum
     elementos de <op_1>, ..., <op_n> for igual ao operador de <expr>.

 -- Função: optimize (<expr>)
     Retorna uma expressão que produz o mesmo valor e efeito que <expr>
     mas faz de forma mais eficientemente por evitar a recomputação de
     subexpressões comuns.  'optimize' também tem o mesmo efeito de
     "colapsar" seus argumentos de forma que todas as subexpressões
     comuns são compartilhadas.  Faça 'example (optimize)' para
     exemplos.

 -- Variável de opção: optimprefix
     Valor padrão: '%'

     'optimprefix' é o prefixo usado para símbolos gerados pelo comando
     'optimize'.

 -- Função: ordergreat (<v_1>, ..., <v_n>)
     Escolhe aliases para as variáveis <v_1>, ..., <v_n> tais que <v_1>
     > <v_2> > ...  > <v_n>, e <v_n> > qualquer outra variável não
     mencionada como um argumento.

     Veja também 'orderless'.

 -- Função: ordergreatp (<expr_1>, <expr_2>)
     Retorna 'true' se <expr_2> precede <expr_1> na ordenação escolhida
     com a função 'ordergreat'.

 -- Função: orderless (<v_1>, ..., <v_n>)
     Escolhe aliases para as variáveis <v_1>, ..., <v_n> tais que <v_1>
     < <v_2> < ...  < <v_n>, and <v_n> < qualquer outra variável não
     mencionada como um argumento.

     Dessa forma a escala de ordenação completa é: constantes numéricas
     < constantes declaradas < escalares declarados < primeiro argumento
     para 'orderless' < ...  < último argumento para 'orderless' <
     variáveis que começam com A < ...  < variáveis que começam com Z <
     último argumento para 'ordergreat' < ...  < primeiro argumento para
     'ordergreat' < 'mainvar's - variáveis principais declaradas.

     Veja também 'ordergreat' e 'mainvar'.

 -- Função: orderlessp (<expr_1>, <expr_2>)
     Retorna 'true' se <expr_1> precede <expr_2> na ordenação escolhida
     pelo comando 'orderless'.

 -- Função: part (<expr>, <n_1>, ..., <n_k>)
     Retorna partes da forma exibida de 'expr'.  Essa função obtém a
     parte de 'expr' como especificado pelos índices <n_1>, ..., <n_k>.
     A primeira parte <n_1> de 'expr' é obtida, então a parte <n_2>
     daquela é obtida, etc.  O resultado é parte <n_k> de ...  parte
     <n_2> da parte <n_1> da 'expr'.

     'part' pode ser usada para obter um elemento de uma lista, uma
     linha de uma matriz, etc.

     Se o último argumento para uma função 'part' for uma lista de
     índices então muitas subexpressões serão pinçadas, cada uma
     correspondendo a um índice da lista.  Dessa forma 'part (x + y + z,
     [1, 3])' é 'z+x'.

     'piece' mantém a última expressão selecionada quando usando as
     funções 'part'.  Isso é escolhido durante a execução da função e
     dessa forma pode referir-se à função em si mesma como mostrado
     abaixo.

     Se 'partswitch' for escolhido para 'true' então 'end' é retornado
     quando uma parte selecionada de uma expressão não existir, de outra
     forma uma mensagem de erro é forncecida.

     Exemplo: 'part (z+2*y, 2, 1)' retorna 2.

     'example (part)' mostra exemplos adicionais.

 -- Função: partition (<expr>, <x>)
     Retorna uma lista de duas expressões.  Elas são (1) os fatores de
     <expr> (se essa expressão for um produto), os termos de <expr> (se
     isso for uma adição), ou a lista (se isso for uma lsita) que não
     contiver 'var' e, (2) os fatores, termos, ou lista que faz.

          (%i1) partition (2*a*x*f(x), x);
          (%o1)                     [2 a, x f(x)]
          (%i2) partition (a+b, x);
          (%o2)                      [b + a, 0]
          (%i3) partition ([a, b, f(a), c], a);
          (%o3)                  [[b, c], [a, f(a)]]

 -- Variável de opção: partswitch
     Valor padrão: 'false'

     Quando 'partswitch' for 'true', 'end' é retornado quando uma parte
     selecionada de uma expressão não existir, de outra forma uma
     mensagem de erro é fornecida.

 -- Função: pickapart (<expr>, <n>)
     Atribui rótulos de expressão intermediária a subexpressões de
     <expr> de comprimento <n>, um inteiro.  A subexpressões maiores ou
     menores não são atribuidos rótulos.  'pickapart' retorna uma
     expressão em termos de expressões intermediárias equivalentes à
     expressão original <expr>.

     Veja também 'part', 'dpart', 'lpart', 'inpart', e 'reveal'.

     Exemplos:

          (%i1) expr: (a+b)/2 + sin (x^2)/3 - log (1 + sqrt(x+1));
                                                    2
                                               sin(x )   b + a
          (%o1)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2
          (%i2) pickapart (expr, 0);

                                                    2
                                               sin(x )   b + a
          (%t2)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2

          (%o2)                          %t2
          (%i3) pickapart (expr, 1);

          (%t3)                - log(sqrt(x + 1) + 1)


                                            2
                                       sin(x )
          (%t4)                        -------
                                          3


                                        b + a
          (%t5)                         -----
                                          2

          (%o5)                    %t5 + %t4 + %t3
          (%i5) pickapart (expr, 2);

          (%t6)                 log(sqrt(x + 1) + 1)


                                            2
          (%t7)                        sin(x )


          (%t8)                         b + a

                                   %t8   %t7
          (%o8)                    --- + --- - %t6
                                    2     3
          (%i8) pickapart (expr, 3);

          (%t9)                    sqrt(x + 1) + 1


                                          2
          (%t10)                         x

                            b + a              sin(%t10)
          (%o10)            ----- - log(%t9) + ---------
                              2                    3
          (%i10) pickapart (expr, 4);

          (%t11)                     sqrt(x + 1)

                                2
                           sin(x )   b + a
          (%o11)           ------- + ----- - log(%t11 + 1)
                              3        2
          (%i11) pickapart (expr, 5);

          (%t12)                        x + 1

                             2
                        sin(x )   b + a
          (%o12)        ------- + ----- - log(sqrt(%t12) + 1)
                           3        2
          (%i12) pickapart (expr, 6);
                            2
                       sin(x )   b + a
          (%o12)       ------- + ----- - log(sqrt(x + 1) + 1)
                          3        2

 -- Variável de sistema: piece
     Mantém a ultima expressão selecionada quando usando funções 'part'.
     Isso é escolhido durante a execução da função e dessa forma pode
     referir-se à função em si mesma.

 -- Função: polarform (<expr>)
     Retorna uma expressão 'r %e^(%i theta)' equivalente a <expr>, tal
     que 'r' e 'theta' sejam puramente reais.

 -- Função: powers (<expr>, <x>)
     Fornece os expoentes de <x> que ocorrem em expressão <expr>.

     'load (powers)' chama essa função.

 -- Função: product (<expr>, <i>, <i_0>, <i_1>)
     Representa um produto dos velores de 'expr' com o índice <i>
     variando de <i_0> a <i_1>.  A forma substantiva ''product' é
     mostrada como um pi maiísculo.

     'product' avalia <expr> e os limites inferior e superior <i_0> e
     <i_1>, 'product' coloca um apóstrofo (não avalia) o índice <i>.

     Se os limites superiores e inferiores diferirem por um inteiro,
     <expr> é avaliada para cada valor do índice <i>, e o resultado um
     produto explícito.

     de outra forma, o intervalo do índice é indefinido.  Algumas regras
     são aplicads para simplificar o produto.  Quando a variável global
     'simpproduct' for 'true', regras adicionais são aplicadas.  Em
     alguns casos, simplificação um resultado que não é um produto; de
     outra forma, o resultado é uma forma substantiva ''product'.

     Veja também 'nouns' e 'evflag'.

     Exemplos:

          (%i1) product (x + i*(i+1)/2, i, 1, 4);
          (%o1)           (x + 1) (x + 3) (x + 6) (x + 10)
          (%i2) product (i^2, i, 1, 7);
          (%o2)                       25401600
          (%i3) product (a[i], i, 1, 7);
          (%o3)                 a  a  a  a  a  a  a
                                 1  2  3  4  5  6  7
          (%i4) product (a(i), i, 1, 7);
          (%o4)          a(1) a(2) a(3) a(4) a(5) a(6) a(7)
          (%i5) product (a(i), i, 1, n);
                                       n
                                     /===\
                                      ! !
          (%o5)                       ! !  a(i)
                                      ! !
                                     i = 1
          (%i6) product (k, k, 1, n);
                                         n
                                       /===\
                                        ! !
          (%o6)                         ! !  k
                                        ! !
                                       k = 1
          (%i7) product (k, k, 1, n), simpproduct;
          (%o7)                          n!
          (%i8) product (integrate (x^k, x, 0, 1), k, 1, n);
                                       n
                                     /===\
                                      ! !    1
          (%o8)                       ! !  -----
                                      ! !  k + 1
                                     k = 1
          (%i9) product (if k <= 5 then a^k else b^k, k, 1, 10);
                                        15  40
          (%o9)                        a   b

 -- Função: realpart (<expr>)
     Retorna a parte real de <expr>.  'realpart' e 'imagpart' irão
     trabalhar sobre expressões envolvendo funções trigonométricas e
     hiperbólicas, bem como raízes quadradas, logarítmos, e
     exponenciação.

 -- Função: rectform (<expr>)
     Retorna uma expressão 'a + b %i' equivalente a <expr>, tal que <a>
     e <b> sejam puramente reais.

 -- Função: rembox (<expr>, unlabelled)
 -- Função: rembox (<expr>, <rótulo>)
 -- Função: rembox (<expr>)
     Remove caixas de <expr>.

     'rembox (<expr>, unlabelled)' remove todas as caixas sem rótulos de
     <expr>.

     'rembox (<expr>, <rótulo>)' remove somente caixas contendo
     <rótulo>.

     'rembox (<expr>)' remove todas as caixas, rotuladas e nã rotuladas.

     Caixas são desenhadas pelas funções 'box', 'dpart', e 'lpart'.

     Exemplos:

          (%i1) expr: (a*d - b*c)/h^2 + sin(%pi*x);
                                            a d - b c
          (%o1)                sin(%pi x) + ---------
                                                2
                                               h
          (%i2) dpart (dpart (expr, 1, 1), 2, 2);
                                  """""""    a d - b c
          (%o2)               sin("%pi x") + ---------
                                  """""""      """"
                                               " 2"
                                               "h "
                                               """"
          (%i3) expr2: lpart (BAR, lpart (FOO, %, 1), 2);
                            FOO"""""""""""   BAR""""""""
                            "    """"""" "   "a d - b c"
          (%o3)             "sin("%pi x")" + "---------"
                            "    """"""" "   "  """"   "
                            """"""""""""""   "  " 2"   "
                                             "  "h "   "
                                             "  """"   "
                                             """""""""""
          (%i4) rembox (expr2, unlabelled);
                                            BAR""""""""
                             FOO"""""""""   "a d - b c"
          (%o4)              "sin(%pi x)" + "---------"
                             """"""""""""   "    2    "
                                            "   h     "
                                            """""""""""
          (%i5) rembox (expr2, FOO);
                                            BAR""""""""
                                 """""""    "a d - b c"
          (%o5)              sin("%pi x") + "---------"
                                 """""""    "  """"   "
                                            "  " 2"   "
                                            "  "h "   "
                                            "  """"   "
                                            """""""""""
          (%i6) rembox (expr2, BAR);
                             FOO"""""""""""
                             "    """"""" "   a d - b c
          (%o6)              "sin("%pi x")" + ---------
                             "    """"""" "     """"
                             """"""""""""""     " 2"
                                                "h "
                                                """"
          (%i7) rembox (expr2);
                                            a d - b c
          (%o7)                sin(%pi x) + ---------
                                                2
                                               h

 -- Função: sum (<expr>, <i>, <i_0>, <i_1>)
     Representa um somatório dos valores de <expr> com o índice <i>
     variando de <i_0> a <i_1>.  A forma substantiva ''sum' é mostrada
     com uma letra sigma maiúscula.  'sum' avalia seu somando <expr> e
     limites inferior e superior <i_0> e <i_1>, 'sum' coloca apóstrofo
     (não avalia) o índice <i>.

     Se os limites superiores e inferiores diferirem de um número
     inteiro, o somatoriando <expr> é avaliado para cada valor do índice
     do somatório <i>, e o resultado é uma adição explícita.

     De outra forma, o intervalo dos índices é indefinido.  Algumas
     regras são aplicadas para simplificar o somatório.  Quando a
     variável global 'simpsum' for 'true', regras adicionais são
     aplicadas.  Em alguns casos, simplificações retornam um resultado
     que não é um somatório; de outra forma, o resultado é uma forma
     substantiva ''sum'.

     Quando o 'evflag' (sinalizador de avaliação) 'cauchysum' for
     'true', um produto de somatórios é mostrado como um produto de
     Cauchy, no qual o índice do somatório mais interno é uma função de
     índice de um nível acima, em lugar de variar independentemente.

     A variável global 'genindex' é o prefixo alfabético usado para
     gerar o próximo índice do somatório, quando um índice
     automaticamente gerado for necessário.

     'gensumnum' é o sufixo numérico usando para gerar o próximo índice
     do somatório, quando um índice gerado automaticamente for
     necessário.  Quando 'gensumnum' for 'false', um índice gerado
     automaticamente é somente 'genindex' sem sufixo numérico.

     Veja também 'sumcontract', 'intosum', 'bashindices', 'niceindices',
     'nouns', 'evflag', e 'zeilberger'.

     Exemplos:

          (%i1) sum (i^2, i, 1, 7);
          (%o1)                          140
          (%i2) sum (a[i], i, 1, 7);
          (%o2)           a  + a  + a  + a  + a  + a  + a
                           7    6    5    4    3    2    1
          (%i3) sum (a(i), i, 1, 7);
          (%o3)    a(7) + a(6) + a(5) + a(4) + a(3) + a(2) + a(1)
          (%i4) sum (a(i), i, 1, n);
                                      n
                                     ====
                                     \
          (%o4)                       >    a(i)
                                     /
                                     ====
                                     i = 1
          (%i5) sum (2^i + i^2, i, 0, n);
                                    n
                                   ====
                                   \       i    2
          (%o5)                     >    (2  + i )
                                   /
                                   ====
                                   i = 0
          (%i6) sum (2^i + i^2, i, 0, n), simpsum;
                                        3      2
                             n + 1   2 n  + 3 n  + n
          (%o6)             2      + --------------- - 1
                                            6
          (%i7) sum (1/3^i, i, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o7)                        >    --
                                      /      i
                                      ====  3
                                      i = 1
          (%i8) sum (1/3^i, i, 1, inf), simpsum;
                                          1
          (%o8)                           -
                                          2
          (%i9) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
                                        inf
                                        ====
                                        \     1
          (%o9)                      30  >    --
                                        /      2
                                        ====  i
                                        i = 1
          (%i10) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
                                            2
          (%o10)                       5 %pi
          (%i11) sum (integrate (x^k, x, 0, 1), k, 1, n);
                                      n
                                     ====
                                     \       1
          (%o11)                      >    -----
                                     /     k + 1
                                     ====
                                     k = 1
          (%i12) sum (if k <= 5 then a^k else b^k, k, 1, 10));
          Incorrect syntax: Too many )'s
          else b^k, k, 1, 10))
                            ^
          (%i12) linenum:11;
          (%o11)                         11
          (%i12) sum (integrate (x^k, x, 0, 1), k, 1, n);
                                      n
                                     ====
                                     \       1
          (%o12)                      >    -----
                                     /     k + 1
                                     ====
                                     k = 1
          (%i13) sum (if k <= 5 then a^k else b^k, k, 1, 10);
                    10    9    8    7    6    5    4    3    2
          (%o13)   b   + b  + b  + b  + b  + a  + a  + a  + a  + a

 -- Função: lsum (<expr>, <x>, <L>)
     Representas a adição de <expr> a cada elemento <x> em <L>.

     Uma forma substantiva ''lsum' é retornada se o argumento <L> não
     avaliar para uma lista.

     Exemplos:

          (%i1) lsum (x^i, i, [1, 2, 7]);
                                      7    2
          (%o1)                      x  + x  + x
          (%i2) lsum (i^2, i, rootsof (x^3 - 1, x));
                               ====
                               \      2
          (%o2)                 >    i
                               /
                               ====
                                             3
                               i in rootsof(x  - 1, x)

 -- Função: verbify (<f>)
     Retorna a forma verbal da função chamada <f>.

     Veja também 'verb', 'noun', e 'nounify'.

     Exemplos:

          (%i1) verbify ('foo);
          (%o1)                          foo
          (%i2) :lisp $%
          $FOO
          (%i2) nounify (foo);
          (%o2)                          foo
          (%i3) :lisp $%
          %FOO


File: maxima.info,  Node: Simplificação,  Next: Montando Gráficos,  Prev: Expressões,  Up: Top

7 Simplificação
***************

* Menu:

* Funções e Variáveis Definidas para Simplificação::  


File: maxima.info,  Node: Funções e Variáveis Definidas para Simplificação,  Prev: Simplificação,  Up: Simplificação

7.1 Funções e Variáveis Definidas para Simplificação
====================================================

 -- Variável de sistema: askexp
     Quando 'asksign' é chamada, 'askexp' é a expressão que 'asksign'
     está testando.

     Antigamente, era possível para um usuário inspecionar 'askexp'
     entrando em uma parada do Maxima com control-A.

 -- Função: askinteger (<expr>, integer)
 -- Função: askinteger (<expr>)
 -- Função: askinteger (<expr>, even)
 -- Função: askinteger (<expr>, odd)

     'askinteger (<expr>, integer)' tenta determinar a partir da base de
     dados do 'assume' se <expr> é um inteiro.  'askinteger' pergunta ao
     usuário pela linha de comando se isso não puder ser feito de outra
     forma, e tenta instalar a informação na base de dados do 'assume'
     se for possível.  'askinteger (<expr>)' é equivalente a 'askinteger
     (<expr>, integer)'.

     'askinteger (<expr>, even)' e 'askinteger (<expr>, odd)' da mesma
     forma tentam determinar se <expr> é um inteiro par ou inteiro
     ímpar, respectivamente.

 -- Função: asksign (<expr>)
     Primeiro tenta determinar se a expressão especificada é positiva,
     negativa, ou zero.  Se isso não for possível, 'asksign' pergunta ao
     usuário pelas questões necessárias para completar a sua dedução.
     As respostas do usuário são guardadas na base de dados pelo tempo
     que durar a computação corrente.  O valor de retorno de 'asksign' é
     um entre 'pos', 'neg', ou 'zero'.

 -- Função: demoivre (<expr>)
 -- Variável de opção: demoivre

     A função 'demoivre (expr)' converte uma expressão sem escolher a
     variável global 'demoivre'.

     Quando a variável 'demoivre' for 'true', exponenciais complexas são
     convertidas em expressões equivalentes em termos de funções
     circulares: 'exp (a + b*%i)' simplifica para '%e^a * (cos(b) +
     %i*sin(b))' se 'b' for livre de '%i'.  'a' e 'b' não são
     expandidos.

     O valor padrão de 'demoivre' é 'false'.

     'exponentialize' converte funções circulares e hiperbólicas para a
     forma exponencial.  'demoivre' e 'exponentialize' não podem ambas
     serem 'true' ao mesmo tempo.

 -- Variável de opção: domain
     Valor padrão: 'real'

     Quando 'domain' for escolhida para 'complex', 'sqrt (x^2)'
     permanecerá 'sqrt (x^2)' em lugar de retornar 'abs(x)'.

 -- Função: expand (<expr>)
 -- Função: expand (<expr>, <p>, <n>)
     Expande a expressão <expr>.  Produtos de somas e somas
     exponenciadas são multiplicadas para fora, numeradores de
     expressões racionais que são adições são quebradas em suas
     respectivas parcelas, e multiplicação (comutativa e não comutativa)
     é distribuída sobre a adição em todos os níveis de <expr>.

     Para polinômios se pode usar freqüêntemente 'ratexpand' que possui
     um algorítmo mais eficiente.

     'maxnegex' e 'maxposex' controlam o máximo expoente negativo e o
     máximo expoente positivo, respectivamente, que irão expandir.

     'expand (<expr>, <p>, <n>)' expande <expr>, usando <p> para
     'maxposex' e <n> para 'maxnegex'.  Isso é útil com o objetivo de
     expandir partes mas não tudo em uma expressão.

     'expon' - o expoente da maior potência negativa que é
     automaticamente expandida (independente de chamadas a 'expand').
     Por Exemplo se 'expon' for 4 então '(x+1)^(-5)' não será
     automaticamente expandido.

     'expop' - o maior expoente positivo que é automaticamente
     expandido.  Dessa forma '(x+1)^3', quando digitado, será
     automaticamente expandido somente se 'expop' for maior que ou igual
     a 3.  Se for desejado ter '(x+1)^n' expandido onde 'n' é maior que
     'expop' então executando 'expand ((x+1)^n)' trabalhará somente se
     'maxposex' não for menor que 'n'.

     O sinalizador 'expand' usado com 'ev' causa expansão.

     O arquivo 'simplification/facexp.mac' contém muitas funções
     relacionadas (em particular 'facsum', 'factorfacsum' e
     'collectterms', que são chamadas automaticamente) e variáveis
     ('nextlayerfactor' e 'facsum_combine') que fornecem ao usuário com
     a habilidade para estruturar expressões por expansão controlada.
     Descrições breves de função estão disponível em
     'simplification/facexp.usg'.  Um arquivo demonstrativo está
     disponível fazendo 'demo("facexp")'.

 -- Função: expandwrt (<expr>, <x_1>, ..., <x_n>)
     Expande a expressão 'expr' com relação às variáveis <x_1>, ...,
     <x_n>.  Todos os produtos envolvendo as variáveis aparecem
     explicitamente.  A forma retornada será livre de produtos de somas
     de expressões que não estão livres das variáveis.  <x_1>, ...,
     <x_n> podem ser variáveis, operadores, ou expressões.

     Por padrão, denominadores não são expandidos, mas isso pode ser
     controlado através do comutador 'expandwrt_denom'.

     Essa função, 'expandwrt', não é automaticamente chamada a partir de
     'simplification/stopex.mac'.

 -- Variável de opção: expandwrt_denom
     Valor padrão: 'false'

     'expandwrt_denom' controla o tratamento de expressões racionais por
     'expandwrt'.  Se 'true', então ambos o numerador e o denominador da
     expressão serão expandidos conforme os argumentos de 'expandwrt',
     mas se 'expandwrt_denom' for 'false', então somente o numerador
     será expandido por aquele caminho.

 -- Função: expandwrt_factored (<expr>, <x_1>, ..., <x_n>)
     é similar a 'expandwrt', mas trata expressões que são produtos um
     tanto quanto diferentemente.  'expandwrt_factored' expande somente
     sobre esses fatores de 'expr' que contiverem as variáveis <x_1>,
     ..., <x_n>.

     Essa função é automaticamente chamada a aprtir de
     'simplification/stopex.mac'.

 -- Variável de opção: expon
     Valor padrão: 0

     'expon' é o expoente da maior potência negativa que é
     automaticamente expandido (independente de chamadas a 'expand').
     Por exemplo, se 'expon' for 4 então '(x+1)^(-5)' não será
     automaticamente expandido.

 -- Função: exponentialize (<expr>)
 -- Variável de opção: exponentialize

     A função 'exponentialize (expr)' converte funções circulares e
     hiperbólicas em <expr> para exponenciais, sem escolher a variável
     global 'exponentialize'.

     Quando a variável 'exponentialize' for 'true', todas as funções
     circulares e hiperbólicas são convertidas para a forma exponencial.
     O valor padrão é 'false'.

     'demoivre' converte exponenciais complexas em funções circulares.
     'exponentialize' e 'demoivre' não podem ambas serem 'true' ao mesmo
     tempo.

 -- Variável de opção: expop
     Valor padrão: 0

     'expop' - o maior expoente positivo que é automaticamente
     expandido.  Dessa forma '(x+1)^3', quando digitado, será
     automaticamente expandido somente se 'expop' for maior que ou igual
     a 3.  Se for desejado ter '(x+1)^n' expandido onde 'n' é maior que
     'expop' então executando 'expand ((x+1)^n)' trabalhará somente se
     'maxposex' não for menor que 'n'.

 -- Variável de opção: factlim
     Valor padrão: -1

     'factlim' especifica o maior fatorial que é automaticamente
     expandido.  Se for -1 então todos os inteiros são expandidos.

 -- Função: intosum (<expr>)
     Move fatores multiplicativos fora de um somatório para dentro.  Se
     o índice for usado na expressão de fora, então a função tentará
     achar um índice razoável, o mesmo que é feito para 'sumcontract'.
     Isso é essencialmente a idéia inversa da propriedade 'outative' de
     somatórios, mas note que isso não remove essa propriedade, somente
     pula sua verificação.

     Em alguns casos, um 'scanmap (multthru, <expr>)' pode ser
     necessário antes de 'intosum'.

 -- Declaração: lassociative
     'declare (g, lassociative)' diz ao simplificador do Maxima que 'g'
     é associativa à esquerda.  E.g., 'g (g (a, b), g (c, d))' irá
     simplificar para 'g (g (g (a, b), c), d)'.

 -- Declaração: linear
     Uma das propriedades operativas do Maxima.  Para funções de uma
     única variável 'f' então declarada, a "expansão" 'f(x + y)' retorna
     'f(x) + f(y)', 'f(a*x)' retorna 'a*f(x)' tomando lugar onde 'a' for
     uma "constante".  para funções de dois ou mais argumentos,
     "linearidade" é definida para ser como no caso de 'sum' ou
     'integrate', i.e., 'f (a*x + b, x)' retorna 'a*f(x,x) + b*f(1,x)'
     para 'a' e 'b' livres de 'x'.

     'linear' é equivalente a 'additive' e 'outative'.  Veja também
     'opproperties'.

 -- Declaração: mainvar
     Você pode declarar variáveis para serem 'mainvar' (variável
     principal).  A escala de ordenação para átomos é essencialmente:
     números < constantes (e.g., '%e', '%pi') < escalares < outras
     variáveis < mainvars.  E.g., compare 'expand ((X+Y)^4)' com
     '(declare (x, mainvar), expand ((x+y)^4))'.  (Nota: Cuidado deve
     ser tomado se você eleger o uso desse recurso acima.  E.g., se você
     subtrair uma expressão na qual 'x' for uma 'mainvar' de uma na qual
     'x' não seja uma 'mainvar', resimplificação e.g.  com 'ev (expr,
     simp)' pode ser necessária se for para ocorrer um cancelamento.
     Também, se você grava uma expressão na qual 'x' é uma 'mainvar',
     você provavelmente pode também gravar 'x'.)

 -- Variável de opção: maxapplydepth
     Valor padrão: 10000

     'maxapplydepth' é a máxima definição para a qual 'apply1' e
     'apply2' irão pesquisar.

 -- Variável de opção: maxapplyheight
     Valor padrão: 10000

     'maxapplyheight' é a elevação máxima a qual 'applyb1' irá alcançar
     antes de abandonar.

 -- Variável de opção: maxnegex
     Valor padrão: 1000

     'maxnegex' é o maior expoente negativo que será expandido pelo
     comando 'expand' (veja também 'maxposex').

 -- Variável de opção: maxposex
     Valor padrão: 1000

     'maxposex' é o maior expoente que será expandido com o comando
     'expand' (veja também 'maxnegex').

 -- Declaração: multiplicative
     'declare (f, multiplicative)' diz ao simplificador do Maxima que
     'f' é multiplicativa.

       1. Se 'f' for uma função de uma única variável, sempre que o
          simplificador encontrar 'f' aplicada a um produto, 'f'
          distribue sobre aquele produto.  E.g., 'f(x*y)' simplifica
          para 'f(x)*f(y)'.
       2. Se 'f' é uma função de 2 ou mais argumentos,
          multiplicatividade é definida como multiplicatividade no
          primeiro argumento para 'f', e.g., 'f (g(x) * h(x), x)'
          simplifica para 'f (g(x) ,x) * f (h(x), x)'.

     Essa simplificação não ocorre quando 'f' é aplicada a expressões da
     forma 'product (x[i], i, m, n)'.

 -- Variável de opção: negdistrib
     Valor padrão: 'true'

     Quando 'negdistrib' for 'true', -1 distribue sobre uma expressão.
     E.g., '-(x + y)' transforma-se em '- y - x'.  Mudando o valor de
     'negdistrib' para 'false' permitirá que '- (x + y)' seja mostrado
     como foi escrito.  Isso algumas vezes é útil mas seja muito
     cuidadoso: como o sinalizador 'simp', isso é um sinalizador que
     você pode não querer escolher para 'false' como algo natural ou
     necessário com excessão de usar localmente no seu Maxima.

 -- Variável de opção: negsumdispflag
     Valor padrão: 'true'

     Quando 'negsumdispflag' for 'true', 'x - y' é mostrado como 'x - y'
     em lugar de como '- y + x'.  Escolhendo isso para 'false' faz com
     que a verificação especial em visualização para a diferença das
     duas expressões não seja concluída.  Uma aplicação é que dessa
     forma 'a + %i*b' e 'a - %i*b' podem ambos serem mostrados pelo
     mesmo caminho.

 -- Símbolo especial: noeval
     'noeval' suprime a fase de avaliação de 'ev'.  Isso é útil em
     conjunção com outros comutadores e para fazer com que expressões
     sejam resimplificadas sem serem reavaliadas.

 -- Declaração: noun
     'noun' é uma das opções do comando 'declare'.  Essa opção faz com
     que um função seja declarada como "noun" (substantivo),
     significando que ela não deve ser avaliada automaticamente.

 -- Variável de opção: noundisp
     Valor padrão: 'false'

     Quando 'noundisp' for 'true', substantivos (nouns) são mostrados
     com um apóstrofo.  Esse comutador é sempre 'true' quando mostrando
     definições de função.

 -- Símbolo especial: nouns
     'nouns' é um 'evflag' (sinalizador de avaliação).  Quando usado
     como uma opção para o comando 'ev', 'nouns' converte todas as
     formas substantivas ("noun") que ocorrem na expressão que está
     sendo avaliada para verbos ("verbs"), i.e., avalia essas
     expressões.  Veja também 'noun', 'nounify', 'verb', e 'verbify'.

 -- Símbolo especial: numer
     'numer' faz com que algumas funções matemáticas (incluindo
     exponenciação) com argumentos numéricos sejam avaliados em ponto
     flutuante.  Isso faz com que variáveis em 'expr' às quais tenham
     sido dados valores numéricos a elas sejam substituídas pelos seus
     valores correspondentes.  'numer' também escolhe o sinalizador
     'float' para 'on'.

 -- Função: numerval (<x_1>, <expr_1>, ..., <var_n>, <expr_n>)
     Declara as variáveis 'x_1', ..., <x_n> para terem valores numéricos
     iguais a 'expr_1', ..., 'expr_n'.  O valor numérico é avaliado e
     substituido para a variável em quaisquer expressões na qual a
     variável ocorra se o sinalizador 'numer' for 'true'.  Veja também
     'ev'.

     As expressões 'expr_1', ..., 'expr_n' podem ser quaisquer
     expressões, não necessariamente numéricas.

 -- Variável de sistema: opproperties

     'opproperties' é a lista de propriedades de operadores especiais
     reconhecidas pelo simplificador do Maxima: 'linear', 'additive',
     'multiplicative', 'outative' (veja logo abaixo), 'evenfun',
     'oddfun', 'commutative', 'symmetric', 'antisymmetric', 'nary',
     'lassociative', 'rassociative'.

 -- Variável de opção: opsubst
     Valor padrão: 'true'

     Quando 'opsubst' for 'false', 'subst' não tenta substituir dentro
     de um operador de uma expressão.  E.g., '(opsubst: false, subst
     (x^2, r, r+r[0]))' irá trabalhar.

 -- Declaração: outative
     'declare (f, outative)' diz ao simplificador do Maxima que fatores
     constantes no argumento de 'f' podem ser puxados para fora.

       1. Se 'f' for uma função de uma única variável, sempre que o
          simplificador encontrar 'f' aplicada a um produto, aquele
          produto será particionado em fatores que são constantes e
          fatores que não são e os fatores constantes serão puxados para
          fora.  E.g., 'f(a*x)' simplificará para 'a*f(x)' onde 'a' é
          uma constante.  Fatores de constantes não atômicas não serão
          puxados para fora.
       2. Se 'f' for uma função de 2 ou mais argumentos, a colocação
          para fora é definida como no caso de 'sum' ou 'integrate',
          i.e., 'f (a*g(x), x)' irá simplificar para 'a * f(g(x), x)'
          sendo 'a' livre de 'x'.

     'sum', 'integrate', e 'limit' são todas 'outative'.

 -- Declaração: posfun
     'declare (f, posfun)' declara 'f' para ser uma função positiva.
     'is (f(x) > 0)' retorna 'true'.

 -- Função: radcan (<expr>)
     Simplifica <expr>, que pode conter logarítmos, exponenciais, e
     radicais, convertendo essa expressão em uma forma que é canônica
     sobre uma ampla classe de expressões e uma dada ordenação de
     variáveis; isto é, todas formas funcionalmente equivalentes são
     mapeadas em uma única forma.  Para uma classe um tanto quanto ampla
     de expressões, 'radcan' produz uma forma regular.  Duas expressões
     equivalentes nessa classe não possuem necessáriamente a mesma
     aparência, mas suas diferenças podem ser simplificadas por 'radcan'
     para zero.

     Para algumas expressões 'radcan' é que consome inteiramente o
     tempo.  Esse é o custo de explorar certos relacionamentos entre os
     componentes da expressão para simplificações baseadas sobre
     fatoração e expansões de fração-parcial de expoentes.

     Quando '%e_to_numlog' for 'true', '%e^(r*log(expr))' simplifica
     para 'expr^r' se 'r' for um número racional.

     Quando 'radexpand' for 'false', certas transformações são inibidas.
     'radcan (sqrt (1-x))' permanece 'sqrt (1-x)' e não é simplificada
     para '%i sqrt (x-1)'.  'radcan (sqrt (x^2 - 2*x + 11))' permanece
     'sqrt (x^2 - 2*x + 1)' e não é simplificada para 'x - 1'.

     'example (radcan)' mostra alguns exemplos.

 -- Variável de opção: radexpand
     Valor padrão: 'true'

     'radexpand' controla algumas simplificações de radicais.

     Quando 'radexpand' for 'all', faz com que n-ésimas raízes de
     fatores de um produto que são potências de n sejam puxados para
     fora do radical.  E.g.  Se 'radexpand' for 'all', 'sqrt (16*x^2)'
     simplifica para '4*x'.

     Mais particularmente, considere 'sqrt (x^2)'.
        * Se 'radexpand' for 'all' or 'assume (x > 0)' tiver sido
          executado, 'sqrt(x^2)' simplifica para 'x'.
        * Se 'radexpand' for 'true' e 'domain' for 'real' (isso é o
          padrão), 'sqrt(x^2)' simplifica para 'abs(x)'.
        * Se 'radexpand' for 'false', ou 'radexpand' for 'true' e
          'domain' for 'complex', 'sqrt(x^2)' não é simplificado.

     Note que 'domain' somente interessa quando 'radexpand' for 'true'.

 -- Variável de opção: radsubstflag
     Valor padrão: 'false'

     'radsubstflag', se 'true', permite a 'ratsubst' fazer substituições
     tais como 'u' por 'sqrt (x)' em 'x'.

 -- Declaração: rassociative
     'declare (g, rassociative)' diz ao simplificador do Maxima que 'g'
     é associativa à direita.  E.g., 'g(g(a, b), g(c, d))' simplifica
     para 'g(a, g(b, g(c, d)))'.

 -- Função: scsimp (<expr>, <rule_1>, ..., <rule_n>)
     Simplificação Seqüêncial Comparativa (método devido a Stoute).
     'scsimp' tenta simplificar <expr> conforme as regras <rule_1>, ...,
     <rule_n>.  Se uma expressão pequena for obtida, o processo
     repete-se.  De outra forma após todas as simplificações serem
     tentadas, 'scsimp' retorna a resposta original.

     'example (scsimp)' mostra alguns exemplos.

 -- Variável de opção: simpsum
     Valor padrão: 'false'

     Quando 'simpsum' for 'true', o resultado de uma 'sum' é
     simplificado.  Essa simplificação pode algumas vezes estar apta a
     produzir uma forma fechada.  Se 'simpsum' for 'false' ou se a forma
     com apóstrofo ''sum' for usada, o valor é uma forma substantiva
     aditiva que é uma representação da notação sigma usada em
     matemática.

 -- Função: sumcontract (<expr>)
     Combina todas as parcelas de um somatório que possuem limites
     superiores e inferiores que diferem por constantes.  O resultado é
     uma expressão contendo um somatório para cada escolha de cada tais
     somatórios adicionados a todos os termos extras apropriados que
     tiveram de ser extraídos para a forma dessa adição.  'sumcontract'
     combina todas as somas compatíveis e usa os indices de uma as somas
     se puder, e então tenta formar um índice razoável se não for usar
     qualquer dos fornecidos.

     Isso pode ser necessário fazer um 'intosum (<expr>)' antes de
     'sumcontract'.

 -- Variável de opção: sumexpand
     Valor padrão: 'false'

     Quando 'sumexpand' for 'true', produtos de somas e somas
     exponeciadas simplificam para somas aninhadas.

     Veja também 'cauchysum'.

     Exemplos:

          (%i1) sumexpand: true$
          (%i2) sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
                               m      n
                              ====   ====
                              \      \
          (%o2)                >      >     f(i1) g(i2)
                              /      /
                              ====   ====
                              i1 = 0 i2 = 0
          (%i3) sum (f (i), i, 0, m)^2;
                               m      m
                              ====   ====
                              \      \
          (%o3)                >      >     f(i3) f(i4)
                              /      /
                              ====   ====
                              i3 = 0 i4 = 0

 -- Variável de opção: sumsplitfact
     Valor padrão: 'true'

     Quando 'sumsplitfact' for 'false', 'minfactorial' é aplicado após
     um 'factcomb'.

 -- Declaração: symmetric
     'declare (h, symmetric)' diz ao simplificador do Maxima que 'h' é
     uma função simétrica.  E.g., 'h (x, z, y)' simplifica para 'h (x,
     y, z)'.

     'commutative' é sinônimo de 'symmetric'.

 -- Função: unknown (<expr>)
     Retorna 'true' se e somente se <expr> contém um operador ou função
     não reconhecida pelo simplificador do Maxima.


File: maxima.info,  Node: Montando Gráficos,  Next: Entrada e Saída,  Prev: Simplificação,  Up: Top

8 Montando Gráficos
*******************

* Menu:

* Funções e Variáveis Definidas para Montagem de Gráficos::    


File: maxima.info,  Node: Funções e Variáveis Definidas para Montagem de Gráficos,  Prev: Montando Gráficos,  Up: Montando Gráficos

8.1 Funções e Variáveis Definidas para Montagem de Gráficos
===========================================================

 -- Função: contour_plot (<expr>, <x_range>, <y_range>, <opções>, ...)

     Monta gráficos de contorno (curvas de nível) de <expr> sobre a
     região <x_range> por <y_range>.  Quaisquer argumentos adicionals
     são tratados da mesma forma que em 'plot3d'.

     'contour_plot' somente trabalha quando o formato do gráfico for
     'gnuplot' ou 'gnuplot_pipes'.

     Veja também 'implicit_plot'.

     Exemplos:

          (%i1) contour_plot (x^2 + y^2, [x, -4, 4], [y, -4, 4]);
          (%o1)
          (%i2) contour_plot (sin(y) * cos(x)^2, [x, -4, 4], [y, -4, 4]);
          (%o2)
          (%i3) F(x, y) := x^3 + y^2;
                                             3    2
          (%o3)                  F(x, y) := x  + y
          (%i4) contour_plot (F, [u, -4, 4], [v, -4, 4]);
          (%o4)
          (%i5) contour_plot (F, [u, -4, 4], [v, -4, 4], [gnuplot_preamble, "set size ratio -1"]);
          (%o5)
          (%i6) set_plot_option ([gnuplot_preamble, "set cntrparam levels 12"])$

          (%i7) contour_plot (F, [u, -4, 4], [v, -4, 4]);

 -- Variável: in_netmath
     Valor padrão: 'false'

     Quando 'in_netmath' é 'true', 'plot3d' imprime uma saída OpenMath
     para o console se 'plot_format' é 'openmath'; caso contrário
     'in_netmath' (mesmo se 'true') não tem efeito.  'in_netmath' não
     tem efeito sobre 'plot2d'.

 -- Função: plot2d (<expr>, <x_range>, ..., <opções>, ...)
 -- Função: plot2d ([<expr_1>, ..., <expr_n>], ..., <opções>, ...)
 -- Função: plot2d ([<expr_1>, ..., <expr_n>], <x_range>,..., <opções>,
          ...)

     onde <expr>, <expr_1>, ..., <expr_n> pode ser uma entre expressões,
     ou funções do Lisp ou do Maxima ou operadores, ou uma lista com
     qualquer das formas: '[discrete, [<x1>, ..., <xn>], [<y1>, ...,
     <yn>]]', '[discrete, [[<x1>, <y1>], ..., [<xn>, ..., <yn>]]' ou
     '[parametric, <x_expr>, <y_expr>, <t_range>]'.

     Mostra um gráfico de uma ou mais expressões como uma função de uma
     variável.

     'plot2d' monta o gráfico da expressão <expr> ou muitas expressões
     '[<name_1>, ..., <name_n>]'.  As expressões que não forem
     paramétricas ou discretas podem todas depender somente de uma
     variável <var> e isso torna obrigatório o uso de <x_range> para
     nome daquela variável e fornece seus valores de máximo e de mínimo,
     usando a sintaxe: '[<variable>, <min>, <max>]'.  O gráfico irá
     mostrar o eixo horizontal associado aos valores de <min> e de
     <max>.

     Uma expressão a ser montado o gráfico pode também ser fornecida na
     forma discreta ou na forma paramétrica.  A saber, como uma lista
     iniciando-se com a palavra "discrete" ou a palavra "parametric".  A
     palavra chave <discrete> deve ser seguida por duas listas de
     valores, ambas com o mesmo comprimento, que são as coodenadas
     horizontais e as coordenadas verticais de um conjunto de pontos;
     alternativamente, as coordenadas de cada ponto pode ser colocada
     dentro de uma lista com dois valores, e todas as coordenadas dos
     pontos podem estar dentro de outra lista.  A palavra chave
     <parametric> deve ser seguida por douas expressões <x_expr> e
     <y_expr>, e um intervalo da forma '[<param>, <min>, <max>]'.  As
     duas expressões devem depender somente do parâmetro <param>, e o
     gráfico irá mostrar o caminho percorrido pelo ponto com coordenadas
     (<x_expr>, <y_expr>) com <param> variando de <min> a <max>.

     O intervalo do eixo vertical não é obrigatório.  É somente mais uma
     das opções para o comando, com a sintaxe: '[y, <min>, <max>]'.  Se
     aquela opção for usada, o gráfico irá mostrar aquele intervalo
     completo, mesmo se a expressão não ocupe todo aquele intervalo.  De
     outra forma, se um intervalo vertical não for especificado através
     de 'set_plot_option', as extremidade do eixo vertical serão
     encontrada automaticamente.

     Todas as outras opções podem também serem listas, iniciando-se com
     o nome da opção.  A opção <xlabel> pode ser usada para fornecer um
     ótulo para o eixo horizontal; se aquela opção não for usada, o eixo
     horizontal irá ser rotulado com o nome da variável especificada em
     <x_range>, ou com a expressão <x_expr> no caso de apenas uma
     expressão paramétrica, ou isso irá ser deichado em branco de outra
     forma.

     Um rótulo para o eixo vertical pode ser fornecido com a opção
     <ylabel>.  Se existir somente uma expressão a ser montado o gráfico
     e a opção <ylabel> não tiver sido usada, o eixo vertical irá ser
     rotulado com aquela expressão, a menos que ela seja muito larga, ou
     com a expressão <y_expr> se a expressão for paramétrica, ou com o
     texto "discrete data" se a expressão for discreta.

     As opções '[logx]' e '[logy]' não precisam de quaisquer parâmetros.
     Elas irão tornar os eixos horizontal e vertical sejam escritos em
     escala logarítmica.

     Se houverem muitas expressões para serem montados os gráficos
     respectivos, uma legenda irá ser escrita para identificar cada uma
     das expressões.  Os rótulos que podem ser usados naquela legenda
     podem ser fornecidos com a opção <legend>.  Se a opção <legend> não
     for usada, Maxima irá criar rótulos a partir das expressões.

     Por padrão, as expressões terão seus gráficos montados como um
     conjunto de segmentos de reta saltando pontos adjacentes dentro de
     um conjunt de pontos que é um dos fornecidos entre a forma
     <discrete>, ou calculado automaticamente a partir da expressão
     fornecida, usando um algorítmo que automaticamente adapta os passos
     entre os pontos usando como uma estimativa inicial do total número
     de pontos o conjunto de valores com a opção <nticks>.  A opção
     <style> pode ser usada para fazer uma das expressões serem
     representadas como um conjunto de pontos isolados, ou como pontos e
     segmentos de reta.

     Existem muitas opções globais armazenadas na lsita <plot_options>
     que pode ser modificada com a função 'set_plot_option'; qualque
     daquelas opções globais pode ser sobrescrita com opções fornecidas
     no comando <plot2d>.

     Uma função a ter seu gráfico montado pode ser especificada como o
     nome de uma função do Maxima ou do Lisp ou um operador, uma
     expressão lambda do Maxima, ou uma expressão geral do Maxima.  Se
     especificado como um nome ou uma expressão lambda, a função deve
     ser uma função de um argumento.

     Exemplos:

     Gráficos de funções comuns.

          (%i1) plot2d (sin(x), [x, -%pi, %pi])$

          (%i1) plot2d (sec(x), [x, -2, 2], [y, -20, 20])$

     Montando gráfico de funções pelo nome.

          (%i1) F(x) := x^2 $
          (%i2) :lisp (defun |$g| (x) (m* x x x))
          $g
          (%i2) H(x) := if x < 0 then x^4 - 1 else 1 - x^5 $
          (%i3) plot2d ([F, G, H], [u, -1, 1], [y, -1.5, 1.5])$

     Podemos montar o gráfico de um círculo usando um gráfico
     paramétrico com um parâmetro <t>.  Não é necessário fornecer um
     intervalo para intervalo horizontal, uma vez que o intervalo do
     parâmetro <t> determina o domínio.  Todavia, usaremos a opção
     <same_xy> para obter a mesma escala em ambos os eixos:

          (%i1) plot2d([[parametric, cos(t), sin(t), [t,0,2*%pi]], -abs(x)],
                   [x, -sqrt(2), sqrt(2)], same_xy)$

     Exemplo de um gráfico logarítmico:
          (%i1) plot2d (exp(3*s), [s, -2, 2], logy)$

     Exemplo de gráfico discreto, definindo as coordenadas x e y por
     separado:

          (%i1) plot2d ([discrete, makelist(i*%pi, i, 1, 5),
                                      [0.6, 0.9, 0.2, 1.3, 1]])$

     O gráfico de pontos pode ser mostrado juntamente com um gráfico da
     função teorética/doutrinária/estética que prevê as coordenads dos
     pontos:

          (%i1) xy: [[10, .6], [20, .9], [30, 1.1], [40, 1.3], [50, 1.4]]$
          (%i2) plot2d([[discrete, xy], 2*%pi*sqrt(l/980)], [l,0,50],
                  [style, points, lines], [color, red, blue],
                  [point_type, asterisk],
                  [legend, "experiment", "theory"],
                  [xlabel, "pendulum's length (cm)"],
                  [ylabel, "period (s)"])$

     Veja também 'plot_options', que descreve opções de montagem de
     gráfico e tem mais exemplos.

 -- Variável de sistema: plot_options
     Elementos dessa lista estabelecem as opções padrão para a montagem
     do gráfico.  Se uma opção está presente em uma chamada a 'plot2d'
     ou 'plot3d', esse valor tem precedência sobre a opção padrão.  De
     outra forma, o valor em 'plot_options' é usado.  Opções padrão são
     atribuídas por 'set_plot_option'.

     Cada elemento de 'plot_options' é uma lista de dois ou mais ítens.
     O primeiro item é o nome de uma opção, e os restantes compreendem o
     valor ou valores atribuídos à opção.  Em alguns casos, o valor
     atribuído é uma lista, que pode compreender muitos ítens.

     As opções de montagem de gráfico que são reconhecidas por 'plot2d'
     e 'plot3d' são as seguintes:

        * Opção: 'plot_format'

          Determina qual interface gráfica é usada por 'plot2d' e por
          'plot3d'.

             * Valor: 'gnuplot' padrão para windows

               Gnuplot é o mais avançado pacote de montagem de gráficos
               entre os pacotes disponíveis no Maxima.  Esse valor
               requer uma instalação externa do gnuplot.
             * Valor: 'gnuplot_pipes' padrão nas plantaformas não
               windows

               Similar ao formato 'gnuplot' exceto que a comunicação com
               o gnuplot é realizada através de um pipe.  Esse valor
               pode ser usado para montar um gráfico na tela, para
               redirecionar a saída do gráfico para um arquivos é melhor
               usar o formato 'gnuplot'.
             * Valor: 'mgnuplot'

               Mgnuplot é um ambiente montado em volta do gnuplot
               baseado no Tk.  Esse ambiente está incluído na
               distribuíção do Maxima.  Mgnuplot oferece uma GUI
               rudimentar para o gnuplot, mas tem menos recursos em
               geral que a interface plana do gnuplot.  Mgnuplot requer
               uma instalação externa do gnuplot e Tcl/Tk.
             * Valor: 'openmath'

               Openmath é um programa gráfico escrito em Tcl/Tk.  Este
               formato é fornecido pelo pacote Xmaxima, que é
               distribuído junto com Maxima; com o objetivo de usar esse
               formato você pode instalar o pacote Xmaxima, e o Openmath
               irá trabalhar não somente a partir do Xmaxima em si
               mesmo, mas também a apartir da linha de comando e outras
               GUI's para o Maxima.

        * Opção: 'run_viewer'

          Controla se o visualizador apropriado para o formato da
          montagem do gráfico pode ou não ser executado.

             * Valor padrão: 'true'

               Executa o programa visualizador.
             * Valor: 'false'

               Não executa o programa visualizador.

        * Opção: 'y'

          O intervalo vertical do gráfico.

          Exemplo:

               [y, - 3, 3]
          Especifica intervalo vertical para [-3, 3].

        * Opção: 'plot_realpart'

          Quando 'plot_realpart' for 'true', a parte real de um valor
          complexo <x> é mostrada; isso é equivalente a mostrar
          'realpart(<x>)' em lugar de <x>.  De outra forma, somente
          valores com a parte imaginária igual a 0 são mostrados na
          tela, e valores complexos são ignorados.

          Exemplo:

               plot2d (log(x), [x, -5, 5], [plot_realpart, false]);
               plot2d (log(x), [x, -5, 5], [plot_realpart, true]);
          O valor padrão é 'false'.

        * Opção: 'nticks'

          Em plot2d, essa opção é fornece o número inicial de pontos
          usado pela rotina adaptativa de montagem de gráficos para
          funções de montagem de gráfico.  Ess número inicial de pontos
          é também o número de pontos que isrá ser mostrado em um
          gráfico paramétrico.

          Exemplo:

               [nticks, 20]
          O padrão para 'nticks' é 10.

        * Opção: 'adapt_depth'

          O número maximo de quebras usada pela rotina adaptativa de
          montagem do gráfico.

          Exemplo:

               [adapt_depth, 5]
          O padrão para 'adapt_depth' é 10.

        * Opção: 'xlabel'

          O rótulo para o eixo horizontal em um gráfico bidimensional.

          Exemplo:
               [xlabel, "Time in seconds"]

        * Opção: 'ylabel'

          O rótulo do eixo vertical em gráficos bidimensionais.

          Exemplo:
               [ylabel, "Temperatura"]

        * Opção: 'logx'

          Essa opção faz com que o eixo horizontal de um gráfico
          bidimensional seja desenhado em proporção logarítmica.  Essa
          opção não precisa de quaisquer parâmetros adicionais.

        * Opção: 'logy'

          Essa opção faz com que o eixo vertical de um gráfico
          bidimensional seja desenhado em proporção logarítmica.  Essa
          opção não precisa de quaisquer parâmetros adicionais.

        * Opção: 'legend'

          Os rótulos para várias expressões em um gráfico bidimensional
          com muitas expressões.  Se houverem mais expressões que o
          número de rótulos fornecidos, eles irão ser repetidos.  Por
          padrão, os nomes das expressões ou funçõe irão ser usados, ou
          as palavras discrete1, discrete2, ..., para conjuntos
          discretos de pontos.

          Exemplo:
               [legend, "Conj 1", "Conj 2", "Conj 3"]

        * Opção: 'style'

          Os estilos que irão ser usados para várias funções ou
          conjuntos de dados em um gráfico bidimensional.  A palavra
          <style> deve ser seguida por um ou mais estilos.  Se houverem
          mais funções e conjuntos de pontos que estilos fornecidos, os
          estilos irão ser repetidos.  Cada estilo pode ser um entre os
          seguintes <lines> para segmentos de reta, <points> para pontos
          isolados, <linespoints> para segmentos e pontos, ou <dots>
          para pequenos pontos isolados.  Gnuplot aceita também o estilo
          <impulses>.

          Cada um dos estilos pode também ser fechado dentro de uma
          lista com alguns parâmetros adicionais.  <lines> aceita um ou
          dois números: a largura da linha e um inteiro que identifica
          uma cor.  <points> aceita um ou dois parâmetros; o primeiro
          parâmetro é o raio dos pontos e o segundo parâmetro é um
          inteiro que para o Gnuplot seleciona diferentes ajustes e
          cores para os ponots e em Openmath modifica a cor usada para
          os pontos.  <linesdots> aceita até quatro parâmetros; os
          primerios dois possuem o mesmo significado que em <lines> e os
          últimos dois possuem o mesmo significado que em <points>.

          Exemplo:
               [style,[lines,2,3],[points,1,4]]

          No Gnuplot, esse exemplo irá montar o gráfico da primeira (e
          terceira, quinta, etc) expressão com segmentos de retas azuis
          de largura 2, ea segunda (e quarta, sexta, etc) expressão com
          quadrados verdes de tamanho 1.  No Openmath, a primeira
          expressão irá ser mostrada com segmentos da cor magenta de
          largura 2, e o segundo com pontos alaranjados de raio 1; note
          que openmath_color(3) openmath_color(4) retornam "magenta" e
          "orange" (alaranjado).

          O padrão para a opção de estilo é <lines> com largura 1, e
          diferentes cores.

        * Opção: 'grid'

          Escolhe o número de pontos da grade para usar nas direções x e
          y para montagem de gráficos tridimensionais.

          Exemplo:
               [grid, 50, 50]
          Escolhe a grade para 50 por 50 pontos.  A grade padrão é 30
          por 30.

        * Opção: 'transform_xy'

          Permite que transformações sejam aplicadas à montagem de
          gráficos tridimensionais.

          Exemplo:
               [transform_xy, false]
          O valor padrão de 'transform_xy' é 'false'.  Se o valor padrão
          de 'transform_xy' não é 'false', pode ser a saída de

               make_transform ([x, y, z], f1(x, y, z), f2(x, y, z), f3(x, y, z))$
          A transformação 'polar_xy' é previamente definida no Maxima.
          Isso fornece a mesma transformação que
               make_transform ([r, th, z], r*cos(th), r*sin(th), z)$

     Opções do Gnuplot:

     Existem muitas opções de montagem de gráfico específicas para
     gnuplot.  Algumas dessas opções são naturais do gnuplot,
     especificados como seqüências de caracteres.  Consulte a
     documentação do gnuplot para mais detalhes.

        * Opção: 'gnuplot_term'

          Escolhe a saída para o tipo terminal para o gnuplot.
             * Valor padrão: 'default'

               A saída do Gnuplot é mostrada em uma janela gráfica
               separada.

             * Valor: 'dumb'

               A sída do Gnuplot é mostrada no console do Maxima por
               meio de uma "concepção artística em ASCII" aproximada
               para gráficos.

             * Valor: 'ps'

               Gnuplot gera comandos na linguagem PostScript de
               descrição de página.  Se a opção 'gnuplot_out_file' for
               escolhida para <nomearquivo>, gnuplot escreve os comandos
               PostScript em <nomearquivo>.  De outra forma, Esse
               arquivo é salvo com o nome 'maxplot.ps'.

             * Valor: qualquer outra especificação válida do terminal
               'term' do gnuplot

               Gnuplot pode gerar saídas em muitos outros formatos
               gráficos tais como png, jpeg, svg etc.  Paa criar
               gráficos em todos esses formatos a opção 'gnuplot_term'
               pode ser escolhida para qualquer terminalsuportado pelo
               gnuplot (símbolo) ou mesmo especificação completa de
               terminal do gnuplot com quaisquer opções (seqüência de
               caracteres).  Por exemplo '[gnuplot_term,png]' cria
               saídas no formato PNG (Portable +Network Graphics)
               enquanto '[gnuplot_term,"png size 1000,1000"]' cria PNG
               de tamanho 1000x1000 pixels.  Se a opção
               'gnuplot_out_file' for escolhida para <nomearquivo>,
               gnuplot escreve a saída para <nomearquivo>.  De outra
               forma, esse arquivo é gravado com o nome de
               'maxplot.<term>', onde <term> é o nome do terminal do
               gnuplot .

        * Opção: 'gnuplot_out_file'

          Escreve a saída do gnuplot para um arquivo.

             * Valor padrão: 'false'

               Nenhum arquivo de saída especificado.
             * Valor: <nomearquivo>

               Exemplo: '[gnuplot_out_file, "meugrafico.ps"]' Esse
               exemplo envia a saída PostScript para o arquivo
               'meugrafico.ps' quando usada conjuntamente com o terminal
               PostScript do gnuplot.

        * Opção: 'gnuplot_pm3d'

          Controla o uso do modo PM3D, que tem recursos avançados em 3D.
          PM3D está somente disponível no gnuplot em versões após a 3.7.
          O valor padrão para 'gnuplot_pm3d' é 'false'.

          Exemplo:

               [gnuplot_pm3d, true]

        * Opção: 'gnuplot_preamble'

          Insere comandos antes que o gráfico seja desenhado.  Quaisquer
          comandos válidos para o gnuplot podem ser usados.  Multiplos
          comandos podem ser separados com um ponto e vírgula.  O
          exemplo mostrado produz uma escala numérica na montagem do
          gráfico.  O valor padrão para 'gnuplot_preamble' é uma
          seqüência de caracteres vazia '""'.

          Exemplo:

               [gnuplot_preamble, "set log y"]

        * Opção: 'gnuplot_curve_titles'

          Controla os títulos dados na chave da montagem do gráfico.  O
          valor padrão é '[default]', que automaticamente escolhe o
          título de cada curva para a função cujo gráfico está sendo
          construído.  Se não contiver '[default]',
          'gnuplot_curve_titles' pode conter uma lista de seqüências de
          caracteres, cada uma das quais é '"title '<title_string>'"'.
          (Para disabilitar a chave de impressão de gráfico, adicione
          '"set nokey"' a 'gnuplot_preamble'.)

          Exemplo:

               [gnuplot_curve_titles,
               ["title 'Minha primeira função'", "title 'Minha segunda função'"]]

        * Opção: 'gnuplot_curve_styles'

          Uma lista de seqüências de caracteres controlando a aparência
          das curvas, i.e., cor, largura, brilho, etc., para serem
          enviadas para o comando de montagem do gráfico do gnuplot.  O
          valor padrão é '["with lines 3", "with lines 1", "with lines
          2", "with lines 5", "with lines 4", "with lines 6", "with
          lines 7"]', que circula através de diferentes cores.  Veja a
          documentação do gnuplot de 'plot' para maiores informações.

          Exemplo:

               [gnuplot_curve_styles, ["with lines 7", "with lines 2"]]

        * Opção: 'gnuplot_default_term_command'

          O comando gnuplot para escolher o tipo de terminal para o
          terminal padrão.  O valor padrão é 'set term windows "Verdana"
          15' em sistemas windows, e 'set term x11 font "Helvetica,16"'
          em sistemas de janelas do X11.

          Exemplo:

               [gnuplot_default_term_command, "set term x11"]

        * Opção: 'gnuplot_dumb_term_command'

          O comando gnuplot para escolher o tipo de terminal para o
          terminal dumb.  O valor padrão é '"set term dumb 79 22"', que
          faz a saída texto com 79 caracteres por 22 caracteres.

          Exemplo:

               [gnuplot_dumb_term_command, "set term dumb 132 50"]

        * Opção: 'gnuplot_ps_term_command'

          O comando gnuplot para escolher o tipo de terminal para o
          terminal PostScript.  O valor padrão é '"set size 1.5, 1.5;set
          term postscript eps enhanced color solid 24"', que escolhe o
          tamanho para 1.5 vezes o padrão do gnuplot, e o tamanho da
          fonte para 24, além de outras coisas.  Veja a documentação do
          gnuplot de 'set term postscript' para mais informação.

          Exemplo:

          Todos os números nos exemplos para a função <plot2d> nesse
          manual foram obtidos de arquivos Postscript que foram gerados
          após escolher 'gnuplot_ps_term_command' como:

               [gnuplot_ps_term_command,
               "set size 1.3, 1.3; set term postscript eps color solid lw 2.5 30"]

 -- Função: plot3d ([<expr_1>, <expr_2>, <expr_3>], <x_range>,
          <y_range>, ..., <opções>, ...)
 -- Função: plot3d (<expr>, <x_range>, <y_range>, ..., <opções>, ...)
 -- Função: plot3d (<name>, <x_range>, <y_range>, ..., <opções>, ...)
 -- Função: plot3d ([<expr_1>, <expr_2>, <expr_3>], <x_rge>, <y_rge>)
 -- Função: plot3d ([<nome_1>, <nome_2>, <nome_3>], <x_range>,
          <y_range>, ..., <opções>, ...)

     Mostra um gráfico de uma ou três expressões como funções de duas
     variáveis.

          (%i1) plot3d (u^2 - v^2, [u, -2, 2], [v, -3, 3], [grid, 100, 100],
                  [mesh_lines_color,false])$

     monta o gráfico de 'u^2-v^2' com 'u' e 'v' variando no intervalo
     fechado [-2,2] e no intervalo fechado de [-3,3] respectivamente, e
     com <u> sobre o eixo x, e 'v' sobre o eixo y.

     Outro exemplo é uma superfície de Klein:

          (%i1) expr_1: 5*cos(x)*(cos(x/2)*cos(y)+sin(x/2)*sin(2*y)+3)-10$
          (%i2) expr_2: -5*sin(x)*(cos(x/2)*cos(y)+sin(x/2)*sin(2*y)+3)$
          (%i3) expr_3: 5*(-sin(x/2)*cos(y)+cos(x/2)*sin(2*y))$
          (%i4) plot3d ([expr_1, expr_2, expr_3], [x, -%pi, %pi],
                  [y, -%pi, %pi], [grid, 50, 50])$

     Algumas vezes isso é necessário para definir uma função para montar
     o graico da expressão.  Todos os argumentos para plot3d são
     avaliados antes de serem passados para plot3d.  Tentar fazer um
     expressão que faz apenas o que é preciso pode ser difícil e pode
     ser mais fácil fazer uma função.

          (%i1) M: matrix([1,2,3,4], [1,2,3,2], [1,2,3,4], [1,2,3,3])$
          (%i2) f(x, y) := float('M [round(x), round(y)])$
          (%i3) plot3d (f(x,y), [x,1,4],[y,1,4],[grid,3,3],[legend,false])$

     Veja 'plot_options' para mais exemplos.

 -- Função: make_transform (<vars>, <fx>, <fy>, <fz>)
     Retorna uma função adequada para a função transformação em plot3d.
     Use com a opção de montagem de gráfico 'transform_xy'.
          make_transform ([r, th, z], r*cos(th), r*sin(th), z)$
     é uma transformação para coordenadas polares.

 -- Função: set_plot_option (<opção>)
     Atribui uma das varáveis globais para impressão.  <opção> é
     especificada como uma lista de dois ou mais elementos, na qual o
     primeiro elemento é uma das palavras chave dentro da lista
     'plot_options'.

     'set_plot_option' avalia seu argumento e retorna a liasta completa
     'plot_options' (após modificar um de seus elementos).

     Veja também 'plot_options', 'plot2d', e 'plot3d'.

     Exemplos:

     Modifica a malha ('grid') e valores de 'x'.  Quando uma palavra
     chave em 'plot_options' tem um valor atribuído, colocar um
     apóstrofo evita avaliação.

          (%i1) set_plot_option ([grid, 30, 40]);
          (%o1) [[x, - 1.755559702014E+305, 1.755559702014E+305],
          [y, - 1.755559702014E+305, 1.755559702014E+305], [t, - 3, 3],
          [grid, 30, 40], [transform_xy, false], [run_viewer, true],
          [plot_format, gnuplot], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 10], [adapt_depth, 10],
          [gnuplot_pm3d, false], [gnuplot_preamble, ],
          [gnuplot_curve_titles, [default]],
          [gnuplot_curve_styles, [with lines 3, with lines 1,
          with lines 2, with lines 5, with lines 4, with lines 6,
          with lines 7]], [gnuplot_default_term_command, ],
          [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript #
          eps enhanced color solid 24]]
          (%i2) x: 42;
          (%o2)                          42
          (%i3) set_plot_option (['x, -100, 100]);
          (%o3) [[x, - 100.0, 100.0], [y, - 1.755559702014E+305,
          1.755559702014E+305], [t, - 3, 3], [grid, 30, 40],
          [transform_xy, false], [run_viewer, true],
          [plot_format, gnuplot], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 10], [adapt_depth, 10],
          [gnuplot_pm3d, false], [gnuplot_preamble, ],
          [gnuplot_curve_titles, [default]],
          [gnuplot_curve_styles, [with lines 3, with lines 1,
          with lines 2, with lines 5, with lines 4, with lines 6,
          with lines 7]], [gnuplot_default_term_command, ],
          [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript #
          eps enhanced color solid 24]]

8.1.1 Funções para trabalhar com o formato 'gnuplot_pipes'
----------------------------------------------------------

 -- Função: gnuplot_start ()

     Abre o pipe para o gnuplot usado para montar um gráfico com o
     formato 'gnuplot_pipes'.  Não é necessário abrir manualmente o pipe
     antes de montar o gráfico.

 -- Função: gnuplot_close ()

     Fecha o pipe para o gnuplot que está sendo usado com o formato
     'gnuplot_pipes'.

 -- Função: gnuplot_restart ()

     Fecha o pipe para o gnuplot que é usado com o formato
     'gnuplot_pipes' e abre um novo pipe.

 -- Função: gnuplot_replot ()
 -- Função: gnuplot_replot (<s>)

     Atualiza a janela gráfica do gnuplot.  Se 'gnuplot_replot' for
     chamado com um comando gnuplot em uma seqüência de caracteres <s>,
     então 's' é enviado para o gnuplot antes de atualizar a janela.

 -- Função: gnuplot_reset ()

     Restaura o estado inicial padrão do gnuplot usado com o formato
     'gnuplot_pipes'.  Para atualizar a janela do gnuplot chama
     'gnuplot_replot' após 'gnuplot_reset'.


File: maxima.info,  Node: Entrada e Saída,  Next: Ponto Flutuante,  Prev: Montando Gráficos,  Up: Top

9 Entrada e Saída
*****************

* Menu:

* Comentários::
* Arquivos::                       
* Funções e Variáveis Definidas para Entrada e Saída::  


File: maxima.info,  Node: Comentários,  Next: Arquivos,  Prev: Entrada e Saída,  Up: Entrada e Saída

9.1 Comentários
===============

Um comentário na entrada do Maxima é qualquer texto entre '/*' e '*/'.

   O analisador do Maxima trata um comentário como espação em branco
para o propósito de encontrar indicações no fluxo de entrada; uma
indicação sempre termina um comentário.  Uma entrada tal como 'a/* foo
*/b' contém duas indicações, 'a' e 'b', e não uma indicação simples
'ab'.  Comentários são de outra ignorados pelo Maxima; nem o conteúdo
nem a localização dos comentários são armazenados pelo analisador de
expressões de entrada.

   Comentários podem ser aninhados de forma a terem um nível de
estratificação arbitrario.  O delimitador '/*' e o delimitador '*/'
formam pares.  A quantidade de '/*' deve ser a mesma quantidade de '*/'.

   Exemplos:

     (%i1) /* aa is a variable of interest */  aa : 1234;
     (%o1)                         1234
     (%i2) /* Value of bb depends on aa */  bb : aa^2;
     (%o2)                        1522756
     (%i3) /* User-defined infix operator */  infix ("b");
     (%o3)                           b
     (%i4) /* Parses same as a b c, not abc */  a/* foo */b/* bar */c;
     (%o4)                         a b c
     (%i5) /* Comments /* can be nested /* to arbitrary depth */ */ */  1 + xyz;
     (%o5)                        xyz + 1


File: maxima.info,  Node: Arquivos,  Next: Funções e Variáveis Definidas para Entrada e Saída,  Prev: Comentários,  Up: Entrada e Saída

9.2 Arquivos
============

Um arquivo é simplesmente uma área sobre um dispositivo particular de
armazenagem que contém dados ou texto.  Arquivos em disco são
figurativamente agrupados dentro de "diretórios".  Um diretório é apenas
uma lista de arquivos.  Comandos que lidam com arquivos são: 'save',
'load', 'loadfile', 'stringout', 'batch', 'demo', 'writefile',
'closefile', e 'appendfile'.


File: maxima.info,  Node: Funções e Variáveis Definidas para Entrada e Saída,  Prev: Arquivos,  Up: Entrada e Saída

9.3 Funções e Variáveis Definidas para Entrada e Saída de Dados
===============================================================

 -- Variável de sistema: __
     '__' é a expressão de entrada atualmente sendo avaliada.  Isto é,
     enquanto um expressão de entrada <expr> está sendo avaliada, '__' é
     <expr>.

     '__' é atribuída à expressão de entrada antes de a entrada ser
     simplificada ou avaliada.  Todavia, o valor de '__' é simplificado
     (mas não avaliado) quando for mostrado.

     '__' é reconhecido por 'batch' e 'load'.  Em um arquivo processado
     por 'batch', '__' tem o mesmo significado que na linha de comando
     interativa.  Em um arquivo processado por 'load', '__' está
     associado à expressão de entrada mais recentemente informada no
     prompt interativo ou em um arquivo de lote (batch); '__' não é
     associado à expressões de entrada no arquivo que está sendo
     processado.  Em particular, quando 'load (<nomearquivo>)' for
     chamado a partir da linha de comando interativa, '__' é associado a
     'load (<nomearquivo>)' enquanto o arquivo está sendo processado.

     Veja também '_' e '%'.

     Exemplos:

          (%i1) print ("Eu fui chamada como", __);
          Eu fui chamada como print(Eu fui chamada como, __)
          (%o1)              print(Eu fui chamada como, __)
          (%i2) foo (__);
          (%o2)                     foo(foo(__))
          (%i3) g (x) := (print ("Expressão atual de entrada =", __), 0);
          (%o3) g(x) := (print("Expressão atual de entrada =", __), 0)
          (%i4) [aa : 1, bb : 2, cc : 3];
          (%o4)                       [1, 2, 3]
          (%i5) (aa + bb + cc)/(dd + ee + g(x));
                                         cc + bb + aa
          Expressão atual de entrada = --------------
                                        g(x) + ee + dd
                                          6
          (%o5)                        -------
                                       ee + dd

 -- Variável de sistema: _

     '_' é a mais recente expressão de entrada (e.g., '%i1', '%i2',
     '%i3', ...).

     A '_' é atribuída à expressão de entrada antes dela ser
     simplificada ou avaliada.  Todavia, o valor de '_' é simplificado
     (mas não avaliado) quando for mostrado.

     '_' é reconhecido por 'batch' e 'load'.  Em um arquivo processado
     por 'batch', '_' tem o mesmo significado que na linha de comando
     interativa.  Em um arquivo processado por load 'load', '_' está
     associado à expressão de entrada mais recentemente avaliada na
     linha de comando interativa ou em um arquivo de lote; '_' não está
     associada a expressões de entrada no arquivo que está sendo
     processado.

     Veja também '__' e '%'.

     Exemplos:

          (%i1) 13 + 29;
          (%o1)                          42
          (%i2) :lisp $_
          ((MPLUS) 13 29)
          (%i2) _;
          (%o2)                          42
          (%i3) sin (%pi/2);
          (%o3)                           1
          (%i4) :lisp $_
          ((%SIN) ((MQUOTIENT) $%PI 2))
          (%i4) _;
          (%o4)                           1
          (%i5) a: 13$
          (%i6) b: 29$
          (%i7) a + b;
          (%o7)                          42
          (%i8) :lisp $_
          ((MPLUS) $A $B)
          (%i8) _;
          (%o8)                         b + a
          (%i9) a + b;
          (%o9)                          42
          (%i10) ev (_);
          (%o10)                         42

 -- Variável de sistema: %
     '%' é a expressão de saída (e.g., '%o1', '%o2', '%o3', ...)  mais
     recentemente calculada pelo Maxima, pode ou não ser mostrada.

     '%' é reconhecida por 'batch' e 'load'.  Em um arquivo processado
     por 'batch', '%' tem o mesmo significado que na linha de comando
     interativa.  Em um arquivo processado por 'load', '%' é associado à
     expressão de entrada mais recentemente calculada na linha de
     comando interativa ou em um arquivo de lote; '%' não está associada
     a expressões de saída no arquivo que está sendo processado.

     Veja também '_', '%%', e '%th'

 -- Variável de sistema: %%
     Em declaração composta, a saber 'block', 'lambda', ou '(<s_1>, ...,
     <s_n>)', '%%' é os valor da declaração anterior.  Por exemplo,

          block (integrate (x^5, x), ev (%%, x=2) - ev (%%, x=1));
          block ([prev], prev: integrate (x^5, x), ev (prev, x=2) - ev (prev, x=1));

     retornam o mesmo resultado, a saber '21/2'.

     Uma declaração composta pode compreender outras declarações
     compostas.  Pode uma declaração ser simples ou composta, '%%' é o
     valor da declaração anterior.  Por exemplo,

          block (block (a^n, %%*42), %%/6)

     retorna '7*a^n'.

     Dentro da declaração composta, o valor de '%%' pode ser
     inspecionado em uma parada de linha de comando, que é aberta pela
     execução da função 'break'.  Por exemplo, na parada de linha de
     comando aberta por

          block (a: 42, break ())$

     digitando '%%;' retorna '42'.

     Na primeira declaração em uma declaração composta, ou fora de uma
     declaração composta, '%%' é indefinido.

     '%%' reconhecido por 'batch' e 'load', e possem o mesmo significao
     que na linha de comando interativa.

     Veja também '%'.

 -- Variável de opção: %edispflag
     Valor padrão: 'false'

     Quando '%edispflag' for 'true', Maxima mostra '%e' para um expoente
     negativo como um quociente.  Por exemplo, '%e^-x' é mostrado como
     '1/%e^x'.

 -- Função: %th (<i>)
     O valor da <i>'ésima expressão prévia de saída.  Isto é, se a
     próxima expressão a ser calculada for a <n>'ésima saída, '%th
     (<m>)' será a (<n> - <m>)'ésima saída.

     '%th' é útil em arquivos 'batch' ou para referir-se a um grupo de
     expressões de saída.  Por exemplo,

          block (s: 0, for i:1 thru 10 do s: s + %th (i))$

     atribui à variável 's' a soma das últimas dez expressões de saída.

     '%th' é reconhecido por 'batch' e 'load'.  Em um arquivo processado
     por 'batch', '%th' possue o mesmo significado que na linha de
     comando interativa.  Em um arquivo processado por 'load', '%th'
     refere-se a expressões de saída mais recentemente calculadas na
     linha de comando interativa ou em um arquivo de lote; '%th' não se
     refere a expressões de saída no arquivo que está sendo processado.

     Veja também '%'.

 -- Símbolo especial: ?
     Como prefixo para uma função ou nome de variável, '?' significa que
     o nome é um nome Lisp, não um nome Maxima.  Por exemplo, '?round'
     significa a função Lisp 'ROUND'.  Veja *note Lisp e Maxima:: para
     mais sobre esse ponto.

     A notação '? palavra' (um ponto de interrogação seguido de uma
     palavra e separado desta por um espaço em branco) é equivalente a
     'describe("palavra")'.  O ponto de interrogação deve aparecer no
     início de uma linha de entrada; de outra forma o ponto de
     interrogação não é reconhecido com um pedido de documentação.

 -- Símbolo especial: ??

     A notação '?? palavra' ('??' seguido de um espaço em branco e uma
     palavra) é equivalente a 'describe("palavra", inexact)'.  O ponto
     de interrogação deve ocorrer no início de uma linha de entrada; de
     outra forma não é reconhecido com um pedido de documentação.

 -- Variável de opção: absboxchar
     Valor padrão: '!'

     'absboxchar' é o caracter usado para para desenhar o sinal de valor
     absoluto em torno de expressões que são maiores que uma linha de
     altura.

 -- Variável de opção: file_output_append
     Valor padrão: 'false'

     'file_output_append' governa se funções de saída de arquivo anexam
     ao final ou truncam seu arquivo de saída.  Quando
     'file_output_append' for 'true', tais funções anexam ao final de
     seu arquivo de saída.  De outra forma, o arquivo de saída é
     truncado.

     'save', 'stringout', e 'with_stdout' respeitam
     'file_output_append'.  Outras funções que escrevem arquivos de
     saída não respeitam 'file_output_append'.  Em particular, montagem
     de gráficos e traduções de funções sempre truncam seu arquivo de
     saída, e 'tex' e 'appendfile' sempre anexam ao final.

 -- Função: appendfile (<nomearquivo>)
     Adiciona ao final de <nomearquivo> uma transcrição do console.
     'appendfile' é o mesmo que 'writefile', exceto que o arquivo
     transcrito, se já existe, terá sempre alguma coisa adicionada ao
     seu final.

     'closefile' fecha o arquivo transcrito que foi aberto anteriormente
     por 'appendfile' ou por 'writefile'.

 -- Função: batch (<nomearquivo>)
     Lê expressões Maxima do arquivo <nomearquivo> e as avalia.  'batch'
     procura pelo arquivo <nomearquivo> na lista 'file_search_maxima'.
     Veja 'file_search'.

     <nomearquivo> compreende uma seqüência de expressões Maxima, cada
     uma terminada com ';' ou '$'.  A varável especial '%' e a função
     '%th' referem-se a resultados prévios dentro do arquivo.  O arquivo
     pode incluir construções ':lisp'.  Espaços, tabulações, e o
     caracter de nova linha no arquivo serão ignorados.  um arquivo de
     entrada conveniente pode ser criado por um editor de texto ou pela
     função 'stringout'.

     'batch' lê cada expressão de entrada de <nomearquivo>, mostra a
     entrada para o console, calcula a correspondente expressão de
     saída, e mostra a expressão de saída.  Rótulos de entrada são
     atribuídos para expressões de entrada e rótulos de saída são
     atribuídos para expressões de saída.  'batch' avalia toda expressão
     de entrada no arquivo a menos que exista um erro.  Se uma entrada
     de usuário for requisitada (por 'asksign' ou por 'askinteger', por
     exemplo) 'batch' interrompe para coletar a entrada requisitada e
     então continua.

     O recurso de requisição de entrada ao usuário possibilita
     interromper 'batch' pela digitação de 'control-C' no console.  O
     efeito de 'control-C' depende da subjacente implementação do Lisp.

     'batch' tem muitos usos, tais como fornecer um reservatório para
     trabalhar linhas de comando, para fornecer demonstrações livres de
     erros, ou para ajudar a organizar alguma coisa na solução de
     problemas complexos.

     'batch' avalia seu argumento.  'batch' não possui valor de retorno.

     Veja também 'load', 'batchload', e 'demo'.

 -- Função: batchload (<nomearquivo>)
     Lê expressões Maxima de <nomearquivo> e as avalia, sem mostrar a
     entrada ou expressões de saída e sem atribuir rótulos para
     expressões de saída.  Saídas impressas (tais como produzidas por
     'print' ou 'describe') são mostradas, todavia.

     A variável especial '%' e a função '%th' referem-se a resultados
     anteriores do interpretador interativo, não a resultados dentro do
     arquivo.  O arquivo não pode incluir construções ':lisp'.

     'batchload' retorna o caminho de <nomearquivo>, como uma seqüência
     de caracteres.  'batchload' avalia seu argumento.

     Veja também 'batch' e 'load'.

 -- Função: closefile ()
     Fecha o arquivo transcrito aberto por 'writefile' ou 'appendfile'.

 -- Função: collapse (<expr>)
     Reduz <expr> fazendo com que todas as suas subexpressões comuns
     (i.e., iguais) sejam compartilhadas (i.e., usam a mesma células),
     dessa forma economizando espaço.  ('collapse' é uma subrotina usada
     pelo comando 'optimize'.)  Dessa forma, chamar 'collapse' pode ser
     útil após um 'save' arquivo.  Você pode diminuir muitas expressões
     juntas pelo uso de 'collapse ([<expr_1>, ..., <expr_n>])'.
     Similarmente, você pode diminuir os elementos de um array 'A'
     fazendo 'collapse (listarray ('A))'.

 -- Função: concat (<arg_1>, <arg_2>, ...)
     Concatena seus argumentos.  Os argumentos devem obrigatóriamente
     serem avaliados para atomos.  O valor de retorno ou é um símbolo se
     o primeiro argumento for um símbolo ou é uma seqüência de
     caracteres no formato do Maxima em caso contrário.

     'concat' avalia seus argumentos.  O apóstrofo ''' evita avaliação.

          (%i1) y: 7$
          (%i2) z: 88$
          (%i3) concat (y, z/2);
          (%o3)                          744
          (%i4) concat ('y, z/2);
          (%o4)                          y44

     Um símbolo construído por 'concat' pode ser atribuído a um valor e
     aparecer em expressões.  O operador de atribuição '::' (duplo dois
     pontos) avalia seu lado esquerdo.

          (%i5) a: concat ('y, z/2);
          (%o5)                          y44
          (%i6) a:: 123;
          (%o6)                          123
          (%i7) y44;
          (%o7)                          123
          (%i8) b^a;
                                         y44
          (%o8)                         b
          (%i9) %, numer;
                                         123
          (%o9)                         b

     Note que embora 'concat (1, 2)' seja visto como números no console,
     na realidade é uma seqüência de caracteres no formato do Maxima.

          (%i10) concat (1, 2) + 3;
          (%o10)                       12 + 3

 -- Função: sconcat (<arg_1>, <arg_2>, ...)

     Concatena seus argumentos em uma seqüência de caracteres.  Ao
     contrário de 'concat', os argumentos arrumados não precisam ser
     atômicos.

     O resultado é uma seqüência de caracteres no format do Lisp.

          (%i1) sconcat ("xx[", 3, "]:", expand ((x+y)^3));
          (%o1)               xx[3]:y^3+3*x*y^2+3*x^2*y+x^3

 -- Função: disp (<expr_1>, <expr_2>, ...)
     é como 'display' mas somente os valores dos argumentos são
     mostrados em lugar de equações.  A função 'disp' é útil para
     argumentos complicados que não possuem nomes ou onde somente o
     valor do argumento é de interesse e não o nome.

 -- Função: dispcon (<tensor_1>, <tensor_2>, ...)
 -- Função: dispcon (all)
     Mostra as propriedades de contração de seus argumentos da forma que
     foram dadas para 'defcon'.  'dispcon (all)' mostra todas as
     propriedades de contração que foram definidas.

 -- Função: display (<expr_1>, <expr_2>, ...)
     Mostra equações cujo lado esquerdo é <expr_i> não avaliado, e cujo
     lado direito é o valor da expressão centrada na linha.  Essa função
     é útil em blocos e em 'for' declarações com o objetivo de ter
     resultados intermediários mostrados.  Os argumentos para 'display'
     são usualmente átomos, variáveis com subscritos, ou chamadas de
     função.  Veja também 'disp'.

          (%i1) display(B[1,2]);
                                                2
                                   B     = X - X
                                    1, 2
          (%o1)                            done

 -- Variável de opção: display2d
     Valor padrão: 'true'

     Quando 'display2d' for 'false', O console visualizador é da forma
     de uma seqüência de caracteres (unidimensional) ao invés da forma
     bidimensional.

 -- Variável de opção: display_format_internal
     Valor padrão: 'false'

     Quando 'display_format_internal' é 'true', expressões são mostradas
     sem ser por caminhos que escondam a representação matemática
     interna.  O visualizador então corresponde ao que 'inpart' retorna
     em lugar de 'part'.

     Exemplos:

          User     part       inpart
          a-b;      A - B     A + (- 1) B

                     A            - 1
          a/b;       -         A B
                     B
                                 1/2
          sqrt(x);   sqrt(X)    X

                    4 X        4
          X*4/3;    ---        - X
                     3         3

 -- Função: dispterms (<expr>)
     Mostra <expr> em partes uma abaixo da outra.  Isto é, primeiro o
     operador de <expr> é mostrado, então cada parcela em uma adição, ou
     fatores em um produto, ou parte de uma expressão mais geral é
     mostrado separadamente.  Isso é útil se <expr> é muito larga para
     ser mostrada de outra forma.  Por exemplo se 'P1', 'P2', ...  são
     expressões muito largas então o programa visualizador pode sair
     fora do espaço de armazenamento na tentativa de mostrar 'P1 + P2 +
     ...' tudo de uma vez.  Todavia, 'dispterms (P1 + P2 + ...)' mostra
     'P1', então abaixo disso 'P2', etc.  Quando não usando 'dispterms',
     se uma expressão exponencial é muito alta para ser mostrada como
     'A^B' isso aparece como 'expt (A, B)' (ou como 'ncexpt (A, B)' no
     caso de 'A^^B').

 -- Variável de opção: error_size
     Valor padrão: 10

     'error_size' modifica mensagens de erro conforme o tamanho das
     expressões que aparecem nelas.  Se o tamanho de uma expressão (como
     determinado pela função Lisp 'ERROR-SIZE') é maior que
     'error_size', a expressão é substituída na mensagem por um símbolo,
     e o o símbolo é atribuído à expressão.  Os símbolos são obtidos da
     lista 'error_syms'.

     De outra forma, a expressão é menor que 'error_size', e a expressão
     é mostrada na mensagem.

     Veja também 'error' e 'error_syms'.

     Exemplo:

     O tamanho de 'U', como determinado por 'ERROR-SIZE', é 24.

          (%i1) U: (C^D^E + B + A)/(cos(X-1) + 1)$

          (%i2) error_size: 20$

          (%i3) error ("Expressão exemplo é", U);

          Expressão exemplo é errexp1
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) errexp1;
                                      E
                                     D
                                    C   + B + A
          (%o4)                    --------------
                                   cos(X - 1) + 1
          (%i5) error_size: 30$

          (%i6) error ("Expressão exemplo é", U);

                                     E
                                    D
                                   C   + B + A
          Expressão exemplo é --------------
                                  cos(X - 1) + 1
           -- an error.  Quitting.  To debug this try debugmode(true);

 -- Variável de opção: error_syms
     Valor padrão: '[errexp1, errexp2, errexp3]'

     Em mensagens de erro, expressões mais largas que 'error_size' são
     substituídas por símbolos, e os símbolos são escolhidos para as
     expressões.  Os símbolos são obtidos da lista 'error_syms'.  A
     primeira expressão muito larga é substituída por 'error_syms[1]', a
     segunda por 'error_syms[2]', e assim por diante.

     Se houverem mais expressões muito largas que há elementos em
     'error_syms', símbolos são construídos automaticamente, com o
     <n>-ésimo símbolo equivalente a 'concat ('errexp, <n>)'.

     Veja também 'error' e 'error_size'.

 -- Função: expt (<a>, <b>)
     Se uma expressão exponencial é muito alta para ser mostrada cmo
     '<a>^<b>' isso aparece como 'expt (<a>, <b>)' (ou como 'ncexpt
     (<a>, <b>)' no caso de '<a>^^<b>').

     'expt' e 'ncexpt' não são reconhecidas em entradas.

 -- Variável de opção: exptdispflag
     Valor padrão: 'true'

     Quando 'exptdispflag' é 'true', Maxima mostra expressões com
     expoente negativo usando quocientes, e.g., 'X^(-1)' como '1/X'.

 -- Função: filename_merge (<path>, <nomearquivo>)
     Constroem um caminho modificado de <path> e <nomearquivo>.  Se o
     componente final de <path> é da forma '###.<algumacoisa>', o
     componente é substituído com '<nomearquivo>.<algumacoisa>'.  De
     outra forma, o componente final é simplesmente substituído por
     <nomearquivo>.

 -- Função: file_search (<nomearquivo>)
 -- Função: file_search (<nomearquivo>, <listacaminho>)

     'file_search' procura pelo arquivo <nomearquivo> e retorna o
     caminho para o arquivo (como uma seqüência de caracteres) se ele
     for achado; de outra forma 'file_search' retorna 'false'.
     'file_search (<nomearquivo>)' procura nos diretórios padrões de
     busca, que são especificados pelas variáveis 'file_search_maxima',
     'file_search_lisp', e 'file_search_demo'.

     'file_search' primeiro verifica se o nome atual passado existe,
     antes de tentar coincidir esse nome atual com o modelo "coringa" de
     busca do arquivo.  Veja 'file_search_maxima' concernente a modelos
     de busca de arquivos.

     O argumento <nomearquivo> pode ser um caminho e nome de arquivo, ou
     apenas um nome de arquivo, ou, se um diretório de busca de arquivo
     inclui um modelo de busca de arquivo, apenas a base do nome de
     arquivo (sem uma extensão).  Por exemplo,

          file_search ("/home/wfs/special/zeta.mac");
          file_search ("zeta.mac");
          file_search ("zeta");

     todos encontram o mesmo arquivo, assumindo que o arquivo exista e
     '/home/wfs/special/###.mac' está em 'file_search_maxima'.

     'file_search (<nomearquivo>, <listacaminho>)' procura somente
     nesses diretórios especificados por <listacaminho>, que é uma lista
     de seqüências de caracteres.  O argumento <listacaminho> substitui
     os diretórios de busca padrão, então se a lista do caminho é dada,
     'file_search' procura somente nesses especificados, e não qualquer
     dos diretórios padrão de busca.  Mesmo se existe somente um
     diretório em <listacaminho>, esse deve ainda ser dado como uma
     lista de um único elemento.

     O usuário pode modificar o diretório de busca padrão.  Veja
     'file_search_maxima'.

     'file_search' é invocado por 'load' com 'file_search_maxima' e
     'file_search_lisp' como diretórios de busca.

 -- Variável de opção: file_search_maxima
 -- Variável de opção: file_search_lisp
 -- Variável de opção: file_search_demo
     Essas variáveis especificam listas de diretórios a serem procurados
     por 'load', 'demo', e algumas outras funções do Maxima.  O valor
     padrão dessas variáveis nomeia vários diretórios na instalaçã
     padrão do Maxima.

     O usuáro pode modificar essas variáveis, quer substituindo os
     valores padrão ou colocando no final diretórios adicionais.  Por
     exemplo,

          file_search_maxima: ["/usr/local/foo/###.mac",
              "/usr/local/bar/###.mac"]$

     substitui o valor padrão de 'file_search_maxima', enquanto

          file_search_maxima: append (file_search_maxima,
              ["/usr/local/foo/###.mac", "/usr/local/bar/###.mac"])$

     adiciona no final da lista dois diretórios adicionais.  Isso pode
     ser conveniente para colocar assim uma expressão no arquivo
     'maxima-init.mac' de forma que o caminho de busca de arquivo é
     atribuído automaticamente quando o Maxima inicia.

     Multiplas extensões de arquivo e e multiplos caminhos podem ser
     especificados por construções "coringa" especiais.  A seqüência de
     caracteres '###' expande a busca para além do nome básico, enquanto
     uma lista separada por vírgulas e entre chaves '{foo,bar,baz}'
     expande em multiplas seqüências de caracteres.  Por exemplo,
     supondo que o nome básico a ser procurado seja 'neumann',

          "/home/{wfs,gcj}/###.{lisp,mac}"

     expande em '/home/wfs/neumann.lisp', '/home/gcj/neumann.lisp',
     '/home/wfs/neumann.mac', e '/home/gcj/neumann.mac'.

 -- Função: file_type (<nomearquivo>)
     Retorna uma suposta informação sobre o conteúdo de <nomearquivo>,
     baseada na extensão do arquivo.  <nomearquivo> não precisa
     referir-se a um arquivo atual; nenhuma tentativa é feita para abrir
     o arquivo e inspecionar seu conteúdo.

     O valor de retorno é um símbolo, qualquer um entre 'object',
     'lisp', ou 'maxima'.  Se a extensão começa com 'm' ou 'd',
     'file_type' retorna 'maxima'.  Se a extensão começa om 'l',
     'file_type' retorna 'lisp'.  Se nenhum dos acima, 'file_type'
     retorna 'object'.

 -- Função: grind (<expr>)
 -- Variável de opção: grind
     A função 'grind' imprime <expr> para o console em uma forma
     adequada de entrada para Maxima.  'grind' sempre retorna 'done'.

     Quando <expr> for um nome de uma função ou o nome de uma macro,
     'grind' mostra na tela a definição da função ou da macro em lugar
     de apenas o nome.

     Veja também 'string', que retorna uma seqüência de caracteres em
     lugar de imprimir sua saída.  'grind' tenta imprimir a expressão de
     uma maneira que a faz levemente mais fácil para ler que a saída de
     'string'.

     Quando a variável 'grind' é 'true', a saída de 'string' e
     'stringout' tem o mesmo formato que 'grind'; de outra forma nenhuma
     tentativa é feita para formatar especialmente a saída dessas
     funções.  O valor padrão da variável 'grind' é 'false'.

     'grind' pode também ser especificado como um argumento de
     'playback'.  Quando 'grind' está presente, 'playback' imprime
     expressões de entrada no mesmo formato que a função 'grind'.  De
     outra forma, nenhuma tentativa é feita para formatar especialmente
     as expressões de entrada.

     'grind' avalia seus argumentos.

     Exemplos:

          (%i1) aa + 1729;
          (%o1)                       aa + 1729
          (%i2) grind (%);
          aa+1729$
          (%o2)                         done
          (%i3) [aa, 1729, aa + 1729];
          (%o3)                 [aa, 1729, aa + 1729]
          (%i4) grind (%);
          [aa,1729,aa+1729]$
          (%o4)                         done
          (%i5) matrix ([aa, 17], [29, bb]);
                                     [ aa  17 ]
          (%o5)                      [        ]
                                     [ 29  bb ]
          (%i6) grind (%);
          matrix([aa,17],[29,bb])$
          (%o6)                         done
          (%i7) set (aa, 17, 29, bb);
          (%o7)                   {17, 29, aa, bb}
          (%i8) grind (%);
          {17,29,aa,bb}$
          (%o8)                         done
          (%i9) exp (aa / (bb + 17)^29);
                                          aa
                                      -----------
                                               29
                                      (bb + 17)
          (%o9)                     %e
          (%i10) grind (%);
          %e^(aa/(bb+17)^29)$
          (%o10)                        done
          (%i11) expr: expand ((aa + bb)^10);
                   10           9        2   8         3   7         4   6
          (%o11) bb   + 10 aa bb  + 45 aa  bb  + 120 aa  bb  + 210 aa  bb
                   5   5         6   4         7   3        8   2
           + 252 aa  bb  + 210 aa  bb  + 120 aa  bb  + 45 aa  bb
                  9        10
           + 10 aa  bb + aa
          (%i12) grind (expr);
          bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6
               +252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2
               +10*aa^9*bb+aa^10$
          (%o12)                        done
          (%i13) string (expr);
          (%o13) bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6\
          +252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2+10*aa^9*\
          bb+aa^10
          (%i14) cholesky (A):= block ([n : length (A), L : copymatrix (A),
          p : makelist (0, i, 1, length (A))], for i thru n do for j : i thru n do
          (x : L[i, j], x : x - sum (L[j, k] * L[i, k], k, 1, i - 1), if i = j then
          p[i] : 1 / sqrt(x) else L[j, i] : x * p[i]), for i thru n do L[i, i] : 1 / p[i],
          for i thru n do for j : i + 1 thru n do L[i, j] : 0, L)$
          (%i15) grind (cholesky);
          cholesky(A):=block(
                   [n:length(A),L:copymatrix(A),
                    p:makelist(0,i,1,length(A))],
                   for i thru n do
                       (for j from i thru n do
                            (x:L[i,j],x:x-sum(L[j,k]*L[i,k],k,1,i-1),
                             if i = j then p[i]:1/sqrt(x)
                                 else L[j,i]:x*p[i])),
                   for i thru n do L[i,i]:1/p[i],
                   for i thru n do (for j from i+1 thru n do L[i,j]:0),L)$
          (%o15)                        done
          (%i16) string (fundef (cholesky));
          (%o16) cholesky(A):=block([n:length(A),L:copymatrix(A),p:makelis\
          t(0,i,1,length(A))],for i thru n do (for j from i thru n do (x:L\
          [i,j],x:x-sum(L[j,k]*L[i,k],k,1,i-1),if i = j then p[i]:1/sqrt(x\
          ) else L[j,i]:x*p[i])),for i thru n do L[i,i]:1/p[i],for i thru \
          n do (for j from i+1 thru n do L[i,j]:0),L)

 -- Variável de opção: ibase
     Valor padrão: 10

     Inteiros fornecidos dentro do Maxima são interpretados com respeito
     à base 'ibase'.

     A 'ibase' pode ser atribuído qualquer inteiro entre 2 e 35
     (decimal), inclusive.  Quando 'ibase' é maior que 10, os numerais
     compreendem aos numerais decimais de 0 até 9 mais as letras
     maiúsculas do alfabeto A, B, C, ..., como necessário.  Os numerais
     para a base 35, a maior base aceitável, compreendem de 0 até 9 e de
     A até Y.

     Veja também 'obase'.

 -- Variável de opção: inchar
     Valor padrão: '%i'

     'inchar' é o prefixo dos rótulos de expressões fornecidas pelo
     usuário.  Maxima automaticamente constrói um rótulo para cada
     expressão de entrada por concatenação de 'inchar' e 'linenum'.  A
     'inchar' pode ser atribuído qualquer seqüência de caracteres ou
     símbolo, não necessariamente um caracter simples.

          (%i1) inchar: "input";
          (%o1)                                input
          (input1) expand ((a+b)^3);
                                      3        2      2      3
          (%o1)                      b  + 3 a b  + 3 a  b + a
          (input2)

     Veja também 'labels'.

 -- Função: ldisp (<expr_1>, ..., <expr_n>)
     Mostra expressões <expr_1>, ..., <expr_n> para o console como saída
     impressa na tela.  'ldisp' atribue um rótulo de expressão
     intermediária a cada argumento e retorna a lista de rótulos.

     Veja também 'disp'.

          (%i1) e: (a+b)^3;
                                             3
          (%o1)                       (b + a)
          (%i2) f: expand (e);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (%i3) ldisp (e, f);
                                             3
          (%t3)                       (b + a)

                               3        2      2      3
          (%t4)               b  + 3 a b  + 3 a  b + a

          (%o4)                      [%t3, %t4]
          (%i4) %t3;
                                             3
          (%o4)                       (b + a)
          (%i5) %t4;
                               3        2      2      3
          (%o5)               b  + 3 a b  + 3 a  b + a

 -- Função: ldisplay (<expr_1>, ..., <expr_n>)
     Mostra expressões <expr_1>, ..., <expr_n> para o console como saída
     impressa na tela.  Cada expressão é impressa como uma equação da
     forma 'lhs = rhs' na qual 'lhs' é um dos argumentos de 'ldisplay' e
     'rhs' é seu valor.  Tipicamente cada argumento é uma variável.
     'ldisp' atribui um rótulo de expressão intermediáia a cada equação
     e retorna a lista de rótulos.

     Veja também 'display'.

          (%i1) e: (a+b)^3;
                                             3
          (%o1)                       (b + a)
          (%i2) f: expand (e);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (%i3) ldisplay (e, f);
                                               3
          (%t3)                     e = (b + a)

                                 3        2      2      3
          (%t4)             f = b  + 3 a b  + 3 a  b + a

          (%o4)                      [%t3, %t4]
          (%i4) %t3;
                                               3
          (%o4)                     e = (b + a)
          (%i5) %t4;
                                 3        2      2      3
          (%o5)             f = b  + 3 a b  + 3 a  b + a

 -- Variável de opção: linechar
     Valor padrão: '%t'

     'linechar' é o refixo de rótulos de expressões intermediárias
     gerados pelo Maxima.  Maxima constrói um rótulo para cada expressão
     intermediária (se for mostrada) pela concatenação de 'linechar' e
     'linenum'.  A 'linechar' pode ser atribuído qualquer seqüência de
     caracteres ou símbolo, não necessáriamente um caractere simples.

     Expressões intermediárias podem ou não serem mostradas.  See
     'programmode' e 'labels'.

 -- Variável de opção: linel
     Valor padrão: 79

     'linel' é a largura assumida (em caracteres) do console para o
     propósito de mostrar expressões.  A 'linel' pode ser atribuído
     qualquer valor pelo usuário, embora valores muio pequenos ou muito
     grandes possam ser impraticáveis.  Textos impressos por funções
     internas do Maxima, tais como mensagens de erro e a saída de
     'describe', não são afetadas por 'linel'.

 -- Variável de opção: lispdisp
     Valor padrão: 'false'

     Quando 'lispdisp' for 'true', símbolos Lisp são mostrados com um
     ponto de interrogação '?' na frente.  De outra forma, símbolos Lisp
     serão mostrados sem o ponto de interrogaçõ na frente.

     Exemplos:

          (%i1) lispdisp: false$
          (%i2) ?foo + ?bar;
          (%o2)                       foo + bar
          (%i3) lispdisp: true$
          (%i4) ?foo + ?bar;
          (%o4)                      ?foo + ?bar

 -- Função: load (<nomearquivo>)
     Avalia expressões em <nomearquivo>, dessa forma conduzindo
     variáveis, funções, e outros objetos dentro do Maxima.  A
     associação de qualquer objeto existente é substituída pela
     associação recuperada de <nomearquivo>.  Para achar o arquivo,
     'load' chama 'file_search' com 'file_search_maxima' e
     'file_search_lisp' como diretórios de busca.  Se 'load' obtém
     sucesso, isso retorna o nome do arquivo.  De outra forma 'load'
     imprime uma mensagem e erro.

     'load' trabalha igualmente bem para códigos Lisp e códigos Maxima.
     Arquivos criados por 'save', 'translate_file', e 'compile_file',
     que criam códigos Lisp, e 'stringout', que criam códigos Maxima,
     podem ser processadas por 'load'.  'load' chama 'loadfile' para
     carregar arquivos Lisp e 'batchload' para carregar arquivos Maxima.

     'load' não reconhece construções ':lisp' em arquivos do Maxima, e
     quando processando <nomearquivo>, as variáveis globais '_', '__',
     '%', e '%th' possuem as mesmas associações que possuiam quando
     'load' foi chamada.

     Veja também 'loadfile', 'batch', 'batchload', e 'demo'.  'loadfile'
     processa arquivos Lisp; 'batch', 'batchload', e 'demo' processam
     arquivos Maxima.

     Veja 'file_search' para mais detalhes sobre o mecanismo de busca de
     arquivos.

     'load' avalia seu argumento.

 -- Função: loadfile (<nomearquivo>)
     Avalia expressões Lisp em <nomearquivo>.  'loadfile' não invoca
     'file_search', então 'nomearquivo' deve obrigatóriamente incluir a
     extensão do arquivo e tanto quanto o caminho como necessário para
     achar o arquivo.

     'loadfile' pode processar arquivos criados por 'save',
     'translate_file', e 'compile_file'.  O usuário pode achar isso mais
     conveniente para usar 'load' em lugar de 'loadfile'.

 -- Variável de opção: loadprint
     Valor padrão: 'true'

     'loadprint' diz se deve imprimir uma mensagem quando um arquivo é
     chamado.

        * Quando 'loadprint' é 'true', sempre imprime uma mensagem.
        * Quando 'loadprint' é ''loadfile', imprime uma mensagem somente
          se um arquivo é chamado pela função 'loadfile'.
        * Quando 'loadprint' é ''autoload', imprime uma mensagem somente
          se um arquivo é automaticamente carregado.  Veja
          'setup_autoload'.
        * Quando 'loadprint' é 'false', nunca imprime uma mensagem.

 -- Variável de opção: obase
     Valor padrão: 10

     'obase' é a base para inteiros mostrados pelo Maxima.

     A 'obase' poode ser atribuído qualquer inteiro entre 2 e 35
     (decimal), inclusive.  Quando 'obase' é maior que 10, os numerais
     compreendem os numerais decimais de 0 até 9 e letras maiúsulas do
     alfabeto A, B, C, ..., quando necessário.  Os numerais para a base
     35, a maior base aceitável, compreendem de 0 até 9, e de A até Y.

     Veja também 'ibase'.

 -- Variável de opção: outchar
     Valor padrão: '%o'

     'outchar' é o prefixo dos rótulos de expressões calculadas pelo
     Maxima.  Maxima automaticamente constrói um rótulo para cada
     expressão calculada pela concatenação de 'outchar' e 'linenum'.  A
     'outchar' pode ser atribuído qualquer seqüência de caracteres ou
     símbolo, não necessáriamente um caractere simples.

          (%i1) outchar: "output";
          (output1)                           output
          (%i2) expand ((a+b)^3);
                                      3        2      2      3
          (output2)                  b  + 3 a b  + 3 a  b + a
          (%i3)

     Veja também 'labels'.

 -- Variável de opção: packagefile
     Valor padrão: 'false'

     Projetistas de pacotes que usam 'save' ou 'translate' para criar
     pacotes (arquivos) para outros usarem podem querer escolher
     'packagefile: true' para prevenir qu informações sejam
     acrescentadas à lista de informações do Maxima (e.g.  'values',
     'funções') exceto onde necessário quando o arquivo é carregado.
     Nesse caminho, o conteúdo do pacote não pegará no caminho do
     usuário quando ele adicionar seus próprios dados.  Note que isso
     não resolve o problema de possíveis conflitos de nome.  Também note
     que o sinalizador simplesmente afeta o que é saída para o arquivo
     pacote.  Escolhendo o sinalizador para 'true' é também útil para
     criar arquivos de init do Maxima.

 -- Variável de opção: pfeformat
     Valor padrão: 'false'

     Quando 'pfeformat' é 'true', uma razão de inteiros é mostrada com o
     caractere sólido (barra normal), e um denominador inteiro 'n' é
     mostrado como um termo multiplicativo em primeiro lugar '1/n'.

          (%i1) pfeformat: false$
          (%i2) 2^16/7^3;
                                        65536
          (%o2)                         -----
                                         343
          (%i3) (a+b)/8;
                                        b + a
          (%o3)                         -----
                                          8
          (%i4) pfeformat: true$
          (%i5) 2^16/7^3;
          (%o5)                       65536/343
          (%i6) (a+b)/8;
          (%o6)                      1/8 (b + a)

 -- Função: print (<expr_1>, ..., <expr_n>)
     Avalia e mostra <expr_1>, ..., <expr_n> uma após a outra, da
     esquerda para a direita, iniciando no lado esquerdo do console.

     O valor retornado por 'print' é o valor de seu último argumento.
     'print' não gera rótulos de expressão intermediária.

     Veja também 'display', 'disp', 'ldisplay', e 'ldisp'.  Essas
     funções mostram uma expressão por linha, enquanto 'print' tenta
     mostrar duas ou mais expressões por linha.

     Para mostrar o conteúdo de um arquivo, veja 'printfile'.

          (%i1) r: print ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is", radcan (log (a^10/b)))$
                      3        2      2      3
          (a+b)^3 is b  + 3 a b  + 3 a  b + a  log (a^10/b) is

                                                        10 log(a) - log(b)
          (%i2) r;
          (%o2)                  10 log(a) - log(b)
          (%i3) disp ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is", radcan (log (a^10/b)))$
                                     (a+b)^3 is

                               3        2      2      3
                              b  + 3 a b  + 3 a  b + a

                                   log (a^10/b) is

                                 10 log(a) - log(b)

 -- Função: tcl_output (<list>, <i0>, <skip>)
 -- Função: tcl_output (<list>, <i0>)
 -- Função: tcl_output ([<list_1>, ..., <list_n>], <i>)

     Imprime os elementos de uma lista entre chaves '{ }', conveniente
     como parte de um programa na linguagem Tcl/Tk.

     'tcl_output (<list>, <i0>, <skip>)' imprime <list>, começando com o
     elemento <i0> e imprimindo elementos '<i0> + <skip>', '<i0> + 2
     <skip>', etc.

     'tcl_output (<list>, <i0>)' é equivalente a 'tcl_output (<list>,
     <i0>, 2)'.

     'tcl_output ([<list_1>, ..., <list_n>], <i>)' imprime os <i>'ésimos
     elementos de <list_1>, ..., <list_n>.

     Exemplos:

          (%i1) tcl_output ([1, 2, 3, 4, 5, 6], 1, 3)$

           {1.000000000     4.000000000
           }
          (%i2) tcl_output ([1, 2, 3, 4, 5, 6], 2, 3)$

           {2.000000000     5.000000000
           }
          (%i3) tcl_output ([3/7, 5/9, 11/13, 13/17], 1)$

           {((RAT SIMP) 3 7) ((RAT SIMP) 11 13)
           }
          (%i4) tcl_output ([x1, y1, x2, y2, x3, y3], 2)$

           {$Y1 $Y2 $Y3
           }
          (%i5) tcl_output ([[1, 2, 3], [11, 22, 33]], 1)$

           {SIMP 1.000000000     11.00000000
           }

 -- Função: read (<expr_1>, ..., <expr_n>)
     Imprime <expr_1>, ..., <expr_n>, então lê uma expressão do console
     e retorna a expressão avaliada.  A expressão é terminada com um
     ponto e vírgula ';' ou o sinal de dólar '$'.

     Veja também 'readonly'.

          (%i1) foo: 42$
          (%i2) foo: read ("foo is", foo, " -- enter new value.")$
          foo is 42  -- enter new value.
          (a+b)^3;
          (%i3) foo;
                                               3
          (%o3)                         (b + a)

 -- Função: readonly (<expr_1>, ..., <expr_n>)
     Imprime <expr_1>, ..., <expr_n>, então lê uma expressão do console
     e retorna a expressão (sem avaliação).  A expressão é terminada com
     um ';' (ponto e vírgula) ou '$' (sinal de dólar).

          (%i1) aa: 7$
          (%i2) foo: readonly ("Forneça uma expressão:");
          Enter an expressão:
          2^aa;
                                            aa
          (%o2)                            2
          (%i3) foo: read ("Forneça uma expressão:");
          Enter an expressão:
          2^aa;
          (%o3)                            128

     Veja também 'read'.

 -- Função: reveal (<expr>, <depth>)
     Substitue partes de <expr> no inteiro especificado <depth> com
     sumário descritivo.

        * Somas e diferenças são substituídas por 'sum(<n>)' onde <n> é
          o número de operandos do produto.
        * Produtos são substituídos por 'product(<n>)' onde <n> é o
          número de operandos da multiplicação.
        * Exponenciais são substituídos por 'expt'.
        * Quocientes são substituídos por 'quotient'.
        * Negação unária é substituída por 'negterm'.

     Quando <depth> é maior que ou igual à máxima intensidade de <expr>,
     'reveal (<expr>, <depth>)' retornam <expr> sem modificações.

     'reveal' avalia seus argumentos.  'reveal' retorna expressão
     sumarizada.

     Exemplo:

          (%i1) e: expand ((a - b)^2)/expand ((exp(a) + exp(b))^2);
                                    2            2
                                   b  - 2 a b + a
          (%o1)               -------------------------
                                  b + a     2 b     2 a
                              2 %e      + %e    + %e
          (%i2) reveal (e, 1);
          (%o2)                       quotient
          (%i3) reveal (e, 2);
                                       sum(3)
          (%o3)                        ------
                                       sum(3)
          (%i4) reveal (e, 3);
                               expt + negterm + expt
          (%o4)               ------------------------
                              product(2) + expt + expt
          (%i5) reveal (e, 4);
                                 2                 2
                                b  - product(3) + a
          (%o5)         ------------------------------------
                                   product(2)     product(2)
                        2 expt + %e           + %e
          (%i6) reveal (e, 5);
                                   2            2
                                  b  - 2 a b + a
          (%o6)              --------------------------
                                 sum(2)     2 b     2 a
                             2 %e       + %e    + %e
          (%i7) reveal (e, 6);
                                    2            2
                                   b  - 2 a b + a
          (%o7)               -------------------------
                                  b + a     2 b     2 a
                              2 %e      + %e    + %e

 -- Variável de opção: rmxchar
     Valor padrão: ']'

     'rmxchar' é the caractere desenhado lado direito de uma matriz.

     Veja também 'lmxchar'.

 -- Função: save (<nomearquivo>, <nome_1>, <nome_2>, <nome_3>, ...)
 -- Função: save (<nomearquivo>, values, functions, labels, ...)
 -- Função: save (<nomearquivo>, [<m>, <n>])
 -- Função: save (<nomearquivo>, <nome_1>=<expr_1>, ...)
 -- Função: save (<nomearquivo>, all)
 -- Função: save (<nomearquivo>, <nome_1>=<expr_1>, <nome_2>=<expr_2>,
          ...)

     Armazena os valores correntes de <nome_1>, <nome_2>, <nome_3>, ...,
     em <nomearquivo>.  Os argumentos são os nomes das variáveis,
     funções, ou outros objetos.  Se um nome não possui valore ou função
     associada a ele, esse nome sem nenhum valor ou função associado
     será ignorado.  'save' retorna <nomearquivo>.

     'save' armazena dados na forma de expressões Lisp.  Os dados
     armazenados por 'save' podem ser recuperados por 'load
     (<nomearquivo>)'.

     O sinalizador global 'file_output_append' governa se 'save' anexa
     ao final ou trunca o arquivo de saída.  Quando 'file_output_append'
     for 'true', 'save' anexa ao final doarquivo de saída.  De outra
     forma, 'save' trunca o arquivo de saída.  Nesse caso, 'save' cria o
     arquivo se ele não existir ainda.

     A forma especial 'save (<nomearquivo>, values, functions, labels,
     ...)' armazena os ítens nomeados por 'values', 'funções', 'labels',
     etc.  Os nomes podem ser quaisquer especificados pela variável
     'infolists'.  'values' compreende todas as variáveis definidas pelo
     usuário.

     A forma especial 'save (<nomearquivo>, [<m>, <n>])' armazena os
     valores de rótulos de entrada e saída de <m> até <n>.  Note que <m>
     e <n> devem obrigatóriamente ser inteiros literais.  Rótulos de
     entrada e saída podem também ser armazenados um a um, e.g., 'save
     ("foo.1", %i42, %o42)'.  'save (<nomearquivo>, labels)' armazena
     todos os rótulos de entrada e saída.  Quando rótulos armazenados
     são recuperados, eles substituem rótulos existentes.

     A forma especial 'save (<nomearquivo>, <nome_1>=<expr_1>,
     <nome_2>=<expr_2>, ...)' armazena os valores de <expr_1>, <expr_2>,
     ..., com nomes <nome_1>, <nome_2>, ....  Isso é útil para aplicar
     essa forma para rótulos de entrada e saída, e.g., 'save ("foo.1",
     aa=%o88)'.  O lado direito dessa igualdade nessa forma pode ser
     qualquer expressão, que é avaliada.  Essa forma não introduz os
     novos nomes no ambiente corrente do Maxima, mas somente armazena-os
     em <nomearquivo>.

     Essa forma especial e a forma geral de 'save' podem ser misturados.
     Por exemplo, 'save (<nomearquivo>, aa, bb, cc=42, funções, [11,
     17])'.

     A forma especial 'save (<nomearquivo>, all)' armazena o estado
     corrente do Maxima.  Isso inclui todas as variáveis definidas pelo
     usuário, funções, arrays, etc., bem como alguns ítens definidos
     automaticamente.  Os ítes salvos incluem variáveis de sistema, tais
     como 'file_search_maxima' ou 'showtime', se a elas tiverem sido
     atribuídos novos valores pelo usuário; veja 'myoptions'.

     'save' avalia <nomearquivo> e não avalia todos os outros
     argumentos.

 -- Variável de opção: savedef
     Valor padrão: 'true'

     Quando 'savedef' é 'true', a vesão Maxima de uma função de usuário
     é preservada quando a função é traduzida.  Isso permite que a
     definição seja mostrada por 'dispfun' e autoriza a função a ser
     editada.

     Quando 'savedef' é 'false', os nomes de funções traduzidas são
     removidos da lista de 'funções'.

 -- Função: show (<expr>)
     Mostra 'expr' com os objetos indexados tendo índices covariantes
     como subscritos, índices contravariantes como sobrescritos.  Os
     índices derivativos são mostrados como subscritos, separados dos
     índices covariantes por uma vírgula.

 -- Função: showratvars (<expr>)
     Retorna uma lista de variáveis expressão racional canônica (CRE) na
     expressão 'expr'.

     Veja também 'ratvars'.

 -- Variável de opção: stardisp
     Valor padrão: 'false'

     Quando 'stardisp' é 'true', multiplicação é mostrada com um
     asterisco '*' entre os operandos.

 -- Função: string (<expr>)
     Converte 'expr' para a notação linear do Maxima apenas como se
     tivesse sido digitada.

     O valor de retorno de 'string' é uma seqüência de caracteres, e
     dessa forma não pode ser usada em um cálculo.

 -- Variãvel de opção: stringdisp
     Valor padrão: 'false'

     Quando 'stringdisp' for 'true', seqüências de caracteres serão
     mostradas contidas em aspas duplas.  De outra forma, aspas não são
     mostradas.

     'stringdisp' é sempre 'true' quando mostrando na tela uma definição
     de função.

     Exemplos:

          (%i1) stringdisp: false$
          (%i2) "This is an example string.";
          (%o2)              This is an example string.
          (%i3) foo () := print ("This is a string in a function definition.");
          (%o3) foo() :=
                        print("This is a string in a function definition.")
          (%i4) stringdisp: true$
          (%i5) "This is an example string.";
          (%o5)             "This is an example string."

 -- Função: stringout (<nomearquivo>, <expr_1>, <expr_2>, <expr_3>, ...)
 -- Função: stringout (<nomearquivo>, [<m>, <n>])
 -- Função: stringout (<nomearquivo>, input)
 -- Função: stringout (<nomearquivo>, functions)
 -- Função: stringout (<nomearquivo>, values)

     'stringout' escreve expressões para um arquivo na mesma forma de
     expressões que foram digitadas para entrada.  O arquivo pode então
     ser usado como entrada para comandos 'batch' ou 'demo', e isso pode
     ser editado para qualquer propósito.  'stringout' pode ser
     executado enquanto 'writefile' está em progresso.

     O sinalizador global 'file_output_append' governa se 'stringout'
     anexa ao final ou trunca o arquivo de saída.  Quando
     'file_output_append' for 'true', 'stringout' anexa ao final do
     arquivo de sad'a.  De outra forma, 'stringout' trunca o arquivo de
     saída.  Nesse caso, 'stringout' cria o arquivo de saída se ele não
     existir ainda.

     A forma geral de 'stringout' escreve os valores de um ou mais
     expressões para o arquivo de saída.  Note que se uma expressão é
     uma variável, somente o valor da variável é escrito e não o nome da
     variável.  Como um útil caso especial, as expressões podem ser
     rótulos de entrada ('%i1', '%i2', '%i3', ...)  ou rótulos de saída
     ('%o1', '%o2', '%o3', ...).

     Se 'grind' é 'true', 'stringout' formata a saída usando o formato
     'grind'.  De outra forma o formato 'string' é usado.  Veja 'grind'
     e 'string'.

     A forma especial 'stringout (<nomearquivo>, [<m>, <n>])' escreve os
     valores dos rótulos de entrada de m até n, inclusive.

     A forma especial 'stringout (<nomearquivo>, input)' escreve todos
     os rótulos de entrada para o arquivo.

     A forma especial 'stringout (<nomearquivo>, functions)' escreve
     todas as funções definidas pelo usuário (nomeadas pela lista global
     'functions') para o arquivo.

     A forma especial 'stringout (<nomearquivo>, values)' escreve todas
     as variáveis atribuídas pelo usuário (nomeadas pela lista global
     'values') para o arquivo.  Cada variável é impressa como uma
     declaração de atribuição, com o nome da variável seguida de dois
     pontos, e seu valor.  Note que a forma geral de 'stringout' não
     imprime variáveis como declarações de atribuição.

 -- Função: tex (<expr>)
 -- Função: tex (<rótulo>)
 -- Função: tex (<expr>, <momearquivo>)
 -- Função: tex (<label>, <nomearquivo>)

     Imprime uma representação de uma expressão adequada para o sistema
     TeX de preparação de documento.  O resultado é um fragmento de um
     documento, que pode ser copiado dentro de um documento maior Esse
     fragmento não pode ser processado de forma direta e isolada.

     'tex (<expr>)' imprime uma representação TeX da <expr> no console.

     'tex (<rótulo>)' imprime uma representação TeX de uma expressão
     chamada <rótulo> e atribui a essa um rótulo de equação (a ser
     mostrado à esquerda da expressão).  O rótulo de equação TeX é o
     mesmo que o rótulo da equação no Maxima.

     'tex (<expr>, <nomearquivo>)' anexa ao final uma representação TeX
     de <expr> no arquivo <nomearquivo>.

     'tex (<rótulo>, <nomearquivo>)' anexa ao final uma representação
     TeX da expressão chamada de <rótulo>, com um rótulo de equação, ao
     arquivo <nomearquivo>.

     'tex' avalia seu primeiro argumento após testar esse argumento para
     ver se é um rótulo.  duplo apóstrofo '''' força a avaliação do
     argumento, desse modo frustrando o teste e prevenindo o rótulo.

     Veja também 'texput'.

     Exemplos:

          (%i1) integrate (1/(1+x^3), x);
                                              2 x - 1
                            2            atan(-------)
                       log(x  - x + 1)        sqrt(3)    log(x + 1)
          (%o1)      - --------------- + ------------- + ----------
                              6             sqrt(3)          3
          (%i2) tex (%o1);
          $$-{{\log \left(x^2-x+1\right)}\over{6}}+{{\arctan \left({{2\,x-1
           }\over{\sqrt{3}}}\right)}\over{\sqrt{3}}}+{{\log \left(x+1\right)
           }\over{3}}\leqno{\tt (\%o1)}$$
          (%o2)                          (\%o1)
          (%i3) tex (integrate (sin(x), x));
          $$-\cos x$$
          (%o3)                           false
          (%i4) tex (%o1, "foo.tex");
          (%o4)                          (\%o1)

 -- Função: texput (<a>, <s>)
 -- Função: texput (<a>, <s>, <operator_type>)
 -- Função: texput (<a>, [<s_1>, <s_2>], matchfix)
 -- Função: texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)

     Atribui a saída TeX para o átomo <a>, que pode ser um símbolo ou o
     nome de um operador.

     'texput (<a>, <s>)' faz com que a função 'tex' interpole a
     seqüência de caracteres <s> dentro da saída TeX em lugar de <a>.

     'texput (<a>, <s>, <operator_type>)', onde <operator_type> é
     'prefix', 'infix', 'postfix', 'nary', ou 'nofix', faz com que a
     função 'tex' interpole <s> dentro da saída TeX em lugar de <a>, e
     coloca o texto interpolado na posição apropriada.

     'texput (<a>, [<s_1>, <s_2>], matchfix)' faz com que a função 'tex'
     interpole <s_1> e <s_2> dentro da saída TeX sobre qualquer lado dos
     argumentos de <a>.  Os argumentos (se mais de um) são separados por
     vírgulas.

     'texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)' faz com que a
     função 'tex' interpole <s_1> e <s_2> dentro da saída TeX sobre
     qualquer lado dos argumentos de <a>, com <s_3> separando os
     argumentos.

     Exemplos:

     Atribui saída TeX a uma variável.

          (%i1) texput (me,"\\mu_e");
          (%o1)                         \mu_e
          (%i2) tex (me);
          $$\mu_e$$
          (%o2)                         false

     Atribui saída TeX a uma função comum (não a um operador).

          (%i1) texput (lcm, "\\mathrm{lcm}");
          (%o1)                     \mathrm{lcm}
          (%i2) tex (lcm (a, b));
          $$\mathrm{lcm}\left(a , b\right)$$
          (%o2)                         false

     Atribui saída TeX a um operador prefixado.

          (%i1) prefix ("grad");
          (%o1)                         grad
          (%i2) texput ("grad", " \\nabla ", prefix);
          (%o2)                        \nabla
          (%i3) tex (grad f);
          $$ \nabla f$$
          (%o3)                         false

     Atribui saída TeX a um operador infixado.

          (%i1) infix ("~");
          (%o1)                           ~
          (%i2) texput ("~", " \\times ", infix);
          (%o2)                        \times
          (%i3) tex (a ~ b);
          $$a \times b$$
          (%o3)                         false

     Atribui saída TeX a um operadro pósfixado.

          (%i1) postfix ("##");
          (%o1)                          ##
          (%i2) texput ("##", "!!", postfix);
          (%o2)                          !!
          (%i3) tex (x ##);
          $$x!!$$
          (%o3)                         false

     Atribui saída TeX a um operador n-ário.

          (%i1) nary ("@@");
          (%o1)                          @@
          (%i2) texput ("@@", " \\circ ", nary);
          (%o2)                         \circ
          (%i3) tex (a @@ b @@ c @@ d);
          $$a \circ b \circ c \circ d$$
          (%o3)                         false

     Atribui saída TeX a um operador nofix.

          (%i1) nofix ("foo");
          (%o1)                          foo
          (%i2) texput ("foo", "\\mathsc{foo}", nofix);
          (%o2)                     \mathsc{foo}
          (%i3) tex (foo);
          $$\mathsc{foo}$$
          (%o3)                         false

     Atribui saída TeX a um operadro matchfix.

          (%i1) matchfix ("<<", ">>");
          (%o1)                          <<
          (%i2) texput ("<<", [" \\langle ", " \\rangle "], matchfix);
          (%o2)                [ \langle ,  \rangle ]
          (%i3) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o3)                         false
          (%i4) tex (<<a, b>>);
          $$ \langle a , b \rangle $$
          (%o4)                         false
          (%i5) texput ("<<", [" \\langle ", " \\rangle ", " \\, | \\,"], matchfix);
          (%o5)           [ \langle ,  \rangle ,  \, | \,]
          (%i6) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o6)                         false
          (%i7) tex (<<a, b>>);
          $$ \langle a \, | \,b \rangle $$
          (%o7)                         false

 -- Função: system (<comando>)
     Executa <comando> como um processo separado.  O comando é passado
     ao shell padraõ para execução.  'system' não é suportado por todos
     os sistemas operacionais, mas geralmente existe em ambientes Unix e
     Unix-like.

     Supondo que '_hist.out' é uma lista de freqüência que você deseja
     imprimir como um gráfico em barras usando 'xgraph'.

          (%i1) (with_stdout("_hist.out",
                     for i:1 thru length(hist) do (
                       print(i,hist[i]))),
                 system("xgraph -bar -brw .7 -nl < _hist.out"));

     Com o objetivo de fazer com que a impressão do gráfico seja
     concluída em segundo plano (retornando o controle para o Maxima) e
     remover o arquivo temporário após isso ter sido concluído faça:

          system("(xgraph -bar -brw .7 -nl < _hist.out;  rm -f _hist.out)&")

 -- Variável de opção: ttyoff
     Valor padrão: 'false'

     Quando 'ttyoff' é 'true', expressões de saída não são mostradas.
     Expressões de saída são ainda calculadas e atribuídas rótulos.
     Veja 'labels'.

     Textos impresso por funções internas do Maxima, tais como mensagens
     de erro e a saída de 'describe', não são afetadas por 'ttyoff'.

 -- Função: with_stdout (<nomearquivo>, <expr_1>, <expr_2>, <expr_3>,
          ...)
     Abre <nomearquivo> e então avalia <expr_1>, <expr_2>, <expr_3>,
     ....  Os valores dos argumentos não são armazenados em
     <nomearquivo>, mas qualquer saída impressa gerada pela avaliação
     dos argumentos (de 'print', 'display', 'disp', ou 'grind', por
     exemplo) vai para <nomearquivo> em lugar do console.

     O sinalizador global 'file_output_append' governa se 'with_stdout'
     anexa ao final ou trunca o arquivo de saída.  Quando
     'file_output_append' for 'true', 'with_stdout' anexa ao final do
     arquivo de saída.  De outra forma, 'with_stdout' trunca o arquivo
     de saída.  Nesse caso, 'with_stdout' cria o arquivo se ele não
     existir ainda.

     'with_stdout' retorna o valor do seu argumento final.

     Veja também 'writefile'.

          (%i1) with_stdout ("tmp.out", for i:5 thru 10 do print (i, "! yields", i!))$
          (%i2) printfile ("tmp.out")$
          5 ! yields 120
          6 ! yields 720
          7 ! yields 5040
          8 ! yields 40320
          9 ! yields 362880
          10 ! yields 3628800

 -- Função: writefile (<nomearquivo>)
     Começa escrevendo uma transcrição da sessão Maxima para
     <nomearquivo>.  Toda interação entre o usuário e Maxima é então
     gravada nesse arquivo, da mesma forma que aparece no console.

     Como a transcrição é impressa no formato de saída do console, isso
     não pode ser reaproveitado pelo Maxima.  Para fazer um arquivo
     contendo expressões que podem ser reaproveitadas, veja 'save' e
     'stringout'.  'save' armazena expressões no formato Lisp, enquanto
     'stringout' armazena expressões no formato Maxima.

     O efeito de executar 'writefile' quando <nomearquivo> ainda existe
     depende da implementação Lisp subjacente; o arquivo transcrito pode
     ser substituído, ou o arquivo pode receber um anexo.  'appendfile'
     sempre anexa para o arquivo transcrito.

     Isso pode ser conveniente para executar 'playback' após 'writefile'
     para salvar a visualização de interações prévias.  Como 'playback'
     mostra somente as variáveis de entrada e saída ('%i1', '%o1',
     etc.), qualquer saída gerada por uma declaração de impressão em uma
     função (como oposição a um valor de retorno) não é mostrada por
     'playback'.

     'closefile' fecha o arquivo transcrito aberto por 'writefile' ou
     'appendfile'.

