This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.


File: maxima.info,  Node: Ponto Flutuante,  Next: Contextos,  Prev: Entrada e Saída,  Up: Top

10 Ponto Flutuante
******************

* Menu:

* Funções e Variáveis Definidas para ponto Flutuante::  


File: maxima.info,  Node: Funções e Variáveis Definidas para ponto Flutuante,  Prev: Ponto Flutuante,  Up: Ponto Flutuante

10.1 Funções e Variáveis Definidas para ponto Flutuante
=======================================================

 -- Função: bffac (<expr>, <n>)
     Versão para grandes números em ponto flutuante da função
     'factorial' (usa o artifício gamma).  O segundo argumento informa
     quantos dígitos reter e retornar, isso é uma boa idéia para
     requisitar precisão adicional.

     'load ("bffac")' chama essa função.

 -- Variável de Opção: algepsilon
     Valor padrão: 10^8

     'algepsilon' é usada por 'algsys'.

 -- Função: bfloat (<expr>)
     Converte todos os números e funções de números em <expr> para
     grandes números em ponto flutuante (bigfloat).  O número de
     algarismos significativos no grande número em ponto flutuante
     resultante é especificado através da variável global 'fpprec'.

     Quando 'float2bf' for 'false' uma mensagem de alerta é mostrada
     quando uma número em ponto flutuante (float) é convertido em um
     grande número em ponto flutuante (bigfloat - uma vez que isso pode
     resultar em perda de precisão).

 -- Função: bfloatp (<expr>)
     Retorna 'true' se a avaliação da <expr> resultar em um grande
     número em ponto flutuante, de outra forma retorna 'false'.

 -- Função: bfpsi (<n>, <z>, <fpprec>)
 -- Função: bfpsi0 (<z>, <fpprec>)
     'bfpsi' é a função 'polygamma' de argumentos reais <z> e ordem de
     inteiro <n>.  'bfpsi0' é a função 'digamma'.  'bfpsi0 (<z>,
     <fpprec>)' é equivalente a 'bfpsi (0, <z>, <fpprec>)'.

     Essas funções retornam valores em grandes números em ponto
     flutuante.  <fpprec> é a precisão do valor de retorno dos grandes
     números em ponto flutuante.

     'load ("bffac")' chama essas funções.

 -- Variável de Opção: bftorat
     Valor padrão: 'false'

     'bftorat' controla a conversão de 'bfloats' para números racionais.
     Quando 'bftorat' for 'false', 'ratepsilon' será usada para
     controlar a conversão (isso resulta em números racionais
     relativametne pequenos).  Quando 'bftorat' for 'true', o número
     racional gerado irá representar precisamente o 'bfloat'.

 -- Variável de Opção: bftrunc
     Valor padrão: 'true'

     'bftrunc' faz com que tilhas de zeros em grandes números em ponto
     flutuante diferentes de zero sejam ocultadas.  Desse modo, se
     'bftrunc' for 'false', 'bfloat (1)' será mostrado como
     '1.000000000000000B0'.  De outra forma, será mostrado como '1.0B0'.

 -- Função: cbffac (<z>, <fpprec>)
     Fatorial complexo de grandes números em ponto flutuante.

     'load ("bffac")' chama essa função.

 -- Função: float (<expr>)
     Converte inteiros, números racionais e grandes números em ponto
     flutuante em <expr> para números em ponto flutuante.  Da mesma
     forma um 'evflag', 'float' faz com que números racionais
     não-inteiros e grandes números em ponto flutuante sejam convertidos
     para ponto flutuante.

 -- Variável de Opção: float2bf
     Valor padrão: 'false'

     Quando 'float2bf' for 'false', uma mensagem de alerta é mostrada
     quando um número em ponto flutuante é convertido em um grande
     número em ponto flutuante (uma vez que isso pode resultar em perda
     de precisão).

 -- Função: floatnump (<expr>)
     Retorna 'true' se <expr> for um número em ponto flutuante, de outra
     forma retorna 'false'.

 -- Variável de Opção: fpprec
     Valor padrão: 16

     'fpprec' é o número de algarismos significativos para aritmética
     sobre grandes números em ponto flutuante 'fpprec' não afeta
     cálculos sobre números em ponto flutuante comuns.

     Veja também 'bfloat' e 'fpprintprec'.

 -- Variável de Opção: fpprintprec
     Valor padrão: 0

     'fpprintprec' é o n;umero de dígitos a serem mostrados na tela
     quando no caso de nuúmeros em ponto flutuante e no caso de grandes
     números em ponto flutuante.

     Para números em ponto flutuante comuns, quando 'fpprintprec' tiver
     um valor entre 2 e 16 (inclusive), o n;umero de dígitos mostrado na
     tela é igual a 'fpprintprec'.  De outra forma, 'fpprintprec' é 0,
     ou maior que 16, e o número de dígitos mostrados é 16.

     Para grandes números em ponto flutuante, quando 'fpprintprec' tiver
     um valor entre 2 e 'fpprec' (inclusive), o n;umero de dígitos
     mostrados é giaul a 'fpprintprec'.  De outra forma, 'fpprintprec' é
     0, ou maior que 'fpprec', e o n;umero de dígitos mostrados é igual
     a 'fpprec'.

     'fpprintprec' não pode ser 1.


File: maxima.info,  Node: Contextos,  Next: Polinômios,  Prev: Ponto Flutuante,  Up: Top

11 Contextos
************

* Menu:

* Funções e Variáveis Definidas para Contextos::    


File: maxima.info,  Node: Funções e Variáveis Definidas para Contextos,  Prev: Contextos,  Up: Contextos

11.1 Funções e Variáveis Definidas para Contextos
=================================================

 -- Função: activate (<context_1>, ..., <context_n>)
     Ativa os contextos <context_1>, ..., <context_n>.  Os fatos nesses
     contextos estão então disponíveis para fazer deduções e recuperar
     informação.  Os fatos nesses contextos não são listadas através de
     'facts ()'.

     A variável 'activecontexts' é a lista de contextos que estão ativos
     pelo caminho da função 'activate'.

 -- Variável de sistema: activecontexts
     Valor padrão: '[]'

     'activecontexts' é a lista de contextos que estão ativos pelo
     caminho da função 'activate', em oposição a sendo ativo porque eles
     são subcontextos do contexto corrente.

 -- Função: assume (<pred_1>, ..., <pred_n>)
     Adiciona predicados <pred_1>, ..., <pred_n> ao contexto corrente.
     Se um predicado for incossistente ou redundante com os predicados
     no contexto corrente, esses predicados não são adicionados ao
     contexto.  O contexto acumula predicados de cada chamada a
     'assume'.

     'assume' retorna uma lista cujos elementos são os predicados
     adicionados ao contexto ou os átomos 'redundant' ou 'inconsistent'
     onde for aplicável.

     Os predicados <pred_1>, ..., <pred_n> podem somente ser expressões
     com os operadores relacionais '< <= equal notequal >=' e '>'.
     Predicados não podem ser expressões de igualdades literais '=' ou
     expressões de desigualdades literais '#', nem podem elas serem
     funções de predicado tais como 'integerp'.

     Predicados combinados da forma '<pred_1> and ... and <pred_n>' são
     reconhecidos, mas não '<pred_1> or ... or <pred_n>'.  'not
     <pred_k>' é reconhecidos se <pred_k> for um predicado relacional.
     Expressões da forma 'not (<pred_1> e <pred_2>)' and 'not (<pred_1>
     or <pred_2>)' não são reconhecidas.

     O mecanismo de dedução do Maxima não é muito forte; exitem
     conseqüências muito óbvias as quais não podem ser determinadas por
     meio de 'is'.  Isso é uma fraqueza conhecida.

     'assume' avalia seus argumentos.

     Veja também 'is', 'facts', 'forget', 'context', e 'declare'.

     Exemplos:

          (%i1) assume (xx > 0, yy < -1, zz >= 0);
          (%o1)              [xx > 0, yy < - 1, zz >= 0]
          (%i2) assume (aa < bb and bb < cc);
          (%o2)                  [bb > aa, cc > bb]
          (%i3) facts ();
          (%o3)     [xx > 0, - 1 > yy, zz >= 0, bb > aa, cc > bb]
          (%i4) is (xx > yy);
          (%o4)                         true
          (%i5) is (yy < -yy);
          (%o5)                         true
          (%i6) is (sinh (bb - aa) > 0);
          (%o6)                         true
          (%i7) forget (bb > aa);
          (%o7)                       [bb > aa]
          (%i8) prederror : false;
          (%o8)                         false
          (%i9) is (sinh (bb - aa) > 0);
          (%o9)                        unknown
          (%i10) is (bb^2 < cc^2);
          (%o10)                       unknown

 -- Variável de opção: assumescalar
     Valor padrão: 'true'

     'assumescalar' ajuda a governar se expressões 'expr' para as quais
     'nonscalarp (expr)' for 'false' são assumidas comportar-se como
     escalares para certas transformações.

     Tomemos 'expr' representando qualquer expressão outra que não uma
     lista ou uma matriz, e tomemos '[1, 2, 3]' representando qualquer
     lista ou matriz.  Então 'expr . [1, 2, 3]' retorna '[expr, 2 expr,
     3 expr]' se 'assumescalar' for 'true', ou 'scalarp (expr)' for
     'true', ou 'constantp (expr)' for 'true'.

     Se 'assumescalar' for 'true', tais expressões irão comportar-se
     como escalares somente para operadores comutativos, mas não para
     multiplicação não comutativa '.'.

     Quando 'assumescalar' for 'false', tais expressões irão
     comportar-se como não escalares.

     Quando 'assumescalar' for 'all', tais expressões irão comportar-se
     como escalares para todos os operadores listados acima.

 -- Variável de opção: assume_pos
     Valor padrão: 'false'

     Quando 'assume_pos' for 'true' e o sinal de um parâmetro <x> não
     pode ser determinado a partir do contexto corrente ou outras
     considerações, 'sign' e 'asksign (<x>)' retornam 'true'.  Isso pode
     impedir algum questionamento de 'asksign' gerado automaticamente,
     tal como pode surgir de 'integrate' ou de outros cálculos.

     Por padrão, um parâmetro é <x> tal como 'symbolp (<x>)' or 'subvarp
     (<x>)'.  A classe de expressões consideradas parâmetros pode ser
     modificada para alguma abrangência através da variável
     'assume_pos_pred'.

     'sign' e 'asksign' tentam deduzir o sinal de expressões a partir de
     sinais de operandos dentro da expressão.  Por exemplo, se 'a' e 'b'
     são ambos positivos, então 'a + b' é também positivo.

     Todavia, não existe caminho para desviar todos os questionamentos
     de 'asksign'.  Particularmente, quando o argumento de 'asksign' for
     uma diferença '<x> - <y>' ou um logarítmo 'log(<x>)', 'asksign'
     sempre solicita uma entrada ao usuário, mesmo quando 'assume_pos'
     for 'true' e 'assume_pos_pred' for uma função que retorna 'true'
     para todos os argumentos.

 -- Variável de opção: assume_pos_pred
     Valor padrão: 'false'

     Quando 'assume_pos_pred' for atribuído o nome de uma função ou uma
     expressão lambda de um argumento <x>, aquela função é chamada para
     determinar se <x> é considerado um parâmetro para o propósito de
     'assume_pos'.  'assume_pos_pred' é ignorado quando 'assume_pos' for
     'false'.

     A função 'assume_pos_pred' é chamada através de 'sign' e de
     'asksign' com um argumento <x> que é ou um átomo, uma variável
     subscrita, ou uma expressão de chamada de função.  Se a função
     'assume_pos_pred' retorna 'true', <x> é considerado um parâmetro
     para o propósito de 'assume_pos'.

     Por padrão, um parâmetro é <x> tal que 'symbolp (x)' ou 'subvarp
     (x)'.

     Veja também 'assume' e 'assume_pos'.

     Exemplos:

          (%i1) assume_pos: true$
          (%i2) assume_pos_pred: symbolp$
          (%i3) sign (a);
          (%o3)                          pos
          (%i4) sign (a[1]);
          (%o4)                          pnz
          (%i5) assume_pos_pred: lambda ([x], display (x), true)$
          (%i6) asksign (a);
                                        x = a

          (%o6)                          pos
          (%i7) asksign (a[1]);
                                       x = a
                                            1

          (%o7)                          pos
          (%i8) asksign (foo (a));
                                     x = foo(a)

          (%o8)                          pos
          (%i9) asksign (foo (a) + bar (b));
                                     x = foo(a)

                                     x = bar(b)

          (%o9)                          pos
          (%i10) asksign (log (a));
                                        x = a

          Is  a - 1  positive, negative, or zero?

          p;
          (%o10)                         pos
          (%i11) asksign (a - b);
                                        x = a

                                        x = b

                                        x = a

                                        x = b

          Is  b - a  positive, negative, or zero?

          p;
          (%o11)                         neg

 -- Variável de opção: context
     Valor padrão: 'initial'

     'context' nomeia a coleção de fatos mantida através de 'assume' e
     'forget'.  'assume' adiciona fatos à coleção nomeada através de
     'context', enquanto 'forget' remove fatos.

     Associando 'context' para um nome <foo> altera o contexto corrente
     para <foo>.  Se o contexto especificado <foo> não existe ainda, ele
     é criado automaticamente através de uma chamada a 'newcontext'.  O
     contexto especificado é ativado automaticamente.

     Veja 'contexts' para uma descrição geral do mecanismo de contexto.

 -- Variável de opção: contexts
     Valor padrão: '[initial, global]'

     'contexts' é uma lista dos contextos que existem atualmente,
     incluindo o contexto ativo atualmente.

     O mecanismo de contexto torna possível para um usuário associar e
     nomear uma porção selecionada de fatos, chamada um contexto.  Assim
     que isso for concluído, o usuário pode ter o Maxima assumindo ou
     esquecendo grande quantidade de fatos meramente através da ativação
     ou desativação seu contexto.

     Qualquer átomo simbólico pode ser um contexto, e os fatos contidos
     naquele contexto irão ser retidos em armazenamento até que sejam
     destruídos um por um através de chamadas a 'forget' ou destruídos
     com um conjunto através de uma chamada a 'kill' para destruir o
     contexto que eles pertencem.

     Contextos existem em uma hierarquía, com o raíz sempre sendo o
     contexto 'global', que contém informações sobre Maxima que alguma
     função precisa.  Quando em um contexto dado, todos os fatos naquele
     contexto estão "ativos" (significando que eles são usados em
     deduções e recuperados) como estão também todos os fatos em
     qualquer contexto que for um subcontexto do contexto ativo.

     Quando um novo Maxima for iniciado, o usuário está em um contexto
     chamado 'initial', que tem 'global' como um subcontexto.

     Veja também 'facts', 'newcontext', 'supcontext', 'killcontext',
     'activate', 'deactivate', 'assume', e 'forget'.

 -- Função: deactivate (<context_1>, ..., <context_n>)
     Desativa os contextos especificados <context_1>, ..., <context_n>.

 -- Função: facts (<item>)
 -- Função: facts ()
     Se <item> for o nome de um contexto, 'facts (<item>)' retorna uma
     lista de fatos no contexto especificado.

     Se <item> não for o nome de um contexto, 'facts (<item>)' retorna
     uma lista de fatos conhecidos sobre <item> no contexto atual.
     Fatos que estão atuvos, mas em um diferente contexto, não são
     listados.

     'facts ()' (i.e., sem argumento) lista o contexto atual.

 -- Declaração: features
     Maxima recnhece ceertas propriedades matemáticas de funções e
     variáveis.  Essas são chamadas "recursos".

     'declare (<x>, <foo>)' fornece a propriedade <foo> para a função ou
     variável <x>.

     'declare (<foo>, recurso)' declara um novo recurso <foo>.  Por
     exemplo, 'declare ([red, green, blue], feature)' declara três novos
     recursos, 'red', 'green', e 'blue'.

     O predicado 'featurep (<x>, <foo>)' retorna 'true' se <x> possui a
     propriedade <foo>, e 'false' de outra forma.

     A infolista 'features' é uma lista de recursos conhecidos.  São
     esses 'integer', 'noninteger', 'even', 'odd', 'rational',
     'irrational', 'real', 'imaginary', 'complex', 'analytic',
     'increasing', 'decreasing', 'oddfun', 'evenfun', 'posfun',
     'commutative', 'lassociative', 'rassociative', 'symmetric', e
     'antisymmetric', mais quaisquer recursos definidos pelo usuário.

     'features' é uma lista de recursos matemáticos.  Existe também uma
     lista de recursos não matemáticos, recursos dependentes do sistema.
     Veja 'status'.

 -- Função: forget (<pred_1>, ..., <pred_n>)
 -- Função: forget (<L>)
     Remove predicados estabelecidos através de 'assume'.  Os predicados
     podem ser expressões equivalentes a (mas não necessáriamente
     idênticas a) esses prevamentes assumidos.

     'forget (<L>)', onde <L> é uma lista de predicados, esquece cada
     item da lista.

 -- Função: killcontext (<context_1>, ..., <context_n>)
     Mata os contextos <context_1>, ..., <context_n>.

     Se um dos contextos estiver for o contexto atual, o novo contexto
     atual irá tornar-se o primeiro subcontexto disponível do contexto
     atual que não tiver sido morto.  Se o primeiro contexto disponível
     não morto for 'global' então 'initial' é usado em seu lugar.  Se o
     contexto 'initial' for morto, um novo, porém vazio contexto
     'initial' é criado.

     'killcontext' recusa-se a matar um contexto que estiver ativo
     atualmente, ou porque ele é um subcontexto do contexto atual, ou
     através do uso da função 'activate'.

     'killcontext' avalia seus argumentos.  'killcontext' retorna
     'done'.

 -- Função: newcontext (<nome>)
     Cria um novo contexto, porém vazio, chamado <nome>, que tem
     'global' como seu único subcontexto.  O contexto recentemente
     criado torna-se o contexto ativo atualmente.

     'newcontext' avalia seu argumento.  'newcontext' retorna <nome>.

 -- Função: supcontext (<nome>, <context>)
 -- Função: supcontext (<nome>)
     Cria um novo contexto, chamado <nome>, que tem <context> como um
     subcontexto.  <context> deve existir.

     Se <context> não for especificado, o contexto atual é assumido.


File: maxima.info,  Node: Polinômios,  Next: Constantes,  Prev: Contextos,  Up: Top

12 Polinômios
*************

* Menu:

* Introdução a Polinômios::  
* Funções e Variáveis Definidas para Polinômios::  


File: maxima.info,  Node: Introdução a Polinômios,  Next: Funções e Variáveis Definidas para Polinômios,  Prev: Polinômios,  Up: Polinômios

12.1 Introdução a Polinômios
============================

Polinômios são armazenados no Maxima ou na forma geral ou na forma de
Expressões Racionais Canônicas (CRE). Essa última é uma forma padrão, e
é usada internamente por operações tais como 'factor', 'ratsimp', e
assim por diante.

   Expressões Racionais Canônicas constituem um tipo de representação
que é especialmente adequado para polinômios expandidos e funções
racionais (também para polinômios parcialmente fatorados e funções
racionais quando RATFAC for escolhida para 'true').  Nessa forma CRE uma
ordenação de variáveis (da mais para a menos importante) é assumida para
cada expressão.  Polinômios são representados recursivamente por uma
lista consistindo da variável principal seguida por uma série de pares
de expressões, uma para cada termo do polinômio.  O primeiro membro de
cada par é o expoente da variável principal naquele termo e o segundo
membro é o coeficiente daquele termo que pode ser um número ou um
polinômio em outra variável novamente respresentado nessa forma.  Sendo
assim a parte principal da forma CRE de 3*X^2-1 é (X 2 3 0 -1) e que a
parte principal da forma CRE de 2*X*Y+X-3 é (Y 1 (X 1 2) 0 (X 1 1 0 -3))
assumindo Y como sendo a variável principal, e é (X 1 (Y 1 2 0 1) 0 -3)
assumindo X como sendo a variável principal.  A variável principal é
usualmente determineda pela ordem alfabética reversa.  As "variáveis" de
uma expressão CRE não necessariamente devem ser atômicas.  De fato
qualquer subexpressão cujo principal operador não for + - * / or ^ com
expoente inteiro será considerado uma "variável" da expressão (na forma
CRE) na qual essa ocorrer.  Por exemplo as variáveis CRE da expressão
X+SIN(X+1)+2*SQRT(X)+1 são X, SQRT(X), e SIN(X+1).  Se o usuário não
especifica uma ordem de variáveis pelo uso da função RATVARS Maxima
escolherá a alfabética por conta própria.  Em geral, CREs representam
expressões racionais, isto é, razões de polinômios, onde o numerador e o
denominador não possuem fatores comuns, e o denominador for positivo.  A
forma interna é essencialmente um par de polinômios (o numerador e o
denominador) precedidos pela lista de ordenação de variável.  Se uma
expressão a ser mostrada estiver na forma CRE ou se contiver quaisquer
subexpressões na forma CRE, o símbolo /R/ seguirá o rótulo da linha.
Veja a função RAT para saber como converter uma expressão para a forma
CRE. Uma forma CRE extendida é usada para a representação de séries de
Taylor.  A noção de uma expressão racional é extendida de modo que os
expoentes das variáveis podem ser números racionais positivos ou
negativos em lugar de apenas inteiros positivos e os coeficientes podem
eles mesmos serem expressões racionais como descrito acima em lugar de
apenas polinômios.  Estes são representados internamente por uma forma
polinomial recursiva que é similar à forma CRE e é a generalização dessa
mesma forma CRE, mas carrega informação adicional tal com o grau de
truncação.  Do mesmo modo que na forma CRE, o símbolo /T/ segue o rótulo
de linha que contém as tais expressões.


File: maxima.info,  Node: Funções e Variáveis Definidas para Polinômios,  Prev: Introdução a Polinômios,  Up: Polinômios

12.2 Funções e Variáveis Definidas para Polinômios
==================================================

 -- Variável de opção: algebraic
     Valor Padrão: 'false'

     'algebraic' deve ser escolhida para 'true' com o objetivo de que a
     simplificação de inteiros algébricos tenha efeito.

 -- Variável de opção: berlefact
     Valor Padrão: 'true'

     Quando 'berlefact' for 'false' então o algorítmo de fatoração de
     Kronecker será usado.  De outra forma o algorítmo de Berlekamp, que
     é o padrão, será usado.

 -- Função: bezout (<p1>, <p2>, <x>)
     uma alternativa para o comando 'resultant'.  Isso retorna uma
     matriz.  'determinant' dessa matriz é o resultante desejado.

 -- Função: bothcoef (<expr>, <x>)
     Retorna uma lista da qual o primeiro membro é o coeficiente de <x>
     em <expr> (como achado por 'ratcoef' se <expr> está na forma CRE de
     outro modo por 'coeff') e cujo segundo membro é a parte restante de
     <expr>.  Isto é, '[A, B]' onde '<expr> = A*<x> + B'.

     Exemplo:

          (%i1) islinear (expr, x) := block ([c],
                  c: bothcoef (rat (expr, x), x),
                  é (freeof (x, c) and c[1] # 0))$
          (%i2) islinear ((r^2 - (x - r)^2)/x, x);
          (%o2)                         true

 -- Função: coeff (<expr>, <x>, <n>)
     Retorna o coeficiente de '<x>^<n>' em <expr>.  <n> pode ser omitido
     se for 1.  <x> pode ser um átomo, ou subexpressão completa de
     <expr> e.g., 'sin(x)', 'a[i+1]', 'x + y', etc.  (No último caso a
     expressão '(x + y)' pode ocorrer em <expr>).  Algumas vezes isso
     pode ser necessário para expandir ou fatorar <expr> com o objetivo
     de fazer '<x>^<n>' explicito.  Isso não é realizado por 'coeff'.

     Exemplos:

          (%i1) coeff (2*a*tan(x) + tan(x) + b = 5*tan(x) + 3, tan(x));
          (%o1)                      2 a + 1 = 5
          (%i2) coeff (y + x*%e^x + 1, x, 0);
          (%o2)                         y + 1

 -- Função: combine (<expr>)
     Simplifica a adição <expr> por termos combinados com o mesmo
     denominador dentro de um termo simples.

 -- Função: content (<p_1>, <x_1>, ..., <x_n>)
     Retorna uma lista cujo primeiro elemento é o máximo divisor comum
     dos coeficientes dos termos do polinômio <p_1> na variável <x_n>
     (isso é o conteúdo) e cujo segundo elemento é o polinômio <p_1>
     dividido pelo conteúdo.

     Exemplos:

          (%i1) content (2*x*y + 4*x^2*y^2, y);
                                             2
          (%o1)                   [2 x, 2 x y  + y]

 -- Função: denom (<expr>)
     Retorna o denominador da expressão racional <expr>.

 -- Função: divide (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     calcula o quocietne e o resto do polinômio <p_1> dividido pelo
     polinômio <p_2>, na variável principal do polinômio, <x_n>.  As
     outras variáveis são como na função 'ratvars'.  O resultado é uma
     lista cujo primeiro elemento é o quociente e cujo segundo elemento
     é o resto.

     Exemplos:

          (%i1) divide (x + y, x - y, x);
          (%o1)                       [1, 2 y]
          (%i2) divide (x + y, x - y);
          (%o2)                      [- 1, 2 x]

     Note que 'y' é a variável principal no segundo exemplo.

 -- Função: eliminate ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_k>])
     Elimina variáveis de equações (ou expressões assumidas iguais a
     zero) pegando resultantes sucessivos.  Isso retorna uma lista de
     '<n> - <k>' expressões com <k> variáveis <x_1>, ..., <x_k>
     eliminadas.  Primeiro <x_1> é eliminado retornando '<n> - 1'
     expressões, então 'x_2' é eliminado, etc.  Se '<k> = <n>' então uma
     expressão simples em uma lista é retornada livre das variáveis
     <x_1>, ..., <x_k>.  Nesse caso 'solve' é chamado para resolver a
     última resultante para a última variável.

     Exemplo:

          (%i1) expr1: 2*x^2 + y*x + z;
                                                2
          (%o1)                    z + x y + 2 x
          (%i2) expr2: 3*x + 5*y - z - 1;
          (%o2)                  - z + 5 y + 3 x - 1
          (%i3) expr3: z^2 + x - y^2 + 5;
                                    2    2
          (%o3)                    z  - y  + x + 5
          (%i4) eliminate ([expr3, expr2, expr1], [y, z]);
                       8         7         6          5          4
          (%o4) [7425 x  - 1170 x  + 1299 x  + 12076 x  + 22887 x

                                              3         2
                                      - 5154 x  - 1291 x  + 7688 x + 15376]

 -- Função: ezgcd (<p_1>, <p_2>, <p_3>, ...)
     Retorna uma lista cujo primeiro elemento é o m.d.c.  dos polinômios
     <p_1>, <p_2>, <p_3>, ...  e cujos restantes elementos são os
     polinômios divididos pelo mdc.  Isso sempre usa o algorítmo
     'ezgcd'.

 -- Variável de opção: facexpand
     Valor Padrão: 'true'

     'facexpand' controla se os fatores irredutíveis retornados por
     'factor' estão na forma expandida (o padrão) ou na forma recursiva
     (CRE normal).

 -- Função: factcomb (<expr>)
     Tenta combinar os coeficientes de fatoriais em <expr> com os
     próprios fatoriais convertendo, por exemplo, '(n + 1)*n!' em '(n +
     1)!'.

     'sumsplitfact' se escolhida para 'false' fará com que
     'minfactorial' seja aplicado após um 'factcomb'.

 -- Função: factor (<expr>)
 -- Função: factor (<expr>, <p>)

     Fatora a expressão <expr>, contendo qualquer número de variáveis ou
     funções, em fatores irredutíveis sobre os inteiros.  'factor
     (<expr>, <p>)' fatora <expr> sobre o campo dos inteiros com um
     elemento adjunto cujo menor polinômio é <p>.

     'factor' usa a função 'ifactors' para fatorar inteiros.

     'factorflag' se 'false' suprime a fatoração de fatores inteiros de
     expressões racionais.

     'dontfactor' pode ser escolhida para uma lista de variáveis com
     relação à qual fatoração não é para ocorrer.  (Essa é inicialmente
     vazia).  Fatoração também não acontece com relação a quaisquer
     variáveis que são menos importantes (usando a ordenação de variável
     assumida pela forma CRE) como essas na lista 'dontfactor'.

     'savefactors' se 'true' faz com que os fatores de uma expressão que
     é um produto de fatores seja guardada por certas funções com o
     objetivo de aumentar a velocidade de futuras fatorações de
     expressões contendo alguns dos mesmos fatores.

     'berlefact' se 'false' então o algorítmo de fatoração de Kronecker
     será usado de outra forma o algorítmo de Berlekamp, que é o padrão,
     será usado.

     'intfaclim' se 'true' maxima irá interromper a fatoração de
     inteiros se nenhum fator for encontrado após tentar divisões e o
     método rho de Pollard.  Se escolhida para 'false' (esse é o caso
     quando o usuário chama 'factor' explicitamente), a fatoração
     completa do inteiro será tentada.  A escolha do usuário para
     'intfaclim' é usada para chamadas internas a 'factor'.  Dessa
     forma, 'intfaclim' pode ser resetada para evitar que o Maxima gaste
     um tempo muito longo fatorando inteiros grandes.

     Exemplos:

          (%i1) factor (2^63 - 1);
                              2
          (%o1)              7  73 127 337 92737 649657
          (%i2) factor (-8*y - 4*x + z^2*(2*y + x));
          (%o2)               (2 y + x) (z - 2) (z + 2)
          (%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                          2  2        2    2    2
          (%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
          (%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                                 2
                               (x  + 2 x + 1) (y - 1)
          (%o4)                ----------------------
                                     36 (y + 1)
          (%i5) factor (1 + %e^(3*x));
                                x         2 x     x
          (%o5)              (%e  + 1) (%e    - %e  + 1)
          (%i6) factor (1 + x^4, a^2 - 2);
                              2              2
          (%o6)             (x  - a x + 1) (x  + a x + 1)
          (%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                                 2
          (%o7)              - (y  + x) (z - x) (z + x)
          (%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                                       x + 2
          (%o8)               ------------------------
                                                     2
                              (x + 3) (x + b) (x + c)
          (%i9) ratsimp (%);
                          4                  3
          (%o9) (x + 2)/(x  + (2 c + b + 3) x

               2                       2             2                   2
           + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
          (%i10) partfrac (%, x);
                     2                   4                3
          (%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

               2              2         2                2
           + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                           c - 2
           - ---------------------------------
               2                             2
             (c  + (- b - 3) c + 3 b) (x + c)

                                   b - 2
           + -------------------------------------------------
                       2             2       3      2
             ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                                   1
           - ----------------------------------------------
                       2
             ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
          (%i11) map ('factor, %);
                        2
                       c  - 4 c - b + 6                 c - 2
          (%o11) - ------------------------- - ------------------------
                          2        2                                  2
                   (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                                 b - 2                        1
                      + ------------------------ - ------------------------
                                       2                          2
                        (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
          (%i12) ratsimp ((x^5 - 1)/(x - 1));
                                 4    3    2
          (%o12)                x  + x  + x  + x + 1
          (%i13) subst (a, x, %);
                                 4    3    2
          (%o13)                a  + a  + a  + a + 1
          (%i14) factor (%th(2), %);
                                 2        3        3    2
          (%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
          (%i15) factor (1 + x^12);
                                 4        8    4
          (%o15)               (x  + 1) (x  - x  + 1)
          (%i16) factor (1 + x^99);
                           2            6    3
          (%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

             10    9    8    7    6    5    4    3    2
           (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

             20    19    17    16    14    13    11    10    9    7    6
           (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

              4    3            60    57    51    48    42    39    33
           - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

              30    27    21    18    12    9    3
           - x   - x   + x   + x   - x   - x  + x  + 1)

 -- Variável de opção: factorflag
     Valor Padrão: 'false'

     Quando 'factorflag' for 'false', suprime a fatoração de fatores
     inteiros em expressões racionais.

 -- Função: factorout (<expr>, <x_1>, <x_2>, ...)
     Rearranja a adição <expr> em uma adição de parcelas da forma 'f
     (<x_1>, <x_2>, ...)*g' onde 'g' é um produto de expressões que não
     possuem qualquer <x_i> e 'f' é fatorado.

 -- Função: factorsum (<expr>)
     Tenta agrupar parcelas em fatores de <expr> que são adições em
     grupos de parcelas tais que sua adição é fatorável.  'factorsum'
     pode recuperar o resultado de 'expand ((x + y)^2 + (z + w)^2)' mas
     não pode recuperar 'expand ((x + 1)^2 + (x + y)^2)' porque os
     termos possuem variáveis em comum.

     Exemplo:

          (%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
                     2      2                            2      2
          (%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                               2        2    2            2
                                  + 2 u v x + u  x + a w  + v  + 2 u v + u
          (%i2) factorsum (%);
                                             2          2
          (%o2)            (x + 1) (a (z + w)  + (v + u) )

 -- Função: fasttimes (<p_1>, <p_2>)
     Retorna o produto dos polinômios <p_1> e <p_2> usando um algorítmo
     especial para a multiplicação de polinômios.  'p_1' e 'p_2' podem
     ser de várias variáveis, densos, e aproximadamente do mesmo
     tamanho.  A multiplicação clássica é de ordem 'n_1 n_2' onde 'n_1'
     é o grau de 'p_1' and 'n_2' é o grau de 'p_2'.  'fasttimes' é da
     ordem 'max (n_1, n_2)^1.585'.

 -- Função: fullratsimp (<expr>)
     'fullratsimp' aplica repetidamente 'ratsimp' seguido por
     simplificação não racional a uma expressão até que nenhuma mudança
     adicional ocorra, e retorna o resultado.

     Quando expressões não racionais estão envolvidas, uma chamada a
     'ratsimp' seguida como é usual por uma simplificação não racional
     ("geral") pode não ser suficiente para retornar um resultado
     simplificado.  Algumas vezes, mais que uma tal chamada pode ser
     necessária.  'fullratsimp' faz esse processo convenientemente.

     'fullratsimp (<expr>, <x_1>, ..., <x_n>)' pega um ou mais
     argumentos similar a 'ratsimp' e 'rat'.

     Exemplo:

          (%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                                 a/2     2   a/2     2
                               (x    - 1)  (x    + 1)
          (%o1)                -----------------------
                                        a
                                       x  - 1
          (%i2) ratsimp (expr);
                                    2 a      a
                                   x    - 2 x  + 1
          (%o2)                    ---------------
                                        a
                                       x  - 1
          (%i3) fullratsimp (expr);
                                        a
          (%o3)                        x  - 1
          (%i4) rat (expr);
                                 a/2 4       a/2 2
                               (x   )  - 2 (x   )  + 1
          (%o4)/R/             -----------------------
                                        a
                                       x  - 1

 -- Função: fullratsubst (<a>, <b>, <c>)
     é o mesmo que 'ratsubst' exceto que essa chama a si mesma
     recursivamente sobre esse resultado até que o resultado para de
     mudar.  Essa função é útil quando a expressão de substituição e a
     expressão substituída tenham uma ou mais variáveis em comum.

     'fullratsubst' irá também aceitar seus argumentos no formato de
     'lratsubst'.  Isto é, o primeiro argumento pode ser uma
     substituição simples de equação ou uma lista de tais equações,
     enquanto o segundo argumento é a expressão sendo processada.

     'load ("lrats")' chama 'fullratsubst' e 'lratsubst'.

     Exemplos:

          (%i1) load ("lrats")$
        * 'subst' pode realizar multiplas substituições.  'lratsubst' é
          analogo a 'subst'.
          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c
        * Se somente uma substituição é desejada, então uma equação
          simples pode ser dada como primeiro argumento.
          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b
        * 'fullratsubst' é equivalente a 'ratsubst' exceto que essa
          executa recursivamente até que seu resultado para de mudar.
          (%i5) ratsubst (b*a, a^2, a^3);
                                         2
          (%o5)                         a  b
          (%i6) fullratsubst (b*a, a^2, a^3);
                                           2
          (%o6)                         a b
        * 'fullratsubst' também aceita uma lista de equações ou uma
          equação simples como primeiro argumento.
          (%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
          (%o7)                           b
          (%i8) fullratsubst (a^2 = b*a, a^3);
                                           2
          (%o8)                         a b
        * 'fullratsubst' pode causar uma recursão infinita.
          (%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

          *** - Lisp stack overflow. RESET

 -- Função: gcd (<p_1>, <p_2>, <x_1>, ...)
     Retorna o máximo divisor comum entre <p_1> e <p_2>.  O sinalizador
     'gcd' determina qual algorítmo é empregado.  Escolhendo 'gcd' para
     'ez', 'subres', 'red', ou 'spmod' seleciona o algorítmo 'ezgcd',
     subresultante 'prs', reduzido, ou modular, respectivamente.  Se
     'gcd' for 'false' então 'gcd (<p_1>, <p_2>, <x>)' sempre retorna 1
     para todo <x>.  Muitas funções (e.g.  'ratsimp', 'factor', etc.)
     fazem com que mdc's sejam feitos implicitamente.  Para polinômios
     homogêneos é recomendado que 'gcd' igual a 'subres' seja usado.
     Para pegar o mdc quando uma expressão algébrica está presente, e.g.
     'gcd (<x>^2 - 2*sqrt(2)*<x> + 2, <x> - sqrt(2))', 'algebraic' deve
     ser 'true' e 'gcd' não deve ser 'ez'.  'subres' é um novo
     algorítmo, e pessoas que tenham estado usando a opção 'red' podem
     provavelmente alterar isso para 'subres'.

     O sinalizador 'gcd', padrão: 'subres', se 'false' irá também evitar
     o máximo divisor comum de ser usado quando expressões são
     convertidas para a forma de expressão racional canônica (CRE). Isso
     irá algumas vezes aumentar a velocidade dos cálculos se mdc's não
     são requeridos.

 -- Função: gcdex (<f>, <g>)
 -- Função: gcdex (<f>, <g>, <x>)
     Retornam uma lista '[<a>, <b>, <u>]' onde <u> é o máximo divisor
     comum (mdc) entre <f> e <g>, e <u> é igual a '<a> <f> + <b> <g>'.
     Os argumentos <f> e <g> podem ser polinômios de uma variável, ou de
     outra forma polinômios em <x> uma main(principal) variável suprida
     desde que nós precisamos estar em um domínio de ideal principal
     para isso trabalhar.  O mdc significa o mdc considerando <f> e <g>
     como polinômios de uma única variável com coeficientes sendo
     funções racionais em outras variáveis.

     'gcdex' implementa o algorítmo Euclideano, onde temos a seqüência
     of 'L[i]: [a[i], b[i], r[i]]' que são todos perpendiculares a '[f,
     g, -1]' e o próximo se é construído como se 'q =
     quotient(r[i]/r[i+1])' então 'L[i+2]: L[i] - q L[i+1]', e isso
     encerra em 'L[i+1]' quando o resto 'r[i+2]' for zero.

          (%i1) gcdex (x^2 + 1, x^3 + 4);
                                 2
                                x  + 4 x - 1  x + 4
          (%o1)/R/           [- ------------, -----, 1]
                                     17        17
          (%i2) % . [x^2 + 1, x^3 + 4, -1];
          (%o2)/R/                        0

     Note que o mdc adiante é '1' uma vez que trabalhamos em 'k(y)[x]',
     o 'y+1' não pode ser esperado em 'k[y, x]'.

          (%i1) gcdex (x*(y + 1), y^2 - 1, x);
                                         1
          (%o1)/R/                 [0, ------, 1]
                                        2
                                       y  - 1

 -- Função: gcfactor (<n>)
     Fatora o inteiro Gaussiano <n> sobre os inteiros Gaussianos, i.e.,
     números da forma '<a> + <b> %i' onde <a> e <b> são inteiros
     raconais (i.e., inteiros comuns).  Fatorações são normalizadas
     fazendo <a> e <b> não negativos.

 -- Função: gfactor (<expr>)
     Fatora o polinômio <expr> sobre os inteiros de Gauss (isto é, os
     inteiros com a unidade imaginária '%i' adjunta).  Isso é como
     'factor (<expr>, <a>^2+1)' trocando <a> por '%i'.

     Exemplo:

          (%i1) gfactor (x^4 - 1);
          (%o1)           (x - 1) (x + 1) (x - %i) (x + %i)

 -- Função: gfactorsum (<expr>)
     é similar a 'factorsum' mas aplica 'gfactor' em lugar de 'factor'.

 -- Função: hipow (<expr>, <x>)
     Retorna o maior expoente explícito de <x> em <expr>.  <x> pode ser
     uma variável ou uma expressão geral.  Se <x> não aparece em <expr>,
     'hipow' retorna '0'.

     'hipow' não considera expressões equivalentes a 'expr'.  Em
     particular, 'hipow' não expande 'expr', então 'hipow (<expr>, <x>)'
     e 'hipow (expand (<expr>, <x>))' podem retornar diferentes
     resultados.

     Exemplos:

          (%i1) hipow (y^3 * x^2 + x * y^4, x);
          (%o1)                           2
          (%i2) hipow ((x + y)^5, x);
          (%o2)                           1
          (%i3) hipow (expand ((x + y)^5), x);
          (%o3)                           5
          (%i4) hipow ((x + y)^5, x + y);
          (%o4)                           5
          (%i5) hipow (expand ((x + y)^5), x + y);
          (%o5)                           0

 -- Variável de opção: intfaclim
     Valor padrão: true

     Se 'true', maxima irá interromper a fatoração de inteiros se nenhum
     fator for encontrado após tentar divisões e o método rho de Pollard
     e a fatoração não será completada.

     Quando 'intfaclim' for 'false' (esse é o caso quando o usuário
     chama 'factor' explicitamente), a fatoração completa será tentada.
     'intfaclim' é escolhida para 'false' quando fatores são calculados
     em 'divisors', 'divsum' e 'totient'.

     Chamadas internas a 'factor' respeitam o valor especificado pelo
     usuário para 'intfaclim'.  Setting 'intfaclim' to 'true' may reduce
     'intfaclim'.  Escolhendo 'intfaclim' para 'true' podemos reduzir o
     tempo gasto fatorando grandes inteiros.

 -- Variável de opção: keepfloat
     Valor Padrão: 'false'

     Quando 'keepfloat' for 'true', evitamos que números em ponto
     flutuante sejam racionalizados quando expressões que os possuem são
     então convertidas para a forma de expressão racional canônica
     (CRE).

 -- Função: lratsubst (<L>, <expr>)
     é análogo a 'subst (<L>, <expr>)' exceto que esse usa 'ratsubst' em
     lugar de 'subst'.

     O primeiro argumento de 'lratsubst' é uma equação ou uma lista de
     equações idênticas em formato para que sejam aceitas por 'subst'.
     As substituições são feitas na ordem dada pela lista de equações,
     isto é, da esquerda para a direita.

     'load ("lrats")' chama 'fullratsubst' e 'lratsubst'.

     Exemplos:

          (%i1) load ("lrats")$
        * 'subst' pode realizar multiplas substituições.  'lratsubst' é
          analoga a 'subst'.
          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c
        * Se somente uma substituição for desejada, então uma equação
          simples pode ser dada como primeiro argumento.
          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b

 -- Variável de opção: modulus
     Valor Padrão: 'false'

     Quando 'modulus' for um número positivo <p>, operações sobre os
     números racionais (como retornado por 'rat' e funções relacionadas)
     são realizadas módulo <p>, usando o então chamado sistema de módulo
     "balanceado" no qual '<n> módulo <p>' é definido como um inteiro
     <k> em '[-(<p>-1)/2, ..., 0, ..., (<p>-1)/2]' quando <p> for ímpar,
     ou '[-(<p>/2 - 1), ..., 0, ...., <p>/2]' quando <p> for par, tal
     que '<a> <p> + <k>' seja igual a <n> para algum inteiro <a>.

     Se <expr> já estiver na forma de expressão racional canônica (CRE)
     quando 'modulus' for colocado em seu valor original, então você
     pode precisar repetir o rat <expr>, e.g., 'expr: rat (ratdisrep
     (expr))', com o objetivo de pegar resultados corretos.

     Tipicamente 'modulus' é escolhido para um número primo.  Se
     'modulus' for escolhido para um inteiro não primo positivo, essa
     escolha é aceita, mas uma mensagem de alerta é mostrada.  Maxima
     permitirá que zero ou um inteiro negativo seja atribuído a
     'modulus', embora isso não seja limpo se aquele tiver quaisquer
     conseqüências úteis.

 -- Função: num (<expr>)
     Retorna o numerador de <expr> se isso for uma razão.  Se <expr> não
     for uma razão, <expr> é retornado.

     'num' avalia seu argumento.

 -- Função: polydecomp (<p>, <x>)

     Decompões o polinômio <p> na variável <x> em uma composição
     funcional de polinômios em <x>.  'polydecomp' retorna uma lista
     '[<p_1>, ..., <p_n>]' tal que

          lambda ([x], p_1) (lambda ([x], p_2) (... (lambda ([x], p_n) (x)) ...))

     seja igual a <p>.  O grau de <p_i> é maior que 1 para <i> menor que
     <n>.

     Tal decomposição não é única.

     Exemplos:

          (%i1) polydecomp (x^210, x);
                                    7   5   3   2
          (%o1)                   [x , x , x , x ]
          (%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                          6      4      3    2
          (%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
          (%i3) polydecomp (p, x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     As seguintes funções compõem 'L = [e_1, ..., e_n]' como funções em
     'x'; essa funçào é a inversa de 'polydecomp':

          compose (L, x) :=
            block ([r : x], for e in L do r : subst (e, x, r), r) $

     Re-exprimindo o exemplo acima usando 'compose':

          (%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     Note que apesar de 'compose (polydecomp (<p>, <x>), <x>)' sempre
     retornar <p> (não expandido), 'polydecomp (compose ([<p_1>, ...,
     <p_n>], <x>), <x>)' não necessáriamente retorna '[<p_1>, ...,
     <p_n>]':

          (%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                                    2       2
          (%o4)                   [x  + 2, x  + 1]
          (%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
                                2       2
                               x  + 3  x  + 5
          (%o5)               [------, ------, 2 x + 1]
                                 4       2

 -- Função: quotient (<p_1>, <p_2>)
 -- Função: quotient (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Retorna o polinômio <p_1> dividido pelo polinômio <p_2>.  Os
     argumentos <x_1>, ..., <x_n> são interpretados como em 'ratvars'.

     'quotient' retorna o primeiro elemento de uma lista de dois
     elementos retornada por 'divide'.

 -- Função: rat (<expr>)
 -- Função: rat (<expr>, <x_1>, ..., <x_n>)
     Converte <expr> para a forma de expressão racional canônica (CRE)
     expandindo e combinando todos os termos sobre um denominador comum
     e cancelando para fora o máximo divisor comum entre o numerador e o
     denominador, também convertendo números em ponto flutuante para
     números racionais dentro da tolerância de 'ratepsilon'.  As
     variáveis são ordenadas de acordo com <x_1>, ..., <x_n>, se
     especificado, como em 'ratvars'.

     'rat' geralmente não simplifica funções outras que não sejam adição
     '+', subtração '-', multiplicação '*', divisão '/', e exponenciação
     com expoente inteiro, uma vez que 'ratsimp' não manuseia esses
     casos.  Note que átomos (números e variáveis) na forma CRE não são
     os mesmos que eles são na forma geral.  Por exemplo, 'rat(x)- x'
     retorna 'rat(0)' que tem uma representação interna diferente de 0.

     Quando 'ratfac' for 'true', 'rat' retorna uma forma parcialmente
     fatorada para CRE. Durante operações racionais a expressão é
     mantida como totalmente fatorada como possível sem uma chamada ao
     pacote de fatoração ('factor').  Isso pode sempre economizar espaço
     de memória e algum tempo em algumas computações.  O numerador e o
     denominador são ainda tidos como relativamente primos (e.g.  'rat
     ((x^2 - 1)^4/(x + 1)^2)' retorna '(x - 1)^4 (x + 1)^2)', mas os
     fatores dentro de cada parte podem não ser relativamente primos.

     'ratprint' se 'false' suprime a impressão de mensagens informando o
     usuário de conversões de números em ponto flutuante para números
     racionais.

     'keepfloat' se 'true' evita que números em ponto flutuante sejam
     convertidos para números racionais.

     Veja também 'ratexpand' e 'ratsimp'.

     Exemplos:

          (%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /(4*y^2 + x^2);
                                                     4
                                            (x - 2 y)
                        (y + a) (2 y + x) (------------ + 1)
                                             2      2 2
                                           (x  - 4 y )
          (%o1)         ------------------------------------
                                        2    2
                                     4 y  + x
          (%i2) rat (%, y, a, x);
                                      2 a + 2 y
          (%o2)/R/                    ---------
                                       x + 2 y

 -- Variável de opção: ratalgdenom
     Valor Padrão: 'true'

     Quando 'ratalgdenom' for 'true', permite racionalização de
     denominadores com respeito a radicais tenham efeito.  'ratalgdenom'
     tem efeito somente quando expressões racionais canônicas (CRE)
     forem usadas no modo algébrico.

 -- Função: ratcoef (<expr>, <x>, <n>)
 -- Função: ratcoef (<expr>, <x>)
     Retorna o coeficiente da expressão '<x>^<n>' dentro da expressão
     <expr>.  Se omitido, <n> é assumido ser 1.

     O valor de retorno está livre (exceto possivelmente em um senso não
     racional) das variáveis em <x>.  Se nenhum coeficiente desse tipo
     existe, 0 é retornado.

     'ratcoef' expande e simplifica racionalmente seu primeiro argumento
     e dessa forma pode produzir respostas diferentes das de 'coeff' que
     é puramente sintática.  Dessa forma 'ratcoef ((x + 1)/y + x, x)'
     retorna '(y + 1)/y' ao passo que 'coeff' retorna 1.

     'ratcoef (<expr>, <x>, 0)', visualiza <expr> como uma adição,
     retornando uma soma desses termos que não possuem <x>.  portanto se
     <x> ocorre para quaisquer expoentes negativos, 'ratcoef' pode não
     ser usado.

     Uma vez que <expr> é racionalmente simplificada antes de ser
     examinada, coeficientes podem não aparecer inteiramente no caminho
     que eles foram pensados.

     Exemplo:

          (%i1) s: a*x + b*x + 5$
          (%i2) ratcoef (s, a + b);
          (%o2)                           x

 -- Função: ratdenom (<expr>)
     Retorna o denominador de <expr>, após forçar a conversão de <expr>
     para expressão racional canônica (CRE). O valor de retorno é a CRE.

     <expr> é forçada para uma CRE por 'rat' se não for já uma CRE. Essa
     conversão pode mudar a forma de <expr> colocando todos os termos
     sobre um denominador comum.

     'denom' é similar, mas retorna uma expressão comum em lugar de uma
     CRE. Também, 'denom' não tenta colocar todos os termos sobre um
     denominador comum, e dessa forma algumas expressões que são
     consideradas razões por 'ratdenom' não são consideradas razões por
     'denom'.

 -- Variável de opção: ratdenomdivide
     Valor Padrão: 'true'

     Quando 'ratdenomdivide' for 'true', 'ratexpand' expande uma razão
     cujo o numerador for uma adição dentro de uma soma de razões, tendo
     todos um denominador comum.  De outra forma, 'ratexpand' colapsa
     uma adição de razões dentro de uma razão simples, cujo numerador
     seja a adição dos numeradores de cada razão.

     Exemplos:

          (%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                                      2
                                     x  + x + 1
          (%o1)                      ----------
                                        2
                                       y  + 7
          (%i2) ratdenomdivide: true$
          (%i3) ratexpand (expr);
                                 2
                                x        x        1
          (%o3)               ------ + ------ + ------
                               2        2        2
                              y  + 7   y  + 7   y  + 7
          (%i4) ratdenomdivide: false$
          (%i5) ratexpand (expr);
                                      2
                                     x  + x + 1
          (%o5)                      ----------
                                        2
                                       y  + 7
          (%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
                                               2
                                     b        a
          (%o6)                    ------ + ------
                                    2        2
                                   b  + 3   b  + 3
          (%i7) ratexpand (expr2);
                                            2
                                       b + a
          (%o7)                        ------
                                        2
                                       b  + 3

 -- Função: ratdiff (<expr>, <x>)
     Realiza a derivação da expressão racional <expr> com relação a <x>.
     <expr> deve ser uma razão de polinômios ou um polinômio em <x>.  O
     argumento <x> pode ser uma variável ou uma subexpressão de <expr>.

     O resultado é equivalente a 'diff', embora talvez em uma forma
     diferente.  'ratdiff' pode ser mais rápida que 'diff', para
     expressões racionais.

     'ratdiff' retorna uma expressão racional canônica (CRE) se 'expr'
     for uma CRE. De outra forma, 'ratdiff' retorna uma expressão geral.

     'ratdiff' considera somente as dependências de <expr> sobre <x>, e
     ignora quaisquer dependências estabelecidas por 'depends'.

     Exemplo:

          (%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                                     3
                                  4 x  + 10 x - 11
          (%o1)                   ----------------
                                        5
                                       x  + 5
          (%i2) ratdiff (expr, x);
                              7       5       4       2
                           8 x  + 40 x  - 55 x  - 60 x  - 50
          (%o2)          - ---------------------------------
                                    10       5
                                   x   + 10 x  + 25
          (%i3) expr: f(x)^3 - f(x)^2 + 7;
                                   3       2
          (%o3)                   f (x) - f (x) + 7
          (%i4) ratdiff (expr, f(x));
                                     2
          (%o4)                   3 f (x) - 2 f(x)
          (%i5) expr: (a + b)^3 + (a + b)^2;
                                        3          2
          (%o5)                  (b + a)  + (b + a)
          (%i6) ratdiff (expr, a + b);
                              2                    2
          (%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a

 -- Função: ratdisrep (<expr>)
     Retorna seu argumento como uma expressão geral.  Se <expr> for uma
     expressão geral, é retornada inalterada.

     Tipicamente 'ratdisrep' é chamada para converter uma expressão
     racional canônica (CRE) em uma expressão geral.  Isso é algumas
     vezes conveniente se deseja-se parar o "contágio", ou caso se
     esteja usando funções racionais em contextos não racionais.

     Veja também 'totaldisrep'.

 -- Variável de opção: ratepsilon
     Valor Padrão: 2.0e-8

     'ratepsilon' é a tolerância usada em conversões de números em ponto
     flutuante para números racionais.

 -- Função: ratexpand (<expr>)
 -- Variável de opção: ratexpand
     Expande <expr> multiplicando para fora produtos de somas e somas
     exponenciadas, combinando frações sobre um denominador comum,
     cancelando o máximo divisor comum entre entre o numerador e o
     denominador, então quebrando o numerador (se for uma soma) dentro
     de suas respectivas parcelas divididas pelo denominador.

     O valor de retorno de 'ratexpand' é uma expressão geral, mesmo se
     <expr> for uma expressão racional canônica (CRE).

     O comutador 'ratexpand' se 'true' fará com que expressões CRE sejam
     completamente expandidas quando forem convertidas de volta para a
     forma geral ou mostradas, enquanto se for 'false' então elas serão
     colocadas na forma recursiva.  Veja também 'ratsimp'.

     Quando 'ratdenomdivide' for 'true', 'ratexpand' expande uma razão
     na qual o numerador é uma adição dentro de uma adição de razões,
     todas tendo um denominador comum.  De outra forma, 'ratexpand'
     contrai uma soma de razões em uma razão simples, cujo numerador é a
     soma dos numeradores de cada razão.

     Quando 'keepfloat' for 'true', evita que números em ponto flutuante
     sejam racionalizados quando expressões que contenham números em
     ponto flutuante forem convertidas para a forma de expressão
     racional canônica (CRE).

     Exemplos:

          (%i1) ratexpand ((2*x - 3*y)^3);
                               3         2       2        3
          (%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
          (%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                                   x - 1       1
          (%o2)                   -------- + -----
                                         2   x - 1
                                  (x + 1)
          (%i3) expand (expr);
                              x              1           1
          (%o3)          ------------ - ------------ + -----
                          2              2             x - 1
                         x  + 2 x + 1   x  + 2 x + 1
          (%i4) ratexpand (expr);
                                  2
                               2 x                 2
          (%o4)           --------------- + ---------------
                           3    2            3    2
                          x  + x  - x - 1   x  + x  - x - 1

 -- Variável de opção: ratfac
     Valor Padrão: 'false'

     Quando 'ratfac' for 'true', expressões racionais canônicas (CRE)
     são manipuladas na forma parcialmente fatorada.

     Durante operações racionais a expressão é mantida como
     completamente fatorada como foi possível sem chamadas a 'factor'.
     Isso pode sempre economizar espaço e pode economizar tempo em
     algumas computações.  O numerador e o denominador são feitos
     relativamente primos, por exemplo 'rat ((x^2 - 1)^4/(x + 1)^2)'
     retorna '(x - 1)^4 (x + 1)^2)', mas o fator dentro de cada parte
     pode não ser relativamente primo.

     No pacote 'ctensor' (Manipulação de componentes de tensores),
     tensores de Ricci, Einstein, Riemann, e de Weyl e a curvatura
     escalar são fatorados automaticamente quando 'ratfac' for 'true'.
     'ratfac' pode somente ser escolhido para casos onde as componentes
     tensoriais sejam sabidametne consistidas de poucos termos.

     Os esquemas de 'ratfac' e de 'ratweight' são incompatíveis e não
     podem ambos serem usados ao mesmo tempo.

 -- Função: ratnumer (<expr>)
     Retorna o numerador de <expr>, após forçar <expr> para uma
     expressão racional canônica (CRE). O valor de retorno é uma CRE.

     <expr> é forçada para uma CRE por 'rat' se isso não for já uma CRE.
     Essa conversão pode alterar a forma de <expr> pela colocação de
     todos os termos sobre um denominador comum.

     'num' é similar, mas retorna uma expressão comum em lugar de uma
     CRE. Também, 'num' não tenta colocar todos os termos sobre um
     denominador comum, e dessa forma algumas expressões que são
     consideradas razões por 'ratnumer' não são consideradas razões por
     'num'.

 -- Função: ratnump (<expr>)
     Retorna 'true' se <expr> for um inteiro literal ou razão de
     inteiros literais, de outra forma retorna 'false'.

 -- Função: ratp (<expr>)
     Retorna 'true' se <expr> for uma expressão racional canônica (CRE)
     ou CRE extendida, de outra forma retorna 'false'.

     CRE são criadas por 'rat' e funções relacionadas.  CRE extendidas
     são criadas por 'taylor' e funções relacionadas.

 -- Variável de opção: ratprint
     Valor Padrão: 'true'

     Quando 'ratprint' for 'true', uma mensagem informando ao usuário da
     conversão de números em ponto flutuante para números racionais é
     mostrada.

 -- Função: ratsimp (<expr>)
 -- Função: ratsimp (<expr>, <x_1>, ..., <x_n>)
     Simplifica a expressão <expr> e todas as suas subexpressões,
     incluindo os argumentos para funções não racionais.  O resultado é
     retornado como o quociente de dois polinômios na forma recursiva,
     isto é, os coeficientes de variável principal são polinômios em
     outras variáveis.  Variáveis podem incluir funções não racionais
     (e.g., 'sin (x^2 + 1)') e os argumentos para quaisquer tais funções
     são também simplificados racionalmente.

     'ratsimp (<expr>, <x_1>, ..., <x_n>)' habilita simplificação
     racional com a especiicação de variável ordenando como em
     'ratvars'.

     Quando 'ratsimpexpons' for 'true', 'ratsimp' é aplicado para os
     expoentes de expressões durante a simplificação.

     Veja também 'ratexpand'.  Note que 'ratsimp' é afetado por algum
     dos sinalizadores que afetam 'ratexpand'.

     Exemplos:

          (%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                                   2      2
                             x         (log(x) + 1)  - log (x)
          (%o1)        sin(------) = %e
                            2
                           x  + x
          (%i2) ratsimp (%);
                                       1          2
          (%o2)                  sin(-----) = %e x
                                     x + 1
          (%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                                 3/2
                          (x - 1)    - sqrt(x - 1) (x + 1)
          (%o3)           --------------------------------
                               sqrt((x - 1) (x + 1))
          (%i4) ratsimp (%);
                                     2 sqrt(x - 1)
          (%o4)                    - -------------
                                           2
                                     sqrt(x  - 1)
          (%i5) x^(a + 1/a), ratsimpexpons: true;
                                         2
                                        a  + 1
                                        ------
                                          a
          (%o5)                        x

 -- Variável de opção: ratsimpexpons
     Valor Padrão: 'false'

     Quando 'ratsimpexpons' for 'true', 'ratsimp' é aplicado para os
     expoentes de expressões durante uma simplificação.

 -- Função: ratsubst (<a>, <b>, <c>)
     Substitue <a> por <b> em <c> e retorna a expressão resultante.  <b>
     pode também ser uma adição, produto, expoente, etc.

     'ratsubst' sabe alguma coisa do significado de expressões uma vez
     que 'subst' não é uma substituição puramente sintática.  Dessa
     forma 'subst (a, x + y, x + y + z)' retorna 'x + y + z' ao passo
     que 'ratsubst' retorna 'z + a'.

     Quando 'radsubstflag' for 'true', 'ratsubst' faz substituição de
     radicais em expressões que explicitamente não possuem esses
     radicais.

     Exemplos:

          (%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                                        3      4
          (%o1)                      a x  y + a
          (%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
                         4         3         2
          (%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
          (%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
                      4           2                     2
          (%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
          (%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                                  4           2
          (%o4)                cos (x) - 2 cos (x) + 1
          (%i5) radsubstflag: false$
          (%i6) ratsubst (u, sqrt(x), x);
          (%o6)                           x
          (%i7) radsubstflag: true$
          (%i8) ratsubst (u, sqrt(x), x);
                                          2
          (%o8)                          u

 -- Função: ratvars (<x_1>, ..., <x_n>)
 -- Função: ratvars ()
 -- Variável de sistema: ratvars
     Declara variáveis principais <x_1>, ..., <x_n> para expressões
     racionais.  <x_n>, se presente em uma expressão racional, é
     considerada a variável principal.  De outra forma, <x_[n-1]> é
     considerada a variável principal se presente, e assim por diante
     até as variáveis precedentes para <x_1>, que é considerada a
     variável principal somente se nenhuma das variáveis que a sucedem
     estiver presente.

     Se uma variável em uma expressão racional não está presente na
     lista 'ratvars', a ela é dada uma prioridade menor que <x_1>.

     Os argumentos para 'ratvars' podem ser ou variáveis ou funções não
     racionais tais como 'sin(x)'.

     A variável 'ratvars' é uma lista de argumentos da função 'ratvars'
     quando ela foi chamada mais recentemente.  Cada chamada para a
     função 'ratvars' sobre-grava a lista apagando seu conteúdo
     anterior.  'ratvars ()' limpa a lista.

 -- Função: ratweight (<x_1>, <w_1>, ..., <x_n>, <w_n>)
 -- Função: ratweight ()
     Atribui um peso <w_i> para a variável <x_i>.  Isso faz com que um
     termo seja substituído por 0 se seu peso exceder o valor da
     variável 'ratwtlvl' (o padrão retorna sem truncação).  O peso de um
     termo é a soma dos produtos dos pesos de uma variável no termo
     vezes seu expoente.  Por exemplo, o peso de '3 x_1^2 x_2' é '2 w_1
     + w_2'.  A truncação de acordo com 'ratwtlvl' é realizada somente
     quando multiplicando ou exponencializando expressões racionais
     canônicas (CRE).

     'ratweight ()' retorna a lista cumulativa de atribuições de pesos.

     Nota: Os esquemas de 'ratfac' e 'ratweight' são incompatíveis e não
     podem ambo serem usados ao mesmo tempo.

     Exemplos:

          (%i1) ratweight (a, 1, b, 1);
          (%o1)                     [a, 1, b, 1]
          (%i2) expr1: rat(a + b + 1)$
          (%i3) expr1^2;
                            2                  2
          (%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
          (%i4) ratwtlvl: 1$
          (%i5) expr1^2;
          (%o5)/R/                  2 b + 2 a + 1

 -- Variável de sistema: ratweights
     Valor Padrão: '[]'

     'ratweights' é a lista de pesos atribuídos por 'ratweight'.  A
     lista é cumulativa: cada chamada a 'ratweight' coloca ítens
     adicionais na lista.

     'kill (ratweights)' e 'save (ratweights)' ambos trabalham como
     esperado.

 -- Variável de opção: ratwtlvl
     Valor Padrão: 'false'

     'ratwtlvl' é usada em combinação com a função 'ratweight' para
     controlar a truncação de expressão racionais canônicas (CRE). Para
     o valor padrão 'false', nenhuma truncação ocorre.

 -- Função: remainder (<p_1>, <p_2>)
 -- Função: remainder (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Retorna o resto do polinômio <p_1> dividido pelo polinômio <p_2>.
     Os argumentos <x_1>, ..., <x_n> são interpretados como em
     'ratvars'.

     'remainder' retorna o segundo elemento de uma lista de dois
     elementos retornada por 'divide'.

 -- Função: resultant (<p_1>, <p_2>, <x>)
 -- Variável: resultant
     Calcula o resultante de dois polinômios <p_1> e <p_2>, eliminando a
     variável <x>.  O resultante é um determinante dos coeficientes de
     <x> em <p_1> e <p_2>, que é igual a zero se e somente se <p_1> e
     <p_2> tiverem um fator em comum não constante.

     Se <p_1> ou <p_2> puderem ser fatorados, pode ser desejável chamar
     'factor' antes de chamar 'resultant'.

     A variável 'resultant' controla que algorítmo será usado para
     calcular o resultante.  'subres' para o prs subresultante, 'mod'
     para o algorítmo resultante modular, e 'red' para prs reduzido.
     Para muitos problemas 'subres' pode ser melhor.  Para alguns
     problemas com valores grandes de grau de uma única variável ou de
     duas variáveis 'mod' pode ser melhor.

     A função 'bezout' pega os mesmos argumentos que 'resultant' e
     retorna uma matriz.  O determinante do valor de retorno é o
     resultante desejado.

 -- Variável de opção: savefactors
     Valor Padrão: 'false'

     Quando 'savefactors' for 'true', faz com que os fatores de uma
     expressão que é um produto de fatores sejam gravados por certas
     funções com o objetivo de aumentar a velocidade em posteriores
     fatorações de expressões contendo algum desses mesmos fatores.

 -- Função: sqfr (<expr>)
     é similar a 'factor' exceto que os fatores do polinômio são "livres
     de raízes".  Isto é, eles possuem fatores somente de grau um.  Esse
     algorítmo, que é também usado no primeiro estágio de 'factor',
     utiliza o fato que um polinômio tem em comum com sua n'ésima
     derivada todos os seus fatores de grau maior que n.  Dessa forma
     pegando o maior divisor comum com o polinômio das derivadas com
     relação a cada variável no polinômio, todos os fatores de grau
     maior que 1 podem ser achados.

     Exemplo:

          (%i1) sqfr (4*x^4 + 4*x^3 - 3*x^2 - 4*x - 1);
                                          2   2
          (%o1)                  (2 x + 1)  (x  - 1)

 -- Função: tellrat (<p_1>, ..., <p_n>)
 -- Função: tellrat ()
     Adiciona ao anel dos inteiros algébricos conhecidos do Maxima os
     elementos que são as soluções dos polinômios <p_1>, ..., <p_n>.
     Cada argumento <p_i> é um polinômio concoeficientes inteiros.

     'tellrat (<x>)' efetivamente significa substituir 0 por <x> em
     funções racionais.

     'tellrat ()' retorna uma lista das substituições correntes.

     'algebraic' deve ser escolhida para 'true' com o objetivo de que a
     simplificação de inteiros algébricos tenha efeito.

     Maxima inicialmente sabe sobre a unidade imaginária '%i' e todas as
     raízes de inteiros.

     Existe um comando 'untellrat' que pega kernels (núcleos) e remove
     propriedades 'tellrat'.

     Quando fazemos 'tellrat' em um polinômio de várias variáveis, e.g.,
     'tellrat (x^2 - y^2)', pode existir uma ambigüidade como para ou
     substituir '<y>^2' por '<x>^2' ou vice-versa.  Maxima seleciona uma
     ordenação particular, mas se o usuário desejar especificar qual
     e.g.  'tellrat (y^2 = x^2)' forneçe uma sintaxe que diga para
     substituir '<y>^2' por '<x>^2'.

     Exemplos:

          (%i1) 10*(%i + 1)/(%i + 3^(1/3));
                                     10 (%i + 1)
          (%o1)                      -----------
                                            1/3
                                      %i + 3
          (%i2) ev (ratdisrep (rat(%)), algebraic);
                       2/3      1/3              2/3      1/3
          (%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
          (%i3) tellrat (1 + a + a^2);
                                      2
          (%o3)                     [a  + a + 1]
          (%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                                1                 a
          (%o4)           ------------- + -----------------
                          sqrt(2) a - 1   sqrt(3) + sqrt(2)
          (%i5) ev (ratdisrep (rat(%)), algebraic);
                   (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
          (%o5)    ----------------------------------------------
                                         7
          (%i6) tellrat (y^2 = x^2);
                                  2    2   2
          (%o6)                 [y  - x , a  + a + 1]

 -- Função: totaldisrep (<expr>)
     Converte toda subexpressão de <expr> da forma de expressão
     racionais canônicas (CRE) para a forma geral e retorna o resultado.
     Se <expr> é em sí mesma na forma CRE então 'totaldisrep' é identica
     a 'ratdisrep'.

     'totaldisrep' pode ser usada para fazer um 'ratdisrep' em
     expressões tais como equações, listas, matrizes, etc., que tiverem
     algumas subexpressões na forma CRE.

 -- Função: untellrat (<x_1>, ..., <x_n>)
     Remove propriedades 'tellrat' de <x_1>, ..., <x_n>.


File: maxima.info,  Node: Constantes,  Next: Logarítmos,  Prev: Polinômios,  Up: Top

13 Constantes
*************

* Menu:

* Funções e Variáveis Definidas para Constantes::


File: maxima.info,  Node: Funções e Variáveis Definidas para Constantes,  Prev: Constantes,  Up: Constantes

13.1 Funções e Variáveis Definidas para Constantes
==================================================

 -- Constante: %e
     '%e' representa a base do logarítmo natural, também conhecido como
     constante de Euler.  O valor numérico de '%e' é um número em ponto
     flutuante de precisão dupla 2.718281828459045d0.

 -- Constante: %i
     '%i' representa a unidade imaginária, sqrt(- 1).

 -- Constante: false
     'false' representa a constante Booleana falso.  Maxima implementa
     'false' através do valor 'NIL' no Lisp.

 -- Constante: inf
     'inf' representa o infinito positivo real.

 -- Constante: infinity
     'infinity' representa o infinito complexo.

 -- Constante: minf
     'minf' representa o menos infinito (i.e., negativo) real.

 -- Constante: %phi

     '%phi' representa o então chamado número áureo, (1 + sqrt(5))/2.  O
     valor numérico de '%phi' é o número em ponto flutuante de de dupla
     precisão 1.618033988749895d0.

     'fibtophi' expressa números de Fibonacci 'fib(n)' em termos de
     '%phi'.

     Por padrão, Maxima não conhece as propriedade algébricas de '%phi'.
     Após avaliar 'tellrat(%phi^2 - %phi - 1)' e 'algebraic: true',
     'ratsimp' pode simplificar algumas expressãoes contendo '%phi'.

     Exemplos:

     'fibtophi' expresses Fibonacci numbers 'fib(n)' in terms of '%phi'.

          (%i1) fibtophi (fib (n));
                                     n             n
                                 %phi  - (1 - %phi)
          (%o1)                  -------------------
                                     2 %phi - 1
          (%i2) fib (n-1) + fib (n) - fib (n+1);
          (%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
          (%i3) fibtophi (%);
                      n + 1             n + 1       n             n
                  %phi      - (1 - %phi)        %phi  - (1 - %phi)
          (%o3) - --------------------------- + -------------------
                          2 %phi - 1                2 %phi - 1
                                                    n - 1             n - 1
                                                %phi      - (1 - %phi)
                                              + ---------------------------
                                                        2 %phi - 1
          (%i4) ratsimp (%);
          (%o4)                           0

     Por padrão, Maxima não conhece as propriedade algébricas de '%phi'.
     Após avaliar 'tellrat(%phi^2 - %phi - 1)' e 'algebraic: true',
     'ratsimp' pode simplificar algumas expressãoes contendo '%phi'.

          (%i1) e : expand ((%phi^2 - %phi - 1) * (A + 1));
                           2                      2
          (%o1)        %phi  A - %phi A - A + %phi  - %phi - 1
          (%i2) ratsimp (e);
                            2                     2
          (%o2)        (%phi  - %phi - 1) A + %phi  - %phi - 1
          (%i3) tellrat (%phi^2 - %phi - 1);
                                      2
          (%o3)                  [%phi  - %phi - 1]
          (%i4) algebraic : true;
          (%o4)                         true
          (%i5) ratsimp (e);
          (%o5)                           0

 -- Constante: %pi
     '%pi' representa a razão do perímetro de um círculo para seu
     diâmetro.  O valor numérico de '%pi' é o n;umero em ponto flutuante
     de dupla precisão 3.141592653589793d0.

 -- Constante: true
     'true' representa a constante Booleana verdadeiro.  Maxima
     implementa 'true' através do valor 'T' no Lisp.


File: maxima.info,  Node: Logarítmos,  Next: Trigonometria,  Prev: Constantes,  Up: Top

14 Logarítmos
*************

* Menu:

* Funções e Variáveis Definidas para Logarítmos::


File: maxima.info,  Node: Funções e Variáveis Definidas para Logarítmos,  Prev: Logarítmos,  Up: Logarítmos

14.1 Funções e Variáveis Definidas para Logarítmos
==================================================

 -- Variável de opção: %e_to_numlog
     Valor padrão: 'false'

     Quando 'true', sendo 'r' algum número racional, e 'x' alguma
     expressão, '%e^(r*log(x))' será simplificado em 'x^r' .  Note-se
     que o comando 'radcan' também faz essa transformação, e
     transformações mais complicadas desse tipo também.  O comando
     'logcontract' "contrai" expressões contendo 'log'.

 -- Função: li [<s>] (<z>)
     Representa a função polilogarítmo de ordem <s> e argumento <z>,
     definida por meio de séries infinitas

                                           inf
                                           ====   k
                                           \     z
                                  Li (z) =  >    --
                                    s      /      s
                                           ====  k
                                           k = 1

     'li [1]' é '- log (1 - z)'.  'li [2]' e 'li [3]' são as funções
     dilogarítmo e trilogarítmo, respectivamente.

     Quando a ordem for 1, o polilogarítmo simplifica para '- log (1 -
     z)', o qual por sua vez simplifica para um valor numérico se <z>
     for um número em ponto flutuante real ou complexo ou o sinalizador
     de avaliação 'numer' estiver presente.

     Quando a ordem for 2 ou 3, o polilogarítmo simplifica para um valor
     numérico se <z> for um número real em ponto flutuante ou o
     sinalizador de avaliação 'numer' estiver presente.

     Exemplos:

          (%i1) assume (x > 0);
          (%o1)                        [x > 0]
          (%i2) integrate ((log (1 - t)) / t, t, 0, x);
          (%o2)                       - li (x)
                                          2
          (%i3) li [2] (7);
          (%o3)                        li (7)
                                         2
          (%i4) li [2] (7), numer;
          (%o4)        1.24827317833392 - 6.113257021832577 %i
          (%i5) li [3] (7);
          (%o5)                        li (7)
                                         3
          (%i6) li [2] (7), numer;
          (%o6)        1.24827317833392 - 6.113257021832577 %i
          (%i7) L : makelist (i / 4.0, i, 0, 8);
          (%o7)   [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]
          (%i8) map (lambda ([x], li [2] (x)), L);
          (%o8) [0, .2676526384986274, .5822405249432515,
          .9784693966661848, 1.64493407, 2.190177004178597
           - .7010261407036192 %i, 2.374395264042415
           - 1.273806203464065 %i, 2.448686757245154
           - 1.758084846201883 %i, 2.467401098097648
           - 2.177586087815347 %i]
          (%i9) map (lambda ([x], li [3] (x)), L);
          (%o9) [0, .2584613953442624, 0.537213192678042,
          .8444258046482203, 1.2020569, 1.642866878950322
           - .07821473130035025 %i, 2.060877505514697
           - .2582419849982037 %i, 2.433418896388322
           - .4919260182322965 %i, 2.762071904015935
           - .7546938285978846 %i]

 -- Função: log (<x>)
     Representa o logarítmo natural (base e) de <x>.

     Maxima não possui uma função interna para logarítmo de base 10 ou
     de outras bases.  'log10(x) := log(x) / log(10)' é uma definição
     útil.

     Simplificação e avaliação de logarítmos são governadas por muitos
     sinalizadores globais:

     'logexpand' - faz com que 'log(a^b)' torne-se 'b*log(a)'.  Se
     'logexpand' for escolhida para 'all', 'log(a*b)' irá também
     simplificar para 'log(a)+log(b)'.  Se 'logexpand' for escolhida
     para 'super', então 'log(a/b)' irá também simplificar para
     'log(a)-log(b)' para números racionais 'a/b', 'a#1'.  ('log(1/b)',
     para 'b' inteiro, sempre simplifica).  Se 'logexpand' for escolhida
     para 'false', todas essas simplificações irão ser desabilitadas.

     'logsimp' - se 'false' então nenhuma simplificação de '%e' para um
     expoente contendo 'log''s é concluída.

     'lognumer' - se 'true' então argumentos negativos em ponto
     flutuante para 'log' irá sempre ser convertido para seu valor
     absoluto antes que 'log' seja tomado.  Se 'numer' for também
     'true', então argumentos negativos inteiros para 'log' irão também
     ser convertidos para seu valor absoluto.

     'lognegint' - se 'true' implementa a regra 'log(-n)' ->
     'log(n)+%i*%pi' para 'n' um inteiro positivo.

     '%e_to_numlog' - quando 'true', 'r' sendo algum número racional, e
     'x' alguma expressão, '%e^(r*log(x))' será simplificado em 'x^r' .
     Note-se que o comando 'radcan' também faz essa transformação, e
     transformações mais complicadas desse tipo também.  O comando
     'logcontract' "contrai" expressões contendo 'log'.

 -- Variável de opção: logabs
     Valor padrão: 'false'

     Quando fazendo integração indefinida onde logs são gerados, e.g.
     'integrate(1/x,x)', a resposta é dada em termos de 'log(abs(...))'
     se 'logabs' for 'true', mas em termos de 'log(...)' se 'logabs' for
     'false'.  Para integração definida, a escolha 'logabs:true' é
     usada, porque aqui "avaliação" de integral indefinida nos extremos
     é muitas vezes necessária.

 -- Variável de opção: logarc
 -- Função: logarc (<expr>)

     Quando a variável global 'logarc' for 'true', funções circulares
     inversas e funções hiperbólicas serão convertidas em funções
     logarítimicas equivalentes.  O valor padrão de 'logarc' é 'false'.

     A função 'logarc(<expr>)' realiza aquela substituíção para uma
     expressão <expr> sem modificar o valor da variável global 'logarc'.

 -- Variável de opção: logconcoeffp
     Valor padrão: 'false'

     Controla quais coeficientes são contraídos quando usando
     'logcontract'.  Pode ser escolhida para o nome de uma função
     predicado de um argumento.  E.g.  se você gosta de gerar raízes
     quadradas, você pode fazer 'logconcoeffp:'logconfun$
     logconfun(m):=featurep(m,integer) ou ratnump(m)$' .  Então
     'logcontract(1/2*log(x));' irá fornecer 'log(sqrt(x))'.

 -- Função: logcontract (<expr>)
     Recursivamente examina a expressão <expr>, transformando
     subexpressões da forma 'a1*log(b1) + a2*log(b2) + c' em
     'log(ratsimp(b1^a1 * b2^a2)) + c'

          (%i1) 2*(a*log(x) + 2*a*log(y))$
          (%i2) logcontract(%);
                                           2  4
          (%o2)                     a log(x  y )

     Se você faz 'declare(n,integer);' então
     'logcontract(2*a*n*log(x));' fornece 'a*log(x^(2*n))'.  Os
     coeficientes que "contraem" dessa maneira são aqueles tais que 2 e
     'n' que satisfazem 'featurep(coeff,integer)'.  O usuário pode
     controlar quais coeficientes são contraídos escolhendo a opção
     'logconcoeffp' para o nome de uma função predicado de um argumento.
     E.g.  se você gosta de gerara raízes quadradas, você pode fazer
     'logconcoeffp:'logconfun$ logconfun(m):=featurep(m,integer) ou
     ratnump(m)$' .  Então 'logcontract(1/2*log(x));' irá fornecer
     'log(sqrt(x))'.

 -- Variável de opção: logexpand
     Valor padrão: 'true'

     Faz com que 'log(a^b)' torne-se 'b*log(a)'.  Se for escolhida para
     'all', 'log(a*b)' irá também simplificar para 'log(a)+log(b)'.  Se
     for escolhida para 'super', então 'log(a/b)' irá também simplificar
     para 'log(a)-log(b)' para números racionais 'a/b', 'a#1'.
     ('log(1/b)', para 'b' inteiro, sempre simplifica).  Se for
     escolhida para 'false', todas essas simplificações irão ser
     desabilitadas.

 -- Variável de opção: lognegint
     Valor padrão: 'false'

     Se 'true' implementa a regra 'log(-n)' -> 'log(n)+%i*%pi' para 'n'
     um inteiro positivo.

 -- Variável de opção: lognumer
     Valor padrão: 'false'

     Se 'true' então argumentos negativos em ponto flutuante para 'log'
     irão sempre ser convertidos para seus valores absolutos antes que o
     'log' seja tomado.  Se 'numer' for também 'true', então argumentos
     inteiros negativos para 'log' irão também ser convertidos para seus
     valores absolutos.

 -- Variável de opção: logsimp
     Valor padrão: 'true'

     Se 'false' então nenhuma simplificação de '%e' para um expoente
     contendo 'log''s é concluída.

 -- Função: plog (<x>)
     Representa o principal ramo logarítmos naturais avaliados para
     complexos com '-%pi' < 'carg(<x>)' <= '+%pi' .


File: maxima.info,  Node: Trigonometria,  Next: Funções Especiais,  Prev: Logarítmos,  Up: Top

15 Trigonometria
****************

* Menu:

* Introdução ao Pacote Trigonométrico::  
* Funções e Variáveis Definidas para Trigonometria::  


File: maxima.info,  Node: Introdução ao Pacote Trigonométrico,  Next: Funções e Variáveis Definidas para Trigonometria,  Prev: Trigonometria,  Up: Trigonometria

15.1 Introdução ao Pacote Trigonométrico
========================================

Maxima tem muitas funções trigonométricas definidas.  Não todas as
identidades trigonometricas estão programadas, mas isso é possível para
o usuário adicionar muitas delas usando a compatibilidade de
correspondência de modelos do sistema.  As funções trigonométricas
definidas no Maxima são: 'acos', 'acosh', 'acot', 'acoth', 'acsc',
'acsch', 'asec', 'asech', 'asin', 'asinh', 'atan', 'atanh', 'cos',
'cosh', 'cot', 'coth', 'csc', 'csch', 'sec', 'sech', 'sin', 'sinh',
'tan', e 'tanh'.  Existe uma coleção de comandos especialmente para
manusear funções trigonométricas, veja 'trigexpand', 'trigreduce', e o
comutador 'trigsign'.  Dois pacotes compartilhados extendem as regras de
simplificação construídas no Maxima, 'ntrig' e 'atrig1'.  Faça
'describe(<comando>)' para detalhes.


File: maxima.info,  Node: Funções e Variáveis Definidas para Trigonometria,  Prev: Introdução ao Pacote Trigonométrico,  Up: Trigonometria

15.2 Funções e Variáveis Definidas para Trigonometria
=====================================================

 -- Função: acos (<x>)
     - Arco Cosseno.

 -- Função: acosh (<x>)
     - Arco Cosseno Hiperbólico.

 -- Função: acot (<x>)
     - Arco Cotangente.

 -- Função: acoth (<x>)
     - Arco Cotangente Hiperbólico.

 -- Função: acsc (<x>)
     - Arco Cossecante.

 -- Função: acsch (<x>)
     - Arco Cossecante Hiperbólico.

 -- Função: asec (<x>)
     - Arco Secante.

 -- Função: asech (<x>)
     - Arco Secante Hiperbólico.

 -- Função: asin (<x>)
     - Arco Seno.

 -- Função: asinh (<x>)
     - Arco Seno Hiperbólico.

 -- Função: atan (<x>)
     - Arco Tangente.

 -- Função: atan2 (<y>, <x>)
     - retorna o valor de 'atan(<y>/<x>)' no intervalo de '-%pi' a
     '%pi'.

 -- Função: atanh (<x>)
     - Arco tangente Hiperbólico.

 -- Pacote: atrig1
     O pacote 'atrig1' contém muitas regras adicionais de simplificação
     para funções trigonométricas inversas.  Junto com regras já
     conhecidas para Maxima, os seguintes ângulos estão completamente
     implementados: '0', '%pi/6', '%pi/4', '%pi/3', e '%pi/2'.  Os
     ângulos correspondentes nos outros três quadrantes estão também
     disponíveis.  Faça 'load(atrig1);' para usá-lo.

 -- Função: cos (<x>)
     - Cosseno.

 -- Função: cosh (<x>)
     - Cosseno hiperbólico.

 -- Função: cot (<x>)
     - Cotangente.

 -- Função: coth (<x>)
     - Cotangente Hyperbólica.

 -- Função: csc (<x>)
     - Cossecante.

 -- Função: csch (<x>)
     - Cossecante Hyperbólica.

 -- Variável de opção: halfangles
     Default value: 'false'

     Quando 'halfangles' for 'true', meios-ângulos são simplificados
     imediatamente.

 -- Pacote: ntrig
     O pacote 'ntrig' contém um conjunto de regras de simplificação que
     são usadas para simplificar função trigonométrica cujos argumentos
     estão na forma '<f>(<n> %pi/10)' onde <f> é qualquer das funções
     'sin', 'cos', 'tan', 'csc', 'sec' e 'cot'.

 -- Função: sec (<x>)
     - Secante.

 -- Função: sech (<x>)
     - Secante Hyperbólica.

 -- Função: sin (<x>)
     - Seno.

 -- Função: sinh (<x>)
     - Seno Hyperbólico.

 -- Função: tan (<x>)
     - Tangente.

 -- Função: tanh (<x>)
     - Tangente Hyperbólica.

 -- Função: trigexpand (<expr>)
     Expande funções trigonometricas e hyperbólicas de adições de
     ângulos e de ângulos multiplos que ocorram em <expr>.  Para
     melhores resultados, <expr> deve ser expandida.  Para intensificar
     o controle do usuário na simplificação, essa função expande somente
     um nível de cada vez, expandindo adições de ângulos ou ângulos
     multiplos.  Para obter expansão completa dentro de senos e cossenos
     imediatamente, escolha o comutador 'trigexpand: true'.

     'trigexpand' é governada pelos seguintes sinalizadores globais:

     'trigexpand'
          Se 'true' causa expansão de todas as expressões contendo senos
          e cossenos ocorrendo subseqüêntemente.
     'halfangles'
          Se 'true' faz com que meios-ângulos sejam simplificados
          imediatamente.
     'trigexpandplus'
          Controla a regra "soma" para 'trigexpand', expansão de adições
          (e.g.  'sin(x + y)') terão lugar somente se 'trigexpandplus'
          for 'true'.
     'trigexpandtimes'
          Controla a regra "produto" para 'trigexpand', expansão de
          produtos (e.g.  'sin(2 x)') terão lugar somente se
          'trigexpandtimes' for 'true'.

     Exemplos:

          (%i1) x+sin(3*x)/sin(x),trigexpand=true,expand;
                                   2           2
          (%o1)               - sin (x) + 3 cos (x) + x
          (%i2) trigexpand(sin(10*x+y));
          (%o2)          cos(10 x) sin(y) + sin(10 x) cos(y)

 -- Variável de opção: trigexpandplus
     Valor padrão: 'true'

     'trigexpandplus' controla a regra da "soma" para 'trigexpand'.
     Dessa forma, quando o comando 'trigexpand' for usado ou o comutador
     'trigexpand' escolhido para 'true', expansão de adições (e.g.
     'sin(x+y))' terão lugar somente se 'trigexpandplus' for 'true'.

 -- Variável de opção: trigexpandtimes
     Valor padrão: 'true'

     'trigexpandtimes' controla a regra "produto" para 'trigexpand'.
     Dessa forma, quando o comando 'trigexpand' for usado ou o comutador
     'trigexpand' escolhido para 'true', expansão de produtos (e.g.
     'sin(2*x)') terão lugar somente se 'trigexpandtimes' for 'true'.

 -- Variável de opção: triginverses
     Valor padrão: 'all'

     'triginverses' controla a simplificação de composições de funções
     trigonométricas e hiperbólicas com suas funções inversas.

     Se 'all', ambas e.g.  'atan(tan(<x>))' e 'tan(atan(<x>))'
     simplificarão para <x>.

     Se 'true', a simplificação de '<arcfun>(<fun>(<x>))' é
     desabilitada.

     Se 'false', ambas as simplificações '<arcfun>(<fun>(<x>))' e
     '<fun>(<arcfun>(<x>))' são desabilitadas.

 -- Função: trigreduce (<expr>, <x>)
 -- Função: trigreduce (<expr>)
     Combina produtos e expoentes de senos e cossenso trigonométricos e
     hiperbólicos de <x> dentro daqueles de múltiplos de <x>.  Também
     tenta eliminar essas funções quando elas ocorrerem em
     denominadores.  Se <x> for omitido então todas as variáveis em
     <expr> são usadas.

     Veja também 'poissimp'.

          (%i1) trigreduce(-sin(x)^2+3*cos(x)^2+x);
                         cos(2 x)      cos(2 x)   1        1
          (%o1)          -------- + 3 (-------- + -) + x - -
                            2             2       2        2

     As rotinas de simplificação trigonométrica irão usar informações
     declaradas em alguns casos simples.  Declarações sobre variáveis
     são usadas como segue, e.g.

          (%i1) declare(j, integer, e, even, o, odd)$
          (%i2) sin(x + (e + 1/2)*%pi);
          (%o2)                        cos(x)
          (%i3) sin(x + (o + 1/2)*%pi);
          (%o3)                       - cos(x)

 -- Variável de opção: trigsign
     Valor padrão: 'true'

     Quando 'trigsign' for 'true', permite simplificação de argumentos
     negativos para funções trigonométricas.  E.g., 'sin(-x)'
     transformar-se-á em '-sin(x)' somente se 'trigsign' for 'true'.

 -- Função: trigsimp (<expr>)
     Utiliza as identidades sin(x)^2 + cos(x)^2 = 1 and cosh(x)^2 -
     sinh(x)^2 = 1 para simplificar expressões contendo 'tan', 'sec',
     etc., para 'sin', 'cos', 'sinh', 'cosh'.

     'trigreduce', 'ratsimp', e 'radcan' podem estar habilitadas a
     adicionar simplificações ao resultado.

     'demo ("trgsmp.dem")' mostra alguns exemplos de 'trigsimp'.

 -- Função: trigrat (<expr>)
     Fornece uma forma quase-linear simplificada canônica de uma
     expressão trigonométrica; <expr> é uma fração racional de muitos
     'sin', 'cos' ou 'tan', os argumentos delas são formas lineares em
     algumas variáveis (ou kernels-núcleos) e '%pi/<n>' (<n> inteiro)
     com coeficientes inteiros.  O resultado é uma fração simplificada
     com numerador e denominador ambos lineares em 'sin' e 'cos'.  Dessa
     forma 'trigrat' lineariza sempre quando isso for passível.

          (%i1) trigrat(sin(3*a)/sin(a+%pi/3));
          (%o1)            sqrt(3) sin(2 a) + cos(2 a) - 1

     O seguinte exemplo encontra-se em Davenport, Siret, and Tournier,
     Calcul Formel, Masson (ou em inglês, Addison-Wesley), seção 1.5.5,
     teorema de Morley.

          (%i1) c: %pi/3 - a - b;
                                              %pi
          (%o1)                     - b - a + ---
                                               3
          (%i2) bc: sin(a)*sin(3*c)/sin(a+b);
                                sin(a) sin(3 b + 3 a)
          (%o2)                 ---------------------
                                     sin(b + a)
          (%i3) ba: bc, c=a, a=c$
          (%i4) ac2: ba^2 + bc^2 - 2*bc*ba*cos(b);
                   2       2
                sin (a) sin (3 b + 3 a)
          (%o4) -----------------------
                         2
                      sin (b + a)

                                                  %pi
             2 sin(a) sin(3 a) cos(b) sin(b + a - ---) sin(3 b + 3 a)
                                                   3
           - --------------------------------------------------------
                                     %pi
                             sin(a - ---) sin(b + a)
                                      3

                2         2         %pi
             sin (3 a) sin (b + a - ---)
                                     3
           + ---------------------------
                       2     %pi
                    sin (a - ---)
                              3
          (%i5) trigrat (ac2);
          (%o5) - (sqrt(3) sin(4 b + 4 a) - cos(4 b + 4 a)

           - 2 sqrt(3) sin(4 b + 2 a) + 2 cos(4 b + 2 a)

           - 2 sqrt(3) sin(2 b + 4 a) + 2 cos(2 b + 4 a)

           + 4 sqrt(3) sin(2 b + 2 a) - 8 cos(2 b + 2 a) - 4 cos(2 b - 2 a)

           + sqrt(3) sin(4 b) - cos(4 b) - 2 sqrt(3) sin(2 b) + 10 cos(2 b)

           + sqrt(3) sin(4 a) - cos(4 a) - 2 sqrt(3) sin(2 a) + 10 cos(2 a)

           - 9)/4


File: maxima.info,  Node: Funções Especiais,  Next: Funções Elípticas,  Prev: Trigonometria,  Up: Top

16 Funções Especiais
********************

* Menu:

* Introdução a Funções Especiais::  
* Funções e Variáveis Definidas para Funções Especiais::  


File: maxima.info,  Node: Introdução a Funções Especiais,  Next: Funções e Variáveis Definidas para Funções Especiais,  Prev: Funções Especiais,  Up: Funções Especiais

16.1 Introdução a Funções Especiais
===================================

A notação de função especial segue adiante:

     bessel_j (index, expr)         Função de Bessel, primeiro tipo
     bessel_y (index, expr)         Função de Bessel, segundo tipo
     bessel_i (index, expr)         Função de Bessel modificada, primeiro tipo
     bessel_k (index, expr)         Função de Bessel modificada, segundo tipo
     %he[n] (z)                     Polinômio de Hermite (Note bem: he, não h. Veja A&S 22.5.18)
     %p[u,v] (z)                    Função de Legendre
     %q[u,v] (z)                    Função de Legendre, segundo tipo
     hstruve[n] (z)                 Função H de Struve H
     lstruve[n] (z)                 Função L de Struve
     %f[p,q] ([], [], expr)         Função Hipergeométrica Generalizada
     gamma()                        Função Gamma
     gamma_incomplete_lower(a,z)    Função gama incompleta inferior
     gammaincomplete(a,z)           Final da função gama incompleta
     slommel
     %m[u,k] (z)                    Função de Whittaker, primeiro tipo
     %w[u,k] (z)                    Função de Whittaker, segundo tipo
     erfc (z)                       Complemento da função erf (função de erros - integral da distribuição normal)
     ei (z)                         Integral de exponencial (?)
     kelliptic (z)                  integral eliptica completa de primeiro tipo (K)
     %d [n] (z)                     Função cilíndrica parabólica


File: maxima.info,  Node: Funções e Variáveis Definidas para Funções Especiais,  Prev: Introdução a Funções Especiais,  Up: Funções Especiais

16.2 Funções e Variáveis Definidas para Funções Especiais
=========================================================

 -- Função: airy_ai (<x>)
     A função de Airy Ai, como definida em Abramowitz e Stegun, Handbook
     of Mathematical Functions, Sessão 10.4.

     A equação de Airy 'diff (y(x), x, 2) - x y(x) = 0' tem duas
     soluções linearmente independentes, 'y = Ai(x)' e 'y = Bi(x)'.  A
     derivada de 'diff (airy_ai(x), x)' é 'airy_dai(x)'.

     Se o argumento 'x' for um número real ou um número complexo
     qualquer deles em ponto flutuante , o valor numérico de 'airy_ai' é
     retornado quando possível.

     Veja também 'airy_bi', 'airy_dai', 'airy_dbi'.

 -- Função: airy_dai (<x>)
     A derivada da função de Airy Ai 'airy_ai(x)'.

     Veja 'airy_ai'.

 -- Função: airy_bi (<x>)
     A função de Airy Bi, como definida em Abramowitz e Stegun, Handbook
     of Mathematical Functions, Sessão 10.4, é a segunda solução da
     equação de Airy 'diff (y(x), x, 2) - x y(x) = 0'.

     Se o argumento 'x' for um número real ou um número complexo
     qualquer deles em ponto flutuante, o valor numérico de 'airy_bi' é
     retornado quando possível.  Em outros casos a expressão não
     avaliada é retornada.

     A derivada de 'diff (airy_bi(x), x)' é 'airy_dbi(x)'.

     Veja 'airy_ai', 'airy_dbi'.

 -- Função: airy_dbi (<x>)
     A derivada de função de Airy Bi 'airy_bi(x)'.

     Veja 'airy_ai' e 'airy_bi'.

 -- Função: asympa
     'asympa' é um pacote para análise assintótica.  O pacote contém
     funções de simplificação para análise assintótica, incluindo as
     funções "grande O" e "pequeno o" que são largamente usadas em
     análises de complexidade e análise numérica.

     'load ("asympa")' chama esse pacote.

 -- Função: bessel (<z>, <a>)
     A função de Bessel de primeiro tipo.

     Essa função está desatualizada.  Escreva 'bessel_j (<z>, <a>)' em
     lugar dessa.

 -- Função: bessel_j (<v>, <z>)
     A função de Bessel do primeiro tipo de ordem v e argumento z.

     'bessel_j' calcula o array 'besselarray' tal que 'besselarray [i] =
     bessel_j [i + v - int(v)] (z)' para 'i' de zero a 'int(v)'.

     'bessel_j' é definida como
                          inf
                          ====       k  - v - 2 k  v + 2 k
                          \     (- 1)  2          z
                           >    --------------------------
                          /        k! gamma(v + k + 1)
                          ====
                          k = 0

     todavia séries infinitas não são usadas nos cálculos.

 -- Função: bessel_y (<v>, <z>)
     A função de Bessel do segundo tipo de ordem v e argumento z.

     'bessel_y' calcula o array 'besselarray' tal que 'besselarray [i] =
     bessel_y [i + v - int(v)] (z)' para 'i' de zero a 'int(v)'.

     'bessel_y' é definida como
                        cos(%pi v) bessel_j(v, z) - bessel_j(-v, z)
                        -------------------------------------------
                                       sin(%pi v)

     quando v não for um inteiro.  Quando v for um inteiro n, o limite
     com v aprocimando-se de n é tomado.

 -- Função: bessel_i (<v>, <z>)
     A função de Bessel modificada de primeiro tipo de ordem v e
     argumento z.

     'bessel_i' calcula o array 'besselarray' tal que 'besselarray [i] =
     bessel_i [i + v - int(v)] (z)' para 'i' de zero a 'int(v)'.

     'bessel_i' é definida como
                              inf
                              ====   - v - 2 k  v + 2 k
                              \     2          z
                               >    -------------------
                              /     k! gamma(v + k + 1)
                              ====
                              k = 0

     embora séries infinitas não são usadas nos cálculos.

 -- Função: bessel_k (<v>, <z>)
     A função de Bessel modificada de segundo tipo de ordem v e
     argumento z.

     'bessel_k' calcula o array 'besselarray' tal que 'besselarray [i] =
     bessel_k [i + v - int(v)] (z)' para 'i' de zero a 'int(v)'.

     'bessel_k' é definida como
                     %pi csc(%pi v) (bessel_i(-v, z) - bessel_i(v, z))
                     -------------------------------------------------
                                            2

     quando v não for inteiro.  Se v for um inteiro n, então o limite
     com v aproximando-se de n é tomado.

 -- Variável de opção: besselexpand
     Valor padrão: 'false'

     Expansões de controle de funções de Bessel quando a ordem for a
     metade de um inteiro ímpar.  Nesse caso, as funções de Bessel podem
     ser expandidas em termos de outras funções elementares.  Quando
     'besselexpand' for 'true', a função de Bessel é expandida.

          (%i1) besselexpand: false$
          (%i2) bessel_j (3/2, z);
                                              3
          (%o2)                      bessel_j(-, z)
                                              2
          (%i3) besselexpand: true$
          (%i4) bessel_j (3/2, z);
                                    2 z   sin(z)   cos(z)
          (%o4)                sqrt(---) (------ - ------)
                                    %pi      2       z
                                            z

 -- Função: scaled_bessel_i (<v>, <z>)

     A função homotética modificada de Bessel de primeiro tipo de ordem
     v e argumento z.  Isto é, scaled_bessel_i(v,z) =
     exp(-abs(z))*bessel_i(v, z).  Essa função é particularmente útil
     para calcular bessel_i para grandes valores de z.  Todavia, maxima
     não conhece outra forma muito mais sobre essa função.  Para
     computação simbólica, é provavelmete preferível trabalhar com a
     expressão 'exp(-abs(z))*bessel_i(v, z)'.

 -- Função: scaled_bessel_i0 (<z>)

     Idêntica a 'scaled_bessel_i(0,z)'.

 -- Função: scaled_bessel_i1 (<z>)

     Idêntica a 'scaled_bessel_i(1,z)'.

 -- Função: beta (<x>, <y>)
     A função beta, definida como 'gamma(x) gamma(y)/gamma(x + y)'.

 -- Função: gamma (<x>)
     A função gama.

     Veja também 'makegamma'.

     A variável 'gammalim' controla a simplificação da função gama.

     A constante de Euler-Mascheroni é '%gamma'.

 -- Variável de opção: gammalim
     Valor padrão: 1000000

     'gammalim' controla a simplificação da função gama para integral e
     argumentos na forma de números racionais.  Se o valor absoluto do
     argumento não for maior que 'gammalim', então a simplificação
     ocorrerá.  Note que 'factlim' comuta controle de simplificaçcão do
     resultado de 'gamma' de um argumento inteiro também.

 -- Função: intopois (<a>)
     Converte <a> em um código de Poisson.

 -- Função: makefact (<expr>)
     Transforma instâncias de funções binomiais, gama, e beta em <expr>
     para fatoriais.

     Veja também 'makegamma'.

 -- Função: makegamma (<expr>)
     Transforma instâncias de funções binomiais, fatorial, e beta em
     <expr> para funções gama.

     Veja também 'makefact'.

 -- Função: numfactor (<expr>)
     Retorna o fator numérico multiplicando a expressão <expr>, que pode
     ser um termo simples.

     'content' retorna o máximo divisor comum (mdc) de todos os termos
     em uma adição.

          (%i1) gamma (7/2);
                                    15 sqrt(%pi)
          (%o1)                     ------------
                                         8
          (%i2) numfactor (%);
                                         15
          (%o2)                          --
                                         8

 -- Função: outofpois (<a>)
     Converte <a> de um código de Poisson para uma representação geral.
     Se <a> não for uma forma de Poisson, 'outofpois' realiza a
     conversão, i.e., o valor de retorno é 'outofpois (intopois (<a>))'.
     Essa função é desse modo um simplificador canônico para adições e
     potências de termos de seno e cosseno de um tipo particular.

 -- Função: poisdiff (<a>, <b>)
     Deriva <a> em relação a <b>.  <b> deve ocorrer somente nos
     argumentos trigonométricos ou somente nos coeficientes.

 -- Função: poisexpt (<a>, <b>)
     Funcionalmente identica a 'intopois (<a>^<b>)'.  <b> deve ser um
     inteiro positico.

 -- Função: poisint (<a>, <b>)
     Integra em um senso restrito similarmente (para 'poisdiff').
     Termos não periódicos em <b> são diminuídos se <b> estiver em
     argumentos trigonométricos.

 -- Variável de opção: poislim
     Valor padrão: 5

     'poislim' determina o domínio dos coeficientes nos argumentos de
     funções trigonométricas.  O valor inicial de 5 corresponde ao
     intervalo [-2^(5-1)+1,2^(5-1)], ou [-15,16], mas isso pode ser
     alterado para [-2^(n-1)+1, 2^(n-1)].

 -- Função: poismap (<series>, <sinfn>, <cosfn>)
     mapeará as funções <sinfn> sobre os termos de seno e <cosfn> ssobre
     os termos de cosseno das séries de Poisson dadas.  <sinfn> e
     <cosfn> são funções de dois argumentos que são um coeficiente e uma
     parte trigonométrica de um termo em séries respectivamente.

 -- Função: poisplus (<a>, <b>)
     É funcionalmente identica a 'intopois (a + b)'.

 -- Função: poissimp (<a>)
     Converte <a> em séries de Poisson para <a> em representação geral.

 -- Símbolo especial: poisson
     O símbolo '/P/' segue o rótulo de linha de uma expressão contendo
     séries de Poisson.

 -- Função: poissubst (<a>, <b>, <c>)
     Substitue <a> por <b> em <c>.  <c> é uma série de Poisson.

     (1) Quando <B> é uma variável <u>, <v>, <w>, <x>, <y>, ou <z>,
     então <a> deve ser uma expressão linear nessas variáveis (e.g.,
     '6*u + 4*v').

     (2) Quando <b> for outra que não essas variáveis, então <a> deve
     também ser livre dessas variáveis, e alé disso, livre de senos ou
     cossenos.

     'poissubst (<a>, <b>, <c>, <d>, <n>)' é um tipo especial d
     substituição que opera sobre <a> e <b> como no tipo (1) acima, mas
     onde <d> é uma série de Poisson, expande 'cos(<d>)' e 'sin(<d>)'
     para a ordem <n> como provendo o resultado da substituição '<a> +
     <d>' por <b> em <c>.  A idéia é que <d> é uma expansão em termos de
     um pequeno parâmetro.  Por exemplo, 'poissubst (u, v, cos(v), %e,
     3)' retorna 'cos(u)*(1 - %e^2/2) - sin(u)*(%e - %e^3/6)'.

 -- Função: poistimes (<a>, <b>)
     É funcionalmente idêntica a 'intopois (<a>*<b>)'.

 -- Função: poistrim ()
     é um nome de função reservado que (se o usuário tiver definido uma
     função com esse nome) é aplicada durante multiplicação de Poisson.
     Isso é uma função predicada de 6 argumentos que são os coeficientes
     de <u>, <v>, ..., <z> em um termo.  Termos para os quais 'poistrim'
     for 'true' (para os coeficientes daquele termo) são eliminados
     durante a multiplicação.

 -- Função: printpois (<a>)
     Mostra uma série de Poisson em um formato legível.  Em comum com
     'outofpois', essa função converterá <a> em um código de Poisson
     primeiro, se necessário.

 -- Função: psi [<n>](<x>)

     A derivada de 'log (gamma (<x>))' de ordem '<n>+1'.  Dessa forma,
     'psi[0](<x>)' é a primeira derivada, 'psi[1](<x>)' é a segunda
     derivada, etc.

     Maxima não sabe como, em geral, calcular um valor numérico de
     'psi', mas Maxima pode calcular alguns valores exatos para
     argumentos racionais.  Muitas variáveis controlam qual intervalo de
     argumentos racionais 'psi' irá retornar um valor exato, se
     possível.  Veja 'maxpsiposint', 'maxpsinegint', 'maxpsifracnum', e
     'maxpsifracdenom'.  Isto é, <x> deve localizar-se entre
     'maxpsinegint' e 'maxpsiposint'.  Se o valor absoluto da parte
     facionária de <x> for racional e tiver um numerador menor que
     'maxpsifracnum' e tiver um denominador menor que 'maxpsifracdenom',
     'psi' irá retornar um valor exato.

     A função 'bfpsi' no pacote 'bffac' pode calcular valores numéricos.

 -- Variável de opção: maxpsiposint
     Valor padrão: 20

     'maxpsiposint' é o maior valor positivo para o qual 'psi[n](x)' irá
     tentar calcular um valor exato.

 -- Variável de opção: maxpsinegint
     Valor padrão: -10

     'maxpsinegint' é o valor mais negativo para o qual 'psi[n](x)' irá
     tentar calcular um valor exato.  Isto é, se <x> for menor que
     'maxnegint', 'psi[n](<x>)' não irá retornar resposta simplificada,
     mesmo se isso for possível.

 -- Variável de opção: maxpsifracnum
     Valor padrão: 6

     Tomemos <x> como sendo um número racional menor que a unidade e da
     forma 'p/q'.  Se 'p' for menor que 'maxpsifracnum', então
     'psi[<n>](<x>)' não irá tentar retornar um valor simplificado.

 -- Variável de opção: maxpsifracdenom
     Valor padrão: 6

     Tomemos <x> como sendo um número racional menor que a unidade e da
     forma 'p/q'.  Se 'q' for maior que 'maxpsifracdenom', então
     'psi[<n>](<x>)' não irá tentar retornar um valor simplificado.

 -- Function: specint (exp(- s*<t>) * <expr>, <t>)

     Calcula a trasformada de Laplace de <expr> com relação à variável
     <t>.  O integrando <expr> pode conter funções especiais.

     Se 'specint' não puder calcular a integral, o valor de retorno pode
     coter vários símbolos do Lisp, incluindo
     'other-defint-to-follow-negtest', 'other-lt-exponential-to-follow',
     'product-of-y-with-nofract-indices', etc.; isso é um erro.

     'demo(hypgeo)' mostra muitos exemplos de tansformadas de Laplace
     calculados por meio de 'specint'.

     Exemplos:

          (%i1) assume (p > 0, a > 0);
          (%o1)                    [p > 0, a > 0]
          (%i2) specint (t^(1/2) * exp(-a*t/4) * exp(-p*t), t);
                                     sqrt(%pi)
          (%o2)                     ------------
                                           a 3/2
                                    2 (p + -)
                                           4
          (%i3) specint (t^(1/2) * bessel_j(1, 2 * a^(1/2) * t^(1/2)) * exp(-p*t), t);
                                             - a/p
                                   sqrt(a) %e
          (%o3)                    ---------------
                                          2
                                         p


File: maxima.info,  Node: Funções Elípticas,  Next: Limites,  Prev: Funções Especiais,  Up: Top

17 Funções Elípticas
********************

* Menu:

* Introdução a Funções Elípticas e Integrais::
* Funções e Variáveis Definidas para Funções Elípticas::
* Funções e Variáveis Definidas para Integrais Elípticas::


File: maxima.info,  Node: Introdução a Funções Elípticas e Integrais,  Next: Funções e Variáveis Definidas para Funções Elípticas,  Up: Top

17.1 Introdução a Funções Elípticas e Integrais
===============================================

Maxima inclui suporte a funções elípticas Jacobianas e a integrais
elípticas completas e incompletas.  Isso inclui manipulação simbólica
dessas funções e avaliação numérica também.  Definições dessas funções e
muitas de suas propriedades podem ser encontradas em Abramowitz e
Stegun, Capítulos 16-17.  Tanto quanto possível, usamos as definições e
relações dadas aí.

   Em particular, todas as funções elípticas e integrais elípticas usam
o parâmetro m em lugar de módulo k ou o ângulo modular \alpha.  Isso é
uma área onde discordamos de Abramowitz e Stegun que usam o ângulo
modular para as funções elípticas.  As seguintes relações são
verdadeiras: m = k^2 e k = \sin(\alpha)

   As funções elípticas e integrais elípticas estão primariamente
tencionando suportar computação simbólica.  Portanto, a maiora das
derivadas de funções e integrais são conhecidas.  Todavia, se valores em
ponto flutuante forem dados, um resultado em ponto flutuante é
retornado.

   Suporte para a maioria de outras propriedades das funções elípticas e
integrais elípticas além das derivadas não foram ainda escritas.

   Alguns exemplos de funções elípticas:

     (%i1) jacobi_sn (u, m);
     (%o1)                    jacobi_sn(u, m)
     (%i2) jacobi_sn (u, 1);
     (%o2)                        tanh(u)
     (%i3) jacobi_sn (u, 0);
     (%o3)                        sin(u)
     (%i4) diff (jacobi_sn (u, m), u);
     (%o4)            jacobi_cn(u, m) jacobi_dn(u, m)
     (%i5) diff (jacobi_sn (u, m), m);
     (%o5) jacobi_cn(u, m) jacobi_dn(u, m)

           elliptic_e(asin(jacobi_sn(u, m)), m)
      (u - ------------------------------------)/(2 m)
                          1 - m

                 2
        jacobi_cn (u, m) jacobi_sn(u, m)
      + --------------------------------
                   2 (1 - m)

   Alguns exemplos de integrais elípticas:

     (%i1) elliptic_f (phi, m);
     (%o1)                  elliptic_f(phi, m)
     (%i2) elliptic_f (phi, 0);
     (%o2)                          phi
     (%i3) elliptic_f (phi, 1);
                                    phi   %pi
     (%o3)                  log(tan(--- + ---))
                                     2     4
     (%i4) elliptic_e (phi, 1);
     (%o4)                       sin(phi)
     (%i5) elliptic_e (phi, 0);
     (%o5)                          phi
     (%i6) elliptic_kc (1/2);
                                          1
     (%o6)                    elliptic_kc(-)
                                          2
     (%i7) makegamma (%);
                                      2 1
                                 gamma (-)
                                        4
     (%o7)                      -----------
                                4 sqrt(%pi)
     (%i8) diff (elliptic_f (phi, m), phi);
                                     1
     (%o8)                 ---------------------
                                         2
                           sqrt(1 - m sin (phi))
     (%i9) diff (elliptic_f (phi, m), m);
            elliptic_e(phi, m) - (1 - m) elliptic_f(phi, m)
     (%o9) (-----------------------------------------------
                                   m

                                      cos(phi) sin(phi)
                                  - ---------------------)/(2 (1 - m))
                                                  2
                                    sqrt(1 - m sin (phi))

   Suporte a funções elípticas e integrais elípticas foi escrito por
Raymond Toy.  Foi colocado sob os termos da Licençã Pública Geral (GPL)
que governa a distribuição do Maxima.


File: maxima.info,  Node: Funções e Variáveis Definidas para Funções Elípticas,  Next: Funções e Variáveis Definidas para Integrais Elípticas,  Prev: Introdução a Funções Elípticas e Integrais,  Up: Top

17.2 Funções e Variáveis Definidas para Funções Elípticas
=========================================================

 -- Função: jacobi_sn (<u>, <m>)
     A Função elíptica Jacobiana sn(u,m).

 -- Função: jacobi_cn (<u>, <m>)
     A função elíptica Jacobiana cn(u,m).

 -- Função: jacobi_dn (<u>, <m>)
     A função elíptica Jacobiana dn(u,m).

 -- Função: jacobi_ns (<u>, <m>)
     A função elíptica Jacobiana ns(u,m) = 1/sn(u,m).

 -- Função: jacobi_sc (<u>, <m>)
     A função elíptica Jacobiana sc(u,m) = sn(u,m)/cn(u,m).

 -- Função: jacobi_sd (<u>, <m>)
     A função elíptica Jacobiana sd(u,m) = sn(u,m)/dn(u,m).

 -- Função: jacobi_nc (<u>, <m>)
     A função elíptica Jacobiana nc(u,m) = 1/cn(u,m).

 -- Função: jacobi_cs (<u>, <m>)
     A função elíptica Jacobiana cs(u,m) = cn(u,m)/sn(u,m).

 -- Função: jacobi_cd (<u>, <m>)
     A função elíptica Jacobiana cd(u,m) = cn(u,m)/dn(u,m).

 -- Função: jacobi_nd (<u>, <m>)
     A função elíptica Jacobiana nc(u,m) = 1/cn(u,m).

 -- Função: jacobi_ds (<u>, <m>)
     A função elíptica Jacobiana ds(u,m) = dn(u,m)/sn(u,m).

 -- Função: jacobi_dc (<u>, <m>)
     A função elíptica Jacobiana dc(u,m) = dn(u,m)/cn(u,m).

 -- Função: inverse_jacobi_sn (<u>, <m>)
     A inversa da função elíptica Jacobiana sn(u,m).

 -- Função: inverse_jacobi_cn (<u>, <m>)
     A inversa da função elíptica Jacobiana cn(u,m).

 -- Função: inverse_jacobi_dn (<u>, <m>)
     A inversa da função elíptica Jacobiana dn(u,m).

 -- Função: inverse_jacobi_ns (<u>, <m>)
     A inversa da função elíptica Jacobiana ns(u,m).

 -- Função: inverse_jacobi_sc (<u>, <m>)
     A inversa da função elíptica Jacobiana sc(u,m).

 -- Função: inverse_jacobi_sd (<u>, <m>)
     A inversa da função elíptica Jacobiana sd(u,m).

 -- Função: inverse_jacobi_nc (<u>, <m>)
     A inversa da função elíptica Jacobiana nc(u,m).

 -- Função: inverse_jacobi_cs (<u>, <m>)
     A inversa da função elíptica Jacobiana cs(u,m).

 -- Função: inverse_jacobi_cd (<u>, <m>)
     A inversa da função elíptica Jacobiana cd(u,m).

 -- Função: inverse_jacobi_nd (<u>, <m>)
     A inversa da função elíptica Jacobiana nc(u,m).

 -- Função: inverse_jacobi_ds (<u>, <m>)
     A inversa da função elíptica Jacobiana ds(u,m).

 -- Função: inverse_jacobi_dc (<u>, <m>)
     A inversa da função elíptica Jacobiana dc(u,m).


File: maxima.info,  Node: Funções e Variáveis Definidas para Integrais Elípticas,  Prev: Funções e Variáveis Definidas para Funções Elípticas,  Up: Top

17.3 Funções e Variáveis Definidas para Integrais Elípticas
===========================================================

 -- Função: elliptic_f (<phi>, <m>)
     A integral elíptica incompleta de primeiro tipo, definida como

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, phi)

     Veja também *note elliptic_e:: e *note elliptic_kc::.

 -- Função: elliptic_e (<phi>, <m>)
     A integral elíptica incompleta de segundo tipo, definida como

     elliptic_e(u, m) = integrate(sqrt(1 - m*sin(x)^2), x, 0, phi) Veja
     também *note elliptic_e:: e *note elliptic_ec::.

 -- Função: elliptic_eu (<u>, <m>)
     A integral elíptica incompleta de segundo tipo, definida como
     integrate(dn(v,m)^2,v,0,u) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),
     t, 0, tau)

     onde tau = sn(u,m)

     Isso é relacionado a elliptic_e através de elliptic_eu(u, m) =
     elliptic_e(asin(sn(u,m)),m) Veja também *note elliptic_e::.

 -- Função: elliptic_pi (<n>, <phi>, <m>)
     A integral elíptica incompleta de terceiro tipo, definida como

     integrate(1/(1-n*sin(x)^2)/sqrt(1 - m*sin(x)^2), x, 0, phi)

     Somente a derivada em relação a phi é conhecida pelo Maxima.

 -- Função: elliptic_kc (<m>)
     A integral elíptica completa de primeiro tipo, definida como

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     Para certos valores de m, o valor da integral é conhecido em termos
     de funções Gamma.  Use 'makegamma' para avaliar esse valor.

 -- Função: elliptic_ec (<m>)
     A integral elíptica completa de sgundo tipo, definida como

     integrate(sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     Para certos valores de m, o valor da integral é conhecido em termos
     de funçõesvGamma.  Use 'makegamma' para avaliar esse valor.


File: maxima.info,  Node: Limites,  Next: Diferenciação,  Prev: Funções Elípticas,  Up: Top

18 Limites
**********

* Menu:

* Funções e Variáveis Definidas para Limites::


File: maxima.info,  Node: Funções e Variáveis Definidas para Limites,  Prev: Limites,  Up: Limites

18.1 Funções e Variáveis Definidas para Limites
===============================================

 -- Variável de Opção: lhospitallim
     Valor padrão: 4

     'lhospitallim' é o máximo número de vezes que a regra L'Hospital é
     usada em 'limit'.  Isso evita ciclos infinitos em casos como 'limit
     (cot(x)/csc(x), x, 0)'.

 -- Função: limit (<expr>, <x>, <val>, <dir>)
 -- Função: limit (<expr>, <x>, <val>)
 -- Função: limit (<expr>)
     Calcula o limite de <expr> com a variável real <x> aproximando-se
     do valor <val> pela direção <dir>.  <dir> pode ter o valor 'plus'
     para um limite pela direita, 'minus' para um limite pela esquerda,
     ou pode ser omitido (implicando em um limite em ambos os lados é
     para ser computado).

     'limit' usa os seguintes símbolos especiais: 'inf' (infinito
     positivo) e 'minf' (infinito negativo).  Em saídas essa função pode
     também usar 'und' (undefined - não definido), 'ind' (indefinido mas
     associado) e 'infinity' (infinito complexo).

     'lhospitallim' é o máximo número de vezes que a regra L'Hospital é
     usada em 'limit'.  Isso evita ciclos infinitos em casos como 'limit
     (cot(x)/csc(x), x, 0)'.

     'tlimswitch' quando 'true' fará o pacote 'limit' usar série de
     Taylor quando possível.

     'limsubst' evita que 'limit' tente substituições sobre formas
     desconhecidas.  Isso é para evitar erros como 'limit (f(n)/f(n+1),
     n, inf)' dando igual a 1.  Escolhendo 'limsubst' para 'true'
     permitirá tais substituições.

     'limit' com um argumento é muitas vezes chamado em ocasiões para
     simplificar expressões de constantes, por exemplo, 'limit (inf-1)'.

     'example (limit)' mostra alguns exemplos.

     Para saber sobre o método utilizado veja Wang, P., "Evaluation of
     Definite Integrals by Symbolic Manipulation", tese de Ph.D., MAC
     TR-92, Outubro de 1971.

 -- Variável de Opção: limsubst
     valor padrão: 'false' - evita que 'limit' tente substituições sobre
     formas desconhecidas.  Isso é para evitar erros como 'limit
     (f(n)/f(n+1), n, inf)' dando igual a 1.  Escolhendo 'limsubst' para
     'true' permitirá tais substituições.

 -- Função: tlimit (<expr>, <x>, <val>, <dir>)
 -- Função: tlimit (<expr>, <x>, <val>)
 -- Função: tlimit (<expr>)
     Retorna 'limit' com 'tlimswitch' escolhido para 'true'.

 -- Variável de Opção: tlimswitch
     Valor padrão: 'false'

     Quando 'tlimswitch' for 'true', fará o pacote 'limit' usar série de
     Taylor quando possível.


File: maxima.info,  Node: Diferenciação,  Next: Integração,  Prev: Limites,  Up: Top

19 Diferenciação
****************

/Differentiation.texi/1.20/Sat Jun 2 00:12:38 2007/-ko/
* Menu:

* Funções e Variáveis Definidas para Diferenciação::  


File: maxima.info,  Node: Funções e Variáveis Definidas para Diferenciação,  Prev: Diferenciação,  Up: Diferenciação

19.1 Funções e Variáveis Definidas para Diferenciação
=====================================================

 -- Função: antid (<expr>, <x>, <u(x)>)
     Retorna uma lista de dois elementos, tais que uma antiderivada de
     <expr> com relação a <x> pode ser constuída a partir da lista.  A
     expressão <expr> pode conter uma função desconhecida <u> e suas
     derivadas.

     Tome <L>, uma lista de dois elementos, como sendo o valor de
     retorno de 'antid'.  Então '<L>[1] + 'integrate (<L>[2], <x>)' é
     uma antiderivada de <expr> com relação a <x>.

     Quando 'antid' obtém sucesso inteiramente, o segundo elemento do
     valor de retorno é zero.  De outra forma, o segundo elemento é não
     zero, e o primeiro elemento não zero ou zero.  Se 'antid' não pode
     fazer nenhum progresso, o primeiro elemento é zero e o segundo não
     zero.

     'load ("antid")' chama essa função.  O pacote 'antid' também define
     as funções 'nonzeroandfreeof' e 'linear'.

     'antid' está relacionada a 'antidiff' como segue.  Tome <L>, uma
     lista de dois elementos, que é o valor de retorno de 'antid'.
     Então o valor de retorno de 'antidiff' é igual a '<L>[1] +
     'integrate (<L>[2], <x>)' onde <x> é a variável de integração.

     Exemplos:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /

 -- Função: antidiff (<expr>, <x>, <u>(<x>))
     Retorna uma antiderivada de <expr> com relação a <x>.  A expressão
     <expr> pode conter uma função desconhecida <u> e suas derivadas.

     Quando 'antidiff' obtém sucesso inteiramente, a expressão
     resultante é livre do sinal de integral (isto é, livre do
     substantivo 'integrate').  De outra forma, 'antidiff' retorna uma
     expressão que é parcialmente ou inteiramente dentro de um sinal de
     um sinal de integral.  Se 'antidiff' não pode fazer qualquer
     progresso, o valor de retorno é inteiramente dentro de um sinal de
     integral.

     'load ("antid")' chama essa função.  O pacote 'antid' também define
     as funções 'nonzeroandfreeof' e 'linear'.

     'antidiff' é relacionada a 'antid' como segue.  Tome <L>, uma lista
     de dois elementos, como sendo o valor de retorno de 'antid'.  Então
     o valor de retorno de 'antidiff' é igual a '<L>[1] + 'integrate
     (<L>[2], <x>)' onde <x> é a variável de integração.

     Exemplos:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /

 -- propriedade: atomgrad

     'atomgrad' é a propriedade do gradiente atômico de uma expressão.
     Essa propriedade é atribuída por 'gradef'.

 -- Função: atvalue (<expr>, [<x_1> = <a_1>, ..., <x_m> = <a_m>], <c>)
 -- Função: atvalue (<expr>, <x_1> = <a_1>, <c>)
     Atribui o valor <c> a <expr> no ponto '<x> = <a>'.  Tipicamente
     valores de extremidade são estabelecidos por esse mecanismo.

     <expr> é a função de avaliação, '<f>(<x_1>, ..., <x_m>)', ou uma
     derivada, 'diff (<f>(<x_1>, ..., <x_m>), <x_1>, <n_1>, ..., <x_n>,
     <n_m>)' na qual os argumentos da função explicitamente aparecem.
     <n_i> é a ordem de diferenciação com relação a <x_i>.

     O ponto no qual o 'atvalue' é estabelecido é dado pela lista de
     equações '[<x_1> = <a_1>, ..., <x_m> = <a_m>]'.  Se existe uma
     variável simples <x_1>, uma única equação pode ser dada sem ser
     contida em uma lista.

     'printprops ([<f_1>, <f_2>, ...], atvalue)' mostra os 'atvalues'
     das funções '<f_1>, <f_2>, ...' como especificado por chamadas a
     'atvalue'.  'printprops (<f>, atvalue)' mostra os 'atvalues' de uma
     função <f>.  'printprops (all, atvalue)' mostra os 'atvalue's de
     todas as funções para as quais 'atvalue's são definidos.

     Os simbolos '@1', '@2', ...  representam as variáveis <x_1>, <x_2>,
     ...  quando 'atvalue's são mostrados.

     'atvalue' avalia seus argumentos.  'atvalue' retorna <c>, o
     'atvalue'.

     Exemplos:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x,y)^2 - u(x,y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1

 -- Função: cartan -
     O cálculo exterior de formas diferenciais é uma ferramenta básica
     de geometria diferencial desenvolvida por Elie Cartan e tem
     importantes aplicações na teoria das equações diferenciais
     parciais.  O pacote 'cartan' implementa as funções 'ext_diff' e
     'lie_diff', juntamente com os operadores '~' (produto da cunha) e
     '|' (contração de uma forma com um vetor.)  Digite 'demo (tensor)'
     para ver uma breve descrição desses comandos juntamente com
     exemplos.

     'cartan' foi implementado por F.B. Estabrook e H.D. Wahlquist.

 -- Função: del (<x>)
     'del (<x>)' representa a diferencial da variável x.

     'diff' retorna uma expressão contendo 'del' se uma variável
     independente não for especificada.  Nesse caso, o valor de retorno
     é a então chamada "diferencial total".

     Exemplos:

          (%i1) diff (log (x));
                                       del(x)
          (%o1)                        ------
                                         x
          (%i2) diff (exp (x*y));
                               x y              x y
          (%o2)            x %e    del(y) + y %e    del(x)
          (%i3) diff (x*y*z);
          (%o3)         x y del(z) + x z del(y) + y z del(x)

 -- Função: delta (<t>)
     A função Delta de Dirac.

     Correntemente somente 'laplace' sabe sobre a função 'delta'.

     Exemplo:

          (%i1) laplace (delta (t - a) * sin(b*t), t, s);
          Is  a  positive, negative, or zero?

          p;
                                             - a s
          (%o1)                   sin(a b) %e

 -- Variável: dependencies
     Valor padrão: '[]'

     'dependencies' é a lista de átomos que possuem dependências
     funcionais, atribuídas por 'depends' ou 'gradef'.  A lista
     'dependencies' é cumulativa: cada chamada a 'depends' ou a 'gradef'
     anexa ítens adicionais.

     Veja 'depends' e 'gradef'.

 -- Função: depends (<f_1>, <x_1>, ..., <f_n>, <x_n>)
     Declara dependêcias funcionais entre variáveis para o propósito de
     calcular derivadas.  Na ausência de dependêcias declaradas, 'diff
     (f, x)' retorna zero.  Se 'depends (f, x)' for declarada, 'diff (f,
     x)' retorna uma derivada simbólica (isto é, um substantivo 'diff').

     Cada argumento <f_1>, <x_1>, etc., pode ser o nome de uma variável
     ou array, ou uma lista de nomes.  Todo elemento de <f_i> (talvez
     apenas um elemento simples) é declarado para depender de todo
     elemento de <x_i> (talvez apenas um elemento simples).  Se algum
     <f_i> for o nome de um array ou contém o nome de um array, todos os
     elementos do array dependem de <x_i>.

     'diff' reconhece dependências indiretas estabelecidas por 'depends'
     e aplica a regra da cadeia nesses casos.

     'remove (<f>, dependency)' remove todas as dependências declaradas
     para <f>.

     'depends' retorna uma lista de dependências estabelecidas.  As
     dependências são anexadas à variável global 'dependencies'.
     'depends' avalia seus argumentos.

     'diff' é o único comando Maxima que reconhece dependências
     estabelecidas por 'depends'.  Outras funções ('integrate',
     'laplace', etc.)  somente reconhecem dependências explicitamente
     representadas por seus argumentos.  Por exemplo, 'integrate' não
     reconhece a dependência de 'f' sobre 'x' a menos que explicitamente
     representada como 'integrate (f(x), x)'.

          (%i1) depends ([f, g], x);
          (%o1)                     [f(x), g(x)]
          (%i2) depends ([r, s], [u, v, w]);
          (%o2)               [r(u, v, w), s(u, v, w)]
          (%i3) depends (u, t);
          (%o3)                        [u(t)]
          (%i4) dependencies;
          (%o4)      [f(x), g(x), r(u, v, w), s(u, v, w), u(t)]
          (%i5) diff (r.s, u);
                                   dr           ds
          (%o5)                    -- . s + r . --
                                   du           du

          (%i6) diff (r.s, t);
                                dr du           ds du
          (%o6)                 -- -- . s + r . -- --
                                du dt           du dt

          (%i7) remove (r, dependency);
          (%o7)                         done
          (%i8) diff (r.s, t);
                                          ds du
          (%o8)                       r . -- --
                                          du dt

 -- Variável de opção: derivabbrev
     Valor padrão: 'false'

     Quando 'derivabbrev' for 'true', derivadas simbólicas (isto é,
     substantivos 'diff') são mostradas como subscritos.  De outra
     forma, derivadas são mostradas na notação de Leibniz 'dy/dx'.

 -- Função: derivdegree (<expr>, <y>, <x>)
     Retorna o maior grau de uma derivada da variável dependente <y> com
     relação à variável independente <x> ocorrendo em <expr>.

     Exemplo:
          (%i1) 'diff (y, x, 2) + 'diff (y, z, 3) + 'diff (y, x) * x^2;
                                   3     2
                                  d y   d y    2 dy
          (%o1)                   --- + --- + x  --
                                    3     2      dx
                                  dz    dx
          (%i2) derivdegree (%, y, x);
          (%o2)                           2

 -- Função: derivlist (<var_1>, ..., <var_k>)
     Causa somente diferenciações com relação às variáveis indicadas,
     dentro do comando 'ev'.

 -- Variável de opção: derivsubst
     Valor padrão: 'false'

     Quando 'derivsubst' for 'true', uma substiruíção não sintática tais
     como 'subst (x, 'diff (y, t), 'diff (y, t, 2))' retorna ''diff (x,
     t)'.

 -- Função: diff (<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)
 -- Função: diff (<expr>, <x>, <n>)
 -- Função: diff (<expr>, <x>)
 -- Função: diff (<expr>)
     Retorna uma derivada ou diferencial de <expr> com relação a alguma
     ou todas as variáveis em <expr>.

     'diff (<expr>, <x>, <n>)' retorna a <n>'ésima derivada de <expr>
     com relação a <x>.

     'diff (<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)' retorna a derivada
     parcial mista de <expr> com relação a <x_1>, ..., <x_m>.  Isso é
     equivalente a 'diff (... (diff (<expr>, <x_m>, <n_m>) ...), <x_1>,
     <n_1>)'.

     'diff (<expr>, <x>)' retorna a primeira derivada de <expr> com
     relação a uma variável <x>.

     'diff (<expr>)' retorna a diferencial total de <expr>, isto é, a
     soma das derivadas de <expr> com relação a cada uma de suas
     variáveis vezes a diferencial 'del' de cada variável.  Nenhuma
     simplificação adicional de 'del' é oferecida.

     A forma substantiva de 'diff' é requerida em alguns contextos, tal
     como declarando uma equação diferencial.  Nesses casos, 'diff' pode
     ser colocado apóstrofo (com ''diff') para retornar a forma
     substantiva em lugar da realização da diferenciação.

     Quando 'derivabbrev' for 'true', derivadas são mostradas como
     subscritos.  De outra forma, derivadas são mostradas na notação de
     Leibniz, 'dy/dx'.

     Exemplos:

          (%i1) diff (exp (f(x)), x, 2);
                               2
                        f(x)  d               f(x)  d         2
          (%o1)       %e     (--- (f(x))) + %e     (-- (f(x)))
                                2                   dx
                              dx
          (%i2) derivabbrev: true$
          (%i3) 'integrate (f(x, y), y, g(x), h(x));
                                   h(x)
                                  /
                                  [
          (%o3)                   I     f(x, y) dy
                                  ]
                                  /
                                   g(x)
          (%i4) diff (%, x);
                 h(x)
                /
                [
          (%o4) I     f(x, y)  dy + f(x, h(x)) h(x)  - f(x, g(x)) g(x)
                ]            x                     x                  x
                /
                 g(x)

     Para o pacote tensor, as seguintes modificações foram incorporadas:

     (1) As derivadas de quaisquer objetos indexados em <expr> terão as
     variáveis <x_i> anexadas como argumentos adicionais.  Então todos
     os índices de derivada serão ordenados.

     (2) As variáveis <x_i> podem ser inteiros de 1 até o valor de uma
     variável 'dimension' [valor padrão: 4].  Isso fará com que a
     diferenciação seja concluída com relação aos <x_i>'ésimos membros
     da lista 'coordinates' que pode ser escolhida para uma lista de
     nomes de coordenadas, e.g., '[x, y, z, t]'.  Se 'coordinates' for
     associada a uma variável atômica, então aquela variável subscrita
     por <x_i> será usada para uma variável de diferenciação.  Isso
     permite um array de nomes de coordenadas ou nomes subscritos como
     'X[1]', 'X[2]', ...  sejam usados.  Se 'coordinates' não foram
     atribuídas um valor, então as variáveis seram tratadas como em (1)
     acima.

 -- Símbolo especial: diff

     Quando 'diff' está presente como um 'evflag' em chamadas para 'ev',
     Todas as diferenciações indicadas em 'expr' são realizdas.

 -- Função: dscalar (<f>)
     Aplica o d'Alembertiano escalar para a função escalar <f>.

     'load ("ctensor")' chama essa função.

 -- Função: express (<expr>)

     Expande o substantivo do operador diferencial em expressões em
     termos de derivadas parciais.  'express' reconhece os operadores
     'grad', 'div', 'curl', 'laplacian'.  'express' também expande o
     produto do X '~'.

     Derivadas simbólicas (isto é, substantivos 'diff') no valor de
     retorno de 'express' podem ser avaliadas incluíndo 'diff' na
     chamada à função 'ev' ou na linha de comando.  Nesse contexto,
     'diff' age como uma 'evfun'.

     'load ("vect")' chama essa função.

     Exemplos:

          (%i1) load ("vect")$
          (%i2) grad (x^2 + y^2 + z^2);
                                        2    2    2
          (%o2)                  grad (z  + y  + x )
          (%i3) express (%);
                 d    2    2    2   d    2    2    2   d    2    2    2
          (%o3) [-- (z  + y  + x ), -- (z  + y  + x ), -- (z  + y  + x )]
                 dx                 dy                 dz
          (%i4) ev (%, diff);
          (%o4)                    [2 x, 2 y, 2 z]
          (%i5) div ([x^2, y^2, z^2]);
                                        2   2   2
          (%o5)                   div [x , y , z ]
          (%i6) express (%);
                             d    2    d    2    d    2
          (%o6)              -- (z ) + -- (y ) + -- (x )
                             dz        dy        dx
          (%i7) ev (%, diff);
          (%o7)                    2 z + 2 y + 2 x
          (%i8) curl ([x^2, y^2, z^2]);
                                         2   2   2
          (%o8)                   curl [x , y , z ]
          (%i9) express (%);
                 d    2    d    2   d    2    d    2   d    2    d    2
          (%o9) [-- (z ) - -- (y ), -- (x ) - -- (z ), -- (y ) - -- (x )]
                 dy        dz       dz        dx       dx        dy
          (%i10) ev (%, diff);
          (%o10)                      [0, 0, 0]
          (%i11) laplacian (x^2 * y^2 * z^2);
                                            2  2  2
          (%o11)                laplacian (x  y  z )
          (%i12) express (%);
                   2                2                2
                  d     2  2  2    d     2  2  2    d     2  2  2
          (%o12)  --- (x  y  z ) + --- (x  y  z ) + --- (x  y  z )
                    2                2                2
                  dz               dy               dx
          (%i13) ev (%, diff);
                                2  2      2  2      2  2
          (%o13)             2 y  z  + 2 x  z  + 2 x  y
          (%i14) [a, b, c] ~ [x, y, z];
          (%o14)                [a, b, c] ~ [x, y, z]
          (%i15) express (%);
          (%o15)          [b z - c y, c x - a z, a y - b x]

 -- Função: gradef (<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)
 -- Função: gradef (<a>, <x>, <expr>)
     Define as derivadas parciais (i.e., os componentes do gradiente) da
     função <f> ou variável <a>.

     'gradef (<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)' define
     'd<f>/d<x_i>' como <g_i>, onde <g_i> é uma expressão; <g_i> pode
     ser uma chamada de função, mas não o nome de uma função.  O número
     de derivadas parciais <m> pode ser menor que o número de argumentos
     <n>, nesses casos derivadas são definidas com relação a <x_1> até
     <x_m> somente.

     'gradef (<a>, <x>, <expr>)' define uma derivada de variável <a> com
     relação a <x> como <expr>.  Isso também estabelece a dependência de
     <a> sobre <x> (via 'depends (<a>, <x>)').

     O primeiro argumento '<f>(<x_1>, ..., <x_n>)' ou <a> é acompanhado
     de apóstrofo, mas os argumentos restantes <g_1>, ..., <g_m> são
     avaliados.  'gradef' retorna a função ou variável para as quais as
     derivadas parciais são definidas.

     'gradef' pode redefinir as derivadas de funções internas do Maxima.
     Por exemplo, 'gradef (sin(x), sqrt (1 - sin(x)^2))' redefine uma
     derivada de 'sin'.

     'gradef' não pode definir derivadas parciais para um função
     subscrita.

     'printprops ([<f_1>, ..., <f_n>], gradef)' mostra as derivadas
     parciais das funções <f_1>, ..., <f_n>, como definidas por
     'gradef'.

     'printprops ([<a_n>, ..., <a_n>], atomgrad)' mostra as derivadas
     parciais das variáveis <a_n>, ..., <a_n>, como definidas por
     'gradef'.

     'gradefs' é a lista de funções para as quais derivadas parciais
     foram definidas por 'gradef'.  'gradefs' não inclui quaisquer
     variáveis para quais derivadas parciais foram definidas por
     'gradef'.

     Gradientes são necessários quando, por exemplo, uma função não é
     conhecida explicitamente mas suas derivadas primeiras são e isso é
     desejado para obter derivadas de ordem superior.

 -- Variável de sistema: gradefs
     Valor padrão: '[]'

     'gradefs' é a lista de funções para as quais derivadas parciais
     foram definidas por 'gradef'.  'gradefs' não inclui quaisquer
     variáveis para as quais derivadas parciais foram deinidas por
     'gradef'.

 -- Função: laplace (<expr>, <t>, <s>)
     Tenta calcular a transformada de Laplace de <expr> com relação a
     uma variável <t> e parâmetro de transformação <s>.  Se 'laplace'
     não pode achar uma solução, um substantivo ''laplace' é retornado.

     'laplace' reconhece em <expr> as funções 'delta', 'exp', 'log',
     'sin', 'cos', 'sinh', 'cosh', e 'erf', também 'derivative',
     'integrate', 'sum', e 'ilt'.  Se algumas outras funções estiverem
     presente, 'laplace' pode não ser habilitada a calcular a
     tranformada.

     <expr> pode também ser uma equação linear, diferencial de
     coeficiente contante no qual caso o 'atvalue' da variável
     dependente é usado.  O requerido 'atvalue' pode ser fornecido ou
     antes ou depois da transformada ser calculada.  Uma vez que as
     condições iniciais devem ser especificadas em zero, se um teve
     condições de limite impostas em qualquer outro lugar ele pode impor
     essas sobre a solução geral e eliminar as constantes resolvendo a
     solução geral para essas e substituindo seus valores de volta.

     'laplace' reconhece integrais de convolução da forma 'integrate
     (f(x) * g(t - x), x, 0, t)'; outros tipos de convoluções não são
     reconhecidos.

     Relações funcionais devem ser explicitamente representadas em
     <expr>; relações implícitas, estabelecidas por 'depends', não são
     reconhecidas.  Isto é, se <f> depende de <x> e <y>, 'f (x, y)' deve
     aparecer em <expr>.

     Veja também 'ilt', a transformada inversa de Laplace.

     Exemplos:

          (%i1) laplace (exp (2*t + a) * sin(t) * t, t, s);
                                      a
                                    %e  (2 s - 4)
          (%o1)                    ---------------
                                     2           2
                                   (s  - 4 s + 5)
          (%i2) laplace ('diff (f (x), x), x, s);
          (%o2)             s laplace(f(x), x, s) - f(0)
          (%i3) diff (diff (delta (t), t), t);
                                    2
                                   d
          (%o3)                    --- (delta(t))
                                     2
                                   dt
          (%i4) laplace (%, t, s);
                                      !
                         d            !         2
          (%o4)        - -- (delta(t))!      + s  - delta(0) s
                         dt           !
                                      !t = 0


File: maxima.info,  Node: Integração,  Next: Equações,  Prev: Diferenciação,  Up: Top

20 Integração
*************

* Menu:

* Introdução a Integração::  
* Funções e Variáveis Definidas para Integração::  
* Introdução a QUADPACK::
* Funções e Variáveis Definidas para QUADPACK::


File: maxima.info,  Node: Introdução a Integração,  Next: Funções e Variáveis Definidas para Integração,  Prev: Integração,  Up: Integração

20.1 Introdução a Integração
============================

Maxima tem muitas rotinas para manusear integração.  A função
'integrate' faz uso de muitas dessas.  Exite também o pacote 'antid',
que manuseia uma função não especificada (e suas derivadas, certamente).
Para usos numericos, existe um conjunto de integradores adaptativos de
QUADPACK, a saber 'quad_qag', 'quad_qags', etc., os quais são descritos
sob o tópico 'QUADPACK'.  Funções hipergeométricas estão sendo
trabalhadas, veja 'specint' para detalhes.  Geralmente falando, Maxima
somente manuseia integrais que são integráveis em termos de "funções
elementares" (funções racionais, trigonometricas, logarítmicas,
exponenciais, radicais, etc.)  e umas poucas extensões (função de erro,
dilogarithm).  Isso não manuseia integrais em termos de funções
desconhecidas tais como 'g(x)' e 'h(x)'.


File: maxima.info,  Node: Funções e Variáveis Definidas para Integração,  Next: Introdução a QUADPACK,  Prev: Introdução a Integração,  Up: Integração

20.2 Funções e Variáveis Definidas para Integração
==================================================

 -- Função: changevar (<expr>, <f(x,y)>, <y>, <x>)
     Faz a mudança de variável dada por '<f(x,y)> = 0' em todas as
     integrais que ocorrem em <expr> com integração em relação a <x>.  A
     nova variável é <y>.

          (%i1) assume(a > 0)$
          (%i2) 'integrate (%e**sqrt(a*y), y, 0, 4);
                                4
                               /
                               [    sqrt(a) sqrt(y)
          (%o2)                I  %e                dy
                               ]
                               /
                                0
          (%i3) changevar (%, y-z^2/a, z, y);
                                0
                               /
                               [                abs(z)
                             2 I            z %e       dz
                               ]
                               /
                                - 2 sqrt(a)
          (%o3)            - ----------------------------
                                          a

     Uma expressão contendo uma forma substantiva, tais como as
     instâncias de ''integrate' acima, pode ser avaliada por 'ev' com o
     sinalizador 'nouns'.  Por exemplo, a expressão retornada por
     'changevar' acima pode ser avaliada por 'ev (%o3, nouns)'.

     'changevar' pode também ser usada para alterações nos índices de
     uma soma ou de um produto.  Todavia, isso deve obrigatóriamente ser
     realizado de forma que quando uma alteração é feita em uma soma ou
     produto, essa mudança deve ser um artifício, i.e., 'i = j+ ...',
     não uma função de grau mais alto.  E.g.,

          (%i4) sum (a[i]*x^(i-2), i, 0, inf);
                                   inf
                                   ====
                                   \         i - 2
          (%o4)                     >    a  x
                                   /      i
                                   ====
                                   i = 0
          (%i5) changevar (%, i-2-n, n, i);
                                  inf
                                  ====
                                  \               n
          (%o5)                    >      a      x
                                  /        n + 2
                                  ====
                                  n = - 2

 -- Função: dblint (<f>, <r>, <s>, <a>, <b>)
     Uma rotina de integral dupla que foi escrita no alto-nível do
     Maxima e então traduzida e compilada para linguagem de máquina.
     Use 'load (dblint)' para acessar esse pacote.  Isso usa o método da
     regra de Simpson em ambas as direções x e y para calcular

          /b /s(x)
          |  |
          |  |    f(x,y) dy dx
          |  |
          /a /r(x)

     A função <f> deve ser uma função traduzida ou compilada de duas
     variáveis, e <r> e <s> devem cada uma ser uma função traduzida ou
     compilada de uma variável, enquanto <a> e <b> devem ser números em
     ponto flutuante.  A rotina tem duas variáveis globais que
     determinam o número de divisões dos intervalos x e y: 'dblint_x' e
     'dblint_y', ambas as quais são inicialmente 10, e podem ser
     alteradas independentemente para outros valores inteiros (existem
     '2*dblint_x+1' pontos calculados na direção x , e '2*dblint_y+1' na
     direção y).  A rotina subdivide o eixo X e então para cada valor de
     X isso primeiro calcula '<r>(x)' e '<s>(x)'; então o eixo Y entre
     '<r>(x)' e '<s>(x)' é subdividido e a integral ao longo do eixo Y é
     executada usando a regra de Simpson; então a integral ao longo do
     eixo X é concluída usando a regra de Simpson com os valores da
     função sendo as integrais-Y. Esse procedimento pode ser
     numericamente instável por uma grande variedade razões, mas
     razoávelmente rápido: evite usar isso sobre funções altamente
     oscilatórias e funções com singularidades (postes ou pontos de
     ramificação na região).  As integrais Y dependem de quanto
     fragmentados '<r>(x)' e '<s>(x)' são, então se a ditância '<s>(x) -
     <r>(x)' varia rapidamente com X, nesse ponto pode ter erros
     substanciais provenientes de truncação com diferentes
     saltos-tamanhos nas várias integrais Y. Um pode incrementar
     'dblint_x' e 'dblint_y' em uma tentativa para melhorar a
     convergência da reião, com sacrifício do tempo de computação.  Os
     valores da função não são salvos, então se a função é muito
     desperdiçadora de tempo,você terá de esperar por re-computação se
     você mudar qualquer coisa (desculpe).  Isso é requerido que as
     funções <f>, <r>, e <s> sejam ainda traduzidas ou compiladas
     previamente chamando 'dblint'.  Isso resultará em ordens de
     magnitude de melhoramentos de velocidade sobre o código
     interpretado em muitos casos!

     'demo (dblint)' executa uma demonstração de 'dblint' aplicado a um
     problema exemplo.

 -- Função: defint (<expr>, <x>, <a>, <b>)
     Tenta calcular uma integral definida.  'defint' é chamada por
     'integrate' quando limites de integração são especificados, i.e.,
     quando 'integrate' é chamado como 'integrate (<expr>, <x>, <a>,
     <b>)'.  Dessa forma do ponto de vista do usuário, isso é suficiente
     para chamar 'integrate'.

     'defint' retorna uma expressão simbólica, e executa um dos dois: ou
     calcula a integral ou a forma substantiva da integral.  Veja
     'quad_qag' e funções rellacionadas para aproximação numérica de
     integrais definidas.

 -- Função: erf (<x>)
     Representa a função de erro, cuja derivada é:
     '2*exp(-x^2)/sqrt(%pi)'.

 -- Variável de opção: erfflag
     Valor padrão: 'true'

     Quando 'erfflag' é 'false', previne 'risch' da introdução da função
     'erf' na resposta se não houver nenhum no integrando para começar.

 -- Função: ilt (<expr>, <t>, <s>)
     Calcula a transformação inversa de Laplace de <expr> em relação a
     <t> e parâmetro <s>.  <expr> deve ser uma razão de polinômios cujo
     denominador tem somente fatores lineares e quadráticos.  Usando a
     funções 'laplace' e 'ilt' juntas com as funções 'solve' ou
     'linsolve' o usuário pode resolver uma diferencial simples ou uma
     equação integral de convolução ou um conjunto delas.

          (%i1) 'integrate (sinh(a*x)*f(t-x), x, 0, t) + b*f(t) = t**2;
                        t
                       /
                       [                                    2
          (%o1)        I  f(t - x) sinh(a x) dx + b f(t) = t
                       ]
                       /
                        0
          (%i2) laplace (%, t, s);
                                         a laplace(f(t), t, s)   2
          (%o2)  b laplace(f(t), t, s) + --------------------- = --
                                                 2    2           3
                                                s  - a           s
          (%i3) linsolve ([%], ['laplace(f(t), t, s)]);
                                                  2      2
                                               2 s  - 2 a
          (%o3)     [laplace(f(t), t, s) = --------------------]
                                              5         2     3
                                           b s  + (a - a  b) s
          (%i4) ilt (rhs (first (%)), s, t);
          Is  a b (a b - 1)  positive, negative, or zero?

          pos;
                         sqrt(a b (a b - 1)) t
                  2 cosh(---------------------)       2
                                   b               a t
          (%o4) - ----------------------------- + -------
                        3  2      2               a b - 1
                       a  b  - 2 a  b + a

                                                                 2
                                                       + ------------------
                                                          3  2      2
                                                         a  b  - 2 a  b + a

 -- Função: integrate (<expr>, <x>)
 -- Função: integrate (<expr>, <x>, <a>, <b>)
     Tenta símbolicamente calcular a integral de <expr> em relação a
     <x>.  'integrate (<expr>, <x>)' é uma integral indefinida, enquanto
     'integrate (<expr>, <x>, <a>, <b>)' é uma integral definida, com
     limites de integração <a> e <b>.  Os limites não poderam conter
     <x>, embora 'integrate' não imponha essa restrição.  <a> não
     precisa ser menor que <b>.  Se <b> é igual a <a>, 'integrate'
     retorna zero.

     Veja 'quad_qag' e funções relacionadas para aproximação numérica de
     integrais definidas.  Veja 'residue' para computação de resíduos
     (integração complexa).  Veja 'antid' para uma forma alternativa de
     calcular integrais indefinidas.

     A integral (uma expressão livre de 'integrate') é retornada se
     'integrate' obtém sucesso.  De outra forma o valor de retorno é a
     forma substantiva da integral (o operador com apóstrofo
     ''integrate') ou uma expressão contendo uma ou mais formas
     substantivas.  A forma substantiva de 'integrate' é mostrada com um
     sinal de integral.

     Em algumas circunstâncias isso é útil para construir uma forma
     substantiva manualmente, colocando em 'integrate' um apóstrofo,
     e.g., ''integrate (<expr>, <x>)'.  Por exemplo, a integral pode
     depender de alguns parâmetos que não estão ainda calculados.  A
     forma substantiva pode ser aplicada a seus argumentos por 'ev (<i>,
     nouns)' onde <i> é a forma substantiva de interesse.

     'integrate' manuseia integrais definidas separadamente das
     indefinidas, e utiliza uma gama de heurísticas para manusear cada
     caso.  Casos especiais de integrais definidas incluem limites de
     integração iguais a zero ou infinito ('inf' ou 'minf'), funções
     trigonométricas com limites de integração iguais a zero e '%pi' ou
     '2 %pi', funções racionais, integrais relacionadas para as
     definições de funções 'beta' e 'psi', e algumas integrais
     logarítmicas e trigonométricas.  Processando funções racionais pode
     incluir computação de resíduo.  Se um caso especial aplicável não é
     encontrado, tentativa será feita para calcular a integra indefinida
     e avaliar isso nos limites de integração.  Isso pode incluir pegar
     um limite como um limite de integração tendendo ao infinito ou a
     menos infinito; veja também 'ldefint'.

     Casos especiais de integrais indefinidas incluem funções
     trigonométricas, exponenciais e funções logarítmicas, e funções
     racionais.  'integrate' pode também fazer uso de uma curta tabela
     de integais elementares.

     'integrate' pode realizar uma mudança de variável se o integrando
     tem a forma 'f(g(x)) * diff(g(x), x)'.  'integrate' tenta achar uma
     subexpressão 'g(x)' de forma que a derivada de 'g(x)' divida o
     integrando.  Essa busca pode fazer uso de derivadas definidas pela
     função 'gradef'.  Veja também 'changevar' e 'antid'.

     Se nenhum dos procedimentos heurísticos acha uma integral
     indefinida, o algorítmo de Risch é executado.  O sinalizador
     'risch' pode ser escolhido como um 'evflag', na chamada para 'ev'
     ou na linha de comando, e.g., 'ev (integrate (<expr>, <x>), risch)'
     ou 'integrate (<expr>, <x>), risch'.  Se 'risch' está presente,
     'integrate' chama a função 'risch' sem tentar heurísticas primeiro.
     Veja também 'risch'.

     'integrate' trabalha somente com relações funcionais representadas
     explicitamente com a notação 'f(x)'.  'integrate' não respeita
     dependências implicitas estabelecidas pela função 'depends'.
     'integrate' pode necessitar conhecer alguma propriedade de um
     parâmetro no integrando.  'integrate' irá primeiro consultar a base
     de dados do 'assume', e , se a variável de interesse não está lá,
     'integrate' perguntará ao usuário.  Dependendo da pergunta,
     respostas adequadas são 'yes;' ou 'no;', ou 'pos;', 'zero;', ou
     'neg;'.

     'integrate' não é, por padrão, declarada ser linear.  Veja
     'declare' e 'linear'.

     'integrate' tenta integração por partes somente em uns poucos casos
     especiais.

     Exemplos:

        * Integrais definidas e indefinidas elementares.

               (%i1) integrate (sin(x)^3, x);
                                          3
                                       cos (x)
               (%o1)                   ------- - cos(x)
                                          3
               (%i2) integrate (x/ sqrt (b^2 - x^2), x);
                                                2    2
               (%o2)                    - sqrt(b  - x )
               (%i3) integrate (cos(x)^2 * exp(x), x, 0, %pi);
                                              %pi
                                          3 %e      3
               (%o3)                      ------- - -
                                             5      5
               (%i4) integrate (x^2 * exp(-x^2), x, minf, inf);
                                           sqrt(%pi)
               (%o4)                       ---------
                                               2

        * Uso de 'assume' e dúvida interativa.

               (%i1) assume (a > 1)$
               (%i2) integrate (x**a/(x+1)**(5/2), x, 0, inf);
                   2 a + 2
               Is  -------  an integer?
                      5

               no;
               Is  2 a - 3  positive, negative, or zero?

               neg;
                                                  3
               (%o2)                  beta(a + 1, - - a)
                                                  2

        * Mudança de variável.  Existem duas mudanças de variável nesse
          exemplo: uma usando a derivada estabelecida por 'gradef', e
          uma usando a derivação 'diff(r(x))' de uma função não
          especificada 'r(x)'.

               (%i3) gradef (q(x), sin(x**2));
               (%o3)                         q(x)
               (%i4) diff (log (q (r (x))), x);
                                     d               2
                                    (-- (r(x))) sin(r (x))
                                     dx
               (%o4)                ----------------------
                                           q(r(x))
               (%i5) integrate (%, x);
               (%o5)                     log(q(r(x)))

        * O valor de retorno contém a forma substantiva ''integrate'.
          Nesse exemplo, Maxima pode extrair um fator do denominador de
          uma função racional, mas não pode fatorar o restante ou de
          outra forma achar sua integral.  'grind' mostra a forma
          substantiva ''integrate' no resultado.  Veja também
          'integrate_use_rootsof' para mais sobre integrais de funções
          racionais.

               (%i1) expand ((x-4) * (x^3+2*x+1));
                                   4      3      2
               (%o1)              x  - 4 x  + 2 x  - 7 x - 4
               (%i2) integrate (1/%, x);
                                             /  2
                                             [ x  + 4 x + 18
                                             I ------------- dx
                                             ]  3
                                log(x - 4)   / x  + 2 x + 1
               (%o2)            ---------- - ------------------
                                    73               73
               (%i3) grind (%);
               log(x-4)/73-('integrate((x^2+4*x+18)/(x^3+2*x+1),x))/73$

        * Definindo uma função em termos de uma integral.  O corpo de
          uma função não é avaliado quando a função é definida.  Dessa
          forma o corpo de 'f_1' nesse exemplo contém a forma
          substantiva de 'integrate'.  O operador apóstrofo-apóstrofo
          '''' faz com que a integral seja avaliada, e o resultado
          transforme-se no corpo de 'f_2'.

               (%i1) f_1 (a) := integrate (x^3, x, 1, a);
                                                    3
               (%o1)           f_1(a) := integrate(x , x, 1, a)
               (%i2) ev (f_1 (7), nouns);
               (%o2)                          600
               (%i3) /* Note parentheses around integrate(...) here */
                     f_2 (a) := ''(integrate (x^3, x, 1, a));
                                                  4
                                                 a    1
               (%o3)                   f_2(a) := -- - -
                                                 4    4
               (%i4) f_2 (7);
               (%o4)                          600

 -- Variável de sistema: integration_constant_counter
     Valor padrão: 0

     'integração_constant_counter' é um contador que é atualizado a cada
     vez que uma constante de integração (nomeada pelo Maxima, e.g.,
     'integrationconstant1') é introduzida em uma expressão pela
     integração indefinida de uma equação.

 -- Variável de opção: integrate_use_rootsof
     Valor padrão: 'false'

     Quando 'integrate_use_rootsof' é 'true' e o denominador de uma
     função racional não pode ser fatorado, 'integrate' retorna a
     integral em uma forma que é uma soma sobre as raízes (não
     conhecidas ainda) do denominador.

     Por exemplo, com 'integrate_use_rootsof' escolhido para 'false',
     'integrate' retorna uma integral não resolvida de uma função
     racional na forma substantiva:

          (%i1) integrate_use_rootsof: false$
          (%i2) integrate (1/(1+x+x^5), x);
                  /  2
                  [ x  - 4 x + 5
                  I ------------ dx                            2 x + 1
                  ]  3    2                2            5 atan(-------)
                  / x  - x  + 1       log(x  + x + 1)          sqrt(3)
          (%o2)   ----------------- - --------------- + ---------------
                          7                 14             7 sqrt(3)

     Agora vamos escolher o sinalizador para ser true e a parte não
     resolvida da integral será expressa como um somatório sobre as
     raízes do denominador da função racional:

          (%i3) integrate_use_rootsof: true$
          (%i4) integrate (1/(1+x+x^5), x);
                ====        2
                \       (%r4  - 4 %r4 + 5) log(x - %r4)
                 >      -------------------------------
                /                    2
                ====            3 %r4  - 2 %r4
                                  3      2
                %r4 in rootsof(%r4  - %r4  + 1, %r4)
          (%o4) ----------------------------------------------------------
                         7

                                                                       2 x + 1
                                                   2            5 atan(-------)
                                              log(x  + x + 1)          sqrt(3)
                                            - --------------- + ---------------
                                                    14             7 sqrt(3)

     Alternativamente o usuário pode calcular as raízes do denominador
     separadamente, e então expressar o integrando em termos dessas
     raízes, e.g., '1/((x - a)*(x - b)*(x - c))' ou '1/((x^2 - (a+b)*x +
     a*b)*(x - c))' se o denominador for um polinômio cúbico.  Algumas
     vezes isso ajudará Maxima a obter resultados mais úteis.

 -- Função: ldefint (<expr>, <x>, <a>, <b>)
     Tenta calcular a integral definida de <expr> pelo uso de 'limit'
     para avaliar a integral indefinida <expr> em relação a <x> no
     limite superior <b> e no limite inferior <a>.  Se isso falha para
     calcular a integral definida, 'ldefint' retorna uma expressão
     contendo limites como formas substantivas.

     'ldefint' não é chamada por 'integrate', então executando 'ldefint
     (<expr>, <x>, <a>, <b>)' pode retornar um resultado diferente de
     'integrate (<expr>, <x>, <a>, <b>)'.  'ldefint' sempre usa o mesmo
     método para avaliar a integral definida, enquanto 'integrate' pode
     utilizar várias heurísticas e pode reconhecer alguns casos
     especiais.

 -- Função: potential (<givengradient>)
     O cálculo faz uso da variável global 'potentialzeroloc[0]' que deve
     ser 'nonlist' ou da forma

          [indeterminatej=expressãoj, indeterminatek=expressãok, ...]

     O formador sendo equivalente para a expressão nonlist para todos os
     lados direitos-manuseados mais tarde.  Os lados direitos indicados
     são usados como o limite inferior de integração.  O sucesso das
     integrações pode depender de seus valores e de sua ordem.
     'potentialzeroloc' é inicialmente escolhido para 0.

 -- Função: residue (<expr>, <z>, <z_0>)
     Calcula o resíduo no plano complexo da expressão <expr> quando a
     variável <z> assumes o valor <z_0>.  O resíduo é o coeficiente de
     '(<z> - <z_0>)^(-1)' nas séries de Laurent para <expr>.

          (%i1) residue (s/(s**2+a**2), s, a*%i);
                                          1
          (%o1)                           -
                                          2
          (%i2) residue (sin(a*x)/x**4, x, 0);
                                           3
                                          a
          (%o2)                         - --
                                          6

 -- Função: risch (<expr>, <x>)
     Integra <expr> em relação a <x> usando um caso transcendental do
     algorítmo de Risch.  (O caso algébrico do algorítmo de Risch foi
     implementado.)  Isso atualmente manuseia os casos de exponenciais
     aninhadas e logarítmos que a parte principal de 'integrate' não
     pode fazer.  'integrate' irá aplicar automaticamente 'risch' se
     dados esses casos.

     'erfflag', se 'false', previne 'risch' da introdução da função
     'erf' na resposta se não for achado nenhum no integrando para
     começar.

          (%i1) risch (x^2*erf(x), x);
                                                                  2
                       3                      2                - x
                  %pi x  erf(x) + (sqrt(%pi) x  + sqrt(%pi)) %e
          (%o1)   -------------------------------------------------
                                        3 %pi
          (%i2) diff(%, x), ratsimp;
                                       2
          (%o2)                       x  erf(x)

 -- Função: tldefint (<expr>, <x>, <a>, <b>)
     Equivalente a 'ldefint' com 'tlimswitch' escolhido para 'true'.


File: maxima.info,  Node: Introdução a QUADPACK,  Next: Funções e Variáveis Definidas para QUADPACK,  Prev: Funções e Variáveis Definidas para Integração,  Up: Integração

20.3 Introdução a QUADPACK
==========================

QUADPACK é uma coleção de funções para aálculo numérico de integrais
definidas unidimensionais.  O pacote QUADPACK resultou da junção de um
projeto de R. Piessens (1), E. de Doncker (2), C. Ueberhuber (3), e D.
Kahaner (4).

   A biblioteca QUADPACK inclída no Maxima é uma tradução automática
(feita através do programa 'f2cl') do código fonte em de QUADPACK como
aparece na SLATEC Common Mathematical Library, Versão 4.1 (5).  A
biblioteca Fortran SLATEC é datada de Julho de 1993, mas as funções
QUADPACK foram escritas alguns anos antes.  Existe outra versão de
QUADPACK em Netlib (6); não está claro no que aquela versão difere da
versão existente em SLATEC.

   As funções QUADPACK incluídas no Maxima são toda automáticas, no
sentido de que essas funções tentam calcular um resultado para uma
precisão específica, requerendo um número não especificado de avaliações
de função.  A tradução do Lisp do Maxima da iblioteca QUADPACK também
inclui algumas funçe~s não automáticas, mas elas não são expostas a
nível de Maxima.

   Informação adicionalsobre a bilioteca QUADPACK pode ser encontrada no
livro do QUADPACK (7).

20.3.1 Overview
---------------

'quad_qag'
     Integração de uma função genérica sobre um intervalo finito.
     'quad_qag' implementa um integrador adaptativo globalmente simples
     usando a estratégia de Aind (Piessens, 1973).  O chamador pode
     escolher entre 6 pares de formulas da quadratura de Gauss-Kronrod
     para a componente de avaliação da regra.  As regras de alto grau
     são adequadas para integrandos fortemente oscilantes.

'quad_qags'
     Integração de uma função genérica sob um intervalo finito.
     'quad_qags' implementa subdivisão de intervalos globalmente
     adaptativos com extrapolação (de Doncker, 1978) por meio do
     algorítmo de Epsilon (Wynn, 1956).

'quad_qagi'
     Integração de uma função genérica sobre um intervalo finito ou
     semi-finito.  O intervalo é mapeado sobre um intervalo finito e
     então a mesma estratégia de 'quad_qags' é aplicada.

'quad_qawo'
     Integração de cos(omega x) f(x) ou sin(omega x) f(x) sobre um
     intervalo finito, onde omega é uma constante.  A componente de
     avaliação da regra é baseada na técnica modificada de
     Clenshaw-Curtis.  'quad_qawo' aplica subdivisão adaptativa com
     extrapolação, similar a 'quad_qags'.

'quad_qawf'
     Calcula uma transformação de cosseno de Fourier ou de um seno de
     Fourier sobre um intervalo semi-finito.  O mesmo aproxima como
     'quad_qawo' aplicado sobre intervalos finitos sucessivos, e
     aceleração de convergência por meio d algorítimo de Epsilon (Wynn,
     1956) aplicado a séries de contribuições de integrais.

'quad_qaws'
     Integraçào de w(x) f(x) sobre um intervalo finito [a, b], onde w é
     uma função da forma (x - a)^alpha (b - x)^beta v(x) e v(x) é 1 ou
     log(x - a) ou log(b - x) ou log(x - a) log(b - x), e alpha > -1 e
     beta > -1.  Auma estratégia de subdivisão adaptativa é aplicada,
     com integração modificada de Clenshaw-Curtis sobre os subintervalos
     que possuem a ou b.

'quad_qawc'
     Calcula o valor principal de Cauchy de f(x)/(x - c) sobre um
     intervalo finito (a, b) e um c especificado.  A estratégia é
     globalmente adaptativa, e a integração modificada de
     Clenshaw-Curtis é usada sobre subamplitudes que possuírem o ponto x
     = c.

   ---------- Footnotes ----------

   (1) Applied Mathematics and Programming Division, K.U. Leuven

   (2) Applied Mathematics and Programming Division, K.U. Leuven

   (3) Institut für Mathematik, T.U. Wien

   (4) National Bureau of Standards, Washington, D.C., U.S.A

   (5) http://www.netlib.org/slatec

   (6) http://www.netlib.org/quadpack

   (7) R. Piessens, E. de Doncker-Kapenga, C.W. Uberhuber, e D.K.
Kahaner.  QUADPACK: A Subroutine Package for Automatic Integration.
Berlin: Springer-Verlag, 1983, ISBN 0387125531.


File: maxima.info,  Node: Funções e Variáveis Definidas para QUADPACK,  Prev: Introdução a QUADPACK,  Up: Integração

20.4 Funções e Variáveis Definidas para QUADPACK
================================================

 -- Função: quad_qag (<f(x)>, <x>, <a>, <b>, <chave>, <epsrel>,
          <limite>)
 -- Função: quad_qag (<f>, <x>, <a>, <b>, <chave>, <epsrel>, <limite>)

     Integração de uma função genérica sobre um intervalo finito.
     'quad_qag' implementa um integrador adaptativo globalmente simples
     usando a estratégia de Aind (Piessens, 1973).  O chamador pode
     escolher entre 6 pares de fórmulas da quadratura de Gauss-Kronrod
     para a componente de avaliação da regra.  As regras de alto nível
     são adequadas para integrandos fortemente oscilatórios.

     'quad_qag' calcula a integral

     integrate (f(x), x, a, b)

     A função a ser integrada é <f(x)>, com variável dependente <x>, e a
     função é para ser integrada entre os limites <a> e <b>.  <chave> é
     o integrador a ser usado e pode ser um inteiro entre 1 e 6,
     inclusive.  O valor de <chave> seleciona a ordem da regra de
     integração de Gauss-Kronrod.  Regra de alta ordem são adequadas
     para integrandos fortemente oscilatórios.

     O integrando pode ser especidficado como o nome de uma função
     Maxima ou uma função Lisp ou um operador, uma expressão lambda do
     Maxima, ou uma expressão geral do Maxima.

     A integração numérica é concluída adaptativamente pela subdivisão a
     região de integração até que a precisão desejada for completada.

     Os argumentos opcionais <epsrel> e <limite> são o erro relativo
     desejado e o número máximo de subintervalos respectivamente.
     <epsrel> padrão em 1e-8 e <limite> é 200.

     'quad_qag' retorna uma lista de quatro elementos:

        * uma aproximação para a integral,
        * o erro absoluto estimado da aproximação,
        * o número de avaliações do integrando,
        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

     '0'
          se nenhum problema for encontrado;
     '1'
          se muitos subintervalos foram concluídos;
     '2'
          se erro excessivo é detectado;
     '3'
          se ocorre comportamento extremamente ruim do integrando;
     '6'
          se a entrada é inválida.

     Exemplos:

          (%i1) quad_qag (x^(1/2)*log(1/x), x, 0, 1, 3);
          (%o1)    [.4444444444492108, 3.1700968502883E-9, 961, 0]
          (%i2) integrate (x^(1/2)*log(1/x), x, 0, 1);
                                          4
          (%o2)                           -
                                          9

 -- Função: quad_qags (<f(x)>, <x>, <a>, <b>, <epsrel>, <limite>)
 -- Função: quad_qags (<f>, <x>, <a>, <b>, <epsrel>, <limite>)

     Integração de uma função geral sobre um intervalo finito.
     'quad_qags' implementa subdivisão de intervalo globalmente
     adaptativa com extrapolação (de Doncker, 1978) através do algorítmo
     de (Wynn, 1956).

     'quad_qags' computes the integral

     integrate (f(x), x, a, b)

     A função a ser integrada é <f(x)>, com variável dependente <x>, e a
     função é para ser integrada entre os limites <a> e <b>.

     O integrando pode ser especidficado como o nome de uma função
     Maxima ou uma função Lisp ou um operador, uma expressão lambda do
     Maxima, ou uma expressão geral do Maxima.

     Os argumentos opcionais <epsrel> e <limite> são o erro relativo
     desejado e o número máximo de subintervalos, respectivamente.
     <epsrel> padrão em 1e-8 e <limite> é 200.

     'quad_qags' retorna uma lista de quatro elementos:

        * uma aproximação para a integral,
        * o erro absoluto estimado da aproximação,
        * o número de avaliações do integrando,
        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

     '0'
          nenhum problema foi encontrado;
     '1'
          muitos subintervalos foram concluídos;
     '2'
          erro excessivo é detectado;
     '3'
          ocorreu comportamento excessivamente ruim do integrando;
     '4'
          falhou para convergência
     '5'
          integral é provavelmente divergente ou lentamente convergente
     '6'
          se a entrada é inválida.

     Exemplos:

          (%i1) quad_qags (x^(1/2)*log(1/x), x, 0 ,1);
          (%o1)   [.4444444444444448, 1.11022302462516E-15, 315, 0]

     Note que 'quad_qags' é mais preciso e eficiente que 'quad_qag' para
     esse integrando.

 -- Função: quad_qagi (<f(x)>, <x>, <a>, <inftype>, <epsrel>, <limite>)
 -- Função: quad_qagi (<f>, <x>, <a>, <inftype>, <epsrel>, <limite>)

     Integração de uma função genérica sobre um intervalo finito ou
     semi-finito.  O intervalo é mapeado sobre um intervalo finito e
     então a mesma estratégia que em 'quad_qags' é aplicada.

     'quad_qagi' avalia uma das seguintes integrais

     integrate (f(x), x, minf, inf)

     integrate (f(x), x, minf, a)

     integrate (f(x), x, a, minf, inf)

     usando a rotina Quadpack QAGI. A função a ser integrada é <f(x)>,
     com variável dependente <x>, e a função é para ser integrada sobre
     um intervalo infinito.

     O integrando pode ser especidficado como o nome de uma função
     Maxima ou uma função Lisp ou um operador, uma expressão lambda do
     Maxima, ou uma expressão geral do Maxima.

     O parâmetro <inftype> determina o intervalo de integração como
     segue:

     'inf'
          O intervalo vai de <a> ao infinito positivo.
     'minf'
          O intervalo vai do infinito negativo até <a>.
     'both'
          O intervalo corresponde a toda reta real.

     Os argumentos opcionais <epsrel> e <limite> são o erro relativo
     desejado e o número maximo de subintervalos, respectivamente.
     <epsrel> padrão para 1e-8 e <limite> é 200.

     'quad_qagi' retorna uma lista de quatro elementos:

        * uma aproximação para a integral,
        * o erro absoluto estimado da aproximação,
        * o número de avaliações do integrando,
        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

     '0'
          nenhum problema foi encontrado;
     '1'
          muitos subintervalos foram concluídos;
     '2'
          erro excessivo é detectado;
     '3'
          ocorreu comportamento excessivamente ruim do integrando;
     '4'
          falhou para convergência;
     '5'
          integral é provavelmente divergente ou lentamente convergente;
     '6'
          se a entrada for inválida.

     Exemplos:

          (%i1) quad_qagi (x^2*exp(-4*x), x, 0, inf);
          (%o1)        [0.03125, 2.95916102995002E-11, 105, 0]
          (%i2) integrate (x^2*exp(-4*x), x, 0, inf);
                                         1
          (%o2)                          --
                                         32

 -- Função: quad_qawc (<f(x)>, <x>, <c>, <a>, <b>, <epsrel>, <limite>)
 -- Função: quad_qawc (<f>, <x>, <c>, <a>, <b>, <epsrel>, <limite>)

     Calcula o valor principal de Cauchy de f(x)/(x - c) over a finite
     interval.  A estratégia é globalmente adaptativa, e a integração de
     Clenshaw-Curtis modificada é usada sobre as subamplitudes que
     possuírem o ponto x = c.

     'quad_qawc' calcula o valor principal de Cauchy de

     integrate (f(x)/(x - c), x, a, b)

     usando a rotina Quadpack QAWC. A função a ser integrada é
     '<f(x)>/(<x> - <c>)', com variável dependente <x>, e a função é
     para ser integrada sobre o intervalo que vai de <a> até <b>.

     O integrando pode ser especidficado como o nome de uma função
     Maxima ou uma função Lisp ou um operador, uma expressão lambda do
     Maxima, ou uma expressão geral do Maxima.

     Os argumentos opcionais <epsrel> e <limite> são o erro relativo
     desejado e o máximo número de subintervalos, respectivamente.
     <epsrel> padrão para 1e-8 e <limite> é 200.

     'quad_qawc' retorna uma lista de quatro elementos:

        * uma aproximação para a integral,
        * o erro absoluto estimado da aproximação,
        * o número de avaliações do integrando,
        * um código de erro.

     O código de erro (quarto elemento do valoor de retorno) pode ter os
     valores:

     '0'
          nenhum problema foi encontrado;
     '1'
          muitos subintervalos foram concluídos;
     '2'
          erro excessivo é detectado;
     '3'
          ocorreu comportamento excessivamente ruim do integrando;
     '6'
          se a entrada é inválida.

     Exemplos:

          (%i1) quad_qawc (2^(-5)*((x-1)^2+4^(-5))^(-1), x, 2, 0, 5);
          (%o1)    [- 3.130120337415925, 1.306830140249558E-8, 495, 0]
          (%i2) integrate (2^(-alpha)*(((x-1)^2 + 4^(-alpha))*(x-2))^(-1), x, 0, 5);
          Principal Value
                                 alpha
                  alpha       9 4                 9
                 4      log(------------- + -------------)
                                alpha           alpha
                            64 4      + 4   64 4      + 4
          (%o2) (-----------------------------------------
                                  alpha
                               2 4      + 2

                   3 alpha                       3 alpha
                   -------                       -------
                      2            alpha/2          2          alpha/2
                2 4        atan(4 4       )   2 4        atan(4       )   alpha
              - --------------------------- - -------------------------)/2
                          alpha                        alpha
                       2 4      + 2                 2 4      + 2
          (%i3) ev (%, alpha=5, numer);
          (%o3)                    - 3.130120337415917

 -- Função: quad_qawf (<f(x)>, <x>, <a>, <omega>, <trig>, <epsabs>,
          <limit>, <maxp1>, <limlst>)
 -- Função: quad_qawf (<f>, <x>, <a>, <omega>, <trig>, <epsabs>,
          <limit>, <maxp1>, <limlst>)

     Calcula uma transformação de cosseno de Fourier ou de um seno de
     Fourier sobre um intervalo semi-finito.  usando a função QAWF do
     pacote Quadpack.  A mesma aproxima como em 'quad_qawo' quando
     aplicada sobre intervalos finitos sucessivos, e aceleração de
     convergência por meio d algorítimo de Epsilon (Wynn, 1956) aplicado
     a séries de contribuições de integrais.

     'quad_qawf' calcula a integral

     integrate (f(x)*w(x), x, a, inf)

     A função peso w é selecionada por <trig>:

     'cos'
          w(x) = cos (omega x)
     'sin'
          w(x) = sin (omega x)

     O integrando pode ser especidficado como o nome de uma função
     Maxima ou uma função Lisp ou um operador, uma expressão lambda do
     Maxima, ou uma expressão geral do Maxima.

     Os argumentos opcionais são:

     'epsabs'
          Erro absoluto de aproximação desejado.  Padrão é 1d-10.
     'limit'
          Tamanho de array interno de trabalho.  (<limit> - <limlst>)/2
          é o maximo número de subintervalos para usar.  O Padrão é 200.
     'maxp1'
          O número máximo dos momentos de Chebyshev.  Deve ser maior que
          0.  O padrão é 100.
     'limlst'
          Limite superior sobre número de ciclos.  Deve ser maior ou
          igual a 3.  O padrão é 10.

     <epsabs> e <limit> são o erro relativo desejado e o número maximo
     de subintervalos, respectivamente.  <epsrel> padrão para 1e-8 e
     <limit> é 200.

     'quad_qawf' retorna uma lista de quatro elementos:

        * uma aproximação para a integral,
        * o erro absoluto estimado da aproximação,
        * o número de avaliações do integrando,
        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

     '0'
          nenhum problema foi encontrado;
     '1'
          muitos subintervalos foram concluídos;
     '2'
          erro excessivo é detectado;
     '3'
          ocorreu um comportamento excessivamente ruim do integrando;
     '6'
          se a entrada é invalida.

     Exemplos:

          (%i1) quad_qawf (exp(-x^2), x, 0, 1, 'cos);
          (%o1)   [.6901942235215714, 2.84846300257552E-11, 215, 0]
          (%i2) integrate (exp(-x^2)*cos(x), x, 0, inf);
                                    - 1/4
                                  %e      sqrt(%pi)
          (%o2)                   -----------------
                                          2
          (%i3) ev (%, numer);
          (%o3)                   .6901942235215714

 -- Função: quad_qawo (<f(x)>, <x>, <a>, <b>, <omega>, <trig>, <epsabs>,
          <limite>, <maxp1>, <limlst>)
 -- Função: quad_qawo (<f>, <x>, <a>, <b>, <omega>, <trig>, <epsabs>,
          <limite>, <maxp1>, <limlst>)

     Integração de cos(omega x) f(x) ou sin(omega x) f(x) sobre um
     intervalo finito, onde omega é uma constante.  A componente de
     avaliação da regra é baseada na técnica modificada de
     Clenshaw-Curtis.  'quad_qawo' aplica subdivisão adaptativa com
     extrapolação, similar a 'quad_qags'.

     'quad_qawo' calcula a integral usando a rotina Quadpack QAWO:

     integrate (f(x)*w(x), x, a, b)

     A função peso w é selecionada por <trig>:

     'cos'
          w(x) = cos (omega x)
     'sin'
          w(x) = sin (omega x)

     O integrando pode ser especidficado como o nome de uma função
     Maxima ou uma função Lisp ou um operador, uma expressão lambda do
     Maxima, ou uma expressão geral do Maxima.

     Os argumentos opcionais são:

     'epsabs'
          Erro absoluto desejado de aproximação.  O Padrão é 1d-10.
     'limite'
          Tamanho do array interno de trabalho.  (<limite> - <limlst>)/2
          é o número máximo de subintervalos a serem usados.  Default é
          200.
     'maxp1'
          Número máximo dos momentos de Chebyshev.  Deve ser maior que
          0.  O padrão é 100.
     'limlst'
          Limite superior sobre o número de ciclos.  Deve ser maior que
          ou igual a 3.  O padrão é 10.

     <epsabs> e <limite> são o erro relativo desejado e o número máximo
     de subintervalos, respectivamente.  <epsrel> o padrão é 1e-8 e
     <limite> é 200.

     'quad_qawo' retorna uma lista de quatro elementos:

        * uma aproximação para a integral,
        * o erro absoluto estimado da aproximação,
        * o número de avaliações do integrando,
        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

     '0'
          nenhum problema foi encontrado;
     '1'
          muitos subintervalos foram concluídos;
     '2'
          erro excessivo é detectado;
     '3'
          comportamento extremamente ruim do integrando;
     '6'
          se a entrada é inválida.

     Exemplos:

          (%i1) quad_qawo (x^(-1/2)*exp(-2^(-2)*x), x, 1d-8, 20*2^2, 1, cos);
          (%o1)     [1.376043389877692, 4.72710759424899E-11, 765, 0]
          (%i2) rectform (integrate (x^(-1/2)*exp(-2^(-alpha)*x) * cos(x), x, 0, inf));
                             alpha/2 - 1/2            2 alpha
                  sqrt(%pi) 2              sqrt(sqrt(2        + 1) + 1)
          (%o2)   -----------------------------------------------------
                                         2 alpha
                                   sqrt(2        + 1)
          (%i3) ev (%, alpha=2, numer);
          (%o3)                     1.376043390090716

 -- Função: quad_qaws (<f(x)>, <x>, <a>, <b>, <alpha>, <beta>, <wfun>,
          <epsabs>, <limite>)
 -- Função: quad_qaws (<f>, <x>, <a>, <b>, <alpha>, <beta>, <wfun>,
          <epsabs>, <limite>)

     Integração de w(x) f(x) sobre um intervalo finito, onde w(x) é uma
     certa função algébrica ou logarítmica.  Uma estratégia de
     subdivisão globalmente adaptativa é aplicada, com integração
     modificada de Clenshaw-Curtis sobre os subintervalos que possuírem
     os pontos finais dos intervalos de integração.

     'quad_qaws' calcula a integral usando a rotina Quadpack QAWS:

     integrate (f(x)*w(x), x, a, b)

     A função peso w é selecionada por <wfun>:

     '1'
          w(x) = (x - a)^alpha (b - x)^beta
     '2'
          w(x) = (x - a)^alpha (b - x)^beta log(x - a)
     '3'
          w(x) = (x - a)^alpha (b - x)^beta log(b - x)
     '4'
          w(x) = (x - a)^alpha (b - x)^beta log(x - a) log(b - x)

     O integrando pode ser especidficado como o nome de uma função
     Maxima ou uma função Lisp ou um operador, uma expressão lambda do
     Maxima, ou uma expressão geral do Maxima.

     O argumentos opcionais são:

     'epsabs'
          Erro absoluto desejado de aproximação.  O padrão é 1d-10.
     'limite'
          Tamanho do array interno de trabalho.  (<limite> - <limlst>)/2
          é o número máximo de subintervalos para usar.  O padrão é 200.

     <epsabs> e <limit> são o erro relativo desejado e o número máximo
     de subintervalos, respectivamente.  <epsrel> o padrão é 1e-8 e
     <limite> é 200.

     'quad_qaws' retorna uma lista de quatro elementos:

        * uma aproximação para a integral,
        * o erro absoluto estimado da aproximação,
        * o número de avaliações do integrando,
        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

     '0'
          nenhum problema foi encontrado;
     '1'
          muitos subintervalos foram concluídos;
     '2'
          erro excessivo é detectado;
     '3'
          ocorreu um comportamento excessivamente ruim do integrando;
     '6'
          se a entrada é invalida.

     Exemplos:

          (%i1) quad_qaws (1/(x+1+2^(-4)), x, -1, 1, -0.5, -0.5, 1);
          (%o1)     [8.750097361672832, 1.24321522715422E-10, 170, 0]
          (%i2) integrate ((1-x*x)^(-1/2)/(x+1+2^(-alpha)), x, -1, 1);
                 alpha
          Is  4 2      - 1  positive, negative, or zero?

          pos;
                                    alpha         alpha
                             2 %pi 2      sqrt(2 2      + 1)
          (%o2)              -------------------------------
                                         alpha
                                      4 2      + 2
          (%i3) ev (%, alpha=4, numer);
          (%o3)                     8.750097361672829


File: maxima.info,  Node: Equações,  Next: Equações Diferenciais,  Prev: Integração,  Up: Top

21 Equações
***********

* Menu:

* Funções e Variáveis Definidas para Equações::   


File: maxima.info,  Node: Funções e Variáveis Definidas para Equações,  Prev: Equações,  Up: Equações

21.1 Funções e Variáveis Definidas para Equações
================================================

 -- Variável: %rnum_list
     Valor padrão: '[]'

     '%rnum_list' é a lista de variáveis introduzidas em soluções por
     'algsys'.  '%r' variáveis São adicionadas a '%rnum_list' na ordem
     em que forem criadas.  Isso é conveniente para fazer substituições
     dentro da solução mais tarde.  É recomendado usar essa lista em
     lugar de fazer 'concat ('%r, j)'.

 -- Variável: algexact
     Valor padrão: 'false'

     'algexact' afeta o comportamento de 'algsys' como segue:

     Se 'algexact' é 'true', 'algsys' sempre chama 'solve' e então usa
     'realroots' sobre falhas de 'solve'.

     Se 'algexact' é 'false', 'solve' é chamada somente se o eliminante
     não for de uma variável, ou se for uma quadrática ou uma
     biquadrada.

     Dessa forma 'algexact: true' não garante somente soluções exatas,
     apenas que 'algsys' tentará primeiro pegar soluções exatas, e
     somente retorna aproximações quando tudo mais falha.

 -- Função: algsys ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
 -- Função: algsys ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Resolve polinômios simultâneos <expr_1>, ..., <expr_m> ou equações
     polinômiais <eqn_1>, ..., <eqn_m> para as variáveis <x_1>, ...,
     <x_n>.  Uma expressão <expr> é equivalente a uma equação '<expr> =
     0'.  Pode existir mais equações que variáveis ou vice-versa.

     'algsys' retorna uma lista de soluções, com cada solução dada com
     uma lista de valores de estado das equações das variáveis <x_1>,
     ..., <x_n> que satisfazem o sistema de equações.  Se 'algsys' não
     pode achar uma solução, uma lista vazia '[]' é retornada.

     Os símbolos '%r1', '%r2', ..., são introduzidos tantos quantos
     forem necessários para representar parâmetros arbitrários na
     solução; essas variáveis são também anexadas à lista '%rnum_list'.

     O método usado é o seguinte:

     (1) Primeiro as equações são fatoradas e quebradas em subsistemas.

     (2) Para cada subsistema <S_i>, uma equação <E> e uma variável <x>
     são selecionados.  A variável é escolhida para ter o menor grau não
     zero.  Então a resultante de <E> e <E_j> em relação a <x> é
     calculada para cada um das equações restantes <E_j> nos subsistemas
     <S_i>.  Isso retorna um novo subsistema <S_i'> em umas poucas
     variáveis, como <x> tenha sido eliminada.  O processo agora retorna
     ao passo (1).

     (3) Eventualmente, um subsistema consistindo de uma equação simples
     é obtido.  Se a equação é de várias variáveis e aproximações na
     forma de números em ponto flutuante nã tenham sido introduzidas,
     então 'solve' é chamada para achar uma solução exata.

     Em alguns casos, 'solve' não está habilitada a achar uma solução,
     ou se isso é feito a solução pode ser uma expressão expressão muito
     larga.

     Se a equação é de uma única variável e é ou linear, ou quadrática,
     ou biquadrada, então novamente 'solve' é chamada se aproximações
     não tiverem sido introduzidas.  Se aproximações tiverem sido
     introduzidas ou a equação não é de uma única variável e nem tão
     pouco linear, quadratica, ou biquadrada, então o comutador
     'realonly' é 'true', A função 'realroots' é chamada para achar o
     valor real das soluções.  Se 'realonly' é 'false', então 'allroots'
     é chamada a qual procura por soluções reais e complexas.

     Se 'algsys' produz uma solução que tem poucos digitos
     significativos que o requerido, o usuário pode escolher o valor de
     'algepsilon' para um valor maior.

     Se 'algexact' é escolhido para 'true', 'solve' será sempre chamada.

     (4) Finalmente, as soluções obtidas no passo (3) são substituídas
     dentro dos níveis prévios e o processo de solução retorna para (1).

     Quando 'algsys' encontrar uma equação de várias variáveis que
     contém aproximações em ponto flutuante (usualmente devido a suas
     falhas em achar soluções exatas por um estágio mais fácil), então
     não tentará aplicar métodos exatos para tais equações e em lugar
     disso imprime a mensagem: "'algsys' cannot solve - system too
     complicated."

     Interações com 'radcan' podem produzir expressões largas ou
     complicadas.  Naquele caso, pode ser possível isolar partes do
     resultado com 'pickapart' ou 'reveal'.

     Ocasionalmente, 'radcan' pode introduzir uma unidade imaginária
     '%i' dentro de uma solução que é atualmente avaliada como real.

     Exemplos:

     ++
          (%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
          (%o1)              2 (1 - a1) x - 2 a2 (x - 1)
          (%i2) e2: a2 - a1;
          (%o2)                        a2 - a1
          (%i3) e3: a1*(-y - x^2 + 1);
                                             2
          (%o3)                   a1 (- y - x  + 1)
          (%i4) e4: a2*(y - (x - 1)^2);
                                                 2
          (%o4)                   a2 (y - (x - 1) )
          (%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
          (%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0],

                                            [x = 1, y = 0, a1 = 1, a2 = 1]]
          (%i6) e1: x^2 - y^2;
                                        2    2
          (%o6)                        x  - y
          (%i7) e2: -1 - y + 2*y^2 - x + x^2;
                                   2        2
          (%o7)                 2 y  - y + x  - x - 1
          (%i8) algsys ([e1, e2], [x, y]);
                           1            1
          (%o8) [[x = - -------, y = -------],
                        sqrt(3)      sqrt(3)

                  1              1             1        1
          [x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
               sqrt(3)        sqrt(3)          3        3

 -- Função: allroots (<expr>)
 -- Função: allroots (<eqn>)
     Calcula aproximações numéricas de raízes reais e complexas do
     polinômio <expr> ou equação polinômial <eqn> de uma variável.

     O sinalizador 'polyfactor' quando 'true' faz com que 'allroots'
     fatore o polinômio sobre os números reais se o polinômio for real,
     ou sobre os números complexos, se o polinômio for complexo.

     'allroots' pode retornar resultados imprecisos no caso de multiplas
     raízes.  Se o polinômio for real, 'allroots (%i*<p>)') pode
     retornar aproximações mais precisas que 'allroots (<p>)', como
     'allroots' invoca um algorítmo diferente naquele caso.

     'allroots' rejeita não-polinômios.  Isso requer que o numerador
     após a classificação ('rat''ing) poderá ser um polinômio, e isso
     requer que o denominador seja quando muito um número complexo.  Com
     um resultado disso 'allroots' irá sempre retornar uma expressão
     equivalente (mas fatorada), se 'polyfactor' for 'true'.

     Para polinômios complexos um algorítmo por Jenkins e Traub é usado
     (Algorithm 419, Comm.  ACM, vol.  15, (1972), p.  97).  Para
     polinômios reais o algorítmo usado é devido a Jenkins (Algorithm
     493, ACM TOMS, vol.  1, (1975), p.178).

     Exemplos:

          (%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                                      3          5
          (%o1)              (2 x + 1)  = 13.5 (x  + 1)
          (%i2) soln: allroots (eqn);
          (%o2) [x = .8296749902129361, x = - 1.015755543828121,

          x = .9659625152196369 %i - .4069597231924075,

          x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
          (%i3) for e in soln
                  do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                                - 3.5527136788005E-15

                               - 5.32907051820075E-15

                   4.44089209850063E-15 %i - 4.88498130835069E-15

                  - 4.44089209850063E-15 %i - 4.88498130835069E-15

                                 3.5527136788005E-15

          (%o3)                         done
          (%i4) polyfactor: true$
          (%i5) allroots (eqn);
          (%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                                     2
           (x + 1.015755543828121) (x  + .8139194463848151 x

           + 1.098699797110288)

 -- Variável: backsubst
     Valor padrão: 'true'

     Quando 'backsubst' é 'false', evita substituições em expressões
     anteriores após as equações terem sido triangularizadas.  Isso pode
     ser de grande ajuda em problemas muito grandes onde substituição em
     expressões anteriores pode vir a causar a geração de expressões
     extremamente largas.

 -- Variável: breakup
     Valor padrão: 'true'

     Quando 'breakup' é 'true', 'solve' expressa soluções de equações
     cúbicas e quárticas em termos de subexpressões comuns, que são
     atribuídas a rótulos de expressões intermediárias ('%t1', '%t2',
     etc.).  De outra forma, subexpressões comuns não são identificadas.

     'breakup: true' tem efeito somente quando 'programmode' é 'false'.

     Exemplos:

          (%i1) programmode: false$
          (%i2) breakup: true$
          (%i3) solve (x^3 + x^2 - 1);

                                  sqrt(23)    25 1/3
          (%t3)                  (--------- + --)
                                  6 sqrt(3)   54
          Solution:

                                                sqrt(3) %i   1
                                                ---------- - -
                          sqrt(3) %i   1            2        2   1
          (%t4)    x = (- ---------- - -) %t3 + -------------- - -
                              2        2            9 %t3        3

                                                sqrt(3) %i   1
                                              - ---------- - -
                        sqrt(3) %i   1              2        2   1
          (%t5)    x = (---------- - -) %t3 + ---------------- - -
                            2        2             9 %t3         3

                                             1     1
          (%t6)                  x = %t3 + ----- - -
                                           9 %t3   3
          (%o6)                    [%t4, %t5, %t6]
          (%i6) breakup: false$
          (%i7) solve (x^3 + x^2 - 1);
          Solution:

                       sqrt(3) %i   1
                       ---------- - -
                           2        2        sqrt(23)    25 1/3
          (%t7) x = --------------------- + (--------- + --)
                       sqrt(23)    25 1/3    6 sqrt(3)   54
                    9 (--------- + --)
                       6 sqrt(3)   54

                                                        sqrt(3) %i   1    1
                                                     (- ---------- - -) - -
                                                            2        2    3

                     sqrt(23)    25 1/3  sqrt(3) %i   1
          (%t8) x = (--------- + --)    (---------- - -)
                     6 sqrt(3)   54          2        2

                                                      sqrt(3) %i   1
                                                    - ---------- - -
                                                          2        2      1
                                                + --------------------- - -
                                                     sqrt(23)    25 1/3   3
                                                  9 (--------- + --)
                                                     6 sqrt(3)   54

                      sqrt(23)    25 1/3             1             1
          (%t9)  x = (--------- + --)    + --------------------- - -
                      6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                           9 (--------- + --)
                                              6 sqrt(3)   54
          (%o9)                    [%t7, %t8, %t9]

 -- Função: dimension (<eqn>)
 -- Função: dimension (<eqn_1>, ..., <eqn_n>)
     'dimen' é um pacote de análise dimensional.  'load ("dimen")' chama
     esse pacote.  'demo ("dimen")' mostra uma cura demostração.

 -- Variável: dispflag
     Valor padrão: 'true'

     Se escolhida para 'false' dentro de um 'block' inibirá a
     visualização da saída gerada pelas funções solve chamadas de dentro
     de 'block'.  Terminando 'block' com um sinal de dolar, $, escolhe
     'dispflag' para 'false'.

 -- Função: funcsolve (<eqn>, <g>(<t>))
     Retorna '[<g>(<t>) = ...]' ou '[]', dependendo de existir ou não
     uma função racional '<g>(<t>)' satisfazendo <eqn>, que deve ser de
     primeira ordem, polinômio linear em (para esse caso) '<g>(<t>)' e
     '<g>(<t>+1)'

          (%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1) = (n - 1)/(n + 2);
                                      (n + 3) f(n + 1)   n - 1
          (%o1)        (n + 1) f(n) - ---------------- = -----
                                           n + 1         n + 2
          (%i2) funcsolve (eqn, f(n));

          Equações dependentes eliminadas:  (4 3)
                                             n
          (%o2)                f(n) = ---------------
                                      (n + 1) (n + 2)

     Atenção: essa é uma implementação muito rudimentar - muitas
     verificações de segurança e obviamente generalizações estão
     ausêntes.

 -- Variável: globalsolve
     Valor padrão: 'false'

     When 'globalsolve' for 'true', variáveis para as quais as equações
     são resolvidas são atribuidas aos valores da solução encontrados
     por 'linsolve', e por 'solve' quando resolvendo duas ou mais
     equações lineares.

     Quando 'globalsolve' for 'false', soluções encontradas por
     'linsolve' e por 'solve' quando resolvendo duas ou mais equações
     lineares são espressas como equações, e as variáveis para as quais
     a equação foi resolvida não são atribuidas.

     Quando resolvendo qualquer coisa outra que não duas equações
     lineares ou mais, 'solve' ignora 'globalsolve'.  Outras funções que
     resolvem equações (e.g., 'algsys') sempre ignoram 'globalsolve'.

     Exemplos:

          (%i1) globalsolve: true$
          (%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t2)                        x : --
                                           7

                                             1
          (%t3)                        y : - -
                                             7
          (%o3)                     [[%t2, %t3]]
          (%i3) x;
                                         17
          (%o3)                          --
                                         7
          (%i4) y;
                                           1
          (%o4)                          - -
                                           7
          (%i5) globalsolve: false$
          (%i6) kill (x, y)$
          (%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t7)                        x = --
                                           7

                                             1
          (%t8)                        y = - -
                                             7
          (%o8)                     [[%t7, %t8]]
          (%i8) x;
          (%o8)                           x
          (%i9) y;
          (%o9)                           y

 -- Função: ieqn (<ie>, <unk>, <tech>, <n>, <guess>)
     'inteqn' é um pacote para resolver equações com integrais.  'load
     ("inteqn")' carrega esse pacote.

     <ie> é a equação integral; <unk> é a função desconhecida; <tech> é
     a técnica a ser tentada nesses dados acima (<tech> = 'first'
     significa: tente a primeira técnica que achar uma solução; <tech> =
     'all' significa: tente todas a técnicas aplicáveis); <n> é o número
     máximo de termos a serem usados de 'taylor', 'neumann',
     'firstkindseries', ou 'fredseries' (isso é também o número máximo
     de ciclos de recurssão para o método de diferenciação); <guess> é o
     inicial suposto para 'neumann' ou 'firstkindseries'.

     Valores padrão do segundo até o quinto parâmetro são:

     <unk>: '<p>(<x>)', onde <p> é a primeira função encontrada em um
     integrando que é desconhecida para Maxima e <x> é a variável que
     ocorre como um argumento para a primeira ocorrência de <p> achada
     fora de uma integral no caso de equações 'secondkind' , ou é
     somente outra variável ao lado da variável de integração em
     equações 'firstkind'.  Se uma tentativa de procurar por <x> falha,
     o usuário será perguntado para suprir a variável independente.

     tech: 'first'

     n: 1

     guess: 'none' o que fará com que 'neumann' e 'firstkindseries' use
     '<f>(<x>)' como uma suposição inicial.

 -- Variável de opção: ieqnprint
     Valor padrão: 'true'

     'ieqnprint' governa o comportamento do resultado retornado pelo
     comando 'ieqn'.  Quando 'ieqnprint' é 'false', as listas retornadas
     pela função 'ieqn' são da forma

     [<solução>, <tecnica usada>, <nterms>, <sinalizador>]

     onde <sinalizador> é retirado se a solução for exata.

     De outra forma, isso é a palavra 'approximate' ou 'incomplete'
     correspondendo à forma inexata ou forma aberta de solução,
     respectivamente.  Se um método de série foi usado, <nterms> fornece
     o número de termos usados (que poderá ser menor que os n dados para
     'ieqn' se ocorrer um erro evita a geração de termos adicionais).

 -- Função: lhs (<expr>)
     Retorna o lado esquerdo (isto é, o primeiro argumento) da expressão
     <expr>, quando o operador de <expr> for um dos operadores
     relacionais '< <= = # equal notequal >= >', um dos operadores de
     atribuição ':= ::= : ::', ou um operadro infixo definido pelo
     usuário, como declarado por meio de 'infix'.

     Quando <expr> for um átomo ou seu operador for alguma coisa que não
     esses listados acima, 'lhs' retorna <expr>.

     Veja também 'rhs'.

     Exemplos:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [lhs (aa < bb), lhs (aa <= bb), lhs (aa >= bb), lhs (aa > bb)];
          (%o4)                   [aa, aa, aa, aa]
          (%i5) [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)), lhs (notequal (aa, bb))];
          (%o5)                   [aa, aa, aa, aa]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
          (%o10)               [foo(x), bar(y), x, x]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) lhs (aa ][ bb);
          (%o12)                         aa

 -- Função: linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
     Resolve a lista de equações lineares simultâneas para a lista de
     variáveis.  As expressões devem ser cada uma polinômios nas
     variáveis e podem ser equações.

     Quando 'globalsolve' é 'true' então variáveis que foram resolvidas
     serão escolhidas para a solução do conjunto de equações
     simultâneas.

     Quando 'backsubst' é 'false', 'linsolve' não realiza substituição
     em equações anteriores após as equações terem sido
     triangularizadas.  Isso pode ser necessário em problemas muito
     grandes onde substituição em equações anteriores poderá causar a
     geração de expressões extremamente largas.

     Quando 'linsolve_params' for 'true', 'linsolve' também gera
     símbolos '%r' usados para representar parâmetros arbitrários
     descritos no manual sob 'algsys'.  De outra forma, 'linsolve'
     resolve um menor-determinado sistema de equações com algumas
     variáveis expressas em termos de outras.

     Quando 'programmode' for 'false', 'linsolve' mostra a solução com
     expressões intermediárias com rótulos ('%t'), e retorna a lista de
     rótulos.

          (%i1) e1: x + z = y;
          (%o1)                       z + x = y
          (%i2) e2: 2*a*x - y = 2*a^2;
                                                 2
          (%o2)                   2 a x - y = 2 a
          (%i3) e3: y - 2*z = 2;
          (%o3)                      y - 2 z = 2
          (%i4) [globalsolve: false, programmode: true];
          (%o4)                     [false, true]
          (%i5) linsolve ([e1, e2, e3], [x, y, z]);
          (%o5)            [x = a + 1, y = 2 a, z = a - 1]
          (%i6) [globalsolve: false, programmode: false];
          (%o6)                    [false, false]
          (%i7) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t7)                       z = a - 1

          (%t8)                        y = 2 a

          (%t9)                       x = a + 1
          (%o9)                    [%t7, %t8, %t9]
          (%i9) ''%;
          (%o9)            [z = a - 1, y = 2 a, x = a + 1]
          (%i10) [globalsolve: true, programmode: false];
          (%o10)                    [true, false]
          (%i11) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t11)                      z : a - 1

          (%t12)                       y : 2 a

          (%t13)                      x : a + 1
          (%o13)                 [%t11, %t12, %t13]
          (%i13) ''%;
          (%o13)           [z : a - 1, y : 2 a, x : a + 1]
          (%i14) [x, y, z];
          (%o14)                 [a + 1, 2 a, a - 1]
          (%i15) [globalsolve: true, programmode: true];
          (%o15)                    [true, true]
          (%i16) linsolve ([e1, e2, e3], '[x, y, z]);
          (%o16)           [x : a + 1, y : 2 a, z : a - 1]
          (%i17) [x, y, z];
          (%o17)                 [a + 1, 2 a, a - 1]

 -- Variável: linsolvewarn
     Valor padrão: 'true'

     Quando 'linsolvewarn' é 'true', 'linsolve' imprime uma mensagem
     "Dependent equações eliminated".

 -- Variável: linsolve_params
     Valor padrão: 'true'

     Quando 'linsolve_params' é 'true', 'linsolve' também gera os
     símbolos '%r' usados para representar parâmetros arbitrários
     descritos no manual sob 'algsys'.  De outra forma, 'linsolve'
     resolve um menor-determinado sistema de equações com algumas
     variáveis expressas em termos e outras.

 -- Variável: multiplicities
     Valor padrão: 'not_set_yet'

     'multiplicities' é escolhida para uma lista de multiplicidades das
     soluções individuais retornadas por 'solve' ou 'realroots'.

 -- Função: nroots (<p>, <low>, <high>)
     Retorna o número de raízes reais do polinômio real de uma única
     variável <p> no intervalo semi-aberto '(<low>, <high>]'.  Uma
     extremidade do intervalo podem ser 'minf' ou 'inf'.  infinito e
     mais infinito.

     'nroots' usa o método das sequüências de Sturm.

          (%i1) p: x^10 - 2*x^4 + 1/2$
          (%i2) nroots (p, -6, 9.1);
          (%o2)                           4

 -- Função: nthroot (<p>, <n>)
     Onde p é um polinômio com coeficientes inteiros e n é um inteiro
     positivo retorna q, um polinômio sobre os inteiros, tal que q^n=p
     ou imprime uma mensagem de erro indicando que p não é uma potência
     n-ésima perfeita.  Essa rotina é mais rápida que 'factor' ou mesmo
     'sqfr'.

 -- Variável: programmode
     Valor padrão: 'true'

     Quando 'programmode' é 'true', 'solve', 'realroots', 'allroots', e
     'linsolve' retornam soluções como elementos em uma lista.  (Exceto
     quando 'backsubst' é escolhido para 'false', nesse caso
     'programmode: false' é assumido.)

     Quando 'programmode' é 'false', 'solve', etc.  cria rótulos de
     expressões intermediárias '%t1', 't2', etc., e atribui as soluções
     para eles.

 -- Variável: realonly
     Valor padrão: 'false'

     Quando 'realonly' é 'true', 'algsys' retorna somente aquelas
     soluções que estão livres de '%i'.

 -- Função: realroots (<expr>, <bound>)
 -- Função: realroots (<eqn>, <bound>)
 -- Função: realroots (<expr>)
 -- Função: realroots (<eqn>)
     Calcula aproximações racionais das raízes reais da expressão
     polinomial <expr> ou da equação polinomial <eqn> de uma variável,
     dentro de uma tolerância de <bound>.  coeficientes de <expr> ou de
     <eqn> devem ser números literais; constantes símbolo tais como
     '%pi' são rejeitadas.

     'realroots' atribui as multiplicidades das raízes que encontrar
     para a variável global 'multiplicities'.

     'realroots' constrói uma seqüência de Sturm para delimitar cada
     raíz, e então palica a bisecção para redefinir as aproximações.
     Todos os coeficientes são convertidos para os equivalentes
     racionais antes da busca por raízes, e cálculos são realizados por
     meio de aritmética racional exata.  Mesmo se alguns coeficientes
     forem números em ponto flutuante, os resultados são racionais (a
     menos que forçados a números em ponto flutuante por 'float' ou por
     'numer' flags).

     Quando <bound> for menor que 1, todas as raízes inteiras são
     encontradas exatamente.  Quando <bound> não for especificado, será
     assumido como sendo igual à variável globa 'rootsepsilon'.

     Quando a varável global 'programmode' for 'true', 'realroots'
     retorna uma lista da forma '[x = <x_1>, x = <x_2>, ...]'.  Quando
     'programmode' for 'false', 'realroots' cria rótulos de expressões
     intermediárias '%t1', '%t2', ..., atribui os resultados a eles, e
     retorna a lista de rótulos.

     Exemplos:

          (%i1) realroots (-1 - x + x^5, 5e-6);
                                         612003
          (%o1)                     [x = ------]
                                         524288
          (%i2) ev (%[1], float);
          (%o2)                 x = 1.167303085327148
          (%i3) ev (-1 - x + x^5, %);
          (%o3)                - 7.396496210176905E-6

          (%i1) realroots (expand ((1 - x)^5 * (2 - x)^3 * (3 - x)), 1e-20);
          (%o1)                 [x = 1, x = 2, x = 3]
          (%i2) multiplicities;
          (%o2)                       [5, 3, 1]

 -- Função: rhs (<expr>)
     Retorna o lado direito (isto é, o segundo argumento) da expressão
     <expr>, quando o operador de <expr> for um dos operadores
     relacionais '< <= = # equal notequal >= >', um dos operadores de
     atribuição ':= ::= : ::', ou um operador binário infixo definido
     pelo usuário, como declarado por meio de 'infix'.

     Quando <expr> for um étomo ou seu operadro for alguma coisa que não
     esses listados acima, 'rhs' retorna 0.

     Veja também 'lhs'.

     Exemplos:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [rhs (aa < bb), rhs (aa <= bb), rhs (aa >= bb), rhs (aa > bb)];
          (%o4)                   [bb, bb, bb, bb]
          (%i5) [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)), rhs (notequal (aa, bb))];
          (%o5)                   [bb, bb, bb, bb]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
          (%o10)                  [2 x, 3 y, y, y]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) rhs (aa ][ bb);
          (%o12)                         bb

 -- Variável de opção: rootsconmode
     Valor padrão: 'true'

     'rootsconmode' governa o comportamento do comando 'rootscontract'.
     Veja 'rootscontract' para detalhes.

 -- Função: rootscontract (<expr>)
     Converte produtos de raízes em raízes de produtos.  Por exemplo,
     'rootscontract (sqrt(x)*y^(3/2))' retorna 'sqrt(x*y^3)'.

     Quando 'radexpand' é 'true' e 'domain' é 'real', 'rootscontract'
     converte 'abs' em 'sqrt', e.g., 'rootscontract (abs(x)*sqrt(y))'
     retorna 'sqrt(x^2*y)'.

     Existe uma opção 'rootsconmode' afetando 'rootscontract' como
     segue:

          Problem            Value of        Result of applying
                            rootsconmode        rootscontract

          x^(1/2)*y^(3/2)      false          (x*y^3)^(1/2)
          x^(1/2)*y^(1/4)      false          x^(1/2)*y^(1/4)
          x^(1/2)*y^(1/4)      true           (x*y^(1/2))^(1/2)
          x^(1/2)*y^(1/3)      true           x^(1/2)*y^(1/3)
          x^(1/2)*y^(1/4)      all            (x^2*y)^(1/4)
          x^(1/2)*y^(1/3)      all            (x^3*y^2)^(1/6)

     Quando 'rootsconmode' é 'false', 'rootscontract' contrai somente
     como relação a expoentes de número racional cujos denominadores são
     os mesmos.  A chave para os exemplos 'rootsconmode: true' é
     simplesmente que 2 divides 4 mas não divide 3.  'rootsconmode: all'
     envolve pegar o menor multiplo comum dos denominadores dos
     expoentes.

     'rootscontract' usa 'ratsimp' em uma maneira similar a
     'logcontract'.

     Exemplos:

          (%i1) rootsconmode: false$
          (%i2) rootscontract (x^(1/2)*y^(3/2));
                                             3
          (%o2)                      sqrt(x y )
          (%i3) rootscontract (x^(1/2)*y^(1/4));
                                             1/4
          (%o3)                     sqrt(x) y
          (%i4) rootsconmode: true$
          (%i5) rootscontract (x^(1/2)*y^(1/4));
          (%o5)                    sqrt(x sqrt(y))
          (%i6) rootscontract (x^(1/2)*y^(1/3));
                                             1/3
          (%o6)                     sqrt(x) y
          (%i7) rootsconmode: all$
          (%i8) rootscontract (x^(1/2)*y^(1/4));
                                        2   1/4
          (%o8)                       (x  y)
          (%i9) rootscontract (x^(1/2)*y^(1/3));
                                       3  2 1/6
          (%o9)                      (x  y )
          (%i10) rootsconmode: false$
          (%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                              *sqrt(sqrt(1 + x) - sqrt(x)));
          (%o11)                          1
          (%i12) rootsconmode: true$
          (%i13) rootscontract (sqrt(5 + sqrt(5)) - 5^(1/4)*sqrt(1 + sqrt(5)));
          (%o13)                          0

 -- Variável de opção: rootsepsilon
     Valor padrão: 1.0e-7

     'rootsepsilon' é a tolerância que estabelece o intervalo de
     conficência para as raízes achadas pela função 'realroots'.

 -- Função: solve (<expr>, <x>)
 -- Função: solve (<expr>)
 -- Função: solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     Resolve a equação algébrica <expr> para a variável <x> e retorna
     uma lista de equações solução em <x>.  Se <expr> não é uma equação,
     a equação '<expr> = 0' é assumida em seu lugar.  <x> pode ser uma
     função (e.g.  'f(x)'), ou outra expressão não atômica exceto uma
     adição ou um produto.  <x> pode ser omitido se <expr> contém
     somente uma variável.  <expr> pode ser uma expressão racional, e
     pode conter funções trigonométricas, exponenciais, etc.

     O seguinte método é usado:

     Tome <E> sendo a expressão e <X> sendo a variável.  Se <E> é linear
     em <X> então isso é trivialmente resolvido para <X>.  De outra
     forma se <E> é da forma 'A*X^N + B' então o resultado é
     '(-B/A)^1/N)' vezes as 'N''ésimas raízes da unidade.

     Se <E> não é linear em <X> então o máximo divisor comum (mdc) dos
     expoentes de <X> em <E> (digamos <N>) é dividido dentro dos
     expoentes e a multiplicidade das raízes é multiplicada por <N>.
     Então 'solve' é chamada novamente sobre o resultado.  Se <E> for
     dada em fatores então 'solve' é chamada sobre cada um dos fatores.
     Finalmente 'solve' usará as fórmulas quadráticas, cúbicas, ou
     quárticas onde necessário.

     No caso onde <E> for um polinômio em alguma função de variável a
     ser resolvida, digamos 'F(X)', então isso é primeiro resolvida para
     'F(X)' (chama o resultado <C>), então a equação 'F(X)=C' pode ser
     resolvida para <X> fornecendo o inverso da função <F> que é
     conhecida.

     'breakup' se 'false' fará com que 'solve' expresse as soluções de
     equações cúbicas ou quárticas como expressões simples ao invés de
     como feito em cima de várias subexpressões comuns que é o padrão.

     'multiplicities' - será escolhido para uma lista de multiplicidades
     de soluções individuais retornadas por 'solve', 'realroots', ou
     'allroots'.  Tente 'apropos (solve)' para os comutadores que afetam
     'solve'.  'describe' pode então ser usada sobre o nome do comutador
     individual se seu proprósito não é claro.

     'solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])' resolve um
     sistema de equações polinomiais (lineares ou não-lineares)
     simultâneas por chamada a 'linsolve' ou 'algsys' e retorna uma
     lista de listas solução nas variáveis.  No caso de 'linsolve' essa
     lista conterá uma lista simples de soluções.  Isso pega duas listas
     como argumentos.  A primeira lista representa as equações a serem
     resolvidas; a segunda lista é a lista de desconhecidos a ser
     determinada.  Se o número total de variáveis nas equações é igual
     ao número de equações, a segunda lista-argumento pode ser omitida.
     Para sistemas lineares se as dadas equações não são compatíveis, a
     mensagem 'inconsistent' será mostrada (veja o comutador
     'solve_inconsistent_error' ); se não existe solução única, então
     'singular' será mostrado.

     Quando 'programmode' for 'false', 'solve' mostra soluções com
     rótulos de expressões intermediárias ('%t'), e retorna a lista de
     rótulos.

     Quando 'globalsolve' for 'true' e o problema for resolver duas ou
     mais equações lineares, cada variável para a qual a equação for
     resolvida é associada a seu valor na solução das equações.

     Exemplos:
          (%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

          SOLVE is using arc-trig functions to get a solution.
          Some solutions will be lost.
                                      %pi
          (%o1)                  [x = ---, f(x) = 1]
                                       6
          (%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                          log(125)
          (%o2)                   [f(x) = --------]
                                           log(5)
          (%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                                2    2
          (%o3)             [4 x  - y  = 12, x y - x = 2]
          (%i4) solve (%, [x, y]);
          (%o4) [[x = 2, y = 2], [x = .5202594388652008 %i

           - .1331240357358706, y = .0767837852378778

           - 3.608003221870287 %i], [x = - .5202594388652008 %i

           - .1331240357358706, y = 3.608003221870287 %i

           + .0767837852378778], [x = - 1.733751846381093,

          y = - .1535675710019696]]
          (%i5) solve (1 + a*x + x^3, x);
                                                 3
                        sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (%o5) [x = (- ---------- - -) (--------------- - -)
                            2        2      6 sqrt(3)      2

                  sqrt(3) %i   1
                 (---------- - -) a
                      2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                                    3
           sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (---------- - -) (--------------- - -)
               2        2      6 sqrt(3)      2

                   sqrt(3) %i   1
                (- ---------- - -) a
                       2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                   3
           sqrt(4 a  + 27)   1 1/3               a
          (--------------- - -)    - --------------------------]
              6 sqrt(3)      2                  3
                                        sqrt(4 a  + 27)   1 1/3
                                     3 (--------------- - -)
                                           6 sqrt(3)      2
          (%i6) solve (x^3 - 1);
                       sqrt(3) %i - 1        sqrt(3) %i + 1
          (%o6)   [x = --------------, x = - --------------, x = 1]
                             2                     2
          (%i7) solve (x^6 - 1);
                     sqrt(3) %i + 1      sqrt(3) %i - 1
          (%o7) [x = --------------, x = --------------, x = - 1,
                           2                   2

                               sqrt(3) %i + 1        sqrt(3) %i - 1
                         x = - --------------, x = - --------------, x = 1]
                                     2                     2
          (%i8) ev (x^6 - 1, %[1]);
                                                6
                                (sqrt(3) %i + 1)
          (%o8)                 ----------------- - 1
                                       64
          (%i9) expand (%);
          (%o9)                           0
          (%i10) x^2 - 1;
                                        2
          (%o10)                       x  - 1
          (%i11) solve (%, x);
          (%o11)                  [x = - 1, x = 1]
          (%i12) ev (%th(2), %[1]);
          (%o12)                          0

 -- Variável de opção: solvedecomposes
     Valor padrão: 'true'

     Quando 'solvedecomposes' é 'true', 'solve' chama 'polydecomp' se
     perguntado para resolver polinômios.

 -- Variável de opção: solveexplicit
     Valor padrão: 'false'

     Quando 'solveexplicit' é 'true', inibe 'solve' de retornar soluções
     implícitas, isto é, soluções da forma 'F(x) = 0' onde 'F' é alguma
     função.

 -- Variável de opção: solvefactors
     Valor padrão: 'true'

     Quando 'solvefactors' é 'false', 'solve' não tenta fatorar a
     expressão.  O 'false' escolhido pode ser desejado em alguns casos
     onde a fatoração não é necessária.

 -- Variável de opção: solvenullwarn
     Valor padrão: 'true'

     Quando 'solvenullwarn' é 'true', 'solve' imprime uma mensagem de
     alerta se chamada com ou uma lista equação ou uma variável lista
     nula.  Por exemplo, 'solve ([], [])' imprimirá duas mensagens de
     alerta e retorna '[]'.

 -- Variável de opção: solveradcan
     Valor padrão: 'false'

     Quando 'solveradcan' é 'true', 'solve' chama 'radcan' que faz
     'solve' lento mas permitirá certamente que problemas contendo
     exponeniais e logarítmos sejam resolvidos.

 -- Variável de opção: solvetrigwarn
     Valor padrão: 'true'

     Quando 'solvetrigwarn' é 'true', 'solve' pode imprimir uma mensagem
     dizendo que está usando funções trigonométricas inversas para
     resolver a equação, e desse modo perdendo soluções.

 -- Variável de opção: solve_inconsistent_error
     Valor padrão: 'true'

     Quando 'solve_inconsistent_error' for 'true', 'solve' e 'linsolve'
     resultam em erro se as equações a serem resolvidas forem
     inconsistentes.

     Se 'false', 'solve' e 'linsolve' retornam uma lista vazia '[]' se
     as equações forem inconsistentes.

     Exemplo:

          (%i1) solve_inconsistent_error: true$
          (%i2) solve ([a + b = 1, a + b = 2], [a, b]);
          Inconsistent equações:  (2)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i3) solve_inconsistent_error: false$
          (%i4) solve ([a + b = 1, a + b = 2], [a, b]);
          (%o4)                          []


File: maxima.info,  Node: Equações Diferenciais,  Next: Numérico,  Prev: Equações,  Up: Top

22 Equações Diferenciais
************************

* Menu:

* Introdução a Equações Diferenciais::
* Funções e Variáveis Definidas para Equações Diferenciais::
Definições para Equações Diferenciais


File: maxima.info,  Node: Introdução a Equações Diferenciais,  Next: Funções e Variáveis Definidas para Equações Diferenciais,  Prev: Equações Diferenciais,  Up: Equações Diferenciais

22.1 Introdução a Equações Diferenciais
=======================================

Essa seção descreve as funções disponíves no Maxima para obter soluções
analíticas para alguns tipos específicos de equações diferencias de
primeira ordem e de equações diferencias de segunda ordem.  Para obter
uma solução numérica para um sistema de equações diferenciais, veja o
pacote adicional 'dynamics'.  Para representações gráficas em espaço de
fase, veja o pacote adicional 'plotdf'.


File: maxima.info,  Node: Funções e Variáveis Definidas para Equações Diferenciais,  Prev: Introdução a Equações Diferenciais,  Up: Equações Diferenciais

22.2 Funções e Variáveis Definidas para Equações Diferenciais
=============================================================

 -- Função: bc2 (<solução>, <xval1>, <yval1>, <xval2>, <yval2>)
     Resolve o problema do valor limite para equações diferenciais de
     segunda ordem.  Aqui: <solução> é uma solução geral para a equação,
     como encontrado por 'ode2', <xval1> especifica o valor da variável
     independente em um primeiro ponto, na forma '<x> = <x1>', e <yval1>
     fornece o valor da variável dependente naquele ponto, na forma '<y>
     = <y1>'.  As expressões <xval2> e <yval2> fornecem os valores para
     essas variáveis em um segundo ponto, usando a mesma forma.

     Veja 'ode2' para um exemplo de sua utilização.

 -- Função: desolve (<eqn>, <x>)
 -- Função: desolve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     A Função 'dsolve' resolve sistema de equações diferenciais lineares
     ordinárias usando a transformada de Laplace.  Aqui as <eqn>'s são
     equações diferenciais nas variáveis dependentes <x_1>, ..., <x_n>.
     A dependência funcional de <x_1>, ..., <x_n> com relação à variável
     independente, por exemplo <x>, deve ser explicitamente indicada nas
     variáveis e em suas derivadas.  Por exemplo, isso pode não ser
     caminho correto para definir duas equações:

          eqn_1: 'diff(f,x,2) = sin(x) + 'diff(g,x);
          eqn_2: 'diff(f,x) + x^2 - f = 2*'diff(g,x,2);

     O caminho correto pode ser:

          eqn_1: 'diff(f(x),x,2) = sin(x) + 'diff(g(x),x);
          eqn_2: 'diff(f(x),x) + x^2 - f(x) = 2*'diff(g(x),x,2);

     A chamada à função 'desolve' pode então ser
          desolve([eqn_1, eqn_2], [f(x),g(x)]);

     Se condições iniciais em 'x=0' forem conhecidas, elas podem ser
     fornecidas antes chamando 'desolve' através de 'atvalue'.

          (%i1) 'diff(f(x),x)='diff(g(x),x)+sin(x);
                           d           d
          (%o1)            -- (f(x)) = -- (g(x)) + sin(x)
                           dx          dx
          (%i2) 'diff(g(x),x,2)='diff(f(x),x)-cos(x);
                            2
                           d            d
          (%o2)            --- (g(x)) = -- (f(x)) - cos(x)
                             2          dx
                           dx
          (%i3) atvalue('diff(g(x),x),x=0,a);
          (%o3)                           a
          (%i4) atvalue(f(x),x=0,1);
          (%o4)                           1
          (%i5) desolve([%o1,%o2],[f(x),g(x)]);
                            x
          (%o5) [f(x) = a %e  - a + 1, g(x) =

                                                          x
                                             cos(x) + a %e  - a + g(0) - 1]
          (%i6) [%o1,%o2],%o5,diff;
                       x       x      x                x
          (%o6)   [a %e  = a %e , a %e  - cos(x) = a %e  - cos(x)]

     Se 'desolve' não pode obter uma solução, retorna 'false'.

 -- Função: ic1 (<solução>, <xval>, <yval>)
     Resolve problemas de valor inicial para equações diferenciais de
     primeira ordem.  Aqui <solução> é uma solução geral para a equação,
     como encontrado por 'ode2', <xval> fornece um valor inicial para a
     variável independente na forma '<x> = <x0>', e <yval> fornece o
     valor inicial para a variável dependente na forma '<y> = <y0>'.

     Veja 'ode2' para um exemplo de sua utilização.

 -- Função: ic2 (<solução>, <xval>, <yval>, <dval>)
     Resolve problemas de valor inicial para equações diferenciais de
     segunda ordem.  Aqui <solução> é uma solução geral para a equação,
     como encontrada por 'ode2', <xval> fornece o valor inicial para a
     variável independente na forma '<x> = <x0>', <yval> fornece o valor
     inicial da veriável dependente na forma '<y> = <y0>', e <dval>
     fornece o valor inicial para a primeira derivada da variável
     dependente com relação à variável independente, na forma
     'diff(<y>,<x>) = <dy0>' ('diff' não precisa receber apóstrofo para
     evitar avaliação).

     Veja 'ode2' para um exemplo de seu uso.

 -- Função: ode2 (<eqn>, <dvar>, <ivar>)
     A função 'ode2' resolve uma equação diferencial ordinária (EDO) de
     primeira ou de segunda ordem.  'ode2' usa três argumentos: uma EDO
     fornecida por <eqn>, a variável dependente <dvar>, e a variável
     independente <ivar>.  Quando 'ode2' encontra uma solução, 'ode2'
     retorna ou uma solução explícita ou uma sulução implícita para a
     variável dependente.  '%c' é usado para representar a constante de
     integração no caso de equações de primeira ordem, e '%k1' e '%k2'
     as constantes para equações de segunda ordem.  A dependência da
     variável dependente com relação à variável independente não tem que
     ser escrita explicitamente, como no caso de 'desolve', mas a
     variável independente deve sempre ser fornecida como o terceiro
     argumento.

     Se 'ode2' não conseguir obter uma solução por qualquer razaão,
     'ode2' retorna 'false', após talvez imprimir uma mensagem de erro.
     Os métodos implementados para equações de primeira ordem na
     seqüência em que eles foram testados são: linear, separável, exato
     - talvez requerendo um fator de integração, homogêneo, equação de
     Bernoulli, e um método homogêneo generalizado.  Os tipos de equaçõe
     de segunda ordem que podem ser resolvidos são: coeficientes
     constantes, exato, linear homogêneo com coeficientes não constantes
     que podem ser transformados em coeficientes constantes, o tipo de
     equação de Euler também chamado de equação equi-dimensional,
     equações resolvíveis pelo método de variação de parâmetros, e
     equações as quais são livres ou da variável independente ou da
     dependente de modo que elas possam ser reduzidas a duas equações
     lineares de primeira ordem para serem resolvidas seqüêncialmente.

     Na resolução de EDO's pelo Maxima, muitas variáveis são escolhidas
     puramente para propósitos informativos: 'método' denota o método de
     solução usado (e.g., 'linear'), 'intfactor' denota qualquer fator
     de integração usado, 'odeindex' denota o índice para o método de
     Bernoulli ou para o método homogêneo generalizado, e 'yp' denota a
     solução particular para a técnica de variação de parâmetros.

     Com o objetivo de resolver poblemas de valor inicial (PVI) as
     funções 'ic1' e 'ic2' estão disponíveis para equações de primeira e
     de segunda ordem, e para resolver problemas do valor de segunda
     ordem associado (BVP em inglês) a função 'bc2' pode ser usada.

     Exemplo:

          (%i1) x^2*'diff(y,x) + 3*y*x = sin(x)/x;
                                2 dy           sin(x)
          (%o1)                x  -- + 3 x y = ------
                                  dx             x
          (%i2) ode2(%,y,x);
                                       %c - cos(x)
          (%o2)                    y = -----------
                                            3
                                           x
          (%i3) ic1(%o2,x=%pi,y=0);
                                        cos(x) + 1
          (%o3)                   y = - ----------
                                             3
                                            x
          (%i4) 'diff(y,x,2) + y*'diff(y,x)^3 = 0;
                                   2
                                  d y      dy 3
          (%o4)                   --- + y (--)  = 0
                                    2      dx
                                  dx
          (%i5) ode2(%,y,x);
                                3
                               y  + 6 %k1 y
          (%o5)                ------------ = x + %k2
                                    6
          (%i6) ratsimp(ic2(%o5,x=0,y=0,'diff(y,x)=2));
                                       3
                                    2 y  - 3 y
          (%o6)                   - ---------- = x
                                        6
          (%i7) bc2(%o5,x=0,y=1,x=1,y=3);
                                   3
                                  y  - 10 y       3
          (%o7)                   --------- = x - -
                                      6           2


File: maxima.info,  Node: Numérico,  Next: Arrays,  Prev: Equações Diferenciais,  Up: Top

23 Numérico
***********

* Menu:

* Introdução a Numérico::
* Pacotes de Fourier::
* Funções e Variáveis Definidas para Numérico::
* Funções e Variáveis Definidas para Séries de Fourier::


File: maxima.info,  Node: Introdução a Numérico,  Next: Pacotes de Fourier,  Prev: Numérico,  Up: Numérico

23.1 Introdução a Numérico
==========================


File: maxima.info,  Node: Pacotes de Fourier,  Next: Funções e Variáveis Definidas para Numérico,  Prev: Introdução a Numérico,  Up: Numérico

23.2 Pacotes de Fourier
=======================

O pacote 'fft' compreende funções para computação numérica (não
simbólica) das transformações rápidas de Fourier.  'load ("fft")' chama
esse pacote.  Veja 'fft'.

   O pacote 'fourie' compreende funções para computação simbólica de
séries de Fourier.  'load ("fourie")' chama esse pacote.  Existem
funções no pacote 'fourie' para calcular coeficientes da integral de
Fourier e algumas funções para manipulação de expressões.  Veja 'Funções
e Variáveis Definidas para Séries'.


File: maxima.info,  Node: Funções e Variáveis Definidas para Numérico,  Next: Funções e Variáveis Definidas para Séries de Fourier,  Prev: Pacotes de Fourier,  Up: Numérico

23.3 Funções e Variáveis Definidas para Numérico
================================================

 -- Função: polartorect (<magnitude_array>, <phase_array>)

     Traduz valores complexos da forma 'r %e^(%i t)' para a forma 'a + b
     %i'.  'load ("fft")' chama essa função dentro do Maxima.  Veja
     também 'fft'.

     O módulo e a fase, 'r' e 't', São tomados de <magnitude_array> e
     <phase_array>, respectivamente.  Os valores originais de arrays de
     entrada são substituídos pelas partes real e emaginária, 'a' e 'b',
     no retorno.  As saídas são calculadas como

          a: r cos (t)
          b: r sin (t)

     Os arrays de entrada devem ter o mesmo tamanho e ser
     unidimensionais.  O tamanho do array não deve ser uma potência de
     2.

     'polartorect' é a função inversa de 'recttopolar'.

 -- Função: recttopolar (<real_array>, <imaginary_array>)

     Traduz valores complexos da forma 'a + b %i' para a forma 'r %e^(%i
     t)'.  'load ("fft")' chama essa função dentro do Maxima.  Veja
     também 'fft'.

     As partes real e imaginária, 'a' e 'b', são tomadas de <real_array>
     e <imaginary_array>, respectivamente.  Os valores originais dos
     arrays de entrada são substituídos pelo módulo e pelo ângulo, 'r' e
     't', no retorno.  As saídas são calculadas como

          r: sqrt (a^2 + b^2)
          t: atan2 (b, a)

     O ângulo calculado encontra-se no intervalo de '-%pi' a '%pi'.

     Os arrays de entrada devem ter o mesmo tamanho e ser
     unidimensionais.  O tamanho do array não deve ser uma potência de
     2.

     'recttopolar' é a função inversa de 'polartorect'.

 -- Função: ift (<real_array>, <imaginary_array>)

     Transformação rápida inversa discreta de Fourier .  'load ("fft")'
     chama essa função dentro do Maxima.

     'ift' realiza a transformação rápida complexa de Fourier sobre
     arrays em ponto flutuante unidimensionais.  A transformação inversa
     é definida como

          x[j]: sum (y[j] exp (+2 %i %pi j k / n), k, 0, n-1)

     Veja 'fft' para maiores detalhes.

 -- Função: fft (<real_array>, <imaginary_array>)
 -- Função: ift (<real_array>, <imaginary_array>)
 -- Função: recttopolar (<real_array>, <imaginary_array>)
 -- Função: polartorect (<magnitude_array>, <phase_array>)

     Transformação rápidada de Fourier e funções relacionadas.  'load
     ("fft")' chama essas funções dentro do Maxima.

     'fft' e 'ift' realiza transformação rápida complexa de Fourier e a
     transformação inversa, respectivamente, sobre arrays em ponto
     flutuante unidimensionais.  O tamanho de <imaginary_array> deve ser
     igual ao tamanho de <real_array>.

     'fft' e 'ift' operam in-loco.  Isto é, sobre o retorno de 'fft' ou
     de 'ift', O conteúdo original dos arrays de entrada é substituído
     pela saída.  A função 'fillarray' pode fazer uma cópia de um array,
     isso pode ser necessário.

     A transformação discreta de Fourier e sua transformação inversa são
     definidas como segue.  Tome 'x' sendo os dados originais, com

          x[i]: real_array[i] + %i imaginary_array[i]

     Tome 'y' sendo os dados transformados.  A transformação normal e
     sua transformação inversa são

          y[k]: (1/n) sum (x[j] exp (-2 %i %pi j k / n), j, 0, n-1)

          x[j]:       sum (y[j] exp (+2 %i %pi j k / n), k, 0, n-1)

     Arrays adequadas podem ser alocadas pela função 'array'.  Por
     exemplo:

          array (my_array, float, n-1)$

     declara um array unidimensional com n elementos, indexado de 0 a
     n-1 inclusive.  O número de elementos n deve ser igual a 2^m para
     algum m.

     'fft' pode ser aplicada a dados reais (todos os arrays imaginários
     são iguais a zero) para obter coeficientes seno e cosseno.  Após
     chamar 'fft', os coeficientes seno e cosseno, digamos 'a' e 'b',
     podem ser calculados como

          a[0]: real_array[0]
          b[0]: 0

     e

          a[j]: real_array[j] + real_array[n-j]
          b[j]: imaginary_array[j] - imaginary_array[n-j]

     para j variando de 1 a n/2-1, e

          a[n/2]: real_array[n/2]
          b[n/2]: 0

     'recttopolar' traduz valores complexos da forma 'a + b %i' para a
     forma 'r %e^(%i t)'.  Veja 'recttopolar'.

     'polartorect' traduz valores complexos da forma 'r %e^(%i t)' para
     a forma 'a + b %i'.  Veja 'polartorect'.

     'demo ("fft")' exibe uma demonstração do pacote 'fft'.

 -- Variável de opção: fortindent
     Valor padrão: 0

     'fortindent' controla a margem esquerda de indentação de expressões
     mostradas pelo comando 'fortran'.  0 fornece indentação normal
     (i.e., 6 espaços), e valores positivos farão com que expressões
     sejam mostrados mais além para a direita.

 -- Função: fortran (<expr>)
     Mostra <expr> como uma declaração Fortran.  A linha de saída é
     indentada com espaços.  Se a linha for muito longa, 'fortran'
     imprime linhas de continuação.  'fortran' mostra o operador de
     exponenciação '^' como '**', e mostra um número complexo 'a + b %i'
     na forma '(a,b)'.

     <expr> pode ser uma equação.  Nesse caso, 'fortran' mostra uma
     declaração de atribuição, atribuindo o primeiro membro (esquerda)
     da equação ao segundo membro (direita).  Em particular, se o
     primeiro membro <expr> é um nome de uma matriz, então 'fortran'
     mostra uma declaração de atribuição para cada elemento da matriz.

     Se <expr> não for alguma coisa reconhecida por 'fortran', a
     expressão é mostrada no formato 'grind' sem reclamação.  'fortran'
     não conhece listas, arrays ou funções.

     'fortindent' controla o margem esquerda das linhas mostradas.  0 é
     a margem normal (i.e., indentada 6 espaços).  Incrementando
     'fortindent' faz com que expressões sejam mostradas adiante para a
     direita.

     quando 'fortspaces' for 'true', 'fortran' preenche cada linha
     mostrada com espaços em branco até completar 80 columas.

     'fortran' avalia seus argumentos; colocando um apóstrofo em um
     argumento evita avaliação.  'fortran' sempre retorna 'done'.

     Exemplos:

          (%i1) expr: (a + b)^12$
          (%i2) fortran (expr);
                (b+a)**12
          (%o2)                         done
          (%i3) fortran ('x=expr);
                x = (b+a)**12
          (%o3)                         done
          (%i4) fortran ('x=expand (expr));
                x = b**12+12*a*b**11+66*a**2*b**10+220*a**3*b**9+495*a**4*b**8+792
               1   *a**5*b**7+924*a**6*b**6+792*a**7*b**5+495*a**8*b**4+220*a**9*b
               2   **3+66*a**10*b**2+12*a**11*b+a**12
          (%o4)                         done
          (%i5) fortran ('x=7+5*%i);
                x = (7,5)
          (%o5)                         done
          (%i6) fortran ('x=[1,2,3,4]);
                x = [1,2,3,4]
          (%o6)                         done
          (%i7) f(x) := x^2$
          (%i8) fortran (f);
                f
          (%o8)                         done

 -- Variável de opção: fortspaces
     Valor padrão: 'false'

     Quando 'fortspaces' for 'true', 'fortran' preenche cada linha
     mostrada com espaços em branco até completar 80 columas.

 -- Função: horner (<expr>, <x>)
 -- Função: horner (<expr>)
     Retorna uma representação rearranjada de <expr> como na regra de
     Horner, usando <x> como variável principal se isso for
     especificado.  'x' pode ser omitido e nesse caso a variável
     principal da forma de expressão racional canônica de <expr> é
     usada.

     'horner' algumas vezes melhora a estabilidade se 'expr' for ser
     numericamente avaliada.  Isso também é útil se Maxima é usado para
     gerar programas para rodar em Fortran.  Veja também 'stringout'.

          (%i1) expr: 1e-155*x^2 - 5.5*x + 5.2e155;
                                     2
          (%o1)            1.0E-155 x  - 5.5 x + 5.2E+155
          (%i2) expr2: horner (%, x), keepfloat: true;
          (%o2)            (1.0E-155 x - 5.5) x + 5.2E+155
          (%i3) ev (expr, x=1e155);
          Maxima encountered a Lisp error:

           floating point overflow

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i4) ev (expr2, x=1e155);
          (%o4)                       7.0E+154

 -- Função: find_root (<f>(<x>), <x>, <a>, <b>)
 -- Função: find_root (<f>, <a>, <b>)
     Encontra a raíz da função <f> com a variável <x> percorrendo o
     intervalo '[<a>, <b>]'.  A função deve ter um sinal diferente em
     cada ponto final.  Se essa condição não for alcançada, a action of
     the function is governed by 'find_root_error'.  If
     'find_root_error' is 'true' then an error occurs, otherwise the
     value of 'find_root_error' is returned (thus for plotting
     'find_root_error' might be set to 0.0).  De outra forma (dado que
     Maxima pode avaliar o primeiro argumento no intervalo especificado,
     e que o intervalo é contínuo) 'find_root' é garantido vir para cima
     com a raíz (ou um deles se existir mais que uma raíz).  A precisão
     de 'find_root' é governada por 'intpolabs' e 'intpolrel' os quais
     devem ser números em ponto flutuante não negativos.  'find_root'
     encerrará quando o primeiro argumento avaliar para alguma coisa
     menor que ou igual a 'intpolabs' ou se sucessivas aproximações da
     raíz diferirem por não mais que 'intpolrel * <um dos
     aproximandos>'.  O valor padrão de 'intpolabs' e 'intpolrel' são
     0.0 de forma que 'find_root' pega como boa uma resposta como for
     possível com a precisão aritmética simples que tivermos.  O
     primeiro argumento pode ser uma equação.  A ordem dos dois últimos
     argumentos é irrelevante.  Dessa forma

          find_root (sin(x) = x/2, x, %pi, 0.1);

     é equivalente a

          find_root (sin(x) = x/2, x, 0.1, %pi);

     O método usado é uma busca binária no intervalo especificado pelos
     últimos dois argumentos.  Quando o resultado da busca for
     encontrado a função é fechada o suficiente para ser linear, isso
     inicia usando interpolação linear.

     Examples:
          (%i1) f(x) := sin(x) - x/2;
                                                  x
          (%o1)                  f(x) := sin(x) - -
                                                  2
          (%i2) find_root (sin(x) - x/2, x, 0.1, %pi);
          (%o2)                   1.895494267033981
          (%i3) find_root (sin(x) = x/2, x, 0.1, %pi);
          (%o3)                   1.895494267033981
          (%i4) find_root (f(x), x, 0.1, %pi);
          (%o4)                   1.895494267033981
          (%i5) find_root (f, 0.1, %pi);
          (%o5)                   1.895494267033981

 -- Variável de opção: find_root_abs
     Valor padrão: 0.0

     'find_root_abs' é a precisão do comando 'find_root'.  A precisão é
     governada por 'find_root_abs' e 'find_root_rel' que devem ser
     números não negativos em ponto flutuante.  'find_root' terminará
     quando o primeiro argumento avaliar para alguma coisa menor que ou
     igual a 'find_root_abs' ou se sucessivos aproximandos para a raíz
     diferirem por não mais que 'find_root_rel * <um dos aproximandos>'.
     Os valores padrão de 'find_root_abs' e 'find_root_rel' são 0.0 de
     forma que 'find_root' tome como boa uma resposta que for possível
     com a precisão aritmética simples que tivermos.

 -- Variável de opção: find_root_error
     Valor padrão: 'true'

     'find_root_error' governa o comportamento de 'find_root'.  Quando
     'find_root' for chamada, ela determina se a função a ser resolvida
     satisfaz ou não a condição que os valores da função nos pontos
     finais do intervalo de interpolação são opostos em sinal.  Se eles
     forem de sinais opostos, a interpolação prossegue.  Se eles forem
     de mesmo sinal, e 'find_root_error' for 'true', então um erro é
     sinalizado.  Se eles forem de mesmo sinal e 'find_root_error' não
     for 'true', o valor de 'find_root_error' é retornado.  Dessa forma
     para montagem de gráfico, 'find_root_error' pode ser escolhida para
     0.0.

 -- Variável de opção: find_root_rel
     Valor padrão: 0.0

     'find_root_rel' é a precisão do comando 'find_root' e é governada
     por 'find_root_abs' e 'find_root_rel' que devem ser números não
     negativos em ponto flutuante.  'find_root' terminará quando o
     primeiro argumento avaliar para alguma coisa menor que ou igual a
     'find_root_abs' ou se sucessivos aproximandos para a raíz diferirem
     de não mais que 'find_root_rel * <um dos aproximandos>'.  Os
     valores padrão de 'find_root_labs' e 'find_root_rel' é 0.0 de forma
     que 'find_root' toma como boa uma resposta que for possível com a
     precisão aritmética simples que tivermos.

 -- Função: newton (<expr>, <x>, <x_0>, <eps>)
     Retorna uma solução aproximada de '<expr> = 0' através do método de
     Newton, considerando <expr> como sendo uma função de uma variável,
     <x>.  A busca pela solução começa com '<x> = <x_0>' e prossegue até
     'abs(<expr>) < <eps>' (com <expr> avaliada para o valor corrente de
     <x>).

     'newton' permite que variáveis indefinidas apareçam em <expr>,
     contanto que o teste de terminação 'abs(<expr>) < <eps>' avalie
     para 'true' ou 'false'.  Dessa forma não é necessário que <expr>
     avalie para um número.

     'load(newton1)' chama essa função.

     Veja também 'realroots', 'allroots', 'find_root', e 'mnewton'.

     Exemplos:

          (%i1) load (newton1);
          (%o1) /usr/share/maxima/5.10.0cvs/share/numeric/newton1.mac
          (%i2) newton (cos (u), u, 1, 1/100);
          (%o2)                   1.570675277161251
          (%i3) ev (cos (u), u = %);
          (%o3)                 1.2104963335033528E-4
          (%i4) assume (a > 0);
          (%o4)                        [a > 0]
          (%i5) newton (x^2 - a^2, x, a/2, a^2/100);
          (%o5)                  1.00030487804878 a
          (%i6) ev (x^2 - a^2, x = %);
                                                     2
          (%o6)                6.098490481853958E-4 a


File: maxima.info,  Node: Funções e Variáveis Definidas para Séries de Fourier,  Prev: Funções e Variáveis Definidas para Numérico,  Up: Numérico

23.4 Funções e Variáveis Definidas para Séries de Fourier
=========================================================

 -- Função: equalp (<x>, <y>)
     Retorna 'true' se 'equal (<x>, <y>)' de outra forma 'false' (não
     fornece uma mensagem de erro como 'equal (x, y)' poderia fazer
     nesse caso).

 -- Função: remfun (<f>, <expr>)
 -- Função: remfun (<f>, <expr>, <x>)
     'remfun (<f>, <expr>)' substitue todas as ocorrências de '<f>
     (<arg>)' por <arg> em <expr>.

     'remfun (<f>, <expr>, <x>)' substitue todas as ocorrências de '<f>
     (<arg>)' por <arg> em <expr> somente se <arg> contiver a variável
     <x>.

 -- Função: funp (<f>, <expr>)
 -- Função: funp (<f>, <expr>, <x>)
     'funp (<f>, <expr>)' retorna 'true' se <expr> contém a função <f>.

     'funp (<f>, <expr>, <x>)' retorna 'true' se <expr> contém a função
     <f> e a variável <x> em algum lugar no argumento de uma das
     instâncias de <f>.

 -- Função: absint (<f>, <x>, <halfplane>)
 -- Função: absint (<f>, <x>)
 -- Função: absint (<f>, <x>, <a>, <b>)
     'absint (<f>, <x>, <halfplane>)' retorna a integral indefinida de
     <f> com relação a <x> no dado semi-plano ('pos', 'neg', ou 'both').
     <f> pode conter expressões da forma 'abs (x)', 'abs (sin (x))',
     'abs (a) * exp (-abs (b) * abs (x))'.

     'absint (<f>, <x>)' é equivalente a 'absint (<f>, <x>, pos)'.

     'absint (<f>, <x>, <a>, <b>)' retorna a integral definida de <f>
     com relação a <x> de <a> até <b>.  <f> pode incluir valores
     absolutos.

 -- Função: fourier (<f>, <x>, <p>)
     Retorna uma lista de coeficientes de Fourier de '<f>(<x>)'
     definidos sobre o intervalo '[-p, p]'.

 -- Função: foursimp (<l>)
     Simplifica 'sin (n %pi)' para 0 se 'sinnpiflag' for 'true' e 'cos
     (n %pi)' para '(-1)^n' se 'cosnpiflag' for 'true'.

 -- Variável de opção: sinnpiflag
     Valor padrão: 'true'

     Veja 'foursimp'.

 -- Variável de opção: cosnpiflag
     Valor padrão: 'true'

     Veja 'foursimp'.

 -- Função: fourexpand (<l>, <x>, <p>, <limit>)
     Constrói e retorna a série de Fourier partindo da lista de
     coeficientes de Fourier <l> até (up through) <limit> termos
     (<limit> pode ser 'inf').  <x> e <p> possuem o mesmo significado
     que em 'fourier'.

 -- Função: fourcos (<f>, <x>, <p>)
     Retorna os coeficientes do cosseno de Fourier para '<f>(<x>)'
     definida sobre '[0, %pi]'.

 -- Função: foursin (<f>, <x>, <p>)
     Retorna os coeficientes do seno de Fourier para '<f>(<x>)' definida
     sobre '[0, <p>]'.

 -- Função: totalfourier (<f>, <x>, <p>)
     Retorna 'fourexpand (foursimp (fourier (<f>, <x>, <p>)), <x>, <p>,
     'inf)'.

 -- Função: fourint (<f>, <x>)
     Constrói e retorna uma lista de coeficientes de integral de Fourier
     de '<f>(<x>)' definida sobre '[minf, inf]'.

 -- Função: fourintcos (<f>, <x>)
     Retorna os coeficientes da integral do cosseno de Fourier para
     '<f>(<x>)' on '[0, inf]'.

 -- Função: fourintsin (<f>, <x>)
     Retorna os coeficientes da integral do seno de Fourier para
     '<f>(<x>)' on '[0, inf]'.


File: maxima.info,  Node: Arrays,  Next: Matrizes e Álgebra Linear,  Prev: Numérico,  Up: Top

24 Arrays
*********

* Menu:

* Funções e Variáveis Definidas para Arrays::  


File: maxima.info,  Node: Funções e Variáveis Definidas para Arrays,  Prev: Arrays,  Up: Arrays

24.1 Funções e Variáveis Definidas para Arrays
==============================================

 -- Função: array (<name>, <dim_1>, ..., <dim_n>)
 -- Função: array (<name>, <type>, <dim_1>, ..., <dim_n>)
 -- Função: array ([<nome_1>, ..., <nome_m>], <dim_1>, ..., <dim_n>)

     Cria um array n-dimensional.  n pode ser menor ou igual a 5.  Os
     subscritos para a i'ésima dimensão são inteiros no intervalo de 0 a
     <dim_i>.

     'array (<name>, <dim_1>, ..., <dim_n>)' cria um array genérico.

     'array (<name>, <type>, <dim_1>, ..., <dim_n>)' cria um array, com
     elementos de um tipo especificado.  <type> pode ser 'fixnum' para
     inteiros de tamanho limitado ou 'flonum' para números em ponto
     flutuante.

     'array ([<nome_1>, ..., <nome_m>], <dim_1>, ..., <dim_n>)' cria m
     arrays, todos da mesma dimensão.

     Se o usuário atribui a uma variável subscrita antes de declarar o
     array correspondente, um array não declarado é criado.  Arrays não
     declarados, também conhecidos como array desordenado (porque o
     codigo desordenado termina nos subscritos), são mais gerais que
     arrays declarados.  O usuário não declara seu tamanho máximo, e ele
     cresce dinamicamente e desordenadamente à medida que são atribuídos
     valores a mais elementos.  Os subscritos de um array não declarado
     não precisam sempre ser números.  Todavia, exceto para um array um
     tanto quanto esparso, é provavelmente mais eficiente declarar isso
     quando possível que deixar não declarado.  A função 'array' pode
     ser usada para transformar um array não declarado em um array
     declarado.

 -- Função: arrayapply (<A>, [<i_1>, ..., <i_n>])
     Avalia '<A> [<i_1>, ..., <i_n>]', quando <A> for um array e <i_1>,
     ..., <i_n> são inteiros.

     Ela é remanescente de 'apply', exceto o primeiro argumento que é um
     array ao invés de uma função.

 -- Função: arrayinfo (<A>)
     Retorna informações sobre o array <A>.  O argumento <A> pode ser um
     array declarado, uma array não declarado ( que sofreu um hash), uma
     função de array, ou uma função que possui subscrito.

     Para arrays declarados, 'arrayinfo' retorna uma lista compreendendo
     o átomo 'declared', o n;umero de dimensões, e o tamanho de cada
     dimensão.  Os elementos do array, ambos associados e não
     associados, são retornados por 'listarray'.

     Para arrays não declarados (arrays que sofreram um hash),
     'arrayinfo' retorna uma lista compreendendo o átomo 'hashed', o
     número de subscritos, e os subscritos de de todo elemento que tiver
     um valor.  Os valores são retornados por meio de 'listarray'.

     Para funções de array, 'arrayinfo' retretorna uma lista
     compreendendo o átomo 'hashed', o número de subscritos, e quaisquer
     valores de subscritos para os quais exista valores funcionais
     armazenados.  Os valores funcionais armazenados são retornados
     através de 'listarray'.

     Para funções que possuem subscritos, 'arrayinfo' retorna uma lista
     compreendendo o átomo 'hashed', o número de subscritos, e qualquer
     valores subscritos para os quais existe uma expressões lambda.  As
     expressões lambda são retornadas por 'listarray'.

     Examples:

     'arrayinfo' e 'listarray' aplicado a um array declarado.

          (%i1) array (aa, 2, 3);
          (%o1)                          aa
          (%i2) aa [2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa [1, 2] : %e;
          (%o3)                          %e
          (%i4) arrayinfo (aa);
          (%o4)                 [declared, 2, [2, 3]]
          (%i5) listarray (aa);
          (%o5) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]

     'arrayinfo' e 'listarray' aplicado a um array não declarado (no
     qual foi aplicado um hash).

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) arrayinfo (bb);
          (%o3)               [hashed, 1, [BAR], [FOO]]
          (%i4) listarray (bb);
                                        3         2
          (%o4)                 [(c - d) , (b + a) ]

     'arrayinfo' e 'listarray' aplicado a uma função de array.

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) arrayinfo (cc);
          (%o4)              [hashed, 2, [4, z], [u, v]]
          (%i5) listarray (cc);
                                        z  v
          (%o5)                        [-, -]
                                        4  u

     'arrayinfo' e 'listarray' aplicadas a funções com subscritos.

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) arrayinfo (dd);
          (%o4)             [hashed, 1, [b + a], [v - u]]
          (%i5) listarray (dd);
                                   b + a                v - u
          (%o5)      [lambda([y], y     ), lambda([y], y     )]

 -- Função: arraymake (<A>, [<i_1>, ..., <i_n>])
     Retorna a expressão '<A>[<i_1>, ..., <i_n>]'.  O resultado é uma
     referência a um array não avaliado.

     'arraymake' é remanicência de 'funmake', exceto o valor retornado é
     um array de referência não avaliado ao invés de uma chamada de
     função não avaliada.

     Exemplos:

          (%i1) arraymake (A, [1]);
          (%o1)                          A
                                          1
          (%i2) arraymake (A, [k]);
          (%o2)                          A
                                          k
          (%i3) arraymake (A, [i, j, 3]);
          (%o3)                       A
                                       i, j, 3
          (%i4) array (A, fixnum, 10);
          (%o4)                           A
          (%i5) fillarray (A, makelist (i^2, i, 1, 11));
          (%o5)                           A
          (%i6) arraymake (A, [5]);
          (%o6)                          A
                                          5
          (%i7) ''%;
          (%o7)                          36
          (%i8) L : [a, b, c, d, e];
          (%o8)                    [a, b, c, d, e]
          (%i9) arraymake ('L, [n]);
          (%o9)                          L
                                          n
          (%i10) ''%, n = 3;
          (%o10)                          c
          (%i11) A2 : make_array (fixnum, 10);
          (%o11)          {Array:  #(0 0 0 0 0 0 0 0 0 0)}
          (%i12) fillarray (A2, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o12)          {Array:  #(1 2 3 4 5 6 7 8 9 10)}
          (%i13) arraymake ('A2, [8]);
          (%o13)                         A2
                                           8
          (%i14) ''%;
          (%o14)                          9

 -- Variável de sistema: arrays
     Valor padrão: '[]'

     'arrays' é uma lista dos arrays que tiverem sido alocados.  Essa
     lista compreende arrays declarados através de 'array', arrays
     desordenados (hashed) construídos através de definição implícita
     (atribuindo alguma coisa a um elemento de array), e funções de
     array definidas por meio de ':=' e 'define'.  Arrays definidos por
     meio de 'make_array' não estão incluídos.

     Veja também 'array', 'arrayapply', 'arrayinfo', 'arraymake',
     'fillarray', 'listarray', e 'rearray'.

     Exemplos:

          (%i1) array (aa, 5, 7);
          (%o1)                          aa
          (%i2) bb [FOO] : (a + b)^2;
                                             2
          (%o2)                       (b + a)
          (%i3) cc [x] := x/100;
                                             x
          (%o3)                      cc  := ---
                                       x    100
          (%i4) dd : make_array ('any, 7);
          (%o4)       {Array:  #(NIL NIL NIL NIL NIL NIL NIL)}
          (%i5) arrays;
          (%o5)                     [aa, bb, cc]

 -- Função: bashindices (<expr>)
     Transforma a expressão <expr> dando a cada somatório e a cada
     produto um único índice.  Isso dá a 'changevar' grande precisão
     quando se está trabalhando com somatórios e produtos.  A forma do
     único índice é 'j<number>'.  A quantidade <number> é determindad
     por referência a 'gensumnum', que pode ser alterada pelo usuário.
     Por exemplo, 'gensumnum:0$' reseta isso.

 -- Função: fillarray (<A>, <B>)
     Preenche o array <A> com <B>, que é uma lista ou um array.

     Se um tipo específico for declarado para <A> no momento de sua
     criação, <A> somente porde ser preenchido com elementos do tipo
     especificado; Constitui um erro alguma tentativa feita para copiar
     um um elemento de um tipo diferente.

     Se as dimensões dos arrays <A> e <B> forem diferents, <A> é
     preenchido no ordem de maior fileira.  Se não existirem elementos
     livres em <B> o último elemento é usado para preencher todo o resto
     de <A>.  Se existirem muitos , esses restantes seram ignorados.

     'fillarray' retorna esse primeiro argumento.

     Exemplos:

     Create an array of 9 elements and fill it from a list.

          (%i1) array (a1, fixnum, 8);
          (%o1)                          a1
          (%i2) listarray (a1);
          (%o2)              [0, 0, 0, 0, 0, 0, 0, 0, 0]
          (%i3) fillarray (a1, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
          (%o3)                          a1
          (%i4) listarray (a1);
          (%o4)              [1, 2, 3, 4, 5, 6, 7, 8, 9]

     Quando existirem poucos elementos para preencher o array, o último
     elemento é repetido.  Quando houverem muitos elementos, os
     elementos extras são ignorados.

          (%i1) a2 : make_array (fixnum, 8);
          (%o1)             {Array:  #(0 0 0 0 0 0 0 0)}
          (%i2) fillarray (a2, [1, 2, 3, 4, 5]);
          (%o2)             {Array:  #(1 2 3 4 5 5 5 5)}
          (%i3) fillarray (a2, [4]);
          (%o3)             {Array:  #(4 4 4 4 4 4 4 4)}
          (%i4) fillarray (a2, makelist (i, i, 1, 100));
          (%o4)             {Array:  #(1 2 3 4 5 6 7 8)}

     Arrays multi-dimensionais são preenchidos em ordem de maior
     fileira.

          (%i1) a3 : make_array (fixnum, 2, 5);
          (%o1)        {Array:  #2A((0 0 0 0 0) (0 0 0 0 0))}
          (%i2) fillarray (a3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o2)        {Array:  #2A((1 2 3 4 5) (6 7 8 9 10))}
          (%i3) a4 : make_array (fixnum, 5, 2);
          (%o3)     {Array:  #2A((0 0) (0 0) (0 0) (0 0) (0 0))}
          (%i4) fillarray (a4, a3);
          (%o4)     {Array:  #2A((1 2) (3 4) (5 6) (7 8) (9 10))}

 -- Função: listarray (<A>)
     Retorna uma lista dos elementos do array <A>.  O argumento <A> pode
     ser um array declarado, um array não declarado (desordenado -
     hashed), uma função de array, ou uma função com subscritos.

     Elementos são listados em ordem de linha maior.  Isto é, elementos
     são ordenados conforme o primeiro índice, en seguida conforme o
     segundo índice, e assim sucessivamente.  A sequüência de ordenação
     por meio dos valores dos índices é a mesma ordem estabelecida por
     meio de 'orderless'.

     Para arrays não declarados , funções de arrays, e funções com
     subscritos, os elementos correspondem aos valores de índice
     retornados através de 'arrayinfo'.

     Elemetos não associados de arrays genéricos declarados (isto é, não
     'fixnum' e não 'flonum') são retornados como '#####'.  Elementos
     não associados de arrays declarados 'fixnum' ou 'flonum' são
     retornados como 0 ou 0.0, respectivamente.  Elementos não
     associados de arrays não declarados, funções de array, e funções
     subscritas não são retornados.

     Exemplos:

     'listarray' e 'arrayinfo' aplicados a um array declarado.

          (%i1) array (aa, 2, 3);
          (%o1)                          aa
          (%i2) aa [2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa [1, 2] : %e;
          (%o3)                          %e
          (%i4) listarray (aa);
          (%o4) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]
          (%i5) arrayinfo (aa);
          (%o5)                 [declared, 2, [2, 3]]

     'listarray' e 'arrayinfo' aplicadas a arrays não declarados (hashed
     - desordenados).

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) listarray (bb);
                                        3         2
          (%o3)                 [(c - d) , (b + a) ]
          (%i4) arrayinfo (bb);
          (%o4)               [hashed, 1, [BAR], [FOO]]

     'listarray' e 'arrayinfo' aplicada a uma função de array.

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) listarray (cc);
                                        z  v
          (%o4)                        [-, -]
                                        4  u
          (%i5) arrayinfo (cc);
          (%o5)              [hashed, 2, [4, z], [u, v]]

     'listarray' e 'arrayinfo' aplicadas a funções com subscritos.

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) listarray (dd);
                                   b + a                v - u
          (%o4)      [lambda([y], y     ), lambda([y], y     )]
          (%i5) arrayinfo (dd);
          (%o5)             [hashed, 1, [b + a], [v - u]]

 -- Função: make_array (<type>, <dim_1>, ..., <dim_n>)
     Cria e retorna um array de Lisp.  <type> pode ser 'any', 'flonum',
     'fixnum', 'hashed' ou 'functional'.  Existem n indices, e o
     i'enésimo indice está no intervalo de 0 a <dim_i> - 1.

     A vantagem de 'make_array' sobre 'array' é que o valor de retorno
     não tem um nome, e uma vez que um ponteiro a ele vai, ele irá
     também.  Por exemplo, se 'y: make_array (...)' então 'y' aponta
     para um objeto que ocupa espaço, mas depois de 'y: false', 'y' não
     mais aponta para aquele objeto, então o objeto pode ser descartado.

     Exemplos:

          (%i1) A1 : make_array (fixnum, 10);
          (%o1)           {Array:  #(0 0 0 0 0 0 0 0 0 0)}
          (%i2) A1 [8] : 1729;
          (%o2)                         1729
          (%i3) A1;
          (%o3)          {Array:  #(0 0 0 0 0 0 0 0 1729 0)}
          (%i4) A2 : make_array (flonum, 10);
          (%o4) {Array:  #(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0)}
          (%i5) A2 [2] : 2.718281828;
          (%o5)                      2.718281828
          (%i6) A2;
          (%o6)
               {Array:  #(0.0 0.0 2.718281828 0.0 0.0 0.0 0.0 0.0 0.0 0.0)}
          (%i7) A3 : make_array (any, 10);
          (%o7) {Array:  #(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)}
          (%i8) A3 [4] : x - y - z;
          (%o8)                      - z - y + x
          (%i9) A3;
          (%o9) {Array:  #(NIL NIL NIL NIL ((MPLUS SIMP) $X ((MTIMES SIMP)\
           -1 $Y) ((MTIMES SIMP) -1 $Z))
            NIL NIL NIL NIL NIL)}
          (%i10) A4 : make_array (fixnum, 2, 3, 5);
          (%o10) {Array:  #3A(((0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0)) ((0 0 \
          0 0 0) (0 0 0 0 0) (0 0 0 0 0)))}
          (%i11) fillarray (A4, makelist (i, i, 1, 2*3*5));
          (%o11) {Array:  #3A(((1 2 3 4 5) (6 7 8 9 10) (11 12 13 14 15))
              ((16 17 18 19 20) (21 22 23 24 25) (26 27 28 29 30)))}
          (%i12) A4 [0, 2, 1];
          (%o12)                         12

 -- Função: rearray (<A>, <dim_1>, ..., <dim_n>)
     Altera as dimenções de um array.  O novo array será preenchido com
     os elementos do antigo em ordem da maior linha.  Se o array antigo
     era muito pequeno, os elementos restantes serão preenchidos com
     'false', '0.0' ou '0', dependendo do tipo do array.  O tipo do
     array não pode ser alterado.

 -- Função: remarray (<A_1>, ..., <A_n>)
 -- Função: remarray (all)
     Remove arrays e funções associadas a arrays e libera o espaço
     ocupado.  Os argumentos podem ser arrays declarados, arrays não
     declarados (dsordenados - hashed), funções de array functions, e
     funções com subscritos.

     'remarray (all)' remove todos os ítens na lista global 'arrays'.

     Isso pode ser necessário para usar essa função se isso é desejado
     para redefinir os valores em um array desordenado.

     'remarray' retorna a lista dos arrays removidos.

 -- Função: subvar (<x>, <i>)
     Avalia a expressão subscrita '<x>[<i>]'.

     'subvar' avalia seus argumentos.

     'arraymake (<x>, [<i>]' constrói a expressão '<x>[<i>]', mas não a
     avalia.

     Exemplos:

          (%i1) x : foo $
          (%i2) i : 3 $
          (%i3) subvar (x, i);
          (%o3)                         foo
                                           3
          (%i4) foo : [aa, bb, cc, dd, ee]$
          (%i5) subvar (x, i);
          (%o5)                          cc
          (%i6) arraymake (x, [i]);
          (%o6)                         foo
                                           3
          (%i7) ''%;
          (%o7)                          cc

 -- Variável de pção: use_fast_arrays
     - Se 'true' somente dois tipos de arrays são reconhecidos.

     1) O array art-q (t no Lisp Comum) que pode ter muitas dimensões
     indexadas por inteiros, e pode aceitar qualquer objeto do Lisp ou
     do Maxima como uma entrada.  Para construir assim um array, insira
     'a:make_array(any,3,4);' então 'a' terá como valor, um array com
     doze posições, e o índice é baseado em zero.

     2) O array Hash_table que é o tipo padrão de array criado se um faz
     'b[x+1]:y^2' (e 'b' não é ainda um array, uma lista, ou uma matriz
     - se isso ou um desses ocorrer um erro pode ser causado desde 'x+1'
     não poderá ser um subscrito válido para um array art-q, uma lista
     ou uma matriz).  Esses índices (também conhecidos como chaves)
     podem ser quaisquer objetos.  Isso somente pega uma chave por vez a
     cada vez ('b[x+1,u]:y' ignorará o 'u').  A referência termina em
     'b[x+1] ==> y^2'.  Certamente a chave poe ser uma lista , e.g.
     'b[[x+1,u]]:y' poderá ser válido.  Isso é incompatível com os
     arrays antigos do Maxima, mas poupa recursos.

     Uma vantagem de armazenar os arrays como valores de símbolos é que
     as convenções usuais sobre variáveis locais de uma função
     aplicam-se a arrays também.  O tipo Hash_table também usa menos
     recursos e é mais eficiente que o velho tipo hashar do Maxima.
     Para obter comportamento consistente em códigos traduzidos e
     compilados posicione 'translate_fast_arrays' para ser 'true'.

