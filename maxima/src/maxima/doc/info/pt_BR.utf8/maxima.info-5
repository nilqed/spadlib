This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.


File: maxima.info,  Node: Funções e Variáveis Definidas para contrib_ode,  Next: Possibilidades de melhorias em contrib_ode,  Prev: Introdução a contrib_ode,  Up: contrib_ode

44.2 Funções e Variáveis Definidas para contrib_ode
===================================================

 -- Função: contrib_ode (<eqn>, <y>, <x>)

     Retorna uma lista de soluções da EDO <eqn> com variável
     independente <x> e variável dependente <y>.

 -- Função: odelin (<eqn>, <y>, <x>)

     'odelin' resolve EDO's lineares homogêneas de primeira e segunda
     ordem com variável independente <x> e variável dependente <y>.
     'odelin' retorna um conjunto solução fundamental da EDO.

     para EDO's de segunda ordem, 'odelin' usa um método, devido a
     Bronstein e Lafaille, que busca por soluções em termos de funções
     especiais dadas.

          (%i1) load('contrib_ode);

          (%i2) odelin(x*(x+1)*'diff(y,x,2)+(x+5)*'diff(y,x,1)+(-4)*y,y,x);
          ...trying factor method
          ...solving 7 equations in 4 variables
          ...trying the Bessel solver
          ...solving 1 equations in 2 variables
          ...trying the F01 solver
          ...solving 1 equations in 3 variables
          ...trying the spherodial wave solver
          ...solving 1 equations in 4 variables
          ...trying the square root Bessel solver
          ...solving 1 equations in 2 variables
          ...trying the 2F1 solver
          ...solving 9 equations in 5 variables
                 gauss_a(- 6, - 2, - 3, - x)  gauss_b(- 6, - 2, - 3, - x)
          (%o2) {---------------------------, ---------------------------}
                              4                            4
                             x                            x

 -- Função: ode_check (<eqn>, <sol>)

     Retorna o valor da EDO <eqn> após substituir uma possível solução
     <sol>.  O valor é igual a zero se <sol> for uma solução of <eqn>.

          (%i1) load('contrib_ode)$

          (%i2) eqn:'diff(y,x,2)+(a*x+b)*y;

                                   2
                                  d y
          (%o2)                   --- + (a x + b) y
                                    2
                                  dx
          (%i3) ans:[y = bessel_y(1/3,2*(a*x+b)^(3/2)/(3*a))*%k2*sqrt(a*x+b)
                   +bessel_j(1/3,2*(a*x+b)^(3/2)/(3*a))*%k1*sqrt(a*x+b)];

                                            3/2
                              1  2 (a x + b)
          (%o3) [y = bessel_y(-, --------------) %k2 sqrt(a x + b)
                              3       3 a
                                                    3/2
                                      1  2 (a x + b)
                           + bessel_j(-, --------------) %k1 sqrt(a x + b)]
                                      3       3 a
          (%i4) ode_check(eqn,ans[1]);

          (%o4)                           0

 -- Variável global: 'method'

     A variável 'method' é escolhida para o método que resolver com
     sucesso uma dada EDO.

 -- Variável: '%c'

     '%c' é a constante de integração para EDO's de primeira ordem.

 -- Variável: '%k1'

     '%k1' é a primeira constante de integração para EDO's de segunda
     ordem.

 -- Variável: '%k2'

     '%k2' é a segunda constante de integração para EDO's de segunda
     ordem.

 -- Função: gauss_a (<a>, <b>, <c>, <x>)

     'gauss_a(a,b,c,x)' e 'gauss_b(a,b,c,x)' são funções
     hipergeométricas 2F1.  Elas represetnam quaisquer duas soluções
     independentes da equação diferencial hipergeométrica 'x(1-x)
     diff(y,x,2) + [c-(a+b+1)x diff(y,x) - aby = 0' (A&S 15.5.1).

     O único uso dessas funções é em soluções de EDO's retornadas por
     'odelin' e 'contrib_ode'.  A definição e o uso dessas funções pode
     mudar em futuras versões do maxima.

     Veja também 'gauss_b', 'dgauss_a' e 'gauss_b'.

 -- Função: gauss_b (<a>, <b>, <c>, <x>)
     Veja 'gauss_a'.

 -- Função: dgauss_a (<a>, <b>, <c>, <x>)
     A derivada em relação a x de 'gauss_a(a,b,c,x)'.

 -- Função: dgauss_b (<a>, <b>, <c>, <x>)
     A derivada em relação a x de 'gauss_b(a,b,c,x)'.

 -- Função: kummer_m (<a>, <b>, <x>)

     A função M de Kummer, como definida em Abramowitz e Stegun,
     Handbook of Mathematical Functions, Section 13.1.2.

     O único uso dessas funções é em soluções de EDO's retornadas por
     'odelin' e 'contrib_ode'.  A definição e o uso dessas funções pode
     mudar em futuras versões do maxima.

     Veja também 'kummer_u', 'dkummer_m' e 'dkummer_u'.

 -- Função: kummer_u (<a>, <b>, <x>)

     A função U de Kummer, como definida em Abramowitz e Stegun,
     Handbook of Mathematical Functions, Section 13.1.3.

     Veja 'kummer_m'.

 -- Função: dkummer_m (<a>, <b>, <x>)
     A derivada com relação a x de 'kummer_m(a,b,x)'.

 -- Função: dkummer_u (<a>, <b>, <x>)
     A derivada com relação a x de 'kummer_u(a,b,x)'.


File: maxima.info,  Node: Possibilidades de melhorias em contrib_ode,  Next: Casos de teste para contrib_ode,  Prev: Funções e Variáveis Definidas para contrib_ode,  Up: contrib_ode

44.3 Possibilidades de melhorias em contrib_ode
===============================================

Essas rotinas aida estão sendo aperfeiçoadas.  É necessário ainda:

   * Extender o método FACTOR 'ode1_factor' para trabalhar com raízes
     multiplas.

   * Extender o método FACTOR 'ode1_factor' para tentar resolver fatores
     de mais alta ordem.  Atualmente somente tenta resolver fatores
     lineares.

   * Corrigir a rotina de LAGRANGE 'ode1_lagrange' para preferiraízes
     reais a raízes complexas.

   * Aumentar a quantidade de métodos adicionais para equações de
     Riccati.

   * Melhorar a detecção de equações de Abel do segundo tipo.  O modelo
     existente de coincidência é fraco.

   * Trabalho sobre a rotina do grupo de simetria de Lie 'ode1_lie'.
     Existem poucos porém grandes problemas com essa rotina: algumas
     partes precisam de implementação; alguns casos de teste parecem
     executar indefinidamente; outros casos de teste abortam
     inesplicavelmente; outros ainda retorna "soluções" muito complexas.
     Seria surpreendente se estivesse pronto para se liberar uma versão
     estável.

   * Adicionar mais casos de teste.


File: maxima.info,  Node: Casos de teste para contrib_ode,  Next: Referências bibliográficas para contrib_ode,  Prev: Possibilidades de melhorias em contrib_ode,  Up: contrib_ode

44.4 Casos de teste para contrib_ode
====================================

Asrotinas foram tesadas sobre aproximadamente mil casos de teste por
Murphy, Kamke, Zwillinger e outros.  Esses testes estão incluídos no
subdiretório de testes.

   * A rotina de Clairault 'ode1_clairault' encontra todas as soluções
     conhecidas, incluindo soluções singulares, das equações de
     Clairault em Murphy e Kamke.

   * As outras rotinas muitas vezes retornam uma solução simples quando
     existem multiplas soluções.

   * Algumas das "soluções" de 'ode1_lie' são extremamente complexas e
     impossíveis de verificar.

   * Existe algumas interrupções inexplicávies de execução.


File: maxima.info,  Node: Referências bibliográficas para contrib_ode,  Prev: Casos de teste para contrib_ode,  Up: contrib_ode

44.5 Referências bibliográficas para contrib_ode
================================================

  1. E Kamke, Differentialgleichungen Losungsmethoden und Losungen, Vol
     1, Geest & Portig, Leipzig, 1961

  2. G M Murphy, Ordinary Differential Equations and Their Solutions,
     Van Nostrand, New York, 1960

  3. D Zwillinger, Handbook of Differential Equations, 3rd edition,
     Academic Press, 1998

  4. F Schwarz, Symmetry Analysis of Abel's Equation, Studies in Applied
     Mathematics, 100:269-294 (1998)

  5. F Schwarz, Algorithmic Solution of Abel's Equation, Computing 61,
     39-49 (1998)

  6. E. S. Cheb-Terrab, A. D. Roche, Symmetries and First Order EDO
     Patterns, Computer Physics Communications 113 (1998), p 239.
     (http://lie.uwaterloo.ca/papers/ode_vii.pdf)

  7. E. S. Cheb-Terrab, T. Koloknikov, First Order EDO's, Symmetries and
     Linear Transformations, European Journal of Applied Mathematics,
     Vol.  14, No.  2, pp.  231-246 (2003).
     (http://arxiv.org/abs/math-ph/0007023)
     (http://lie.uwaterloo.ca/papers/ode_iv.pdf)

  8. G W Bluman, S C Anco, Symmetry and Integration Methods for
     Differential Equations, Springer, (2002)

  9. M Bronstein, S Lafaille, Solutions of linear ordinary equações
     diferenciais in terms of special functions, Proceedings of ISSAC
     2002, Lille, ACM Press, 23-28.
     (http://www-sop.inria.fr/cafe/Manuel.Bronstein/publications/issac2002.pdf)


File: maxima.info,  Node: descriptive,  Next: diag,  Prev: contrib_ode,  Up: Top

45 descriptive
**************

* Menu:

* Introdução ao pacote descriptive::
* Funções e Variáveis Definidas para manipulação da dados::
* Funções e Variáveis Definidas para estatística descritiva::
* Funções e Variáveis Definidas específicas para estatística descritiva de várias variáveis::
* Funções e Variáveis Definidas para gráficos estatísticos::


File: maxima.info,  Node: Introdução ao pacote descriptive,  Next: Funções e Variáveis Definidas para manipulação da dados,  Prev: descriptive,  Up: descriptive

45.1 Introdução ao pacote descriptive
=====================================

O pacote 'descriptive' contém um conjunto de funções para fazer cálculos
de estatística descritiva e desenhar gráficos.  Juntamente com o código
fonte três conjuntos de dados em suar árvore do Maxima: 'pidigits.data',
'wind.data' e 'biomed.data'.  Eles também podem ser baixados a partir de
'www.biomates.net'.

   Qualque manual de estatística pode ser usado como referência para as
funções no pacote 'descriptive'.

   Para comentários, erros ou sugestões, por favor entre em contato
comigo em <'mario AT edu DOT xunta DOT es'>.

   Aqui está um exemplo sobre como as funções de estatística descritiva
no pacote 'descriptive' fazem esse trabalho, dependendo da natureza de
seus argumentos, listas e matrizes,

     (%i1) load (descriptive)$
     (%i2) /* univariate sample */   mean ([a, b, c]);
                                 c + b + a
     (%o2)                       ---------
                                     3
     (%i3) matrix ([a, b], [c, d], [e, f]);
                                 [ a  b ]
                                 [      ]
     (%o3)                       [ c  d ]
                                 [      ]
                                 [ e  f ]
     (%i4) /* amostra de várias variáveis */ mean (%);
                           e + c + a  f + d + b
     (%o4)                [---------, ---------]
                               3          3

   Note que em amostras de várias variáveis a média é calculada em cada
coluna.

   No caso de muitas amostras amostras com possíveis tamanhos
diferentes, A função do Maxima 'map' pode ser usada para pegar os
resultados desejados de cada amostra,

     (%i1) load (descriptive)$
     (%i2) map (mean, [[a, b, c], [d, e]]);
                             c + b + a  e + d
     (%o2)                  [---------, -----]
                                 3        2

   Nesse caso, duas amostras de tamanhos 3 e 2 foram armazenadas em uma
lista.

   Amostras de uma única variável devem ser armazenadas em listas como

     (%i1) s1 : [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];
     (%o1)           [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]

   e amostras de várias variáveis em matrizes como em

     (%i1) s2 : matrix ([13.17, 9.29], [14.71, 16.88], [18.50, 16.88],
                  [10.58, 6.63], [13.33, 13.25], [13.21,  8.12]);
                             [ 13.17  9.29  ]
                             [              ]
                             [ 14.71  16.88 ]
                             [              ]
                             [ 18.5   16.88 ]
     (%o1)                   [              ]
                             [ 10.58  6.63  ]
                             [              ]
                             [ 13.33  13.25 ]
                             [              ]
                             [ 13.21  8.12  ]

   Nesse caso, o número de colunas é igual à dimensão (ao número) de
variáveis e o n;umero de linhas é o tamano da amostra.

   Dados podem ser introduzidos manualmente, mas grandes amostras são
usualmente armazenadas em arquivos no formato texto plano.  Por exemplo,
o arquivo 'pidigits.data' contém os primeiros 100 dígitos do número
'%pi':
           3
           1
           4
           1
           5
           9
           2
           6
           5
           3 ...

   Com o objetivo de chamar esses dígitos no Maxima,

     (%i1) load (numericalio)$
     (%i2) s1 : read_list (file_search ("pidigits.data"))$
     (%i3) length (s1);
     (%o3)                          100

   Por outro lado, o arquivo 'wind.data' contém a média diária de
velocidades do ventoem 5 estações meteorológicas na República da Irlanda
(Esses dados são parte de um conjunto de dados tomados em 12 estações
meteorológicas.  O arquivo original está disponivel livremente para
download no Repositório de Dados StatLib e sua análise é discutida em
Haslett, J., Raftery, A. E. (1989) <Space-time Modelling with
Long-memory Dependence: Assessing Ireland's Wind Power Resource, with
Discussion>.  Applied Statistics 38, 1-50).  As linhas seguintes mostram
como tornar os dados disponíveis para o Maxima:

     (%i1) load (numericalio)$
     (%i2) s2 : read_matrix (file_search ("wind.data"))$
     (%i3) length (s2);
     (%o3)                          100
     (%i4) s2 [%]; /* last record */
     (%o4)            [3.58, 6.0, 4.58, 7.62, 11.25]

   Algumas amostras possuem dados não numéricos.  Como um exemplo, o
arquivo 'biomed.data' (que é parte de outro grande arquivo tomado do
Repósitório de Dados StatLib) contém quatro medidas sangüíneas tomadas
de dois grupos de pacientes, 'A' e 'B', de diferentes idades,

     (%i1) load (numericalio)$
     (%i2) s3 : read_matrix (file_search ("biomed.data"))$
     (%i3) length (s3);
     (%o3)                          100
     (%i4) s3 [1]; /* first record */
     (%o4)            [A, 30, 167.0, 89.0, 25.6, 364]

   O primeiro indivíduo pertence ao grupo 'A', com 30 anos de idade e
suas medidas sangüíneas foram 167.0, 89.0, 25.6 e 364.

   Se deve tomar cuidado quando se trabalha com dados divididos por
categorias.  no exemplo seguinte, ao símbolo 'a' é atribuído um valor em
algum momento anterior e então a amostra com valores divididos por
categoria 'a' é interpretada como,

     (%i1) a : 1$
     (%i2) matrix ([a, 3], [b, 5]);
                                 [ 1  3 ]
     (%o2)                       [      ]
                                 [ b  5 ]


File: maxima.info,  Node: Funções e Variáveis Definidas para manipulação da dados,  Next: Funções e Variáveis Definidas para estatística descritiva,  Prev: Introdução ao pacote descriptive,  Up: descriptive

45.2 Funções e Variáveis Definidas para manipulação da dados
============================================================

 -- Função: continuous_freq (<list>)
 -- Função: continuous_freq (<list>, <m>)
     O argumetno de 'continuous_freq' deve ser uma lista de números, que
     serão então agrupadas em intervalos e contado quantos desses dados
     pertencem a cada grupo.  Opcionalmente, a função 'continuous_freq'
     admite um segundo argumento indicando o número de classes, 10 é o
     valor padrão,

          (%i1) load (numericalio)$
          (%i2) load (descriptive)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) continuous_freq (s1, 5);
          (%o4) [[0, 1.8, 3.6, 5.4, 7.2, 9.0], [16, 24, 18, 17, 25]]

     A primeira lista contém os limites de intervalos e o segundo a
     correspondente contagem: existem 16 algarismos da parte decimal de
     '%pi' dentro do intervalo '[0, 1.8]', isto é 0's e 1's, 24
     algarismos em '(1.8, 3.6]', isto é 2's e 3's, e assim por diante.

 -- Função: discrete_freq (<list>)
     Conta as freqüências absolutas em amostras discretas, em amostras
     numéricas e em amostras divididas em categorias.  Seu único
     argumento é uma lista,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"));
          (%o3) [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3, 2, 3, 8,
          4, 6, 2, 6, 4, 3, 3, 8, 3, 2, 7, 9, 5, 0, 2, 8, 8, 4, 1, 9, 7,
          1, 6, 9, 3, 9, 9, 3, 7, 5, 1, 0, 5, 8, 2, 0, 9, 7, 4, 9, 4, 4,
          5, 9, 2, 3, 0, 7, 8, 1, 6, 4, 0, 6, 2, 8, 6, 2, 0, 8, 9, 9, 8,
          6, 2, 8, 0, 3, 4, 8, 2, 5, 3, 4, 2, 1, 1, 7, 0, 6, 7]
          (%i4) discrete_freq (s1);
          (%o4) [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
                                       [8, 8, 12, 12, 10, 8, 9, 8, 12, 13]]

     A primeira lista fornece os valores da amostra e a segunda seuas
     freqüências absolutas.  Os comandos '? col' e '? transpose' podem
     ajudar a você a entender a última entrada.

 -- Função: subsample (<matriz_de_dados>, <expressão_lógica>)
 -- Função: subsample (<matriz_de_dados>, <expressão_lógica>, <col_num>,
          <col_num>, ...)
     Essas funções são um tipo de variação da função 'submatrix' do
     Maxima.  O primeiro argumento é o nome da matriz de dados, o
     segundo argumento é uma expressão lógica que recebeu apóstrofo e os
     argumentos opcionais adicionais são o número de colunas a serem
     tomadas.  Esse comportamento é melhor entendido com exemplos,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) subsample (s2, '(%c[1] > 18));
                        [ 19.38  15.37  15.12  23.09  25.25 ]
                        [                                   ]
                        [ 18.29  18.66  19.08  26.08  27.63 ]
          (%o4)         [                                   ]
                        [ 20.25  21.46  19.95  27.71  23.38 ]
                        [                                   ]
                        [ 18.79  18.96  14.46  26.38  21.84 ]

     Existem registros de várias variáveis nos quais a velocidade do
     vento na primeira estação meteorológica foram maiores que 18.  Veja
     que na expressão lógica que recebeu apóstrofo o <i>-ésimo
     componente é referenciado como '%c[i]'.  O símbolo '%c[i]' é usado
     dentro da função 'subsample', portanto quando usado como uma
     variável de uma categoria, Maxima fica confuso.  No seguinte
     exemplo, requisitamos somente o primeiro, o segundo e o quinto
     componentes desses registro com velocidades de vento maiores que ou
     igual a 16 nós na estação meteorológica número 1 e menor que 25 nós
     na estação meteorológica número 4,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) subsample (s2, '(%c[1] >= 16 and %c[4] < 25), 1, 2, 5);
                               [ 19.38  15.37  25.25 ]
                               [                     ]
                               [ 17.33  14.67  19.58 ]
          (%o4)                [                     ]
                               [ 16.92  13.21  21.21 ]
                               [                     ]
                               [ 17.25  18.46  23.87 ]

     Aqui está um exemplo com as variáveis divididas em categorias do
     arquivo 'biomed.data'.  Queremos os registros correspondentes a
     aqueles pacientes no grupo 'B' que possuem idade maior que 38 anos,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) subsample (s3, '(%c[1] = B and %c[2] > 38));
                          [ B  39  28.0  102.3  17.1  146 ]
                          [                               ]
                          [ B  39  21.0  92.4   10.3  197 ]
                          [                               ]
                          [ B  39  23.0  111.5  10.0  133 ]
                          [                               ]
                          [ B  39  26.0  92.6   12.3  196 ]
          (%o4)           [                               ]
                          [ B  39  25.0  98.7   10.0  174 ]
                          [                               ]
                          [ B  39  21.0  93.2   5.9   181 ]
                          [                               ]
                          [ B  39  18.0  95.0   11.3  66  ]
                          [                               ]
                          [ B  39  39.0  88.5   7.6   168 ]

     Probavelmente, a análise estatística irá envolver somente as
     medidas sangüíneas,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) subsample (s3, '(%c[1] = B and %c[2] > 38), 3, 4, 5, 6);
                             [ 28.0  102.3  17.1  146 ]
                             [                        ]
                             [ 21.0  92.4   10.3  197 ]
                             [                        ]
                             [ 23.0  111.5  10.0  133 ]
                             [                        ]
                             [ 26.0  92.6   12.3  196 ]
          (%o4)              [                        ]
                             [ 25.0  98.7   10.0  174 ]
                             [                        ]
                             [ 21.0  93.2   5.9   181 ]
                             [                        ]
                             [ 18.0  95.0   11.3  66  ]
                             [                        ]
                             [ 39.0  88.5   7.6   168 ]

     Essa é a média de várias variáveis de 's3',

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) mean (s3);
                 65 B + 35 A  317          6 NA + 8145.0
          (%o4) [-----------, ---, 87.178, -------------, 18.123,
                     100      10                100
                                                              3 NA + 19587
                                                              ------------]
                                                                  100
     Aqui, a primeira componente é sem sentido, uma vez que 'A' e 'B'
     são categorias, o segundo componente é a idade média dos indivíduos
     na forma racional, e o quarto eo último valores exibem um
     comportamento estranho.  Isso ocorre porque o símbolo 'NA' é usado
     aqui para indicar dado não disponível (<non available> em inglês),
     e as duas médias são certamente sem sentido.  Uma solução possível
     pode ser jogar fora a matriz cujas linhas possuam símbolos 'NA',
     embora isso cause alguma perda de informação,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) mean (subsample (s3, '(%c[4] # NA and %c[6] # NA), 3, 4, 5, 6));
          (%o4) [79.4923076923077, 86.2032967032967, 16.93186813186813,
                                                                      2514
                                                                      ----]
                                                                       13


File: maxima.info,  Node: Funções e Variáveis Definidas para estatística descritiva,  Next: Funções e Variáveis Definidas específicas para estatística descritiva de várias variáveis,  Prev: Funções e Variáveis Definidas para manipulação da dados,  Up: descriptive

45.3 Funções e Variáveis Definidas para estatística descritiva
==============================================================

 -- Função: mean (<lista>)
 -- Função: mean (<matriz>)
     Essa função calcula a média de uma amostra, definida como
                                 n
                               ====
                       _   1   \
                       x = -    >    x
                           n   /      i
                               ====
                               i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) mean (s1);
                                         471
          (%o4)                          ---
                                         100
          (%i5) %, numer;
          (%o5)                         4.71
          (%i6) s2 : read_matrix (file_search ("wind.data"))$
          (%i7) mean (s2);
          (%o7)     [9.9485, 10.1607, 10.8685, 15.7166, 14.8441]

 -- Função: var (<list>)
 -- Função: var (<matrix>)
     This is the sample variance, defined as
                               n
                             ====
                     2   1   \          _ 2
                    s  = -    >    (x - x)
                         n   /       i
                             ====
                             i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) var (s1), numer;
          (%o4)                   8.425899999999999

     See also function 'var1'.

 -- Função: var1 (<lista>)
 -- Função: var1 (<matriz>)
     Essa função calcula a variância da amostra, definida como
                               n
                             ====
                         1   \          _ 2
                        ---   >    (x - x)
                        n-1  /       i
                             ====
                             i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) var1 (s1), numer;
          (%o4)                    8.5110101010101
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) var1 (s2);
          (%o6) [17.39586540404041, 15.13912778787879, 15.63204924242424,
                                      32.50152569696971, 24.66977392929294]

     See also function 'var'.

 -- Função: std (<lista>)
 -- Função: std (<matriz>)
     A raíz quadrada da função 'var', a variância com denominador n.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) std (s1), numer;
          (%o4)                   2.902740084816414
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) std (s2);
          (%o6) [4.149928523480858, 3.871399812729241, 3.933920277534866,
                                      5.672434260526957, 4.941970881136392]

     Veja também as funções 'var' e 'std1'.

 -- Função: std1 (<lista>)
 -- Função: std1 (<matriz>)
     É a raíz quadrada da função 'var1', a variância com denominador
     n-1.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) std1 (s1), numer;
          (%o4)                   2.917363553109228
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) std1 (s2);
          (%o6) [4.17083509672109, 3.89090320978032, 3.953738641137555,
                                      5.701010936401517, 4.966867617451963]

     Veja também as funções 'var1' e 'std'.

 -- Função: noncentral_moment (<lista>, <k>)
 -- Função: noncentral_moment (<matriz>, <k>)
     O momento não central de ordem k, definido como
                                 n
                               ====
                           1   \      k
                           -    >    x
                           n   /      i
                               ====
                               i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) noncentral_moment (s1, 1), numer; /* the mean */
          (%o4)                         4.71
          (%i6) s2 : read_matrix (file_search ("wind.data"))$
          (%i7) noncentral_moment (s2, 5);
          (%o7) [319793.8724761506, 320532.1923892463, 391249.5621381556,
                                      2502278.205988911, 1691881.797742255]

     Veja também a função 'central_moment'.

 -- Função: central_moment (<lista>, <k>)
 -- Função: central_moment (<matriz>, <k>)
     O momento central de ordem k, definido como
                              n
                            ====
                        1   \          _ k
                        -    >    (x - x)
                        n   /       i
                            ====
                            i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) central_moment (s1, 2), numer; /* a variância */
          (%o4)                   8.425899999999999
          (%i6) s2 : read_matrix (file_search ("wind.data"))$
          (%i7) central_moment (s2, 3);
          (%o7) [11.29584771375004, 16.97988248298583, 5.626661952750102,
                                       37.5986572057918, 25.85981904394192]

     Veja também as funções 'central_moment' e 'mean'.

 -- Função: cv (<lista>)
 -- Função: cv (<matriz>)
     O coeficiente de variação é o quociente entre o desvio padrão da
     amostra ('std') e a média 'mean',

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) cv (s1), numer;
          (%o4)                   .6193977819764815
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) cv (s2);
          (%o6) [.4192426091090204, .3829365309260502, 0.363779605385983,
                                      .3627381836021478, .3346021393989506]

     Veja também as funções 'std' e 'mean'.

 -- Função: mini (<lista>)
 -- Função: mini (<matriz>)
     É o valor mínimo da amostra <lista>,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) mini (s1);
          (%o4)                           0
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) mini (s2);
          (%o6)             [0.58, 0.5, 2.67, 5.25, 5.17]

     Veja também função 'maxi'.

 -- Função: maxi (<lista>)
 -- Função: maxi (<matriz>)
     É o valor máximo da amostra <lista>,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) maxi (s1);
          (%o4)                           9
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) maxi (s2);
          (%o6)          [20.25, 21.46, 20.04, 29.63, 27.63]

     Veja também a função 'mini'.

 -- Função: range (<lista>)
 -- Função: range (<matriz>)
     A amplitude é a diferença entre os valores de maximo e de mínimo.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) range (s1);
          (%o4)                           9
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) range (s2);
          (%o6)          [19.67, 20.96, 17.37, 24.38, 22.46]

 -- Função: quantile (<lista>, <p>)
 -- Função: quantile (<matriz>, <p>)
     É o <p>-'quantile' (quantil de ordem <p>), com <p> sendo um número
     em [0, 1] (intervalo fechado), da amostra <lista>.  Embora exista
     muitas definições para quantil de uma amostra (Hyndman, R. J., Fan,
     Y. (1996) <Sample quantiles in statistical packages>.  American
     Statistician, 50, 361-365), aquela que se baseia em interpolação
     linear é a que foi implementada no pacote 'descriptive'.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) /* 1st and 3rd quartiles */ [quantile (s1, 1/4), quantile (s1, 3/4)], numer;
          (%o4)                      [2.0, 7.25]
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) quantile (s2, 1/4);
          (%o6)    [7.2575, 7.477500000000001, 7.82, 11.28, 11.48]

 -- Função: median (<lista>)
 -- Função: median (<matriz>)
     Uma vez que a amostra está ordenada, se o tamanho da amostra for
     ímpar a mediana é o valor central, de outra forma a mediana será a
     média dos dois valores centrais.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) median (s1);
                                          9
          (%o4)                           -
                                          2
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) median (s2);
          (%o6)         [10.06, 9.855, 10.73, 15.48, 14.105]

     A mediana é o 1/2-'quantil'.

     Veja também function 'quantile'.

 -- Função: qrange (<lista>)
 -- Função: qrange (<matriz>)
     A amplitude do interquartil é a diferença entre o terceiro e o
     primeiro quartil, 'quantile(<lista>,3/4) - quantile(<lista>,1/4)',

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) qrange (s1);
                                         21
          (%o4)                          --
                                         4
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) qrange (s2);
          (%o6) [5.385, 5.572499999999998, 6.0225, 8.729999999999999,
                                                         6.650000000000002]

     Veja também a função 'quantile'.

 -- Função: mean_deviation (<lista>)
 -- Função: mean_deviation (<matriz>)
     O desvio médio, definido como
                               n
                             ====
                         1   \          _
                         -    >    |x - x|
                         n   /       i
                             ====
                             i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) mean_deviation (s1);
                                         51
          (%o4)                          --
                                         20
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) mean_deviation (s2);
          (%o6) [3.287959999999999, 3.075342, 3.23907, 4.715664000000001,
                                                         4.028546000000002]

     Veja também a função 'mean'.

 -- Função: median_deviation (<lista>)
 -- Função: median_deviation (<matriz>)
     O desvio da mediana, definido como
                           n
                         ====
                     1   \
                     -    >    |x - med|
                     n   /       i
                         ====
                         i = 1
     onde 'med' é a mediana da <lista>.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) median_deviation (s1);
                                          5
          (%o4)                           -
                                          2
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) median_deviation (s2);
          (%o6)           [2.75, 2.755, 3.08, 4.315, 3.31]

     Veja também a função 'mean'.

 -- Função: harmonic_mean (<lista>)
 -- Função: harmonic_mean (<matriz>)
     A média harmônica, definida como
                            n
                         --------
                          n
                         ====
                         \     1
                          >    --
                         /     x
                         ====   i
                         i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i4) harmonic_mean (y), numer;
          (%o4)                   3.901858027632205
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) harmonic_mean (s2);
          (%o6) [6.948015590052786, 7.391967752360356, 9.055658197151745,
                                      13.44199028193692, 13.01439145898509]

     Veja também as funções 'mean' e 'geometric_mean'.

 -- Função: geometric_mean (<lista>)
 -- Função: geometric_mean (<matriz>)
     A média geométrica, definida como
                           /  n      \ 1/n
                           | /===\   |
                           |  ! !    |
                           |  ! !  x |
                           |  ! !   i|
                           | i = 1   |
                           \         /

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i4) geometric_mean (y), numer;
          (%o4)                   4.454845412337012
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) geometric_mean (s2);
          (%o6) [8.82476274347979, 9.22652604739361, 10.0442675714889,
                                      14.61274126349021, 13.96184163444275]

     Veja também as funções 'mean' e 'harmonic_mean'.

 -- Função: kurtosis (<lista>)
 -- Função: kurtosis (<matriz>)
     O coeficiente de curtose, definido como
                              n
                            ====
                      1     \          _ 4
                     ----    >    (x - x)  - 3
                        4   /       i
                     n s    ====
                            i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) kurtosis (s1), numer;
          (%o4)                  - 1.273247946514421
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) kurtosis (s2);
          (%o6) [- .2715445622195385, 0.119998784429451,
             - .4275233490482866, - .6405361979019522, - .4952382132352935]

     Veja também as funções 'mean', 'var' e 'skewness'.

 -- Função: skewness (<lista>)
 -- Função: skewness (<matriz>)
     O coeficiente de assimetria, definido como
                              n
                            ====
                      1     \          _ 3
                     ----    >    (x - x)
                        3   /       i
                     n s    ====
                            i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) skewness (s1), numer;
          (%o4)                  .009196180476450306
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) skewness (s2);
          (%o6) [.1580509020000979, .2926379232061854, .09242174416107717,
                                      .2059984348148687, .2142520248890832]

     Veja também as funções 'mean', 'var' e 'kurtosis'.

 -- Função: pearson_skewness (<lista>)
 -- Função: pearson_skewness (<matriz>)
     O coeficiente de assimetria de pearson, definido como
                          _
                       3 (x - med)
                       -----------
                            s
     onde <med> é a mediana de <lista>.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) pearson_skewness (s1), numer;
          (%o4)                   .2159484029093895
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) pearson_skewness (s2);
          (%o6) [- .08019976629211892, .2357036272952649,
                   .1050904062491204, .1245042340592368, .4464181795804519]

     Veja também as funções 'mean', 'var' e 'median'.

 -- Função: quartile_skewness (<lista>)
 -- Função: quartile_skewness (<matriz>)
     O coeficiented de assimetria do quartil, definido como
                         c    - 2 c    + c
                          3/4      1/2    1/4
                         --------------------
                             c    - c
                              3/4    1/4
     onde c_p é o quartil de ordem <p> da amostra <lista>.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) quartile_skewness (s1), numer;
          (%o4)                  .04761904761904762
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) quartile_skewness (s2);
          (%o6) [- 0.0408542246982353, .1467025572005382,
                 0.0336239103362392, .03780068728522298, 0.210526315789474]

     Veja também a função 'quantile'.


File: maxima.info,  Node: Funções e Variáveis Definidas específicas para estatística descritiva de várias variáveis,  Next: Funções e Variáveis Definidas para gráficos estatísticos,  Prev: Funções e Variáveis Definidas para estatística descritiva,  Up: descriptive

45.4 Funções e Variáveis Definidas específicas para estatística descritiva de várias variáveis
==============================================================================================

 -- Função: cov (<matriz>)
     A matriz de covariância da amostra de várias variáveis, definida
     como
                        n
                       ====
                    1  \           _        _
                S = -   >    (X  - X) (X  - X)'
                    n  /       j        j
                       ====
                       j = 1
     onde X_j é a j-ésima linha da matriz de amostra.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) fpprintprec : 7$  /* modifique a precisão para obter uma saída melhor */
          (%i5) cov (s2);
                [ 17.22191  13.61811  14.37217  19.39624  15.42162 ]
                [                                                  ]
                [ 13.61811  14.98774  13.30448  15.15834  14.9711  ]
                [                                                  ]
          (%o5) [ 14.37217  13.30448  15.47573  17.32544  16.18171 ]
                [                                                  ]
                [ 19.39624  15.15834  17.32544  32.17651  20.44685 ]
                [                                                  ]
                [ 15.42162  14.9711   16.18171  20.44685  24.42308 ]

     Veja também a função 'cov1'.

 -- Função: cov1 (<matriz>)
     A matriz de covariância da amostra de várias variáveis, definida
     como
                        n
                       ====
                   1   \           _        _
             S  = ---   >    (X  - X) (X  - X)'
              1   n-1  /       j        j
                       ====
                       j = 1
     where X_j is the j-th row of the sample matrix.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) fpprintprec : 7$ /* modifique a precisão para obter uma saída melhor */
          (%i5) cov1 (s2);
                [ 17.39587  13.75567  14.51734  19.59216  15.5774  ]
                [                                                  ]
                [ 13.75567  15.13913  13.43887  15.31145  15.12232 ]
                [                                                  ]
          (%o5) [ 14.51734  13.43887  15.63205  17.50044  16.34516 ]
                [                                                  ]
                [ 19.59216  15.31145  17.50044  32.50153  20.65338 ]
                [                                                  ]
                [ 15.5774   15.12232  16.34516  20.65338  24.66977 ]

     Veja também a função 'cov'.

 -- Função: global_variances (<matriz>)
 -- Função: global_variances (<matriz>, <valor_lógico>)
     A função 'global_variances' retorna uma lista de medidas de
     variância global:

        * <variância total>: 'trace(S_1)',
        * <variância média>: 'trace(S_1)/p',
        * <variância generalizada>: 'determinant(S_1)',
        * <desvio padrão generalizado>: 'sqrt(determinant(S_1))',
        * <variância efetiva> 'determinant(S_1)^(1/p)', (defined in:
          Peña, D. (2002) <Análisis de datos multivariantes>;
          McGraw-Hill, Madrid.)
        * <desvio padrão efetivo>: 'determinant(S_1)^(1/(2*p))'.
     onde <p> é a dimensão das várias variáveis aleatórias e S_1 a
     matriz de covariância retornada por 'cov1'.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) global_variances (s2);
          (%o4) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608502, 6.636590811800794, 2.576158149609762]

     A função 'global_variances' tem um argumento lógico opcional:
     'global_variances(x,true)' diz ao Maxima que 'x' é a matriz de
     dados, fazendo o mesmo que 'global_variances(x)'.  Por outro lado,
     'global_variances(x,false)' significa que 'x' não é a matriz de
     dados, mas a matriz de covariância, evitando a repetição seu
     cálculo,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) s : cov1 (s2)$
          (%i5) global_variances (s, false);
          (%o5) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608502, 6.636590811800794, 2.576158149609762]

     Veja também 'cov' e 'cov1'.

 -- Função: cor (<matriz>)
 -- Função: cor (<matriz>, <valor_lógico>)
     A matriz de correlação da maostra de várias variáveis.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) fpprintprec:7$
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) cor (s2);
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o5) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     A função 'cor' tem um argumento lógico opcional: 'cor(x,true)' diz
     ao Maxima que 'x' é a matriz de dados, fazendo o mesmo que
     'cor(x)'.  Por outro lado, 'cor(x,false)' significa que 'x' não é a
     matriz de dados, mas a matriz de covariância, evitando a repetição
     de seu cálculo,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) fpprintprec:7$
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) s : cov1 (s2)$
          (%i6) cor (s, false); /* this is faster */
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o6) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     Veja também 'cov' e 'cov1'.

 -- Função: list_correlations (<matriz>)
 -- Função: list_correlations (<matriz>, <valor_lógico>)
     A função 'list_correlations' retorna uma lista de medidas de
     correlação:

        * <matriz de precisão>: o inverso da matriz de covariância S_1,
                      -1     ij
                     S   = (s  )
                      1         i,j = 1,2,...,p

        * <vetor de correlação multipla>: (R_1^2, R_2^2, ..., R_p^2),
          com
                      2          1
                     R  = 1 - -------
                      i        ii
                              s   s
                                   ii
          sendo um indicador do melhor do ajuste do modelo de regressão
          linear de várias variáveis dobre X_i quando o resto das
          variáveis são usados como regressores.

        * <matriz de correlação parcial>: como elemento (i, j) sendo
                                        ij
                                       s
                     r        = - ------------
                      ij.rest     / ii  jj\ 1/2
                                  |s   s  |
                                  \       /

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) z : list_correlations (s2)$
          (%i5) fpprintprec : 5$ /* for pretty output */
          (%i6) z[1];  /* precision matrix */
                [  .38486   - .13856   - .15626   - .10239    .031179  ]
                [                                                      ]
                [ - .13856   .34107    - .15233    .038447   - .052842 ]
                [                                                      ]
          (%o6) [ - .15626  - .15233    .47296    - .024816  - .10054  ]
                [                                                      ]
                [ - .10239   .038447   - .024816   .10937    - .034033 ]
                [                                                      ]
                [ .031179   - .052842  - .10054   - .034033   .14834   ]
          (%i7) z[2];  /* multiple correlation vector */
          (%o7)       [.85063, .80634, .86474, .71867, .72675]
          (%i8) z[3];  /* partial correlation matrix */
                 [  - 1.0     .38244   .36627   .49908   - .13049 ]
                 [                                                ]
                 [  .38244    - 1.0    .37927  - .19907   .23492  ]
                 [                                                ]
          (%o8)  [  .36627    .37927   - 1.0    .10911    .37956  ]
                 [                                                ]
                 [  .49908   - .19907  .10911   - 1.0     .26719  ]
                 [                                                ]
                 [ - .13049   .23492   .37956   .26719    - 1.0   ]

     A função 'list_correlations' também tem um argumento lógico
     opcional: 'list_correlations(x,true)' diz ao Maxima que 'x' é a
     matriz de dados, fazendo o mesmo que 'list_correlations(x)'.  Por
     outro lado, 'list_correlations(x,false)' significa que 'x' não é a
     matriz de correlação, mas a matriz de covariancia, evitando a
     repetição de seu cálculo.

     Veja também 'cov' e 'cov1'.


File: maxima.info,  Node: Funções e Variáveis Definidas para gráficos estatísticos,  Prev: Funções e Variáveis Definidas específicas para estatística descritiva de várias variáveis,  Up: descriptive

45.5 Funções e Variáveis Definidas para gráficos estatísticos
=============================================================

 -- Função: dataplot (<lista>)
 -- Função: dataplot (<lista>, <opção_1>, <opção_2>, ...)
 -- Função: dataplot (<matriz>)
 -- Função: dataplot (<matriz>, <opção_1>, <opção_2>, ...)
     A função 'dataplot' permite visualização direta de dados de
     amostra, ambas d uma única variável (<lista>) e de várias variáveis
     (<matriz>).  Fornecendo valores para as seguintes <opções> que são
     alguns aspéctos de impressão que podem ser controlados:

        * ''outputdev', o valor padrão é '"x"', indica o formato de
          dispositivo/arquivo da figura de saída; valores corretos são
          '"x"', '"eps"' e '"png"', para a tela, formato de arquivo
          postscript e formato de arquivo png, respectivamente.

        * ''maintitle', o valor padrão é '""', é o título principal
          entre aspas duplas.

        * ''axisnames', o valor padrão é '["x","y","z"]', é uma lista de
          nomes dos eixos 'x', 'y' e 'z'.

        * ''joined', o valor padrão é 'false', um valor lógico para
          selecionar pontos em 2D para serem unidos ou isolados.

        * ''picturescales', o valor padrão é '[1.0, 1.0]', fator de
          proporcionalidade para o tamanho do gráfico.

        * ''threedim', o valor padrão é 'true', diz ao Maxima se ou
          monta-se o gráfico de uma matriz de três colunas como um
          diagrama 3D ou se monta-se o gráfico como um diagrama de
          dispersão de várias variáveis.  Veja exemplos abaixo.

        * ''axisrot', o valor padrão é '[60, 30]', modifica o ponto de
          visualização quando ''threedim' for escolhido para 'true'
          dados forem armazenados em uma matriz de três colunas.  O
          primeiro número é o ângulo de rotação do eixo <x>, e o segundo
          número é o angulo de rotação do eixo <z>-axis, ambas as
          medidas em graus.

        * ''nclasses', o valor padrão é '10', é o número de classes para
          histogramas na diagonal de gráficos de dispersão de várias
          variáveis.

        * ''pointstyle', o valor padrão é '1', é um inteiro que indica
          como mostrar pontos de amostra.

     Por exemplo, com a seguite entrada um gráfico simples dos primeiros
     vinte dígitos de '%pi' é requisitado e a saída é armazenada em um
     arquivo no formato eps.

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) dataplot (makelist (s1[k], k, 1, 20), 'pointstyle = 3)$

     Note que dados unidimensionais são colocados no gráfico como uma
     série de tempo.  No caso seguinte, ocorre a mesma coisa só que com
     mais dados e com mais configurações,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) dataplot (makelist (s1[k], k, 1, 50), 'maintitle = "Primeiros dígitos de pi",
           'axisnames = ["ordem do dígito", "valor do dígito"], 'pointstyle = 2,
           'joined = true)$

     A função 'dataplot' pode ser usada para montar gráficos de pontos
     no plano.  O exemplo seguinte é gráfico de dispersão de pares de
     pontos de velocidades de vento para o primeira e para o quinta
     estação meteorológica,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) dataplot (submatrix (s2, 2, 3, 4), 'pointstyle = 2,
           'maintitle = "Pares de medidas de velocidade do vento em nós",
           'axisnames = ["Velocidade do vento em A", "Velocidade do vento em E"])$

     Se pontos forem armazenados em uma matriz de duas colunas,
     'dataplot' pode montar o gráfico desses pontos diretamente, mas se
     eles forem formatados em uma lista de pares, essa lista deve ser
     transformada em uma matriz como no seguinte exemplo.

          (%i1) load (descriptive)$
          (%i2) x : [[-1, 2], [5, 7], [5, -3], [-6, -9], [-4, 6]]$
          (%i3) dataplot (apply ('matrix, x), 'maintitle = "Pontos",
           'joined = true, 'axisnames = ["", ""], 'picturescales = [0.5, 1.0])$

     Pontos no espaço tridimensional podem ser vistos como uma projeção
     no plano.  Nesse exemplo, o gráfico de velocidades do vento
     correspondendo a três estações meteorológicas são requisitados,
     primeiramente em um gráfico em 3D e a seguir em um gráfico de
     dispers@~ao de várias variáveis.

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) /* 3D plot */ dataplot (submatrix (s2, 4, 5), 'pointstyle = 2,
           'maintitle = "Pares de medidas de velocidades do vento em nós",
           'axisnames = ["Estação A", "Estação B", "Estação C"])$
          (%i5) /* Gráfico de dispersão de várias variáveis */ dataplot (submatrix (s2, 4, 5),
           'nclasses = 6, 'threedim = false)$
     Note que no último exemplo, o número de classes no histogramas da
     diagonal é escolhido para 6, e aquela opção ''threedim' for
     escolhida para 'false'.

     Para mais que três dimensões somente gráficos de dispersão de
     várias variáveis são possível, como em

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) dataplot (s2)$

 -- Função: histogram (<lista>)
 -- Função: histogram (<lista>, <opção_1>, <opção_2>, ...)
 -- Função: histogram (<one_column_matrix>)
 -- Função: histogram (<one_column_matrix>, <opção_1>, <opção_2>, ...)
     Essa função monta um gráfico de um histograma.  Dados de amostras
     devem ser armazenados em uma lista de números ou em uma matriz de
     uma coluna.  Fornecendo valores para as seguintes <opções> alguns
     aspéctos do gráfico podem ser controlados:

        * ''outputdev', o valor padrão é '"x"', indica o formato de
          arquivo da figura de saída; valores corretos são '"x"',
          '"eps"' e '"png"', para a tela, formato de arquivo postscript
          e formato de arquivo png, respectivamente.

        * ''maintitle', o valor padrão é '""', é o título principal
          entre aspas duplas.

        * ''axisnames', o valor padrão é '["x", "Fr."]', é uma lista de
          nomes dos eixos 'x' e 'y'.

        * ''picturescales', o valor padrão é '[1.0, 1.0]', fator de
          proporcionalidade para o tamanho do gráfico.

        * ''nclasses', o valor padrão é '10', é o número de classes ou o
          número de barras.

        * ''relbarwidth', o valor padrão é '0.9', um número decimao
          entre 0 e 1 para controlar a largura das barras.

        * ''barcolor', o valor padrão é '1', um inteiro para indicar a
          cor das barras.

        * ''colorintensity', o valor padrão é '1', um número decimal
          entre 0 e 1 para estabelecer a intensidade da cor.

     Nos próximos dois exemplos, histogramas são requisitados para os
     primeiros 100 dígitos do número '%pi' e para velocidades do vento
     na terceira estação meteorológica.

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) histogram (s1, 'maintitle = "dígitos de pi", 'axisnames = ["", "Freqüência absoluta"],
           'relbarwidth = 0.2, 'barcolor = 3, 'colorintensity = 0.6)$
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) histogram (col (s2, 3), 'colorintensity = 0.3)$
     Note tque no primeiro caso, 's1' é uma lista e o segundo exemplo,
     'col(s2,3)' é uma matriz.

     Veja também a função 'barsplot'.

 -- Função: barsplot (<lista>)
 -- Função: barsplot (<lista>, <opção_1>, <opção_2>, ...)
 -- Função: barsplot (<one_column_matrix>)
 -- Função: barsplot (<one_column_matrix>, <opção_1>, <opção_2>, ...)
     Similar a 'histogram' mas para variáveis estatísticas, numéricas ou
     divididas em categorias.  As opções estão abaixo,

        * ''outputdev', o valor padrão é '"x"', indica o formato de
          arquivo da figura de saída; valores corretos são '"x"',
          '"eps"' e '"png"', para a tela, formato de arquivo postscript
          e formato de arquivo png, respectivamente.

        * ''maintitle', o valor padrão é '""', é o título principal
          entre aspas duplas.

        * ''axisnames', o valor padrão é '["x", "Fr."]', é uma lista de
          nomes dos eixos 'x' e 'y'.

        * ''picturescales', o valor padrão é '[1.0, 1.0]', fator de
          proporcionalidade para o tamanho do gráfico.

        * ''relbarwidth', o valor padrão é '0.9', um número decimao
          entre 0 e 1 para controlar a largura das barras.

        * ''barcolor', o valor padrão é '1', um inteiro para indicar a
          cor das barras.

        * ''colorintensity', o valor padrão é '1', um número decimal
          entre 0 e 1 para estabelecer a intensidade da cor.

     Esse exemplo monta um gráfico de barras para os grupos 'A' e 'B' de
     pacientes na amostra 's3',

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) barsplot (col (s3, 1), 'maintitle = "Grupos de pacientes",
           'axisnames = ["Grupo", "# de indivíduos"], 'colorintensity = 0.2)$
     A primeira coluna na amostra 's3' armazena os valores das
     categorias 'A' e 'B', também conhecidos algumas vezes como fatores.
     Por outro lado, os números inteiros positivos na segunda coluna sào
     idades, em anos, que se comportam como variável discreta, então
     podemos montar um gráfico as freqüências absolutas para esses
     valores,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) barsplot (col (s3, 2), 'maintitle = "Idades",
           'axisnames = ["Anos", "# dos indivíduos"], 'colorintensity = 0.2,
           'relbarwidth = 0.6)$

     Veja também a função 'histogram'.

 -- Função: boxplot (<data>)
 -- Função: boxplot (<data>, <opção_1>, <opção_2>, ...)
     Essa função monta diagramas em caixas.  O argumento <data> pode ser
     uma lista, que não é de grande interesse, uma vez que esses
     diagramas são principalmente usados para comparação entre
     diferentes amostras, ou uma matriz, eentão é possível comparar dois
     ou mais componentes de uma variável estatística de várias
     variáveis.  Mas é também permitido <data> se uma lista de amostras
     com tamanhos diferentes de amostra, de fato essa é aa única função
     no pacote 'descriptive' que admite esse tipo de estrutura de dados.
     Veja o exemplo abaixo.  Abaixo etão as opções,

        * ''outputdev', o valor padrão é '"x"', indica o formato de
          arquivo da figura de saída; valores corretos são '"x"',
          '"eps"' e '"png"', para a tela, formato de arquivo postscript
          e formato de arquivo png, respectivamente.

        * ''maintitle', o valor padrão é '""', é o título principal
          entre aspas duplas.

        * ''axisnames', o valor padrão é '["sample", "y"]', é uma lista
          de nomes dos eixos 'x' e 'y'.

        * ''picturescales', o valor padrão é '[1.0, 1.0]', fator de
          proporcionalidade para o tamanho do gráfico.

     Examples:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) boxplot (s2, 'maintitle = "Velocidade do vento em nós",
           'axisnames = ["Estação do ano", ""])$
          (%i5) A :
           [[6, 4, 6, 2, 4, 8, 6, 4, 6, 4, 3, 2],
            [8, 10, 7, 9, 12, 8, 10],
            [16, 13, 17, 12, 11, 18, 13, 18, 14, 12]]$
          (%i6) boxplot (A)$


File: maxima.info,  Node: diag,  Next: distrib,  Prev: descriptive,  Up: Top

46 diag
*******

* Menu:

* Funções e Variáveis Definidas para diag::


File: maxima.info,  Node: Funções e Variáveis Definidas para diag,  Prev: diag,  Up: diag

46.1 Funções e Variáveis Definidas para diag
============================================

 -- Função: diag (<lm>)
     Constrói a matriz quadrada com as matrizes de <lm> na diagonal.
     <lm> é uma lista de matrizes ou escalares.

     Exemplo:
          (%i1) load("diag")$

          (%i2) a1:matrix([1,2,3],[0,4,5],[0,0,6])$

          (%i3) a2:matrix([1,1],[1,0])$

          (%i4) diag([a1,x,a2]);
                             [ 1  2  3  0  0  0 ]
                             [                  ]
                             [ 0  4  5  0  0  0 ]
                             [                  ]
                             [ 0  0  6  0  0  0 ]
          (%o4)              [                  ]
                             [ 0  0  0  x  0  0 ]
                             [                  ]
                             [ 0  0  0  0  1  1 ]
                             [                  ]
                             [ 0  0  0  0  1  0 ]

     Para usar essa função escreva primeiramente 'load("diag")'.

 -- Função: JF (<lambda>,<n>)
     Retorna a célula de Jordan de ordem <n> com autovalor <lambda>.

     Exemplo:
          (%i1) load("diag")$

          (%i2) JF(2,5);
                              [ 2  1  0  0  0 ]
                              [               ]
                              [ 0  2  1  0  0 ]
                              [               ]
          (%o2)               [ 0  0  2  1  0 ]
                              [               ]
                              [ 0  0  0  2  1 ]
                              [               ]
                              [ 0  0  0  0  2 ]
          (%i3) JF(3,2);
                                   [ 3  1 ]
          (%o3)                    [      ]
                                   [ 0  3 ]

     Para usar essa função escreva primeiramente 'load("diag")'.

 -- Função: jordan (<mat>)
     Retorna a forma de Jordan da matriz <mat>, mas codificada em uma
     lista do Maxima.  Para pegar a matriz correspondente à codificação,
     chame a função 'dispJordan' sando como argumento a saída de 'JF'.

     Exemplo:
          (%i1) load("diag")$

          (%i3) a:matrix([2,0,0,0,0,0,0,0],
                         [1,2,0,0,0,0,0,0],
                         [-4,1,2,0,0,0,0,0],
                         [2,0,0,2,0,0,0,0],
                         [-7,2,0,0,2,0,0,0],
                         [9,0,-2,0,1,2,0,0],
                         [-34,7,1,-2,-1,1,2,0],
                         [145,-17,-16,3,9,-2,0,3])$

          (%i34) jordan(a);
          (%o4)             [[2, 3, 3, 1], [3, 1]]
          (%i5) dispJordan(%);
                          [ 2  1  0  0  0  0  0  0 ]
                          [                        ]
                          [ 0  2  1  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  2  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  0  2  1  0  0  0 ]
          (%o5)           [                        ]
                          [ 0  0  0  0  2  1  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  2  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  2  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  0  3 ]

     Para usar essa função escreva primeiramente 'load("diag")'.  Veja
     também 'dispJordan' e 'minimalPoly'.

 -- Função: dispJordan (<l>)
     Retorna a matriz de Jordan associada à codificação fornecida pela
     lista do Maxima <l>, que é a saída fornecida pela função 'jordan'.

     Exemplo:
          (%i1) load("diag")$

          (%i2) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i3) jordan(b1);
          (%o3)                  [[0, 3, 2]]
          (%i4) dispJordan(%);
                              [ 0  1  0  0  0 ]
                              [               ]
                              [ 0  0  1  0  0 ]
                              [               ]
          (%o4)               [ 0  0  0  0  0 ]
                              [               ]
                              [ 0  0  0  0  1 ]
                              [               ]
                              [ 0  0  0  0  0 ]

     Para usar essa função escreva primeiramente 'load("diag")'.  Veja
     também 'jordan' e 'minimalPoly'.

 -- Função: minimalPoly (<l>)
     Retorna o menor polinômio associado à codificação fornecida pela
     lista do Maxima <l>, que é a saída fornecida pela função 'jordan'.

     Exemplo:
          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                         [-2,2,1,2],
                         [-2,-1,-1,1],
                         [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) minimalPoly(%);
                                      3
          (%o4)                (x - 1)  (x + 1)

     Para usar essa função escreva primeiramente 'load("diag")'.  Veja
     também 'jordan' e 'dispJordan'.

 -- Função: ModeMatrix (<A>,<l>)
     Retorna a matriz <M> tal que (M^^-1).A.M=J, onde <J> é a forma de
     Jordan de <A>.  A lista do Maxima <l> é a codificação da forma de
     Jordan como retornado pela função 'jordan'.

     Exemplo:
          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                    [-2,2,1,2],
                    [-2,-1,-1,1],
                    [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) M: ModeMatrix(a,%);
                            [  1    - 1   1   1 ]
                            [                   ]
                            [   1               ]
                            [ - -   - 1   0   0 ]
                            [   9               ]
                            [                   ]
          (%o4)             [   13              ]
                            [ - --   1   - 1  0 ]
                            [   9               ]
                            [                   ]
                            [  17               ]
                            [  --   - 1   1   1 ]
                            [  9                ]
          (%i5) is(  (M^^-1).a.M = dispJordan(%o3)  );
          (%o5)                      true
     Note que 'dispJordan(%o3)' é a forma de Jordan da matriz 'a'.

     Para usa essa função escreva primeiramente 'load("diag")'.  Veja
     também 'jordan' e 'dispJordan'.

 -- Função: mat_function (<f>,<mat>)
     Retorna f(mat), onde <f> é uma função analítica e <mat> uma matriz.
     Essa computação é baseada na fórmula da integral de Cauchy, que
     estabelece que se 'f(x)' for analítica e

          mat=diag([JF(m1,n1),...,JF(mk,nk)]),

     então

          f(mat)=ModeMatrix*diag([f(JF(m1,n1)),...,f(JF(mk,nk))])*ModeMatrix^^(-1)

     Note que existem entre 6 ou 8 outros métodos para esse cálculo.

     Segue-se alguns exemplos.

     Exemplo 1:
          (%i1) load("diag")$

          (%i2) b2:matrix([0,1,0], [0,0,1], [-1,-3,-3])$

          (%i3) mat_function(exp,t*b2);
                         2   - t
                        t  %e          - t     - t
          (%o3) matrix([-------- + t %e    + %e   ,
                           2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) + t (2 %e    - -----)
                  t       2                             t
                         t
                                   - t          - t     - t
                 - t       - t   %e        2  %e      %e
           + 2 %e   , t (%e    - -----) + t  (----- - -----)
                                   t            2       t
                         2   - t            - t     - t
               - t      t  %e        2    %e      %e        - t
           + %e   ], [- --------, - t  (- ----- - ----- + %e   ),
                           2                t       2
                                                   t
                  - t     - t      2   - t
             2  %e      %e        t  %e          - t
          - t  (----- - -----)], [-------- - t %e   ,
                  2       t          2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) - t (2 %e    - -----),
                  t       2                             t
                         t
                - t     - t                 - t
           2  %e      %e            - t   %e
          t  (----- - -----) - t (%e    - -----)])
                2       t                   t
          (%i4) ratsimp(%);
                         [   2              - t ]
                         [ (t  + 2 t + 2) %e    ]
                         [ -------------------- ]
                         [          2           ]
                         [                      ]
                         [         2   - t      ]
          (%o4)  Col 1 = [        t  %e         ]
                         [      - --------      ]
                         [           2          ]
                         [                      ]
                         [     2          - t   ]
                         [   (t  - 2 t) %e      ]
                         [   ----------------   ]
                         [          2           ]
                   [      2        - t    ]
                   [    (t  + t) %e       ]
                   [                      ]
           Col 2 = [     2            - t ]
                   [ - (t  - t - 1) %e    ]
                   [                      ]
                   [     2          - t   ]
                   [   (t  - 3 t) %e      ]
                   [        2   - t       ]
                   [       t  %e          ]
                   [       --------       ]
                   [          2           ]
                   [                      ]
                   [      2          - t  ]
           Col 3 = [    (t  - 2 t) %e     ]
                   [  - ----------------  ]
                   [           2          ]
                   [                      ]
                   [   2              - t ]
                   [ (t  - 4 t + 2) %e    ]
                   [ -------------------- ]
                   [          2           ]

     Exemplo 2:
          (%i5) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i6) mat_function(exp,t*b1);
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o6)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i7) minimalPoly(jordan(b1));
                                       3
          (%o7)                       x
          (%i8) ident(5)+t*b1+1/2*(t^2)*b1^^2;
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o8)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i9) mat_function(exp,%i*t*b1);
                       [                           2 ]
                       [                          t  ]
                       [ 1  0  %i t  %i t  %i t - -- ]
                       [                          2  ]
                       [                             ]
          (%o9)        [ 0  1   0    %i t    %i t    ]
                       [                             ]
                       [ 0  0   1     0      %i t    ]
                       [                             ]
                       [ 0  0   0     1        0     ]
                       [                             ]
                       [ 0  0   0     0        1     ]
          (%i10) mat_function(cos,t*b1)+%i*mat_function(sin,t*b1);
                        [                           2 ]
                        [                          t  ]
                        [ 1  0  %i t  %i t  %i t - -- ]
                        [                          2  ]
                        [                             ]
          (%o10)        [ 0  1   0    %i t    %i t    ]
                        [                             ]
                        [ 0  0   1     0      %i t    ]
                        [                             ]
                        [ 0  0   0     1        0     ]
                        [                             ]
                        [ 0  0   0     0        1     ]

     Exemplo 3:
          (%i11) a1:matrix([2,1,0,0,0,0],
                           [-1,4,0,0,0,0],
                           [-1,1,2,1,0,0],
                           [-1,1,-1,4,0,0],
                           [-1,1,-1,1,3,0],
                           [-1,1,-1,1,1,2])$

          (%i12) fpow(x):=block([k],declare(k,integer),x^k)$

          (%i13) mat_function(fpow,a1);
                          [  k      k - 1 ]         [      k - 1    ]
                          [ 3  - k 3      ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [  k      k - 1 ]
                          [  - k 3        ]         [ 3  + k 3      ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
          (%o13)  Col 1 = [               ] Col 2 = [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [  k      k - 1 ]         [      k - 1    ]
                   [ 3  - k 3      ]         [   k 3         ]
                   [               ]         [               ]
           Col 3 = [       k - 1   ] Col 4 = [  k      k - 1 ]
                   [  - k 3        ]         [ 3  + k 3      ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [    0    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
           Col 5 = [    0    ] Col 6 = [    ]
                   [         ]         [ 0  ]
                   [    k    ]         [    ]
                   [   3     ]         [ 0  ]
                   [         ]         [    ]
                   [  k    k ]         [  k ]
                   [ 3  - 2  ]         [ 2  ]

     Para usar essa função escreva primeiramente 'load("diag")'.


File: maxima.info,  Node: distrib,  Next: draw,  Prev: diag,  Up: Top

47 distrib
**********

* Menu:

* Introdução a distrib::
* Funções e Variáveis Definidas para distribuições contínuas::
* Funções e Variáveis Definidas para distribuições discretas::


File: maxima.info,  Node: Introdução a distrib,  Next: Funções e Variáveis Definidas para distribuições contínuas,  Prev: distrib,  Up: distrib

47.1 Introdução a distrib
=========================

Pacote 'distrib' contém um conjunto de funções para fazer cálculos
envolvendo probabilidades de modelos de uma única variável estatística e
de ambos os tipos discreta e contínua.

   O que segue é um curto resumo de definiçoes básicas relacionadas à
teoria das probabilidades.

   Seja f(x) a <função densidade de probabilidade> absoluta de uma
variável aleatória contínua X.  A <função distribuição de probabilidade>
é definida como
                            x
                           /
                           [
                    F(x) = I     f(u) du
                           ]
                           /
                            minf
   que é igual à probabilidade <Pr(X <= x)>.

   O valor <médio> é um parâmetro de localização e está definido como
                          inf
                         /
                         [
                E[X]  =  I   x f(x) dx
                         ]
                         /
                          minf

   A <variância> é uma medida de variação,
                      inf
                     /
                     [                    2
              V[X] = I     f(x) (x - E[X])  dx
                     ]
                     /
                      minf
   que é um número real positivo.  A raíz quadrada da variância é o
<desvio padrão>, D[X]=sqrt(V[X]), e esse <desvio padrão> é outra medida
de variação.

   O <coeficiente de assimetria> é uma medida de não simetria,
                      inf
                     /
                 1   [                    3
       SK[X] = ----- I     f(x) (x - E[X])  dx
                   3 ]
               D[X]  /
                      minf

   E o <coeficiente de curtose> mede o grau de achatamento de uma
distribuição,
                      inf
                     /
                 1   [                    4
       KU[X] = ----- I     f(x) (x - E[X])  dx - 3
                   4 ]
               D[X]  /
                      minf
   Se X for gaussiana, KU[X]=0.  De fato, ambos assimetria e curtose são
parâmetros de ajuste usados para medir a não gaussianidade de uma
distribuição.

   Se a variável aleatória X for discreta, a função densidade de
probabilidade, ou simplesmente <probabilidade>, f(x) toma valores
positivos dentro de certos conjuntos contáveis de números x_i, e zero em
caso contrário.  Nesse caso, a função distribuição de probabilidade é
                            ====
                            \
                     F(x) =  >    f(x )
                            /        i
                            ====
                           x <= x
                            i

   A média, variância, desvio padrão, coeficiente de assimetria e
coeficiente de curtose tomam a forma
                            ====
                            \
                     E[X] =  >  x  f(x ) ,
                            /    i    i
                            ====
                             x
                              i

                     ====
                     \                     2
             V[X] =   >    f(x ) (x - E[X])  ,
                     /        i    i
                     ====
                      x
                       i

                    D[X] = sqrt(V[X]),

                          ====
                   1      \                     3
       SK[X] =  -------    >    f(x ) (x - E[X])
                D[X]^3    /        i    i
                          ====
                           x
                            i
   and
                          ====
                   1      \                     4
       KU[X] =  -------    >    f(x ) (x - E[X])   - 3 ,
                D[X]^4    /        i    i
                          ====
                           x
                            i
   respectively.

   O Pacote 'distrib' inclui funções para simulação de variáveis
estatísticas pseudo-aleatórias.  Algumas dessas funções fazem uso de
variáveis opcionais que indicam o algorítmo a ser usado.  O método
inverso genérico (baseado no fato que se <u> for um número aleatório
uniforme no intervalo (0,1), então <F^(-1)(u)> é uma variável
estatística pseudo-aleatória com distribuição F) está implementada para
a maioria dos casos; isso é um método subótimo em termos de
cronometragem, mas útil para fazer comparações com outros algorítmos.
Nesse exemplo, a 'perandom_formance' dos algorítmos 'ahrens_cheng' e
'inverse' em simular variáveis chi-quadradas (letra grega "chi") são
comparadas por meio de seus histogramas:

     (%i1) load(distrib)$
     (%i2) load(descriptive)$
     (%i3) showtime: true$
     Evaluation took 0.00 seconds (0.00 elapsed) using 32 bytes.
     (%i4) random_chi2_algorithm: 'ahrens_cheng$ histogram(random_chi2(10,500))$
     Evaluation took 0.00 seconds (0.00 elapsed) using 40 bytes.
     Evaluation took 0.69 seconds (0.71 elapsed) using 5.694 MB.
     (%i6) random_chi2_algorithm: 'inverse$ histogram(random_chi2(10,500))$
     Evaluation took 0.00 seconds (0.00 elapsed) using 32 bytes.
     Evaluation took 10.15 seconds (10.17 elapsed) using 322.098 MB.

   Com o objetivo de fazer comparações visuais entre algorítmos para uma
variável estatística discreta, a função 'barsplot' do pacote
'descriptive' pode ser usada.

   Note que algum trabalho resta para ser realizado, uma vez que essas
funções de simulação não foram ainda verificadas pelos mais
rigorosamente melhores dos testes de ajuste.

   Por favor, consulte um manual introdutório sobre probabilidade e
estatística para maiores informações sobre todo esse material
matemático.

   Existe uma convenção de nome no pacote 'distrib'.  Todo nome de
função tem duas partes, a primeira faz referência à função ou ao
parâmetro que queremos calcular,
     Funções:
        função densidade de probabilidade            (pdf_*)
        função distribuição de probabilidade       (cdf_*)
        Quartil                    (quantile_*)
        Média                        (mean_*)
        Variância                    (var_*)
        Desvio padrão          (std_*)
        Coeficiente de assimetria        (skewness_*)
        Coeficiente de curtose        (kurtosis_*)
        Variável estatística pseudo-aleatória              (random_*)

   A segunda parte é uma referência explícita ao modelo probabilístico,
     Distribuíções contínuas:
        Normal              (*normal)
        Student             (*student_t)
        Chi^2               (*chi2)
        F                   (*f)
        Exponencial         (*exp)
        Lognormal           (*lognormal)
        Gama               (*gamma)
        Beta                (*beta)
        contínua uniforme  (*continuous_uniform)
        Logística            (*logistic)
        Pareto              (*pareto)
        Weibull             (*weibull)
        Rayleigh            (*rayleigh)
        Laplace             (*laplace)
        Cauchy              (*cauchy)
        Gumbel              (*gumbel)

     Distribuições discretas:
        Binomial             (*binomial)
        Poisson              (*poisson)
        Bernoulli            (*bernoulli)
        Geométrica            (*geometric)
        discreta uniforme     (*discrete_uniform)
        hipergeométrica       (*hypergeometric)
        Binomial Negativa    (*negative_binomial)

   Por exemplo, 'pdf_student_t(x,n)' é a função densidade de
probabilidade da distribuição de Student com <n> graus de liberdade,
'std_pareto(a,b)' é o desvio padrão da distribuição de Pareto com
parâmetros <a> e <b> e 'kurtosis_poisson(m)' é o coeficiente de curtose
da distribuição de Poisson com média <m>.

   Com o objetivo de fazer uso do pacote 'distrib' você precisa primeiro
tornar esse pacote disponível para uso escrevendo
     (%i1) load(distrib)$

   Para comentários, melhorias ou sugestões, por favor contacte o autor
em <'mario AT edu DOT xunta DOT es'>.


File: maxima.info,  Node: Funções e Variáveis Definidas para distribuições contínuas,  Next: Funções e Variáveis Definidas para distribuições discretas,  Prev: Introdução a distrib,  Up: distrib

47.2 Funções e Variáveis Definidas para distribuições contínuas
===============================================================

 -- Função: pdf_normal (<x>,<m>,<s>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Normal(m,s), com s>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_normal (<x>,<m>,<s>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Normal(m,s), com s>0.  Essa função é
     definida em termos de funções de erro internas do Maxima, 'erf'.

          (%i1) load (distrib)$
          (%i2) assume(s>0)$ cdf_normal(x,m,s);
                                       x - m
                                 erf(---------)
                                     sqrt(2) s    1
          (%o3)                  -------------- + -
                                       2          2

     Veja também 'erf'.

 -- Função: quantile_normal (<q>,<m>,<s>)
     Retorna o <q>-quantil de uma variável aleatória Normal(m,s), com
     s>0; em outras palavras, isso é o inverso de 'cdf_normal'.  O
     argumento <q> deve ser um elemento de [0,1].  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_normal (<m>,<s>)
     Retorna a média de uma variável aleatória Normal(m,s), com s>0, a
     saber <m>.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: var_normal (<m>,<s>)
     Retorna a variância de uma variável aleatória Normal(m,s), com s>0,
     a saber <s^2>.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: std_normal (<m>,<s>)
     Retorna o desvio padrão de uma variável aleatória Normal(m,s), com
     s>0, a saber <s>.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: skewness_normal (<m>,<s>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Normal(m,s), com s>0, que é sempre igual a 0.  Para fazer uso dessa
     função,escreva primeiramente 'load(distrib)'.

 -- Função: kurtosis_normal (<m>,<s>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Normal(m,s), com s>0, que é sempre igual a 0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Variável de opção: random_normal_algorithm
     Valor padrão: 'box_mueller'

     Esse é o algorítmo selecionado para simular variáveis aleatórias
     normais.  O algorítmos implementados são 'box_mueller' e 'inverse':
        * 'box_mueller', Baseado no algorítmo descrito em Knuth, D.E.
          (1981) <Seminumerical Algorithms.  The Art of Computer
          Programming.> Addison-Wesley.

        * 'inverse', baseado no método inverso genérico.

     Veja também 'random_normal'.

 -- Função: random_normal (<m>,<s>)
 -- Função: random_normal (<m>,<s>,<n>)
     Retorna uma variável estatística pseudo-aleatória Normal(m,s), com
     s>0.  Chamando 'random_normal' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Existem dois algorítmos implementados para essa função, e o
     algorítmo a ser usado pode ser selecionado fornecendo um certo
     valor para a variável global 'random_normal_algorithm', cujo valor
     padrão é 'box_mueller'.

     Veja também 'random_normal_algorithm'.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_student_t (<x>,<n>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória de Student t(n), com n>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_student_t (<x>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória de Student t(n), com n>0.  Essa função não
     tem uma forma definitiva e é calculada numericamente se a variável
     global 'numer' for igual a 'true', de outra froma 'cdf_student_t'
     retorna uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_student_t(1/2, 7/3);
                                               1  7
          (%o2)                  cdf_student_t(-, -)
                                               2  3
          (%i3) %,numer;
          (%o3)                   .6698450596140417

 -- Função: quantile_student_t (<q>,<n>)
     Retorna o <q>-quantil de uma variável aleatória de Student t(n),
     com n>0; em outras palavras, 'quantile_student_t' é o inverso de
     'cdf_student_t'.  O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_student_t (<n>)
     Retorna a média de uma variável aleatória de Student t(n), com n>0,
     que é sempre igual a 0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: var_student_t (<n>)
     Retorna a variância de uma variável aleatória de Student t(n), com
     n>2.

          (%i1) load (distrib)$
          (%i2) assume(n>2)$  var_student_t(n);
                                          n
          (%o3)                         -----
                                        n - 2

 -- Função: std_student_t (<n>)
     Retorna o desvio padrão de uma variável aleatória de Student t(n),
     com n>2.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_student_t (<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória de
     Student t(n), com n>3, que é sempre igual a 0.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: kurtosis_student_t (<n>)
     Retorna o coeficiente de curtose de uma variável aleatória de
     Student t(n), com n>4.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Variável de opção: random_student_t_algorithm
     Valor padrão: 'ratio'

     Esse é o algorítmo selecionado para simular variáveis estatísticas
     pseudo-aleatórias de Student.  Algorítmos implementados são
     'inverse' e 'ratio':
        * 'inverse', baseado no método inverso genérico.

        * 'ratio', baseado no fato que se <Z> for uma variável aleatória
          normal N(0,1) e S^2 for uma variável aleatória chi quadrada
          com <n> graus de liberdade, Chi^2(n), então
                                          Z
                                X = -------------
                                    /   2  \ 1/2
                                    |  S   |
                                    | ---  |
                                    \  n   /
          é uma variável aleatória de Student com <n> graus de
          liberdade, t(n).

     Veja também 'random_student_t'.

 -- Função: random_student_t (<n>)
 -- Função: random_student_t (<n>,<m>)
     Retorna uma variável estatística pseudo-aleatória de Student t(n),
     com n>0.  Chamando 'random_student_t' com um segundo argumento <m>,
     uma amostra aleatória de tamanho <m> será simulada.

     Existem dois algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global 'random_student_t_algorithm', cujo valor padrão é
     'ratio'.

     Veja também 'random_student_t_algorithm'.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_chi2 (<x>,<n>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Chi-quadrada Chi^2(n), com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2),
     portanto quando Maxima não tiver informação para pegar o resultado,
     uma forma nomial baseada na função de densidade densidade de
     probabilidade da função gama é retornada.

          (%i1) load (distrib)$
          (%i2) pdf_chi2(x,n);
                                              n
          (%o2)                  pdf_gamma(x, -, 2)
                                              2
          (%i3) assume(x>0, n>0)$  pdf_chi2(x,n);
                                   n/2 - 1   - x/2
                                  x        %e
          (%o4)                   ----------------
                                    n/2       n
                                   2    gamma(-)
                                              2

 -- Função: cdf_chi2 (<x>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Chi-quadrada Chi^2(n), com n>0.

     Essa função não possui uma forma fechada e é calculada
     numericamante se a variável global 'numer' for igual a 'true', de
     outra forma essa função retorna uma expressão nominal baseada na
     distribuição gama, uma vez que a variável aleatória Chi^2(n) é
     equivalente a é equivalente a Gamma(n/2,2).

          (%i1) load (distrib)$
          (%i2) cdf_chi2(3,4);
          (%o2)                  cdf_gamma(3, 2, 2)
          (%i3) cdf_chi2(3,4),numer;
          (%o3)                   .4421745996289249

 -- Função: quantile_chi2 (<q>,<n>)
     Retorna o <q>-quantilede uma variável aleatória Chi-quadrada
     Chi^2(n), com n>0; em outras palavras, essa função é a inversa da
     função 'cdf_chi2'.  O argumento <q> deve ser um elemento de [0,1].

     This função não possui uma forma fechada e é calculada
     numericamante se a variável global 'numer' for igual a 'true', de
     outra forma essa função retorna uma expressão nominal baseada no
     quantil da função gama, uma vez que a variável aleatória Chi^2(n) é
     equivalente a Gamma(n/2,2).

          (%i1) load (distrib)$
          (%i2) quantile_chi2(0.99,9);
          (%o2)                   21.66599433346194
          (%i3) quantile_chi2(0.99,n);
                                                  n
          (%o3)              quantile_gamma(0.99, -, 2)
                                                  2

 -- Função: mean_chi2 (<n>)
     Retorna a média de uma variável aleatória Chi-quadrada Chi^2(n),
     com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na média da função gama é
     retornada.

          (%i1) load (distrib)$
          (%i2) mean_chi2(n);
                                             n
          (%o2)                   mean_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ mean_chi2(n);
          (%o4)                           n

 -- Função: var_chi2 (<n>)
     Retorna a variância de uma variável aleatória Chi-quadrada
     Chi^2(n), com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na variância da função gama é
     retornada.

          (%i1) load (distrib)$
          (%i2) var_chi2(n);
                                             n
          (%o2)                    var_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ var_chi2(n);
          (%o4)                          2 n

 -- Função: std_chi2 (<n>)
     Retorna o desvio padrão de uma variável aleatória Chi-quadrada
     Chi^2(n), com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no desvio padrão da função
     gama é retornada.

          (%i1) load (distrib)$
          (%i2) std_chi2(n);
                                             n
          (%o2)                    std_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ std_chi2(n);
          (%o4)                    sqrt(2) sqrt(n)

 -- Função: skewness_chi2 (<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Chi-quadrada Chi^2(n), com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de assimetria
     da função gama é retornada.

          (%i1) load (distrib)$
          (%i2) skewness_chi2(n);
                                               n
          (%o2)                 skewness_gamma(-, 2)
                                               2
          (%i3) assume(n>0)$ skewness_chi2(n);
                                      2 sqrt(2)
          (%o4)                       ---------
                                       sqrt(n)

 -- Função: kurtosis_chi2 (<n>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Chi-quadrada Chi^2(n), com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de curtose da
     função gama é retornada.

          (%i1) load (distrib)$
          (%i2) kurtosis_chi2(n);
                                               n
          (%o2)                 kurtosis_gamma(-, 2)
                                               2
          (%i3) assume(n>0)$ kurtosis_chi2(n);
                                         12
          (%o4)                          --
                                         n

 -- Variável de opção: random_chi2_algorithm
     Valor padrão: 'ahrens_cheng'

     Esse é o algorítmo selecionado para simular variáveis estatística
     pseudo-aleatórias Chi-quadradas.  Os algorítmos implementados são
     'ahrens_cheng' e 'inverse':

        * 'ahrens_cheng', baseado na simulação aleatória de variáveis
          gama.  Veja 'random_gamma_algorithm' para mais detalhes.

        * 'inverse', baseado no método inverso genérico.

     Veja também 'random_chi2'.

 -- Função: random_chi2 (<n>)
 -- Função: random_chi2 (<n>,<m>)
     Retorna uma variável estatística pseudo-aleatória Chi-square
     Chi^2(n), com n>0.  Chamando 'random_chi2' com um segundo argumento
     <m>, uma amostra aleatória de tamanho <m> será simulada.

     Existem dois algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global 'random_chi2_algorithm', cujo valor padrão é
     'ahrens_cheng'.

     Veja também 'random_chi2_algorithm'.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: pdf_f (<x>,<m>,<n>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória F, F(m,n), com m,n>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_f (<x>,<m>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória F, F(m,n), com m,n>0.  Essa função não
     possui uma forma definitiva e é calculada numericamente se a
     variável global 'numer' for igual a 'true', de outra forma retorna
     uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_f(2,3,9/4);
                                               9
          (%o2)                    cdf_f(2, 3, -)
                                               4
          (%i3) %,numer;
          (%o3)                   0.66756728179008

 -- Função: quantile_f (<q>,<m>,<n>)
     Retorna o <q>-quantil de uma variável aleatória F, F(m,n), com
     m,n>0; em outras palavras, essa função é o inverso de 'cdf_f'.  O
     argumento <q> deve ser um elemento de [0,1].

     Essa função não possui uma forma fechada e é calculada
     numericamante se a variável global 'numer' for igual a 'true', de
     outra forma essa função retorna uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) quantile_f(2/5,sqrt(3),5);
                                         2
          (%o2)               quantile_f(-, sqrt(3), 5)
                                         5
          (%i3) %,numer;
          (%o3)                   0.518947838573693

 -- Função: mean_f (<m>,<n>)
     Retorna a média de uma variável aleatória F, F(m,n), com m>0, n>2.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: var_f (<m>,<n>)
     Retorna a variância de uma variável aleatória F, F(m,n), com m>0,
     n>4.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: std_f (<m>,<n>)
     Retorna o desvio padrão de uma variável aleatória F, F(m,n), com
     m>0, n>4.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_f (<m>,<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória F,
     F(m,n), com m>0, n>6.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: kurtosis_f (<m>,<n>)
     Retorna o coeficiente de curtose de uma variável aleatória F,
     F(m,n), com m>0, n>8.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Variável de opção: random_f_algorithm
     Valor padrão: 'inverse'

     Esse é o algorítmo selecionado para simular variáveis estatísticas
     pseudo-aleatórias F. Os algorítmos implementados são 'ratio' e
     'inverse':

        * 'ratio', baseado no fato de que se <X> for uma variável
          aleatória Chi^2(m) e Y for uma variável aleatória Chi^2(n),
          então
                                       n X
                                   F = ---
                                       m Y
          é uma variável aleatória F com <m> e <n> graus de liberdade,
          F(m,n).

        * 'inverse', baseado no método inverso genérico.

     Veja também 'random_f'.

 -- Função: random_f (<m>,<n>)
 -- Função: random_f (<m>,<n>,<k>)
     Retorna uma variável estatística pseudo-aleatória F, F(m,n), com
     m,n>0.  Chamando 'random_f' com um terceiro argumento <k>, uma
     amostra aleatória de tamanho <k> será simulada.

     Existem dois algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global 'random_f_algorithm', cujo valor padrão é
     'inverse'.

     Veja também 'random_f_algorithm'.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: pdf_exp (<x>,<m>)
     Retorna o valor em <x> da função densidade de probabilidade
     variável aleatória Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na função de densidade de
     probabilidade de Weibull éretornada.

          (%i1) load (distrib)$
          (%i2) pdf_exp(x,m);
                                                  1
          (%o2)                 pdf_weibull(x, 1, -)
                                                  m
          (%i3) assume(x>0,m>0)$  pdf_exp(x,m);
                                          - m x
          (%o4)                       m %e

 -- Função: cdf_exp (<x>,<m>)
     Retorna o valor em <x> da função distribuição de probabilidade
     variável aleatória Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na distribuição de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) cdf_exp(x,m);
                                                  1
          (%o2)                 cdf_weibull(x, 1, -)
                                                  m
          (%i3) assume(x>0,m>0)$  cdf_exp(x,m);
                                           - m x
          (%o4)                      1 - %e

 -- Função: quantile_exp (<q>,<m>)
     Retorna o <q>-quantil variável aleatória Exponential(m), com m>0;
     em outras palavras, essa função é inversa da função 'cdf_exp'.  O
     argumento <q> deve ser um elemento de [0,1].

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no qualtil de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) quantile_exp(0.56,5);
          (%o2)                   .1641961104139661
          (%i3) quantile_exp(0.56,m);
                                                      1
          (%o3)             quantile_weibull(0.56, 1, -)
                                                      m

 -- Função: mean_exp (<m>)
     Retorna a média de uma variável aleatória Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na média de Weibull é
     reornada.

          (%i1) load (distrib)$
          (%i2) mean_exp(m);
                                                 1
          (%o2)                  mean_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  mean_exp(m);
                                          1
          (%o4)                           -
                                          m

 -- Função: var_exp (<m>)
     Retorna a variância de uma variável aleatória Exponential(m), com
     m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na variância de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) var_exp(m);
                                                 1
          (%o2)                   var_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  var_exp(m);
                                         1
          (%o4)                          --
                                          2
                                         m

 -- Função: std_exp (<m>)
     Retorna o desvio padrão de uma variável aleatória Exponential(m),
     com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no desvio padrão de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) std_exp(m);
                                                 1
          (%o2)                   std_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  std_exp(m);
                                          1
          (%o4)                           -
                                          m

 -- Função: skewness_exp (<m>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de assimetria
     de Weibull é retornada.

          (%i1) load (distrib)$
          (%i2) skewness_exp(m);
                                                   1
          (%o2)                skewness_weibull(1, -)
                                                   m
          (%i3) assume(m>0)$  skewness_exp(m);
          (%o4)                           2

 -- Função: kurtosis_exp (<m>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de curtose de
     Weibull é retornada.

          (%i1) load (distrib)$
          (%i2) kurtosis_exp(m);
                                                   1
          (%o2)                kurtosis_weibull(1, -)
                                                   m
          (%i3) assume(m>0)$  kurtosis_exp(m);
          (%o4)                           6

 -- Variável de opção: random_exp_algorithm
     Valor padrão: 'inverse'

     Esse é o algorítmo selecionado para simular variáveis exponenciais
     estatística pseudo-aleatórias.  Os algorítmos implementados são
     'inverse', 'ahrens_cheng' e 'ahrens_dieter'

        * 'inverse', baseado no método inverso genérico.

        * 'ahrens_cheng', baseado no fato de que a variável aleatória
          Exp(m) é equivalente a Gamma(1,1/m).  Veja
          'random_gamma_algorithm' para maiores detalhes.

        * 'ahrens_dieter', baseado no algorítmo descrito em Ahrens, J.H.
          e Dieter, U. (1972) <Computer methods for sampling from the
          exponential and normal distributions.> Comm, ACM, 15, Oct.,
          873-882.

     Veja também 'random_exp'.

 -- Função: random_exp (<m>)
 -- Função: random_exp (<m>,<k>)
     Retorna uma variável estatística pseudo-aleatória Exponential(m),
     com m>0.  Chamando 'random_exp' com um segundo argumento <k>, uma
     amostra aleatória de tamanho <k> será simulada.

     Existem três algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global 'random_exp_algorithm', cujo valor padrão é
     'inverse'.

     Veja também 'random_exp_algorithm'.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: pdf_lognormal (<x>,<m>,<s>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Lognormal(m,s), com s>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_lognormal (<x>,<m>,<s>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Lognormal(m,s), com s>0.  Essa função é
     definida em termos de funções 'erf'de erro internas do Maxima.

          (%i1) load (distrib)$
          (%i2) assume(x>0, s>0)$  cdf_lognormal(x,m,s);
                                     log(x) - m
                                 erf(----------)
                                     sqrt(2) s     1
          (%o3)                  --------------- + -
                                        2          2

     Veja também 'erf'.

 -- Função: quantile_lognormal (<q>,<m>,<s>)
     Retorna o <q>-quantil de uma variável aleatória Lognormal(m,s), com
     s>0; em outras palavras, essa função é a inversa da função
     'cdf_lognormal'.  O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_lognormal (<m>,<s>)
     Retorna a média de uma variável aleatória Lognormal(m,s), com s>0.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: var_lognormal (<m>,<s>)
     Retorna a variância de uma variável aleatória Lognormal(m,s), com
     s>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: std_lognormal (<m>,<s>)
     Retorna o desvio padrão de uma variável aleatória Lognormal(m,s),
     com s>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_lognormal (<m>,<s>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Lognormal(m,s), com s>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: kurtosis_lognormal (<m>,<s>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Lognormal(m,s), com s>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: random_lognormal (<m>,<s>)
 -- Função: random_lognormal (<m>,<s>,<n>)
     Retorna uma variável estatística pseudo-aleatória Lognormal(m,s),
     com s>0.  Chamando 'random_lognormal' com um terceiro argumento
     <n>, uma amostra aleatória de tamanho <n> será simulada.

     Variáveis Log-normal são simuladas por meio de variáveis
     estatísticas normais pseudo-aleatórias.  Existem dois algorítmos
     implementados para essa função, se pode selecionar o algorítmo a
     ser usado fornecendo um certo valor à variável global
     'random_normal_algorithm', cujo valor padrão é 'box_mueller'.

     Veja também 'random_normal_algorithm'.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_gamma (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Gamma(a,b), com a,b>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_gamma (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Gamma(a,b), com a,b>0.

     Essa função não possui uma forma fechada e é calculada
     numericamante se a variável global 'numer' for igual a 'true', de
     outra forma essa função retorna uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_gamma(3,5,21);
          (%o2)                  cdf_gamma(3, 5, 21)
          (%i3) %,numer;
          (%o3)                 4.402663157135039E-7

 -- Função: quantile_gamma (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Gamma(a,b), com
     a,b>0; em outras palavras, essa função é a inversa da função
     'cdf_gamma'.  O argumento <q> deve ser um elemento de [0,1].  Para
     fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_gamma (<a>,<b>)
     Retorna a média de uma variável aleatória Gamma(a,b), com a,b>0.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: var_gamma (<a>,<b>)
     Retorna a variância de uma variável aleatória Gamma(a,b), com
     a,b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: std_gamma (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Gamma(a,b), com
     a,b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_gamma (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Gamma(a,b), com a,b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: kurtosis_gamma (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Gamma(a,b), com a,b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Variável de opção: random_gamma_algorithm
     Valor padrão: 'ahrens_cheng'

     Esse é o algorítmo selecionado para simular variáveis estatística
     gama pseudo-aleatórias.  Os algorítmos implementados são
     'ahrens_cheng' e 'inverse'

        * 'ahrens_cheng', essa é uma combinação de dois processos,
          dependendo do valor do parâmetro <a>:

          For a>=1, Cheng, R.C.H. e Feast, G.M. (1979).  <Some simple
          gamma variate generators>.  Appl.  Stat., 28, 3, 290-295.

          For 0<a<1, Ahrens, J.H. e Dieter, U. (1974).  <Computer
          methods for sampling from gamma, beta, poisson and binomial
          cdf_tributions>.  Computing, 12, 223-246.

        * 'inverse', baseado no método inverso genérico.

     Veja também 'random_gamma'.

 -- Função: random_gamma (<a>,<b>)
 -- Função: random_gamma (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Gamma(a,b), com
     a,b>0.  Chamando 'random_gamma' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Existem dois algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global 'random_gamma_algorithm', cujo valor padrão é
     'ahrens_cheng'.

     Veja também 'random_gamma_algorithm'.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: pdf_beta (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Beta(a,b), com a,b>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_beta (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Beta(a,b), com a,b>0.

     Essa função não possui uma forma fechada e é calculada
     numericamante se a variável global 'numer' for igual a 'true', de
     outra forma essa função retorna uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_beta(1/3,15,2);
                                           1
          (%o2)                   cdf_beta(-, 15, 2)
                                           3
          (%i3) %,numer;
          (%o3)                 7.666089131388224E-7

 -- Função: quantile_beta (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Beta(a,b), com
     a,b>0; em outras palavras, essa função é a inversa da função
     'cdf_beta'.  O argumento <q> deve ser um elemento de [0,1].  Para
     fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_beta (<a>,<b>)
     Retorna a média de uma variável aleatória Beta(a,b), com a,b>0.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: var_beta (<a>,<b>)
     Retorna a variância de uma variável aleatória Beta(a,b), com a,b>0.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: std_beta (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Beta(a,b), com
     a,b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_beta (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Beta(a,b), com a,b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: kurtosis_beta (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Beta(a,b), com a,b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Variável de opção: random_beta_algorithm
     Valor padrão: 'cheng'

     Esse é o algorítmo selecionado para simular variáveis estatísticas
     beta pseudo-aleatórias.  Os algorítmos implementados são 'cheng',
     'inverse' e 'ratio'

        * 'cheng', esse é o algorítmo definido em Cheng, R.C.H. (1978).
          <Generating Beta Variates with Nonintegral Shape Parameters>.
          Communications of the ACM, 21:317-322

        * 'inverse', baseado no método inverso genérico.

        * 'ratio', baseado no fato de que se <X> for uma variável
          aleatória Gamma(a,1) e <Y> for Gamma(b,1), então a razão
          X/(X+Y) está distribuída como Beta(a,b).

     Veja também 'random_beta'.

 -- Função: random_beta (<a>,<b>)
 -- Função: random_beta (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Beta(a,b), com
     a,b>0.  Chamando 'random_beta' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Existem três algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global 'random_beta_algorithm', cujo valor padrão é
     'cheng'.

     Veja também 'random_beta_algorithm'.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: pdf_continuous_uniform (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Continuous Uniform(a,b), com a<b.  Para fazer
     uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_continuous_uniform (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Continuous Uniform(a,b), com a<b.  Para
     fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: quantile_continuous_uniform (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Continuous
     Uniform(a,b), com a<b; em outras palavras, essa função é a inversa
     da função 'cdf_continuous_uniform'.  O argumento <q> deve ser um
     elemento de [0,1].  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: mean_continuous_uniform (<a>,<b>)
     Retorna a média de uma variável aleatória Continuous Uniform(a,b),
     com a<b.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: var_continuous_uniform (<a>,<b>)
     Retorna a variância de uma variável aleatória Continuous
     Uniform(a,b), com a<b.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: std_continuous_uniform (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Continuous
     Uniform(a,b), com a<b.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: skewness_continuous_uniform (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Continuous Uniform(a,b), com a<b.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: kurtosis_continuous_uniform (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Continuous Uniform(a,b), com a<b.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: random_continuous_uniform (<a>,<b>)
 -- Função: random_continuous_uniform (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Continuous
     Uniform(a,b), com a<b.  Chamando 'random_continuous_uniform' com um
     terceiro argumento <n>, uma amostra aleatória de tamanho <n> será
     simulada.

     Essa é uma aplicação direta da função 'random' interna do Maxima.

     Veja também 'random'.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: pdf_logistic (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Logistic(a,b) , com b>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_logistic (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Logistic(a,b), com b>0.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: quantile_logistic (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Logistic(a,b) , com
     b>0; em outras palavras, essa função é a inversa da função
     'cdf_logistic'.  O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: meanlog (<a>,<b>)
     Retorna a média de uma Logistic(a,b) variável aleatória , com b>0.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: var_logistic (<a>,<b>)
     Retorna a variância de uma variável aleatória Logistic(a,b) , com
     b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: std_logistic (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Logistic(a,b) ,
     com b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_logistic (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Logistic(a,b) , com b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: kurtosis_logistic (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Logistic(a,b) , com b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: random_logistic (<a>,<b>)
 -- Função: random_logistic (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Logistic(a,b),
     com b>0.  Chamando 'random_logistic' com um terceiro argumento <n>,
     uma amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado.  Para fazer
     uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_pareto (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Pareto(a,b), com a,b>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_pareto (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Pareto(a,b), com a,b>0.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: quantile_pareto (<q>,<a>,<b>)
     Retorna o <q>-quantile de uma variável aleatória Pareto(a,b), com
     a,b>0; em outras palavras, essa função é a inversa da função
     'cdf_pareto'.  O argumento <q> deve ser um elemento de [0,1].  Para
     fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_pareto (<a>,<b>)
     Retorna a média de uma variável aleatória Pareto(a,b), com a>1,b>0.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: var_pareto (<a>,<b>)
     Retorna a variância de uma variável aleatória Pareto(a,b), com
     a>2,b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: std_pareto (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Pareto(a,b), com
     a>2,b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_pareto (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Pareto(a,b), com a>3,b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: kurtosis_pareto (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Pareto(a,b), com a>4,b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: random_pareto (<a>,<b>)
 -- Função: random_pareto (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Pareto(a,b), com
     a>0,b>0.  Chamando 'random_pareto' com um terceiro argumento <n>,
     uma amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado.  Para fazer
     uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_weibull (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Weibull(a,b), com a,b>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_weibull (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Weibull(a,b), com a,b>0.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: quantile_weibull (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Weibull(a,b), com
     a,b>0; em outras palavras, essa função é a inversa da função
     'cdf_weibull'.  O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_weibull (<a>,<b>)
     Retorna a média de uma variável aleatória Weibull(a,b), com a,b>0.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: var_weibull (<a>,<b>)
     Retorna a variância de uma variável aleatória Weibull(a,b), com
     a,b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: std_weibull (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Weibull(a,b), com
     a,b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_weibull (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Weibull(a,b), com a,b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: kurtosis_weibull (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Weibull(a,b), com a,b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: random_weibull (<a>,<b>)
 -- Função: random_weibull (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Weibull(a,b), com
     a,b>0.  Chamando 'random_weibull' com um terceiro argumento <n>,
     uma amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado.  Para fazer
     uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_rayleigh (<x>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na função densidade de
     probabilidade de Weibull é retornada.

          (%i1) load (distrib)$
          (%i2) pdf_rayleigh(x,b);
                                                  1
          (%o2)                 pdf_weibull(x, 2, -)
                                                  b
          (%i3) assume(x>0,b>0)$ pdf_rayleigh(x,b);
                                              2  2
                                     2     - b  x
          (%o4)                   2 b  x %e

 -- Função: cdf_rayleigh (<x>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na distribuição de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) cdf_rayleigh(x,b);
                                                  1
          (%o2)                 cdf_weibull(x, 2, -)
                                                  b
          (%i3) assume(x>0,b>0)$ cdf_rayleigh(x,b);
                                             2  2
                                          - b  x
          (%o4)                     1 - %e

 -- Função: quantile_rayleigh (<q>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Rayleigh(b), com
     b>0; em outras palavras, essa função é a inversa da função
     'cdf_rayleigh'.  O argumento <q> deve ser um elemento de [0,1].

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no quantil de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) quantile_rayleigh(0.99,b);
                                                      1
          (%o2)             quantile_weibull(0.99, 2, -)
                                                      b
          (%i3) assume(x>0,b>0)$ quantile_rayleigh(0.99,b);
                                  2.145966026289347
          (%o4)                   -----------------
                                          b

 -- Função: mean_rayleigh (<b>)
     Retorna a média de uma variável aleatória Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na meia de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) mean_rayleigh(b);
                                                 1
          (%o2)                  mean_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ mean_rayleigh(b);
                                      sqrt(%pi)
          (%o4)                       ---------
                                         2 b

 -- Função: var_rayleigh (<b>)
     Retorna a variância de uma variável aleatória Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na variância de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) var_rayleigh(b);
                                                 1
          (%o2)                   var_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ var_rayleigh(b);
                                           %pi
                                       1 - ---
                                            4
          (%o4)                        -------
                                          2
                                         b

 -- Função: std_rayleigh (<b>)
     Retorna o desvio padrão de uma variável aleatória Rayleigh(b), com
     b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na Weibull desvio padrão é
     retornada.

          (%i1) load (distrib)$
          (%i2) std_rayleigh(b);
                                                 1
          (%o2)                   std_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ std_rayleigh(b);
                                             %pi
                                    sqrt(1 - ---)
                                              4
          (%o4)                     -------------
                                          b

 -- Função: skewness_rayleigh (<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de assimetria
     de Weibull é retornada.

          (%i1) load (distrib)$
          (%i2) skewness_rayleigh(b);
                                                   1
          (%o2)                skewness_weibull(2, -)
                                                   b
          (%i3) assume(b>0)$ skewness_rayleigh(b);
                                   3/2
                                %pi      3 sqrt(%pi)
                                ------ - -----------
                                  4           4
          (%o4)                 --------------------
                                         %pi 3/2
                                    (1 - ---)
                                          4

 -- Função: kurtosis_rayleigh (<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de curtose de
     Weibull é retornada.

          (%i1) load (distrib)$
          (%i2) kurtosis_rayleigh(b);
                                                   1
          (%o2)                kurtosis_weibull(2, -)
                                                   b
          (%i3) assume(b>0)$ kurtosis_rayleigh(b);
                                            2
                                       3 %pi
                                   2 - ------
                                         16
          (%o4)                    ---------- - 3
                                        %pi 2
                                   (1 - ---)
                                         4

 -- Função: random_rayleigh (<b>)
 -- Função: random_rayleigh (<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Rayleigh(b), com
     b>0.  Chamando 'random_rayleigh' com um segundo argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado.  Para fazer
     uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_laplace (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Laplace(a,b), com b>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_laplace (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Laplace(a,b), com b>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: quantile_laplace (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Laplace(a,b), com
     b>0; em outras palavras, essa função é a inversa da função
     'cdf_laplace'.  O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_laplace (<a>,<b>)
     Retorna a média de uma variável aleatória Laplace(a,b), com b>0.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: var_laplace (<a>,<b>)
     Retorna a variância de uma variável aleatória Laplace(a,b), com
     b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: std_laplace (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Laplace(a,b), com
     b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_laplace (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Laplace(a,b), com b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: kurtosis_laplace (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Laplace(a,b), com b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: random_laplace (<a>,<b>)
 -- Função: random_laplace (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Laplace(a,b), com
     b>0.  Chamando 'random_laplace' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado.  Para fazer
     uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_cauchy (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Cauchy(a,b), com b>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_cauchy (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Cauchy(a,b), com b>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: quantile_cauchy (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Cauchy(a,b), com
     b>0; em outras palavras, essa função é a inversa da função
     'cdf_cauchy'.  O argumento <q> deve ser um elemento de [0,1].  Para
     fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: random_cauchy (<a>,<b>)
 -- Função: random_cauchy (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo aleatória Cauchy(a,b), com
     b>0.  Chamando 'random_cauchy' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado.  Para fazer
     uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_gumbel (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Gumbel(a,b), com b>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_gumbel (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Gumbel(a,b), com b>0.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: quantile_gumbel (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Gumbel(a,b), com
     b>0; em outras palavras, essa função é a inversa da função
     'cdf_gumbel'.  O argumento <q> deve ser um elemento de [0,1].  Para
     fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_gumbel (<a>,<b>)
     Retorna a média de uma variável aleatória Gumbel(a,b), com b>0.

          (%i1) load (distrib)$
          (%i2) assume(b>0)$  mean_gumbel(a,b);
          (%o3)                     %gamma b + a
     onde o símbolol '%gamma' representa a constante de
     Euler-Mascheroni.  Veja também '%gamma'.

 -- Função: var_gumbel (<a>,<b>)
     Retorna a variância de uma variável aleatória Gumbel(a,b), com b>0.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: std_gumbel (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Gumbel(a,b), com
     b>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_gumbel (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Gumbel(a,b), com b>0.

          (%i1) load (distrib)$
          (%i2) assume(b>0)$ skewness_gumbel(a,b);
                                 12 sqrt(6) zeta(3)
          (%o3)                  ------------------
                                           3
                                        %pi
          (%i4) numer:true$ skewness_gumbel(a,b);
          (%o5)                   1.139547099404649
     onde 'zeta' representa a função zeta de Riemann.

 -- Função: kurtosis_gumbel (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Gumbel(a,b), com b>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: random_gumbel (<a>,<b>)
 -- Função: random_gumbel (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Gumbel(a,b), com
     b>0.  Chamando 'random_gumbel' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado.  Para fazer
     uso dessa função, escreva primeiramente 'load(distrib)'.


File: maxima.info,  Node: Funções e Variáveis Definidas para distribuições discretas,  Prev: Funções e Variáveis Definidas para distribuições contínuas,  Up: distrib

47.3 Funções e Variáveis Definidas para distribuições discretas
===============================================================

 -- Função: pdf_binomial (<x>,<n>,<p>)
     Retorna o valor em <x> da função de probabilidade de uma
     Binomial(n,p) variável aleatória, com 0<p<1 e n um inteiro
     positivo.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: cdf_binomial (<x>,<n>,<p>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma Binomial(n,p) variável aleatória, com 0<p<1 e n um inteiro
     positivo.

     'cdf_binomial' é calculada numéricamente se a variável global
     'numer' for igual a 'true', de outra forma 'cdf_binomial' retorna
     uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_binomial(5,7,1/6);
                                                   1
          (%o2)                 cdf_binomial(5, 7, -)
                                                   6
          (%i3) cdf_binomial(5,7,1/6), numer;
          (%o3)                   .9998713991769548

 -- Função: quantile_binomial (<q>,<n>,<p>)
     Retorna o <q>-quantil de uma variável aleatória Binomial(n,p), com
     0<p<1 e n um inteiro positivo; em outras palavras, essa função é a
     inversa da função 'cdf_binomial'.  O argumento <q> deve ser um
     elemento de [0,1].  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: mean_binomial (<n>,<p>)
     Retorna a média de uma variável aleatória Binomial(n,p), com 0<p<1
     e n um inteiro positivo.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: var_binomial (<n>,<p>)
     Retorna a variância de uma variável aleatória Binomial(n,p), com
     0<p<1 e n um inteiro positivo.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: std_binomial (<n>,<p>)
     Retorna o desvio padrão de uma variável aleatória Binomial(n,p),
     com 0<p<1 e n um inteiro positivo.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: skewness_binomial (<n>,<p>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Binomial(n,p), com 0<p<1 e n um inteiro positivo.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: kurtosis_binomial (<n>,<p>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Binomial(n,p), com 0<p<1 e n um inteiro positivo.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Variável de opção: random_binomial_algorithm
     Valor padrão: 'kachit'

     Esse é o algorítmo selecionado para simular rvariáveis estatísticas
     pseudo-aleatórias binomiais.  Os algorítmos implementados são
     'kachit', 'bernoulli' e 'inverse':

        * 'kachit', baseado no algorítmo descrito em Kachitvichyanukul,
          V. and Schmeiser, B.W. (1988) <Binomial Random Variate
          Generation>.  Communications of the ACM, 31, Feb., 216.

        * 'bernoulli', baseado na simulação testes de Bernoulli.

        * 'inverse', baseado no método inverso genérico.

     Veja também 'random_binomial'.

 -- Função: random_binomial (<n>,<p>)
 -- Função: random_binomial (<n>,<p>,<m>)
     Retorna uma variável estatística pseudo-aleatória Binomial(n,p),
     com 0<p<1 e n um inteiro positivo.  Chamando 'random_binomial' com
     um terceiro argumento <m>, uma amostra aleatória de tamanho <m>
     será simulada.

     Existem três algorítmos implementado para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global 'random_binomial_algorithm', cujo valor padrão é
     'kachit'.

     Veja também 'random_binomial_algorithm'.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_poisson (<x>,<m>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Poisson(m), com m>0.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: cdf_poisson (<x>,<m>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Poisson(m), com m>0.

     Essa função é calculada numéricamente se a variável global 'numer'
     for igual a 'true', de outra forma essa função retorna uma
     expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_poisson(3,5);
          (%o2)                   cdf_poisson(3, 5)
          (%i3) cdf_poisson(3,5), numer;
          (%o3)                   .2650259152973617

 -- Função: quantile_poisson (<q>,<m>)
     Retorna o <q>-quantil de uma variável aleatória Poisson(m), com
     m>0; em outras palavras, essa função é a inversa da função
     'cdf_poisson'.  O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_poisson (<m>)
     Retorna a média de uma variável aleatória Poisson(m), com m>0.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: var_poisson (<m>)
     Retorna a variância de uma variável aleatória Poisson(m), com m>0.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: std_poisson (<m>)
     Retorna o desvio padrão de uma variável aleatória Poisson(m), com
     m>0.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_poisson (<m>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Poisson(m), com m>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: kurtosis_poisson (<m>)
     Retorna o coeficiente de curtose de uma Poisson variável aleatória
     Poi(m), com m>0.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Variável de opção: random_poisson_algorithm
     Valor padrão: 'ahrens_dieter'

     Esse é o algorítmo selecionado para simular variáveis estatísticas
     pseudo-aleatórias de Poisson.Os algorítmos implementados são
     'ahrens_dieter' e 'inverse':

        * 'ahrens_dieter', baseado no algorítmo descrito em Ahrens, J.H.
          and Dieter, U. (1982) <Computer Generation of Poisson Deviates
          From Modified Normal Distributions>.  ACM Trans.  Math.
          Software, 8, 2, June,163-179.

        * 'inverse', baseado no método inverso genérico.

     Veja também 'random_poisson'.

 -- Função: random_poisson (<m>)
 -- Função: random_poisson (<m>,<n>)
     Retorna uma variável estatística pseudo-aleatória Poisson(m), com
     m>0.  Chamando 'random_poisson' com um segundo argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Existem dois algorítmos implementado para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global 'random_poisson_algorithm', cujo valor padrão é
     'ahrens_dieter'.

     Veja também 'random_poisson_algorithm'.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_bernoulli (<x>,<p>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Bernoulli(p), com 0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na função binomial de
     probabilidade é retornada.

          (%i1) load (distrib)$
          (%i2) pdf_bernoulli(1,p);
          (%o2)                 pdf_binomial(1, 1, p)
          (%i3) assume(0<p,p<1)$ pdf_bernoulli(1,p);
          (%o4)                           p

 -- Função: cdf_bernoulli (<x>,<p>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Bernoulli(p), com 0<p<1.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: quantile_bernoulli (<q>,<p>)
     Retorna o <q>-quantil de uma variável aleatória Bernoulli(p), com
     0<p<1; em outras palavras, essa função é a inversa da função
     'cdf_bernoulli'.  O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_bernoulli (<p>)
     Retorna a média de uma variável aleatória Bernoulli(p), com 0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na média binomial é retornada.

          (%i1) load (distrib)$
          (%i2) mean_bernoulli(p);
          (%o2)                  mean_binomial(1, p)
          (%i3) assume(0<p,p<1)$ mean_bernoulli(p);
          (%o4)                           p

 -- Função: var_bernoulli (<p>)
     Retorna a variância de uma variável aleatória Bernoulli(p), com
     0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na variância binomial é
     retornada.

          (%i1) load (distrib)$
          (%i2) var_bernoulli(p);
          (%o2)                  var_binomial(1, p)
          (%i3) assume(0<p,p<1)$ var_bernoulli(p);
          (%o4)                       (1 - p) p

 -- Função: std_bernoulli (<p>)
     Retorna o desvio padrão de uma variável aleatória Bernoulli(p), com
     0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no desvio padrão binomial é
     retornada.

          (%i1) load (distrib)$
          (%i2) std_bernoulli(p);
          (%o2)                  std_binomial(1, p)
          (%i3) assume(0<p,p<1)$ std_bernoulli(p);
          (%o4)                  sqrt(1 - p) sqrt(p)

 -- Função: skewness_bernoulli (<p>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Bernoulli(p), com 0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de assimetria
     binomial é retornada.

          (%i1) load (distrib)$
          (%i2) skewness_bernoulli(p);
          (%o2)                skewness_binomial(1, p)
          (%i3) assume(0<p,p<1)$ skewness_bernoulli(p);
                                       1 - 2 p
          (%o4)                  -------------------
                                 sqrt(1 - p) sqrt(p)

 -- Função: kurtosis_bernoulli (<p>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Bernoulli(p), com 0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de curtose
     binomial é retornada.

          (%i1) load (distrib)$
          (%i2) kurtosis_bernoulli(p);
          (%o2)                kurtosis_binomial(1, p)
          (%i3) assume(0<p,p<1)$ kurtosis_bernoulli(p);
                                   1 - 6 (1 - p) p
          (%o4)                    ---------------
                                      (1 - p) p

 -- Função: random_bernoulli (<p>)
 -- Função: random_bernoulli (<p>,<n>)
     Retorna uma variável estatística pseudo-aleatória Bernoulli(p), com
     0<p<1.  Chamando 'random_bernoulli' com um segundo argumento <n>,
     uma amostra aleatória de tamanho <n> será simulada.

     Essa é uma aplicação direta da função 'random' built-in função do
     Maxima.

     Veja também 'random'.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: pdf_geometric (<x>,<p>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Geometric(p), com 0<p<1.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: cdf_geometric (<x>,<p>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Geometric(p), com 0<p<1.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: quantile_geometric (<q>,<p>)
     Retorna o <q>-quantil de uma variável aleatória Geometric(p), com
     0<p<1; em outras palavras, essa função é a inversa da função
     'cdf_geometric'.  O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_geometric (<p>)
     Retorna a média de uma variável aleatória Geometric(p), com 0<p<1.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: var_geometric (<p>)
     Retorna a variância de uma variável aleatória Geometric(p), com
     0<p<1.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: std_geometric (<p>)
     Retorna o desvio padrão de uma variável aleatória Geometric(p), com
     0<p<1.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: skewness_geometric (<p>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Geometric(p), com 0<p<1.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: kurtosis_geometric (<p>)
     Retorna o coeficiente de curtose de uma geometric variável
     aleatória Geo(p), com 0<p<1.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Variável de opção: random_geometric_algorithm
     Valor padrão: 'bernoulli'

     Esse é o algorítmo selecionado para simular variáveis estatísticas
     pseudo-aleatórias geométricas.  Algorítmos implementados são
     'bernoulli', 'devroye' e 'inverse':

        * 'bernoulli', baseado na simulação de testes de Bernoulli.

        * 'devroye', baseado no algorítmo descrito em Devroye, L. (1986)
          <Non-Uniform Random Variate Generation.> Springer Verlag, p.
          480.

        * 'inverse', baseado no método inverso genérico.

     Veja também 'random_geometric'.

 -- Função: random_geometric (<p>)
 -- Função: random_geometric (<p>,<n>)
     Retorna um Geometric(p) variável estatística pseudo-aleatória, com
     0<p<1.  Chamando 'random_geometric' com um segundo argumento <n>,
     uma amostra aleatória de tamanho <n> será simulada.

     Existem três algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global 'random_geometric_algorithm', cujo valor padrão é
     'bernoulli'.

     Veja também 'random_geometric_algorithm'.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_discrete_uniform (<x>,<n>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Discrete Uniform(n), com n a strictly positive integer.
     Para fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: cdf_discrete_uniform (<x>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Discrete Uniform(n), com n inteiro
     estritamente positivo.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: quantile_discrete_uniform (<q>,<n>)
     Retorna o <q>-quantil de uma variável aleatória Discrete
     Uniform(n), com n um inteiro estritamente positivo; em outras
     palavras, essa função é a inversa da função 'cdf_discrete_uniform'.
     O argumento <q> deve ser um elemento de [0,1].  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: mean_discrete_uniform (<n>)
     Retorna a média de uma variável aleatória Discrete Uniform(n), com
     n um inteiro estritamente positivo.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: var_discrete_uniform (<n>)
     Retorna a variância de uma variável aleatória Discrete Uniform(n),
     com n um inteiro estritamente positivo.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: std_discrete_uniform (<n>)
     Retorna o desvio padrão de uma variável aleatória Discrete
     Uniform(n), com n um inteiro estritamente positivo.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: skewness_discrete_uniform (<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Discrete Uniform(n), com n um inteiro estritamente positivo.  Para
     fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: kurtosis_discrete_uniform (<n>)
     Retorna o coeficiente de curtose de uma variável aleatória Discrete
     Uniform(n), com n um inteiro estritamente positivo.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: random_discrete_uniform (<n>)
 -- Função: random_discrete_uniform (<n>,<m>)
     Retorna uma variável estatística pseudo-aleatória Discrete
     Uniform(n), com n um inteiro estritamente positivo.  Chamando
     'random_discrete_uniform' com um segundo argumento <m>, uma amostra
     aleatória de tamanho <m> será simulada.

     Isso é uma aplicação direta da função 'random' built-in função do
     Maxima.

     Veja também 'random'.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: pdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros
     não negativos e n<=n1+n2.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: cdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Hypergeometric(n1,n2,n), com <n1>, <n2> e
     <n> inteiros não negativos e n<=n1+n2.  Para fazer uso dessa
     função, escreva primeiramente 'load(distrib)'.

 -- Função: quantile_hypergeometric (<q>,<n1>,<n2>,<n>)
     Retorna o <q>-quantil de uma variável aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2; em outras palavras, essa função é a inversa
     da função 'cdf_hypergeometric'.  O argumento <q> deve ser um
     elemento de [0,1].  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: mean_hypergeometric (<n1>,<n2>,<n>)
     Retorna a média de uma variável aleatória discreta univorme
     Hyp(n1,n2,n), com <n1>, <n2> e <n> inteiros não negativos e
     n<=n1+n2.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: var_hypergeometric (<n1>,<n2>,<n>)
     Retorna a variância de uma variável aleatória hipergeométrica
     Hyp(n1,n2,n), com <n1>, <n2> e <n> inteiros não negativos e
     n<=n1+n2.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: std_hypergeometric (<n1>,<n2>,<n>)
     Retorna o desvio padrão de uma variável aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: skewness_hypergeometric (<n1>,<n2>,<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Função: kurtosis_hypergeometric (<n1>,<n2>,<n>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2.  Para fazer uso dessa função, escreva
     primeiramente 'load(distrib)'.

 -- Variável de opção: random_hypergeometric_algorithm
     Valor padrão: 'kachit'

     Esse é o algorítmo selecionado para simular variáveis estatísticas
     pseudo aleatórias hipergeométricas.Os algorítmos implementados são
     'kachit' e 'inverse':

        * 'kachit', baseado no algorítmo descrito em Kachitvichyanukul,
          V., Schmeiser, B.W. (1985) <Computer generation of
          hypergeometric variáveis estatística pseudo-aleatórias.>
          Journal of Statistical Computation and Simulation 22, 127-145.

        * 'inverse', baseado no método inverso genérico.

     Veja também 'random_hypergeometric'.

 -- Função: random_hypergeometric (<n1>,<n2>,<n>)
 -- Função: random_hypergeometric (<n1>,<n2>,<n>,<m>)
     Retorna uma variável estatística pseudo-aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2.  Chamando 'random_hypergeometric' com um
     quarto argumento <m>, uma amostra aleatória de tamanho <m> será
     simulada.

     Existem dois algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global 'random_hypergeometric_algorithm', cujo valor
     padrão é 'kachit'.

     Veja também 'random_hypergeometric_algorithm'.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: pdf_negative_binomial (<x>,<n>,<p>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Negative Binomial(n,p), com 0<p<1 e n um inteiro
     positivo.  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: cdf_negative_binomial (<x>,<n>,<p>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma Negative Binomial(n,p) variável aleatória, com 0<p<1 e n um
     inteiro positivo.

     Essa função é calculada numéricamente se a variável global 'numer'
     for igual a 'true', de outra forma essa função retorna uma
     expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_negative_binomial(3,4,1/8);
                                                       1
          (%o2)            cdf_negative_binomial(3, 4, -)
                                                       8
          (%i3) cdf_negative_binomial(3,4,1/8), numer;
          (%o3)                  .006238937377929698

 -- Função: quantile_negative_binomial (<q>,<n>,<p>)
     Retorna o <q>-quantil de uma variável aleatória Negative
     Binomial(n,p), com 0<p<1 e n um inteiro positivo; em outras
     palavras, essa função é a inversa da função
     'cdf_negative_binomial'.  O argumento <q> deve ser um elemento de
     [0,1].  Para fazer uso dessa função, escreva primeiramente
     'load(distrib)'.

 -- Função: mean_negative_binomial (<n>,<p>)
     Retorna a média de uma variável aleatória Negative Binomial(n,p),
     com 0<p<1 e n um inteiro positivo.  Para fazer uso dessa função,
     escreva primeiramente 'load(distrib)'.

 -- Função: var_negative_binomial (<n>,<p>)
     Retorna a variância de uma variável aleatória Negative
     Binomial(n,p), com 0<p<1 e n um inteiro positivo.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: std_negative_binomial (<n>,<p>)
     Retorna o desvio padrão de uma variável aleatória Negative
     Binomial(n,p), com 0<p<1 e n um inteiro positivo.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: skewness_negative_binomial (<n>,<p>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Negative Binomial(n,p), com 0<p<1 e n um inteiro positivo.  Para
     fazer uso dessa função, escreva primeiramente 'load(distrib)'.

 -- Função: kurtosis_negative_binomial (<n>,<p>)
     Retorna o coeficiente de curtose de uma variável aleatória Negative
     Binomial(n,p), com 0<p<1 e n um inteiro positivo.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.

 -- Variável de opção: random_negative_binomial_algorithm
     Valor padrão: 'bernoulli'

     Esse é o algorítmo selecionado para simular variáveis estatísticas
     pseuso-aleatórias binomiais negativas.  Os algorítmos implementados
     são 'devroye', 'bernoulli' e 'inverse':

        * 'devroye', baseado no algorítmo descrito em Devroye, L. (1986)
          <Non-Uniform Random Variate Generation>.  Springer Verlag, p.
          480.

        * 'bernoulli', baseado na simulação de testes de Bernoulli.

        * 'inverse', baseado no método inverso genérico.

     Veja também 'random_negative_binomial'.

 -- Função: random_negative_binomial (<n>,<p>)
 -- Função: random_negative_binomial (<n>,<p>,<m>)
     Retorna uma variável estatística pseudo-aleatória Negative
     Binomial(n,p), com 0<p<1 e n um inteiro positivo.  Chamando
     'random_negative_binomial' com um terceiro argumento <m>, uma
     amostra aleatória de tamanho <m> será simulada.

     Existem três algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global 'random_negative_binomial_algorithm', cujo valor
     padrão é 'bernoulli'.

     Veja também 'random_negative_binomial_algorithm'.  Para fazer uso
     dessa função, escreva primeiramente 'load(distrib)'.


File: maxima.info,  Node: draw,  Next: dynamics,  Prev: distrib,  Up: Top

48 draw
*******

* Menu:

* Introdução a draw::
* Funções e Variáveis Definidas para draw::


File: maxima.info,  Node: Introdução a draw,  Next: Funções e Variáveis Definidas para draw,  Prev: draw,  Up: draw

48.1 Introdução a draw
======================

'draw' é uma interface entre o Maxima e o Gnuplot.

   Existem três funções a serem usadas n nível do Maxima: 'draw2d',
'draw3d' e 'draw'.

   Siga o link abaixo para exemplos mais elaborados deste pacote:

   <http://es.geocities.com/riotorto/maxima/gpdraw>

   Voce precisará do Gnuplot 4.2 para executar este programa.


File: maxima.info,  Node: Funções e Variáveis Definidas para draw,  Prev: Introdução a draw,  Up: draw

48.2 Funções e Variáveis Definidas para draw
============================================

 -- Opção gráfica: xrange
     Valor padrão: 'false'

     Se 'xrange' for 'false', o intevalo para a coordenada <x> é
     calculado automaticamente.

     Caso o usuário deseje um intervalo específico para <x>, esse
     intervalo deve ser fornecido como uma lista da forma definida pelo
     Maxima, como em 'xrange=[-2, 3]'.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange = [-3,5],
                       explicit(x^2,x,-1,1))$

     Veja também 'yrange' e 'zrange'.

 -- Opção gráfica: yrange
     Valor padrão: 'false'

     Se 'yrange' for 'false', the range for the <y> coordinate is
     computed automatically.

     Se o usuário sesejar um intervalo específico para <y>, esse
     intervalo deve ser fornecido como uma lista da forma definida pelo
     Maxima, como em 'yrange=[-2, 3]'.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(yrange = [-2,3],
                       explicit(x^2,x,-1,1),
                       xrange = [-3,3])$

     Veja também 'xrange' e 'zrange'.

 -- Opção gráfica: zrange
     Valor padrão: 'false'

     Se 'zrange' for 'false', o intervalo para a coordenada <z> é
     calculado automaticamente.

     Se o usuário sesejar um intervalo específico para <z>, esse
     intervalo deve ser fornecido como uma lista da forma definida pelo
     Maxima, como em 'zrange=[-2, 3]'.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(yrange = [-3,3],
                       zrange = [-2,5],
                       explicit(x^2+y^2,x,-1,1,y,-1,1),
                       xrange = [-3,3])$

     Veja também 'yrange' e 'zrange'.

 -- Opção gráfica: logx
     Valor padrão: 'false'

     Se 'logx' for 'true', o eixo <x>será desenhado em escala
     logarítmica.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(log(x),x,0.01,5),
                       logx = true)$

     Veja também 'logy' e 'logz'.

 -- Opção gráfica: logy
     Valor padrão: 'false'

     Se 'logy' for 'true', o eixo <y>será desenhado em escala
     logarítmica.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(logy = true,
                       explicit(exp(x),x,0,5))$

     Veja também 'logx' e 'logz'.

 -- Opção gráfica: logz
     Valor padrão: 'false'

     Se 'logz' for 'true', o eixo <z>será desenhado em escala
     logarítmica.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(logz = true,
                       explicit(exp(u^2+v^2),u,-2,2,v,-2,2))$

     Veja também 'logx' e 'logy'.

 -- Opção gráfica: terminal
     Valor padrão: 'screen'

     Seleciona o terminal a ser usado pelo Gnuplot; os valores possíveis
     são: 'screen' (o valor padrão), 'png', 'jpg', 'eps', e 'eps_color'.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.  Pode também ser usada como um
     argumento da função 'draw'

     Exemplos:

          (%i1) load(draw)$
          (%i2) /* screen terminal (default) */
                draw2d(explicit(x^2,x,-1,1))$
          (%i3) /* png file */
                draw2d(terminal  = 'png,
                       pic_width = 300,
                       explicit(x^2,x,-1,1))$
          (%i4) /* jpg file */
                draw2d(terminal   = 'jpg,
                       pic_width  = 300,
                       pic_height = 300,
                       explicit(x^2,x,-1,1))$
          (%i5) /* eps file */
                draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'eps)$

     Veja também 'file_name', 'pic_width', e 'pic_height'.

 -- Opção gráfica: grid
     Valor padrão: 'false'

     Se 'grid' for 'true', uma malha será desenhada sobre o plano <xy>.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(grid = true,
                       explicit(exp(u),u,-2,2))$

 -- Opção gráfica: title
     Valor padrão: '""' (a seqüência de caracteres vazia)

     A opção 'title' armazena uma seqüência de caracteres do Maxima com
     o título principal de um fundo gráfico.  Por padrão, nenhum título
     é escrito.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(u),u,-2,2),
                       title = "Exponential function")$

 -- Opção gráfica: xlabel
     Valor padrão: '""' (a seqüência de caracteres vazia)

     A opção 'xlabel' armazena uma seqüência de caracteres do Maxima com
     o rótulo para o eixo <x>.  Por padrão, nenhum rótulo é escrito.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xlabel = "Time",
                       explicit(exp(u),u,-2,2),
                       ylabel = "Population")$

     Veja também 'ylabel', e 'zlabel'.

 -- Opção gráfica: ylabel
     Valor padrão: '""' (a seqüência de caracteres vazia)

     A opção 'ylabel' armazena uma seqüência de caracteres do Maxima com
     o rótulo para o eixo <y>.  Por padrão, nenhum rótulo é escrito.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xlabel = "Time",
                       ylabel = "Population",
                       explicit(exp(u),u,-2,2) )$

     Veja também 'xlabel', e 'zlabel'.

 -- Opção gráfica: zlabel
     Valor padrão: '""' (a seqüência de caracteres vazia)

     A opção 'zlabel' armazena uma seqüência de caracteres do Maxima com
     o rótulo para o eixo <z>.  Por padrão, nenhum rótulo é escrito.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(zlabel = "Z variable",
                       ylabel = "Y variable",
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2),
                       xlabel = "X variable" )$

     Veja também 'xlabel', e 'ylabel'.

 -- Opção gráfica: xtics
     Valor padrão: 'true'

     Se 'xtics' for 'true', a marcação numérica será feitas sobre o eixo
     <x>.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) /* No tics in the x-axis */
                draw2d(xtics = false,
                       explicit(exp(u),u,-2,2))$

     Veja também 'ytics', e 'ztics'.

 -- Opção gráfica: ytics
     Valor padrão: 'true'

     Se 'ytics' for 'true', a marcação numérica será feitas sobre o eixo
     <y>.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(ytics = false,
                       explicit(exp(u),u,-2,2),
                       xtics = false)$

     Veja também 'xtics', e 'ztics'.

 -- Opção gráfica: ztics
     Valor padrão: 'true'

     Se 'ztics' for 'true', a marcação numérica será feitas sobre o eixo
     <z>.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) /* No tics in the z-axis */
                draw3d(ztics = false,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Veja também 'xtics', e 'ytics'.

 -- Opção gráfica: rot_vertical
     Valor padrão: 60

     'rot_vertical' é o ângulo (em graus) da rotação vertical (em torno
     do eixo <x>) para escolher o ponto de visualização em fundos
     gráficos tridimensionais.

     O ângulo é associado ao intervalo [0, 180].

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(rot_vertical = 170,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Veja também 'rot_horizontal'.

 -- Opção gráfica: rot_horizontal
     Valor padrão: 30

     'rot_horizontal' é o ângulo (em graus) da rotação horizontal (em
     torno do eixo <z>) para escolher o ponto de visualização em fundos
     gráficos tridimensionais.

     O ângulo é associado ao intervalo [0, 180].

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(rot_vertical = 170,
                       rot_horizontal = 360,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Veja também 'rot_vertical'.

 -- Opção gráfica: xy_file
     Valor padrão: '""' (a seqüência de caracteres vazia)

     'xy_file' é o nome do arquivo onde as coordenada serão armazenadas
     após um clique com o botão do mouse e pressionar a tecla 'x'.  Por
     padrão, nenhuma coordenada é armazenada.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

 -- Opção gráfica: user_preamble
     Valor padrão: '""' (a seqüência de caracteres vazia)

     Usuários experientes de Gnuplot podem fazer uso dessa opção para
     ajuste fino do comportamento do Gnuplot escolhendo opções para
     serem enviadas antes do comando 'plot' ou do comando 'splot'.

     O valor dessa opção deve ser uma seqüência de caracteres ou uma
     lista de seqüência de caracteres (um por linha).

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

     O terminal dumb não é suportado pelo pacote 'draw', mas é possível
     escolher o terminal dumb fazendo uso da opção 'user_preamble',
          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(x)-1,x,-1,1),
                       parametric(cos(u),sin(u),u,0,2*%pi),
                       user_preamble="set terminal dumb")$

 -- Opção gráfica: file_name
     Valor padrão: '"maxima_out"'

     Esse é o nome do arquivo onde os terminais 'png', 'jpg', 'eps' e
     'eps_color' guardarão o gráfico.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.  Pode também ser usada como um
     argumento da função 'draw'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'png)$

     Veja também 'terminal', 'pic_width', e 'pic_height'.

 -- Opção gráfica: pic_width
     Valor padrão: 640

     Essa é a largura do arquivo de bitmap gerado pelos terminais 'png'
     e 'jpg'.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.  Pode também ser usada como um
     argumento da função 'draw'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'png,
                       pic_width  = 300,
                       pic_height = 300,
                       explicit(x^2,x,-1,1))$

     Veja também 'terminal', 'file_name', e 'pic_height'.

 -- Opção gráfica: pic_height
     Valor padrão: 640

     Essa é a altura do arquivo de bitmap gerado pelos terminais 'png' e
     'jpg'.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.  Pode também ser usada como um
     argumento da função 'draw'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'png,
                       pic_width  = 300,
                       pic_height = 300,
                       explicit(x^2,x,-1,1))$

     Veja também 'terminal', 'file_name', e 'pic_width'.

 -- Opção gráfica: eps_width
     Valor padrão: 12

     Essa é a largura (medida em cm) do arquivo Postscript gerado pelos
     terminais 'eps' e 'eps_color'.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo gráfico não é importante.  Pode também ser usada
     como um argumento da função 'draw'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'eps,
                       eps_width  = 3,
                       eps_height = 3,
                       explicit(x^2,x,-1,1))$

     Veja também 'terminal', 'file_name', e 'eps_height'.

 -- Opção gráfica: eps_height
     Valor padrão: 8

     Essa é a altura (medida em cm) do arquivo Postscript gerado pelos
     terminais 'eps' e 'eps_color'.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo gráfico não é importante.  Pode também ser usada
     como um argumento da função 'draw'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'eps,
                       eps_width  = 3,
                       eps_height = 3,
                       explicit(x^2,x,-1,1))$

     Veja também 'terminal', 'file_name', e 'eps_width'.

 -- Opção gráfica: axis_bottom
     Valor padrão: 'true'

     Se 'axis_bottom' for 'true', o eixo inferior é mostrado em fundos
     gráficos bidimensionais.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_bottom = false,
                       explicit(x^3,x,-1,1))$

     Veja também 'axis_left', 'axis_top', 'axis_right', e 'axis_3d'.

 -- Opção gráfica: axis_left
     Valor padrão: 'true'

     Se 'axis_left' for 'true', o eixo da esquerda é mostrado em fundos
     gráficos bidimensionais.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_left = false,
                       explicit(x^3,x,-1,1))$

     Veja também 'axis_bottom', 'axis_top', 'axis_right', e 'axis_3d'.

 -- Opção gráfica: axis_top
     Valor padrão: 'true'

     Se 'axis_top' for 'true', o eixo superior é mostrado em fundos
     gráficos bidimensionais.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_top = false,
                       explicit(x^3,x,-1,1))$

     Veja também 'axis_bottom', 'axis_left', 'axis_right', e 'axis_3d'.

 -- Opção gráfica: axis_right
     Valor padrão: 'true'

     Se 'axis_right' for 'true', o eixo da direita é mostrado em fundos
     gráficos bidimensionais.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_right = false,
                       explicit(x^3,x,-1,1))$

     Veja também 'axis_bottom', 'axis_left', 'axis_top', e 'axis_3d'.

 -- Opção gráfica: axis_3d
     Valor padrão: 'true'

     Se 'axis_3d' for 'true', os eixos <x>, <y> e <z> são mostrados em
     fundos gráficos tridimensionais.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(axis_3d = false,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Veja também 'axis_bottom', 'axis_left', 'axis_top', e 'axis_right'
     para eixos em duas dimensões.

 -- Opção gráfica: palette
     Valor padrão: 'color'

     'palette' indica como mapear os valores reais de uma matriz passada
     para o objeto 'image' sobre componentes de cor.

     'palette' é um vetor comprimento três com componentes variando de
     -36 a +36; cada valor é um índice para uma fórmula mapeando os
     níveis sobre as cores vermelho, verde e blue, respectivamente:
           0: 0               1: 0.5           2: 1
           3: x               4: x^2           5: x^3
           6: x^4             7: sqrt(x)       8: sqrt(sqrt(x))
           9: sin(90x)       10: cos(90x)     11: |x-0.5|
          12: (2x-1)^2       13: sin(180x)    14: |cos(180x)|
          15: sin(360x)      16: cos(360x)    17: |sin(360x)|
          18: |cos(360x)|    19: |sin(720x)|  20: |cos(720x)|
          21: 3x             22: 3x-1         23: 3x-2
          24: |3x-1|         25: |3x-2|       26: (3x-1)/2
          27: (3x-2)/2       28: |(3x-1)/2|   29: |(3x-2)/2|
          30: x/0.32-0.78125 31: 2*x-0.84     32: 4x;1;-2x+1.84;x/0.08-11.5
          33: |2*x - 0.5|    34: 2*x          35: 2*x - 0.5
          36: 2*x - 1
     números negativos significam componentes negativos de cores.

     'palette = gray' and 'palette = color' are short cuts for 'palette
     = [3,3,3]' and 'palette = [7,5,15]', respectively.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo do gráfico não é importante.

     Exemplos:

          (%i1) load(draw)$
          (%i2) im: apply(
                     'matrix,
                      makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) /* palette = color, default */
                draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(palette = gray, image(im,0,0,30,30))$
          (%i5) draw2d(palette = [15,20,-4],
                       colorbox=false,
                       image(im,0,0,30,30))$

     Veja também 'colorbox'.

 -- Opção gráfica: colorbox
     Valor padrão: 'true'

     If 'colorbox' is 'true', a color scale is drawn together with
     'image' objects.

     Since this is a global graphics option, its position in the scene
     description does not matter.

     Exemplo:

          (%i1) load(draw)$
          (%i2) im: apply('matrix,
                           makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(colorbox=false, image(im,0,0,30,30))$

     Veja também 'palette'.

 -- Opção gráfica: enhanced3d
     Valor padrão: 'false'

     Se 'enhanced3d' for 'true', superfícies são coloridas em gráficos
     tridimensionais; em outras palavras, pode escolher o modo pm3d do
     Gnuplot.

     Veja a opção 'palette' para aprender como paletas são
     especificadas.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(surface_hide = true,
                       enhanced3d   = true,
                       palette      = gray,
                       explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3))$

 -- Opção gráfica: point_size
     Valor padrão: 1

     'point_size' escolhe o tamanho para os pontos do gráfico.  Esse
     valor deve ser um número não negativo.

     Essa opção afeta os seguintes objetos gráficos:
        * 'gr2d': 'points'.

        * 'gr3d': 'points'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(points(makelist([random(20),random(50)],k,1,10)),
                       point_size = 5,
                       points(makelist(k,k,1,20),makelist(random(30),k,1,20)))$

 -- Opção gráfica: point_type
     Valor padrão: 1

     'point_type' indica como pontos isolados são mostrados; o valor
     dessa opção pode ser qualquer índice inteiro maior que ou igual a
     -1, ou o nome de um estilo de ponto: '$none' (-1), 'dot' (0),
     'plus' (1), 'multiply' (2), 'asterisk' (3), 'square' (4),
     'filled_square' (5), 'circle' (6), 'filled_circle' (7),
     'up_triangle' (8), 'filled_up_triangle' (9), 'down_triangle' (10),
     'filled_down_triangle' (11), 'diamant' (12) e 'filled_diamant'
     (13).

     Essa opção afeta os seguintes objetos gráficos:
        * 'gr2d': 'points'.

        * 'gr3d': 'points'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange = [0,10],
                       yrange = [0,10],
                       point_size = 3,
                       point_type = 1,
                       points([[1,1],[5,1],[9,1]]),
                       point_type = 2,
                       points([[1,2],[5,2],[9,2]]),
                       point_type = asterisk,
                       points([[1,3],[5,3],[9,3]]),
                       point_type = 4,
                       points([[1,4],[5,4],[9,4]]),
                       point_type = 5,
                       points([[1,5],[5,5],[9,5]]),
                       point_type = 6,
                       points([[1,6],[5,6],[9,6]]),
                       point_type = filled_circle,
                       points([[1,7],[5,7],[9,7]]),
                       point_type = 8,
                       points([[1,8],[5,8],[9,8]]),
                       point_type = filled_diamant,
                       points([[1,9],[5,9],[9,9]]) )$

 -- Opção gráfica: points_joined
     Valor padrão: 'false'

     Se 'points_joined' for 'true', pontos são unidos por linhas retas.

     Essa opção afeta os seguintes objetos gráficos:
        * 'gr2d': 'points'.

        * 'gr3d': 'points'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange        = [0,10],
                       yrange        = [0,4],
                       point_size    = 3,
                       point_type    = 1,
                       line_type     = 3,
                       points([[1,1],[5,1],[9,1]]),
                       points_joined = true,
                       point_type    = 3,
                       line_type     = 5,
                       points([[1,2],[5,2],[9,2]]),
                       point_type    = 5,
                       line_type     = 8,
                       line_width    = 7,
                       points([[1,3],[5,3],[9,3]]) )$

 -- Opção gráfica: filled_func
     Valor padrão: 'false'

     'filled_func' indica se uma função é preenchida ('true') ou não
     ('false').

     Essa opção afeta somente objetos gráfico bidimensional 'explicit'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = red,
                       filled_func = true,
                       explicit(sin(x),x,0,10) )$

     Veja também 'fill_color'.

 -- Opção gráfica: transparent
     Valor padrão: 'false'

     Se 'transparent' for 'true', regiões internas de poligonos são
     preenchidas de acordo com 'fill_color'.

     Essa opção afeta os seguintes objetos gráficos:
        * 'gr2d': 'polygon', 'rectangle', e 'ellipse'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(polygon([[3,2],[7,2],[5,5]]),
                       transparent = true,
                       color       = blue,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Opção gráfica: border
     Valor padrão: 'true'

     Se 'border' for 'true', bordas de polígonos são colorizadas de
     acordo com 'line_type' e 'line_width'.

     Essa opção afeta os seguintes objetos gráficos:
        * 'gr2d': 'polygon', 'rectangle', e 'ellipse'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(color       = brown,
                       line_width  = 8,
                       polygon([[3,2],[7,2],[5,5]]),
                       border      = false,
                       fill_color  = blue,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Opção gráfica: head_both
     Valor padrão: 'false'

     Se 'head_both' for 'true', vetores são mostrados com seta dupla na
     ponta.  Se 'false', somente uma seta é mostrada.

     Essa opção somente é relevante para objetos do tipo 'vector'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,8],
                       yrange      = [0,8],
                       head_length = 0.7,
                       vector([1,1],[6,0]),
                       head_both   = true,
                       vector([1,7],[6,0]) )$

     Veja também 'head_length', 'head_angle', e 'head_type'.

 -- Opção gráfica: head_length
     Valor padrão: 2

     'head_length' indica, em unidades do eixo <x>, o comprimento da
     ponta da seta do vetor.

     Essa opção é relevante somente para objetos do tipo 'vector'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,8],
                       vector([0,1],[5,5]),
                       head_length = 1,
                       vector([2,1],[5,5]),
                       head_length = 0.5,
                       vector([4,1],[5,5]),
                       head_length = 0.25,
                       vector([6,1],[5,5]))$

     Veja também 'head_both', 'head_angle', e 'head_type'.

 -- Opção gráfica: head_angle
     Valor padrão: 45

     'head_angle' indica o ângulo, em graus, entre a ponta da seta do
     vetor e o segmento que forma o corpo do vetor.

     Essa opção é relevante somente para objetos do tipo 'vector'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,10],
                       yrange      = [0,9],
                       head_length = 0.7,
                       head_angle  = 10,
                       vector([1,1],[0,6]),
                       head_angle  = 20,
                       vector([2,1],[0,6]),
                       head_angle  = 30,
                       vector([3,1],[0,6]),
                       head_angle  = 40,
                       vector([4,1],[0,6]),
                       head_angle  = 60,
                       vector([5,1],[0,6]),
                       head_angle  = 90,
                       vector([6,1],[0,6]),
                       head_angle  = 120,
                       vector([7,1],[0,6]),
                       head_angle  = 160,
                       vector([8,1],[0,6]),
                       head_angle  = 180,
                       vector([9,1],[0,6]) )$

     Veja também 'head_both', 'head_length', e 'head_type'.

 -- Opção gráfica: head_type
     Valor padrão: 'filled'

     'head_type' é usada para especificar como a ponta é mostrada.
     Valores possíveis são: 'filled' (ponta fechada e preenchida),
     'empty' (ponta fechada mas não preenchida), e 'nofilled' (ponta
     aberta).

     Essa opção é relevante somente para objetos do tipo 'vector'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,10],
                       head_length = 1,
                       vector([0,1],[5,5]), /* default type */
                       head_type = 'empty,
                       vector([3,1],[5,5]),
                       head_type = 'nofilled,
                       vector([6,1],[5,5]))$

     Veja também 'head_both', 'head_angle', e 'head_length'.

 -- Opção gráfica: label_alignment
     Valor padrão: 'center'

     'label_alignment' é usado para especificar onde escrever rótulos
     com relação às coordenadas fornecidas.  Valores possíveis são:
     'center', 'left', e 'right'.

     Essa opção é relevante somente para objetos do tipo 'label'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange          = [0,10],
                       yrange          = [0,10],
                       points_joined   = true,
                       points([[5,0],[5,10]]),
                       color           = blue,
                       label("Centered alignment (default)",5,2),
                       label_alignment = 'left,
                       label("Left alignment",5,5),
                       label_alignment = 'right,
                       label("Right alignment",5,8))$

     Veja também 'label_orientation', e 'color'.

 -- Opção gráfica: label_orientation
     Valor padrão: 'horizontal'

     'label_orientation' é usada para especificar a orientação dos
     rótulos.  Valores possíveis são: 'horizontal', e 'vertical'.

     Essa opção é relevante somente para objetos do tipo 'label'.

     Exemplo:

     Nesse exemplo, um ponto fictício é adicionado para firmar uma
     imagem.  o pacote 'draw' precisa sempre de dados para montar um
     fundo.
          (%i1) load(draw)$
          (%i2) draw2d(xrange     = [0,10],
                       yrange     = [0,10],
                       point_size = 0,
                       points([[5,5]]),
                       color      = navy,
                       label("Horizontal orientation (default)",5,2),
                       label_orientation = 'vertical,
                       color             = "#654321",
                       label("Vertical orientation",1,5))$

     Veja também 'label_alignment', e 'color'.

 -- Opção gráfica: color
     Valor padrão: '"black"'

     'color' especifica a cor para o desenho de linhas, pontos, bordas
     de polígonos e rótulos.

     Cores podem ser fornecidas como nomes ou em código hexadecimal rgb.

     Nomes de cores disponíveis atualmente são: '"white"', '"black"',
     '"gray0"', '"grey0"', '"gray10"', '"grey10"', '"gray20"',
     '"grey20"', '"gray30"', '"grey30"', '"gray40"', '"grey40"',
     '"gray50"', '"grey50"', '"gray60"', '"grey60"', '"gray70"',
     '"grey70"', '"gray80"', '"grey80"', '"gray90"', '"grey90"',
     '"gray100"', '"grey100"', '"gray"', '"grey"', '"light-gray"',
     '"light-grey"', '"dark-gray"', '"dark-grey"', '"red"',
     '"light-red"', '"dark-red"', '"yellow"', '"light-yellow"',
     '"dark-yellow"', '"green"', '"light-green"', '"dark-green"',
     '"spring-green"', '"forest-green"', '"sea-green"', '"blue"',
     '"light-blue"', '"dark-blue"', '"midnight-blue"', '"navy"',
     '"medium-blue"', '"royalblue"', '"skyblue"', '"cyan"',
     '"light-cyan"', '"dark-cyan"', '"magenta"', '"light-magenta"',
     '"dark-magenta"', '"turquoise"', '"light-turquoise"',
     '"dark-turquoise"', '"pink"', '"light-pink"', '"dark-pink"',
     '"coral"', '"light-coral"', '"orange-red"', '"salmon"',
     '"light-salmon"', '"dark-salmon"', '"aquamarine"', '"khaki"',
     '"dark-khaki"', '"goldenrod"', '"light-goldenrod"',
     '"dark-goldenrod"', '"gold"', '"beige"', '"brown"', '"orange"',
     '"dark-orange"', '"violet"', '"dark-violet"', '"plum"' and
     '"purple"'.

     Componentes cromáticos em código hexadecimal são introduzidos na
     forma '"#rrggbb"'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^2,x,-1,1), /* default is black */
                       color = "red",
                       explicit(0.5 + x^2,x,-1,1),
                       color = blue,
                       explicit(1 + x^2,x,-1,1),
                       color = "light-blue", /* double quotes if - is used */
                       explicit(1.5 + x^2,x,-1,1),
                       color = "#23ab0f",
                       label("Esse é um rótulo",0,1.2)  )$

     Veja também 'fill_color'.

 -- Opção gráfica: fill_color
     Valor padrão: '"red"'

     'fill_color' especifica a cor para preenchimento de polígonos e
     funções explicitamente bidimensionais.

     Veja 'color' para aprender como cores são especificadas.

 -- Opção gráfica: line_width
     Valor padrão: 1

     'line_width' é a lagura das linhas do gráfico.  Seu valor deve ser
     um número positivo.

     Essa opção afeta os seguintes objetos gráficos:
        * 'gr2d': 'points', 'polygon', 'rectangle', 'ellipse', 'vector',
          'explicit', 'implicit', 'parametric' e 'polar'.

        * 'gr3d': 'points' e 'parametric'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^2,x,-1,1), /* default width */
                       line_width = 5.5,
                       explicit(1 + x^2,x,-1,1),
                       line_width = 10,
                       explicit(2 + x^2,x,-1,1))$

     Veja também 'line_type'.

 -- Opção gráfica: line_type
     Valor padrão: 'solid'

     'line_type' indica como linhas são mostradas; valores possíveis são
     'solid' e 'dots'.

     Essa opção afeta os seguintes objetos gráficos:
        * 'gr2d': 'points', 'polygon', 'rectangle', 'ellipse', 'vector',
          'explicit', 'implicit', 'parametric' e 'polar'.

        * 'gr3d': 'points', 'explicit', 'parametric' e
          'parametric_surface'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(line_type = dots,
                       explicit(1 + x^2,x,-1,1),
                       line_type = solid, /* default */
                       explicit(2 + x^2,x,-1,1))$

     Veja também 'line_width'.

 -- Opção gráfica: nticks
     Valor padrão: 30

     'nticks' é o número de amostra de pontos usado pelas rotinas de
     montagem de gráfico.

     Essa opção afeta os seguintes objetos gráficos:
        * 'gr2d': 'ellipse', 'explicit', 'parametric' e 'polar'.

        * 'gr3d': 'parametric'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(transparent = true,
                       ellipse(0,0,4,2,0,180),
                       nticks = 5,
                       ellipse(0,0,4,2,180,180) )$

 -- Opção gráfica: adapt_depth
     Valor padrão: 10

     'adapt_depth' é o número máximo de quebras usado pelas rotinas
     adaptativos de impressão.

     Essa opção é relevante somente para funções 2d 'explicitas'.

 -- Opção gráfica: key
     Valor padrão: '""' (a seqüência de caracteres vazia)

     'key' é o nome de uma função na legenda.  Se 'key' é uma seqüência
     de caracteres vazia, nenhuma chave é atribuída à função.

     Essa opção afeta os seguintes objetos gráficos:
        * 'gr2d': 'points', 'polygon', 'rectangle', 'ellipse', 'vector',
          'explicit', 'implicit', 'parametric', e 'polar'.

        * 'gr3d': 'points', 'explicit', 'parametric', e
          'parametric_surface'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(key = "Seno",
                       explicit(sin(x),x,0,10),
                       key = "Cosseno",
                       line_type = 3,
                       explicit(cos(x),x,0,10) )$

 -- Opção gráfica: xu_grid
     Valor padrão: 30

     'xu_grid' é o número de coordenadas da primeira variável ('x' na
     forma explícita e o número de coordenadas de 'u' em superfícies
     tridimensionais na forma paramétrica) para contruir a grade dos
     pontos de amostra.

     Essa opção afeta os seguintes objetos gráficos:
        * 'gr3d': 'explicit' e 'parametric_surface'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     Veja também 'yv_grid'.

 -- Opção gráfica: yv_grid
     Valor padrão: 30

     'yv_grid' é o número de coordenadas da segunda variável ('y' na
     forma explícita e o número de coordenadas de 'v' em superfícies
     tridimensionais na forma paramétrica) para construir a grade dos
     pontos de amostra.

     Essa opção afeta os seguintes objetos gráficos:
        * 'gr3d': 'explicit' e 'parametric_surface'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     Veja também 'xu_grid'.

 -- Opção gráfica: surface_hide
     Valor padrão: 'false'

     Se 'surface_hide' for 'true', partes escondidas não são mostradas
     no gráfico em superfícies tridimensioais.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw(columns=2,
                     gr3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)),
                     gr3d(surface_hide = true,
                          explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)) )$

 -- Opção gráfica: contour
     Valor padrão: 'none'

     Option 'contour' torna o usuário capaz de selecionar onde imprimir
     linhas de contorno.  Valores possíveis são:

        * 'none': nenhuma linha de contorno é mostrada.

        * 'base': linhas de contorno são projetadas no plano xy.

        * 'surface': linhas de contorno são mostradas sobre a
          superfície.

        * 'both': duas linhas de contorno são mostradas: no plano xy e
          sobre a superfície.

        * 'map': linhas de contorno são projetadas sobre o plano xy, e o
          ponto de boservação é escolhido na vertical.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 15,
                       contour        = both,
                       surface_hide   = true) $

 -- Opção gráfica: contour_levels
     Valor padrão: 5

     'contour_levels' é o número de níveis em gráficos de contorno.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 15,
                       contour        = both,
                       surface_hide   = true) $

 -- Opção gráfica: columns
     Valor padrão: 1

     'columns' é o número de colunas em gráficos multiplos.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo do gráfico não é importante.  Pode também ser
     usado como um argumento da função 'draw'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) scene1: gr2d(title="Elipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triângulo",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$

 -- Opção gráfica: ip_grid
     Valor padrão: '[50, 50]'

     'ip_grid' escolhe a grade para a primeira amostragem em gráficos
     implícitos.

     Essa opção é relevante somente para 'implicit' objects.

 -- Opção gráfica: ip_grid_in
     Valor padrão: '[5, 5]'

     'ip_grid_in' escolhe a grade para a segunda amostragem em gráficos
     implícitos.

     Essa opção é relevante somente para 'implicit' objects.

 -- Construtor de fundo gráfico: gr2d (<opção gráfica>, ..., <objeto
          gráfico>, ...)

     A função 'gr2d' constrói um objeto descrevendo um fundo gráfico em
     duas dimensões.  Arguments are opções gráficas e objetos gráficos.
     Esse fundo gráfico é interpretado seqüêncialmente: opções gráficas
     afetam aqueles objetos gráficos colocados imediatamente à sua
     direita.

     Para fazer uso dessa função escreva primeiramente 'load(draw)'.

     Adiante encontra-se uma lista de objetos gráficos disponívies para
     fundos gráficos em duas dimensões:

        * 'points([[x1,y1], [x2,y2], [x3,y3],...])' ou
          'points([x1,x2,x3,...], [y1,y2,y3,...])': posiciona os pontos
          '[x1,y1]', '[x2,y2]', '[x2,y2]', ...  no gráfico.

          Esse objeto é efetado pelas seguintes opções gráficas:
          'point_size', 'point_type', 'points_joined', 'line_width',
          'key', 'line_type' e 'color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(key           = "Small points",
                            points(makelist([random(20),random(50)],k,1,10)),
                            point_type    = 6,
                            point_size    = 3,
                            points_joined = true,
                            key           = "Great points",
                            points(makelist(k,k,1,20),makelist(random(30),k,1,20)))$

        * 'polygon([[x1,y1], [x2,y2], [x3,y3],...])' ou
          'polygon([x1,x2,x3,...], [y1,y2,y3,...])': desenha um polígono
          com vértices '[x1,y1]', '[x2,y2]', '[x2,y2]', ...  no plano.

          Esse objeto é afetado pelas seguintes opçs gráficas:
          'transparent', 'fill_color', 'border', 'line_width', 'key',
          'line_type' 'color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(color      = "#e245f0",
                            line_width = 8,
                            polygon([[3,2],[7,2],[5,5]]),
                            border      = false,
                            fill_color  = yellow,
                            polygon([[5,2],[9,2],[7,5]]) )$

        * 'rectangle([x1,y1], [x2,y2])': desenha um retângulo partindo
          do vértice '[x1,y1]' e terminando no vértice '[x2,y2]' oposto
          ao primeiro.

          Esse objeto é afetado pelas seguintes opções gráficas:
          'transparent', 'fill_color', 'border', 'line_width', 'key',
          'line_type' e 'color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(fill_color  = red,
                            line_width  = 6,
                            line_type   = dots,
                            transparent = false,
                            fill_color   = blue,
                            rectangle([-2,-2],[8,-1]),   /* opposite vertices */
                            transparent = true,
                            line_type   = solid,
                            line_width  = 1,
                            rectangle([9,4],[2,-1.5]),
                            xrange      = [-3,10],
                            yrange      = [-3,4.5] )$

        * 'ellipse(xc, yc, a, b, ang1, ang2)': desenha uma elipse com
          centro em '[xc, yc]' com semi-eixo maior 'a' e semi-eixo menor
          'b' traçando um arco de elipse que se inicia no ângulo 'ang1'
          e que vai até o ângulo 'ang2'.  semi axis 'a' e 'b',
          respectively, from angle 'ang1' to angle 'ang2'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          'nticks', 'transparent', 'fill_color', 'border', 'line_width',
          'line_type', 'key' e 'color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(transparent = false,
                            fill_color  = 8,
                            color       = gray30,
                            transparent = false,
                            line_width  = 5,
                            ellipse(0,6,3,2,270,-270),  /* center (x,y), a, b, start & end in degrees */
                            transparent = true,
                            color       = blue,
                            line_width  = 3,
                            ellipse(2.5,6,2,3,30,-90),
                            xrange      = [-3,6],
                            yrange      = [2,9] )$

        * 'label(rótulo,x,y)': escreve o 'rótulo' no ponto '[x,y]'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          'label_alignment', 'label_orientation' e 'color'.

          Exemplo:

          Nesse exemplo, um ponto imaginário é adicionado para firmar a
          imagem.  O pacote 'draw' precisa sempre da dados para desenhar
          um fundo.  Essas cores podem mudar em diferentes terminais.
               (%i1) load(draw)$
               (%i2) draw2d(explicit(x^2,x,-1,1),
                            color = "red",
                            label("Label in red",0,0.3),
                            color = "#0000ff",
                            label("Label in blue",0,0.6),
                            color = "light-blue", /* double quotes if - is used */
                            label("Rótulo em light-blue",0,0.9)  )$

        * 'vector([x,y], [dx,dy])': desenha um vetor de componentes
          ortogonais '[dx,dy]' com orígem eno ponto '[x,y]'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          'head_both', 'head_length', 'head_angle', 'head_type',
          'line_width', 'line_type' e 'key'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(xrange      = [0,12],
                            yrange      = [0,10],
                            head_length = 1,
                            vector([0,1],[5,5]), /* default type */
                            head_type = 'empty,
                            vector([3,1],[5,5]),
                            head_both = true,
                            head_type = 'nofilled,
                            line_type = dots,
                            vector([6,1],[5,5]))$

        * 'explicit(fcn,var,minval,maxval)': monta o gráfico da função
          explícita 'fcn', com variável 'var' assumindo valores de
          'minval' a 'maxval'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          'nticks', 'adapt_depth', 'line_width', 'line_type', 'key',
          'filled_func', 'fill_color' e 'color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(line_width = 3,
                            color      = blue,
                            explicit(x^2,x,-3,3) )$
               (%i3) draw2d(fill_color  = brown,
                            filled_func = true,
                            explicit(x^2,x,-3,3) )$

        * 
          'implicit(fcn,x-var,x-minval,x-maxval,y-var,y-minval,y-maxval)':
          monta o gráfico da função implícita definida por 'fcn', com
          variável 'x-var' assumindo de 'x-minval' a 'x-maxval', e
          variável 'y-var' assumindo valores de 'y-minval' a 'y-maxval'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          'ip_grid', 'ip_grid_in', 'line_width', 'line_type', 'key' e
          'color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(terminal  = eps,
                            grid      = true,
                            line_type = solid,
                            key       = "y^2=x^3-2*x+1",
                            implicit(y^2=x^3-2*x+1, x, -4,4, y, -4,4),
                            line_type = dots,
                            key       = "x^3+y^3 = 3*x*y^2-x-1",
                            implicit(x^3+y^3 = 3*x*y^2-x-1, x, -4,4, y, -4,4),
                            title     = "Duas funções implícitas" )$

        * 'polar(radius,ang,minang,maxang)': plots function
          'radius(ang)' defined in polar coordinates, com a variável
          'ang' assumindo valores de 'minang' a 'maxang'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          'nticks', 'line_width', 'line_type', 'key' e 'color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(user_preamble = "set grid polar",
                            nticks        = 200,
                            xrange        = [-5,5],
                            yrange        = [-5,5],
                            line_type     = 6,
                            line_width    = 3,
                            title         = "Hyperbolic Spiral",
                            polar(10/theta,theta,1,10*%pi) )$

        * 'parametric(xfun,yfun,par,parmin,parmax)': monta o gráfico da
          função paramétrica '[xfun,yfun]', com parâmetro 'par'
          assumindo valores de 'parmin' a 'parmax'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          'nticks', 'line_width', 'line_type', 'key' e 'color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(explicit(exp(x),x,-1,3),
                            color = red,
                            key   = "Esse é a unidade paramétrica!!",
                            parametric(2*cos(rrr),rrr^2,rrr,0,2*%pi))$

        * 'image(im,x0,y0,width,height)': monta o gráfico da imágem 'im'
          em uma região retangular do vértice '(x0,y0)' ao vértice
          '(x0+width,y0+height)' no plano real.  O argumeto 'im' deve
          ser uma matriz de números reais, ou uma matriz de vetores de
          comprimento três.

          Se 'im' for uma matriz de números reais, valores de pixel são
          interpretados conforme a opção gráfica 'palette', que é um
          vetor de comprimento três com componentes numéricas variando
          de -36 a +36; cada valor é um índice para uma fórmula mapeando
          os níveis sobre as cores vermelha, verde e azul,
          respectivamente:
                0: 0               1: 0.5           2: 1
                3: x               4: x^2           5: x^3
                6: x^4             7: sqrt(x)       8: sqrt(sqrt(x))
                9: sin(90x)       10: cos(90x)     11: |x-0.5|
               12: (2x-1)^2       13: sin(180x)    14: |cos(180x)|
               15: sin(360x)      16: cos(360x)    17: |sin(360x)|
               18: |cos(360x)|    19: |sin(720x)|  20: |cos(720x)|
               21: 3x             22: 3x-1         23: 3x-2
               24: |3x-1|         25: |3x-2|       26: (3x-1)/2
               27: (3x-2)/2       28: |(3x-1)/2|   29: |(3x-2)/2|
               30: x/0.32-0.78125 31: 2*x-0.84     32: 4x;1;-2x+1.84;x/0.08-11.5
               33: |2*x - 0.5|    34: 2*x          35: 2*x - 0.5
               36: 2*x - 1
          números negativos significam componente de cor negativa.

          'palette = gray' e 'palette = color' são atalhos para 'palette
          = [3,3,3]' e 'palette = [7,5,15]', respectivamente.

          Se 'im' for uma matriz de vetores de comprimento três, eles
          são interpretados como componenetes das cores vermelho, verde
          e azul.

          Exemplos:

          se 'im' for uma matriz de números reais, valores de pixel são
          interpretados conforme a opção gráfica 'palette'.
               (%i1) load(draw)$
               (%i2) im: apply(
                          'matrix,
                           makelist(makelist(random(200),i,1,30),i,1,30))$
               (%i3) /* palette = color, default */
                     draw2d(image(im,0,0,30,30))$
               (%i4) draw2d(palette = gray, image(im,0,0,30,30))$
               (%i5) draw2d(palette = [15,20,-4],
                            colorbox=false,
                            image(im,0,0,30,30))$

          Veja também 'colorbox'.

          Se 'im' for uma matriz de vetores de comprimento três, eles
          são interpretados como componentes da cores vermelho, verde e
          azul.
               (%i1) load(draw)$
               (%i2) im: apply(
                           'matrix,
                            makelist(
                              makelist([random(300),
                                        random(300),
                                        random(300)],i,1,30),i,1,30))$
               (%i3) draw2d(image(im,0,0,30,30))$

     Veja também as seguintes opções gráficas: 'xrange', 'yrange',
     'logx', 'logy', 'terminal', 'grid', 'title', 'xlabel', 'ylabel',
     'xtics', 'ytics', 'xy_file', 'file_name', 'pic_width',
     'pic_height', 'eps_width', 'eps_height', 'user_preamble',
     'axis_bottom', 'axis_left', 'axis_top', e 'axis_right'.

 -- Scene constructor: gr3d (<opção gráfica>, ..., <objeto gráfico>,
          ...)

     A função 'gr3d' constrói um objeto descrevendo um fundo gráfico
     tridimensional.  Argumentos são opções gráficas e objetos gráficos.
     Esse fundo gráfico é interpretado seqüêncialmente: opções gráficas
     afetam aqueles objetos gráficos colocados imediatamente à sua
     direita.

     Para fazer uso dessa função escreva primeiramente 'load(draw)'.

     Essa é a lista dos objetos gráficos disponíveis para fundos
     gráficos tridimensionais:

        * 'points([[x1,y1,z1], [x2,y2,z2], [x3,y3,z3],...])' ou
          'points([x1,x2,x3,...], [y1,y2,y3,...], [z1,z2,z3,...])':
          posiciona os pontos '[x1,y1,z1]', '[x2,y2,z2]', '[x2,y2,z3]',
          ...  no gráfico.

          Esse objeto é afetado pelas seguintes opções gráficas:
          'point_size', 'point_type', 'points_joined', 'line_width',
          'key', 'line_type' e 'color'.

          Exemplos:

          Uma amostra tridimensional,
               (%i1) load(draw)$
               (%i2) load (numericalio)$
               (%i3) s2 : read_matrix (file_search ("wind.data"))$
               (%i4) draw3d(title      = "Velocidades diárias de ventos disponíveis",
                            point_size = 2,
                            points(args(submatrix (s2, 4, 5))) )$

          Duas amostras tridimensionais,
               (%i1) load(draw)$
               (%i2) load (numericalio)$
               (%i3) s2 : read_matrix (file_search ("wind.data"))$
               (%i4) draw3d(title      = "Velocidades diárias de ventos disponíveis. Dois conjuntos de dados",
                            point_size = 2,
                            key        = "Amostras das estações 1, 2 e 3",
                            points(args(submatrix (s2, 4, 5))),
                            point_type = 4,
                            key        = "Amostras das estações 1, 4 e 5",
                            points(args(submatrix (s2, 2, 3))) )$

        * 'label(rótulo,x,y,z)': escreve 'rótulo' no ponto '[x,y,z]'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          'label_alignment', 'label_orientation' e 'color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                            color = red,
                            label("SUBINDO",-2,0,3),
                            color = blue,
                            label("DESCENDO",2,0,-3) )$

        * 'vector([x,y,z], [dx,dy,dz])': monta o gráfico do vetor
          '[dx,dy,dz]' com orígem em '[x,y,z]'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          'head_both', 'head_type', 'line_width', 'line_type', 'key' e
          'color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw3d(color = cyan,
                            vector([0,0,0],[1,1,1]/sqrt(3)),
                            vector([0,0,0],[1,-1,0]/sqrt(2)),
                            vector([0,0,0],[1,1,-2]/sqrt(6)) )$

        * 'explicit(fcn,var1,minval1,maxval1,var2,minval2,maxval2)':
          monta o gráfico da função explícita 'fcn', com a variável
          'var1' assumindo valores de 'minval1' a 'maxval1' e variável
          'var2' assumindo valores de 'minval2' a 'maxval2'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          'xu_grid', 'yv_grid', 'line_type', 'key' e 'color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw3d(key   = "Gauss",
                            color = "#a02c00",
                            explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3),
                            color = blue,
                            key   = "Plane",
                            explicit(x+y,x,-5,5,y,-5,5),
                            surface_hide = true)$

        * 'parametric(xfun,yfun,zfun,par,parmin,parmax)': monta o
          gráfico da curva paramétrica '[xfun,yfun,zfun]', com parâmetro
          'par' assumindo valores de 'parmin' a 'parmax'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          'nticks', 'line_width', 'line_type', 'key' e 'color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                            color = royalblue,
                            parametric(cos(5*u)^2,sin(7*u),u-2,u,0,2),
                            color      = turquoise,
                            line_width = 2,
                            parametric(t^2,sin(t),2+t,t,0,2),
                            surface_hide = true,
                            title = "Surface & curves" )$

        * 
          'parametric_surface(xfun,yfun,zfun,par1,par1min,par1max,par2,par2min,par2max)':
          monta o gráfico da superfície paramétrica '[xfun,yfun,zfun]',
          com parâmetro 'par1' assumindo valores de 'par1min' a
          'par1max' e o parâmetro 'par2' assumindo valores de 'par2min'
          a 'par2max'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          'xu_grid', 'yv_grid', 'line_type', 'key' e 'color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw3d(title          = "Concha do mar",
                            xu_grid        = 100,
                            yv_grid        = 25,
                            rot_vertical   = 100,
                            rot_horizontal = 20,
                            surface_hide   = true,
                            parametric_surface(0.5*u*cos(u)*(cos(v)+1),
                                               0.5*u*sin(u)*(cos(v)+1),
                                               u*sin(v) - ((u+3)/8*%pi)^2 - 20,
                                               u, 0, 13*%pi, v, -%pi, %pi) )$

     Veja também as seguintes opções gráficas: 'xrange', 'yrange',
     'zrange', 'logx', 'logy', 'logz', 'terminal', 'grid', 'title',
     'xlabel', 'ylabel', 'zlabel', 'xtics', 'ytics', 'ztics', 'xy_file',
     'user_preamble', 'axis_bottom', 'axis_left', 'axis_top',
     'file_name', 'pic_width', 'pic_height', 'eps_width', 'eps_height',
     'axis_right', 'rot_vertical', 'rot_horizontal', 'axis_3d',
     'xu_grid', 'yv_grid', 'surface_hide', 'contour', 'contour_levels',
     'palette', 'colorbox' e 'enhanced3d'.

 -- Function: draw (<gr2d>, ..., <gr3d>, ..., <opções>, ...)

     Monta o fundo de uma série de gráficos; seus argumentos são objetos
     'gr2d' e 'gr3d', juntamente com algumas opções.  Por padrão, o
     fundos gráficos são colocados juntos em uma coluna.

     A função 'draw' aceita duas opções possíveis: 'terminal' e
     'columns'.

     As funções 'draw2d' e 'draw3d' são atalhos para serem usados quando
     somente um fundo gráfico é requerido, em duas ou três dimensões,
     respectivamente.

     Para fazer uso dessa função escreva primeiramente 'load(draw)'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) scene1: gr2d(title="Ellipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triangle",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$

 -- Função: draw2d (<opção>, <objeto gráfico>, ...)

     Essa função é um atalho para 'draw2d(gr2d(<opções>, ..., <objeto
     gráfico>, ...))'.

     Pode ser usada para montar gráfico de um único fundo bidimensional.

     Para fazer uso dessa função escreva primeiramente 'load(draw)'.

 -- Função: draw3d (<opção>, <graphic object>, ...)

     Essa função é um atalho para 'draw3d(gr3d(<opções>, ..., <objeto
     gráfico>, ...))'.

     Pode ser usada para montar o fundo gráfico único tridmensional.

     Para fazer uso dessa função escreva primeiramente 'load(draw)'.

 -- Variável: draw_pipes
     Valor padrão: 'true'

     Quando 'draw_pipes' for 'true', Maxima comunica-se com Gnuplot
     diretamente (via pipes).  Se 'draw_pipes' for 'false', Maxima
     comunica-se com Gnuplot via arquivos.  Essa opção não está
     disponível para usuários windows.


File: maxima.info,  Node: dynamics,  Next: eval_string,  Prev: draw,  Up: Top

49 dynamics
***********

* Menu:

* Introdução a dynamics::
* Funções e Variáveis Definidas para dynamics::


File: maxima.info,  Node: Introdução a dynamics,  Next: Funções e Variáveis Definidas para dynamics,  Prev: dynamics,  Up: dynamics

49.1 Introdução a dynamics
==========================

O pacote adicional 'dynamics' inclui muitas funções para criar várias
representações gráficas de sistemas dinâmicos discretos e fractais, e
uma implementação deo método numérico de Runge-Kutta de quarta ordem
para a resolução de sistemas de equações diferenciais.

   Para usar as funções nesse pacote você deve primeiramente torná-lo
disponível para uso com 'load("dynamics")'.

   Modificações introduzidas no Maxima 5.12

   Iniciando no Maxima 5.12, o pacote dynamics agora utiliza a função
'plot2d' para monar os gráficos.  Os comandos que produzem gráficos (com
exceção de 'julia' e de 'mandelbrot') agora aceitam qualquer opção de
'plot2d', incluindo a opção que modificam o montante das várias
interfaces gráficas, usando diferentes estilos de montagem de gráfico e
cores, e representando um ou ambos os eixos em uma escala logarítmica.
As antigas opções <domain>, <pointsize>, <xcenter>, <xradius>,
<ycenter>, <yradius>, <xaxislabel> e <yaxislabel> não são aceitas nessa
nova versão.

   Todos os programas irão agora aceitar quaisquer nomes de variáveis, e
não apenas <x> e <y> como nas antigas versões.  Dois parâmetros
requeridos tiveram modificações em dois desses programas: 'evolution2d'
agora requer uma lista nomeando explicitamente as duas variáveis
independentes, e o intervalo horizontal para 'orbits' não mais requer um
tamanho de passo; o intervalo pode somente espcificar o nome da
variável, e o menor e o maior valores; o número de passos pode agora ser
modificado com a opção <nticks>.


File: maxima.info,  Node: Funções e Variáveis Definidas para dynamics,  Prev: Introdução a dynamics,  Up: dynamics

49.2 Funções e Variáveis Definidas para dynamics
================================================

 -- Função: chaosgame ('[['<x1>, <y1>']'...'['<xm>, <ym>']]', '['<x0>,
          <y0>']', <b>, <n>, ...opções...);

     Implementa o então chamado jogo do caos: o ponto inicial (<x0>,
     <y0>) é colocado no gráfico e então um dos <m> pontos '['<x1>,
     <y1>']'...'['<xm>, <ym>']' será selecionado de forma aleatória.  O
     próximo ponto colocado no gráfico será sobre o segmento que vai do
     ponto anteriormente colocado no gráfico ao ponto escolhido
     aleatóriamente, à distância do ponto aleatório que será <b> vezes o
     comprimento daquele segmento.  o procedimento é repetido <n> vezes.

 -- Função: evolution (<F>, <y0>, <n>, ..., opções, ...);

     Desenha <n+1> pontos em gráfico bidimensional, onde as coordenadas
     horizontais dos pontos são os inteiros 0, 1, 2, ..., <n>, e as
     coordenadas verticais são os valores correspondentes <y(n)> da
     seqüência definida pela relação de recorrência
                  y(n+1) = F(y(n))

     com valor inicial <y(0)> igual a <y0>.  <F> deve ser uma expressão
     que depende somente de uma variável (no exemplo, essa variável
     dependente de <y>, mas qualquer outra variável pode ser usada em
     lugar de <y>), <y0> deve ser um número real e <n> deve ser um
     inteiro positivo.

 -- Função: evolution2d ('['<F>, <G>']', '['<u>, <v>']', '['<u0>,
          <y0>']', <n>, ..., opções, ...);

     Mostra, em um gráfico bidimensional, os primeiros <n+1> pontos na
     seqüência de pontos definida por meio do sistema dinâmico discreto
     bidimensional com relações de recorrência
                  u(n+1) = F(u(n), v(n))    v(n+1) = G(u(n), v(n))

     Com valores iniciais <u0> e <v0>.  <F> e <G> devem ser duas
     expressões que dependem somente de duas variáveis <u> e <v>, que
     devem ser nomeadas explicitamente em uma lista.

 -- Função: ifs ('['<r1>, ..., <rm>']', '['<A1>, ..., <Am>']', '[['<x1>,
          <y1>']', ..., '['<xm>, <ym>']]', '['<x0>, <y0>']', <n>, ...,
          opções, ...);

     Implemanta o método de Sistemas de Funções iteradas.  Esse método é
     similar ao método descrito na função 'chaosgame', mas em lugar de
     encolher o segmento do ponto corrente ao ponto escolhido
     aleatóriamente, as duas componentes daquele segmento irão ser
     multiplicadas pela matrix 2 por 2 <Ai> que corresponde ao ponto
     escolhido aleatóriamente.

     A escolha aleatória de um dos <m> pontos de atração pode ser feita
     com uma distribuição de probabilidade não uniforme definida por
     meio dos pesos <r1>,...,<rm>.  Esses pesos são fornecidos de forma
     cumulativa; por exemplo se existem 3 pontos com probabilidades 0.2,
     0.5 e 0.3, os pesos <r1>, <r2> e <r3> podem ser 2, 7 e 10.

 -- Função: rk (EDO, var, inicio, domain)
 -- Função: rk ([EDO1,...,EDOm], [v1,...,vm], [inic1,...,inicm], domain)

     A primeira forma resolve numericamente uma equação diferencial de
     primeira ordem, e a segunda formaresolve um sistema de m dessas
     equações, usando o método de Runge-Kutta de quarta ordem.  'var'
     representa a variável dependente.  EDO deve ser uma expressão que
     dependa somente da variável independente e da variável dependente e
     defina a derivada da variável dependente com relação à variável
     independente.

     A variável independente é especificada com 'domain', que deve ser
     uma lista dde quatro elementos como, por exemplo:
          [t, 0, 10, 0.1]
     O primeiro elemento da lista identifica a variável independente, o
     segundo e o terceiro elementos são os valores inicial e final para
     para aquela variável, e o último elemento escolhe o incremento que
     pode ser usado dentro daquele intervalo.

     Se <m> equações estão sendo resolvidas, podem existir <m> variáveis
     dependentes <v1>, <v2>, ..., <vm>.  Os valores iniciais para
     aquelas variáveis serão <inic1>, <inic2>, ..., <inicm>.  Ainda pode
     ser apenas uma variável independente definida por 'domain', como no
     caso anterior.  <EDO1>, ..., <EDOm> são as expressões que definem
     as derivadas de cada variável dependente em termos da variável
     independente.  As variáveis que podem aparecer naquelas expressões
     são a variável independente e quaisquer outras variáveis
     dependentes.  É importante fornecer as derivadas <EDO1>, ...,
     <EDOm> na lista exatamente na mesma ordem usada para variáveis
     dependentes; por exemplo, o terceiro elemento na lista irá ser
     interpretado com a derivada da terceira variável dependente.

     O programa tentará integrar as equações a partir do valor inicial
     da variável independente até seu último valor, usando incrementos
     constantes.  Se em algum passo uma das variáveis dependentes recebe
     um valor absoluto muito grande, a integração será interrompida
     naquele ponto.  O resultado será uma lista com tamtos elementos
     quantos forem o número de iterações feitas.  Cada elemento na lista
     de resultado é em si mesmo outra lista comh <m>+1 elementos: o
     valor da variável independente, seguido pelos valores das variáveis
     dependentes correspondentes àquele ponto.

 -- Função: staircase (<F>, <y0>, <n>, ...opções...);

     Desenha um diagrama em escada para a seqüência definida pela
     relação de recorrência
                  y(n+1) = F(y(n))

     A interpretação e os valores permitidos dos parâmetros de entrada
     são os mesmos que para a função 'evolution'.  Um diagrama em escada
     consiste de um gráfico da função <F(y)>, juntamente com a linha
     <G(y)> '=' <y>.  Um segmento vertical é desenhado a partir das
     point (<y0>, <y0>) on that line until the point where it
     intersecções com a função <F>.  A partir daquele ponto um segmento
     horizontal é desenhado até encontrar o ponto (<y1>, <y1>) sobre a
     linha, e o procedimento é repetido <n> vezes até que o ponto (<yn>,
     <yn>) é encontrado.

   opções

   Cada opção é uma lista de dois ou mais itens.  O primeiro item é o
nome da opção, e os restantes compreendem os argumentos para a opção.

   As opções aceitas pelas funções 'evolution', 'evolution2d',
'staircase', 'orbits', 'ifs' e 'chaosgame' são as mesmas opções para
'plot2d'.  Adicionalmente para aquelas opções, 'orbits' aceita a opção
extra <pixels> que escolhe o número máximo de pontos diferentes que irão
ser representados na direção vertical.

   Exemplos

   Representação gráfica e diagrama em escada para a seqüência: 2,
cos(2), cos(cos(2)),...

     (%i1) load("dynamics")$

     (%i2) evolution(cos(y), 2, 11);

     (%i3) staircase(cos(y), 1, 11, [y, 0, 1.2]);

   Se seu sistema for lento, você deverá reduzir o número de iterações
nos seguintes exemplos.  E se os pontos parecerem muito pequenos no seu
monitor, você pode querer tentar um estilo diferente, tal como
'['<style>,'['<points>,0.8']]'.

   Diagrama de órbitas para o mapa quadrático, com um parâmetro <a>.
             x(n+1) = a + x(n)^2

     (%i4) orbits(x^2+a, 0, 50, 200, [a, -2, 0.25], [style, dots]);

   Para ampliar a região em torno da bifurcação menor perto de x '='
-1.25 use:
     (%i5) orbits(x+y^2, 0, 100, 400, [a,-1,-1.53], [x,-1.6,-0.8],
                  [nticks, 400], [style,dots]);

   Evolução de um sistemma bidimensional que leva a um fractal:

     (%i6) f: 0.6*x*(1+2*x)+0.8*y*(x-1)-y^2-0.9$

     (%i7) g: 0.1*x*(1-6*x+4*y)+0.1*y*(1+9*y)-0.4$

     (%i8) evolution2d([f,g], [x,y], [-0.5,0], 50000, [style,dots]);

   E uma ampliação de uma pequena regial naquele fractal:

     (%i9) evolution2d([f,g], [x,y], [-0.5,0], 300000, [x,-0.8,-0.6],
                       [y,-0.4,-0.2], [style, dots]);

   Um gráfico do triângulo de Sierpinsky, obtido com o jogo do caos:

     (%i9) chaosgame([[0, 0], [1, 0], [0.5, sqrt(3)/2]], [0.1, 0.1], 1/2,
                      30000, [style, dots]);

   A samambaia de Barnsley, obtida com um Sistema de Funções Iteradas:

     (%i10) a1: matrix([0.85,0.04],[-0.04,0.85])$

     (%i11) a2: matrix([0.2,-0.26],[0.23,0.22])$

     (%i12) a3: matrix([-0.15,0.28],[0.26,0.24])$

     (%i13) a4: matrix([0,0],[0,0.16])$

     (%i14) p1: [0,1.6]$

     (%i15) p2: [0,1.6]$

     (%i16) p3: [0,0.44]$

     (%i17) p4: [0,0]$

     (%i18) w: [85,92,99,100]$

     (%i19) ifs(w, [a1,a2,a3,a4], [p1,p2,p3,p4], [5,0], 50000, [style,dots]);

   Para resolver numericamente a equação diferencial

               dx/dt = t - x^2

   Com valor inicial x(t=0) = 1, no intervalo de 't' de 0 a 8 e com
incrementos de 0.1 para 't', use:

     (%i20) results: rk(t-x^2,x,1,[t,0,8,0.1])$

   os resultados serão salvos na lista de resultados.

   Para resolver numericamente o sistema:

             dx/dt = 4-x^2-4*y^2     dy/dt = y^2-x^2+1

   para 't' entre 0 e 4, e com valores de -1.25 e 0.75 para x e y em
t=0:

     (%i21) sol: rk([4-x^2-4*y^2,y^2-x^2+1],[x,y],[-1.25,0.75],[t,0,4,0.02])$


File: maxima.info,  Node: eval_string,  Next: f90,  Prev: dynamics,  Up: Top

50 eval_string
**************

* Menu:

* Funções e Variáveis Definidas para eval_string::


File: maxima.info,  Node: Funções e Variáveis Definidas para eval_string,  Prev: eval_string,  Up: eval_string

50.1 Funções e Variáveis Definidas para eval_string
===================================================

 -- Função: eval_string (<str>)
     Entrega a seqüência de caracteres do Maxima <str> como uma
     expressão do Maxima e a avalia.  <str> é uma seqüência de
     caracteres do Maxima.  Essa seqüência pode ou não ter um marcador
     de final (sinal de dólar '$' ou ponto e vírgula ';').  Somente a
     primeira expressão é entregue e avaliada, se ouver mais de uma.

     Reclama se <str> não for uma seqüência de caracteres do Maxima.

     Exemplos:
          (%i1) eval_string ("foo: 42; bar: foo^2 + baz");
          (%o1)                       42
          (%i2) eval_string ("(foo: 42, bar: foo^2 + baz)");
          (%o2)                   baz + 1764

     Veja também 'parse_string'.

 -- Função: parse_string (<str>)
     Entrega a seqüência de caracteres do Maxima <str> como uma
     expressão do Maxima (sem fazer nenhuma avaliação dessa expressão).
     <str> é uma seqüência de caracteres do Maxima.  Essa seqüência pode
     ou não ter um marcador de final (sinal de dólar '$' ou ponto e
     vírgula ';').  Somente a primeira expressão é entregue e avaliada,
     se ouver mais de uma.

     Reclama se <str> não for uma seqüência de caracteres do Maxima.

     Exemplos:
          (%i1) parse_string ("foo: 42; bar: foo^2 + baz");
          (%o1)                    foo : 42
          (%i2) parse_string ("(foo: 42, bar: foo^2 + baz)");
                                              2
          (%o2)          (foo : 42, bar : foo  + baz)

     Veja também a função 'eval_string'.


File: maxima.info,  Node: f90,  Next: ggf,  Prev: eval_string,  Up: Top

51 f90
******

* Menu:

* Funções e Variáveis Definidas para f90::


File: maxima.info,  Node: Funções e Variáveis Definidas para f90,  Prev: f90,  Up: f90

51.1 Funções e Variáveis Definidas para f90
===========================================

 -- Função: f90 (<expr>)
     O comando f90 é uma atualização para o comando 'fortran' original
     do maxima.  A diferença primária é o caminho através do qual linhas
     longas são quebradas.

     No exemplo seguinte, observe como o comando 'fortran' para linhas
     dentro de símbolos.  O comando 'f90' jamais para linha dentro de um
     símbolo.

          (%i1) load("f90")$

          (%i2) expr:expand((xxx+yyy+7)^4);
                   4            3         3        2    2
          (%o2) yyy  + 4 xxx yyy  + 28 yyy  + 6 xxx  yyy
                       2          2        3             2
           + 84 xxx yyy  + 294 yyy  + 4 xxx  yyy + 84 xxx  yyy
                                         4         3          2
           + 588 xxx yyy + 1372 yyy + xxx  + 28 xxx  + 294 xxx
           + 1372 xxx + 2401
          (%i3) fortran(expr);
                yyy**4+4*xxx*yyy**3+28*yyy**3+6*xxx**2*yyy**2+84*xxx*yyy**2+294*yy
               1   y**2+4*xxx**3*yyy+84*xxx**2*yyy+588*xxx*yyy+1372*yyy+xxx**4+28*
               2   xxx**3+294*xxx**2+1372*xxx+2401
          (%o3)                       done
          (%i4) f90(expr);
          yyy**4+4*xxx*yyy**3+28*yyy**3+6*xxx**2*yyy**2+84*xxx*yyy**2+294* &
               yyy**2+4*xxx**3*yyy+84*xxx**2*yyy+588*xxx*yyy+1372*yyy+xxx** &
               4+28*xxx**3+294*xxx**2+1372*xxx+2401
          (%o4)                       done

     A implementação 'f90' termina como um rápido reparo em 'fortran'.
     Não é necessáriamente um bom exemplo sobre o qual se deva basear
     outros tradutores do Maxima para outras linguagens de programação.

     Para usar essa função escreva primeiro 'load("f90")'.


File: maxima.info,  Node: ggf,  Next: grobner,  Prev: f90,  Up: Top

52 ggf
******

* Menu:

* Funções e Variáveis Definidas para ggf::


File: maxima.info,  Node: Funções e Variáveis Definidas para ggf,  Prev: ggf,  Up: ggf

52.1 Funções e Variáveis Definidas para ggf
===========================================

 -- Variável de Opção: GGFINFINITY
     Valor padrão: 3

     Essa é uma variável de opção para a função 'ggf'.

     Quando calculando a fração contínua da função geradora, um
     quociente parcial tendo um grau (estritamente) maior que
     <GGFINFINITY> será descartado e o convergente atual será
     considerado como o valor exato da função geradora; na grande mioria
     dos casos o grau de todos os quocientes parciais será ou 0 ou 1; se
     você usar um valor muito grande, então você poderá fornecer termos
     suficientes com o objetivo de fazer o cálculo preciso o bastante.

     Veja também 'ggf'.

 -- Variável de opção: GGFCFMAX
     Valor padrão: 3

     Essa é uma variável de opção para a função 'ggf'.

     Quando calculando a fração contínua da função geradora, se nenhum
     bom resultado for encontrado (veja o sinalizador <GGFINFINITY>)
     após se ter calculado uma quantidade de <GGFCFMAX> quocientes
     parciais, a função geradora será considerada como não sendo uma
     fração de dois polinômios e a função irá terminar.  Coloque
     livemente um valor muito grande para funções geradoras mais
     complicadas.

     Veja também 'ggf'.

 -- Função: ggf (<l>)
     Calcula a função geradora (se for uma fração de dois polinômios) de
     uma seqüência, sendo dados seus primeiros termos.  <l> é uma lista
     de números.

     A solução é retornada como uma fração de dois polinômios.  Se
     nenhuma solução tiver sido encontrada, é retornado 'done'.

     Essa função é controlada attravés das variáveis globais
     <GGFINFINITY> e <GGFCFMAX>.  Veja também <GGFINFINITY> e
     <GGFCFMAX>.

     Para usar essa função primeiro escreva 'load("ggf")'.


File: maxima.info,  Node: grobner,  Next: impdiff,  Prev: ggf,  Up: Top

53 grobner
**********

/grobner.texi/1.3/Sat Jun 2 00:13:21 2007//
* Menu:

* Introdução a grobner::
* Funções e Variáveis Definidas para grobner::


File: maxima.info,  Node: Introdução a grobner,  Next: Funções e Variáveis Definidas para grobner,  Prev: Top,  Up: Top

53.1 Introdução a grobner
=========================

'grobner' é um pacote para trabalhos com bases de Groebner no Maxima.

Um tutorial sobre _Bases de Groebner_ pode ser encontrado em

<http://www.geocities.com/CapeCanaveral/Hall/3131/>

Para usar as seguintes funções você deve primeiramente tornar o pacote
'grobner.lisp' disponível para uso:

     load(grobner);

Uma demonstração de uso pode ser iniciada com
     demo("grobner.demo");

ou com
     batch("grobner.demo")

Alguns dos cálculos no arquivo de demonstração irão tomar um pouco de
tempo portanto a saída 'grobner-demo.output' do arquivo de demonstração
pode ser encontrada no mesmo diretório que o arquivo de demonstração.

53.1.1 Notas sobre o pacote grobner
-----------------------------------

O pacote foi escrito por

Marek Rychlik

<http://alamos.math.arizona.edu>

e foi liberado em 24/05/2002 nos termos da Licença Pública Geral
(GPL/GNU/FSF) (veja o arquivo 'grobner.lisp'.  Essa documentação foi
extraída dos arquivos
'README', 'grobner.lisp', 'grobner.demo', 'grobner-demo.output'

por Günter Nowak.  Sugestões de melhorias da documentação podem ser
discutidas em _maxima_-mailing-list <maxima@math.utexas.edu>.  O código
está um pouco desatualizado atualmente.  Implementações modernas
utilizam o algorítmo rápido _F4_ descrito em
A new efficient algorithm for computing Gröbner bases (F4)
Jean-Charles Faugère
LIP6/CNRS Université Paris VI
January 20, 1999

53.1.2 Implementações de ordem monomial admissível em grobner
-------------------------------------------------------------

   * 'lex'

     puramente lexicográfica, ordenação padrão para comparações
     monomiais
   * 'grlex'

     ordenação total de grau, quando houver empate é quebrada pela ordem
     lexicográfica

   * 'grevlex'

     grau total, quando houver empate é quebrada pela ordem
     lexicográfica reversa

   * 'invlex'

     ordenação lexicográfica reversa


File: maxima.info,  Node: Funções e Variáveis Definidas para grobner,  Prev: Introdução a grobner,  Up: Top

53.2 Funções e Variáveis Definidas para grobner
===============================================

53.2.1 Comutadores globais para grobner
---------------------------------------

 -- Variável de opção: poly_monomial_order
     Valor padrão: 'lex'

     Esse comutador globalcontrola qual a ordenação monomial é usada em
     polinomio e em cálculos com Bases de Groebner.  Se não for
     escolhidat, 'lex' será usada.

 -- Variável de opção: poly_coefficient_ring
     Valor padrão: 'expression_ring'

     Esse comutador indica o anel de coeficiente dos polinômios que irá
     ser usado em cálculos de grobner.  Se não for escolhido, o anel de
     expressão geral do _maxima's_ irá ser usado.  Essa variável pode
     ser escolhida para 'ring_of_integers' se for desejado.

 -- Variável de opção: poly_primary_elimination_order
     Valor padrão: 'false'

     Nome da ordem padrão de eliminação de variáveis em funções de
     eliminação.  Se não for escolhida, 'lex' irá ser usada.

 -- Variável de opção: poly_secondary_elimination_order
     Valor padrão: 'false'

     Nome da ordem padrão para manter variáveis em funções de
     eliminação.  Se não for escolhida, 'lex' irá ser usada.

 -- Variável de opção: poly_elimination_order
     Valor padrão: 'false'

     Nome da ordem padrão de funções de eliminação.  Se escolhida, irá
     sobrescrever as escolhas nas variáveis
     'poly_primary_elimination_order' e
     'poly_secondary_elimination_order'.  O usuário deve garantir que
     essa é uma ordem de eliminação verdadeira válida para o número de
     variáveis eliminadas.

 -- Variável de opção: poly_return_term_list
     Valor padrão: 'false'

     Se escolhida para 'true', todas as funções no pacote 'grobner' irão
     retornar cada polinômio como uma lista de termos na ordem monomial
     corrente em lugar de retornar uma expressão geral do _maxima_.

 -- Variável de opção: poly_grobner_debug
     Valor padrão: 'false'

     Se escolhida para 'true', produz saída de depuração e rastros.

 -- Variável de opção: poly_grobner_algorithm
     Valor padrão: 'buchberger'

     Valores possíveis:
        * 'buchberger'
        * 'parallel_buchberger'
        * 'gebauer_moeller'

     O nome do algorítmo usado para encontrar as bases de Groebner.

 -- Variável de opção: poly_top_reduction_only
     Valor padrão: 'false'

     Se não for 'false', usa redução de topo somente se for possível.
     Redução de topo significa que o algorítmo de divisão para após a
     primeira redução.

53.2.2 Operadores simples em grobner
------------------------------------

'poly_add', 'poly_subtract', 'poly_multiply' e 'poly_expt' são as
operações aritméticas sobre polinômios.  Elas são executadas usando
representação interna, mas os resultados são convertidos de volta à
forma geral do _maxima_.

 -- Função: poly_add (<poli1>, <poli2>, <varlist>)
     Adiciona dois polinômios <poli1> e <poli2>.

          (%i1) poly_add(z+x^2*y,x-z,[x,y,z]);
                                              2
          (%o1)                              x  y + x

 -- Função: poly_subtract (<poli1>, <poli2>, <varlist>)
     Subtrai o polinômio <poli2> do polinômio <poli1>.

          (%i1) poly_subtract(z+x^2*y,x-z,[x,y,z]);
                                                2
          (%o1)                          2 z + x  y - x

 -- Função: poly_multiply (<poli1>, <poli2>, <varlist>)
     Retorna o produto dos polinômios <poli1> e <poli2>.

          (%i2) poly_multiply(z+x^2*y,x-z,[x,y,z])-(z+x^2*y)*(x-z),expand;
          (%o1)                                  0

 -- Função: poly_s_polynomial (<poli1>, <poli2>, <varlist>)
     Retorna o _polinômio syzygy_ (_S-polinomial_) de dois polinômios
     <poli1> e <poli2>.

 -- Função: poly_primitive_part (<poli1>, <varlist>)
     Retorna o polinômio <poli> dividido pelo MDC entre seus
     coeficientes.

          (%i1) poly_primitive_part(35*y+21*x,[x,y]);
          (%o1)                              5 y + 3 x

 -- Função: poly_normalize (<poli>, <varlist>)
     Retorna o polinômio <poli> dividido pelo coeficiente lider.
     'poly_normalize' assume que a divisão é possível, o que nem sempre
     ocorre em anéis que não são corpos (fields).

53.2.3 Outras funções em grobner
--------------------------------

 -- Função: poly_expand (<poli>, <varlist>)
     Essa função transforma polinômios para a forma interna e da forma
     interna para a forma geral.  'poly_expand' é equivalente a
     'expand(poly)' se <poli> passa corretamente para um polinômio.  Se
     a representação não for compatível com um polinômio nas variáveis
     <varlist>, o resultado é um erro.  Esse resultado em erro pode ser
     usado para testar se uma expressão transforma-se corretamente para
     a representação interna.  Os seguintes exemplos ilustra que
     variáveis de funções indexadas e transcendentes são permitidas.

          (%i1) poly_expand((x-y)*(y+x),[x,y]);
                                               2    2
          (%o1)                               x  - y
          (%i2) poly_expand((y+x)^2,[x,y]);
                                          2            2
          (%o2)                          y  + 2 x y + x
          (%i3) poly_expand((y+x)^5,[x,y]);
                            5      4         2  3       3  2      4      5
          (%o3)            y  + 5 x y  + 10 x  y  + 10 x  y  + 5 x  y + x
          (%i4) poly_expand(-1-x*exp(y)+x^2/sqrt(y),[x]);
                                                    2
                                            y      x
          (%o4)                       - x %e  + ------- - 1
                                                 sqrt(y)

          (%i5) poly_expand(-1-sin(x)^2+sin(x),[sin(x)]);
                                          2
          (%o5)                      - sin (x) + sin(x) - 1

 -- Função: poly_expt (<poli>, <número>, <varlist>)
     eleva <poli> a um inteiro positivo <número>.  If <número> não for
     um inteiro positivo um erro irá ser mostrado.

          (%i1) poly_expt(x-y,3,[x,y])-(x-y)^3,expand;
          (%o1)                                  0

 -- Função: poly_content (<poli>. <varlist>)
     'poly_content' extrai o MDC entre seus coeficientes

          (%i1) poly_content(35*y+21*x,[x,y]);
          (%o1)                                  7

 -- Função: poly_pseudo_divide (<poli>, <polilist>, <varlist>)
     Realiza a divisão falsa do polinômio <poli> pela lista de n
     polinômios <polilist>.  Retorna multiplos valores.  O primeiro
     valor é uma lista de quocientes a.  O segundo valor é o resto r.  O
     terceiro argumento é um coeficiente escalar c, tal que c*poli pode
     ser dividido por<polilist> dentro do anel dos coeficientes, que não
     é necessáriamente corpo.  Finalmente, o quarto valor é um contador
     inteiro do número de reduções realizadas.  O objetos resultantes
     satisfazem à equação:

     c*poly=sum(a[i]*polylist[i],i=1...n)+r.

 -- Função: poly_exact_divide (<poli1>, <poli2>, <varlist>)
     Divide um polinômio <poli1> por outro polinômio <poli2>.  Assume
     que a divisão exata (sem resto) é possível.  Retorna o quociente.

 -- Função: poly_normal_form (<poli>, <polilist>, <varlist>)
     'poly_normal_form' encontra a forma normal de um polinômio <poli>
     com relação a um conjunto de polinômios <polilist>.

 -- Função: poly_buchberger_criterion (<polilist>, <varlist>)
     Returns 'true' if <polilist> is a Groebner basis with respect to
     the current term order, by using the Buchberger criterion: for
     every two polynomials h1 and h2 in <polilist> the S-polynomial
     S(h1,h2) reduces to 0 modulo <polilist>.

 -- Função: poly_buchberger (<polilist_fl> <varlist>)
     'poly_buchberger' realiza o algorítmo de Buchberger sobre uma lista
     de polinômios e retorna a base de Grobner resultante.

53.2.4 Pósprocessamento padão de bases de Groebner
--------------------------------------------------

O _k-ésimo ideal de eliminação_ I_k de uma Ideal I sobre K[
x[1],...,x[n] ] é o ideal intersecção(I, K[ x[k+1],...,x[n] ]).
O _ideal quociente_ I:J é o ideal {h|for all w em J: w*h em I}.
O ideal I:p^inf é o ideal {h| existe um n em N: p^n*h em I}.
O ideal I:J^inf é o ideal {h| existe um n em N \and a p em J: p^n*h em
I}.
O _ideal radical_ sqrt(I) é o ideal {h| existe um n em N : h^n em I }.

 -- Função: poly_reduction (<polilist>, <varlist>)
     'poly_reduction' reduz uma lista de polinômios <polilist>, de forma
     que cada poinômio é completametne reduzido com relação a outros
     polinômios.

 -- Função: poly_minimization (<polilist>, <varlist>)
     Retorna uma sublista da lista de polinômios <polilist> gerando o
     mesmo ideal de monômio que <polilist> mas minimo, i.e.  nenhum
     monômio líder de um polinômio na sublista divide o monômio líder de
     outro polinômio.

 -- Função: poly_normalize_list (<polilist>, <varlist>)
     'poly_normalize_list' aplica 'poly_normalize' a cada polinômio na
     lista.  Que significa que 'poly_normalize_list' divide todo
     polinômio em uma lista <polilist> por seu coeficiente líder.

 -- Função: poly_grobner (<polilist>, <varlist>)
     Retorna uma base de Groebner do ideal gerado pelos polinômios
     <polilist>.  Afetado pelos sinalizadores globais.

 -- Função: poly_reduced_grobner (<polilist>, <varlist>)
     Retorna uma base de Groebner reduzida do ideal gerado pelos
     polinômios <polilist>.  Afetado pelos sinalizadores globais.

 -- Função: poly_depends_p (<poli>, <var>, <varlist>)
     'poly_depends' testa se um polinômio depende da variável <var>.

 -- Função: poly_elimination_ideal (<polilist>, <num>, <varlist>)

     'poly_elimination_ideal' retorna a base de grobner do num-ésimo
     ideal de eliminação de um ideal especificado como uma lista de
     polinômios geradores (não necessáriamente base de Groebner)

 -- Função: poly_colon_ideal (<polilist1>, <polilist2>, <varlist>)

     Retorna a base reduzida de Groebner do ideal quociente

     I(polilist1):I(polilist2)

     onde polilist1 e polilist2 são duas listas de polinômios.

 -- Função: poly_ideal_intersection (<polilist1>, <polilist2>,
          <varlist>)

     'poly_ideal_intersection' retorna a intersecção entre dois ideais.

 -- Função: poly_lcm (<poli1>, <poli2>, <varlist>)
     Retorna o mínimo múltiplo comum entre <poli1> e <poli2>.

 -- Função: poly_gcd (<poli1>, <poli2>, <varlist>)
     Retorna máximo divisor comum de <poli1> e <poli2>.

 -- Função: poly_grobner_equal (<polilist1>, <polilist2>, <varlist>)
     'poly_grobner_equal' testa se duas bases de Groebner geram o mesmo
     ideal.  Retorna 'true' se as duas listas de polinômios <polilist1>
     e <polilist2>, assumidas serem bases de Groebner, geram o mesmo
     ideal, e 'false' de outra forma.  Isso é equivalente a verificar
     que todo polinômio da primeira base é reduzido a 0 módulo a segunda
     base e vice-versa.  Note que no exemplo abaixo a primeira lista não
     é uma base de Groebner, e dessa forma o resultado é 'false'.

          (%i1) poly_grobner_equal([y+x,x-y],[x,y],[x,y]);
          (%o1)                         false

 -- Função: poly_grobner_subsetp (<polilist1>, <polilist2>, <varlist>)

     'poly_grobner_subsetp' testa se um ideal gerado pela <polilist1>
     está contido em um ideal gerado pela <polilist2>.  Para esse teste
     sempre tenha sucesso, <polilist2> deve ser uma base de Groebner.

 -- Função: poly_grobner_member (<poli>, <polilist>, <varlist>)

     Retorna 'true' se um polinômio <poli> pertence ao ideal gerado pela
     lista polinomial <polilist>, que é assumida como sendouma base de
     Groebner.  Retorna 'false' de outra forma.

     'poly_grobner_member' testa se um polinômio pertence a um ideal
     gerado por uma lista de polinômios, que é assumida ser uma base de
     Groebner.  Equivale a 'normal_form' sendo 0.

 -- Função: poly_ideal_saturation1 (<polilist>, <poli>, <varlist>)
     Retorna abase de Groebner reduzida da saturação do ideal

     I(polylist):poly^inf

     Geometricamente, sobre um corpo algebricamente fechado, esse é um
     conjunto de polinmios no ideal gerado por <polilist> que não tende
     identicamente a zero sobre a variação de <poli>.

 -- Função: poly_ideal_saturation (<polilist1>, <polilist2>, <varlist>)
     Retorna a base de Groebner reduzida da saturação do ideal

     I(polylist1):I(polylist2)^inf

     Geometricamente, sobre um corpo algebricamente fechado, esse é um
     conjunto de polinmios no ideal gerado por <polilist1> que não tende
     identicamente a zero sobre a variação de <polilist2>.

 -- Função: poly_ideal_polysaturation1 (<polilist1>, <polilist2>,
          <varlist>)
     <polilist2> ist a list of n polynomials '[poly1,...,polyn]'.
     Retorna a base de Groebner reduzida do ideal

     I(polylist):poly1^inf:...:polyn^inf

     obtido por uma seqüência de sucessivas saturações nos polinômios da
     lista polinômial <polilist2> do ideal gerado pela lista polinomial
     <polilist1>.

 -- Função: poly_ideal_polysaturation (<polilist>, <polilistlist>,
          <varlist>)
     <polilistlist> is a list of n list of polynomials
     '[polylist1,...,polylistn]'.  Retorna a base reduzida de Groebner
     da saturação do ideal

     I(polylist):I(polylist_1)^inf:...:I(polylist_n)^inf

 -- Função: poly_saturation_extension (<poli>, <polilist>, <varlist1>,
          <varlist2>)

     'poly_saturation_extension' implementa o famoso artifício de
     Rabinowitz.


File: maxima.info,  Node: impdiff,  Next: implicit_plot,  Prev: grobner,  Up: Top

54 impdiff
**********

* Menu:

* Funções e Variáveis Definidas para impdiff::


File: maxima.info,  Node: Funções e Variáveis Definidas para impdiff,  Prev: impdiff,  Up: impdiff

54.1 Funções e Variáveis Definidas para impdiff
===============================================

 -- Função: implicit_derivative (<f>,<indvarlist>,<orderlist>,<depvar>)
     Essa subrotina calcula derivadas implícitas de funções de várias
     variáveis.  <f> é uma função do tipo array, os índices são o grau
     da derivada na ordem <indvarlist>; <indvarlist> é a lista de
     variáveis independentes; <orderlist> é a ordem desejada; e <depvar>
     é a variável dependente.

     Para usar essa função escreva primeiro 'load("impdiff")'.


File: maxima.info,  Node: implicit_plot,  Next: interpol,  Prev: impdiff,  Up: Top

55 implicit_plot
****************

* Menu:

* Funções e Variáveis Definidas para implicit_plot::


File: maxima.info,  Node: Funções e Variáveis Definidas para implicit_plot,  Prev: implicit_plot,  Up: implicit_plot

55.1 Funções e Variáveis Definidas para implicit_plot
=====================================================

 -- Função: implicit_plot (<expr>, <x_range>, <y_range>)
 -- Função: implicit_plot ([<expr_1>, ..., <expr_n>], <x_range>,
          <y_range>)

     Mostra na tela um gráfico de uma ou mais expressões na forma
     implícita.  <expr> é a expressão a ser montado o gráfico, <x_range>
     o intervalo do eixo do eixo horizontal e <y_range> o intervalo do
     eixo vertical.  'implicit_plot' somente trabalha com o driver do
     gnuplot.  'implicit_plot' respeita as escolhas globais para o
     driver do gnuplot escolhidas por meio da função <set_plot_option>.
     Opções podem tamb;em serem passadas para a função 'implicit_plot'
     como argumentos opcionais.

     'implicit_plot' trabalha por meio de mudanças de sinal de trilha
     sobre a área fornecida através de <x_range> e <y_range> e pode
     falhar em expressões complicadas.

     'load(implicit_plot)' torna essa função disponível para uso.

     Exemplo:
          (%i1) load(implicit_plot)$
          (%i2) implicit_plot (x^2 = y^3 - 3*y + 1, [x, -4, 4], [y, -4, 4])$


File: maxima.info,  Node: interpol,  Next: lbfgs,  Prev: implicit_plot,  Up: Top

56 interpol
***********

* Menu:

* Introdução a interpol::
* Funções e Variáveis Definidas para interpol::


File: maxima.info,  Node: Introdução a interpol,  Next: Funções e Variáveis Definidas para interpol,  Prev: interpol,  Up: interpol

56.1 Introdução a interpol
==========================

Pacote 'interpol' define os métodos Lagrangiano, linear e o de splines
cúbicos para interpolação polinomial.

   Comentários, correções e sugestões, por favor contacte-me em <'mario
AT edu DOT xunta DOT es'>.


File: maxima.info,  Node: Funções e Variáveis Definidas para interpol,  Prev: Introdução a interpol,  Up: interpol

56.2 Funções e Variáveis Definidas para interpol
================================================

 -- Função: lagrange (<pontos>)
 -- Função: lagrange (<pontos>, <opção>)
     Calcula a interpolação polinomial através do método Lagrangiano.  O
     argumento <pontos> deve ser um dos seguintes:

        * uma matriz de duas colunas, 'p:matrix([2,4],[5,6],[9,3])',
        * uma lista de pares, 'p: [[2,4],[5,6],[9,3]]',
        * uma lista de números, 'p: [4,6,3]', e nesse caso as abcissas
          irão ser atribuídas automaticamente aos valores 1, 2, 3, etc.

     Nos dois primeiros casos os pares são ordenados em relação à
     primeira coordenada antes de fazer os cálculos.

     Com o argumento <opção> é possível escolher o nome da variável
     independente, o qual é ''x' por padrão; para definir qualquer
     outra, z por exemplo, escreva 'varname='z'.

     Exemplos:

          (%i1) load("interpol")$
          (%i2) p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$
          (%i3) lagrange(p);
                           4        3         2
                       73 x    701 x    8957 x    5288 x   186
          (%o3)        ----- - ------ + ------- - ------ + ---
                        420     210       420      105      5
          (%i4) f(x):=''%;
                               4        3         2
                           73 x    701 x    8957 x    5288 x   186
          (%o4)    f(x) := ----- - ------ + ------- - ------ + ---
                            420     210       420      105      5
          (%i5) /* Evaluate the polynomial at some points */
                map(f,[2.3,5/7,%pi]);
                                       919062
          (%o5)  [- 1.567534999999992, ------,
                                       84035
                                   4          3           2
                             73 %pi    701 %pi    8957 %pi    5288 %pi   186
                             ------- - -------- + --------- - -------- + ---]
                               420       210         420        105       5
          (%i6) %,numer;
          (%o6) [- 1.567534999999992, 10.9366573451538, 2.89319655125692]
          (%i7) /* Plot the polynomial together with points */
                plot2d([f(x),[discrete,p]],[x,0,10],
                     [gnuplot_curve_styles,
                           ["with lines","with points pointsize 3"]])$
          (%i8) /* Change variable name */
                lagrange(p, varname=w);
                           4        3         2
                       73 w    701 w    8957 w    5288 w   186
          (%o8)        ----- - ------ + ------- - ------ + ---
                        420     210       420      105      5

 -- Função: charfun2 (<x>, <a>, <b>)
     Retorna 'true', i.  e., verdadeiro se o número <x> pertence ao
     intervalo [a, b), e 'false', i.  e., falsono caso contrário.

 -- Função: linearinterpol (<pontos>)
 -- Função: linearinterpol (<pontos>, <opção>)
     Calcula a interpolação polinomial através do método linear.  O
     argumento <pontos> deve ser um dos seguintes:

        * uma matriz de duas colunas, 'p:matrix([2,4],[5,6],[9,3])',
        * uma lista de pares, 'p: [[2,4],[5,6],[9,3]]',
        * uma lista de números, 'p: [4,6,3]', e nesse caso as abcissas
          irão ser atribuídas automaticamente aos valores 1, 2, 3, etc.

     Nos dois primeiros casos os pares são ordenados em relação à
     primeira coordenada antes de fazer os cálculos.

     Com o argumento <opção> é possível escolher o nome da variável
     independente, o qual é ''x' por padrão; para definir qualquer
     outra, z por exemplo, escreva 'varname='z'.

     Examples:
          (%i1) load("interpol")$
          (%i2) p: matrix([7,2],[8,3],[1,5],[3,2],[6,7])$
          (%i3) linearinterpol(p);
                  13   3 x
          (%o3)  (-- - ---) charfun2(x, minf, 3)
                  2     2
           + (x - 5) charfun2(x, 7, inf) + (37 - 5 x) charfun2(x, 6, 7)
              5 x
           + (--- - 3) charfun2(x, 3, 6)
               3

          (%i4) f(x):=''%;
                          13   3 x
          (%o4)  f(x) := (-- - ---) charfun2(x, minf, 3)
                          2     2
           + (x - 5) charfun2(x, 7, inf) + (37 - 5 x) charfun2(x, 6, 7)
              5 x
           + (--- - 3) charfun2(x, 3, 6)
               3
          (%i5)  /* Evaluate the polynomial at some points */
                 map(f,[7.3,25/7,%pi]);
                                      62  5 %pi
          (%o5)                 [2.3, --, ----- - 3]
                                      21    3
          (%i6) %,numer;
          (%o6)  [2.3, 2.952380952380953, 2.235987755982989]
          (%i7)  /* Plot the polynomial together with points */
                 plot2d(['(f(x)),[discrete,args(p)]],[x,-5,20],
                     [gnuplot_curve_styles,
                           ["with lines","with points pointsize 3"]])$
          (%i8)  /* Change variable name */
                 linearinterpol(p, varname='s);
                 13   3 s
          (%o8) (-- - ---) charfun2(s, minf, 3)
                 2     2
           + (s - 5) charfun2(s, 7, inf) + (37 - 5 s) charfun2(s, 6, 7)
              5 s
           + (--- - 3) charfun2(s, 3, 6)
               3

 -- Função: cspline (<pontos>)
 -- Função: cspline (<pontos>, <opção1>, <opção2>, ...)
     Calcula a interpolação polnomial pelo método de splines (
     polinômios de ordem k que interpolam os dados e têm k-1 derivadas
     contínuas em todo o intervalo ) cúbicos.  O argumento <pontos> deve
     ser um dos seguintes:

        * uma matriz de duas colunas, 'p:matrix([2,4],[5,6],[9,3])',
        * uma lista de pares, 'p: [[2,4],[5,6],[9,3]]',
        * uma lista de números, 'p: [4,6,3]', e nesse caso as abcissas
          irão ser atribuídas automaticamente aos valores 1, 2, 3, etc.

     Nos dois primeiros casos os pares são ordenados em relação à
     primeira coordenada antes de fazer os cálculos.

     Existem três opções para ajustar necessidades específicas:
        * ''d1', o padrão é ''unknown', é a primeira derivada em x_1; se
          essa primeira derivada for desconhecida, ''unknown', a segunda
          derivada em x_1 é igualada a 0 (o spline cúbico natural); se
          essa primeira derivada for igual a um número, a segunda
          derivada é calculada baseando-se nesse número.

        * ''dn', o padrão é ''unknown', é a primeira derivada em x_n; se
          essa primeira derivada for desconhecida, ''unknown', a segunda
          derivada em x_n é igualada a 0 (o spline cúbico natural); se
          essa primeira derivada for igual a um número, a segunda
          derivada é calculada baseando-se nesse número.

        * ''nome_var', o padrão é ''x', é o nome da variável
          independente.

     Exemplos:
          (%i1) load("interpol")$
          (%i2) p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$
          (%i3) /* Unknown first derivatives at the extremes
                   is equivalent to natural cubic splines */
                cspline(p);
                        3         2
                  1159 x    1159 x    6091 x   8283
          (%o3)  (------- - ------- - ------ + ----) charfun2(x, minf, 3)
                   3288      1096      3288    1096
                      3         2
                2587 x    5174 x    494117 x   108928
           + (- ------- + ------- - -------- + ------) charfun2(x, 7, inf)
                 1644       137       1644      137
                    3          2
              4715 x    15209 x    579277 x   199575
           + (------- - -------- + -------- - ------) charfun2(x, 6, 7)
               1644       274        1644      274
                      3         2
                3287 x    2223 x    48275 x   9609
           + (- ------- + ------- - ------- + ----) charfun2(x, 3, 6)
                 4932       274      1644     274

          (%i4) f(x):=''%$
          (%i5) /* Some evaluations */
                map(f,[2.3,5/7,%pi]), numer;
          (%o5) [1.991460766423356, 5.823200187269903, 2.227405312429507]
          (%i6) /* Plotting interpolating function */
                plot2d(['(f(x)),[discrete,p]],[x,0,10],
                    [gnuplot_curve_styles,
                         ["with lines","with points pointsize 3"]])$
          (%i7) /* New call, but giving values at the derivatives */
                cspline(p,d1=0,dn=0);
                        3          2
                  1949 x    11437 x    17027 x   1247
          (%o7)  (------- - -------- + ------- + ----) charfun2(x, minf, 3)
                   2256       2256      2256     752
                      3          2
                1547 x    35581 x    68068 x   173546
           + (- ------- + -------- - ------- + ------) charfun2(x, 7, inf)
                  564       564        141      141
                   3          2
              607 x    35147 x    55706 x   38420
           + (------ - -------- + ------- - -----) charfun2(x, 6, 7)
               188       564        141      47
                      3         2
                3895 x    1807 x    5146 x   2148
           + (- ------- + ------- - ------ + ----) charfun2(x, 3, 6)
                 5076       188      141      47
          (%i8) /* Defining new interpolating function */
                g(x):=''%$
          (%i9) /* Plotting both functions together */
                plot2d(['(f(x)),'(g(x)),[discrete,p]],[x,0,10],
                     [gnuplot_curve_styles,
                        ["with lines","with lines","with points pointsize 3"]])$


File: maxima.info,  Node: lbfgs,  Next: lindstedt,  Prev: interpol,  Up: Top

57 lbfgs
********

* Menu:

* Introdução a lbfgs::
* Funções e Variáveis Definidas para lbfgs::


File: maxima.info,  Node: Introdução a lbfgs,  Next: Funções e Variáveis Definidas para lbfgs,  Prev: Top,  Up: Top

57.1 Introdução a lbfgs
=======================

'lbfgs' é uma implementação do algorítmo[1] L-BFGS
(Broyden-Fletcher-Goldfarb-Shanno) para resolver problemas de
minimização não limitada através de um algorítmo de memória limitada
quasi-Newton (BFGS). Esse algorítmo é chamado de método de memória
limitada porque uma aproximação de baixo ranque da inverso da matriz
Hessiana é armazenado em lugar da inversa da matriz Hessiana completa.
O programa foi escrito origináriamente em Fortran [2] por Jorge Nocedal,
incorporando algumas funções originalmente escritas por Jorge J. Moré e
David J. Thuente, e traduzidas para Lisp automaticamente através do
programa 'f2cl'.  O pacote do Maxima 'lbfgs' compreende o código
traduzido e adicionalmente uma interface de função que gerencia alguns
detallhes.

   Referências:

   [1] D. Liu and J. Nocedal.  "On the limited memory BFGS method for
large scale optimization".  Mathematical Programming B 45:503-528 (1989)

   [2] http://netlib.org/opt/lbfgs_um.shar


File: maxima.info,  Node: Funções e Variáveis Definidas para lbfgs,  Prev: Introdução a lbfgs,  Up: Top

57.2 Funções e Variáveis Definidas para lbfgs
=============================================

 -- Função: lbfgs (<FOM>, <X>, <X0>, <epsilon>, <iprint>)

     Encontra uma solução aproximada da minimização não limitada de
     número de mérito <FOM> sobre a lista de variáveis <X>, começando a
     partir da estimativa inicial <X0>, tal que norm grad FOM < epsilon
     max(1, norm X).

     O algorítmo aplicado é um algorítmo de memória limitada[1]
     quasi-Newton (BFGS). Esse algorítmo é chamado de método de memória
     limitada porque uma aproximação de baixo ranque da inverso da
     matriz Hessiana é armazenado em lugar da inversa da matriz Hessiana
     completa.  Cada iteração do algorítmo é uma busca de linha, isto é,
     uma busca ao longo de um raio em torno da variáveis <X>, com a
     direção de busca calculada a partir da Hessian inversa aproximada.
     O FOM é sempre decrementado por meio de uma busca de linha
     realizada com sucesso.  Usualmente (mas não sempre) a norma do
     gradiente de FOM também é decrementada.

     <iprint> controla as messaens de progresso mostradas através de
     'lbfgs'.

     'iprint[1]'
          '<iprint>[1]' controla a freqüência das mensagens de
          progresso.
          'iprint[1] < 0'
               Nenhuma mensagem de progresso.
          'iprint[1] = 0'
               Messagens na primeira iteração e na última iteração.
          'iprint[1] > 0'
               Mostra uma mensagem a cada '<iprint>[1]' iterações.
     'iprint[2]'
          '<iprint>[2]' controla a quantidade de informações fornecidas
          pelas mensagens de progresso (verbosidade).
          'iprint[2] = 0'
               Mostra na tela o contador de iterações, o número de
               avaliações de <FOM>, o valor de <FOM>, a norma do
               gradiente de <FOM>, e o comprimento do salto.
          'iprint[2] = 1'
               O mesmo que '<iprint>[2] = 0', adicionando <X0> e o
               gradiente de <FOM> avaliado em <X0>.
          'iprint[2] = 2'
               O mesmo que '<iprint>[2] = 1', adicionando valores de <X>
               a cada iteração.
          'iprint[2] = 3'
               O mesmo que '<iprint>[2] = 2', adicionando o gradiente de
               <FOM> a cada iteração.

     As colunas mostradas por 'lbfgs' são as seguintes.

     'I'
          número de iterações.  Esse número é incrementado a cada busca
          de linha.
     'NFN'
          Número de avaliações do número de mérito.
     'FUNC'
          Valor do nero de mérito ao final da busca de linha mais
          recente.
     'GNORM'
          Norma do gradiente do número de mérito ao final da mais
          recente busca de linha.
     'STEPLENGTH'
          Um parâmetro interno do algorítmo de busca.

     Informação adicional com relação a detalhes do algorítmo podem ser
     encontradas nos comentários do código Fortran original em [2].

     Veja também 'lbfgs_nfeval_max' e 'lbfgs_ncorrections'.

     Referências:

     [1] D. Liu e J. Nocedal.  "On the limited memory BFGS method for
     large scale optimization".  Mathematical Programming B 45:503-528
     (1989)

     [2] http://netlib.org/opt/lbfgs_um.shar

     Exemplo:

     O mesmo FOM como calculada por FGCOMPUTE no programa sdrive.f no
     pacote LBFGS de Netlib.  Note que as variáveis em questão são
     variáveis com subscritos.  O FOM tem um mínimo exato igual a zero
     em u[k] = 1 for k = 1, ..., 8.

          (%i1) load (lbfgs);
          (%o1)   /usr/share/maxima/5.10.0cvs/share/lbfgs/lbfgs.mac
          (%i2) t1[j] := 1 - u[j];
          (%o2)                     t1  := 1 - u
                                      j         j
          (%i3) t2[j] := 10*(u[j + 1] - u[j]^2);
                                                    2
          (%o3)                t2  := 10 (u      - u )
                                 j         j + 1    j
          (%i4) n : 8;
          (%o4)                           8
          (%i5) FOM : sum (t1[2*j - 1]^2 + t2[2*j - 1]^2, j, 1, n/2);
                           2 2           2              2 2           2
          (%o5) 100 (u  - u )  + (1 - u )  + 100 (u  - u )  + (1 - u )
                      8    7           7           6    5           5
                               2 2           2              2 2           2
                  + 100 (u  - u )  + (1 - u )  + 100 (u  - u )  + (1 - u )
                          4    3           3           2    1           1
          (%i6) lbfgs (FOM, '[u[1], u[2], u[3], u[4], u[5], u[6], u[7], u[8]],
                 [-1.2, 1, -1.2, 1, -1.2, 1, -1.2, 1], 1e-3, [1, 0]);
          *************************************************
            N=    8   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  9.680000000000000D+01   GNORM=  4.657353755084532D+02
          *************************************************

             I  NFN     FUNC                    GNORM                   STEPLENGTH

             1    3     1.651479526340304D+01   4.324359291335977D+00   7.926153934390631D-04
             2    4     1.650209316638371D+01   3.575788161060007D+00   1.000000000000000D+00
             3    5     1.645461701312851D+01   6.230869903601577D+00   1.000000000000000D+00
             4    6     1.636867301275588D+01   1.177589920974980D+01   1.000000000000000D+00
             5    7     1.612153014409201D+01   2.292797147151288D+01   1.000000000000000D+00
             6    8     1.569118407390628D+01   3.687447158775571D+01   1.000000000000000D+00
             7    9     1.510361958398942D+01   4.501931728123680D+01   1.000000000000000D+00
             8   10     1.391077875774294D+01   4.526061463810632D+01   1.000000000000000D+00
             9   11     1.165625686278198D+01   2.748348965356917D+01   1.000000000000000D+00
            10   12     9.859422687859137D+00   2.111494974231644D+01   1.000000000000000D+00
            11   13     7.815442521732281D+00   6.110762325766556D+00   1.000000000000000D+00
            12   15     7.346380905773160D+00   2.165281166714631D+01   1.285316401779533D-01
            13   16     6.330460634066370D+00   1.401220851762050D+01   1.000000000000000D+00
            14   17     5.238763939851439D+00   1.702473787613255D+01   1.000000000000000D+00
            15   18     3.754016790406701D+00   7.981845727704576D+00   1.000000000000000D+00
            16   20     3.001238402309352D+00   3.925482944716691D+00   2.333129631296807D-01
            17   22     2.794390709718290D+00   8.243329982546473D+00   2.503577283782332D-01
            18   23     2.563783562918759D+00   1.035413426521790D+01   1.000000000000000D+00
            19   24     2.019429976377856D+00   1.065187312346769D+01   1.000000000000000D+00
            20   25     1.428003167670903D+00   2.475962450826961D+00   1.000000000000000D+00
            21   27     1.197874264861340D+00   8.441707983493810D+00   4.303451060808756D-01
            22   28     9.023848941942773D-01   1.113189216635162D+01   1.000000000000000D+00
            23   29     5.508226405863770D-01   2.380830600326308D+00   1.000000000000000D+00
            24   31     3.902893258815567D-01   5.625595816584421D+00   4.834988416524465D-01
            25   32     3.207542206990315D-01   1.149444645416472D+01   1.000000000000000D+00
            26   33     1.874468266362791D-01   3.632482152880997D+00   1.000000000000000D+00
            27   34     9.575763380706598D-02   4.816497446154354D+00   1.000000000000000D+00
            28   35     4.085145107543406D-02   2.087009350166495D+00   1.000000000000000D+00
            29   36     1.931106001379290D-02   3.886818608498966D+00   1.000000000000000D+00
            30   37     6.894000721499670D-03   3.198505796342214D+00   1.000000000000000D+00
            31   38     1.443296033051864D-03   1.590265471025043D+00   1.000000000000000D+00
            32   39     1.571766603154336D-04   3.098257063980634D-01   1.000000000000000D+00
            33   40     1.288011776581970D-05   1.207784183577257D-02   1.000000000000000D+00
            34   41     1.806140173752971D-06   4.587890233385193D-02   1.000000000000000D+00
            35   42     1.769004645459358D-07   1.790537375052208D-02   1.000000000000000D+00
            36   43     3.312164100763217D-10   6.782068426119681D-04   1.000000000000000D+00

           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o6) [u  = 1.000005339815974, u  = 1.000009942839805,
                  1                       2
          u  = 1.000005339815974, u  = 1.000009942839805,
           3                       4
          u  = 1.000005339815974, u  = 1.000009942839805,
           5                       6
          u  = 1.000005339815974, u  = 1.000009942839805]
           7                       8

 -- Variãvel: lbfgs_nfeval_max
     Valor padrão: 100

     'lbfgs_nfeval_max' é o número máximo de avaliações do número de
     mérito (FOM - "figure of merit" em inglês) em 'lbfgs'.  Quando
     'lbfgs_nfeval_max' for encontrada, 'lbfgs' retorna o resultado da
     última busca de linha realizada co sucesso.

 -- Variãvel: lbfgs_ncorrections
     Valor padrão: 25

     'lbfgs_ncorrections' é o número de correções aplicadas à matriz
     Hessiana inversa aproximada que é mantida por 'lbfgs'.


File: maxima.info,  Node: lindstedt,  Next: linearalgebra,  Prev: lbfgs,  Up: Top

58 lindstedt
************

* Menu:

* Funções e Variáveis Definidas para lindstedt::


File: maxima.info,  Node: Funções e Variáveis Definidas para lindstedt,  Prev: lindstedt,  Up: lindstedt

58.1 Funções e Variáveis Definidas para lindstedt
=================================================

 -- Função: Lindstedt (<eq>,<pvar>,<torder>,<ic>)
     Esse é um primeiro passo para um código de Lindstedt.  Esse código
     pode resolver problemas com condições iniciais fornecidas, às quais
     podem ser constantes arbitrárias, (não apenas <%k1> e <%k2>) onde
     as condições iniciais sobre as equações de perturbação são z[i]=0,
     z'[i]=0 para i>0.  <ic> é a lista de condições iniciais.

     Problemas ocorrem quando condições iniciais não forem dadas, como
     as constantes nas equações de perturbação são as mesmas que a
     solução da equação de ordem zero.  Também, problemas ocorrem quando
     as condições iniciais para as equações de perturbação não são
     z[i]=0, z'[i]=0 para i>0, tais como a equação de Van der Pol.

     Exemplo:
          (%i1) load("makeOrders")$

          (%i2) load("lindstedt")$

          (%i3) Lindstedt('diff(x,t,2)+x-(e*x^3)/6,e,2,[1,0]);
                    2
                   e  (cos(5 T) - 24 cos(3 T) + 23 cos(T))
          (%o3) [[[---------------------------------------
                                    36864
             e (cos(3 T) - cos(T))
           - --------------------- + cos(T)],
                      192
                    2
                 7 e    e
          T = (- ---- - -- + 1) t]]
                 3072   16

     Para usar essa função escreva primeiro 'load("makeOrders")' e
     'load("lindstedt")'.


File: maxima.info,  Node: linearalgebra,  Next: lsquares,  Prev: lindstedt,  Up: Top

59 linearalgebra
****************

* Menu:

* Introdução a linearalgebra::
* Funções e Variáveis Definidas para linearalgebra::


File: maxima.info,  Node: Introdução a linearalgebra,  Next: Funções e Variáveis Definidas para linearalgebra,  Prev: linearalgebra,  Up: linearalgebra

59.1 Introdução a linearalgebra
===============================

'linearalgebra' é uma coleção de funções para álgebra linear.

   Exemplo:

     (%i1) M : matrix ([1, 2], [1, 2]);
                                 [ 1  2 ]
     (%o1)                       [      ]
                                 [ 1  2 ]
     (%i2) nullspace (M);
                                    [  1  ]
                                    [     ]
     (%o2)                     span([   1 ])
                                    [ - - ]
                                    [   2 ]
     (%i3) columnspace (M);
                                     [ 1 ]
     (%o3)                      span([   ])
                                     [ 1 ]
     (%i4) ptriangularize (M - z*ident(2), z);
                              [ 1   2 - z   ]
     (%o4)                    [             ]
                              [           2 ]
                              [ 0  3 z - z  ]
     (%i5) M : matrix ([1, 2, 3], [4, 5, 6], [7, 8, 9]) - z*ident(3);
                          [ 1 - z    2      3   ]
                          [                     ]
     (%o5)                [   4    5 - z    6   ]
                          [                     ]
                          [   7      8    9 - z ]
     (%i6) MM : ptriangularize (M, z);
                   [ 4  5 - z            6            ]
                   [                                  ]
                   [                2                 ]
                   [     66        z    102 z   132   ]
                   [ 0   --      - -- + ----- + ---   ]
     (%o6)         [     49        7     49     49    ]
                   [                                  ]
                   [               3        2         ]
                   [           49 z    245 z    147 z ]
                   [ 0    0    ----- - ------ - ----- ]
                   [            264      88      44   ]
     (%i7) algebraic : true;
     (%o7)                         true
     (%i8) tellrat (MM [3, 3]);
                              3       2
     (%o8)                  [z  - 15 z  - 18 z]
     (%i9) MM : ratsimp (MM);
                    [ 4  5 - z           6           ]
                    [                                ]
                    [                2               ]
     (%o9)         [     66      7 z  - 102 z - 132 ]
                    [ 0   --    - ------------------ ]
                    [     49              49         ]
                    [                                ]
                    [ 0    0             0           ]
     (%i10) nullspace (MM);
                             [        1         ]
                             [                  ]
                             [   2              ]
                             [  z  - 14 z - 16  ]
                             [  --------------  ]
     (%o10)             span([        8         ])
                             [                  ]
                             [    2             ]
                             [   z  - 18 z - 12 ]
                             [ - -------------- ]
                             [         12       ]
     (%i11) M : matrix ([1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]);
                            [ 1   2   3   4  ]
                            [                ]
                            [ 5   6   7   8  ]
     (%o11)                 [                ]
                            [ 9   10  11  12 ]
                            [                ]
                            [ 13  14  15  16 ]
     (%i12) columnspace (M);
                                [ 1  ]  [ 2  ]
                                [    ]  [    ]
                                [ 5  ]  [ 6  ]
     (%o12)                span([    ], [    ])
                                [ 9  ]  [ 10 ]
                                [    ]  [    ]
                                [ 13 ]  [ 14 ]
     (%i13) apply ('orthogonal_complement, args (nullspace (transpose (M))));
                                [ 0 ]  [  1  ]
                                [   ]  [     ]
                                [ 1 ]  [  0  ]
     (%o13)                span([   ], [     ])
                                [ 2 ]  [ - 1 ]
                                [   ]  [     ]
                                [ 3 ]  [ - 2 ]


File: maxima.info,  Node: Funções e Variáveis Definidas para linearalgebra,  Prev: Introdução a linearalgebra,  Up: linearalgebra

59.2 Funções e Variáveis Definidas para linearalgebra
=====================================================

 -- Função: addmatrices (<f>, <M_1>, ..., <M_n>)

     Usando a função <f> como a função de adição, retorne a adição das
     matrizes <M_1>, ..., <M_n>.  A função <f> deve aceitar qualquer
     número de argumentos (uma função enária do Maxima).

     Exemplos:

          (%i1) m1 : matrix([1,2],[3,4])$
          (%i2) m2 : matrix([7,8],[9,10])$
          (%i3) addmatrices('max,m1,m2);
          (%o3) matrix([7,8],[9,10])
          (%i4) addmatrices('max,m1,m2,5*m1);
          (%o4) matrix([7,10],[15,20])

 -- Função: blockmatrixp (<M>)

     Retorna 'true' se e somente se <M> for uma matriz e toda entrada de
     <M> também for uma matriz.

 -- Função: columnop (<M>, <i>, <j>, <theta>)

     Se <M> for uma matriz, retorna a matriz que resulta de fazer a
     operação de coluna 'C_i <- C_i - <theta> * C_j'.  Se <M> não tiver
     uma linha <i> ou <j>, emite uma mensagem de erro.

 -- Função: columnswap (<M>, <i>, <j>)

     Se <M> for uma matriz, troca as colunas <i> e <j>.  Se <M> não
     tiver uma coluna <i> ou <j>, emite uma mensagem de erro.

 -- Função: columnspace (<M>)

     Se <M> for uma matriz, retorna 'span (v_1, ..., v_n)', onde o
     conjunto '{v_1, ..., v_n}' é uma base para o espaço coluna de <M>.
     A diferença entre o maior elemento e o menor elemento do conjunto
     vazio é '{0}'.  Dessa forma, quando o espaço coluna tiver somente
     um membro, retorna 'span ()'.

 -- Função: copy (<e>)

     Retorna uma cópia da expressão <e> do Maxima.  Embora <e> possa ser
     qualquer expressão do Maxima, A função 'copy' é mais útil quando
     <e> for ou uma lista ou uma matriz; considere:
          (%i1) m : [1,[2,3]]$
          (%i2) mm : m$
          (%i3) mm[2][1] : x$
          (%i4) m;
          (%o4)                      [1,[x,3]]
          (%i5) mm;
          (%o5)                      [1,[x,3]]
     Vamos tentar a mesma experiência, mas dessa vez tomemos <mm> como
     sendo uma cópia de <m>
          (%i6) m : [1,[2,3]]$
          (%i7) mm : copy(m)$
          (%i8) mm[2][1] : x$
          (%i9) m;
          (%o9)                     [1,[2,3]]
          (%i10) mm;
          (%o10)                    [1,[x,3]]
     Dessa vez, a atribuição a <mm> não muda o valor de <m>.

 -- Função: cholesky (<M>)
 -- Função: cholesky (<M>, <campo>)

     Retorna fatorização de Cholesky da matriz hermitiana (or
     autoadjunta) <M>.  O valor padrão para o segundo argumento é
     'generalring'.  Para uma descrição dos possíveis valores para
     <campo>, veja 'lu_factor'.

 -- Função: ctranspose (<M>)

     Retorna a matriz transposta conjugada complexa da matriz <M>.  A
     função 'ctranspose' usa 'matrix_element_transpose' para transpor
     cada elemento da matriz.

 -- Função: diag_matrix (<d_1>, <d_2>,...,<d_n>)

     Retorna uma matriz diagonal matriz com entradas de diagonal <d_1>,
     <d_2>,...,<d_n>.  Quando as entradas de diagonal forem matrizes, as
     entradas zero da matriz retornada serão todas matrizes de tamanho
     apropriado; por exemplo:
          (%i1) diag_matrix(diag_matrix(1,2),diag_matrix(3,4));

                                      [ [ 1  0 ]  [ 0  0 ] ]
                                      [ [      ]  [      ] ]
                                      [ [ 0  2 ]  [ 0  0 ] ]
          (%o1)                       [                    ]
                                      [ [ 0  0 ]  [ 3  0 ] ]
                                      [ [      ]  [      ] ]
                                      [ [ 0  0 ]  [ 0  4 ] ]
          (%i2) diag_matrix(p,q);

                                             [ p  0 ]
          (%o2)                              [      ]
                                             [ 0  q ]

 -- Função: dotproduct (<u>, <v>)

     Retorna o produto do ponto (produto escalar) dos vetores <u> e <v>.
     Isso é o mesmo que 'conjugate (transpose (<u>)) . <v>'.  Os
     argumentos <u> e <v> devem ser vetores coluna.

 -- Função: eigens_by_jacobi (<A>)
 -- Função: eigens_by_jacobi (<A>, <tipo_corpo>)

     Calculam os autovalores e autovetores de <A> pelo método de
     rotações de Jacobi.  <A> deve ser uma matriz simétrica (mas essa
     matriz simétrica precisa não ser nem definida positiva e nem
     semidefinida positiva).  <tipo_corpo> indica o corpo computacional,
     pode ser ou 'floatfield' ou 'bigfloatfield'.  Se <tipo_corpo> não
     for especificado, o padrão é 'floatfield'.

     Os elementos de <A> devem ser números ou expressões que avaliam
     para números via 'float' ou 'bfloat' (dependendo do valor de
     <tipo_corpo>).

     Exemplos:

          (%i1) S : matrix ([1/sqrt(2), 1/sqrt(2)], [- 1/sqrt(2), 1/sqrt(2)]);                     [     1         1    ]
                               [     1         1    ]
                               [  -------   ------- ]
                               [  sqrt(2)   sqrt(2) ]
          (%o1)                [                    ]
                               [      1        1    ]
                               [ - -------  ------- ]
                               [   sqrt(2)  sqrt(2) ]
          (%i2) L : matrix ([sqrt(3), 0], [0, sqrt(5)]);
                                [ sqrt(3)     0    ]
          (%o2)                 [                  ]
                                [    0     sqrt(5) ]
          (%i3) M : S . L . transpose (S);
                      [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
                      [ ------- + -------  ------- - ------- ]
                      [    2         2        2         2    ]
          (%o3)       [                                      ]
                      [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
                      [ ------- - -------  ------- + ------- ]
                      [    2         2        2         2    ]
          (%i4) eigens_by_jacobi (M);
          The largest percent change was 0.1454972243679
          The largest percent change was 0.0
          number of sweeps: 2
          number of rotations: 1
          (%o4) [[1.732050807568877, 2.23606797749979],
                                  [  0.70710678118655   0.70710678118655 ]
                                  [                                      ]]
                                  [ - 0.70710678118655  0.70710678118655 ]
          (%i5) float ([[sqrt(3), sqrt(5)], S]);
          (%o5) [[1.732050807568877, 2.23606797749979],
                                  [  0.70710678118655   0.70710678118655 ]
                                  [                                      ]]
                                  [ - 0.70710678118655  0.70710678118655 ]
          (%i6) eigens_by_jacobi (M, bigfloatfield);
          The largest percent change was 1.454972243679028b-1
          The largest percent change was 0.0b0
          number of sweeps: 2
          number of rotations: 1
          (%o6) [[1.732050807568877b0, 2.23606797749979b0],
                          [  7.071067811865475b-1   7.071067811865475b-1 ]
                          [                                              ]]
                          [ - 7.071067811865475b-1  7.071067811865475b-1 ]

 -- Função: get_lu_factors (<x>)

     Quando '<x> = lu_factor (<A>)', então 'get_lu_factors' retorna uma
     lista da forma '[P, L, U]', onde <P> é uma matriz de permutação,
     <L> é triangular baixa com a diagonal preenchida com a unidade, e
     <U> é triangular alta, e '<A> = <P> <L> <U>'.

 -- Função: hankel (<col>)
 -- Função: hankel (<col>, <lin>)

     Retorna uma matriz de Hankel <H>.  A primeira coluna de <H> é
     <col>; exceto para a primeira entrada, a última linha de <H> é
     <lin>.  O valor padrão para <lin> é o vetor nulo com o mesmo
     comprimento que <col>.

 -- Função: hessian (<f>,<vars>)

     Retorna a matriz hessiana de <f> com relação às variáveis na lista
     <vars>.  As entradas <i>,<j> da matriz hessiana são <diff(f
     vars[i],1,vars[j],1)>.

 -- Função: hilbert_matrix (<n>)

     Retorna the <n> by <n> matriz de Hilbert.  Quando <n> não for um
     inteiro positivo, emite uma mensagem de erro.

 -- Função: identfor (<M>)
 -- Função: identfor (<M>, <corpo>)

     Retorna uma matriz identidade que tem o mesmo tamanho que a matriz
     <M>.  As entradas de diagonal da matriz identidade são a identidade
     multiplicativa do corpo <corpo>; o padrão para <corpo> é
     <generalring>.

     O primeiro argumento <M> pode ser uma matriz quadrada ou um não
     matriz.  Quando <M> for uma matriz, cada entrada de <M> pode ser
     uma matriz quadrada - dessa forma <M> pode ser uma matriz de bloco
     do Maxima.  A matriz pode ser de bloco para qualquer (finita)
     quantidade de níveis.

     Veja também 'zerofor'

 -- Função: invert_by_lu (<M>, <(rng generalring)>)

     Inverte a matriz <M> através de fatorização linear alta (LU). A
     fatorização LU é concluída usando o anel <rng>.

 -- Função: kronecker_product (<A>, <B>)

     Retorna o produto de Kronecker das matrizes <A> e <B>.

 -- Função: listp (<e>, <p>)
 -- Função: listp (<e>)

     Recebendo um argumento opcional <p>, retorna 'true' se <e> for uma
     lista do Maxima e <p> avalia para 'true' para elemento da lista.
     Quando 'listp' não recebe o argumento opcional, retorna 'true' se
     <e> for uma lista do Maxima.  em todos os outros casos, retorna
     'false'.

 -- Função: locate_matrix_entry (<M>, <r_1>, <c_1>, <r_2>, <c_2>, <f>,
          <rel>)

     O primeiro argumento deve ser uma matriz; os argumentos que vão de
     <r_1> até <c_2> determinam um sub-matriz de <M> que consiste de
     linhas que vão de <r_1> até <r_2> e colunas que vão de <c_1> até
     <c_2>.

     Encontra uma entrada na sub-matriz <M> que satisfaz alguma
     propriedade.  Existem três casos:

     (1) '<rel> = 'bool' e <f> um predicado:

     Examina a sub-matriz da esquerda para a direita e de cima para
     baixo, e retorna o índice da primeria entrada que satisfizer o
     predicado <f>.  Se nenhuma entrada da matriz satisfizer o predicado
     <f>, retorna 'false'.

     (2) '<rel> = 'max' e <f> avaliar para um número real:

     Examina a sub-matriz procurando por uma entrada que maximize <f>.
     Retorna retorna o índice da entrada maximizada.

     (3) '<rel> = 'min' e <f> avaliar para um número real:

     Examina a sub-matriz procurando por uma entrada que minimize <f>.
     Retorna o índice de uma entrada minimizada.

 -- Função: lu_backsub (<M>, <b>)

     Quando '<M> = lu_factor (<A>, <corpo>)', então 'lu_backsub (<M>,
     <b>)' resolve o sistema linear '<A> <x> = <b>'.

 -- Função: lu_factor (<M>, <corpo>)

     Retorna uma lista da forma '[<LU>, <perm>, <corpo>]', ou da forma
     '[<LU>, <perm>, <cmp>, <baixo-cnd> <alto-cnd>]', onde

     (1) A matriz <LU> contéa fatorização de <M> na forma enpacotada.
     Forma empacotada significa três coisas: Primeiro, as linhas de <LU>
     são permutadas confirme a lista <perm>.  Se, por exemplo, <perm>
     for a lista list '[3,2,1]', a primeira linha atual da fatorização
     <LU> será a terceira linha da matriz <LU>.  Segundo, o fator
     triangular baixo de m é a parte triangular baixa de <LU> com as
     entradas de diagonal todas substituídas pela unidade.  Terceiro, o
     fator triangular alto de <M> é a parte triangular alta de <LU>.

     (2) Quando o corpo for ou 'floatfield' ou 'complexfield', os
     números <baixo-cnd> e <alto-cnd> serão associados baixo e alto para
     o número condicional de norma infinita de <M>.  Para todos os
     corpos (fields), o número condicional de norma infinita não pode
     ser estimado; para tais corpos, 'lu_factor' retorna uma lista com
     dois itens.  Ambos o baixo e o alto associado podem diferir de seus
     verdadeiros valores de fatores arbitráriamente grandes.  (Veja
     também 'mat_cond'.)

     O argumento <M> deve ser a matriz quadrada.

     O argumento opcional <cmp> deve ser um símbolo que determine um
     anel ou corpo.  Os corpos e anéis predefinidos são:

     (a) 'generalring' - o anel de expressões do Maxima, (b)
     'floatfield' - o corpo dos números em ponto flutuante do tipo de
     precisão dupla, (c) 'complexfield' - o corpo dos números complexos
     em ponto flutuante do tipo de precisão dupla, (d) 'crering' - o
     anel das expressões racionais canônicas (CRE) do Maxima, (e)
     'rationalfield' - o corpo dos números racionais, (f) 'runningerror'
     - rastro de todos os erros de arredondamento de números em ponto
     flutuante, (g) 'noncommutingring' - o anel de expressões do Maxima
     onde multiplicação for o operador ponto não comutativo.

     Quando o corpo for 'floatfield', 'complexfield', ou 'runningerror',
     o algorítmo usa pivotagem parcial; para todos os outros corpos,
     linhas são comutadas somente quando necessário para evitar um pivô
     nulo.

     A adição aritmética em ponto flutuante não é associativa, então o
     significado de 'corpo' difere da definição matemática.

     Um membro do corpo 'runningerror' é uma lista do Máxima de dois
     membros da forma '[x,n]',onde <x> é um número em onto flutuante e
     'n' é um inteiro.  A diferença relativa entre o valor de
     'verdadeiro' de 'x' e 'x' é aproximadamente associado pelo épsilon
     da máquina vezes 'n'.  O erro de execução associado arrasta alguns
     termos da ordem do quadrado do épsilon da máquina.

     Não existe interface de usuário definida um novo anel.  Um usuário
     que estiver familiazrizado com o Lisp Comum está apto para definir
     um novo corpo.  Para fazer isso, um usuário deve definir funções
     para as operações aritméticas e funções para conversão para a
     representação de corpo do Máxima e vice-versa.  Adicionalmente,
     para corpos ordenados (onde a pivotagem parcial será usada), um
     uduário deve definir funções para módulo e para comparar membros do
     corpo.  Após isso tudo que resta é definir uma estrutura de Lisp
     Comum 'mring'.  O arquivo 'mring' tem muitos exemplos.

     Para calcular a fatorização, a primeira tarefa é converter cada
     entrada de matriz para um elemento do corpo indicado.  Quando a
     cnversão não for possível, a fatorização encerra com uma mensagem
     de erro.  Elementos do corpo não precisam ser expressões do Maxima.
     Elementos do 'complexfield', por exemplo, são números complexos do
     Lisp Comum.  Dessa forma após calcular a fatorização, como entradas
     da matriz devem ser convertidas para expressões do Maxima.

     Veja também 'get_lu_factors'.

     Exemplos:
          (%i1) w[i,j] := random (1.0) + %i * random (1.0);
          (%o1)          w     := random(1.) + %i random(1.)
                          i, j
          (%i2) showtime : true$
          Evaluation took 0.00 seconds (0.00 elapsed)
          (%i3) M : genmatrix (w, 100, 100)$
          Evaluation took 7.40 seconds (8.23 elapsed)
          (%i4) lu_factor (M, complexfield)$
          Evaluation took 28.71 seconds (35.00 elapsed)
          (%i5) lu_factor (M, generalring)$
          Evaluation took 109.24 seconds (152.10 elapsed)
          (%i6) showtime : false$

          (%i7) M : matrix ([1 - z, 3], [3, 8 - z]);
                                  [ 1 - z    3   ]
          (%o7)                   [              ]
                                  [   3    8 - z ]
          (%i8) lu_factor (M, generalring);
                    [ 1 - z         3        ]
                    [                        ]
          (%o8)    [[   3            9       ], [1, 2], generalring]
                    [ -----  - z - ----- + 8 ]
                    [ 1 - z        1 - z     ]
          (%i9) get_lu_factors (%);
                            [   1    0 ]  [ 1 - z         3        ]
                  [ 1  0 ]  [          ]  [                        ]
          (%o9) [[      ], [   3      ], [                9       ]]
                  [ 0  1 ]  [ -----  1 ]  [   0    - z - ----- + 8 ]
                            [ 1 - z    ]  [              1 - z     ]
          (%i10) %[1] . %[2] . %[3];
                                  [ 1 - z    3   ]
          (%o10)                  [              ]
                                  [   3    8 - z ]

 -- Função: mat_cond (<M>, 1)
 -- Função: mat_cond (<M>, inf)

     Retorna o número condiciona da norma de ordem <p> da matriz <m>.
     Os valores permitidos para <p> são 1 e <inf>.  Essa função utiliza
     a fatorização linear alta para inverter a matriz <m>.  Dessa forma
     o tempode execução para 'mat_cond' é proporcional ao cubo do
     tamanho da matriz; 'lu_factor' determina as associaçãoes baixa e
     alta para o número de condição de norma infinita em tempo
     proporcional ao quadrado do tamanho da matriz.

 -- Função: mat_norm (<M>, 1)
 -- Função: mat_norm (<M>, inf)
 -- Função: mat_norm (<M>, frobenius)

     Retorna a matriz de norma <p> da matriz <M>.  Os valores permitidos
     para <p> são 1, 'inf', e 'frobenius' (a norma da matriz de
     Frobenius).  A matriz <M> pode ser uma matriz não de bloco.

 -- Função: matrixp (<e>, <p>)
 -- Função: matrixp (<e>)

     Fornecendo um argumento opcional <p>, 'matrixp' retorna 'true' se
     <e> for uma matriz e <p> avaliar para 'true' para todo elemento da
     matriz.  Quando a 'matrixp' não for fornecido umargumento opcional,
     retorna 'true' se 'e' for uma matriz.  em todos os outros casos,
     retorna 'false'.

     Veja também 'blockmatrixp'

 -- Função: matrix_size (<M>)

     Retorna uma lista com dois elementos que fornecem o número de
     linhas e colunas, respectivamente da matriz <M>.

 -- Função: mat_fullunblocker (<M>)

     Se <M> for uma matriz de bloco, expande todos os blocos da matriz
     em todos os níveis.  Se <M> for uma matriz, retorna <M>; de outra
     forma, emite uma mensagem de erro.

 -- Função: mat_trace (<M>)

     Retorna o traço da matriz <M>.  Se <M> não for uma matriz, retorna
     uma forma substantiva.  Quando <M> for uma matriz de bloco,
     'mat_trace(M)' retorna o mesmo valor retornado por
     'mat_trace(mat_unblocker(m))'.

 -- Função: mat_unblocker (<M>)

     Se <M> for uma matriz de bloco, 'mat_unbloker' desfaz o bloco de
     <M> um nível.  Se <M> for uma matriz, 'mat_unblocker (M)' retorna
     <M>; de outra forma, emite uma mensagem de erro.

     Dessa forma se cada entrada de <M> for matriz, 'mat_unblocker (M)'
     retorna uma matriz "desblocada", mas se cada entrada de <M> for uma
     matriz de bloco, 'mat_unblocker (M)' retorna uma matriz de bloco
     com um nível de bloco a menos.

     Se você usa matrizes de bloco, muito provavelmente você irá querer
     escolher 'matrix_element_mult' para '"."' e
     'matrix_element_transpose' para ''transpose'.  Veja também
     'mat_fullunblocker'.

     Exemplo:

          (%i1) A : matrix ([1, 2], [3, 4]);
                                      [ 1  2 ]
          (%o1)                       [      ]
                                      [ 3  4 ]
          (%i2) B : matrix ([7, 8], [9, 10]);
                                      [ 7  8  ]
          (%o2)                       [       ]
                                      [ 9  10 ]
          (%i3) matrix ([A, B]);
                               [ [ 1  2 ]  [ 7  8  ] ]
          (%o3)                [ [      ]  [       ] ]
                               [ [ 3  4 ]  [ 9  10 ] ]
          (%i4) mat_unblocker (%);
                                   [ 1  2  7  8  ]
          (%o4)                    [             ]
                                   [ 3  4  9  10 ]

 -- Função: nonnegintegerp (<n>)

     Retorna 'true' se e somente se '<n> >= 0' e <n> for um inteiro.

 -- Função: nullspace (<M>)

     Se <M> for uma matriz, retorna 'span (v_1, ..., v_n)', onde o
     conjunto '{v_1, ..., v_n}' é uma base para o espaço nulo de <M>.  A
     diferença entre o maior elemento e o menor elemento do conjunto
     vazio é '{0}'.  Dessa forma, quando o espaço nulo tiver somente um
     membro, retorna 'span ()'.

 -- Função: nullity (<M>)

     Se <M> for uma matriz, retorna a dimensão do espaço nulo de <M>.

 -- Função: orthogonal_complement (<v_1>, ..., <v_n>)

     Retorna 'span (u_1, ..., u_m)', onde o conjunto '{u_1, ..., u_m}' é
     uma base para o complemento ortogonal do conjunto '(v_1, ...,
     v_n)'.

     Cada vetor no intervalo de <v_1> até <v_n> deve ser um vetor
     coluna.

 -- Função: polynomialp (<p>, <L>, <coeffp>, <exponp>)
 -- Função: polynomialp (<p>, <L>, <coeffp>)
 -- Função: polynomialp (<p>, <L>)

     Retorna 'true' se <p> for um polinômio nas variáveis da lista <L>,
     O predicado <coeffp> deve avaliar para 'true' para cada
     coeficiente, e o predicado <exponp> deve avaliar para 'true' para
     todos os expoentes das variáveis na lista <L>.  Se você quiser usar
     um valor personalizado para <exponp>, você deve fornecer <coeffp>
     com um valor mesmo se você quiser o valor padrão para <coeffp>.

     'polynomialp (<p>, <L>, <coeffp>)' é equivalente a 'polynomialp
     (<p>, <L>, <coeffp>, 'nonnegintegerp)'.

     'polynomialp (<p>, <L>)' é equivalente a 'polynomialp (<p>, L<,>
     'constantp, 'nonnegintegerp)'.

     O polinômio não precisa ser expandido:

          (%i1) polynomialp ((x + 1)*(x + 2), [x]);
          (%o1)                         true
          (%i2) polynomialp ((x + 1)*(x + 2)^a, [x]);
          (%o2)                         false

     Um exemplo usando um valor personalizado para 'coeffp' e para
     'exponp':

          (%i1) polynomialp ((x + 1)*(x + 2)^(3/2), [x], numberp, numberp);
          (%o1)                         true
          (%i2) polynomialp ((x^(1/2) + 1)*(x + 2)^(3/2), [x], numberp, numberp);
          (%o2)                         true

     Polinômios com duas variáveis:

          (%i1) polynomialp (x^2 + 5*x*y + y^2, [x]);
          (%o1)                         false
          (%i2) polynomialp (x^2 + 5*x*y + y^2, [x, y]);
          (%o2)                         true

 -- Função: polytocompanion (<p>, <x>)

     Se <p> for um polinômio em <x>, retorna a atriz companheira de <p>.
     Para um polinômio mônico <p> de grau <n>, temos '<p> = (-1)^<n>
     charpoly (polytocompanion (<p>, <x>))'.

     Quando <p> não for um polinômio em <x>, emite uma mensagem de erro.

 -- Função: ptriangularize (<M>, <v>)

     Se <M> for uma matriz onde cada entrada dessa matriz for um
     polinômio em <v>, retorna a matriz <M2> tal que

     (1) <M2> é triangular alta,

     (2) '<M2> = <E_n> ... <E_1> <M>', onde os elemetnos de <E_1> a
     <E_n> são matrizes elementares cujas entrada são polinômios em <v>,

     (3) '|det (<M>)| = |det (<M2>)|',

     Nota: Essa função não verifica se toda entrada é um polinômio em
     <v>.

 -- Função: rowop (<M>, <i>, <j>, <theta>)

     Se <M> for uma matriz, retorna a matriz que resulta de se fazer a
     operação de linha 'R_i <- R_i - theta * R_j'.  Se <M> não tiver uma
     linha <i> ou <j>, emite uma mensagem de erro.

 -- Função: rank (<M>)

     Retorna o ranque daquela matriz <M>.  O rank é a dimensão do espaço
     coluna.  Exemplo:
          (%i1) rank(matrix([1,2],[2,4]));
          (%o1)                                  1
          (%i2) rank(matrix([1,b],[c,d]));
           Proviso:  {d - b c # 0}
          (%o2)                                  2

 -- Função: rowswap (<M>, <i>, <j>)

     Se <M> for uma matriz, permuta as linha <i> e <j>.  Se <M> não
     tiver uma linha <i> ou <j>, emite uma mensagem de erro.

 -- Função: toeplitz (<col>)
 -- Função: toeplitz (<col>, <lin>)

     Retorna uma matriz de Toeplitz <T>.  a primeira coluna de <T> é
     <col>; exceto para a primeira entrada, a primeira linha de <T> é
     <lin>.  O padrão para <lin> é o conjugado complexo de <col>.
     Exemplo:
          (%i1)  toeplitz([1,2,3],[x,y,z]);

                                            [ 1  y  z ]
                                            [         ]
          (%o1)                             [ 2  1  y ]
                                            [         ]
                                            [ 3  2  1 ]
          (%i2)  toeplitz([1,1+%i]);

                                        [   1     1 - %I ]
          (%o2)                         [                ]
                                        [ %I + 1    1    ]

 -- Função: vandermonde_matrix ([<x_1>, ..., <x_n>])

     Retorna uma matriz <n> por <n> cuja <i>-ésima linha é '[1, <x_i>,
     <x_i>^2, ... <x_i>^(<n>-1)]'.

 -- Função: zerofor (<M>)
 -- Função: zerofor (<M>, <fld>)

     Retorna uma matriz zero que tem o mesmo tamanho da matriz <M>.
     Toda entrada da matriz zero é a identidade aditiva do anel <fld>; o
     valor padrão para <fld> é <generalring>.

     O primeiro argumento <M> pode ser uma matriz quadrada ou uma não
     matriz.  Quando <M> for uma matriz, cada entrada de <M> pode ser
     uma matriz quadrada - dessa forma <M> pode ser uma matriz de bloco
     do Maxima.  A matriz pode ser de bloco para qualquer nível
     (finito).

     Veja também 'identfor'

 -- Função: zeromatrixp (<M>)

     Se <M> não for uma matriz de bloco, retorna 'true' se 'is (equal
     (<e>, 0))' for verdadeiro para cada elemento <e> da matriz <M>.  Se
     <M> for uma matriz de bloco, retorna 'true' se 'zeromatrixp'
     avaliar para 'true' para cada elemento de <e>.

