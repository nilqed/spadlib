)abbrev package DRAWFE DrawFrontend
++ Author: Kurt Pagani <nilqed@gmail.com>
++ Date Created: 13 October 2016
++ Date Revised: 13 April 2021
++ Basic Operations: 
DrawFrontend():
 Exports == Implementation where 
  EF    ==> Expression Float
  STR   ==> String
  FET   ==> Table(Symbol,String) 
  G     ==> GraphImage
  DROP  ==> DrawOption
  DROP0 ==> DrawOptionFunctions0
  DROP1 ==> DrawOptionFunctions1
  
  SPACE3 ==> ThreeSpace(DoubleFloat)
  

  Exports ==> with
  
    createDraw2D : (G, List DROP, FET) -> Void
    createDraw3D : (SPACE3, List DROP, FET) -> Void
    writeGnuplot2D : (G, List DROP, FET) -> Void
    writeGnuplot3D : (SPACE3, List DROP, FET) -> Void
    writeGLE2D : (G, List DROP, FET) -> Void
    writeGLE3D : (SPACE3, List DROP, FET) -> Void
    
  Implementation ==> add
  
    import from TwoDimensionalViewport
    import from ThreeDimensionalViewport
    import from TopLevelDrawFunctions
    import from GraphImage
    import from SPACE3
    import from EF

    -- persist option is -p or --persist
    gpl:="system gnuplot -p -e _"set term ~A;load '~A'_""   

    createDraw2D(g1:G,opts:List DROP,fe:FET):Void ==
      fetype:STR:=fe.'type
      feoutp:STR:=fe.'output
      fedisp:STR:=fe.'display
      output("Frontend ......: " fetype)$OutputPackage
      output("Output ........: " feoutp)$OutputPackage
      output("Display .......: " fedisp)$OutputPackage
      fetype = "gnuplot"  => writeGnuplot2D(g1,opts,fe)
      fetype = "gle"      => writeGLE2D(g1,opts,fe)
      void()

    createDraw3D(s1:SPACE3,opts:List DROP,fe:FET):Void ==
      fetype:STR:=fe.'type
      feoutp:STR:=fe.'output
      fedisp:STR:=fe.'display
      output("Frontend ......: " fetype)$OutputPackage
      output("Output ........: " feoutp)$OutputPackage
      output("Display .......: " fedisp)$OutputPackage
      fetype = "gnuplot"  => writeGnuplot3D(s1,opts,fe)
      fetype = "gle"      => writeGLE3D(s1,opts,fe)
      void()


    writeGnuplot2D(g : G, opts : List DROP, fe:FET):Void ==
      filename:String:=fe.'output
      display:String:=fe.'display
      f1:TextFile:=open(filename::FileName,"output")
      title:=title(opts,"")$DROP0
      style:=style(opts,"lc 'magenta' lw 2 with lines")$DROP0
      pfmt:="plot '-' title '~A' ~A"
      pcmd:=string(FORMAT('NIL,pfmt,title,style)$Lisp)
      writeLine!(f1,pcmd)
      p2 := pointLists(g)
      for p1 in p2 repeat
        for p in p1 repeat
          writeLine!(f1,concat([unparse(convert(p.1)@InputForm)," ",
                              unparse(convert(p.2)@InputForm)]))
        writeLine!(f1)
      close! f1
      cmd:=string(FORMAT('NIL,gpl,display,filename)$Lisp)
      systemCommand(cmd)$MoreSystemCommands
      
      
    
    writeGnuplot3D(s : SPACE3, opts : List DROP, fe:FET):Void ==
      filename:String:=fe.'output
      display:String:=fe.'display
      f1:TextFile:=open(filename::FileName,"output")
      title:=title(opts,"")$DROP0 
      style:=style(opts,"lc 'magenta' lw 1 with lines")$DROP0  
      -- TODO style? strange
      pfmt:="splot '-' title '~A' ~A"
      pcmd:=string(FORMAT('NIL,pfmt,title,style)$Lisp)
      writeLine!(f1, pcmd) 
      p2:List List Point DoubleFloat
      if mesh? s then 
        p2 := mesh(s)
      else
        if curve? s then
          p2 := [curve(s)]
        else
          error "unknown object."
      --
      for p1 in p2 repeat
        for p in p1 repeat
          writeLine!(f1,concat([unparse(convert(p.1)@InputForm)," ",
                                unparse(convert(p.2)@InputForm)," ",
                                unparse(convert(p.3)@InputForm)]))
        writeLine!(f1)
      close! f1      
      cmd:=string(FORMAT('NIL,gpl,display,filename)$Lisp)
      systemCommand(cmd)$MoreSystemCommands


)abbrev domain GRIMAGE GraphImage
++ Author: Jim Wen
++ Date Created: 27 April 1989
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: TwoDimensionalGraph creates virtual two dimensional graphs
++ (to be displayed on TwoDimensionalViewports).
GraphImage () : Exports == Implementation where

  VIEW    ==> _$ViewportServer$Lisp
  sendI   ==> sockSendInt$Lisp
  sendSF  ==> sockSendFloat$Lisp
  sendSTR ==> sockSendString$Lisp
  getI    ==> sockGetInt$Lisp
  getSF   ==> sockGetFloat$Lisp

  typeGRAPH  ==> 2
  typeVIEW2D ==> 3

  makeGRAPH  ==> (-1)$SingleInteger
  makeVIEW2D ==> (-1)$SingleInteger

  I   ==> Integer
  PI  ==> PositiveInteger
  NNI ==> NonNegativeInteger
  SF  ==> DoubleFloat
  F   ==> Float
  L   ==> List
  P   ==> Point(SF)
  V   ==> Vector
  SEG ==> Segment
  RANGESF   ==> L SEG SF
  RANGEF    ==> L SEG F
  UNITSF   ==> L SF
  UNITF    ==> L F
  PAL ==> Palette
  E   ==> OutputForm
  DROP ==> DrawOption
  PP ==> PointPackage(SF)
  COORDSYS ==> CoordinateSystems(SF)

  Exports ==> SetCategory with
    graphImage      :  ()                                        -> %
      ++ graphImage() returns an empty graph with 0 point lists
      ++ of the domain \spadtype{GraphImage}.  A graph image contains
      ++ the graph data component of a two dimensional viewport.
    sendGraphImage  :  %  -> Void
      ++ sendGraphImage(gi) takes the given graph, \spad{gi} of the
      ++ domain \spadtype{GraphImage}, and sends it's data to the
      ++ viewport manager where it waits to be included in a two-dimensional
      ++ viewport window.  \spad{gi} cannot be an empty graph.
    makeGraphImage  :  (L L P)                                   -> %
      ++ makeGraphImage(llp) returns a graph of the domain
      ++ \spadtype{GraphImage} which is composed of the points and
      ++ lines from the list of lists of points, \spad{llp}, with
      ++ default point size and default point and line colours.
    makeGraphImage  :  (L L P, L PAL, L PAL, L PI)                  -> %
      ++ makeGraphImage(llp, lpal1, lpal2, lp) returns a graph of the
      ++ domain \spadtype{GraphImage} which is composed of the points
      ++ and lines from the list of lists of points, \spad{llp}, whose
      ++ point colors are indicated by the list of palette colors,
      ++ \spad{lpal1}, and whose lines are colored according to the list
      ++ of palette colors, \spad{lpal2}.  The paramater lp is a list of
      ++ integers which denote the size of the data points.
    makeGraphImage  :  (L L P, L PAL, L PAL, L PI, L DROP)           -> %
      ++ makeGraphImage(llp, lpal1, lpal2, lp, lopt) returns a graph of
      ++ the domain \spadtype{GraphImage} which is composed of the
      ++ points and lines from the list of lists of points, \spad{llp},
      ++ whose point colors are indicated by the list of palette colors,
      ++ \spad{lpal1}, and whose lines are colored according to the list
      ++ of palette colors, \spad{lpal2}.  The paramater lp is a list of
      ++ integers which denote the size of the data points, and \spad{lopt}
      ++ is the list of draw command options.
    pointLists      :  %                                         -> L L P
      ++ pointLists(gi) returns the list of lists of points which compose
      ++ the given graph, \spad{gi}, of the domain \spadtype{GraphImage}.
    key             :  %                                         -> I
      ++ key(gi) returns the process ID of the given graph, \spad{gi},
      ++ of the domain \spadtype{GraphImage}.
    ranges          :  %                                         -> RANGEF
      ++ ranges(gi) returns the list of ranges of the point components from
      ++ the indicated graph, \spad{gi}, of the domain \spadtype{GraphImage}.
    ranges          :  (%, RANGEF)                                -> RANGEF
      ++ ranges(gi, lr) modifies the list of ranges for the given graph,
      ++ \spad{gi} of the domain \spadtype{GraphImage}, to be that of the
      ++ list of range segments, \spad{lr}, and returns the new range list
      ++ for \spad{gi}.
    units           :  %                                         -> UNITF
      ++ units(gi) returns the list of unit increments for the x and y
      ++ axes of the indicated graph, \spad{gi}, of the domain
      ++ \spadtype{GraphImage}.
    units           :  (%, UNITF)                                 -> UNITF
      ++ units(gi, lu) modifies the list of unit increments for the x and y
      ++ axes of the given graph, \spad{gi} of the domain
      ++ \spadtype{GraphImage}, to be that of the list of unit increments,
      ++ \spad{lu}, and returns the new list of units for \spad{gi}.
    component       :  (%, L P, PAL, PAL, PI)                        -> Void
      ++ component(gi, lp, pal1, pal2, p) sets the components of the
      ++ graph, \spad{gi} of the domain \spadtype{GraphImage}, to the
      ++ values given.  The point list for \spad{gi} is set to the list
      ++ \spad{lp}, the color of the points in \spad{lp} is set to
      ++ the palette color \spad{pal1}, the color of the lines which
      ++ connect the points \spad{lp} is set to the palette color
      ++ \spad{pal2}, and the size of the points in \spad{lp} is given
      ++ by the integer p.
    component       :  (%, P)                                     -> Void
      ++ component(gi, pt) modifies the graph \spad{gi} of the domain
      ++ \spadtype{GraphImage} to contain one point component, \spad{pt}
      ++ whose point color, line color and point size are determined by
      ++ the default functions \spadfun{pointColorDefault},
      ++ \spadfun{lineColorDefault}, and \spadfun{pointSizeDefault}.
    component       :  (%, P, PAL, PAL, PI)                          -> Void
      ++ component(gi, pt, pal1, pal2, ps) modifies the graph \spad{gi} of
      ++ the domain \spadtype{GraphImage} to contain one point component,
      ++ \spad{pt} whose point color is set to the palette color \spad{pal1},
      ++ line color is set to the palette color \spad{pal2}, and point
      ++ size is set to the positive integer \spad{ps}.
    appendPoint     :  (%, P)                                     -> Void
      ++ appendPoint(gi, pt) appends the point \spad{pt} to the end
      ++ of the list of points component for the graph, \spad{gi}, which is
      ++ of the domain \spadtype{GraphImage}.
    point           :  (%, P, PAL)                                 -> Void
      ++ point(gi, pt, pal) modifies the graph \spad{gi} of the domain
      ++ \spadtype{GraphImage} to contain one point component, \spad{pt}
      ++ whose point color is set to be the palette color \spad{pal}, and
      ++ whose line color and point size are determined by the default
      ++ functions \spadfun{lineColorDefault} and \spadfun{pointSizeDefault}.
    coerce          :  L L P                                     -> %
      ++ coerce(llp) creates and returns a graph of the domain
      ++ \spadtype{GraphImage} which is composed of the list of list
      ++ of points given by \spad{llp}, and whose point colors, line colors
      ++ and point sizes are determined by the default functions
      ++ \spadfun{pointColorDefault}, \spadfun{lineColorDefault}, and
      ++ \spadfun{pointSizeDefault}.  The graph data is then sent to the
      ++ viewport manager where it waits to be included in a two-dimensional
      ++ viewport window.
    coerce          :  %                                         -> E
      ++ coerce(gi) returns the indicated graph, \spad{gi}, of domain
      ++ \spadtype{GraphImage} as output of the domain \spadtype{OutputForm}.
    putColorInfo    : (L L P, L PAL)                              -> L L P
      ++ putColorInfo(llp, lpal) takes a list of list of points, \spad{llp},
      ++ and returns the points with their hue and shade components
      ++ set according to the list of palette colors, \spad{lpal}.

  Implementation ==> add
    import from Color()
    import from Palette()
    import from ViewDefaultsPackage()
    import from PlotTools()
    import from DrawOptionFunctions0
    import from P
    import from PP
    import from COORDSYS

    Rep := Record(key : I, rangesField : RANGESF, unitsField : UNITSF, _
       llPoints : L L P, pointColors : L PAL, lineColors : L PAL, pointSizes : L PI, _
       optionsField : L DROP)

--%Internal Functions

    graph       : RANGEF                          -> %
    scaleStep   : SEG SF -> SF


    numberCheck(nums : Point SF) : Void ==
      for i in minIndex(nums)..maxIndex(nums) repeat
        COMPLEXP(nums.(i::PositiveInteger))$Lisp =>
          error "An unexpected complex number was encountered in the calculations."


    doOptions(g : Rep) : Void ==
      lr : RANGEF := ranges(g.optionsField, ranges g)
      if (#lr > 1$I) then
        g.rangesField := [segment(convert(low(lr.1))@SF,
                                  convert(high(lr.1))@SF)$(Segment(SF)),
                          segment(convert(low(lr.2))@SF,
                                  convert(high(lr.2))@SF)$(Segment(SF))]
      else
        g.rangesField := []
      lu : UNITF := units(g.optionsField, units g)
      if (#lu > 1$I) then
        g.unitsField := [convert(lu.1)@SF, convert(lu.2)@SF]
      else
        g.unitsField := []
    -- etc - graphimage specific stuff...

    putColorInfo(llp, listOfPalettes) ==
      llp2 : L L P := []
      for lp in llp for pal in listOfPalettes repeat
        lp2 : L P := []
        daHue   := (hue(hue pal))::SF
        daShade := (shade pal)::SF
        for p in lp repeat
          if (d := dimension p) < 3 then
            p := extend(p, [daHue, daShade])
          else
            p.3 := daHue
            d < 4 => p := extend(p, [daShade])
            p.4 := daShade
          lp2 := cons(p, lp2)
        llp2 := cons(reverse! lp2, llp2)
      reverse! llp2

    graph demRanges ==
      empty?(demRanges) =>  [ 0, [], [], [], [], [], [], [] ]
      demRangesSF : RANGESF := _
        [segment(convert(low(demRanges.1))@SF,
                 convert(high(demRanges.1))@SF)$(Segment(SF)),
         segment(convert(low(demRanges.1))@SF,
                 convert(high(demRanges.1))@SF)$(Segment(SF))]
      [ 0, demRangesSF, [], [], [], [], [], [] ]

    scaleStep(range_seg) ==                        -- MGR
      range := high(range_seg) - low(range_seg)

      adjust : NNI
      tryStep : SF
      scaleDown : SF
      numerals : String
      adjust := 0
      while range < 100.0::SF repeat
        adjust := adjust + 1
        range := range * 10.0::SF -- might as well take big steps
      tryStep := range/10.0::SF
      numerals := string(((retract(ceiling(tryStep)$SF)$SF)@I))$String
      scaleDown := (10@I ^$I (((#(numerals)@I) - 1$I) pretend PI))::SF
      scaleDown*ceiling(tryStep/scaleDown - 0.5::SF)/((10 ^$I adjust)::SF)

    figureUnits(ranges : RANGESF) : UNITSF ==
        [scaleStep(first(ranges)), scaleStep(second(ranges))]

    roundRange(range : SEG SF) : SEG SF ==
        single_eps := (2.0::SF)^(-19)
        low := low(range)
        low :=
            abs(low) < 1 => low - single_eps
            low < 0 => (1.0::SF + single_eps)*low
            (1.0::SF - single_eps)*low
        high := high(range)
        high :=
            abs(high) < 1 =>  high + single_eps
            high < 0 => (1.0::SF - single_eps)*high
            (1.0::SF + single_eps)*high
        low..high

    roundRanges(ranges : RANGESF) : RANGESF ==
        [roundRange(first(ranges)), roundRange(second(ranges))]

    plotLists(graf : Rep, listOfListsOfPoints : L L P, listOfPointColors : L PAL, listOfLineColors : L PAL, listOfPointSizes : L PI) : % ==
      givenLen := #listOfListsOfPoints
        -- take out point lists that are actually empty
      listOfListsOfPoints := [l for l in listOfListsOfPoints | not empty?(l)]
      if empty?(listOfListsOfPoints) then
        error "GraphImage was given a list that contained no valid point lists"
      if ((len := #listOfListsOfPoints) ~= givenLen) then
          say("   Warning: Ignoring pointless point list")$DisplayPackage
      graf.llPoints := listOfListsOfPoints
        -- do point colors
      if ((givenLen := #listOfPointColors) > len) then
         -- pad or discard elements if given list has length different from the point list
        graf.pointColors := concat(listOfPointColors,
            new((len - givenLen)::NonNegativeInteger + 1, pointColorDefault()))
      else graf.pointColors := first(listOfPointColors, len)
        -- do line colors
      if ((givenLen := #listOfLineColors) > len) then
        graf.lineColors := concat(listOfLineColors,
             new((len - givenLen)::NonNegativeInteger + 1, lineColorDefault()))
      else graf.lineColors := first(listOfLineColors, len)
        -- do point sizes
      if ((givenLen := #listOfPointSizes) > len) then
        graf.pointSizes := concat(listOfPointSizes,
             new((len - givenLen)::NonNegativeInteger + 1, pointSizeDefault()))
      else graf.pointSizes := first(listOfPointSizes, len)
      graf

    sendGraphImage graf ==
      doOptions(graf)
      (s := #(graf.llPoints)) = 0 =>
        error "You are trying to make a graph with no points"
      key graf ~= 0 =>
        error "You are trying to draw over an existing graph"
      transform := coord(graf.optionsField, cartesian$COORDSYS)$DrawOptionFunctions0
      graf.llPoints := putColorInfo(graf.llPoints, graf.pointColors)
      if empty?(ranges graf) then  -- figure out best ranges for points
        graf.rangesField := calcRanges(graf.llPoints)  --::V SEG SF
      graf.rangesField := roundRanges(graf.rangesField)
      if empty?(units graf) then  -- figure out best ranges for points
        graf.unitsField := figureUnits(graf.rangesField)  --::V SEG SF
      say(
        "   Graph data being transmitted to the viewport manager..."
                  )$DisplayPackage
      sendI(VIEW, typeGRAPH)
      sendI(VIEW, makeGRAPH)
      tonto := (graf.rangesField)::RANGESF
      sendSF(VIEW, low(first(tonto)))
      sendSF(VIEW, high(first(tonto)))
      sendSF(VIEW, low(second(tonto)))
      sendSF(VIEW, high(second(tonto)))
      sendSF(VIEW, first (graf.unitsField))
      sendSF(VIEW, second (graf.unitsField))
      sendI(VIEW, s)    -- how many lists of points are being sent
      for aList in graf.llPoints for pColor in graf.pointColors for lColor in graf.lineColors for s in graf.pointSizes repeat
        sendI(VIEW, #aList)   -- how many points in this list
        for p in aList repeat
          aPoint := transform p
          sendSF(VIEW, xCoord aPoint)
          sendSF(VIEW, yCoord aPoint)
          sendSF(VIEW, hue(p)$PP)  -- ?use aPoint as well...?
          sendSF(VIEW, shade(p)$PP)
        hueShade := hue hue pColor + shade pColor * numberOfHues()
        sendI(VIEW, hueShade)
        hueShade := (hue hue lColor -1)*5 + shade lColor
        sendI(VIEW, hueShade)
        sendI(VIEW, s)
      graf.key := getI(VIEW)


--%Exported Functions
    key graf                  == graf.key
    pointLists graf           == graf.llPoints
    ranges graf                ==
      empty?(graf.rangesField) => []
      [segment(convert(low(graf.rangesField.1))@F,
               convert(high(graf.rangesField.1))@F),
       segment(convert(low(graf.rangesField.2))@F,
               convert(high(graf.rangesField.2))@F)]
    ranges(graf, rangesList)     ==
      graf.rangesField :=
        [segment(convert(low(rangesList.1))@SF,
                 convert(high(rangesList.1))@SF),
         segment(convert(low(rangesList.2))@SF,
                 convert(high(rangesList.2))@SF)]
      rangesList
    units graf                ==
      empty?(graf.unitsField) => []
      [convert(graf.unitsField.1)@F, convert(graf.unitsField.2)@F]
    units (graf, unitsToBe)    ==
      graf.unitsField := [convert(unitsToBe.1)@SF, convert(unitsToBe.2)@SF]
      unitsToBe
    graphImage                == graph []

    makeGraphImage(llp) ==
      makeGraphImage(llp,
        [pointColorDefault() for i in 1..(l := #llp)],
         [lineColorDefault() for i in 1..l],
          [pointSizeDefault() for i in 1..l])

    makeGraphImage(llp, lpc, llc, lps) ==
      makeGraphImage(llp, lpc, llc, lps, [])

    makeGraphImage(llp, lpc, llc, lps, opts) ==
      graf := graph(ranges(opts, []))
      graf.optionsField := opts
      graf := plotLists(graf, llp, lpc, llc, lps)
      transform := coord(graf.optionsField, cartesian$COORDSYS)$DrawOptionFunctions0
      for aList in graf.llPoints repeat
        for p in aList repeat
          aPoint := transform p
          numberCheck aPoint
      graf

    component (graf : %, ListOfPoints : L P, PointColor : PAL, LineColor : PAL, PointSize : PI) ==
      graf.llPoints    := append(graf.llPoints, [ListOfPoints])
      graf.pointColors := append(graf.pointColors, [PointColor])
      graf.lineColors  := append(graf.lineColors, [LineColor])
      graf.pointSizes  := append(graf.pointSizes, [PointSize])

    component (graf, aPoint) ==
      component(graf, aPoint, pointColorDefault(), lineColorDefault(), pointSizeDefault())

    component (graf : %, aPoint : P, PointColor : PAL, LineColor : PAL, PointSize : PI) ==
      component (graf, [aPoint], PointColor, LineColor, PointSize)

    appendPoint (graf, aPoint) ==
      num : I  := #(graf.llPoints) - 1
      num < 0 => error "No point lists to append to!"
      (graf.llPoints.num) := append((graf.llPoints.num), [aPoint])

    point (graf, aPoint, PointColor) ==
      component(graf, aPoint, PointColor, lineColorDefault(), pointSizeDefault())

    coerce (llp : L L P) : % ==
      makeGraphImage(llp,
          [pointColorDefault() for i in 1..(l := #llp)],
                [lineColorDefault() for i in 1..l],
                     [pointSizeDefault() for i in 1..l])

    coerce (graf : %) : E ==
        hconcat([message("Graph with "), (p := # pointLists graf)::E,
            message(p = 1 => " point list"; " point lists")])


)abbrev domain VIEW2D TwoDimensionalViewport
++ Author: Jim Wen
++ Date Created: 28 April 1989
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: TwoDimensionalViewport creates viewports to display graphs.
TwoDimensionalViewport () : Exports == Implementation where

  VIEW    ==> _$ViewportServer$Lisp
  sendI   ==> sockSendInt$Lisp
  sendSF  ==> sockSendFloat$Lisp
  sendSTR ==> sockSendString$Lisp
  getI    ==> sockGetInt$Lisp
  getSF   ==> sockGetFloat$Lisp

  typeGRAPH  ==> 2
  typeVIEW2D ==> 3

  makeGRAPH  ==> (-1)$SingleInteger
  makeVIEW2D ==> (-1)$SingleInteger

  I    ==> Integer
  PI   ==> PositiveInteger
  NNI  ==> NonNegativeInteger
  XY   ==> Record( X : I, Y : I )
  XYP  ==> Record( X : PI, Y : PI )
  XYNN ==> Record( X : NNI, Y : NNI )
  F    ==> Float
  SF   ==> DoubleFloat
  STR  ==> String
  L    ==> List
  V    ==> Vector
  E    ==> OutputForm
  FLAG ==> Record( showCP : I )
  PAL  ==> Palette()
  B    ==> Boolean
  G    ==> GraphImage
  GS   ==> Record( scaleX : SF, scaleY : SF, deltaX : SF, deltaY : SF, _
                  points : I, connect : I, spline : I, _
                  axes : I, axesColor : PAL, units : I, unitsColor : PAL, _
                  showing : I)
  GU   ==> Union(G,"undefined")
  DROP ==> DrawOption
  POINT ==> Point(SF)

  ---+
  DRAWFE ==> DrawFrontend()
  FET    ==> Table(Symbol,String) 
  ---+

  TRANSLATE2D     ==> 0$I
  SCALE2D         ==> 1$I
  pointsOnOff     ==> 2
  connectOnOff    ==> 3
  spline2D        ==> 4   -- used for controlling regions, now
  reset2D         ==> 5
  hideControl2D   ==> 6
  closeAll2D      ==> 7
  axesOnOff2D     ==> 8
  unitsOnOff2D    ==> 9

  SPADBUTTONPRESS ==> 100
  MOVE            ==> 102
  RESIZE          ==> 103
  TITLE           ==> 104
  showing2D       ==> 105  -- as defined in include/actions.h
  putGraph2D      ==> 106
  writeView       ==> 110
  axesColor2D     ==> 112
  unitsColor2D    ==> 113
  getPickedPTS    ==> 119

  graphStart      ==> 13   -- as defined in include/actions.h

  noControl ==> 0$I

  yes       ==> 1$I
  no        ==> 0$I

  maxGRAPHS ==> 9::I   -- should be the same as maxGraphs in include/view2D.h

  fileTypeDefs ==> ["PIXMAP"]    -- see include/write.h for things to include

  Exports ==> SetCategory with
    getPickedPoints : % -> L POINT
      ++ getPickedPoints(x)
      ++ returns a list of small floats for the points the
      ++ user interactively picked on the viewport
      ++ for full integration into the system, some design
      ++ issues need to be addressed: e.g. how to go through
      ++ the GraphImage interface, how to default to graphs, etc.
    viewport2D     : ()                                     -> %
      ++ viewport2D() returns an undefined two-dimensional viewport
      ++ of the domain \spadtype{TwoDimensionalViewport} whose
      ++ contents are empty.
    makeViewport2D : %                                      -> %
      ++ makeViewport2D(v) takes the given two-dimensional viewport,
      ++ v, of the domain \spadtype{TwoDimensionalViewport} and
      ++ displays a viewport window on the screen which contains
      ++ the contents of v.
    options        : %                                      -> L DROP
      ++ options(v) takes the given two-dimensional viewport, v, of the
      ++ domain \spadtype{TwoDimensionalViewport} and returns a list
      ++ containing the draw options from the domain \spadtype{DrawOption}
      ++ for v.
    options        : (%, L DROP)                             -> %
      ++ options(v, lopt) takes the given two-dimensional viewport, v,
      ++ of the domain \spadtype{TwoDimensionalViewport} and returns
      ++ v with it's draw options modified to be those which are indicated
      ++ in the given list, \spad{lopt} of domain \spadtype{DrawOption}.
    makeViewport2D : (G, L DROP)                             -> %
      ++ makeViewport2D(gi, lopt) creates and displays a viewport window
      ++ of the domain \spadtype{TwoDimensionalViewport} whose graph
      ++ field is assigned to be the given graph, \spad{gi}, of domain
      ++ \spadtype{GraphImage}, and whose options field is set to be
      ++ the list of options, \spad{lopt} of domain \spadtype{DrawOption}.
    graphState     : (%, PI, SF, SF, SF, SF, I, I, I, I, PAL, I, PAL, I) -> Void
      ++ graphState(v, num, sX, sY, dX, dY, pts, lns, box, axes, axesC, un, unC, cP)
      ++ sets the state of the characteristics for the graph indicated
      ++ by \spad{num} in the given two-dimensional viewport v, of domain
      ++ \spadtype{TwoDimensionalViewport}, to the values given as
      ++ parameters.  The scaling of the graph in the x and y component
      ++ directions is set to be \spad{sX} and \spad{sY}; the window
      ++ translation in the x and y component directions is set to be
      ++ \spad{dX} and \spad{dY}; The graph points, lines, bounding box,
      ++ axes, or units will be shown in the viewport if their given
      ++ parameters \spad{pts}, \spad{lns}, \spad{box}, \spad{axes} or
      ++ \spad{un} are set to be \spad{1}, but will not be shown if they
      ++ are set to \spad{0}.  The color of the axes and the color of the
      ++ units are indicated by the palette colors \spad{axesC} and
      ++ \spad{unC} respectively.  To display the control panel when
      ++ the viewport window is displayed, set \spad{cP} to \spad{1},
      ++ otherwise set it to \spad{0}.
    graphStates    : %                                      -> V GS
      ++ graphStates(v) returns and shows a listing of a record containing
      ++ the current state of the characteristics of each of the ten graph
      ++ records in the given two-dimensional viewport, v, which is of
      ++ domain \spadtype{TwoDimensionalViewport}.
    graphs         : %                                      -> V GU
      ++ graphs(v) returns a vector, or list, which is a union of all
      ++ the graphs, of the domain \spadtype{GraphImage}, which are
      ++ allocated for the two-dimensional viewport, v, of domain
      ++ \spadtype{TwoDimensionalViewport}.  Those graphs which have
      ++ no data are labeled "undefined", otherwise their contents
      ++ are shown.
    title          : (%, STR)                                -> Void
      ++ title(v, s) changes the title which is shown in the two-dimensional
      ++ viewport window, v of domain \spadtype{TwoDimensionalViewport}.
    putGraph       : (%, G, PI)                               -> Void
      ++ putGraph(v, gi, n) sets the graph field indicated by n, of the
      ++ indicated two-dimensional viewport, v, which is of domain
      ++ \spadtype{TwoDimensionalViewport}, to be the graph, \spad{gi}
      ++ of domain \spadtype{GraphImage}.  The contents of viewport, v,
      ++ will contain \spad{gi} when the function \spadfun{makeViewport2D}
      ++ is called to create the an updated viewport v.
    getGraph       : (%, PI)                                 -> G
      ++ getGraph(v, n) returns the graph which is of the domain
      ++ \spadtype{GraphImage} which is located in graph field n
      ++ of the given two-dimensional viewport, v, which is of the
      ++ domain \spadtype{TwoDimensionalViewport}.
    axes           : (%, PI, STR)                             -> Void
      ++ axes(v, n, s) displays the axes of the graph in field n of
      ++ the given two-dimensional viewport, v, which is of domain
      ++ \spadtype{TwoDimensionalViewport}, if s is "on", or does
      ++ not display the axes if s is "off".
    axes           : (%, PI, PAL)                             -> Void
      ++ axes(v, n, c) displays the axes of the graph in field n of
      ++ the given two-dimensional viewport, v, which is of domain
      ++ \spadtype{TwoDimensionalViewport}, with the axes color set to
      ++ the given palette color c.
    units          : (%, PI, STR)                             -> Void
      ++ units(v, n, s) displays the units of the graph in field n of
      ++ the given two-dimensional viewport, v, which is of domain
      ++ \spadtype{TwoDimensionalViewport}, if s is "on", or does
      ++ not display the units if s is "off".
    units          : (%, PI, PAL)                             -> Void
      ++ units(v, n, c) displays the units of the graph in field n of
      ++ the given two-dimensional viewport, v, which is of domain
      ++ \spadtype{TwoDimensionalViewport}, with the units color set to
      ++ the given palette color c.
    points         : (%, PI, STR)                             -> Void
      ++ points(v, n, s) displays the points of the graph in field n of
      ++ the given two-dimensional viewport, v, which is of domain
      ++ \spadtype{TwoDimensionalViewport}, if s is "on", or does
      ++ not display the points if s is "off".
    region         : (%, PI, STR)                             -> Void
      ++ region(v, n, s) displays the bounding box of the graph in
      ++ field n of the given two-dimensional viewport, v, which is
      ++ of domain \spadtype{TwoDimensionalViewport}, if s is "on",
      ++ or does not display the bounding box if s is "off".
    connect        : (%, PI, STR)                             -> Void
      ++ connect(v, n, s) displays the lines connecting the graph
      ++ points in field n of the given two-dimensional viewport, v,
      ++ which is of domain \spadtype{TwoDimensionalViewport}, if s
      ++ is "on", or does not display the lines if s is "off".
    controlPanel   : (%, STR)                                -> Void
      ++ controlPanel(v, s) displays the control panel of the given
      ++ two-dimensional viewport, v, which is of domain
      ++ \spadtype{TwoDimensionalViewport}, if s is "on", or hides
      ++ the control panel if s is "off".
    close          : %                                      -> Void
      ++ close(v) closes the viewport window of the given
      ++ two-dimensional viewport, v, which is of domain
      ++ \spadtype{TwoDimensionalViewport}, and terminates the
      ++ corresponding process ID.
    dimensions     : (%, NNI, NNI, PI, PI)                      -> Void
      ++ dimensions(v, x, y, width, height) sets the position of the
      ++ upper left-hand corner of the two-dimensional viewport, v,
      ++ which is of domain \spadtype{TwoDimensionalViewport}, to
      ++ the window coordinate x, y, and sets the dimensions of the
      ++ window to that of \spad{width}, \spad{height}.  The new
      ++ dimensions are not displayed until the function
      ++ \spadfun{makeViewport2D} is executed again for v.
    scale          : (%, PI, F, F)                             -> Void
      ++ scale(v, n, sx, sy) displays the graph in field n of the given
      ++ two-dimensional viewport, v, which is of domain
      ++ \spadtype{TwoDimensionalViewport}, scaled by the factor \spad{sx}
      ++ in the x-coordinate direction and by the factor \spad{sy} in
      ++ the y-coordinate direction.
    translate      : (%, PI, F, F)                             -> Void
      ++ translate(v, n, dx, dy) displays the graph in field n of the given
      ++ two-dimensional viewport, v, which is of domain
      ++ \spadtype{TwoDimensionalViewport}, translated by \spad{dx} in
      ++ the x-coordinate direction from the center of the viewport, and
      ++ by \spad{dy} in the y-coordinate direction from the center.
      ++ Setting \spad{dx} and \spad{dy} to \spad{0} places the center
      ++ of the graph at the center of the viewport.
    show           : (%, PI, STR)                             -> Void
      ++ show(v, n, s) displays the graph in field n of the given
      ++ two-dimensional viewport, v, which is of domain
      ++ \spadtype{TwoDimensionalViewport}, if s is "on", or does not
      ++ display the graph if s is "off".
    move           : (%, NNI, NNI)                            -> Void
      ++ move(v, x, y) displays the two-dimensional viewport, v, which
      ++ is of domain \spadtype{TwoDimensionalViewport}, with the upper
      ++ left-hand corner of the viewport window at the screen
      ++ coordinate position x, y.
    update         : (%, G, PI)                               -> Void
      ++ update(v, gr, n) drops the graph \spad{gr} in slot \spad{n}
      ++ of viewport \spad{v}. The graph gr must have been
      ++ transmitted already and acquired an integer key.
    resize         : (%, PI, PI)                              -> Void
      ++ resize(v, w, h) displays the two-dimensional viewport, v, which
      ++ is of domain \spadtype{TwoDimensionalViewport}, with a width
      ++ of w and a height of h, keeping the upper left-hand corner
      ++ position unchanged.
    write          : (%, STR)                                -> STR
      ++ write(v, s) takes the given two-dimensional viewport, v, which
      ++ is of domain \spadtype{TwoDimensionalViewport}, and creates
      ++ a directory indicated by s, which contains the graph data
      ++ files for v.
    write          : (%, STR, STR)                            -> STR
      ++ write(v, s, f) takes the given two-dimensional viewport, v, which
      ++ is of domain \spadtype{TwoDimensionalViewport}, and creates
      ++ a directory indicated by s, which contains the graph data
      ++ files for v and an optional file type f.
    write          : (%, STR, L STR)                          -> STR
      ++ write(v, s, lf) takes the given two-dimensional viewport, v, which
      ++ is of domain \spadtype{TwoDimensionalViewport}, and creates
      ++ a directory indicated by s, which contains the graph data
      ++ files for v and the optional file types indicated by the list lf.
    reset          :  %                                     -> Void
      ++ reset(v) sets the current state of the graph characteristics
      ++ of the given two-dimensional viewport, v, which is of domain
      ++ \spadtype{TwoDimensionalViewport}, back to their initial settings.
    key            :  %                                     -> I
      ++ key(v) returns the process ID number of the given two-dimensional
      ++ viewport, v, which is of domain \spadtype{TwoDimensionalViewport}.
    coerce         :  %                                     -> E
      ++ coerce(v) returns the given two-dimensional viewport, v, which
      ++ is of domain \spadtype{TwoDimensionalViewport} as output of
      ++ the domain \spadtype{OutputForm}.
    setFrontend2D : FET -> FET
      ++ Sets the frontend according to the values in the FET table. 
    getFrontend2D : () -> FET
      ++ Gets the FET table of the current frontend.
    makeFrontend2D  : (%, FET) -> Void
      ++ Makes the frontend according to the values in the FET table.



  Implementation ==> add

    import from GraphImage()
    import from Color()
    import from Palette()
    import from ViewDefaultsPackage()
    import from DrawOptionFunctions0
    import from POINT
    import from DRAWFE

    Rep := Record (key : I, graphsField : V GU, graphStatesField : V GS, _
                   title : STR, moveTo : XYNN, size : XYP, flags : FLAG, optionsField : L DROP)

    import from FLAG

    defaultGS : GS := [convert(0.9)@SF, convert(0.9)@SF, 0$SF, 0$SF, _
                      yes, yes, no, _
                      yes, axesColorDefault(), no, unitsColorDefault(), _
                      yes]

    --+
    frontend:FET:=table()
    frontend.'type:="viewman"
    frontend.'output:=""
    frontend.'display:=""

    --% Local Functions
    setFrontend2D(fe:FET):FET ==
      frontend:=copy(fe)
      
    getFrontend2D():FET == frontend

    makeFrontend2D(v:%, fe:FET):Void ==
      g1:G:=getGraph(v,1)
      opts:L DROP:=options(v)
      createDraw2D(g1,opts,fe)
    --+


     --% Local Functions
    checkViewport (viewport : %) : B ==
        -- checks to see if this viewport still exists
        -- by sending the key to the viewport manager and
        -- waiting for its reply after it checks it against
        -- the viewports in its list. a -1 means it doesn't
        -- exist.
      sendI(VIEW, viewport.key)
      i : Integer := getI(VIEW)
      (i < 0$I) =>
        viewport.key := 0$I
        error "This viewport has already been closed!"
      true

    doOptions(v : Rep) : Void ==
      v.title := title(v.optionsField,"FriCAS2D")
      -- etc - 2D specific stuff...

     --% Exported Functions

    options viewport ==
      viewport.optionsField

    options(viewport, opts) ==
      viewport.optionsField := opts
      viewport

    putGraph (viewport, aGraph, which) ==
      if ((which > maxGRAPHS) or (which < 1)) then
        error "Trying to put a graph with a negative index or too big an index"
      viewport.graphsField.which := aGraph

    getGraph (viewport, which) ==
      if ((which > maxGRAPHS) or (which < 1)) then
        error "Trying to get a graph with a negative index or too big an index"
      viewport.graphsField.which case "undefined" =>
        error "Graph is undefined!"
      viewport.graphsField.which::GraphImage


    graphStates viewport  == viewport.graphStatesField
    graphs viewport       == viewport.graphsField
    key viewport          == viewport.key

    dimensions(viewport, ViewX, ViewY, ViewWidth, ViewHeight) ==
      viewport.moveTo := [ViewX, ViewY]
      viewport.size   := [ViewWidth, ViewHeight]

    move(viewport, xLoc, yLoc) ==
      viewport.moveTo := [xLoc, yLoc]
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW2D)
        sendI(VIEW, MOVE)
        checkViewport viewport =>
          sendI(VIEW, xLoc)
          sendI(VIEW, yLoc)
          getI(VIEW)          -- acknowledge

    update(viewport, graph, slot) ==
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW2D)
        sendI(VIEW, putGraph2D)
        checkViewport viewport =>
          sendI(VIEW, key graph)
          sendI(VIEW, slot)
          getI(VIEW) -- acknowledge
      void()

    resize(viewport, xSize, ySize) ==
      viewport.size := [xSize, ySize]
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW2D)
        sendI(VIEW, RESIZE)
        checkViewport viewport =>
          sendI(VIEW, xSize)
          sendI(VIEW, ySize)
          getI(VIEW)          -- acknowledge

    translate(viewport, graphIndex, xTranslateF, yTranslateF) ==
      xTranslate := convert(xTranslateF)@SF
      yTranslate := convert(yTranslateF)@SF
      if (graphIndex > maxGRAPHS) then
        error "Referring to a graph with too big an index"
      viewport.graphStatesField.graphIndex.deltaX := xTranslate
      viewport.graphStatesField.graphIndex.deltaY := yTranslate
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW2D)
        sendI(VIEW, TRANSLATE2D)
        checkViewport viewport =>
          sendI(VIEW, graphIndex)
          sendSF(VIEW, xTranslate)
          sendSF(VIEW, yTranslate)
          getI(VIEW)          -- acknowledge

    scale(viewport, graphIndex, xScaleF, yScaleF) ==
      xScale := convert(xScaleF)@SF
      yScale := convert(yScaleF)@SF
      if (graphIndex > maxGRAPHS) then
        error "Referring to a graph with too big an index"
      viewport.graphStatesField.graphIndex.scaleX := xScale  -- check union (undefined?)
      viewport.graphStatesField.graphIndex.scaleY := yScale  -- check union (undefined?)
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW2D)
        sendI(VIEW, SCALE2D)
        checkViewport viewport =>
          sendI(VIEW, graphIndex)
          sendSF(VIEW, xScale)
          sendSF(VIEW, yScale)
          getI(VIEW)          -- acknowledge

    viewport2D ==
      [0,new(maxGRAPHS,"undefined"), _
       new(maxGRAPHS,copy defaultGS),"FriCAS2D", _
        [viewPosDefault().1, viewPosDefault().2], [viewSizeDefault().1, viewSizeDefault().2], _
         [noControl], [] ]

    makeViewport2D0 : % -> %

    makeViewport2D(g : G, opts : L DROP) == 
      viewport               := viewport2D()
      viewport.graphsField.1 := g
      viewport.optionsField := opts
      if frontend.'type = "vieman" then
        makeViewport2D0(viewport)
      else
        makeFrontend2D(viewport, getFrontend2D())
        viewport

    makeViewport2D viewport == 
      if frontend.'type = "vieman" then 
        makeViewport2D0 copy(viewport::Rep)
      else
        makeFrontend2D(viewport, getFrontend2D())
        viewport
 

    send_graphs(vg : V GU) : Void ==
        for i in 1..#vg repeat
            (gu := vg(i)) case "undefined" => "iterate"
            g := gu::G
            if key(g) = 0 then sendGraphImage(g)

    makeViewport2D0 viewportDollar ==
      viewport := viewportDollar::Rep
      send_graphs(viewport.graphsField)
      doOptions viewport --local function to extract and assign optional arguments for 2D viewports
      say("   FriCAS2D data being transmitted to the viewport manager..."
         )$DisplayPackage
      sendI(VIEW, typeVIEW2D)
      sendI(VIEW, makeVIEW2D)
      sendSTR(VIEW, viewport.title)
      sendI(VIEW, viewport.moveTo.X)
      sendI(VIEW, viewport.moveTo.Y)
      sendI(VIEW, viewport.size.X)
      sendI(VIEW, viewport.size.Y)
      sendI(VIEW, viewport.flags.showCP)
      for i in 1..maxGRAPHS repeat
        g := (graphs viewport).i
        if g case "undefined" then
          sendI(VIEW, 0$I)
        else
          sendI(VIEW, key(g::G))
          gs := (graphStates viewport).i
          sendSF(VIEW, gs.scaleX)
          sendSF(VIEW, gs.scaleY)
          sendSF(VIEW, gs.deltaX)
          sendSF(VIEW, gs.deltaY)
          sendI(VIEW, gs.points)
          sendI(VIEW, gs.connect)
          sendI(VIEW, gs.spline)
          sendI(VIEW, gs.axes)
          hueShade := hue hue gs.axesColor + shade gs.axesColor * numberOfHues()
          sendI(VIEW, hueShade)
          sendI(VIEW, gs.units)
          hueShade := hue hue gs.unitsColor + shade gs.unitsColor * numberOfHues()
          sendI(VIEW, hueShade)
          sendI(VIEW, gs.showing)
      viewport.key := getI(VIEW)
      viewport

    graphState(viewport, num, sX, sY, dX, dY, Points, Lines, Spline, _
               Axes, AxesColor, Units, UnitsColor, Showing) ==
      viewport.graphStatesField.num := [sX, sY, dX, dY, Points, Lines, Spline, _
                                        Axes, AxesColor, Units, UnitsColor, Showing]

    title(viewport, Title) ==
      viewport.title := Title
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW2D)
        sendI(VIEW, TITLE)
        checkViewport viewport =>
          sendSTR(VIEW, Title)
          getI(VIEW)          -- acknowledge

    reset viewport ==
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW2D)
        sendI(VIEW, SPADBUTTONPRESS)
        checkViewport viewport =>
          sendI(VIEW, reset2D)
          getI(VIEW)          -- acknowledge
      void()

    axes (viewport : %, graphIndex : PI, onOff : STR) : Void ==
      if (graphIndex > maxGRAPHS) then
        error "Referring to a graph with too big an index"
      if onOff = "on" then
        status := yes
      else
        status := no
      viewport.graphStatesField.graphIndex.axes := status  -- check union (undefined?)
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW2D)
        sendI(VIEW, axesOnOff2D)
        checkViewport viewport =>
          sendI(VIEW, graphIndex)
          sendI(VIEW, status)
          getI(VIEW)          -- acknowledge

    axes (viewport : %, graphIndex : PI, color : PAL) : Void ==
      if (graphIndex > maxGRAPHS) then
        error "Referring to a graph with too big an index"
      viewport.graphStatesField.graphIndex.axesColor := color
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW2D)
        sendI(VIEW, axesColor2D)
        checkViewport viewport =>
          sendI(VIEW, graphIndex)
          hueShade := hue hue color + shade color * numberOfHues()
          sendI(VIEW, hueShade)
          getI(VIEW)          -- acknowledge

    units (viewport : %, graphIndex : PI, onOff : STR) : Void ==
      if (graphIndex > maxGRAPHS) then
        error "Referring to a graph with too big an index"
      if onOff = "on" then
        status := yes
      else
        status := no
      viewport.graphStatesField.graphIndex.units := status  -- check union (undefined?)
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW2D)
        sendI(VIEW, unitsOnOff2D)
        checkViewport viewport =>
          sendI(VIEW, graphIndex)
          sendI(VIEW, status)
          getI(VIEW)          -- acknowledge

    units (viewport : %, graphIndex : PI, color : PAL) : Void ==
      if (graphIndex > maxGRAPHS) then
        error "Referring to a graph with too big an index"
      viewport.graphStatesField.graphIndex.unitsColor := color
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW2D)
        sendI(VIEW, unitsColor2D)
        checkViewport viewport =>
          sendI(VIEW, graphIndex)
          hueShade := hue hue color + shade color * numberOfHues()
          sendI(VIEW, hueShade)
          getI(VIEW)          -- acknowledge

    connect (viewport : %, graphIndex : PI, onOff : STR) : Void ==
      if (graphIndex > maxGRAPHS) then
        error "Referring to a graph with too big an index"
      if onOff = "on" then
        status := 1$I
      else
        status := 0$I
      viewport.graphStatesField.graphIndex.connect := status  -- check union (undefined?)
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW2D)
        sendI(VIEW, connectOnOff)
        checkViewport viewport =>
          sendI(VIEW, graphIndex)
          sendI(VIEW, status)
          getI(VIEW)          -- acknowledge

    points (viewport : %, graphIndex : PI, onOff : STR) : Void ==
      if (graphIndex > maxGRAPHS) then
        error "Referring to a graph with too big an index"
      if onOff = "on" then
        status := 1$I
      else
        status := 0$I
      viewport.graphStatesField.graphIndex.points := status  -- check union (undefined?)
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW2D)
        sendI(VIEW, pointsOnOff)
        checkViewport viewport =>
          sendI(VIEW, graphIndex)
          sendI(VIEW, status)
          getI(VIEW)          -- acknowledge

    region (viewport : %, graphIndex : PI, onOff : STR) : Void ==
      if (graphIndex > maxGRAPHS) then
        error "Referring to a graph with too big an index"
      if onOff = "on" then
        status := 1$I
      else
        status := 0$I
      viewport.graphStatesField.graphIndex.spline := status  -- check union (undefined?)
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW2D)
        sendI(VIEW, spline2D)
        checkViewport viewport =>
          sendI(VIEW, graphIndex)
          sendI(VIEW, status)
          getI(VIEW)          -- acknowledge

    show (viewport, graphIndex, onOff) ==
      if (graphIndex > maxGRAPHS) then
        error "Referring to a graph with too big an index"
      if onOff = "on" then
        status := 1$I
      else
        status := 0$I
      viewport.graphStatesField.graphIndex.showing := status  -- check union (undefined?)
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW2D)
        sendI(VIEW, showing2D)
        checkViewport viewport =>
          sendI(VIEW, graphIndex)
          sendI(VIEW, status)
          getI(VIEW)          -- acknowledge

    controlPanel (viewport, onOff) ==
      if onOff = "on" then viewport.flags.showCP := yes
      else viewport.flags.showCP := no
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW2D)
        sendI(VIEW, hideControl2D)
        checkViewport viewport =>
          sendI(VIEW, viewport.flags.showCP)
          getI(VIEW)          -- acknowledge

    close viewport ==
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW2D)
        sendI(VIEW, closeAll2D)
        checkViewport viewport =>
          getI(VIEW)          -- acknowledge
          viewport.key := 0$I
      void()

    coerce viewport ==
      (key(viewport) = 0$I) =>
        hconcat [message("Closed or Undefined TwoDimensionalViewport: "),
                  (viewport.title)::E]
      hconcat [message("TwoDimensionalViewport: "), (viewport.title)::E]

    write(viewport : %, Filename : STR, aThingToWrite : STR) ==
      write(viewport, Filename, [aThingToWrite])

    write(viewport, Filename) ==
      write(viewport, Filename, viewWriteDefault())

    write(viewport : %, Filename : STR, thingsToWrite : L STR) ==
      stringToSend : STR := ""
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW2D)
        sendI(VIEW, writeView)
        checkViewport viewport =>
          sendSTR(VIEW, Filename)
          m := minIndex(avail := viewWriteAvailable())
          for aTypeOfFile in thingsToWrite repeat
            if (writeTypeInt := position(upperCase aTypeOfFile, avail)-m) < 0 then
              say(["  > ", aTypeOfFile,
                " is not a valid file type for writing a 2D viewport"
                          ])$DisplayPackage
            else
              sendI(VIEW, writeTypeInt + 1$I)
                  --              stringToSend := concat [stringToSend,"%",aTypeOfFile]
                  --              sendSTR(VIEW, stringToSend)
          sendI(VIEW, 0$I)     -- no more types of things to write
          getI(VIEW)          -- acknowledge
          Filename


--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
)abbrev domain VIEW3D ThreeDimensionalViewport
++ Author: Jim Wen
++ Date Created: 28 April 1989
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: ThreeDimensionalViewport creates viewports to display graphs
VIEW    ==> _$ViewportServer$Lisp
sendI   ==> sockSendInt$Lisp
sendSF  ==> sockSendFloat$Lisp
sendSTR ==> sockSendString$Lisp
getI    ==> sockGetInt$Lisp
getSF   ==> sockGetFloat$Lisp

typeVIEW3D   ==> 1$I
typeVIEWTube ==> 4

makeVIEW3D ==> (-1)$SingleInteger

ThreeDimensionalViewport() : Exports == Implementation where
  I   ==> Integer
  PI  ==> PositiveInteger
  NNI ==> NonNegativeInteger
  XY  ==> Record( X : I, Y : I )
  XYP ==> Record( X : PI, Y : PI )
  XYNN ==> Record( X : NNI, Y : NNI )
  SF  ==> DoubleFloat
  F   ==> Float
  L   ==> List
  Pt ==> ColoredThreeDimensionalPoint
  SEG ==> Segment
  S   ==> String
  E   ==> OutputForm
  PLOT3D ==> Plot3D
  TUBE   ==> TubePlot
  V   ==> Record( theta : SF, phi : SF, scale : SF, scaleX : SF, scaleY : SF, scaleZ : SF, deltaX : SF, deltaY : SF )
  H   ==> Record( hueOffset : I, hueNumber : I)
  FLAG   ==> Record( showCP : I, style : I, axesOn : I, diagonalsOn : I, outlineRenderOn : I, showRegionField : I )
  FR  ==> Record( fn : Fn2, fc : FnU, xmin : SF, xmax : SF, ymin : SF, ymax : SF, xnum : I, ynum : I )
  FParamR ==> Record( theTube : TUBE )
  LR  ==> Record( lightX : SF, lightY : SF, lightZ : SF, lightTheta : SF, lightPhi : SF , translucence : SF)
  UFR ==> Union(FR,FParamR,"undefined")
  PR  ==> Record( perspectiveField : I, eyeDistance : SF, hitherPlane : SF)
  VR  ==> Record( clipXMin : SF, clipXMax : SF, clipYMin : SF, clipYMax : SF, clipZMin : SF, clipZMax : SF, clipRegionField : I, clipSurfaceField : I)
  C   ==> Color()
  B   ==> Boolean
  POINT ==> Point(SF)
  SUBSPACE ==> SubSpace(3, SF)
  SPACE3 ==> ThreeSpace(SF)
  DROP ==> DrawOption
  COORDSYS ==> CoordinateSystems(SF)
  DRAWFE ==> DrawFrontend()
  FET ==> Table(Symbol,String)


    -- the below macros correspond to the ones in include/actions.h
  ROTATE       ==> 0$I  -- rotate      in actions.h
  ZOOM         ==> 1$I  -- zoom        in actions.h
  TRANSLATE    ==> 2    -- translate   in actions.h
  rendered     ==> 3    -- render      in actions.h
  hideControl  ==> 4
  closeAll     ==> 5
  axesOnOff    ==> 6
  opaque       ==> 7    -- opaqueMesh  in action.h
  contour      ==> 24
  RESET        ==> 8
  wireMesh     ==> 9    -- transparent in actions.h
  region3D     ==> 12
  smooth       ==> 22
  diagOnOff    ==> 26
  outlineOnOff ==> 13
  zoomx        ==> 14
  zoomy        ==> 15
  zoomz        ==> 16
  perspectiveOnOff ==> 27
  clipRegionOnOff ==> 66
  clipSurfaceOnOff ==> 67

  SPADBUTTONPRESS ==> 100
  COLORDEF        ==> 101
  MOVE            ==> 102
  RESIZE          ==> 103
  TITLE           ==> 104
  lightDef        ==> 108
  translucenceDef ==> 109
  writeView       ==> 110
  eyeDistanceData ==> 111
  modifyPOINT     ==> 114
--  printViewport   ==> 115
  hitherPlaneData ==> 116
  queryVIEWPOINT  ==> 117
  changeVIEWPOINT ==> 118

  noControl ==> 0$I

  yes       ==> 1$I
  no        ==> 0$I

  EYED      ==> 500::SF  -- see draw.h, should be the same(?) as clipOffset
  HITHER    ==> (-250)::SF   -- see process.h in view3D/ (not yet passed to viewman)

  openTube  ==> 1$I
  closedTube ==> 0$I

  fun2Var3D  ==> "   Three Dimensional Viewport: Function of Two Variables"
  para1Var3D ==> "   Three Dimensional Viewport: Parametric Curve of One Variable"
  undef3D    ==> "   Three Dimensional Viewport: No function defined for this viewport yet"

  Exports ==> SetCategory with
    viewThetaDefault      : ()                                       -> F
      ++ viewThetaDefault() returns the current default longitudinal
      ++ view angle in radians.
    viewThetaDefault      : F                                        -> F
      ++ viewThetaDefault(t) sets the current default longitudinal
      ++ view angle in radians to the value t and returns t.
    viewPhiDefault        : ()                                       -> F
      ++ viewPhiDefault() returns the current default latitudinal
      ++ view angle in radians.
    viewPhiDefault        : F                                        -> F
      ++ viewPhiDefault(p) sets the current default latitudinal
      ++ view angle in radians to the value p and returns p.
    viewZoomDefault       : ()                                       -> F
      ++ viewZoomDefault() returns the current default graph scaling
      ++ value.
    viewZoomDefault       : F                                        -> F
      ++ viewZoomDefault(s) sets the current default graph scaling
      ++ value to s and returns s.
    viewDeltaXDefault     : ()                                       -> F
      ++ viewDeltaXDefault() returns the current default horizontal
      ++ offset from the center of the viewport window.
    viewDeltaXDefault     : F                                        -> F
      ++ viewDeltaXDefault(dx) sets the current default horizontal
      ++ offset from the center of the viewport window to be \spad{dx}
      ++ and returns \spad{dx}.
    viewDeltaYDefault     : ()                                       -> F
      ++ viewDeltaYDefault() returns the current default vertical
      ++ offset from the center of the viewport window.
    viewDeltaYDefault     : F                                        -> F
      ++ viewDeltaYDefault(dy) sets the current default vertical
      ++ offset from the center of the viewport window to be \spad{dy}
      ++ and returns \spad{dy}.
    viewport3D            : ()                                       -> %
      ++ viewport3D() returns an undefined three-dimensional viewport
      ++ of the domain \spadtype{ThreeDimensionalViewport} whose
      ++ contents are empty.
    makeViewport3D        : %                                        -> %
      ++ makeViewport3D(v) takes the given three-dimensional viewport,
      ++ v, of the domain \spadtype{ThreeDimensionalViewport} and
      ++ displays a viewport window on the screen which contains
      ++ the contents of v.
    makeViewport3D        : (SPACE3, S)                               -> %
      ++ makeViewport3D(sp, s) takes the given space, \spad{sp} which is
      ++ of the domain \spadtype{ThreeSpace} and displays a viewport
      ++ window on the screen which contains the contents of \spad{sp},
      ++ and whose title is given by s.
    makeViewport3D        : (SPACE3, L DROP)                          -> %
      ++ makeViewport3D(sp, lopt) takes the given space, \spad{sp} which is
      ++ of the domain \spadtype{ThreeSpace} and displays a viewport
      ++ window on the screen which contains the contents of \spad{sp},
      ++ and whose draw options are indicated by the list \spad{lopt}, which
      ++ is a list of options from the domain \spad{DrawOption}.
    subspace              : %                                        -> SPACE3
      ++ subspace(v) returns the contents of the viewport v, which is
      ++ of the domain \spadtype{ThreeDimensionalViewport}, as a subspace
      ++ of the domain \spad{ThreeSpace}.
    subspace              : (%, SPACE3)                               -> %
      ++ subspace(v, sp) places the contents of the viewport v, which is
      ++ of the domain \spadtype{ThreeDimensionalViewport}, in the subspace
      ++ \spad{sp}, which is of the domain \spad{ThreeSpace}.
    modifyPointData       : (%, NNI, POINT)                            -> Void
      ++ modifyPointData(v, ind, pt) takes the viewport, v, which is of the
      ++ domain \spadtype{ThreeDimensionalViewport}, and places the data
      ++ point, \spad{pt} into the list of points database of v at the index
      ++ location given by \spad{ind}.
    options               : %                                        -> L DROP
      ++ options(v) takes the viewport, v, which is of the domain
      ++ \spadtype{ThreeDimensionalViewport} and returns a list of all
      ++ the draw options from the domain \spad{DrawOption} which are
      ++ being used by v.
    options               : (%, L DROP)                               -> %
      ++ options(v, lopt) takes the viewport, v, which is of the domain
      ++ \spadtype{ThreeDimensionalViewport} and sets the draw options
      ++ being used by v to those indicated in the list, \spad{lopt},
      ++ which is a list of options from the domain \spad{DrawOption}.
    move                  : (%, NNI, NNI)                              -> Void
      ++ move(v, x, y) displays the three-dimensional viewport, v, which
      ++ is of domain \spadtype{ThreeDimensionalViewport}, with the upper
      ++ left-hand corner of the viewport window at the screen
      ++ coordinate position x, y.
    resize                : (%, PI, PI)                                -> Void
      ++ resize(v, w, h) displays the three-dimensional viewport, v, which
      ++ is of domain \spadtype{ThreeDimensionalViewport}, with a width
      ++ of w and a height of h, keeping the upper left-hand corner
      ++ position unchanged.
    title                 : (%, S)                                    -> Void
      ++ title(v, s) changes the title which is shown in the three-dimensional
      ++ viewport window, v of domain \spadtype{ThreeDimensionalViewport}.
    dimensions            : (%, NNI, NNI, PI, PI)                        -> Void
      ++ dimensions(v, x, y, width, height) sets the position of the
      ++ upper left-hand corner of the three-dimensional viewport, v,
      ++ which is of domain \spadtype{ThreeDimensionalViewport}, to
      ++ the window coordinate x, y, and sets the dimensions of the
      ++ window to that of \spad{width}, \spad{height}.  The new
      ++ dimensions are not displayed until the function
      ++ \spadfun{makeViewport3D} is executed again for v.
    viewpoint             : (%, F, F, F, F, F)                            -> Void
      ++ viewpoint(v, th, phi, s, dx, dy) sets the longitudinal view angle
      ++ to \spad{th} radians, the latitudinal view angle to \spad{phi}
      ++ radians, the scale factor to \spad{s}, the horizontal viewport
      ++ offset to \spad{dx}, and the vertical viewport offset to \spad{dy}
      ++ for the viewport v, which is of the domain
      ++ \spadtype{ThreeDimensionalViewport}.  The new viewpoint position
      ++ is not displayed until the function \spadfun{makeViewport3D} is
      ++ executed again for v.
    viewpoint             : (%)                                     -> V
      ++ viewpoint(v) returns the current viewpoint setting of the given
      ++ viewport, v.  This function is useful in the situation where the
      ++ user has created a viewport, proceeded to interact with it via
      ++ the control panel and desires to save the values of the viewpoint
      ++ as the default settings for another viewport to be created using
      ++ the system.
    viewpoint             : (%, V)                                    -> Void
      ++ viewpoint(v, viewpt) sets the viewpoint for the viewport.  The
      ++ viewport record consists of the latitudal and longitudal angles,
      ++ the zoom factor, the X, Y, and Z scales, and the X and Y displacements.
    viewpoint             : (%, I, I, F, F, F)                            -> Void
      ++ viewpoint(v, th, phi, s, dx, dy) sets the longitudinal view angle
      ++ to \spad{th} degrees, the latitudinal view angle to \spad{phi}
      ++ degrees, the scale factor to \spad{s}, the horizontal viewport
      ++ offset to \spad{dx}, and the vertical viewport offset to \spad{dy}
      ++ for the viewport v, which is of the domain
      ++ \spadtype{ThreeDimensionalViewport}.  The new viewpoint position
      ++ is not displayed until the function \spadfun{makeViewport3D} is
      ++ executed again for v.
    viewpoint             : (%, F, F)                                  -> Void
      ++ viewpoint(v, th, phi) sets the longitudinal view angle to \spad{th}
      ++ radians and the latitudinal view angle to \spad{phi} radians
      ++ for the viewport v, which is of the domain
      ++ \spadtype{ThreeDimensionalViewport}.  The new viewpoint position
      ++ is not displayed until the function \spadfun{makeViewport3D} is
      ++ executed again for v.
    viewpoint             : (%, F, F, F)                                -> Void
      ++ viewpoint(v, rotx, roty, rotz) sets the rotation about the x-axis
      ++ to be \spad{rotx} radians, sets the rotation about the y-axis
      ++ to be \spad{roty} radians, and sets the rotation about the z-axis
      ++ to be \spad{rotz} radians, for the viewport v, which is of the
      ++ domain \spadtype{ThreeDimensionalViewport} and displays v with
      ++ the new view position.
    controlPanel          : (%, S)                                    -> Void
      ++ controlPanel(v, s) displays the control panel of the given
      ++ three-dimensional viewport, v, which is of domain
      ++ \spadtype{ThreeDimensionalViewport}, if s is "on", or hides
      ++ the control panel if s is "off".
    axes                  : (%, S)                                    -> Void
      ++ axes(v, s) displays the axes of the given three-dimensional
      ++ viewport, v, which is of domain \spadtype{ThreeDimensionalViewport},
      ++ if s is "on", or does not display the axes if s is "off".
    diagonals             : (%, S)                                    -> Void
      ++ diagonals(v, s) displays the diagonals of the polygon outline
      ++ showing a triangularized surface instead of a quadrilateral
      ++ surface outline, for the given three-dimensional viewport v
      ++ which is of domain \spadtype{ThreeDimensionalViewport}, if s is
      ++ "on", or does not display the diagonals if s is "off".
    outlineRender         : (%, S)                                    -> Void
      ++ outlineRender(v, s) displays the polygon outline showing either
      ++ triangularized surface or a quadrilateral surface outline depending
      ++ on the whether the \spadfun{diagonals} function has been set, for
      ++ the given three-dimensional viewport v which is of domain
      ++ \spadtype{ThreeDimensionalViewport}, if s is "on", or does not
      ++ display the polygon outline if s is "off".
    drawStyle             : (%, S)                                    -> Void
      ++ drawStyle(v, s) displays the surface for the given three-dimensional
      ++ viewport v which is of domain \spadtype{ThreeDimensionalViewport}
      ++ in the style of drawing indicated by s.  If s is not a valid
      ++ drawing style the style is wireframe by default.  Possible
      ++ styles are \spad{"shade"}, \spad{"solid"} or \spad{"opaque"},
      ++ \spad{"smooth"}, and \spad{"wireMesh"}.
    rotate                : (%, F, F)                                  -> Void
      ++ rotate(v, th, phi) rotates the graph to the longitudinal view angle
      ++ \spad{th} radians and the latitudinal view angle \spad{phi} radians
      ++ for the viewport v, which is of the domain
      ++ \spadtype{ThreeDimensionalViewport}.
    rotate                : (%, I, I)                                  -> Void
      ++ rotate(v, th, phi) rotates the graph to the longitudinal view angle
      ++ \spad{th} degrees and the latitudinal view angle \spad{phi} degrees
      ++ for the viewport v, which is of the domain
      ++ \spadtype{ThreeDimensionalViewport}.  The new rotation position
      ++ is not displayed until the function \spadfun{makeViewport3D} is
      ++ executed again for v.
    zoom                  : (%, F)                                    -> Void
      ++ zoom(v, s) sets the graph scaling factor to s, for the viewport v,
      ++ which is of the domain \spadtype{ThreeDimensionalViewport}.
    zoom                  : (%, F, F, F)                                -> Void
      ++ zoom(v, sx, sy, sz) sets the graph scaling factors for the x-coordinate
      ++ axis to \spad{sx}, the y-coordinate axis to \spad{sy} and the
      ++ z-coordinate axis to \spad{sz} for the viewport v, which is of
      ++ the domain \spadtype{ThreeDimensionalViewport}.
    translate             : (%, F, F)                                  -> Void
      ++ translate(v, dx, dy) sets the horizontal viewport offset to \spad{dx}
      ++ and the vertical viewport offset to \spad{dy}, for the viewport v,
      ++ which is of the domain \spadtype{ThreeDimensionalViewport}.
    perspective           : (%, S)                                    -> Void
      ++ perspective(v,s) displays the graph in perspective if s is "on",
      ++ or does not display perspective if s is "off" for the given
      ++ three-dimensional viewport, v, which is of domain
      ++ \spadtype{ThreeDimensionalViewport}.
    eyeDistance           : (%, F)                                    -> Void
      ++ eyeDistance(v, d) sets the distance of the observer from the center
      ++ of the graph to d, for the viewport v, which is of the domain
      ++ \spadtype{ThreeDimensionalViewport}.
    hitherPlane           : (%, F)                                    -> Void
      ++ hitherPlane(v, h) sets the hither clipping plane of the graph to h,
      ++ for the viewport v, which is of the domain
      ++ \spadtype{ThreeDimensionalViewport}.
    showRegion            : (%, S)                                    -> Void
      ++ showRegion(v, s) displays the bounding box of the given
      ++ three-dimensional viewport, v, which is of domain
      ++ \spadtype{ThreeDimensionalViewport}, if s is "on", or does not
      ++ display the box if s is "off".
    showClipRegion        : (%, S)                                    -> Void
      ++ showClipRegion(v, s) displays the clipping region of the given
      ++ three-dimensional viewport, v, which is of domain
      ++ \spadtype{ThreeDimensionalViewport}, if s is "on", or does not
      ++ display the region if s is "off".
    clipSurface           : (%, S)                                    -> Void
      ++ clipSurface(v, s) displays the graph with the specified
      ++ clipping region removed if s is "on", or displays the graph
      ++ without clipping implemented if s is "off", for the given
      ++ three-dimensional viewport, v, which is of domain
      ++ \spadtype{ThreeDimensionalViewport}.
    lighting              : (%, F, F, F)                                -> Void
      ++ lighting(v, x, y, z) sets the position of the light source to
      ++ the coordinates x, y, and z and displays the graph for the given
      ++ three-dimensional viewport, v, which is of domain
      ++ \spadtype{ThreeDimensionalViewport}.
    intensity             : (%, F)                                    -> Void
      ++ intensity(v, i) sets the intensity of the light source to i, for
      ++ the given three-dimensional viewport, v, which is of domain
      ++ \spadtype{ThreeDimensionalViewport}.
    reset                 :  %                                       -> Void
      ++ reset(v) sets the current state of the graph characteristics
      ++ of the given three-dimensional viewport, v, which is of domain
      ++ \spadtype{ThreeDimensionalViewport}, back to their initial settings.
    colorDef              : (%, C, C)                                  -> Void
      ++ colorDef(v, c1, c2) sets the range of colors along the colormap so
      ++ that the lower end of the colormap is defined by \spad{c1} and the
      ++ top end of the colormap is defined by \spad{c2}, for the given
      ++ three-dimensional viewport, v, which is of domain
      ++ \spadtype{ThreeDimensionalViewport}.
    write                 : (%, S)                                    -> S
      ++ write(v, s) takes the given three-dimensional viewport, v, which
      ++ is of domain \spadtype{ThreeDimensionalViewport}, and creates
      ++ a directory indicated by s, which contains the graph data
      ++ file for v.
    write                 : (%, S, S)                                  -> S
      ++ write(v, s, f) takes the given three-dimensional viewport, v, which
      ++ is of domain \spadtype{ThreeDimensionalViewport}, and creates
      ++ a directory indicated by s, which contains the graph data
      ++ file for v and an optional file type f.
    write                 : (%, S, L S)                                -> S
      ++ write(v, s, lf) takes the given three-dimensional viewport, v, which
      ++ is of domain \spadtype{ThreeDimensionalViewport}, and creates
      ++ a directory indicated by s, which contains the graph data
      ++ file for v and the optional file types indicated by the list lf.
    close                 :  %                                       -> Void
      ++ close(v) closes the viewport window of the given
      ++ three-dimensional viewport, v, which is of domain
      ++ \spadtype{ThreeDimensionalViewport}, and terminates the
      ++ corresponding process ID.
    key                   :  %                                       -> I
      ++ key(v) returns the process ID number of the given three-dimensional
      ++ viewport, v, which is of domain \spadtype{ThreeDimensionalViewport}.
--    print                 :  %                                       -> Void
    setFrontend3D  : (FET) -> FET
      ++ Sets the frontend according to the values in the FET table.
    getFrontend3D  : () -> FET
      ++ Gets the FET table of the current frontend.
    makeFrontend3D : (%, FET) -> Void
      ++ Make frontend according to the values in the FET table.


  Implementation ==> add
    import from Color()
    import from ViewDefaultsPackage()
    import from Plot3D()
    import from TubePlot()
    import from POINT
    import from PointPackage(SF)
    import from SubSpaceComponentProperty()
    import from SPACE3
    import from MeshCreationRoutinesForThreeDimensions()
    import from DrawOptionFunctions0
    import from COORDSYS
    import from Set(PositiveInteger)
    import from DRAWFE

    Rep := Record (key : I, fun : I, _
                   title : S, moveTo : XYNN, size : XYP, viewpoint : V, colors : H, flags : FLAG, _
                   lighting : LR, perspective : PR, volume : VR, _
                   space3D : SPACE3, _
                   optionsField : L DROP)

    import from FLAG
    import from LR
    import from V
    import from PR
    import from VR

    degrees := pi()$F / 180.0
    degreesSF := pi()$SF / 180
    defaultTheta  : SF := convert(pi()$F/4.0)@SF
    defaultPhi    : SF := convert(-pi()$F/4.0)@SF
    defaultZoom   : SF := convert(1.2)@SF
    defaultDeltaX : SF := 0
    defaultDeltaY : SF := 0

    frontend:FET:=table()
    frontend.'type:="viewman"
    frontend.'output:=""
    frontend.'display:=""
    
--%Local Functions

    setFrontend3D(fe:FET):FET ==
      frontend:=copy(fe)
      
    getFrontend3D():FET == frontend

    makeFrontend3D(v:%, fe:FET):Void ==
      s1:SPACE3:=subspace(v)
      opts:List DROP:=options(v)
      createDraw3D(s1,opts,fe)


--%Local Functions
    checkViewport (viewport : %) : B ==
        -- checks to see if this viewport still exists
        -- by sending the key to the viewport manager and
        -- waiting for its reply after it checks it against
        -- the viewports in its list. a -1 means it doesn't
        -- exist.  As side effect selects the viewport for
        -- current operation.
      sendI(VIEW, viewport.key)
      i : Integer := getI(VIEW)
      (i < 0$I) =>
        viewport.key := 0$I
        error "This viewport has already been closed!"
      true

    doOptions(v : Rep) : Void ==
      v.title := title(v.optionsField,"FriCAS3D")
      st:S := style(v.optionsField, "render")
      if (st = "shade" or st = "render") then
        v.flags.style := rendered
      else if (st = "solid" or st = "opaque") then
        v.flags.style := opaque
      else if (st = "contour") then
        v.flags.style := contour
      else if (st = "smooth") then
        v.flags.style := smooth
      else if (st = "wireMesh") then
        v.flags.style := wireMesh
      else
        v.flags.style := rendered
      v.viewpoint := viewpoint(v.optionsField,
        [defaultTheta, defaultPhi, defaultZoom, _
          1$SF, 1$SF, 1$SF, defaultDeltaX, defaultDeltaY])
        -- etc - 3D specific stuff...

--%Exported Functions : Default Settings
    viewport3D() ==
      [0,typeVIEW3D,"FriCAS3D",[viewPosDefault().1,viewPosDefault().2], _
       [viewSizeDefault().1, viewSizeDefault().2], _
        [defaultTheta, defaultPhi, defaultZoom, _
          1$SF, 1$SF, 1$SF, defaultDeltaX, defaultDeltaY], _
        [0, 27], [noControl, rendered, yes, no, yes, no], _
        [0$SF, 0$SF, 1$SF, 0$SF, 0$SF, 1$SF], _
        [yes, EYED, HITHER], [0$SF, 1$SF, 0$SF, 1$SF, 0$SF, 1$SF, no, yes], _
                create3Space()$SPACE3, [] ]

    subspace viewport ==
      viewport.space3D

    subspace(viewport, space) ==
      viewport.space3D := space
      viewport

    options viewport ==
      viewport.optionsField

    options(viewport, opts) ==
      viewport.optionsField := opts
      viewport

    makeViewport3D0 : % -> %

    makeViewport3D viewport ==
      if frontend.'type = "vieman" then 
        makeViewport3D0 copy(viewport::Rep)
      else
        makeFrontend3D(viewport, getFrontend3D())
        viewport

    makeViewport3D(space : SPACE3, Title : S) : % ==
      v := viewport3D()
      v.space3D := space
      v.optionsField := [title(Title)]
      if frontend.'type = "vieman" then
        makeViewport3D0(v)
      else
        makeFrontend3D(v, getFrontend3D())
        v

    makeViewport3D(space : SPACE3, opts : L DROP) : % ==
      v := viewport3D()
      v.space3D := space
      v.optionsField := opts
      if frontend.'type = "vieman" then
        makeViewport3D0(v)
      else
        makeFrontend3D(v, getFrontend3D())
        v   


    makeViewport3D0 viewport ==
      doOptions viewport --local function to extract and assign optional arguments for 3D viewports
      say("   Transmitting data...")$DisplayPackage
      transform := coord(viewport.optionsField, cartesian$COORDSYS)$DrawOptionFunctions0
      check(viewport.space3D)
      lpts := lp(viewport.space3D)
      lllipts  := lllip(viewport.space3D)
      llprops := llprop(viewport.space3D)
      lprops  := lprop(viewport.space3D)
        -- check for dimensionality of points
        -- if they are all 4D points, then everything is okay
        -- if they are all 3D points, then pad an extra constant
        -- coordinate for color
        -- if they have varying dimensionalities, give an error
      s := empty()$Set(PI)
      for pt in lpts repeat
        insert!(dimension pt, s)
      #s > 1 => error "All points should have the same dimension"
      (n := first parts s) < 3 => error "Dimension of points should be greater than 2"
      sendI(VIEW, viewport.fun)
      sendI(VIEW, makeVIEW3D)
      sendSTR(VIEW, viewport.title)
      sendSF(VIEW, viewport.viewpoint.deltaX)
      sendSF(VIEW, viewport.viewpoint.deltaY)
      sendSF(VIEW, viewport.viewpoint.scale)
      sendSF(VIEW, viewport.viewpoint.scaleX)
      sendSF(VIEW, viewport.viewpoint.scaleY)
      sendSF(VIEW, viewport.viewpoint.scaleZ)
      sendSF(VIEW, viewport.viewpoint.theta)
      sendSF(VIEW, viewport.viewpoint.phi)
      sendI(VIEW, viewport.moveTo.X)
      sendI(VIEW, viewport.moveTo.Y)
      sendI(VIEW, viewport.size.X)
      sendI(VIEW, viewport.size.Y)
      sendI(VIEW, viewport.flags.showCP)
      sendI(VIEW, viewport.flags.style)
      sendI(VIEW, viewport.flags.axesOn)
      sendI(VIEW, viewport.flags.diagonalsOn)
      sendI(VIEW, viewport.flags.outlineRenderOn)
      sendI(VIEW, viewport.flags.showRegionField)  -- add to make3D.c
      sendI(VIEW, viewport.volume.clipRegionField)  -- add to make3D.c
      sendI(VIEW, viewport.volume.clipSurfaceField)  -- add to make3D.c
      sendI(VIEW, viewport.colors.hueOffset)
      sendI(VIEW, viewport.colors.hueNumber)
      sendSF(VIEW, viewport.lighting.lightX)
      sendSF(VIEW, viewport.lighting.lightY)
      sendSF(VIEW, viewport.lighting.lightZ)
      sendSF(VIEW, viewport.lighting.translucence)
      sendI(VIEW, viewport.perspective.perspectiveField)
      sendSF(VIEW, viewport.perspective.eyeDistance)
        -- new, crazy points domain stuff
          -- first, send the point data list
      sendI(VIEW, #lpts)
      for pt in lpts repeat
        aPoint := transform pt
        sendSF(VIEW, xCoord aPoint)
        sendSF(VIEW, yCoord aPoint)
        sendSF(VIEW, zCoord aPoint)
        n = 3 => sendSF(VIEW, zCoord aPoint)
        sendSF(VIEW, color aPoint)  -- change to c
          -- now, send the 3d subspace structure
      sendI(VIEW, #lllipts)
      for allipts in lllipts for oneprop in lprops for onelprops in llprops repeat
           -- the following is false for f(x, y) and user-defined for [x(t), y(t), z(t)]
           -- this is temporary - until the generalized points stuff gets put in
        sendI(VIEW, (closed? oneprop => yes; no))
        sendI(VIEW, (solid? oneprop => yes; no))
        sendI(VIEW, #allipts)
        for alipts in allipts for tinyprop in onelprops repeat
           -- the following is false for f(x, y) and true for [x(t), y(t), z(t)]
           -- this is temporary -- until the generalized points stuff gets put in
          sendI(VIEW, (closed? tinyprop => yes;no))
          sendI(VIEW, (solid? tinyprop => yes;no))
          sendI(VIEW, #alipts)
          for oneIndexedPoint in alipts repeat
            sendI(VIEW, oneIndexedPoint)
      viewport.key := getI(VIEW)
      viewport
         -- the key (now set to 0) should be what the viewport returns

    viewThetaDefault    == convert(defaultTheta)@F
    viewThetaDefault  t ==
      defaultTheta := convert(t)@SF
      t
    viewPhiDefault      == convert(defaultPhi)@F
    viewPhiDefault    t ==
      defaultPhi := convert(t)@SF
      t
    viewZoomDefault     == convert(defaultZoom)@F
    viewZoomDefault   t ==
      defaultZoom := convert(t)@SF
      t
    viewDeltaXDefault   == convert(defaultDeltaX)@F
    viewDeltaXDefault t ==
      defaultDeltaX := convert(t)@SF
      t
    viewDeltaYDefault   == convert(defaultDeltaY)@F
    viewDeltaYDefault t ==
      defaultDeltaY := convert(t)@SF
      t

--Exported Functions: Available features for 3D viewports
    lighting(viewport, Xlight, Ylight, Zlight) ==
      viewport.lighting.lightX := convert(Xlight)@SF
      viewport.lighting.lightY := convert(Ylight)@SF
      viewport.lighting.lightZ := convert(Zlight)@SF
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, lightDef)
        checkViewport viewport =>
          sendSF(VIEW, viewport.lighting.lightX)
          sendSF(VIEW, viewport.lighting.lightY)
          sendSF(VIEW, viewport.lighting.lightZ)
          getI(VIEW)          -- acknowledge

    axes (viewport, onOff) ==
      if onOff = "on" then viewport.flags.axesOn := yes
      else viewport.flags.axesOn := no
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, axesOnOff)
        checkViewport viewport =>
          sendI(VIEW, viewport.flags.axesOn)
          getI(VIEW)          -- acknowledge

    diagonals (viewport, onOff) ==
      if onOff = "on" then viewport.flags.diagonalsOn := yes
      else viewport.flags.diagonalsOn := no
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, diagOnOff)
        checkViewport viewport =>
          sendI(VIEW, viewport.flags.diagonalsOn)
          getI(VIEW)          -- acknowledge

    outlineRender (viewport, onOff) ==
      if onOff = "on" then viewport.flags.outlineRenderOn := yes
      else viewport.flags.outlineRenderOn := no
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, outlineOnOff)
        checkViewport viewport =>
          sendI(VIEW, viewport.flags.outlineRenderOn)
          getI(VIEW)          -- acknowledge

    controlPanel (viewport, onOff) ==
      if onOff = "on" then viewport.flags.showCP := yes
      else viewport.flags.showCP := no
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, hideControl)
        checkViewport viewport =>
          sendI(VIEW, viewport.flags.showCP)
          getI(VIEW)          -- acknowledge

    drawStyle (viewport, how) ==
      if (how = "shade") then                    -- render
        viewport.flags.style := rendered
      else if (how = "solid") then               -- opaque
        viewport.flags.style := opaque
      else if (how = "contour") then             -- contour
        viewport.flags.style := contour
      else if (how = "smooth") then              -- smooth
        viewport.flags.style := smooth
      else viewport.flags.style := wireMesh
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, viewport.flags.style)
        checkViewport viewport =>
          getI(VIEW)          -- acknowledge

    reset viewport ==
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, SPADBUTTONPRESS)
        checkViewport viewport =>
          sendI(VIEW, RESET)
          getI(VIEW)          -- acknowledge
      void()

    close viewport ==
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, closeAll)
        checkViewport viewport =>
          getI(VIEW)          -- acknowledge
          viewport.key := 0$I
      void()

    viewpoint (viewport : %) : V ==
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, queryVIEWPOINT)
        checkViewport viewport =>
          deltaX_sf : SF := getSF(VIEW)
          deltaY_sf : SF := getSF(VIEW)
          scale_sf  : SF := getSF(VIEW)
          scaleX_sf : SF := getSF(VIEW)
          scaleY_sf : SF := getSF(VIEW)
          scaleZ_sf : SF := getSF(VIEW)
          theta_sf  : SF := getSF(VIEW)
          phi_sf    : SF := getSF(VIEW)
          getI(VIEW)          -- acknowledge
          viewport.viewpoint :=
            [ theta_sf, phi_sf, scale_sf, scaleX_sf, scaleY_sf, scaleZ_sf,
              deltaX_sf, deltaY_sf ]
        viewport.viewpoint
      viewport.viewpoint

    viewpoint (viewport : %, viewpt : V) : Void ==
      viewport.viewpoint := viewpt
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, changeVIEWPOINT)
        checkViewport viewport =>
          sendSF(VIEW, viewport.viewpoint.deltaX)
          sendSF(VIEW, viewport.viewpoint.deltaY)
          sendSF(VIEW, viewport.viewpoint.scale)
          sendSF(VIEW, viewport.viewpoint.scaleX)
          sendSF(VIEW, viewport.viewpoint.scaleY)
          sendSF(VIEW, viewport.viewpoint.scaleZ)
          sendSF(VIEW, viewport.viewpoint.theta)
          sendSF(VIEW, viewport.viewpoint.phi)
          getI(VIEW)          -- acknowledge


    viewpoint (viewport : %, Theta : F, Phi : F, Scale : F, DeltaX : F, DeltaY : F) : Void ==
      viewport.viewpoint :=
        [convert(Theta)@SF, convert(Phi)@SF, convert(Scale)@SF, 1$SF, 1$SF, 1$SF, convert(DeltaX)@SF, convert(DeltaY)@SF]

    viewpoint (viewport : %, Theta : I, Phi : I, Scale : F, DeltaX : F, DeltaY : F) : Void ==
      viewport.viewpoint := [convert(Theta)@SF * degreesSF, convert(Phi)@SF * degreesSF,
        convert(Scale)@SF, 1$SF, 1$SF, 1$SF, convert(DeltaX)@SF, convert(DeltaY)@SF]

    viewpoint (viewport : %, Theta : F, Phi : F) : Void ==
      viewport.viewpoint.theta := convert(Theta)@SF
      viewport.viewpoint.phi   := convert(Phi)@SF

    viewpoint (viewport : %, X : F, Y : F, Z : F) : Void ==
      Theta : F
      Phi : F
      if (X = 0$F) and (Y = 0$F) then
        Theta := 0$F
        if (Z>=0$F) then
          Phi := 0$F
        else
          Phi := pi()
      else
        Theta := asin(Y/(R := sqrt(X*X+Y*Y)))
        if (Z = 0$F) then
          Phi := pi()/(2::F)
        else
          Phi := atan(Z/R)
      rotate(viewport, Theta, Phi)

    title (viewport, Title) ==
      viewport.title := Title
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, TITLE)
        checkViewport viewport =>
          sendSTR(VIEW, Title)
          getI(VIEW)          -- acknowledge

    colorDef (viewport, HueOffset, HueNumber) ==
      viewport.colors := [h := (hue HueOffset), (hue HueNumber) - h]
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, COLORDEF)
        checkViewport viewport =>
          sendI(VIEW, hue HueOffset)
          sendI(VIEW, hue HueNumber)
          getI(VIEW)          -- acknowledge

    dimensions (viewport, ViewX, ViewY, ViewWidth, ViewHeight) ==
      viewport.moveTo := [ViewX, ViewY]
      viewport.size   := [ViewWidth, ViewHeight]

    move(viewport, xLoc, yLoc) ==
      viewport.moveTo := [xLoc, yLoc]
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, MOVE)
        checkViewport viewport =>
          sendI(VIEW, xLoc)
          sendI(VIEW, yLoc)
          getI(VIEW)          -- acknowledge

    resize(viewport, xSize, ySize) ==
      viewport.size := [xSize, ySize]
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, RESIZE)
        checkViewport viewport =>
          sendI(VIEW, xSize)
          sendI(VIEW, ySize)
          getI(VIEW)          -- acknowledge

    coerce viewport ==
      (key(viewport) = 0$I) =>
        hconcat
          [message("Closed or Undefined ThreeDimensionalViewport: "),
           (viewport.title)::E]
      hconcat [message("ThreeDimensionalViewport: "), (viewport.title)::E]

    key viewport == viewport.key

    rotate(viewport : %, Theta : I, Phi : I) ==
      rotate(viewport, Theta::F * degrees, Phi::F * degrees)

    rotate(viewport : %, Theta : F, Phi : F) ==
      viewport.viewpoint.theta := convert(Theta)@SF
      viewport.viewpoint.phi   := convert(Phi)@SF
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, ROTATE)
        checkViewport viewport =>
          sendSF(VIEW, viewport.viewpoint.theta)
          sendSF(VIEW, viewport.viewpoint.phi)
          getI(VIEW)          -- acknowledge

    zoom(viewport : %, Scale : F) ==
      viewport.viewpoint.scale := convert(Scale)@SF
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, ZOOM)
        checkViewport viewport =>
          sendSF(VIEW, viewport.viewpoint.scale)
          getI(VIEW)          -- acknowledge

    zoom(viewport : %, ScaleX : F, ScaleY : F, ScaleZ : F) ==
      viewport.viewpoint.scaleX := convert(ScaleX)@SF
      viewport.viewpoint.scaleY := convert(ScaleY)@SF
      viewport.viewpoint.scaleZ := convert(ScaleZ)@SF
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, zoomx)
        checkViewport viewport =>
          sendSF(VIEW, viewport.viewpoint.scaleX)
          sendSF(VIEW, viewport.viewpoint.scaleY)
          sendSF(VIEW, viewport.viewpoint.scaleZ)
          getI(VIEW)          -- acknowledge

    translate(viewport, DeltaX, DeltaY) ==
      viewport.viewpoint.deltaX := convert(DeltaX)@SF
      viewport.viewpoint.deltaY := convert(DeltaY)@SF
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, TRANSLATE)
        checkViewport viewport =>
          sendSF(VIEW, viewport.viewpoint.deltaX)
          sendSF(VIEW, viewport.viewpoint.deltaY)
          getI(VIEW)          -- acknowledge

    intensity(viewport, Amount) ==
      if (Amount < 0$F) or (Amount > 1$F) then
        error "The intensity must be a value between 0 and 1, inclusively."
      viewport.lighting.translucence := convert(Amount)@SF
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, translucenceDef)
        checkViewport viewport =>
          sendSF(VIEW, viewport.lighting.translucence)
          getI(VIEW)          -- acknowledge

    write(viewport : %, Filename : S, aThingToWrite : S) ==
      write(viewport, Filename, [aThingToWrite])

    write(viewport, Filename) ==
      write(viewport, Filename, viewWriteDefault())

    write(viewport : %, Filename : S, thingsToWrite : L S) ==
      stringToSend : S := ""
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, writeView)
        checkViewport viewport =>
          sendSTR(VIEW, Filename)
          m := minIndex(avail := viewWriteAvailable())
          for aTypeOfFile in thingsToWrite repeat
            if (writeTypeInt:= position(upperCase aTypeOfFile, avail)-m) < 0 then
              say(["  > ", aTypeOfFile,
                " is not a valid file type for writing a 3D viewport"
                       ])$DisplayPackage
            else
              sendI(VIEW, writeTypeInt + 1$I)
          sendI(VIEW, 0$I)     -- no more types of things to write
          getI(VIEW)          -- acknowledge
          Filename

    perspective (viewport, onOff) ==
      if onOff = "on" then viewport.perspective.perspectiveField := yes
      else viewport.perspective.perspectiveField := no
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, perspectiveOnOff)
        checkViewport viewport =>
          sendI(VIEW, viewport.perspective.perspectiveField)
          getI(VIEW)          -- acknowledge

    showRegion (viewport, onOff) ==
      if onOff = "on" then viewport.flags.showRegionField := yes
      else viewport.flags.showRegionField := no
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, region3D)
        checkViewport viewport =>
          sendI(VIEW, viewport.flags.showRegionField)
          getI(VIEW)          -- acknowledge

    showClipRegion (viewport, onOff) ==
      if onOff = "on" then viewport.volume.clipRegionField := yes
      else viewport.volume.clipRegionField := no
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, clipRegionOnOff)
        checkViewport viewport =>
          sendI(VIEW, viewport.volume.clipRegionField)
          getI(VIEW)          -- acknowledge

    clipSurface (viewport, onOff) ==
      if onOff = "on" then viewport.volume.clipSurfaceField := yes
      else viewport.volume.clipSurfaceField := no
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, clipSurfaceOnOff)
        checkViewport viewport =>
          sendI(VIEW, viewport.volume.clipSurfaceField)
          getI(VIEW)          -- acknowledge

    eyeDistance(viewport : %, EyeDistance : F) ==
      viewport.perspective.eyeDistance := convert(EyeDistance)@SF
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, eyeDistanceData)
        checkViewport viewport =>
          sendSF(VIEW, viewport.perspective.eyeDistance)
          getI(VIEW)          -- acknowledge

    hitherPlane(viewport : %, HitherPlane : F) ==
      viewport.perspective.hitherPlane := convert(HitherPlane)@SF
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, hitherPlaneData)
        checkViewport viewport =>
          sendSF(VIEW, viewport.perspective.hitherPlane)
          getI(VIEW)          -- acknowledge

    modifyPointData(viewport, anIndex, aPoint) ==
      (n := dimension aPoint) < 3 => error "The point should have dimension of at least 3"
      viewport.space3D := modifyPointData(viewport.space3D, anIndex, aPoint)
      (key(viewport) ~= 0$I) =>
        sendI(VIEW, typeVIEW3D)
        sendI(VIEW, modifyPOINT)
        checkViewport viewport =>
          sendI(VIEW, anIndex)
          sendSF(VIEW, xCoord aPoint)
          sendSF(VIEW, yCoord aPoint)
          sendSF(VIEW, zCoord aPoint)
          if (n = 3) then sendSF(VIEW, convert(0.5)@SF)
          else sendSF(VIEW, color aPoint)
          getI(VIEW)          -- acknowledge

--    print viewport ==
--      (key(viewport) ~= 0$I) =>
--        sendI(VIEW, typeVIEW3D)
--        sendI(VIEW, printViewport)
--        checkViewport viewport =>
--          getI(VIEW)          -- acknowledge

--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-- this is a new graphics package and does not depend on any of the
-- current plotting stuff
-- so it is best to run it in a minimum system (like spadsys)
