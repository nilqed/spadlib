)abbrev package GEOMV Geomview
Geomview() : Exports == Implementation where

  MSC ==> MoreSystemCommands
  STR ==> String
  INT ==> Integer
  LLI ==> List List Integer
  LLS ==> List List String
  LLF ==> List List Float
  LI  ==> List Integer
  LS  ==> List String
  LF  ==> List Float
  FL  ==> Float
  
  COLOR ==> Record(red:FL,green:FL,blue:FL,transparency:FL)
  POINT ==> Record(X:FL,Y:FL,Z:FL,color:COLOR,diam:INT)
  PLINE ==> Record(vertices:List POINT,color:COLOR,diam:INT)

  Exports == with

    lisp : String -> SExpression
    ++ lisp(s) reads the string s and evaluates in Lisp.
    makePipe : String -> String
    quitPipe : String -> Void
    writePipe : (String,String) -> Void
    mkPtsFmt: (STR,INT,LLS,LLS) -> STR
      ++ mkPtsFmt(name,diam,lp,lc) creates a OOGL VECT object comprising
      ++ points only. The parameters are: name (arbitrary identifier), diam
      ++ the diameter of the points (e.g. 10), lp a list of lists of floats
      ++ as strings, and lc a list of lists of floats as strings, representing 
      ++ the color of each point as r,g,b and transparency.[low-level].
    drawPoint: (STR,STR,POINT) -> Void 
      ++ drawPoint(p,n,pt) draws the point 'pt' named 'n' to the pipe 'p'.
    drawPolyLine: (STR,STR,PLINE,Boolean) -> Void 
      ++ drawPolyLine(p,n,pl,closed?) draws the polyline 'pl' named 'n' to the 
      ++ pipe 'p'. Set the parameter closed?=true if the polyline shall be 
      ++ closed.
    load: (STR,STR) -> Void
      ++ load(pipe,file) loads the given file into geomview (pipe). 
    load: (STR,STR,STR) -> Void  
      ++ Loads the given file into geomview (pipe). The third argument 
      ++ specifies the type of data it contains, which may be 'command' 
      ++ (geomview commands), 'geometry' (OOGL geometric data), or 'camera' 
      ++ (OOGL camera definition). If omitted, attempts to guess about the 
      ++ file's contents. Loading geometric data creates a new visible object; 
      ++ loading a camera opens a new window; loading a command file executes 
      ++ those commands.
    loadPath : STR -> Void
      ++ loadPath(pipe) returns the current search path for command, geometry, 
      ++ etc. files. 
    setLoadPath: (STR,LS) -> Void
      ++ setLoadPath(pipe,[path1,...,pathN]) Sets search path for command, 
      ++ geometry, etc. files. The PATHi are strings giving the pathnames of 
      ++ directories to be searched. The special directory name + is replaced 
      ++ by the existing path, so e.g. setLoadPath(p,["mydir","+"]) prepends 
      ++ mydir to the path.
    help: (STR,STR) -> Void
      ++ help(pipe,cmd) prints info about cmd. Command may include * wildcards.
      ++ For instance, help(pipe,"*") prints all commands.
    scale : (STR,STR,Float) -> Void
      ++ scale(pipe,GEOM-ID,factor) scales GEOM-ID, multiplying its size by 
      ++ factor.
    scale : (STR,STR,Float,Float,Float) -> Void
      ++ scale(pipe,GEOM-ID,fx,fy,fz) scales GEOM-ID, multiplying its size by 
      ++ fx,fy,fz. Scaling only really makes sense in Euclidean space!
      

      
    
     
  Implementation == add 
  
    lisp(s) == EVAL(READ_-FROM_-STRING(s)$Lisp)$Lisp
    
    makePipe(s) == 
      cmd:SExpression:=FORMAT('NIL,"system togeomview ~A </dev/null",s)$Lisp 
      systemCommand(string cmd)$MSC
      if null? PROBE_-FILE("/tmp/geomview/" s)$Lisp then
        error string FORMAT('NIL,"Could not create pipe ~A",s)$Lisp
      else
        FORMAT('T,"Pipe /tmp/geomview/~a created. ~%",s)$Lisp
        return s
      
    quitPipe(s) == 
      tp:=string FORMAT('NIL,"/tmp/geomview/~a",s)$Lisp 
      cmd:SExpression:=FORMAT('NIL,"system echo '(quit)' > ~A",tp)$Lisp     
      systemCommand(string cmd)$MSC
      
    writePipe(p,c):Void ==
      tp:=string FORMAT('NIL,"/tmp/geomview/~a",p)$Lisp 
      cmd:SExpression:=FORMAT('NIL,"system printf '~A' > ~A",c,tp)$Lisp
      systemCommand(string cmd)$MSC
    

    fmtPtsHead:="(progn (new-geometry _"[~A]_" appearance {linewidth ~A}"
    fmtPtsA:="~A ~% VECT ~A ~A ~A~%~{~A ~}~%~{~A ~}~%"  -- intro 
    fmtPtsB:="~{~{~A ~}~%~}~%~{~{~A ~}~%~})~%~A)"       -- data
    fmtPts:=concat(fmtPtsA,fmtPtsB)$String
    fmtPtsTail:="(normalization _"World_" none)"
    
    
    mkPtsFmt(name:STR,diam:INT,p:LLS,c:LLS):STR ==
      nL:INT:=#p
      nV:=nL
      nC:=#c
      lv:=[1 for i in 1..nL]
      lc:=[1 for i in 1..nC]
      f1:=string FORMAT('NIL,fmtPtsHead,name,diam)$Lisp
      f2:=string FORMAT('NIL,fmtPts,f1,nL,nV,nC,lv,lc,p,c,fmtPtsTail)$Lisp


    drawPoint(pipe:STR,name:STR,data:POINT):Void ==
      p:List Float:=[data.X,data.Y,data.Z]
      c:COLOR:=data.color
      cl:List Float:=[c.red,c.green,c.blue,c.transparency]
      lv:LLS:=[[toString(s) for s in p]]
      lc:LLS:=[[toString(s) for s in cl]]
      mp:=mkPtsFmt(name,data.diam,lv,lc)
      writePipe(pipe,mp)
      
    drawPolyLine(pipe:STR,name:STR,data:PLINE,closed:Boolean):Void ==
      v:List POINT:=data.vertices
      c:COLOR:=data.color
      cl:List Float:=[c.red,c.green,c.blue,c.transparency]
      lf:LF:=concat [[s.X,s.Y,s.Z] for s in v]
      llv:LLS:=[[toString(s) for s in lf]]
      llc:LLS:=[[toString(s) for s in cl]]
      nL:INT:=1
      nV:INT:=#v
      nC:INT:=1
      lv:LI
      if closed then lv:=[-nV] else lv:=[nV]
      lc:LI:=[1]
      f1:=string FORMAT('NIL,fmtPtsHead,name,data.diam)$Lisp
      f2:=string FORMAT('NIL,fmtPts,f1,nL,nV,nC,lv,lc,llv,llc,fmtPtsTail)$Lisp
      --output(f2)$OutputPackage
      writePipe(pipe,f2)

    load(p:STR,f:STR):Void ==
      cmd:=string FORMAT('NIL,"(load ~A)",f)$Lisp
      writePipe(p,cmd)
      
    load(p:STR,f:STR,opt:STR):Void ==
      o:List String:=["command","geometry","camera"]
      not member?(opt,o) => error "options are: [command|geometry|camera])"
      cmd:=string FORMAT('NIL,"(load ~A ~A)",f,opt)$Lisp
      writePipe(p,cmd)
      
    loadPath(p:STR):Void ==
      cmd:="(echo (load-path))"
      writePipe(p,cmd)
      
    setLoadPath(p:STR,paths:LS) ==
      cmd:=string FORMAT('NIL,"(set-load-path ~A)",paths)$Lisp
      writePipe(p,cmd)

    help(p:STR,c:STR):Void ==
      cmd:=string FORMAT('NIL,"(morehelp ~A)",c)$Lisp
      writePipe(p,cmd)
      
    scale(p:STR,g:STR,f:Float):Void ==
      fs:STR:=toString(f)
      cmd:=string FORMAT('NIL,"(scale ~A ~A)",g,fs)$Lisp
      writePipe(p,cmd)
      
    scale(p:STR,g:STR,fx:Float,fy:Float,fz:Float):Void ==
      sx:STR:=toString(fx); sy:STR:=toString(fy); sz:STR:=toString(fz);  
      cmd:=string FORMAT('NIL,"(scale ~A ~A ~A ~A)",g,sx,sy,sz)$Lisp
      writePipe(p,cmd)