)abbrev package GEOMV Geomview
Geomview() : Exports == Implementation where

  MSC ==> MoreSystemCommands
  STR ==> String
  INT ==> Integer
  LLI ==> List List Integer
  LLS ==> List List String
  LLF ==> List List Float
  LI  ==> List Integer
  LS  ==> List String
  LF  ==> List Float
  FL  ==> Float
  
  COLOR ==> Record(red:FL,green:FL,blue:FL,transparency:FL)
  POINT ==> Record(X:FL,Y:FL,Z:FL,color:COLOR,diam:INT)
  PLINE ==> Record(vertices:List POINT,color:COLOR,diam:INT)

  Exports == with

    lisp : String -> SExpression
    ++ lisp(s) reads the string s and evaluates in Lisp.
    makePipe : String -> String
    quitPipe : String -> Void
    writePipe : (String,String) -> Void
    mkPtsFmt: (STR,INT,LLS,LLS) -> STR
      ++ mkPtsFmt(name,diam,lp,lc) creates a OOGL VECT object comprising
      ++ points only. The parameters are: name (arbitrary identifier), diam
      ++ the diameter of the points (e.g. 10), lp a list of lists of floats
      ++ as strings, and lc a list of lists of floats as strings, representing 
      ++ the color of each point as r,g,b and transparency.[low-level].
    drawPoint: (STR,STR,POINT) -> Void 
      ++ drawPoint(p,n,pt) draws the point 'pt' named 'n' to the pipe 'p'.
    drawPolyLine: (STR,STR,PLINE,Boolean) -> Void 
      ++ drawPolyLine(p,n,pl,closed?) draws the polyline 'pl' named 'n' to the 
      ++ pipe 'p'. The parameter closed? is true if the polyline shall be 
      ++ closed.
     
  Implementation == add 
  
    lisp(s) == EVAL(READ_-FROM_-STRING(s)$Lisp)$Lisp
    
    makePipe(s) == 
      cmd:SExpression:=FORMAT('NIL,"system togeomview ~A </dev/null",s)$Lisp 
      systemCommand(string cmd)$MSC
      if null? PROBE_-FILE("/tmp/geomview/" s)$Lisp then
        error string FORMAT('NIL,"Could not create pipe ~A",s)$Lisp
      else
        FORMAT('T,"Pipe /tmp/geomview/~a created. ~%",s)$Lisp
        return s
      
    quitPipe(s) == 
      tp:=string FORMAT('NIL,"/tmp/geomview/~a",s)$Lisp 
      cmd:SExpression:=FORMAT('NIL,"system echo '(quit)' > ~A",tp)$Lisp     
      systemCommand(string cmd)$MSC
      
    writePipe(p,c):Void ==
      tp:=string FORMAT('NIL,"/tmp/geomview/~a",p)$Lisp 
      cmd:SExpression:=FORMAT('NIL,"system printf '~A' > ~A",c,tp)$Lisp
      systemCommand(string cmd)$MSC
    

    fmtPtsHead:="(progn (new-geometry _"[~A]_" appearance {linewidth ~A}"
    fmtPtsA:="~A ~% VECT ~A ~A ~A~%~{~A ~}~%~{~A ~}~%"  -- intro 
    fmtPtsB:="~{~{~A ~}~%~}~%~{~{~A ~}~%~})~%~A)"       -- data
    fmtPts:=concat(fmtPtsA,fmtPtsB)$String
    fmtPtsTail:="(normalization _"World_" none)"
    
    
    mkPtsFmt(name:STR,diam:INT,p:LLS,c:LLS):STR ==
      nL:INT:=#p
      nV:=nL
      nC:=#c
      lv:=[1 for i in 1..nL]
      lc:=[1 for i in 1..nC]
      f1:=string FORMAT('NIL,fmtPtsHead,name,diam)$Lisp
      f2:=string FORMAT('NIL,fmtPts,f1,nL,nV,nC,lv,lc,p,c,fmtPtsTail)$Lisp


    drawPoint(pipe:STR,name:STR,data:POINT):Void ==
      p:List Float:=[data.X,data.Y,data.Z]
      c:COLOR:=data.color
      cl:List Float:=[c.red,c.green,c.blue,c.transparency]
      lv:LLS:=[[toString(s) for s in p]]
      lc:LLS:=[[toString(s) for s in cl]]
      mp:=mkPtsFmt(name,data.diam,lv,lc)
      writePipe(pipe,mp)
      
    drawPolyLine(pipe:STR,name:STR,data:PLINE,closed:Boolean):Void ==
      v:List POINT:=data.vertices
      c:COLOR:=data.color
      cl:List Float:=[c.red,c.green,c.blue,c.transparency]
      lf:LF:=concat [[s.X,s.Y,s.Z] for s in v]
      llv:LLS:=[[toString(s) for s in lf]]
      llc:LLS:=[[toString(s) for s in cl]]
      nL:INT:=1
      nV:INT:=#v
      nC:INT:=1
      lv:LI
      if closed then lv:=[-nV] else lv:=[nV]
      lc:LI:=[1]
      f1:=string FORMAT('NIL,fmtPtsHead,name,data.diam)$Lisp
      f2:=string FORMAT('NIL,fmtPts,f1,nL,nV,nC,lv,lc,llv,llc,fmtPtsTail)$Lisp
      --output(f2)$OutputPackage
      writePipe(pipe,f2)

