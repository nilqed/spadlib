)abbrev package GLE GraphicsLayoutEngine
++ Author: Kurt Pagani
++ Date Created: Mon Aug 06 18:17:40 CEST 2018
++ Date Revised: Do 24 Okt 2024 19:54:57 CEST
++ License: BSD
++ References: 
++ * <a href="https://glx.sourceforge.io/index.html">GLE home</a>
++ * <a href="https://glx.sourceforge.io/main/docs.html">GLE docs</a>
++ * <a href="https://glx.sourceforge.io/downloads/downloads.html">get GLE</a>
++ * <a href="https://en.wikipedia.org/wiki/Graphics_Layout_Engine">GLE@WP</a>
++   January 2022: GLE is now on GitHub and utilizing cmake to build 
++     from source: <a href="https://github.com/vlabella/GLE">GLE@GitHub</a>
++ Description:
++   GLE - Graphics Layout Engine
++   Debian: sudo apt install gle-graphics  (ghostscript,...)
++ Builds on PLOT, PLOT3D domains besides other constructs.
++ <strong>PlotSupport eliminated</strong>.
++
++ A) By now there are two graphic objects GRAPH and SURFACE which
++    are represented as records. 
++ B) Instances of these objects are created by graph() and surface()
++    which will be used by the plot and push functions.
++ C) Those instances contain the generated GLE*.dat or GLE*.z file
++    respectively. At this point the graphics file GLE*.gle is not
++    created yet, so that the instances may be still manipulated,
++    however, the filename (only) is already created and stored.
++ D) The "create" function will generate the final GLE*.gle file, so
++    that the object can be displayed (QGLE) or transformed to one of
++    the available formats (gle -help device):
++    Option: -device
++      Abbreviation(s): -d
++      Selects output device(s)
++      Argument 'device-names': set output device(s)
++    Possible values: eps, ps, pdf, svg, jpg, png
++ E) The instances may be further processed and redisplayed etc.
++ The (*) in GLE*.[gle,dat,z] is the GET-UNIVERSAL-TIME from LISP.
++ Example:
++   l1:=[[x,sin x,cos x] for x in [n*0.1::DoubleFloat for n in 1..10]]
++        Type: List(List(DoubleFloat))
++   g1:=plot l1  --> returns a GRAPH object 
++        getPath g1.glefile -> NIL
++   display g1 --> shows the graph g1 in QGLE 
++        getPath g1.glefile -> /home/.../GLE3938789612.gle
++   g1.title := "sin/cos"
++        set a title (default is "Title")
++   runGLE(g1.glefile,"eps","") --> produces a "GLE*.eps".
++ One may combine of course, e.g. display plot l1 ...
++
GraphicsLayoutEngine : Exports == Implementation where

  MSC   ==> MoreSystemCommands
  STR   ==> String
  INT   ==> Integer
  LDF   ==> List DoubleFloat
  LLDF  ==> List LDF
  LSTR  ==> List STR
  LLSTR ==> List LSTR
  PI    ==> PositiveInteger
  DF    ==> DoubleFloat
  PDF   ==> Point DF
  XDF   ==> Expression DF
  SDF   ==> Segment DF
  SBDF  ==> SegmentBinding DF
  CTDF  ==> ConvertibleTo DoubleFloat
  NUMS  ==> Union(DoubleFloat,Float,Integer,Fraction Integer)
  SBNS  ==> SegmentBinding NUMS
  EXPZ  ==> Expression Integer
  
  
  GRAPH ==> Record(glefile:STR, pre:STR, xsize:STR, ysize:STR, xtitle:STR,_
                   ytitle:STR, title:STR, data:STR, cmds:LSTR)

  ZFILE ==> Record(data:LLDF,nx:INT,ny:INT,xmin:DF,xmax:DF,_
                   ymin:DF,ymax:DF)

  SURFACE ==> Record(glefile:STR, pre:STR, xsize:STR, ysize:STR, xtitle:STR,_
                   ytitle:STR, ztitle:STR, title:STR, data:STR, cmds:LSTR)
  
  sys(s) ==> systemCommand(s)$MoreSystemCommands

  Exports == with
  
    convert : (PDF, String) -> String
      ++ convert(P,sep) converts a point P to a string of 'sep' separated
      ++ double floats. Example: P:=convert([1.0,2.0,3.0,4.5])$Point(DF),
      ++ then convert(P," ") => "1.0 2.0 3.0 4.5". 
    convertBranch : (List PDF, String) -> LSTR
      ++ convertBranch(p,sep) converts a list of points to a list of 
      ++ strings. Each string corresponds to a point. The 'sep' string
      ++ separates each coordinate (e.g. blank, comma, semicolon etc.)
    convert : (Plot, String) -> LLSTR
      ++ convert(p,sep) converts a PLOT to a list of lists of strings. For
      ++ each branch a list of strings (of 'sep' double floats) will be
      ++ generated.
    combineBranches : Plot -> List PDF 
      ++ combineBranches(p) combines all branches in a Plot such that
      ++ the first column are the common x-values and all other columns
      ++ represent the y-values. That is all branches must have the same
      ++ xRange and therefore the same number of points.
    createDataFile : (FileName, LSTR) -> Void
	  ++ createDataFile(fn,data) creates and writes the list of strings (data) 
	  ++ to the file named 'fn'.
    numOfBranches : Plot -> Integer
	  ++ numOfBranches(p) returns the number of branches in the Plot p.
      ++ (-) PlotSupport ------------------------------------------
    format : (STR,STR) -> STR
      ++ format("CL format string","string to format") returns a
      ++ formatted string (like FORMAT('NIL,fmt,r)$Lisp)
    format : (STR,List STR) -> STR
      ++ format("CL format string",["strings to format"])
    graph  : () -> GRAPH 
      ++ graph() will create a new instance of a GRAPH object. This
      ++ object may be filled with gle commands and parameterized.
      ++ Note that nothing will be performed before 'create'.
    create : GRAPH -> FileName
      ++ create(g) will actually create the graph object, i.e writing
      ++ the source file *.gle.
    display : FileName -> Void
      ++ display(file.gle) opens the interactive QGLE window and displays
      ++ the graph.
    display : GRAPH -> Void
      ++ display(g) opens the interactive QGLE windows and displays the
      ++ graph g. QGLE allows interactive changes to data as well as the
      ++ GLE source file. For this, you have to set a default editor.
    plot : Plot -> GRAPH
      ++ plot(p) creates graph from a Plot object.
    plot : (DF -> DF, Segment DF) -> GRAPH
      ++ plot(x+->f(x),x1..x2)$GLE creates a graph for the function
      ++ f(x).
    plot : LLDF -> GRAPH
      ++ plot([[x1,y11,y12,...],[x2,y21,y22,...]]) creates data
      ++ representing graphs with (n-1) branches (datasets), where
      ++ n is the common length of the sublists.
    push : (GRAPH,STR) -> GRAPH
      ++ push(g,cmd) adds a GLE command (string) to the end of g.cmds.
    push : (SURFACE,STR) -> SURFACE
      ++ push(s,cmd) adds a GLE command (string) to the end of s.cmds.
    surface : () -> SURFACE
      ++ surface() will create a new instance of a SURFACE object. This
      ++ object may be filled with gle commands and parameterized.
      ++ Note that nothing will be performed before 'create'.
    create : SURFACE -> FileName
      ++ create(s) will actually create the surface object, i.e writing
      ++ the source file *.gle.
    display : SURFACE -> Void
      ++ display(s) opens the interactive QGLE window and displays the
      ++ surface s. QGLE allows interactive changes to data as well as the
      ++ GLE source file. For this, you have to set a default editor.
    letz : (FileName, XDF, SBDF, SBDF, DF, DF) -> STR
      ++ GLE letz
    splot : ((DF,DF)->DF,SDF,SDF,DF,DF) -> ZFILE
      ++ splot creates a ZFILE object
    writeZfile : (FileName,ZFILE) -> Void
      ++ writeZfile writes the ZFILE object to a file *.z
    plot :((DF,DF)->DF,SDF,SDF,DF,DF) -> SURFACE
      ++ plot((x,y)+->f(x,y),xr,yr,stx,sty)$GLE creates a surface for the 
      ++ function z=f(x,y), where xr,yr are x-range, y-range and stx,sty
      ++ denote the stepzize for each direction.
    runGLE : (String,String,String) -> String
      ++ runGLE(glefile,device,options) runs GLE as command, where 
      ++ 'device' in {eps, ps, pdf, svg, jpg, png} as strings and
      ++ 'options' (maybe "") is a string containing more command
      ++ line parameters (use gle --help). So, for instance, the 
      ++ command runGLE("filex.gle", "eps", "") will produce a "eps"
      ++ image "filex.eps" by running gle -device eps [options] filex.gle. 
    conv  : NUMS -> DoubleFloat
      ++ convert(x:Union(DoubleFloat,Float,Integer,Fraction Integer))
      ++ to a DoubleFloat.
    range : (NUMS,NUMS,NUMS) -> List DF
      ++ range(from,to,step) creates a list of DoubleFloat numbers ranging
      ++ from "from" to "to" with stepsize "step" (calculated).
      ++ range(1,2,0.05) --> [1.0,1.05,..,1.95,2.0] , 21 numbers.
      ++ Note: upper bound "to" not necessarily included!
    range : (Segment(NUMS),NUMS) -> List DF
      ++ range(from .. to,step) creates a list of DoubleFloat numbers ranging
      ++ from "from" to "to" with stepsize "step" (calculated).
      ++ range(1..2,0.05) --> [1.0,1.05,..,1.95,2.0] , 21 numbers. 
      ++ Note: upper bound "to" not necessarily included!
    cseg : (NUMS,NUMS) -> Segment DF
      ++ cseg(a,b) creates a segment of DoubleFloats when a and are in
      ++ Union(DoubleFloat,Float,Integer,Fraction Integer).
      ++ cseg(1,5/6) -> 1.0..0.8333333333333334
    numlst2str :List NUMS -> String
      ++ numlst2str([n1,...]) converts a list of numbers to a comma
      ++ separated string. E.g. numlst2str [1,2,3.4,5/7] results in
      ++ "1.0, 2.0, 3.4, 0.7142857142857142". 
    getPath : String -> String
      ++ getPath(filename) returns the full path of the file if it
      ++ exists, otherwise "NIL" is returned.
    catGLE : GRAPH -> Void
      ++ Show the .gle file if created
    catGLE : SURFACE -> Void
	  ++ Show the .gle file if created
    tmQGLE : LLDF -> GRAPH
      ++ QGLE(l) plots a list of list of double floats as a graph in
      ++ TeXmacs (when current frontend) and shows the result interactively
      ++ in the QGLE windows.
    tmGLE  : (LLDF, String, List String) -> String
      ++ tmGLE(l) plots a list of list of double floats as a graph in
      ++ TeXmacs (when current frontend) and returns the path of a *.eps
      ++ file to include with inlineImage.
      
	  
	  
  Implementation ==  add

    format(s:STR,t:STR):STR == string FORMAT('NIL,s,t)$Lisp 
    format(s:STR,l:LSTR):STR == string FORMAT('NIL,s,l)$Lisp
    
    
    convert(p:PDF, sep:String):String ==
      fmt:String:=concat ["窿蔻箦瓞"]
      format(fmt,[toString(x)$DF for x in entries p])
      
    
    convertBranch(b:List PDF, sep:String):LSTR ==
      [convert(x, sep) for x in b]
          
      
    convert(p:Plot, sep:String):LLSTR ==
      b:List List Point(DF):=listBranches p
      [convertBranch(x,sep) for x in b]


    combineBranches(p:Plot):List PDF ==
      b:List List PDF:=listBranches p
      x:List DF:=[first entries t for t in first b]
      y:List List DF:=[[second entries t for t in u] for u in b]
      z:List List DF:=concat(x,y)
      M:Matrix DF:=matrix z
      [point(u) for u in listOfLists(transpose M)]
      

    createDataFile(fn:FileName,data:LSTR):Void ==
      df:TextFile:=open(fn,"output")
      wl:List String:=[writeLine!(df,s) for s in data]
      close!(df)
      void()   
      
      
    numOfBranches(p:Plot):Integer ==
      b:List List PDF:=listBranches p
      #b
  
    getUTC():Integer == 
      utc:SExpression:=GET_-UNIVERSAL_-TIME()$Lisp
      integer utc
      
    getPath(f:String):String ==
      string FORMAT('NIL,"a", PROBE_-FILE(f)$Lisp)$Lisp

    graph():GRAPH ==
      seed:String:=convert(getUTC())@String
      glefn:="GLE" seed ".gle"
      datfn:="GLE" seed ".dat"
      cmds:LSTR:= ["dn line color black", "d1 line color red"]
      pre:STR:="! pre"
      construct(glefn,pre,"12","8","x","y","Title",datfn,cmds)$GRAPH
      

    surface():SURFACE ==
      seed:String:=convert(getUTC())@String
      glefn:="GLE" seed ".gle"
      datfn:="GLE" seed ".z"
      cmds:LSTR:= ["top color orange", "underneath color blue"]
      pre:STR:="size 12 9"
      construct(glefn,pre,"12","8","x","y","z","Title",datfn,cmds)$SURFACE


    graph1:="徇ン辁徇モ彗轭珧狃柽糸綮撷徇⑦糸綮撷徇⑦糸綮撷徇⑦溽翎撷徇⑦徇ュ钿珧狃棹戾酊焙舰モ彗轭戾酊溽翎撷徇骝镯麸篝屦骝镯麸篝屦ュ钿戾酊"  
      
    fitz1:="モ彗轭骈酊溽翎撷徇骝镯麸篝屦骝镯麸篝屦钽镱麸躜ュ钿骈酊"

    contour1:="モ彗轭泔铘秕蜻溽翎撷徇鲠祯弩骝镯麸篝屦箜镲翳ュ钿泔铘秕蟒泔铘秕虿航モ彗轭泔铘秕蜻溽翎撷徇鲠祯弩窿蕃 _
      %  smooth a _
      %end contour}"

    surface1:="徇モ彗轭篚蜴徙暹箝徇糸綮撷徇⑦糸綮撷徇⑦糸綮撷徇⑦糸綮撷徇⑦溽翎撷徇⑦徇ュ钿篚蜴徙妣韵南黼祈粲趄辑泸遽翦翳翦眇灬翦徕秭狨麸磲糸汜祆韵南疰疳翳靠铒箫顼镤泸遽翦ㄧ呵伊腥┖崎戾吾礤浇骖浩殪逦犴搴界珈彐殪搴浩殪逦犴翩涸屮羝殪搴斤疱瞑骖秕麴豸瘐舁螬浇黩轸逄轭濉翩螬泔溴河趄轭绾骘蝽狒á窿撖",g.cmds)
      init:LSTR:=[g.pre,g.xsize,g.ysize,g.xtitle,g.ytitle,g.title,g.data,code]
      s:=format(graph1,init)
      put(s)
      close!(tf)
      return fn
      
    create(s:SURFACE):FileName ==
      fn:FileName:=s.glefile::FileName
      tf:TextFile:=open(fn,"output")
      put(t) ==> writeLine!(tf,t)
      code:String:= format("窿撖",s.cmds)
      init:LSTR:=[s.pre,s.xsize,s.ysize,s.xtitle,s.ytitle,s.ztitle,s.title,_
        s.data,code]
      t:=format(surface1,init)
      put(t)
      close!(tf)
      return fn
    
    display(f:FileName):Void ==
      cmd:=format("system qgle -f a &",f::STR)
      sys cmd


    display(g:GRAPH):Void ==
      display(create g)

    display(s:SURFACE):Void ==
      display(create s)

    plot(p:Plot):GRAPH ==
      g:GRAPH:=graph()
      fn:FileName:=g.data::FileName
      if numOfBranches(p) <= 1 then
        d:LSTR:=first convert(p," ")
      else
        c:List Point DF:=combineBranches(p)
        d:LSTR:=convertBranch(c," ")
      createDataFile(fn,d)
      return g      

    plot(f:DF->DF,s:Segment DF):GRAPH ==
      g:GRAPH:=graph()
      fn:FileName:=g.data::FileName
      p:Plot:=plot(f,s)$Plot
      d:LSTR:=first convert(p," ")
      createDataFile(fn,d)
      return g
      
    plot(l:LLDF):GRAPH ==
      g:GRAPH:=graph()
      fn:FileName:=g.data::FileName
      lp:=[point(x)$Point(DF) for x in l]
      d:LSTR:=convertBranch(lp," ")
      createDataFile(fn,d)
      return g 
      
    push(g:GRAPH,s:STR):GRAPH ==
      l:LSTR:=concat(g.cmds,s)   
      g.cmds:=l
      g
   
    push(s:SURFACE,c:STR):SURFACE ==
      l:LSTR:=concat(s.cmds,c)   
      s.cmds:=l
      s

    letz(fn:FileName,e:XDF,xx:SBDF,yy:SBDF,xstep:DF,ystep:DF):STR ==
      ie:=convert(e)@InputForm
      z:STR:=unparse(ie)
      xs:Symbol:=variable xx
      ys:Symbol:=variable yy
      sx:Segment DF:=segment xx
      sy:Segment DF:=segment yy
      xa:DF:=low(sx)
      xb:DF:=high(sx)
      ya:DF:=low(sy)
      yb:DF:=high(sy)  
      --
      params:LSTR:=[fn::STR,z,"x1","x2","xs","y1","y2","ys"]
      s:=format(letz1,params)
      
      
    splot(f:(DF,DF)->DF,sx:SDF,sy:SDF,xstep:DF,ystep:DF):ZFILE ==
      xa:DF:=low(sx)
      xb:DF:=high(sx)
      ya:DF:=low(sy)
      yb:DF:=high(sy)  
      --
      nxf:DF:=floor((xb-xa)/xstep)
      nyf:DF:=floor((yb-ya)/ystep)
      nx:INT:=integer(nxf)$ IntegerRetractions(DF)
      ny:INT:=integer(nyf)$ IntegerRetractions(DF)
      SI==>SingleInteger
      gr:LLDF:=[[f(float(u,0)$DF*xstep, float(v,0)$DF*ystep) _
          for u in 1..coerce(nx)$SI] for v in 1..coerce(ny)$SI]
      [gr,nx,ny,xa,xb,ya,yb]$ZFILE
      

    writeZfile(fn:FileName, zdf:ZFILE):Void ==
      zf:TextFile:=open(fn,"output")
      hdfmt:String:="铠铢黹磲黹磲"
      hd:STR:=format(hdfmt,[string(zdf.nx),string(zdf.ny), _
        toString(zdf.xmin),toString(zdf.xmax),toString(zdf.ymin), _
        toString(zdf.ymax)])
      fmt:STR:=concat ["窿蔻"]
      data:LSTR:=[format(fmt,[toString(x)$DF for x in y]) for y in zdf.data]
      w0:STR:=writeLine!(zf,hd)
      wl:LSTR:=[writeLine!(zf,s) for s in data]
      close!(zf)
      void()   
    
    plot(f:(DF,DF)->DF,sx:SDF,sy:SDF,xstep:DF,ystep:DF):SURFACE ==
      z:ZFILE:=splot(f,sx,sy,xstep,ystep)
      s:SURFACE:=surface()
      fn:FileName:=(s.data)::FileName
      writeZfile(fn, z)
      s
      
    runGLE(glefile, device, options) ==
      null?(PROBE_-FILE(glefile)$Lisp)$SExpression => _
        error "GLE file not found (created?)! Use )cd to change path."
      sys "system gle -device " device " " options " " glefile 
      --l:=split(glefile ,char ".")
      --r:String:=concat(l.(1..#l-1)) "." device
      fn:FileName:=glefile::FileName
      gn:FileName:=filename(directory(fn), name(fn), device)
      r:=gn::String
      null?(PROBE_-FILE(r)$Lisp)$SExpression => _
        error "GLE: output file not created :-("
      return r

    conv(x:NUMS):DoubleFloat == 
      if x case Integer then r:DF:=convert x
      if x case Float then r:DF:=convert x
      if x case Fraction Integer then r:DF:=convert x
      if x case DoubleFloat then r:DF:=x@DF
      r
      

    range(fro:NUMS,to:NUMS,step:NUMS):List DF ==
      f:=conv fro
      t:=conv to
      s:=conv step
      d:DF:=t-f
      not positive? d => error "Zero interval."
      not positive? s => error "Stepsize must be positive."
      not positive? (d-2.0*s) => error "Stepsize too big."
      fn:DF:=floor((t-f)/s)
      n:Union(Integer,"failed"):=retractIfCan fn
      n case "failed" => error "Number of steps cannot be calculated."
      r:=[f+i::DF * s for i in 0..n]
      --[f,t,s]

    range(s:Segment(NUMS),step:NUMS):List DF == range(low s, high s, step)

    cseg(a:NUMS,b:NUMS):Segment DF == conv(a)..conv(b) 
    
    -- instead of
    -- outputSpacing 0;
    -- toString() if has FPS
    numlst2str(x:List NUMS):String ==
      SEX ==> SExpression
      y:List SEX:=[convert(conv s)$SEX for s in x]
      string FORMAT('NIL,"窿蕃", y)$Lisp
      
    catGLE(g:GRAPH):Void == 
      getPath(g.glefile) = "NIL" => error "File not found."
      sys "system cat " g.glefile
        
    catGLE(s:SURFACE):Void == 
      getPath(s.glefile) = "NIL" => error "File not found."
      sys "system cat " s.glefile

    tmQGLE(l:LLDF):GRAPH ==
      sys "cd /tmp"  --  /.TeXmacs/system/tmp" (issues in TM ???)
      g:=plot(l)
      display g
      g
   
    tmGLE(l:LLDF,title:String,options:List String):String ==
      sys "cd /tmp" -- /.TeXmacs/system/tmp"
      g:=plot(l)
      g.title := title
      if not empty? options then
        r:List GRAPH:=[push(g,s) for s in options]
      fn:=create g
      img:=runGLE("/tmp/" g.glefile, "eps", "")
      

-- l1:=[[x,sin x,cos x] for x in [n*0.1::DoubleFloat for n in 1..10]]
-- l2:=[[x,sin x,cos x,exp(x),x*x] for x in [n*0.1::DoubleFloat for n in 1..10]]
-- g1:=plot l1
-- g2:=plot l2
-- display g1 ....

-- s1:=plot((x:DF,y:DF):DF+->x*x*y-y*y,-1.0::DF..1.0,-1.0::DF..1.0,0.1::DF,0.1::DF)$GLE
-- display s1

-- display plot(sin$DF,-%pi..%pi)
-- display plot(digamma$DF,0.4..10.0)

-- l3:=[[x,sin x,cos x] for x in range(0,10,0.1) ]
-- g3:=plot l3
-- display g3
-- g3.title:="x,sin(x),cos(x)"
-- display g3


-- FORMAT('NIL,"窿蕃",[1,2,3] )$Lisp
-- l2x:=[[convert(x)$SEX for x in s] for s in l2]
-- string FORMAT('NIL,"窿蕃",l2x.1 )$Lisp

-- l:=[[x,sin x,1/x] for x in range(1..10,0.1)]
-- tmGLE(l,"sin(x), 1/x", []) -->