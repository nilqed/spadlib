(
(core_criticalpair lambda (tt k u l v sugar) (list (quote cp) tt k u l v sugar))

(core_getpairlcm lambda (p) (cadr p))

(core_getpairfirst lambda (p) (cons (caddr p) (cadddr p)))

(core_getpairsecond lambda (p) (cons (car (cddddr p)) (cadr (cddddr p))))

(core_getpairsugar lambda (p) (caddr (cddddr p)))

(core_rewriterule lambda (idx tt) (list (quote rr) idx tt))

(core_getruleindex lambda (r) (cadr r))

(core_getruleterm lambda (r) (caddr r))

(core_setpoly lambda (r i f) (putv (cadr r) i f))

(core_getpoly lambda (r i) (getv (cadr r) i))

(core_getbasisidx lambda (r) (idifference (caddr r) 1))

(core_isrewritable lambda (u k r rule) (not (iequal (core_findrewriting u k r
rule) k)))

(core_selectpairs lambda (pairs) (cond (!*f5sugar (core_selectpairssugar pairs))
(t (core_selectpairsnormal pairs))))

(lp_signature lambda (idx st) (list (quote sgn) idx st))

(lp_labeledpolynomial1 lambda (poly idx) (lp_labeledpolynomial2 poly (list (
quote sgn) idx (poly_identityterm))))

(lp_labeledpolynomial2 lambda (poly sgn) (list (quote lp) poly sgn))

(lp_sgn lambda (f) (caddr f))

(lp_eval lambda (f) (cadr f))

(lp_seteval lambda (lp ev) (setcar (cdr lp) ev))

(lp_setsgn lambda (lp s) (setcar (cddr lp) s))

(lp_indexsgn lambda (s) (cadr s))

(lp_termsgn lambda (s) (caddr s))

(lp_eqsgn lambda (s1 s2) (and (iequal (cadr s1) (cadr s2)) (poly_eqterm!? (caddr
s1) (caddr s2))))

(lp_iszero!? lambda (lp) (poly_iszero!? (cadr lp)))

(lp_mulsgn lambda (sgn ev) (list (quote sgn) (cadr sgn) (poly_multerm (caddr sgn
) ev)))

(lp_normalize lambda (f) (list (quote lp) (poly_normalize (cadr f)) (caddr f)))

(lp_scaledenominators lambda (f) (list (quote lp) (poly_scaledenominators (cadr
f)) (caddr f)))

(lp_reducecoeffs lambda (f prime) (list (quote lp) (poly_reducecoeffs (cadr f)
prime) (caddr f)))

(lp_reconstructcoeffs lambda (f prime) (list (quote lp) (poly_reconstructcoeffs
(cadr f) prime) (caddr f)))

(lp_crtcoeffs lambda (polyaccum modulo polycomp prime) (list (quote lp) (
poly_crtcoeffs (cadr polyaccum) modulo (cadr polycomp) prime) (caddr polyaccum))
)

(poly_polynomialwithsugar lambda (ts cfs sugar) (list (quote p) ts cfs sugar))

(poly_polynomial lambda (ts cfs) (list (quote p) ts cfs 0))

(poly_getterms lambda (poly) (cadr poly))

(poly_getcoeffs lambda (poly) (caddr poly))

(poly_getsugar lambda (poly) (cadddr poly))

(poly_zero lambda nil (list (quote p) nil nil 0))

(poly_one lambda nil (list (quote p) (list (poly_zeroexp)) (list (poly_onecoeff)
) 0))

(poly_iszero!? lambda (p) (null (cadr p)))

(poly_sf2poly lambda (u) (poly_sq2poly (cons u 1)))

(poly_groundcoeff lambda (var deg) (cons (cons (cons (cons var deg) 1) nil) 1))

(poly_sq2poly lambda (u) (poly_sq2poly1 u (poly_zeroexp) (poly_onecoeff)))

(poly_totaldegexp lambda (e1) (car e1))

(poly_zeroexp lambda nil (prog (x forall!-result forall!-endptr) (setq x 1) (
cond ((minusp (difference (length global!-dipvars!*) x)) (return nil))) (setq
forall!-result (setq forall!-endptr (cons 0 nil))) looplabel (setq x (plus2 x 1)
) (cond ((minusp (difference (length global!-dipvars!*) x)) (return
forall!-result))) (rplacd forall!-endptr (cons 0 nil)) (setq forall!-endptr (cdr
forall!-endptr)) (go looplabel)))

(poly_2aexp lambda (e) (ev_2aexp1 (cdr e) (cdr global!-dipvars!*)))

(poly_cmpexpgradlex lambda (e1 e2) (or (ilessp (car e1) (car e2)) (and (iequal (
car e1) (car e2)) (poly_cmpexplex e1 e2))))

(poly_cmpexprevgradlex lambda (e1 e2) (or (ilessp (car e1) (car e2)) (and (
iequal (car e1) (car e2)) (iequal (evinvlexcomp (cdr e1) (cdr e2)) (minus 1)))))

(poly_cmpexpgeneric lambda (e1 e2) (equal (evcomp (cdr e1) (cdr e2)) (minus 1)))

(poly_tdegcmpexp lambda (e1 e2) (ilessp (car e1) (car e2)))

(poly_eqexp!? lambda (e1 e2) (equal e1 e2))

(poly_identityterm lambda nil (prog (x forall!-result forall!-endptr) (setq x 1)
(cond ((minusp (difference (length global!-dipvars!*) x)) (return nil))) (setq
forall!-result (setq forall!-endptr (cons 0 nil))) looplabel (setq x (plus2 x 1)
) (cond ((minusp (difference (length global!-dipvars!*) x)) (return
forall!-result))) (rplacd forall!-endptr (cons 0 nil)) (setq forall!-endptr (cdr
forall!-endptr)) (go looplabel)))

(poly_isidentityterm!? lambda (tm) (iequal (poly_totaldegterm tm) 0))

(poly_totaldegterm lambda (a) (car a))

(poly_multerm lambda (a b) (poly_sumexp a b))

(poly_divterm lambda (a b) (poly_subexp a b))

(poly_dividesterm!? lambda (a b) (poly_divexp!? a b))

(poly_lcmterm lambda (a b) (poly_elmaxexp a b))

(poly_cmpterm lambda (a b) (poly_cmpexp a b))

(poly_disjterm!? lambda (a b) (poly_disjexp!? a b))

(poly_eqterm!? lambda (a b) (equal a b))

(poly_tail lambda (poly) (list (quote p) (poly_tailterms poly) (poly_tailcoeffs
poly) (cadddr poly)))

(poly_leadterm lambda (poly) (car (cadr poly)))

(poly_leadcoeff lambda (poly) (car (caddr poly)))

(poly_tailterms lambda (poly) (cdr (cadr poly)))

(poly_tailcoeffs lambda (poly) (cdr (caddr poly)))

(poly_length lambda (poly) (length (cadr poly)))

(poly_isconst!? lambda (poly) (or (null (cadr poly)) (equal (car (cadr poly)) (
prog (x forall!-result forall!-endptr) (setq x 1) (cond ((minusp (difference (
length global!-dipvars!*) x)) (return nil))) (setq forall!-result (setq
forall!-endptr (cons 0 nil))) looplabel (setq x (plus2 x 1)) (cond ((minusp (
difference (length global!-dipvars!*) x)) (return forall!-result))) (rplacd
forall!-endptr (cons 0 nil)) (setq forall!-endptr (cdr forall!-endptr)) (go
looplabel)))))

(poly_iszerocoeff!? lambda (a) (not (car a)))

(poly_isonecoeff!? lambda (a) (and (eqn (car a) 1) (eqn (cdr a) 1)))

(poly_zerocoeff lambda nil (poly_2coeff 0))

(poly_onecoeff lambda nil (poly_2coeff 1))

(poly_2coeff lambda (c) (cond ((sqp c) c) (t (cons c 1))))

(poly_2acoeff lambda (c) (prepsq c))

(poly_addcoeff lambda (a b) (addsq a b))

(poly_subcoeff lambda (a b) (addsq a (negsq b)))

(poly_mulcoeff lambda (a b) (multsq a b))

(poly_negcoeff lambda (a) (negsq a))

(poly_isnegcoeff!? lambda (a) (minusf (car a)))

(poly_divcoeff lambda (a b) (multsq a (invsq b)))

(poly_invcoeff lambda (a) (progn (cons (cdr a) (car a))))

(poly_paircombtail lambda (f fmult fcoeff g gmult gcoeff) (poly_paircomb (list (
quote p) (poly_tailterms f) (poly_tailcoeffs f) (cadddr f)) fmult fcoeff (list (
quote p) (poly_tailterms g) (poly_tailcoeffs g) (cadddr g)) gmult gcoeff))

(poly_sumpoly lambda (f g) (cond ((null (cadr f)) g) ((null (cadr g)) f) (t (
poly_paircomb f (prog (x forall!-result forall!-endptr) (setq x 1) (cond ((
minusp (difference (length global!-dipvars!*) x)) (return nil))) (setq
forall!-result (setq forall!-endptr (cons 0 nil))) looplabel (setq x (plus2 x 1)
) (cond ((minusp (difference (length global!-dipvars!*) x)) (return
forall!-result))) (rplacd forall!-endptr (cons 0 nil)) (setq forall!-endptr (cdr
forall!-endptr)) (go looplabel)) (negsq (poly_2coeff 1)) g (prog (x
forall!-result forall!-endptr) (setq x 1) (cond ((minusp (difference (length
global!-dipvars!*) x)) (return nil))) (setq forall!-result (setq forall!-endptr
(cons 0 nil))) looplabel (setq x (plus2 x 1)) (cond ((minusp (difference (length
global!-dipvars!*) x)) (return forall!-result))) (rplacd forall!-endptr (cons 0
nil)) (setq forall!-endptr (cdr forall!-endptr)) (go looplabel)) (poly_2coeff 1)
))))

(poly_cmppolylead lambda (poly1 poly2) (poly_cmpexp (car (cadr poly1)) (car (
cadr poly2))))

(cde_alglistp lambda (l) (and (listp l) (equal (car l) (quote list))))

(cde_list_to_ids lambda (l) (cde_list2id (cdr l)))

(cde_mal lambda (ll) (cons (quote list) ll))

(cde_tools lambda nil nil)

(ra_x lambda nil (quote x))

(ra_y lambda nil (quote w))

(ra_zero lambda nil (ra_mk (list (cons (cons (quote x) 1) 1)) (riv_mk (cons (
minus 1) 1) (cons 1 1))))

(lexer_option lambda (o) (not (zerop (land lexer_style!* o))))

(sml_opchar lambda (ch) (and (not (zerop (land lexer_style!* 131072))) (flagp ch
(quote sml_opchar))))

(lex_unicode_alphabetic lambda (c) (or (and (geq c 65) (leq c 90)) (and (geq c
97) (leq c 122))))

(lex_unicode_numeric lambda (c) (and (geq c 48) (leq c 57)))

(logoturtle!-autodraw lambda nil (cond (!*logoturtle_autodraw (draw))))

(logoturtle!-autodraw!-nothing lambda nil (cond (!*logoturtle_autodraw (prog (
!*logoturtle!-draw!-nothing) (setq !*logoturtle!-draw!-nothing t) (draw)))))

(bibasis_insert lambda (y x) (rplaca (rplacd y (cons (car y) (cdr y))) x))

(bibasis_remove lambda (y) (rplacd (rplaca y (cadr y)) (cddr y)))

(getvariable lambda (variable) (getv fluidbibasissinglevariablemonomialss
variable))

(monomgetdegree lambda (monom) (getv monom 0))

(monomsetdegree lambda (monom degree) (putv monom 0 degree))

(monomgetexponent lambda (monom) (getv monom 1))

(monomsetexponent lambda (monom exponent) (putv monom 1 exponent))

(createprolongset lambda nil (cons nil nil))

(triplegetid lambda (triple) (getv triple 0))

(triplegetpolynom lambda (triple) (getv triple 1))

(triplegetancestorid lambda (triple) (getv triple 2))

(triplegetlm lambda (triple) (car (getv triple 1)))

(triplegetprolongset lambda (triple) (getv triple 3))

(createjanettreenode lambda (degree triple nextdegree nextvariable) (cons (cons
degree triple) (cons nextdegree nextvariable)))

(janettreereset lambda nil (setq fluidbibasisjanettreerootnode nil))

(janettreeprint lambda nil (janettreenodeprint fluidbibasisjanettreerootnode))

(setqreset lambda nil (setq fluidbibasissetq (cons nil nil)))

(setqisempty lambda nil (null (car fluidbibasissetq)))

(setqinsert lambda (triple) (sortedtriplelistinsert fluidbibasissetq triple))

(mk_sq lambda (a) (list (quote !*sq) a t))

(string!-to!-list lambda (a) (string2list a))

(fancy!-logb lambda (u) (fancy!-indexed!-fn (list "\log" (caddr u) (cadr u))))

(fancy!-log10 lambda (u) (fancy!-indexed!-fn (list "\log" 10 (cadr u))))

(wuclass lambda (f) (cond ((wuconstantp f) nil) (t (caaar f))))

(wudeg lambda (f) (cond ((wuconstantp f) 0) (t (cdaar f))))

(wuinitial lambda (f) (cond ((wuconstantp f) f) (t (cdar f))))

(classlessp lambda (c1 c2) (symbollessp c1 c2))

(getcoef lambda (g0) (car g0))

(getvl lambda (g0) (cdr g0))

(putcoef lambda (g0 c) (rplaca g0 c))

(putvl lambda (g0 vl) (rplacd g0 vl))

(gettv lambda (v) (car v))

(gete1 lambda (v) (cadr v))

(gete2 lambda (v) (caddr v))

(gete3 lambda (v) (cadddr v))

(getinq lambda (v) (cadr v))

(getoutq lambda (v) (caddr v))

(puttv lambda (v tv) (rplaca v tv))

(pute1 lambda (v e) (rplaca (cdr v) e))

(pute2 lambda (v e) (rplaca (cddr v) e))

(pute3 lambda (v e) (rplaca (cdddr v) e))

(putinq lambda (v e) (rplaca (cdr v) e))

(putoutq lambda (v e) (rplaca (cddr v) e))

(mkg0 lambda (c g0) (cons c g0))

(chktv lambda (v tv) (eq (car v) tv))

(qgvp lambda (v) (eq (car v) (quote qg)))

(g3vp lambda (v) (eq (car v) (quote g3)))

(zcoefp lambda (g0) (null (car (car g0))))

(mkcopyg0 lambda (g0) (cons (car g0) (mkcopy (cdr g0))))

(chkhp lambda (v) (or (eq (cadr v) (caddr v)) (eq (cadr v) (cadddr v)) (eq (
caddr v) (cadddr v))))

(existqgv lambda (g0) (assoc (quote qg) (cdr g0)))

(exist3gv lambda (g0) (assoc (quote g3) (cdr g0)))

(revv lambda (v e) (cond ((or (null (eq (car v) (quote g3))) (null (memq e (cdr
v)))) (cerror (list "Edge" e "is absent in vertex" v))) (t (revv0 v e))))

(tri_istag lambda (v w) (equal (car v) w))

(tri_unary lambda (uby) (car uby))

(tri_binary lambda (uby) (cdr uby))

(tri_lcopy lambda (a) (prog (x forall!-result forall!-endptr) (setq x a) (cond (
(null x) (return nil))) (setq forall!-result (setq forall!-endptr (cons ((lambda
(x) x) (car x)) nil))) looplabel (setq x (cdr x)) (cond ((null x) (return
forall!-result))) (rplacd forall!-endptr (cons ((lambda (x) x) (car x)) nil)) (
setq forall!-endptr (cdr forall!-endptr)) (go looplabel)))

(tri_triassert lambda (name item) (put name (quote texname) item))

(tri_assertl lambda (l) (prog (v) (setq v l) lab (cond ((null v) (return nil)))
((lambda (v) (put (car v) (quote texname) (cadr v))) (car v)) (setq v (cdr v)) (
go lab)))

(tri_retract lambda (name) (put name (quote texname) nil))

(tri_retractl lambda (l) (prog (v) (setq v l) lab (cond ((null v) (return nil)))
((lambda (v) (put (car v) (quote texname) nil)) (car v)) (setq v (cdr v)) (go
lab)))

(tri_gettexitem lambda (a) (or (get a (quote texname)) (and (get a (quote class)
) a)))

(strtexitem lambda (e) (cond ((equal e blank) (list (quote !\! ))) ((equal e (
quote !	)) (list (quote !\! ))) ((liter e) (list e)) ((or (get e (quote texname)
) (and (get e (quote class)) e)) (list (or (get e (quote texname)) (and (get e (
quote class)) e)))) (t (unknownitem e))))

(kindof lambda (item) (get item (quote textag)))

(classof lambda (item) (get item (quote class)))

(groupbeg lambda (kind) (memq kind (quote (beg sup sub frc mat))))

(groupend lambda (kind) (equal kind (quote end)))

(grouphs lambda (kind) (equal kind (quote tab)))

(groupvs lambda (kind) (memq kind (quote (esp esb sep cr))))

(sp2mm lambda (x) (quotient x 186468))

(isglue lambda (l) (and (not (atom l)) (numberp (car l))))

(isactive lambda (x) (not (numberp x)))

(ispassive lambda (x) (numberp x))

(isdelta lambda (x) (cdddr x))

(addup lambda (x) (cond (x (eval (cons (quote plus) x))) (t 0)))

(poke lambda (stack ptr val) (cond ((null ptr) (setq stack (nconc stack (cons
val nil)))) (t (progn (cond ((greaterp val (car ptr)) (rplaca ptr val))) (setq
ptr (cdr ptr))))))

(concatenate lambda (l) (prog (r) (prog (e) (setq e l) lab (cond ((null e) (
return nil))) ((lambda (e) (setq r (nconc r (explode e)))) (car e)) (setq e (cdr
e)) (go lab)) (return (compress r))))

(widthof lambda (deltanode) (car deltanode))

(penaltyof lambda (deltanode) (cadr deltanode))

(totalof lambda (deltanode) (cadr deltanode))

(offsetof lambda (deltanode) (caddr deltanode))

(idof lambda (deltanode) (cadddr deltanode))

(ptrof lambda (deltanode) (car (cddddr deltanode)))

(indentof lambda (deltanode) (caddr (cddddr deltanode)))

(tailof lambda (deltanode) (cddddr deltanode))

(tri_newline lambda nil (cond (nlflag (setq cc indent)) ((greaterp cc indent) (
progn (terpri) (setq cc indent) (setq nlflag t)))))

(mrv_constantp lambda (f x) (or (constant_exprp f) (freeof f x)))

(mrv!-smallest lambda (u) (cond ((atom u) u) (t (prog (v lng1 lng2) (setq v (car
u)) (setq lng1 (mrv!-length v)) (prog (el) (setq el (cdr u)) lab (cond ((null el
) (return nil))) ((lambda (el) (cond ((greaterp lng1 (setq lng2 (mrv!-length el)
)) (progn (setq v el) (setq lng1 lng2))))) (car el)) (setq el (cdr el)) (go lab)
) (return v)))))

(nzerolist lambda (n) (nlist 0 n))

(copy!-list lambda (l) (append l nil))

(make!-taylor!* lambda (cflis tp orig flgs) (list (quote taylor!*) cflis tp orig
flgs))

(taymakecoeff lambda (u v) (cons u v))

(taycoefflist lambda (u) (cadr u))

(taytemplate lambda (u) (caddr u))

(tayorig lambda (u) (cadddr u))

(tayflags lambda (u) (car (cddddr u)))

(taycfpl lambda (u) (car u))

(taycfsq lambda (u) (cdr u))

(taytpvars lambda (tp) (prog (x forall!-result forall!-endptr) (setq x tp)
startover (cond ((null x) (return nil))) (setq forall!-result ((lambda (x) (
append (car x) nil)) (car x))) (setq forall!-endptr (lastpair forall!-result)) (
setq x (cdr x)) (cond ((atom forall!-endptr) (go startover))) looplabel (cond ((
null x) (return forall!-result))) (rplacd forall!-endptr ((lambda (x) (append (
car x) nil)) (car x))) (setq forall!-endptr (lastpair forall!-endptr)) (setq x (
cdr x)) (go looplabel)))

(tayvars lambda (u) (prog (x forall!-result forall!-endptr) (setq x (caddr u))
startover (cond ((null x) (return nil))) (setq forall!-result ((lambda (x) (
append (car x) nil)) (car x))) (setq forall!-endptr (lastpair forall!-result)) (
setq x (cdr x)) (cond ((atom forall!-endptr) (go startover))) looplabel (cond ((
null x) (return forall!-result))) (rplacd forall!-endptr ((lambda (x) (append (
car x) nil)) (car x))) (setq forall!-endptr (lastpair forall!-endptr)) (setq x (
cdr x)) (go looplabel)))

(taygetcoeff lambda (degrlis coefflis) ((lambda (cc) (cond ((null cc) (cons nil
1)) (t (cdr cc)))) (assoc degrlis coefflis)))

(taytpelvars lambda (u) (car u))

(taytpelpoint lambda (u) (cadr u))

(taytpelorder lambda (u) (caddr u))

(taytpelnext lambda (u) (cadddr u))

(tpdegreelist lambda (tp) (prog (x forall!-result forall!-endptr) (setq x tp) (
cond ((null x) (return nil))) (setq forall!-result (setq forall!-endptr (cons ((
lambda (x) (caddr x)) (car x)) nil))) looplabel (setq x (cdr x)) (cond ((null x)
(return forall!-result))) (rplacd forall!-endptr (cons ((lambda (x) (caddr x)) (
car x)) nil)) (setq forall!-endptr (cdr forall!-endptr)) (go looplabel)))

(tpnextlist lambda (tp) (prog (x forall!-result forall!-endptr) (setq x tp) (
cond ((null x) (return nil))) (setq forall!-result (setq forall!-endptr (cons ((
lambda (x) (cadddr x)) (car x)) nil))) looplabel (setq x (cdr x)) (cond ((null x
) (return forall!-result))) (rplacd forall!-endptr (cons ((lambda (x) (cadddr x)
) (car x)) nil)) (setq forall!-endptr (cdr forall!-endptr)) (go looplabel)))

(taydegreesum lambda (u) (prog (x forall!-result) (setq x (caddr u)) (setq
forall!-result 0) lab1 (cond ((null x) (return forall!-result))) (setq
forall!-result (plus ((lambda (x) (caddr x)) (car x)) forall!-result)) (setq x (
cdr x)) (go lab1)))

(set!-taycoefflist lambda (u v) (rplaca (cdr u) v))

(set!-taytemplate lambda (u v) (rplaca (cddr u) v))

(set!-tayorig lambda (u v) (rplaca (cdddr u) v))

(set!-tayflags lambda (u v) (rplaca (cddddr u) v))

(set!-taycfpl lambda (u v) (rplaca u v))

(set!-taycfsq lambda (u v) (rplacd u v))

(exponent!-check!-int lambda (rn) (cond ((equal (cddr rn) 1) (cadr rn)) (t rn)))

(tayflagscombine lambda (u v) nil)

(get!-degree lambda (dg) (prog (n forall!-result) (setq n dg) (setq
forall!-result 0) lab1 (cond ((null n) (return forall!-result))) (setq
forall!-result (tayexp!-plus ((lambda (n) n) (car n)) forall!-result)) (setq n (
cdr n)) (go lab1)))

(get!-degreelist lambda (dgl) (prog (dg forall!-result forall!-endptr) (setq dg
dgl) (cond ((null dg) (return nil))) (setq forall!-result (setq forall!-endptr (
cons ((lambda (dg) (prog (n forall!-result) (setq n dg) (setq forall!-result 0)
lab1 (cond ((null n) (return forall!-result))) (setq forall!-result (
tayexp!-plus ((lambda (n) n) (car n)) forall!-result)) (setq n (cdr n)) (go lab1
))) (car dg)) nil))) looplabel (setq dg (cdr dg)) (cond ((null dg) (return
forall!-result))) (rplacd forall!-endptr (cons ((lambda (dg) (prog (n
forall!-result) (setq n dg) (setq forall!-result 0) lab1 (cond ((null n) (return
forall!-result))) (setq forall!-result (tayexp!-plus ((lambda (n) n) (car n))
forall!-result)) (setq n (cdr n)) (go lab1))) (car dg)) nil)) (setq
forall!-endptr (cdr forall!-endptr)) (go looplabel)))

(invert!-powerlist lambda (pl) (prog (nl forall!-result forall!-endptr) (setq nl
pl) (cond ((null nl) (return nil))) (setq forall!-result (setq forall!-endptr (
cons ((lambda (nl) (prog (p forall!-result forall!-endptr) (setq p nl) (cond ((
null p) (return nil))) (setq forall!-result (setq forall!-endptr (cons ((lambda
(p) (tayexp!-minus p)) (car p)) nil))) looplabel (setq p (cdr p)) (cond ((null p
) (return forall!-result))) (rplacd forall!-endptr (cons ((lambda (p) (
tayexp!-minus p)) (car p)) nil)) (setq forall!-endptr (cdr forall!-endptr)) (go
looplabel))) (car nl)) nil))) looplabel (setq nl (cdr nl)) (cond ((null nl) (
return forall!-result))) (rplacd forall!-endptr (cons ((lambda (nl) (prog (p
forall!-result forall!-endptr) (setq p nl) (cond ((null p) (return nil))) (setq
forall!-result (setq forall!-endptr (cons ((lambda (p) (tayexp!-minus p)) (car p
)) nil))) looplabel (setq p (cdr p)) (cond ((null p) (return forall!-result))) (
rplacd forall!-endptr (cons ((lambda (p) (tayexp!-minus p)) (car p)) nil)) (setq
forall!-endptr (cdr forall!-endptr)) (go looplabel))) (car nl)) nil)) (setq
forall!-endptr (cdr forall!-endptr)) (go looplabel)))

(taymultcoeffs lambda (c1 c2) (cons (add!-degrees (car c1) (car c2)) (multsq (
cdr c1) (cdr c2))))

(prune!-coefflist lambda (cflist) ((lambda (cflis) (progn (prog nil whilelabel (
cond ((not (and (not (null cflis)) (null (car (cdr (car cflis)))))) (return nil)
)) (setq cflis (cdr cflis)) (go whilelabel)) cflis)) cflist))

(multintocoefflist lambda (coefflis sq) (prog (p forall!-result forall!-endptr)
(setq p coefflis) (cond ((null p) (return nil))) (setq forall!-result (setq
forall!-endptr (cons ((lambda (p) (cons (car p) (resimp (subs2!* (multsq (cdr p)
sq))))) (car p)) nil))) looplabel (setq p (cdr p)) (cond ((null p) (return
forall!-result))) (rplacd forall!-endptr (cons ((lambda (p) (cons (car p) (
resimp (subs2!* (multsq (cdr p) sq))))) (car p)) nil)) (setq forall!-endptr (cdr
forall!-endptr)) (go looplabel)))

(subs2coefflist lambda (clist) (prog (pp forall!-result forall!-endptr) (setq pp
clist) startover (cond ((null pp) (return nil))) (setq forall!-result ((lambda (
pp) ((lambda (sq) (cond ((not (null (car sq))) (list (cons (car pp) sq))))) (
subs2!* (cdr pp)))) (car pp))) (setq forall!-endptr (lastpair forall!-result)) (
setq pp (cdr pp)) (cond ((atom forall!-endptr) (go startover))) looplabel (cond
((null pp) (return forall!-result))) (rplacd forall!-endptr ((lambda (pp) ((
lambda (sq) (cond ((not (null (car sq))) (list (cons (car pp) sq))))) (subs2!* (
cdr pp)))) (car pp))) (setq forall!-endptr (lastpair forall!-endptr)) (setq pp (
cdr pp)) (go looplabel)))

(resimpcoefflist lambda (clist) (prog (cc forall!-result forall!-endptr) (setq
cc clist) (cond ((null cc) (return nil))) (setq forall!-result (setq
forall!-endptr (cons ((lambda (cc) (cons (car cc) (subs2 (resimp (cdr cc))))) (
car cc)) nil))) looplabel (setq cc (cdr cc)) (cond ((null cc) (return
forall!-result))) (rplacd forall!-endptr (cons ((lambda (cc) (cons (car cc) (
subs2 (resimp (cdr cc))))) (car cc)) nil)) (setq forall!-endptr (cdr
forall!-endptr)) (go looplabel)))

(resimptaylor lambda (u) (list (quote taylor!*) (prog (cc forall!-result
forall!-endptr) (setq cc (cadr u)) (cond ((null cc) (return nil))) (setq
forall!-result (setq forall!-endptr (cons ((lambda (cc) (cons (car cc) (subs2 (
resimp (cdr cc))))) (car cc)) nil))) looplabel (setq cc (cdr cc)) (cond ((null
cc) (return forall!-result))) (rplacd forall!-endptr (cons ((lambda (cc) (cons (
car cc) (subs2 (resimp (cdr cc))))) (car cc)) nil)) (setq forall!-endptr (cdr
forall!-endptr)) (go looplabel)) (caddr u) (cond ((and !*taylorkeeporiginal (
cadddr u)) (resimp (cadddr u))) (t nil)) (car (cddddr u))))

(make!-cst!-powerlist lambda (tp) (prog (el forall!-result forall!-endptr) (setq
el tp) (cond ((null el) (return nil))) (setq forall!-result (setq forall!-endptr
(cons ((lambda (el) (nlist 0 (length (car el)))) (car el)) nil))) looplabel (
setq el (cdr el)) (cond ((null el) (return forall!-result))) (rplacd
forall!-endptr (cons ((lambda (el) (nlist 0 (length (car el)))) (car el)) nil))
(setq forall!-endptr (cdr forall!-endptr)) (go looplabel)))

(make!-cst!-coefficient lambda (cst tp) (cons (prog (el forall!-result
forall!-endptr) (setq el tp) (cond ((null el) (return nil))) (setq
forall!-result (setq forall!-endptr (cons ((lambda (el) (nlist 0 (length (car el
)))) (car el)) nil))) looplabel (setq el (cdr el)) (cond ((null el) (return
forall!-result))) (rplacd forall!-endptr (cons ((lambda (el) (nlist 0 (length (
car el)))) (car el)) nil)) (setq forall!-endptr (cdr forall!-endptr)) (go
looplabel)) cst))

(make!-cst!-coefflis lambda (cst tp) (list (cons (prog (el forall!-result
forall!-endptr) (setq el tp) (cond ((null el) (return nil))) (setq
forall!-result (setq forall!-endptr (cons ((lambda (el) (nlist 0 (length (car el
)))) (car el)) nil))) looplabel (setq el (cdr el)) (cond ((null el) (return
forall!-result))) (rplacd forall!-endptr (cons ((lambda (el) (nlist 0 (length (
car el)))) (car el)) nil)) (setq forall!-endptr (cdr forall!-endptr)) (go
looplabel)) cst)))

(cst!-taylor!* lambda (cst tp) (list (quote taylor!*) (list (cons (prog (el
forall!-result forall!-endptr) (setq el tp) (cond ((null el) (return nil))) (
setq forall!-result (setq forall!-endptr (cons ((lambda (el) (nlist 0 (length (
car el)))) (car el)) nil))) looplabel (setq el (cdr el)) (cond ((null el) (
return forall!-result))) (rplacd forall!-endptr (cons ((lambda (el) (nlist 0 (
length (car el)))) (car el)) nil)) (setq forall!-endptr (cdr forall!-endptr)) (
go looplabel)) cst)) tp cst nil))

(has!-taylor!* lambda (u) (smember (quote taylor!*) u))

(taylor!*p lambda (u) (eqcar u (quote taylor!*)))

(taylor!-kernel!-sf!-p lambda (u) (and (not (or (atom u) (atom (car u)))) (null
(cdr u)) (equal (cdar u) 1) (equal (cdaar u) 1) (eqcar (caaar u) (quote taylor!*
))))

(taylor!-kernel!-sq!-p lambda (u) (and (kernp u) (eqcar (caaar (car u)) (quote
taylor!*))))

(has!-tayvars lambda (tay ex) (smemberlp (prog (x forall!-result forall!-endptr)
(setq x (caddr tay)) startover (cond ((null x) (return nil))) (setq
forall!-result ((lambda (x) (append (car x) nil)) (car x))) (setq forall!-endptr
(lastpair forall!-result)) (setq x (cdr x)) (cond ((atom forall!-endptr) (go
startover))) looplabel (cond ((null x) (return forall!-result))) (rplacd
forall!-endptr ((lambda (x) (append (car x) nil)) (car x))) (setq forall!-endptr
(lastpair forall!-endptr)) (setq x (cdr x)) (go looplabel)) ex))

(!*tay2f lambda (u) (list (cons (getpower (fkern u) 1) 1)))

(!*tay2q lambda (u) (cons (list (cons (getpower (fkern u) 1) 1)) 1))

(get!-denom lambda (expo) (cond ((atom expo) 1) (t (cddr expo))))

(taycoeff!-before lambda (cc1 cc2) (taydegree!< (car cc1) (car cc2)))

(degree!-union lambda (u v) (union u v))

(checkpower lambda (var var0 n) (cond ((eq var0 (quote infinity)) (cond ((equal
n 0) 1) (t (list (quote quotient) 1 (checkexp var n))))) (t (checkexp (
checkdifference var (reval1 var0 t)) n))))

(talp_unmkalop lambda (f) (aeval (clear (list f))))

(talp_getl lambda nil talp_lang!*)

(talp_getextl lambda nil talp_extlang!*)

(talp_lengthat lambda (atf) (length (talp_argl atf)))

(talp_resimpterm lambda (term) (talp_simpterm term))

(talp_prepterm lambda (term) (talp_simpterm term))

(talp_opp lambda (op) (memq op (quote (equal neq))))

(talp_op lambda (at) (car at))

(talp_fop lambda (term) (car term))

(talp_arg2l lambda (at) (cadr at))

(talp_arg2r lambda (at) (caddr at))

(talp_argl lambda (f) (cdr f))

(talp_invarg lambda (term) (cadr term))

(talp_mkinv lambda (inv term) (cons inv (list term)))

(talp_mk2 lambda (op lhs rhs) (list op lhs rhs))

(talp_mkn lambda (op argl) (cons op argl))

(talp_mktn lambda (op argl) (cons op argl))

(talp_fargl lambda (term) (cdr term))

(qqe_exit lambda nil nil)

(qqe_lengthat lambda (f) 2)

(qqe_prepat lambda (f) f)

(qqe_simpat lambda (f) f)

(qqe_prepterm lambda (f) f)

(qqe_op lambda (atf) (car atf))

(qqe_lhs lambda (atf) (cadr atf))

(qqe_rhs lambda (atf) (caddr atf))

(qqe_arg2l lambda (atf) (cadr atf))

(qqe_arg2r lambda (atf) (caddr atf))

(qqe_argn lambda (atf) (list (cadr atf) (caddr atf)))

(qqe_mk2 lambda (op lhs rhs) (list op lhs rhs))

(qqe_0mk2 lambda (op lhs) (list op lhs nil))

(qqe_mkn lambda (op argl) (list op (car argl) (cadr argl)))

(qqe_rqopp lambda (op) (memq op (quote (qequal qneq))))

(qqe_rbopp lambda (op) (memq op (quote (equal neq lessp leq geq greaterp))))

(qqe_ropp lambda (op) (or (memq op (quote (qequal qneq))) (memq op (quote (equal
neq lessp leq geq greaterp)))))

(qqe_qopp lambda (op) (memq op (quote (radd ladd lhead rhead ltail rtail))))

(qqe_qopheadp lambda (op) (memq op (quote (lhead rhead))))

(qqe_qoptailp lambda (op) (cond ((memq op (quote (rtail ltail))) t)))

(qqe_qopaddp lambda (op) (cond ((memq op (quote (ladd radd))) t)))

(qqe_btid lambda (u) (put u (quote idtype) (quote bt)))

(qqe_qtid lambda (u) (put u (quote idtype) (quote qt)))

(qqe_niltid lambda (u) (put u (quote idtype) nil))

(qqe_btidp lambda (u) (equal (get u (quote idtype)) (quote bt)))

(qqe_qtidp lambda (u) (equal (get u (quote idtype)) (quote qt)))

(qqe_nytidp lambda (u) (equal (get u (quote idtype)) nil))

(pasf_op lambda (atf) (car atf))

(pasf_opp lambda (op) (or (memq op (quote (equal neq lessp leq greaterp geq))) (
and (pairp op) (memq (car op) (quote (cong ncong))))))

(pasf_m lambda (atf) (cdar atf))

(pasf_arg2l lambda (atf) (cadr atf))

(pasf_arg2r lambda (atf) (caddr atf))

(pasf_mk2 lambda (op lhs rhs) (list op lhs rhs))

(pasf_0mk2 lambda (op lhs) (list op lhs nil))

(pasf_opn lambda (atf) (cond ((or (eq atf (quote true)) (eq atf (quote false)))
atf) ((pairp (car atf)) (caar atf)) (t (car atf))))

(pasf_atfp lambda (f) (memq (cond ((or (eq f (quote true)) (eq f (quote false)))
f) ((pairp (car f)) (caar f)) (t (car f))) (quote (equal neq leq geq lessp
greaterp cong ncong))))

(pasf_congopp lambda (op) (memq op (quote (cong ncong))))

(pasf_equopp lambda (op) (memq op (quote (equal neq))))

(pasf_congp lambda (atf) (and (pairp atf) (pairp (car atf)) (memq (caar atf) (
quote (cong ncong)))))

(pasf_newvar lambda (f) ((lambda (w) (progn (cond (!*rlgensymintern (intern w))
(t (remob w))) w)) (compress (cons (quote !!) (cons (quote !_) (cons (quote k) (
explode (setcdr rlgensymfast!* (plus (cdr rlgensymfast!*) 1)))))))))

(ibalp_subalchk lambda (al) nil)

(ibalp_eqnrhskernels lambda (x) (ibalp_varlt (cdr x)))

(ibalp_prepterm lambda (u) u)

(ibalp_boolfp lambda (op) (memq op (quote (bnot band bor bimpl brepl bequiv))))

(ibalp_resimpterm lambda (u) (ibalp_simpterm u))

(ibalp_prepat lambda (f) f)

(ibalp_op lambda (atf) (car atf))

(ibalp_atfp lambda (f) (memq (car f) (quote (equal neq))))

(ibalp_arg1 lambda (atf) (cadr atf))

(ibalp_arg2l lambda (atf) (cadr atf))

(ibalp_arg2r lambda (atf) (caddr atf))

(ibalp_argn lambda (atf) (cdr atf))

(ibalp_mk2 lambda (op lhs rhs) (list op lhs rhs))

(ibalp_1mk2 lambda (op lhs) (list op lhs 1))

(ibalp_mkn lambda (op argl) (cons op argl))

(ibalp_atab lambda (f) (cl_atab (cl_simpl f nil (minus 1))))

(ibalp_itab lambda (f) (cl_itab (cl_simpl f nil (minus 1))))

(ibalp_ordp lambda (u1 u2) (ordp (list (cons (cons u1 1) 1)) (list (cons (cons
u2 1) 1))))

(ibalp_ordrelp lambda (r1 r2) (not (not (memq r2 (memq r1 (quote (equal neq)))))
))

(ibalp_negatet lambda (u) (cond ((equal u 0) 1) ((equal u 1) 0) (t (list (quote
bnot) u))))

(ibalp_transform lambda (v f vl an theo ans bvl) nil)

(ibalp_trygauss lambda (f v theo ans bvl) (quote failed))

(ibalp_specelim lambda (f vl theo ans bvl) (quote failed))

(ibalp_mkalp lambda (tag l) (cons (list (cons tag l)) (list (cons tag 1))))

(ibalp_qsat!-initoptions lambda nil (ibalp_qsat!-setoptionl (list (quote zmom) 5
1 1.2 200)))

(ibalp_qsat!-getoption lambda (opt) (lto_catsoc opt ibalp_qsatoptions!*))

(ibalp_var!-new lambda (id) (list id nil nil nil 0 0 (minus 1) nil 0 0 nil 0 nil
0 nil))

(ibalp_var!-setval lambda (var val) (setcar (cdr var) val))

(ibalp_var!-setposocc lambda (var posocc) (setcar (cddr var) (cons posocc (caddr
var))))

(ibalp_var!-setnegocc lambda (var negocc) (setcar (cdddr var) (cons negocc (
cadddr var))))

(ibalp_var!-setposoccabs lambda (var posocc) (setcar (cddr var) posocc))

(ibalp_var!-setnegoccabs lambda (var negocc) (setcar (cdddr var) negocc))

(ibalp_var!-setnumpos lambda (var numpos) (setcar (cddddr var) numpos))

(ibalp_var!-setnumneg lambda (var numneg) (setcar (cdr (cddddr var)) numneg))

(ibalp_var!-setlev lambda (var lev) (setcar (cddr (cddddr var)) lev))

(ibalp_var!-setreas lambda (var reas) (setcar (cdddr (cddddr var)) reas))

(ibalp_var!-setposcc lambda (var num) (setcar (cddddr (cddddr var)) num))

(ibalp_var!-setnegcc lambda (var num) (setcar (cdr (cddddr (cddddr var))) num))

(ibalp_var!-setwc lambda (var wc) (setcar (cddr (cddddr (cddddr var))) (cons wc
(caddr (cddddr (cddddr var))))))

(ibalp_var!-setmom lambda (var mom) (setcar (cdddr (cddddr (cddddr var))) mom))

(ibalp_var!-setquant lambda (var quant) (setcar (cddddr (cddddr (cddddr var)))
quant))

(ibalp_var!-setqlevel lambda (var qlevel) (setcar (cdr (cddddr (cddddr (cddddr
var)))) qlevel))

(ibalp_var!-setflip lambda (var flip) (setcar (cddr (cddddr (cddddr (cddddr var)
))) flip))

(ibalp_var!-getid lambda (var) (car var))

(ibalp_var!-getval lambda (var) (cadr var))

(ibalp_var!-getposocc lambda (var) (caddr var))

(ibalp_var!-getnegocc lambda (var) (cadddr var))

(ibalp_var!-getnumpos lambda (var) (car (cddddr var)))

(ibalp_var!-getnumneg lambda (var) (cadr (cddddr var)))

(ibalp_var!-getlev lambda (var) (caddr (cddddr var)))

(ibalp_var!-getreas lambda (var) (cadddr (cddddr var)))

(ibalp_var!-getposcc lambda (var) (car (cddddr (cddddr var))))

(ibalp_var!-getnegcc lambda (var) (cadr (cddddr (cddddr var))))

(ibalp_var!-getwc lambda (var) (caddr (cddddr (cddddr var))))

(ibalp_var!-delwc lambda (var wc) (setcar (cddr (cddddr (cddddr var))) (lto_delq
wc (caddr (cddddr (cddddr var))))))

(ibalp_var!-delallwc lambda (var) (setcar (cddr (cddddr (cddddr var))) nil))

(ibalp_var!-getmom lambda (var) (cadddr (cddddr (cddddr var))))

(ibalp_var!-getquant lambda (var) (car (cddddr (cddddr (cddddr var)))))

(ibalp_var!-isex lambda (var) (eq (car (cddddr (cddddr (cddddr var)))) (quote ex
)))

(ibalp_var!-isuni lambda (var) (eq (car (cddddr (cddddr (cddddr var)))) (quote
all)))

(ibalp_var!-getqlevel lambda (var) (cadr (cddddr (cddddr (cddddr var)))))

(ibalp_var!-getflip lambda (var) (caddr (cddddr (cddddr (cddddr var)))))

(ibalp_clause!-new lambda nil (list nil nil 0 0 nil nil nil))

(ibalp_clause!-setsat lambda (clause sat) (setcar (cddddr clause) (cons sat (car
(cddddr clause)))))

(ibalp_clause!-delallsat lambda (clause) (setcar (cddddr clause) nil))

(ibalp_clause!-setposlit lambda (clause var) (setcar clause (cons var (car
clause))))

(ibalp_clause!-setneglit lambda (clause var) (setcar (cdr clause) (cons var (
cadr clause))))

(ibalp_clause!-setposlitabs lambda (clause var) (setcar clause var))

(ibalp_clause!-setneglitabs lambda (clause var) (setcar (cdr clause) var))

(ibalp_clause!-setactpos lambda (clause actpos) (setcar (cddr clause) actpos))

(ibalp_clause!-setactneg lambda (clause actneg) (setcar (cdddr clause) actneg))

(ibalp_clause!-setcount lambda (clause count) (setcar (cdr (cddddr clause))
count))

(ibalp_clause!-setwl lambda (clause wl) (setcar (cddr (cddddr clause)) (cons wl
(caddr (cddddr clause)))))

(ibalp_clause!-delallwl lambda (clause) (setcar (cddr (cddddr clause)) nil))

(ibalp_clause!-delwl lambda (clause wl) (setcar (cddr (cddddr clause)) (lto_delq
wl (caddr (cddddr clause)))))

(ibalp_clause!-getposlit lambda (clause) (car clause))

(ibalp_clause!-getneglit lambda (clause) (cadr clause))

(ibalp_clause!-getactpos lambda (clause) (caddr clause))

(ibalp_clause!-getactneg lambda (clause) (cadddr clause))

(ibalp_clause!-getsat lambda (clause) (car (cddddr clause)))

(ibalp_clause!-delsat lambda (clause sat) (setcar (cddddr clause) (lto_delq sat
(car (cddddr clause)))))

(ibalp_clause!-getcount lambda (clause) (cadr (cddddr clause)))

(ibalp_clause!-getwl lambda (clause) (caddr (cddddr clause)))

(ibalp_lenisone lambda (l) (and l (null (cdr l))))

(ibalp_commonlenisone lambda (l1 l2) (or (and (null l1) (and l2 (null (cdr l2)))
) (and (null l2) (and l1 (null (cdr l1))))))

(ibalp_emptyclausep lambda (clause) (and (null (car (cddddr clause))) (eqn (
caddr clause) 0) (eqn (cadddr clause) 0)))

(ibalp_csat lambda (clausel) (or (null clausel) (and (car (cddddr (car clausel))
) (ibalp_csat (cdr clausel)))))

(ibalp_cv lambda (varal) (cond ((null (cadr (cdar varal))) (cdar varal)) (t (
ibalp_cv (cdr varal)))))

(ibalp_iscnf lambda (f) (or (ibalp_clausep f) (and (eq (cond ((atom f) f) (t (
car f))) (quote and)) (ibalp_clauselp (cdr f)))))

(ibalp_clausep lambda (s) (or (ibalp_litp s) (and (eq (cond ((atom s) s) (t (car
s))) (quote or)) (ibalp_litlp (cdr s)))))

(ibalp_litp lambda (s) (or (ibalp_atomp s) (and (eq (cond ((atom s) s) (t (car s
))) (quote not)) (ibalp_atomp (cadr s)))))

(ibalp_vequal lambda (v1 v2) (eq (car v1) (car v2)))

(ibalp_qsat!-csat lambda (clausel) (or (null clausel) (and (car (cddddr (car
clausel))) (ibalp_csat (cdr clausel)))))

(dvfsf_susipost lambda (atl knowl) atl)

(dvfsf_susitf lambda (at knowl) at)

(ofsf_op lambda (atf) (car atf))

(ofsf_arg2l lambda (atf) (cadr atf))

(ofsf_arg2r lambda (atf) (caddr atf))

(ofsf_argn lambda (atf) (list (cadr atf) (caddr atf)))

(ofsf_mk2 lambda (op lhs rhs) (list op lhs rhs))

(ofsf_0mk2 lambda (op lhs) (list op lhs nil))

(ofsf_mkn lambda (op argl) (list op (car argl) (cadr argl)))

(ofsf_opp lambda (op) (memq op (quote (lessp leq equal neq geq greaterp))))

(ofsf_preq lambda (a1 a2 b1 b2) (or (and (eq a1 b1) (eq a2 b2)) (and (eq a1 b2)
(eq a2 b1))))

(ofsf_mkalp lambda (tag l) (cons (list (cons tag l)) (list (cons tag 1))))

(ofsf_ceterm1a lambda (m u) (list (list (quote neq) m nil) u))

(ofsf_ceterm2a lambda (a m u) (cond (a (list (cons (quote and) (list (list (
quote equal) a nil) (list (quote neq) m nil))) u)) (t (list (list (quote neq) m
nil) u))))

(ofsf_ceterm1l lambda (a l) (cons (list (quote neq) a nil) l))

(ofsf_ceterm2l lambda (a d l) (cons (cons (quote and) (list (list (quote neq) a
nil) (list (quote geq) d nil))) l))

(ofsf_mktag1 lambda (x) (intern (compress (nconc (explode x) (quote (!1))))))

(ofsf_mktag2 lambda (x y) (intern (compress (nconc (explode x) (cons (quote !2)
(explode y))))))

(ofsf_cvl lambda (x) (car x))

(ofsf_al lambda (x) (cadr x))

(ofsf_pl lambda (x) (caddr x))

(ofsf_an lambda (x) (cdddr x))

(ofsf_mkentry lambda (cvl al pl an) (cons cvl (cons al (cons pl an))))

(ofsf_xopt!-ansl!-mk lambda (l) l)

(ofsf_xopt!-ansl!-ansl lambda (ansl) ansl)

(ofsf_xopt!-ans!-mk lambda (gd pt) (cons gd pt))

(ofsf_xopt!-ans!-gd lambda (ans) (car ans))

(ofsf_xopt!-ans!-pt lambda (ans) (cdr ans))

(ofsf_xopt!-pt!-ctl lambda (pt) pt)

(ofsf_xopt!-pt!-mk lambda (ctl) ctl)

(ofsf_xopt!-ct!-mk lambda (v vl) (cons v vl))

(ofsf_xopt!-ct!-var lambda (ct) (car ct))

(ofsf_xopt!-ct!-value lambda (ct) (cdr ct))

(ofsf_xopt!-co!-mk lambda (cel) cel)

(ofsf_xopt!-co!-cel lambda (co) co)

(ofsf_xopt!-ce!-mk lambda (vl f pt pl) (list vl f pt pl))

(ofsf_xopt!-ce!-vl lambda (ce) (car ce))

(ofsf_xopt!-ce!-f lambda (ce) (cadr ce))

(ofsf_xopt!-ce!-pt lambda (ce) (caddr ce))

(ofsf_xopt!-ce!-pl lambda (ce) (cadddr ce))

(ofsf_xopt!-co!-put lambda (co ce) (cons ce co))

(ofsf_xopt!-co!-get lambda (co) co)

(ofsf_xopt!-co!-length lambda (co) (length co))

(ofsf_xopt!-cs!-mk lambda (ubl lbl eql) (list ubl lbl eql))

(ofsf_xopt!-cs!-ubl lambda (cs) (car cs))

(ofsf_xopt!-cs!-lbl lambda (cs) (cadr cs))

(ofsf_xopt!-cs!-eql lambda (cs) (caddr cs))

(ofsf_xopt!-cp!-mk lambda (p) p)

(ofsf_xopt!-cp!-p lambda (cp) cp)

(ofsf_xopt!-es!-mk lambda (cpl) cpl)

(ofsf_xopt!-es!-cpl lambda (es) es)

(tre_varassp lambda (tre) (eqcar tre (quote rl_varass)))

(tre_declitp lambda (tre) (eqcar tre (quote rl_declit)))

(tre_proplitp lambda (tre) (eqcar tre (quote rl_proplit)))

(tre_litp lambda (tre) (or (eqcar tre (quote rl_proplit)) (eqcar tre (quote
rl_declit))))

(tre_lit lambda (tre) (cadr tre))

(varass_mk lambda (x anu) (list (quote rl_varass) x anu))

(varass_x lambda (va) (nth va 2))

(varass_value lambda (va) (nth va 3))

(ofsfic!*ce_mk lambda (vl f v eterm an fvect) (list (quote ce) vl f v eterm an
fvect))

(ce_fvect lambda (x) (nth (cdr x) 6))

(ofsfic!*co_push2 lambda (co ce) (cons ce co))

(ofsfic!*cl_mk1eqr lambda (f eql) (list (list f eql)))

(cl_identifyathashkey lambda (atf) (cons (cadr atf) (cons (car atf) (cddr atf)))
)

(cl_identifyats lambda (f) (cond (!*rlidentify (cl_apply2ats f (quote
cl_identifyat))) (t f)))

(cl_simplathashkey lambda (atf sop) (cons (cadr atf) (cons (car atf) (cons (cddr
atf) (cons sop (cons rl_cid!* (cons rl_argl!* (siatenv_asinteger))))))))

(ce_mk lambda (vl f v eterm an) (list (quote ce) vl f v eterm an))

(ce_vl lambda (x) (car (cdr x)))

(ce_f lambda (x) (cadr (cdr x)))

(ce_v lambda (x) (caddr (cdr x)))

(ce_eterm lambda (x) (cadddr (cdr x)))

(ce_ans lambda (x) (nth (cdr x) 5))

(co_data lambda (co) (car co))

(co_dynl lambda (co) (cdr co))

(co_setdata lambda (co data) (rplaca co data))

(co_setdynl lambda (co dynl) (rplacd co dynl))

(cl_mkj lambda (f an) (cons f an))

(cl_jf lambda (j) (car j))

(cl_ja lambda (j) (cdr j))

(cl_co2j lambda (x) (cons (cadr (cdr x)) (nth (cdr x) 5)))

(cl_erth lambda (er) (car er))

(cl_ereqr lambda (er) (cdr er))

(cl_mker lambda (theo eqr) (cons theo eqr))

(cl_mk1eqr lambda (f eql) (list (cons f eql)))

(cgb_xvars!-psys lambda (l vl) (cgb_vars l vl))

(cgb_xvars!-psys2 lambda (l cd vl) (cgb_vars l vl))

(cgb_xvars!-psys3 lambda (l cd xvl vl) (cgb_vars l vl))

(cgb_s2s!-cgb lambda (l) (cgb_cgb!-sfl l))

(cgb_s2s!-bra lambda (bra) (list (bra_cd bra) (cgb_cgb!-sfl (bra_system bra))))

(cgb_a2s2!-cd lambda (cd) cd)

(cgb_a2s!-varl lambda (varl) (cdr varl))

(cgb_a2s2!-varl lambda (varl) varl)

(cgb_cleanup lambda (u v) u)

(cgb_tt lambda (s1 s2) (ev_lcm (cgp_evlmon s1) (cgp_evlmon s2)))

(cd_falsep lambda (cd) (eqcar cd (quote false)))

(cpr_mk1 lambda (lcm p1 p2 sugar) (list lcm p1 p2 sugar))

(cpr_lcm lambda (cpr) (car cpr))

(cpr_p1 lambda (cpr) (cadr cpr))

(cpr_p2 lambda (cpr) (caddr cpr))

(cpr_sugar lambda (cpr) (cadddr cpr))

(bra_cd lambda (br) (car br))

(bra_system lambda (br) (cadr br))

(bra_cprl lambda (br) (caddr br))

(bra_mk lambda (cd system cprl) (list cd system cprl))

(bra_ordp lambda (b1 b2) (cd_ordp (car b1) (car b2)))

(gsy_normalize lambda (l) (sort (gsy_normalize1 l) (quote bra_ordp)))

(cgp_mk lambda (hp rp sugar number ci) (list (quote cgp) hp rp sugar number ci))

(cgp_hp lambda (cgp) (cadr cgp))

(cgp_rp lambda (cgp) (caddr cgp))

(cgp_sugar lambda (cgp) (cadddr cgp))

(cgp_number lambda (cgp) (nth cgp 5))

(cgp_init lambda (vars sm sx) (dip_init vars sm sx))

(cgp_cleanup lambda (l) (dip_cleanup l))

(cgp_lbc lambda (u) (dip_lbc (caddr u)))

(cgp_evlmon lambda (u) (dip_evlmon (caddr u)))

(cgp_zerop lambda (u) (and (null (cadr u)) (null (caddr u))))

(cgp_greenp lambda (u) (null (caddr u)))

(cgp_monp lambda (u) (and (null (cadr u)) (dip_monp (caddr u))))

(cgp_zero lambda nil (list (quote cgp) nil nil nil nil (quote zero)))

(cgp_one lambda nil (list (quote cgp) nil (dip_one) 0 nil (quote red)))

(cgp_tdeg lambda (u) (dip_tdeg (caddr u)))

(cgp_mred lambda (cgp) (list (quote cgp) (cadr cgp) (dip_mred (caddr cgp)) (
cadddr cgp) nil (quote unknown)))

(cgp_cp lambda (cgp) (list (quote cgp) (cadr cgp) (caddr cgp) (cadddr cgp) (nth
cgp 5) (cgp_ci cgp)))

(cgp_f2cgp lambda (u) (list (quote cgp) nil (dip_f2dip u) nil nil (quote unknown
)))

(cgp_2a lambda (u) (dip_2a (dip_append (cadr u) (caddr u))))

(cgp_2f lambda (u) (dip_2f (dip_append (cadr u) (caddr u))))

(cgp_enumerate lambda (p) (cgp_setnumber p (setq cgp_pcount!* (iplus2
cgp_pcount!* 1))))

(cgp_unitp lambda (p) (and (caddr p) (ev_zero!? (dip_evlmon (caddr p)))))

(cgp_setnumber lambda (p n) (progn (setcar (pnth p 5) n) p))

(cgp_setsugar lambda (p s) (progn (setcar (pnth p 4) s) p))

(cgp_setci lambda (p tg) (progn (setcar (pnth p 6) tg) p))

(cgp_shift!-gen lambda (p) p)

(cgp_comp lambda (p1 p2) (dip_comp (caddr p1) (caddr p2)))

(gb_s2s!-gb lambda (l) (gb_gb!-sfl l))

(gb_a2s!-pol lambda (p) (car (simp (reval1 p t))))

(gb_a2s2!-pol lambda (p) (vdp_f2vdp p))

(gb_s2a!-pol lambda (p) (vdp_2a p))

(gb_s2s!-pol lambda (p) (vdp_2sq p))

(gb_dummy1 lambda (dummy) nil)

(gb_xvars!-psys lambda (l vl) (gb_vars l vl))

(gb_xvars!-psys2 lambda (l cd vl) (gb_vars l vl))

(gb_xvars!-psys3 lambda (l cd xvarl vl) (gb_vars l vl))

(gb_xvars!-ppsys lambda (p l vl) (gb_vars (cons p l) vl))

(gb_cleanup lambda (u v) u)

(gb_tt lambda (s1 s2) (ev_lcm (vdp_evlmon s1) (vdp_evlmon s2)))

(gb_gbggsys0 lambda (p dummy dummy1) (gb_gbgsys p))

(gb_gbgsys0 lambda (p dummy) (gb_gbgsys p))

(gb_gbgsys lambda (p) (list (list nil (gb_gb p) nil)))

(gb_gb0 lambda (p dummy) (gb_gb p))

(gb_buchcrit4t lambda (e1 e2) (not (ev_disjointp e1 e2)))

(gb_buch!-ev_divides!? lambda (vev1 vev2) (ev_mtest!? vev2 vev1))

(gb_min!# lambda (a b) (cond ((ilessp a b) a) (t b)))

(vdp_lbc lambda (u) (caddr u))

(vdp_evlmon lambda (u) (cadr u))

(vdp_poly lambda (u) (car (cdddr u)))

(vdp_zero!? lambda (u) (null (car (cdddr u))))

(vdp_plist lambda (u) (cadr (cdddr u)))

(vdp_number lambda (f) (or (vdp_getprop f (quote number)) 0))

(vdp_unit!? lambda (p) (and (not (null (car (cdddr p)))) (ev_zero!? (cadr p))))

(vdp_make lambda (vbc vev form) (list (quote vdp) vev vbc form nil))

(vdp_monp lambda (u) (dip_monp (car (cdddr u))))

(vdp_tdeg lambda (u) (dip_tdeg (car (cdddr u))))

(vdp_content lambda (p) (dip_contenti (car (cdddr p))))

(vdp_content1 lambda (d c) (dip_contenti1 (car (cdddr d)) c))

(vdp_length lambda (f) (dip_length (car (cdddr f))))

(vdp_zero lambda nil (list (quote vdp) (quote invalid) (quote invalid) nil nil))

(vdp_condense lambda (f) (dip_condense (car (cdddr f))))

(vdp_setnumber lambda (p n) (vdp_putprop p (quote number) n))

(vdp_2a lambda (u) (dip_2a (car (cdddr u))))

(vdp_2f lambda (u) (dip_2f (car (cdddr u))))

(vdp_2sq lambda (u) (dip_2sq (car (cdddr u))))

(vdp_init lambda (vars sm sx) (dip_init vars sm sx))

(vdp_evlcomp lambda (p1 p2) (dip_evlcomp (car (cdddr p1)) (car (cdddr p2))))

(bc_zero lambda nil (cons nil 1))

(bc_zero!? lambda (u) (null (car u)))

(bc_abs lambda (u) (cons (absf (car u)) (cdr u)))

(bc_one!? lambda (u) (and (equal (car u) 1) (equal (cdr u) 1)))

(bc_2sq lambda (u) u)

(bc_a2bc lambda (u) (simp!* u))

(bc_fd lambda (a) (cons a 1))

(bc_neg lambda (u) (negsq u))

(bc_quot lambda (a b) (multsq a (invsq b)))

(bc_2a lambda (u) (prepsq u))

(bc_mkat lambda (op bc) (list op (car bc) nil))

(bc_dcont lambda (bc) (sfto_dcontentf (car bc)))

(bc_2d lambda (bc) (or (car bc) 0))

(ev_max!# lambda (a b) (cond ((igreaterp a b) a) (t b)))

(ev_init lambda nil nil)

(ev_member lambda (ev evl) (member ev evl))

(ev_divides!? lambda (ev1 ev2) (ev_mtest!? ev2 ev1))

(ev_sdivp lambda (ev1 ev2) (and (neq ev1 ev2) (ev_mtest!? ev2 ev1)))

(ev_2a lambda (e) (ev_2a1 e dip_vars!*))

(ev_compless!? lambda (e1 e2) (iequal (ev_comp e2 e1) 1))

(dip_fmon lambda (a e) (cons e (cons a nil)))

(dip_moncomp lambda (a e p) (cons e (cons a p)))

(dip_mred lambda (p) (cddr p))

(dip_lbc lambda (p) (cadr p))

(dip_evlmon lambda (p) (car p))

(dip_monp lambda (u) (and u (not (cddr u))))

(dip_2f lambda (u) (car (dip_2sq u)))

(dip_f2dip lambda (u) (dip_f2dip1 u (ev_zero) (cons 1 1)))

(dip_2a lambda (u) (cond ((null u) 0) (t (dip_replus (dip_2a1 u)))))

(dip_contenti lambda (p) (dip_contenti1 p (cons nil 1)))

(dip_condense lambda (f) f)

(dip_append lambda (p1 p2) (append p1 p2))

(dip_comp1 lambda (p1 p2) (ev_comp (car p1) (car p2)))

(dip_one lambda nil (cons (ev_zero) (cons (simp!* 1) nil)))

(rl_op lambda (f) (cond ((atom f) f) (t (car f))))

(rl_arg1 lambda (f) (cadr f))

(rl_arg2l lambda (f) (cadr f))

(rl_arg2r lambda (f) (caddr f))

(rl_argn lambda (f) (cdr f))

(rl_var lambda (f) (cadr f))

(rl_mat lambda (f) (caddr f))

(rl_b lambda (f) (cadddr f))

(rl_mk1 lambda (uop arg) (list uop arg))

(rl_mk2 lambda (bop larg rarg) (list bop larg rarg))

(rl_mkn lambda (nop argl) (cons nop argl))

(rl_smkn lambda (nop argl) (cond ((and argl (cdr argl)) (cons nop argl)) ((null
argl) (cond ((eq nop (quote and)) (quote true)) (t (quote false)))) (t (car argl
))))

(rl_mkq lambda (q v m) (list q v m))

(rl_mkbq lambda (q v b m) (list q v m b))

(rl_quap lambda (x) (or (eq x (quote ex)) (eq x (quote all))))

(rl_bquap lambda (x) (or (eq x (quote bex)) (eq x (quote ball))))

(rl_junctp lambda (x) (or (eq x (quote or)) (eq x (quote and))))

(rl_basbp lambda (x) (or (or (eq x (quote or)) (eq x (quote and))) (eq x (quote
not))))

(rl_extbp lambda (x) (or (eq x (quote impl)) (eq x (quote repl)) (eq x (quote
equiv))))

(rl_boolp lambda (x) (or (or (or (eq x (quote or)) (eq x (quote and))) (eq x (
quote not))) (or (eq x (quote impl)) (eq x (quote repl)) (eq x (quote equiv)))))

(rl_tvalp lambda (x) (or (eq x (quote true)) (eq x (quote false))))

(rl_cxp lambda (x) (or (or (eq x (quote true)) (eq x (quote false))) (or (or (or
(eq x (quote or)) (eq x (quote and))) (eq x (quote not))) (or (eq x (quote impl)
) (eq x (quote repl)) (eq x (quote equiv)))) (or (eq x (quote ex)) (eq x (quote
all))) (or (eq x (quote bex)) (eq x (quote ball)))))

(lto_hashid lambda (id) (id2int id))

(lto_fastgensym lambda nil ((lambda (w) (progn (cond (!*rlgensymintern (intern w
)) (t (remob w))) w)) (compress (cons (quote !!) (cons (quote !_) (cons (quote k
) (explode (setcdr rlgensymfast!* (plus (cdr rlgensymfast!*) 1)))))))))

(lto_gensym lambda nil (lto_gensym1 rlgensymbase!*))

(rl_skipequal lambda (proc) (progn (scan) (cond ((neq cursym!* (quote equal)) (
rederr (list "expecting '=' in" proc "but found" cursym!*))))))

(rl_skiplcbkt lambda (proc) (progn (scan) (cond ((neq cursym!* (quote !*lcbkt!*)
) (rederr (list "expecting '{' in, " proc "but found" cursym!*))))))

(defint_gw lambda (u) (caar u))

(defint_gl lambda (u) (caadar u))

(defint_gk lambda (u) (cdadar u))

(defint_gr lambda (u) (cadar u))

(defint_gm lambda (u) (caadr u))

(defint_gn lambda (u) (cadadr u))

(defint_gp lambda (u) (caddr (cadr u)))

(defint_gq lambda (u) (cadddr (cadr u)))

(defint_ga lambda (u) (caddr u))

(defint_gb lambda (u) (cadddr u))

(sumlistsq lambda (u) ((lambda (p) (progn (prog (pp) (setq pp u) lab (cond ((
null pp) (return nil))) ((lambda (pp) (progn (setq p (addsq pp p)))) (car pp)) (
setq pp (cdr pp)) (go lab)) p)) (quote (nil . 1))))

(limit!-factrprep lambda (p) ((lambda (!*factor) (prepsq (simp!* p))) t))

(rands lambda (e) (cdr e))

(rand1 lambda (e) (cadr e))

(rand2 lambda (e) (caddr e))

(rand3 lambda (e) (cadddr e))

(rator lambda (e) (car e))

(ps!:domainp lambda (u) (or (atom u) (and (neq (car u) (quote !:ps!:)) (not (
listp u)))))

(ps!:p lambda (u) (and (pairp u) (equal (car u) (quote !:ps!:))))

(ps!:atom lambda (u) (or (atom u) (and (neq (car u) (quote !:ps!:)) (get (car u)
(quote dname)))))

(ps!:numberp lambda (u) (or (numberp u) (and (pairp u) (neq (car u) (quote
!:ps!:)) (get (car u) (quote dname)))))

(ps!:set!-order lambda (ps n) (ps!:putv ps 0 n))

(ps!:set!-last!-term lambda (ps n) (ps!:putv ps 1 n))

(ps!:set!-depvar lambda (ps x) (ps!:putv ps 2 x))

(ps!:set!-expansion!-point lambda (ps x) (ps!:putv ps 3 x))

(ps!:set!-value lambda (ps x) (ps!:putv ps 4 x))

(ps!:terms lambda (ps) (cond ((or (atom ps) (and (neq (car ps) (quote !:ps!:)) (
get (car ps) (quote dname)))) (list (cons 0 (cons ps 1)))) (t (ps!:getv ps 5))))

(ps!:set!-terms lambda (ps x) (ps!:putv ps 5 x))

(ps!:set!-expression lambda (ps x) (ps!:putv ps 6 x))

(ps!:operator lambda (ps) (car (ps!:getv ps 6)))

(ps!:operands lambda (ps) (cdr (ps!:getv ps 6)))

(i2ps lambda (u) u)

(ps!:minusp!: lambda (u) nil)

(ps!:plus!: lambda (u v) (ps!:operator!: (quote plus) u v))

(ps!:difference!: lambda (u v) (ps!:operator!: (quote difference) u v))

(ps!:times!: lambda (u v) (ps!:operator!: (quote times) u v))

(ps!:quotient!: lambda (u v) (ps!:operator!: (quote quotient) u v))

(ps!:zerop!: lambda (u) ((lambda (v) (and (numberp v) (zerop v))) (ps!:value u))
)

(ps!:onep!: lambda (u) (onep (ps!:value u)))

(ps!:prepfn!: lambda (u) u)

(ps!:get!-rthpow lambda (genseries r) (ps!:get!-term genseries r))

(mksqnew lambda (u) (cons (list (cons (cons (car (fkern u)) 1) 1)) 1))

(gamsq lambda (u) (cons (list (cons (cons (car (fkern (list (quote gamma) (
prepsq u)))) 1) 1)) 1))

(multgamma lambda (u) ((lambda (p) (progn (prog (pp) (setq pp u) lab (cond ((
null pp) (return nil))) ((lambda (pp) (progn (setq p (multsq (cons (list (cons (
cons (car (fkern (list (quote gamma) (prepsq pp)))) 1) 1)) 1) p)))) (car pp)) (
setq pp (cdr pp)) (go lab)) p)) (quote (1 . 1))))

(besssq lambda (v u) (cons (list (cons (cons (car (fkern (list (quote besselj) (
prepsq v) (prepsq u)))) 1) 1)) 1))

(bessmsq lambda (v u) (cons (list (cons (cons (car (fkern (list (quote besseli)
(prepsq v) (prepsq u)))) 1) 1)) 1))

(simppochh lambda (v u) (cons (list (cons (cons (car (fkern (list (quote
pochhammer) (prepsq v) (prepsq u)))) 1) 1)) 1))

(psisq lambda (v) (cons (list (cons (cons (car (fkern (list (quote psi) (prepsq
v)))) 1) 1)) 1))

(difflist lambda (u v) (prog (uu forall!-result forall!-endptr) (setq uu u) (
cond ((null uu) (return nil))) (setq forall!-result (setq forall!-endptr (cons (
(lambda (uu) (addsq uu (negsq v))) (car uu)) nil))) looplabel (setq uu (cdr uu))
(cond ((null uu) (return forall!-result))) (rplacd forall!-endptr (cons ((lambda
(uu) (addsq uu (negsq v))) (car uu)) nil)) (setq forall!-endptr (cdr
forall!-endptr)) (go looplabel)))

(listsq lambda (u) (prog (uu forall!-result forall!-endptr) (setq uu u) (cond ((
null uu) (return nil))) (setq forall!-result (setq forall!-endptr (cons ((lambda
(uu) (simp!* uu)) (car uu)) nil))) looplabel (setq uu (cdr uu)) (cond ((null uu)
(return forall!-result))) (rplacd forall!-endptr (cons ((lambda (uu) (simp!* uu)
) (car uu)) nil)) (setq forall!-endptr (cdr forall!-endptr)) (go looplabel)))

(listmin lambda (u) (prog (uu forall!-result forall!-endptr) (setq uu u) (cond (
(null uu) (return nil))) (setq forall!-result (setq forall!-endptr (cons ((
lambda (uu) (negsq uu)) (car uu)) nil))) looplabel (setq uu (cdr uu)) (cond ((
null uu) (return forall!-result))) (rplacd forall!-endptr (cons ((lambda (uu) (
negsq uu)) (car uu)) nil)) (setq forall!-endptr (cdr forall!-endptr)) (go
looplabel)))

(multlist lambda (u) ((lambda (p) (progn (prog (pp) (setq pp u) lab (cond ((null
pp) (return nil))) ((lambda (pp) (progn (setq p (multsq pp p)))) (car pp)) (setq
pp (cdr pp)) (go lab)) p)) (quote (1 . 1))))

(pdifflist lambda (u v) (prog (vv forall!-result forall!-endptr) (setq vv v) (
cond ((null vv) (return nil))) (setq forall!-result (setq forall!-endptr (cons (
(lambda (vv) (addsq u (negsq vv))) (car vv)) nil))) looplabel (setq vv (cdr vv))
(cond ((null vv) (return forall!-result))) (rplacd forall!-endptr (cons ((lambda
(vv) (addsq u (negsq vv))) (car vv)) nil)) (setq forall!-endptr (cdr
forall!-endptr)) (go looplabel)))

(heavisidesq lambda (u) (cons (list (cons (cons (car (fkern (list (quote
heaviside) (prepsq u)))) 1) 1)) 1))

(struvelsq lambda (v u) (cons (list (cons (cons (car (fkern (list (quote struvel
) (prepsq v) (prepsq u)))) 1) 1)) 1))

(struvehsq lambda (v u) (cons (list (cons (cons (car (fkern (list (quote struveh
) (prepsq v) (prepsq u)))) 1) 1)) 1))

(neumsq lambda (v u) (cons (list (cons (cons (car (fkern (list (quote bessely) (
prepsq v) (prepsq u)))) 1) 1)) 1))

(dfpsisq lambda (v u) (cons (list (cons (cons (car (fkern (list (quote polygamma
) (prepsq u) (prepsq v)))) 1) 1)) 1))

(lommel2sq lambda (u v w) (cons (list (cons (cons (car (fkern (list (quote
lommel2) (prepsq u) (prepsq v) (prepsq w)))) 1) 1)) 1))

(tricomisq lambda (u v w) (cons (list (cons (cons (car (fkern (list (quote
kummeru) (prepsq u) (prepsq v) (prepsq w)))) 1) 1)) 1))

(macdsq lambda (v u) (cons (list (cons (cons (car (fkern (list (quote besselk) (
prepsq v) (prepsq u)))) 1) 1)) 1))

(sumlist lambda (u) ((lambda (p) (progn (prog (pp) (setq pp u) lab (cond ((null
pp) (return nil))) ((lambda (pp) (progn (setq p (addsq (simp pp) p)))) (car pp))
(setq pp (cdr pp)) (go lab)) p)) (quote (nil . 1))))

(listprepsq lambda (u) (prog (uu forall!-result forall!-endptr) (setq uu u) (
cond ((null uu) (return nil))) (setq forall!-result (setq forall!-endptr (cons (
(lambda (uu) (prepsq uu)) (car uu)) nil))) looplabel (setq uu (cdr uu)) (cond ((
null uu) (return forall!-result))) (rplacd forall!-endptr (cons ((lambda (uu) (
prepsq uu)) (car uu)) nil)) (setq forall!-endptr (cdr forall!-endptr)) (go
looplabel)))

(ghyper_fehlerf lambda nil (rerror (quote specialf) 139
"Wrong arguments to hypergeometric"))

(meijerg_fehler lambda nil (rerror (quote specialf) 140
"Wrong arguments to operator MeijerG"))

(priznak lambda (u v) (prog (uu forall!-result forall!-endptr) (setq uu u) (cond
((null uu) (return nil))) (setq forall!-result (setq forall!-endptr (cons ((
lambda (uu) (cons uu v)) (car uu)) nil))) looplabel (setq uu (cdr uu)) (cond ((
null uu) (return forall!-result))) (rplacd forall!-endptr (cons ((lambda (uu) (
cons uu v)) (car uu)) nil)) (setq forall!-endptr (cdr forall!-endptr)) (go
looplabel)))

(sq2bf!* lambda (x) (cond ((fixp x) (cons (quote !:rd!:) (cons x 0))) (t ((
lambda (y) (cond ((neq (car y) (quote !:rd!:)) ((lambda (u) (cond ((atom u) u) (
t (cons (quote !:rd!:) u)))) (cdr (!*rn2rd y)))) (t (cond ((atom (cdr y)) (cdr y
)) (t (cons (quote !:rd!:) (cdr y))))))) (!*q2f (simp!* x))))))

(prload lambda nil nil)

(xmember lambda (u v) (reverse (member u (reverse v))))

(appends lambda (u v w) (append u (append v w)))

(leqgrt lambda (l i j) (or (and (leq i j) (eqn l i)) (geq i (add1 j))))

(fidep lambda (u) (and (assoc u depl!*) (cdr (assoc u depl!*))))

(terpri2 lambda nil (progn (terpri) (terpri)))

(lcf lambda (u) (and (not (or (atom u) (atom (car u)))) (cdar u)))

(minus!-f lambda (u) (minusf (car (simp (reval1 u t)))))

(diford lambda (u) (lengthn (cddr u)))

(solvef lambda (u v) (car (solve0 (prepf u) v)))

(comfacn lambda (u) (lnc (ckrn u)))

(remfacn lambda (u) ((lambda (!*exp) (quotf1 u (lnc (ckrn u)))) t))

(numgen lambda nil (length (get (quote gen) (quote kvalue))))

(matsm1!-xsimp lambda (u) (cond ((not (lchk (cdr u))) (rerror (quote matrix) 3
"Matrix mismatch")) (t (prog (j forall!-result forall!-endptr) (setq j (cdr u))
(cond ((null j) (return nil))) (setq forall!-result (setq forall!-endptr (cons (
(lambda (j) (prog (k forall!-result forall!-endptr) (setq k j) (cond ((null k) (
return nil))) (setq forall!-result (setq forall!-endptr (cons ((lambda (k) (
xsimp k)) (car k)) nil))) looplabel (setq k (cdr k)) (cond ((null k) (return
forall!-result))) (rplacd forall!-endptr (cons ((lambda (k) (xsimp k)) (car k))
nil)) (setq forall!-endptr (cdr forall!-endptr)) (go looplabel))) (car j)) nil))
) looplabel (setq j (cdr j)) (cond ((null j) (return forall!-result))) (rplacd
forall!-endptr (cons ((lambda (j) (prog (k forall!-result forall!-endptr) (setq
k j) (cond ((null k) (return nil))) (setq forall!-result (setq forall!-endptr (
cons ((lambda (k) (xsimp k)) (car k)) nil))) looplabel (setq k (cdr k)) (cond ((
null k) (return forall!-result))) (rplacd forall!-endptr (cons ((lambda (k) (
xsimp k)) (car k)) nil)) (setq forall!-endptr (cdr forall!-endptr)) (go
looplabel))) (car j)) nil)) (setq forall!-endptr (cdr forall!-endptr)) (go
looplabel)))))

(sparsemat!-xsimp lambda (u) (prog (rows new oldrow) (setq rows 0) (setq rows (
sprow_dim u)) (setq new (mkempspmat rows (caddr u))) (prog (i) (setq i 1) lab (
cond ((minusp (difference rows i)) (return nil))) (progn (setq oldrow (getv (
cadr u) i)) (cond ((not (null oldrow)) (putv (cadr new) i (cons (list nil) (prog
(el forall!-result forall!-endptr) (setq el (cdr oldrow)) (cond ((null el) (
return nil))) (setq forall!-result (setq forall!-endptr (cons ((lambda (el) (
cons (car el) (expchk (cdr el)))) (car el)) nil))) looplabel (setq el (cdr el))
(cond ((null el) (return forall!-result))) (rplacd forall!-endptr (cons ((lambda
(el) (cons (car el) (expchk (cdr el)))) (car el)) nil)) (setq forall!-endptr (
cdr forall!-endptr)) (go looplabel)))))) nil) (setq i (plus2 i 1)) (go lab)) (
return new)))

(sparsemat!-subs2 lambda (u) (prog (rows new oldrow) (setq rows 0) (setq rows (
sprow_dim u)) (setq new (mkempspmat rows (caddr u))) (prog (i) (setq i 1) lab (
cond ((minusp (difference rows i)) (return nil))) (progn (setq oldrow (getv (
cadr u) i)) (cond ((not (null oldrow)) (putv (cadr new) i (cons (list nil) (prog
(el forall!-result forall!-endptr) (setq el (cdr oldrow)) (cond ((null el) (
return nil))) (setq forall!-result (setq forall!-endptr (cons ((lambda (el) (
cons (car el) (progn (setq !*sub2 t) (mk!*sq (subs2 (simp (cdr el))))))) (car el
)) nil))) looplabel (setq el (cdr el)) (cond ((null el) (return forall!-result))
) (rplacd forall!-endptr (cons ((lambda (el) (cons (car el) (progn (setq !*sub2
t) (mk!*sq (subs2 (simp (cdr el))))))) (car el)) nil)) (setq forall!-endptr (cdr
forall!-endptr)) (go looplabel)))))) nil) (setq i (plus2 i 1)) (go lab)) (return
new)))

(scope_row lambda (x) (getv codmat (plus maxvar x)))

(scope_free lambda (x) (getv (getv codmat (plus maxvar x)) 0))

(scope_wght lambda (x) (getv (getv codmat (plus maxvar x)) 1))

(awght lambda (x) (caar (getv (getv codmat (plus maxvar x)) 1)))

(scope_mwght lambda (x) (cdar (getv (getv codmat (plus maxvar x)) 1)))

(scope_hwght lambda (x) (cdr (getv (getv codmat (plus maxvar x)) 1)))

(scope_opval lambda (x) (getv (getv codmat (plus maxvar x)) 2))

(scope_farvar lambda (x) (getv (getv codmat (plus maxvar x)) 3))

(scope_zstrt lambda (x) (getv (getv codmat (plus maxvar x)) 4))

(scope_chrow lambda (x) (getv (getv codmat (plus maxvar x)) 5))

(scope_expcof lambda (x) (getv (getv codmat (plus maxvar x)) 6))

(scope_hir lambda (x) (getv (getv codmat (plus maxvar x)) 7))

(scope_phir lambda (x) (car (getv (getv codmat (plus maxvar x)) 7)))

(scope_nhir lambda (x) (cdr (getv (getv codmat (plus maxvar x)) 7)))

(scope_fillrow lambda (x v) (putv codmat (plus maxvar x) v))

(scope_setoccup lambda (x) (putv (getv codmat (plus maxvar x)) 0 nil))

(scope_setfree lambda (x) (putv (getv codmat (plus maxvar x)) 0 t))

(scope_setwght lambda (x v) (putv (getv codmat (plus maxvar x)) 1 v))

(scope_setopval lambda (x v) (putv (getv codmat (plus maxvar x)) 2 v))

(scope_setfarvar lambda (x v) (putv (getv codmat (plus maxvar x)) 3 v))

(scope_setzstrt lambda (x v) (putv (getv codmat (plus maxvar x)) 4 v))

(scope_setchrow lambda (x v) (putv (getv codmat (plus maxvar x)) 5 v))

(scope_setexpcof lambda (x v) (putv (getv codmat (plus maxvar x)) 6 v))

(scope_sethir lambda (x v) (putv (getv codmat (plus maxvar x)) 7 v))

(scope_setphir lambda (x v) (rplaca (getv (getv codmat (plus maxvar x)) 7) v))

(scope_setnhir lambda (x v) (rplacd (getv (getv codmat (plus maxvar x)) 7) v))

(xind lambda (z) (car z))

(yind lambda (z) (car z))

(val lambda (z) (cdr z))

(ival lambda (z) (car (cdr z)))

(bval lambda (z) (cdr (cdr z)))

(setival lambda (z v) (rplaca (cdr z) v))

(setbval lambda (z v) (rplacd (cdr z) v))

(mkzel lambda (n iv) (cond ((or (idp iv) (constp iv)) (cons n (cons iv nil))) (t
(cons n iv))))

(ordr lambda (x) (getv (getv codmat (plus maxvar x)) 8))

(setordr lambda (x l) (putv (getv codmat (plus maxvar x)) 8 l))

(histo lambda (x) (getv codhisto x))

(sethisto lambda (x v) (putv codhisto x v))

(protected lambda (a pn) (member (cond ((atom a) a) (t (car a))) pn))

(find!+var lambda (var fa iv) (getcind var (quote varlst!+) (quote plus) fa iv))

(find!*var lambda (var fa iv) (getcind var (quote varlst!*) (quote times) fa iv)
)

(testprow lambda (y opv) (and (getv (getv codmat (plus maxvar y)) 0) (eq (getv (
getv codmat (plus maxvar y)) 2) opv)))

(protect lambda (n pn) (cond ((member (cond ((atom n) n) (t (car n))) pn) pn) (t
(cons (cond ((atom n) n) (t (car n))) pn))))

(nil2zero lambda (u) (cond ((null u) 0) (t u)))

(bind lambda (u v) (put u (quote binding) (cons v (get u (quote binding)))))

(binding lambda (u) ((lambda (x) (cond (x (car x)))) (get u (quote binding))))

(unbind lambda (u) (put u (quote binding) (cdr (get u (quote binding)))))

(newenv lambda (u) (put u (quote binding) (cons (quote unbound) (get u (quote
binding)))))

(restorenv lambda (u) (put u (quote binding) (cdr (get u (quote binding)))))

(pm!:free lambda (u) (eq ((lambda (x) (cond (x (car x)))) (get u (quote binding)
)) (quote unbound)))

(bound lambda (u) ((lambda (x) (and x (neq x (quote unbound)))) ((lambda (x) (
cond (x (car x)))) (get u (quote binding)))))

(meq lambda (u v) ((lambda (x) (equal (cond ((and x (neq x (quote unbound))) x)
(t u)) v)) ((lambda (x) (cond (x (car x)))) (get u (quote binding)))))

(mval lambda (u) u)

(ident lambda (op) (get op (quote identity)))

(genp lambda (u) (and (atom u) (or (get u (quote gen)) (mgenp u))))

(mgenp lambda (u) (and (atom u) (get u (quote mgen))))

(suchp lambda (u) (and (not (atom u)) (eq (car u) (quote such!-that))))

(my_reval lambda (n) (cond ((fixp n) n) (t (reval1 n t))))

(my_revlis lambda (u) (prog (j forall!-result forall!-endptr) (setq j u) (cond (
(null j) (return nil))) (setq forall!-result (setq forall!-endptr (cons ((lambda
(j) (cond ((fixp j) j) (t (reval1 j t)))) (car j)) nil))) looplabel (setq j (cdr
j)) (cond ((null j) (return forall!-result))) (rplacd forall!-endptr (cons ((
lambda (j) (cond ((fixp j) j) (t (reval1 j t)))) (car j)) nil)) (setq
forall!-endptr (cdr forall!-endptr)) (go looplabel)))

(my_minus lambda (u) (cond ((atom u) (list (quote minus) u)) ((equal (car u) (
quote minus)) (cadr u)) (t (list (quote minus) u))))

(smplx_prepsq lambda (u) (cond ((atom u) u) ((and (equal (car u) (quote minus))
(atom (cadr u))) u) ((and (equal (car u) (quote minus)) (equal (caadr u) (quote
!*sq))) (list (quote minus) (car (cadadr u)))) ((and (equal (car u) (quote minus
)) (equal (caadr u) (quote !:rd!:))) u) ((equal (car u) (quote !:rd!:)) u) ((
equal (car u) (quote !*sq)) (prepsq (cadr u)))))

(fast_row_dim lambda (in_mat) (idifference (length in_mat) 1))

(fast_column_dim lambda (in_mat) (length (cadr in_mat)))

(fast_stack_rows lambda (in_mat row_list) (cons (quote mat) (list (nth (cdr
in_mat) row_list))))

(fast_getmat lambda (matri i j) (fast_unchecked_getmatelem (list matri i j)))

(fast_my_letmtr lambda (u v y) (rplaca (pnth (nth (cdr y) (car (prog (j
forall!-result forall!-endptr) (setq j (cdr u)) (cond ((null j) (return nil))) (
setq forall!-result (setq forall!-endptr (cons ((lambda (j) (cond ((fixp j) j) (
t (reval1 j t)))) (car j)) nil))) looplabel (setq j (cdr j)) (cond ((null j) (
return forall!-result))) (rplacd forall!-endptr (cons ((lambda (j) (cond ((fixp
j) j) (t (reval1 j t)))) (car j)) nil)) (setq forall!-endptr (cdr forall!-endptr
)) (go looplabel)))) (cadr (prog (j forall!-result forall!-endptr) (setq j (cdr
u)) (cond ((null j) (return nil))) (setq forall!-result (setq forall!-endptr (
cons ((lambda (j) (cond ((fixp j) j) (t (reval1 j t)))) (car j)) nil)))
looplabel (setq j (cdr j)) (cond ((null j) (return forall!-result))) (rplacd
forall!-endptr (cons ((lambda (j) (cond ((fixp j) j) (t (reval1 j t)))) (car j))
nil)) (setq forall!-endptr (cdr forall!-endptr)) (go looplabel)))) v))

(mksq!*mat lambda (in_mat) (prog (tmp_mat out_mat) (setq tmp_mat (cdr in_mat)) (
setq out_mat (prog (u forall!-result forall!-endptr) (setq u tmp_mat) (cond ((
null u) (return nil))) (setq forall!-result (setq forall!-endptr (cons ((lambda
(u) (prog (v forall!-result forall!-endptr) (setq v u) (cond ((null v) (return
nil))) (setq forall!-result (setq forall!-endptr (cons ((lambda (v) (cond ((atom
v) v) (t (mk!*sq v)))) (car v)) nil))) looplabel (setq v (cdr v)) (cond ((null v
) (return forall!-result))) (rplacd forall!-endptr (cons ((lambda (v) (cond ((
atom v) v) (t (mk!*sq v)))) (car v)) nil)) (setq forall!-endptr (cdr
forall!-endptr)) (go looplabel))) (car u)) nil))) looplabel (setq u (cdr u)) (
cond ((null u) (return forall!-result))) (rplacd forall!-endptr (cons ((lambda (
u) (prog (v forall!-result forall!-endptr) (setq v u) (cond ((null v) (return
nil))) (setq forall!-result (setq forall!-endptr (cons ((lambda (v) (cond ((atom
v) v) (t (mk!*sq v)))) (car v)) nil))) looplabel (setq v (cdr v)) (cond ((null v
) (return forall!-result))) (rplacd forall!-endptr (cons ((lambda (v) (cond ((
atom v) v) (t (mk!*sq v)))) (car v)) nil)) (setq forall!-endptr (cdr
forall!-endptr)) (go looplabel))) (car u)) nil)) (setq forall!-endptr (cdr
forall!-endptr)) (go looplabel))) (return (cons (quote mat) out_mat))))

(reval!*mat lambda (in_mat) (prog (tmp_mat out_mat) (setq tmp_mat (cdr in_mat))
(setq out_mat (prog (u forall!-result forall!-endptr) (setq u tmp_mat) (cond ((
null u) (return nil))) (setq forall!-result (setq forall!-endptr (cons ((lambda
(u) (prog (v forall!-result forall!-endptr) (setq v u) (cond ((null v) (return
nil))) (setq forall!-result (setq forall!-endptr (cons ((lambda (v) (cond ((fixp
v) v) (t (reval1 v t)))) (car v)) nil))) looplabel (setq v (cdr v)) (cond ((null
v) (return forall!-result))) (rplacd forall!-endptr (cons ((lambda (v) (cond ((
fixp v) v) (t (reval1 v t)))) (car v)) nil)) (setq forall!-endptr (cdr
forall!-endptr)) (go looplabel))) (car u)) nil))) looplabel (setq u (cdr u)) (
cond ((null u) (return forall!-result))) (rplacd forall!-endptr (cons ((lambda (
u) (prog (v forall!-result forall!-endptr) (setq v u) (cond ((null v) (return
nil))) (setq forall!-result (setq forall!-endptr (cons ((lambda (v) (cond ((fixp
v) v) (t (reval1 v t)))) (car v)) nil))) looplabel (setq v (cdr v)) (cond ((null
v) (return forall!-result))) (rplacd forall!-endptr (cons ((lambda (v) (cond ((
fixp v) v) (t (reval1 v t)))) (car v)) nil)) (setq forall!-endptr (cdr
forall!-endptr)) (go looplabel))) (car u)) nil)) (setq forall!-endptr (cdr
forall!-endptr)) (go looplabel))) (return (cons (quote mat) out_mat))))

(term lambda (c v e) (list (quote times) c (list (quote expt) v e)))

(varp lambda (m) (or (and (idp m) m) (and (pairp m) (equal (get (car m) (quote
simpfn)) (quote simpiden)))))

(checkexpt lambda (m) (and (eqcar m (quote expt)) (or (and (idp (cadr m)) (cadr
m)) (and (pairp (cadr m)) (equal (get (car (cadr m)) (quote simpfn)) (quote
simpiden)))) (numberp (caddr m))))

(checksinglevar lambda (m) (cond ((or (and (idp m) m) (and (pairp m) (equal (get
(car m) (quote simpfn)) (quote simpiden)))) t) (t (and (eqcar m (quote expt)) (
or (and (idp (cadr m)) (cadr m)) (and (pairp (cadr m)) (equal (get (car (cadr m)
) (quote simpfn)) (quote simpiden)))) (numberp (caddr m))))))

(checkmon lambda (m) (cond ((cond ((or (and (idp m) m) (and (pairp m) (equal (
get (car m) (quote simpfn)) (quote simpiden)))) t) (t (and (eqcar m (quote expt)
) (or (and (idp (cadr m)) (cadr m)) (and (pairp (cadr m)) (equal (get (car (cadr
m)) (quote simpfn)) (quote simpiden)))) (numberp (caddr m))))) t) ((eqcar m (
quote times)) (checktimes (cdr m))) (t nil)))

(checkargs lambda (monl var) (and (listp monl) (eqcar monl (quote list)) (or (
and (idp var) var) (and (pairp var) (equal (get (car var) (quote simpfn)) (quote
simpiden)))) (checkmonl monl)))

(allocmon lambda (n) (makevector n 0))

(getnthexp lambda (mon n) (getv mon n))

(setnthexp lambda (mon n d) (putv mon n d))

(gettdeg lambda (mon) (getv mon 0))

(settdeg lambda (mon d) (putv mon 0 d))

(theemptyideal lambda nil (list nil nil))

(notemptyideal lambda (ideal) (cadr ideal))

(firstmon lambda (ideal) (caadr ideal))

(appendideals lambda (ideal1 ideal2) (list (car ideal2) (append (cadr ideal1) (
cadr ideal2))))

(tt lambda (s1 s2) (vevlcm (cadr s1) (cadr s2)))

(atleast2elementsin lambda (u) (and u (cdr u)))

(dipzero!? lambda (u) (null u))

(diplbc lambda (p) (cadr p))

(dipmoncomp lambda (a e p) (cons e (cons a p)))

(dipevlmon lambda (p) (car p))

(dipfmon lambda (a e) (cons e (cons a nil)))

(dipnov lambda (p) (length (car p)))

(dipmred lambda (p) (cddr p))

(vevzero!? lambda (u) (or (null u) (and (equal (car u) 0) (vevzero!?1 (cdr u))))
)

(makevdp lambda (vbc vev form) (list (quote vdp) vev vbc form nil))

(vdppoly lambda (u) (cadr (cddr u)))

(vdplbc lambda (u) (caddr u))

(vdpevlmon lambda (u) (cadr u))

(vdpzero!? lambda (u) (or (null u) (null (cadr (cddr u)))))

(vdpone!? lambda (p) (and (not (or (null p) (null (cadr (cddr p))))) (or (null (
cadr p)) (and (equal (car (cadr p)) 0) (vevzero!?1 (cdr (cadr p)))))))

(vevdivides!? lambda (vev1 vev2) (vevmtest!? vev2 vev1))

(vevzero lambda nil (vevmaptozero1 vdpvars!* nil))

(vdpnumber lambda (f) (vdpgetprop f (quote number)))

(makedipzero lambda nil nil)

(vdpredzero!? lambda (u) (null (cddr (cadr (cddr u)))))

(vbczero!? lambda (u) (bczero!? u))

(vbcfi lambda (u) (bcfd u))

(a2vbc lambda (u) (a2bc u))

(vbcquot lambda (u v) (bcquot u v))

(vbcneg lambda (u) (bcneg u))

(vbcone!? lambda (u) (bcone!? u))

(vbcprod lambda (u v) (bcprod u v))

(vdpcleanup lambda nil (setq dipevlist!* (list nil)))

(vdp2a lambda (u) (dip2a (cadr (cddr u))))

(vbc2a lambda (u) (bc2a u))

(vdp2f lambda (u) (dip2f (cadr (cddr u))))

(vdpzero lambda nil (a2vdp 0))

(vdpvevlcomp lambda (p1 p2) (dipevlcomp (cadr (cddr p1)) (cadr (cddr p2))))

(vevilcompless!? lambda (e1 e2) (equal 1 (evilcomp e2 e1)))

(vevilcomp lambda (e1 e2) (evilcomp e1 e2))

(vevcompless!? lambda (e1 e2) (equal 1 (evcomp e2 e1)))

(vevcomp lambda (e1 e2) (evcomp e1 e2))

(vdpcontent1 lambda (d c) (dipnumcontent (cadr (cddr d)) c))

(vdpmonfac lambda (d) (dipmonfac (cadr (cddr d))))

(vdpcoeffcientsfromdomain!? lambda (w) (dipcoeffcientsfromdomain!? (cadr (cddr w
))))

(vdplength lambda (f) (diplength (cadr (cddr f))))

(vdplcm lambda (p) (diplcm (cadr (cddr p))))

(vdprectoint lambda (p q) (dip2vdp (diprectoint (cadr (cddr p)) q)))

(vdpreduceconti lambda (p co vev) (vdpdivmon p co vev))

(dipappendmon lambda (dip bc ev) (append dip (cons ev (cons bc nil))))

(dipnconcmon lambda (dip bc ev) (nconc dip (cons ev (cons bc nil))))

(dipappenddip lambda (dip1 dip2) (append dip1 dip2))

(dipnconcdip lambda (dip1 dip2) (nconc dip1 dip2))

(vdpsave lambda (u) u)

(torder2 lambda (u) (dipsortingmode u))

(f2dip lambda (u) (f2dip1 u (evzero) (bcfd 1)))

(vdpcondense lambda (f) (dipcondense (car (cdddr f))))

(empty_xset lambda nil (cons (quote !*xset!*) nil))

(empty_xsetp lambda (c) (null (cdr c)))

(xset_item lambda (c) (car c))

(xpolyindex lambda (x) (length (member x (reverse xpolylist!*))))

(xval lambda (f) (wedgefax (caar f)))

(sort!-set lambda (l) (sort l (function set!-ordp)))

(getprec lambda nil (plus 2 (precision 0)))

(setprec lambda (p) (precision1 (difference p 2) t))

(bfsiz lambda (p) (msd!: (abs (cadr (cond ((floatp p) (fl2bf p)) (t (normbf (
cond ((not (atom p)) p) ((fixp p) (cons (quote !:rd!:) (cons p 0))) (t (
read!:num p))))))))))

(bfnump lambda (p) (or (numberp p) (and (eqcar p (quote !:rd!:)) (not (atom (cdr
p))))))

(bfrlmult lambda (r u) (cond ((atom u) (times r u)) (t (normbf (round!:mt (
times!: (cond ((floatp r) (fl2bf r)) (t (normbf (cond ((not (atom r)) r) ((fixp
r) (cons (quote !:rd!:) (cons r 0))) (t (read!:num r)))))) u) !:bprec!:)))))

(bfabs lambda (u) (cond ((atom u) (abs u)) (t (abs!: u))))

(rl2gf lambda (u) (cond (!*bftag (cons (cond ((floatp u) (fl2bf u)) (t (normbf (
cond ((not (atom u)) u) ((fixp u) (cons (quote !:rd!:) (cons u 0))) (t (
read!:num u)))))) bfz!*)) (t (cons (cflot u) 0.0))))

(im2gf lambda (u) (cond (!*bftag (cons bfz!* (cond ((floatp u) (fl2bf u)) (t (
normbf (cond ((not (atom u)) u) ((fixp u) (cons (quote !:rd!:) (cons u 0))) (t (
read!:num u)))))))) (t (cons 0.0 (cflot u)))))

(xclp lambda (a) (eqcar a (quote list)))

(mkxcl lambda (a) (cond ((eqcar a (quote list)) a) (t (cons (quote list) a))))

(ncpxp lambda (p) (or (or (numberp p) (and (eqcar p (quote !:rd!:)) (not (atom (
cdr p))))) (or (numberp (cdar p)) (and (eqcar (cdar p) (quote !:rd!:)) (not (
atom (cdr (cdar p))))))))

(cpxp lambda (p) (not (or (or (numberp p) (and (eqcar p (quote !:rd!:)) (not (
atom (cdr p))))) (or (numberp (cdar p)) (and (eqcar (cdar p) (quote !:rd!:)) (
not (atom (cdr (cdar p)))))))))

(pmsg lambda (a) (cond ((and !*rootmsg !*trroot) (progn (progn (prin2 a) nil) (
terpri)))))

(ceillog lambda (m) (ceiling (log10 (float m))))

(setflbf lambda (b) (setq !*bftag b))

(trmsg1 lambda (a nx) (cond (!*trroot (trmsg1a a nx))))

(trmsg2 lambda (a xn px) (cond (!*trroot (trmsg2a a xn px))))

(trmsg3 lambda (a xn) (cond (!*trroot (trmsg3a a xn))))

(trmsg4 lambda (req) (cond (!*trroot (trmsg4a req))))

(trmsg6 lambda (k xn px) (cond (!*trroot (trmsg6a k xn px))))

(trmsg7 lambda (xn) (cond (!*trroot (trmsg7a xn))))

(trmsg8 lambda nil (cond (!*trroot (trmsg8a))))

(trmsg10 lambda (a) (cond ((or !*trroot !*rootmsg) (trmsg10a a))))

(trmsg11 lambda (xn n) (cond (!*trroot (trmsg11a xn n))))

(trmsg12 lambda (z) (cond (!*trroot (trmsg12a z))))

(trmsg13 lambda (n xn px) (cond (!*trroot (trmsg13a n xn px))))

(dnp lambda (x) (eqcar x (quote !:dn!:)))

(sqr!: lambda (a) (times!: a a))

(rndpwrxc lambda (x c) (cond ((atom (car x)) c) (t (cons (normbf (round!:mt (car
c) !:bprec!:)) (normbf (round!:mt (cdr c) !:bprec!:))))))

(rand_apply_c lambda (c) (simp!* (apply c nil)))

(kp2f lambda (k p) (car (mksq k p)))

(tensrnk lambda (u) (car u))

(tensval lambda (u) (cadr u))

(smallfloatp lambda (u) (atom u))

(fortexp_name lambda (u) (cond ((atom u) (list u)) (t (rplaca (fortexp (cons (
quote dummyarraytoken) (cdr u))) (car u)))))

(ratexp_name lambda (u) (cond ((atom u) (list u)) (t (rplaca (ratexp (cons (
quote dummyarraytoken) (cdr u))) (car u)))))

(cexp_name lambda (u) (cond ((atom u) (list u)) (t (rplaca (cexp (cons (quote
dummyarraytoken) (cdr u))) (car u)))))

(pascexp_name lambda (u) (cond ((atom u) (list u)) (t (rplaca (pascexp (cons (
quote dummyarraytoken) (cdr u))) (car u)))))

(ldpf lambda (u) (caar u))

(tpsf lambda (u) (car u))

(lwf lambda (u) (car u))

(rwf lambda (u) (cdr u))

(lftshftp lambda (u) (smemqlp lftshft!* u))

(mkbasformsq lambda (u) (mksq (list (caar basisforml!*) u) 1))

(mkbaseform lambda (u) (mkupf (list (caar basisforml!*) u)))

(upindp lambda (u) (atom (revalind u)))

(wedgeordp lambda (u v) (worderp u v))

(multwedgesq lambda (u v) (multsq u v))

(noncomp2 lambda (u) (cond ((atom u) (flagp u (quote noncom))) (t (flagp (car u)
(quote noncom)))))

(hvectorp lambda (x) (eq (get x (quote rtype)) (quote hvector)))

(windexp lambda (x) (memq x (car windices!*)))

(replace_by_indexp lambda (v) (get v (quote replace_by_index)))

(indexp lambda (i) (memq i indices!*))

(replace_by_vectorp lambda (i) (get i (quote replace_by_vector)))

(replace_by_vector lambda (i) (or (get i (quote replace_by_vector)) i))

(gamma5p lambda (x) (memq x (car gamma5!*)))

(nospurp lambda (x) (flagp x (quote nospur)))

(clear_gamma5 lambda nil (setq gamma5!* (cons nil (append (reverse (car gamma5!*
)) (cdr gamma5!*)))))

(p_empty_map_ lambda (map_) (null map_))

(p_empty_vertex lambda (vertex) (null vertex))

(s_vertex_first lambda (map_) (car map_))

(s_map__rest lambda (map_) (cdr map_))

(s_vertex_second lambda (map_) (car (cdr map_)))

(first_edge lambda (vertex) (car vertex))

(s_vertex_rest lambda (vertex) (cdr vertex))

(second_edge lambda (vertex) (car (cdr vertex)))

(s_edge_name lambda (edge) (car edge))

(s_edge_prop_ lambda (edge) (cadr edge))

(s_edge_type lambda (edge) (caddr edge))

(add_vertex lambda (vertex map_) (cons vertex map_))

(add_edge lambda (edge vertex) (cons edge vertex))

(append_map_s lambda (map_1 map_2) (append map_1 map_2))

(conc_map_s lambda (map_1 map_2) (nconc map_1 map_2))

(conc_vertex lambda (vertex1 vertex2) (nconc vertex1 vertex2))

(mk_name1 lambda (name) (explode name))

(mk_edge_prop_ lambda (prop_1 prop_2) (cons prop_1 prop_2))

(mk_edge_type lambda (typ1 typ2) (and typ1 typ2))

(mk_edge lambda (name prop_ type) (list name prop_ type))

(mk_edge3_vertex lambda (edge1 edge2 edge3) (list edge1 edge2 edge3))

(mk_empty_map_ lambda nil nil)

(mk_empty_vertex lambda nil nil)

(mk_vertex1_map_ lambda (vertex1) (list vertex1))

(mk_vertex2_map_ lambda (vertex1 vertex2) (list vertex1 vertex2))

(mk_edge2_vertex lambda (edge1 edge2) (list edge1 edge2))

(cycl_map_ lambda (map_) (append (cdr map_) (list (car map_))))

(cycl_vertex lambda (vertex) (append (cdr vertex) (list (car vertex))))

(mk_world lambda (actedges world1) (list actedges (list nil) world1))

(p_member_edge lambda (edge vertex) (assoc (car edge) vertex))

(equal_edges lambda (edge1 edge2) (eq (car edge1) (car edge2)))

(single_no_parents lambda (edges) (equal (length edges) 1))

(resto_map__order lambda (map_) (reverse map_))

(map__length lambda (map_) (length map_))

(vertex_length lambda (vertex) (length vertex))

(prepare_map_ lambda (map_) (prog (x forall!-result forall!-endptr) (setq x map_
) (cond ((null x) (return nil))) (setq forall!-result (setq forall!-endptr (cons
((lambda (x) (mk_old_edge x)) (car x)) nil))) looplabel (setq x (cdr x)) (cond (
(null x) (return forall!-result))) (rplacd forall!-endptr (cons ((lambda (x) (
mk_old_edge x)) (car x)) nil)) (setq forall!-endptr (cdr forall!-endptr)) (go
looplabel)))

(p_vertex_prim lambda (vertex) (leq (length vertex) 3))

(s!-edge!-name lambda (edge) (car edge))

(sappend lambda (x y) (append x y))

(sreverse lambda (y) (reverse y))

(getedge lambda (x y) (cdr (assoc x y)))

(mk!-road!-name lambda (x y n) (list (cons (car x) n) (cons (car y) n)))

(mk!-external!-leg lambda (edge) (list (cons edge 0)))

(index!-in lambda (ind l) (cond ((atom ind) nil) (t (member ind l))))

(reverse_map_ lambda (map_) (reverse map_))

(mk_edge1_vertex lambda (edge) (list edge))

(mk_edges_vertex lambda (edges) edges)

(reversip_vertex lambda (vertex) (reversip vertex))

(append_vertex lambda (vertex1 vertex2) (append vertex1 vertex2))

(mk_edge4_vertex lambda (edge1 edge2 edge3 edge4) (list edge1 edge2 edge3 edge4)
)

(p_old_edge lambda (edge) (assoc (car edge) old_edge_list))

(s_atlas_map_ lambda (atlas) (car atlas))

(s_atlas_coeff lambda (atlas) (cadr atlas))

(s_atlas_den_om lambda (atlas) (caddr atlas))

(mk_atlas lambda (map_ atlases den_om) (list map_ atlases den_om))

(vertex_edges lambda (edge) edge)

(s_coeff_world1 lambda (world1) (cadr world1))

(s_edgelist_world lambda (world) (car world))

(s_world1 lambda (world) (caddr world))

(s_world_var lambda (world) (cadr world))

(s_world_atlas lambda (world) (caddr world))

(s_world_edges lambda (world) (car world))

(eqnp lambda (u) (eqcar u (quote equal)))

(odesolve!-basisp lambda (soln) (and (eqcar (cadr soln) (quote list)) (not (
eqcar (cadadr soln) (quote equal)))))

(mv!-!.!+ lambda (u v) (cons u v))

(mv!-!.!* lambda (u v) (cons u v))

(mv!-lc lambda (u) (cdar u))

(mv!-lpow lambda (u) (caar u))

(mv!-lt lambda (u) (car u))

(mv!-red lambda (u) (cdr u))

(mv!-term!-coeff lambda (u) (cdr u))

(mv!-term!-pow lambda (u) (car u))

(mv!-tpow lambda (u) (car u))

(mv!-tc lambda (u) (cdr u))

(domain!-!* lambda (u v) (times u v))

(domain!-!/ lambda (u v) (quotient u v))

(domain!-!+ lambda (u v) (plus u v))

(domain!-!- lambda (u v) (difference u v))

(domain!-divide lambda (u v) (divide u v))

(domain!-gcd lambda (u v) (gcdn u v))

(domain!-onep lambda (u) (onep u))

(putv!.unsafe lambda (x y z) (putv x y z))

(getv!.unsafe lambda (x y) (getv x y))

(fs!:set!-next lambda (f p) (putv f 3 p))

(fs!:next lambda (f) (getv f 3))

(fs!:set!-coeff lambda (f p) (putv f 0 p))

(fs!:coeff lambda (f) (getv f 0))

(fs!:set!-fn lambda (f p) (putv f 1 p))

(fs!:fn lambda (f) (getv f 1))

(fs!:set!-angle lambda (f p) (putv f 2 p))

(fs!:angle lambda (f) (getv f 2))

(i2fourier lambda (u) (cond ((equal dmode!* (quote !:fs!:)) (!*d2fourier u)) (t
u)))

(fs!:minusp!: lambda (x) (fs!:minusp (cdr x)))

(fs!:difference!: lambda (x y) (fs!:plus!: x (fs!:negate!: y)))

(fs!:negate!: lambda (x) (cons (get (quote fourier) (quote tag)) (fs!:negate (
cdr x))))

(fs!:prepfn!: lambda (x) x)

(simpfs lambda (u) (cons (cons (quote !:fs!:) u) 1))

(zeroterm lambda (x) (equal (getv x 0) (quote (nil . 1))))

(mo_zero lambda nil (cons nil (mo!=deglist nil)))

(mo_zero!? lambda (u) (mo!=zero (car u)))

(mo_comp lambda (v) (cond ((null (car v)) 0) (t (caar v))))

(flag1 lambda (u v) (flag (list u) v))

(remflag1 lambda (u v) (remflag (list u) v))

(isglob lambda (u) (flagp u (quote dclglb)))

(chkseen lambda (s) (cond ((not (flagp s (quote seen))) (progn (flag (list s) (
quote seen)) (setq seen!* (cons s seen!*))))))

(globref lambda (u) (cond ((not (flagp u (quote glb2rf))) (progn (flag (list u)
(quote glb2rf)) (setq globs!* (cons u globs!*))))))

(anatom lambda (u) (cond ((and !*globals u (not (eq u (quote t))) (idp u) (not (
assoc u locls!*))) (cond ((not (flagp u (quote glb2rf))) (progn (flag (list u) (
quote glb2rf)) (setq globs!* (cons u globs!*))))))))

(chkgseen lambda (g) (cond ((not (flagp g (quote gseen))) (progn (setq gseen!* (
cons g gseen!*)) (flag (list g) (quote gseen))))))

(toput lambda (u v w) (cond (w (put u v (cond (toplv!* (union w (get u v))) (t w
))))))

(c_zero lambda nil nil)

(cneg lambda (c) (negf c))

(csum lambda (c1 c2) (addf c1 c2))

(cprod lambda (c1 c2) (cond (!*physop!-loaded (physop!-multf c1 c2)) (t (
poly!-multf c1 c2))))

(cdiv lambda (c1 c2) (car (resimp (cons c1 c2))))

(ljet lambda (p) (caar p))

(pdif lambda (p1 p2) (psum p1 (pneg p2)))

(addgt lambda (u) (cond ((equal ordering (quote lex)) u) (t (cons (eval (cons (
quote plus) u)) u))))

(njets lambda (n q) (combin q (plus q (difference n 1))))

(vectorfn lambda (oper vfn) (put oper (quote vectorfunction) vfn))

(t_minusp lambda (u) nil)

(unpkpv lambda (pv) (unpkpv1 pv nil))

(addmultsym lambda (t1 t2) (addmsym t1 t2 (caar t1) (caar t2)))

(addmultsym_ lambda (t1 t2) nil)

(t_difference lambda (u v) (t_plus u (t_minus v)))

(t_zerop lambda (u) (null (cdr u)))

(t_onep lambda (u) (equal (cdr u) 1))

(t_pri lambda (u) (t_pri1 u nil))

(t_intequiv lambda (u) (atom (cdr u)))

(i2tensor lambda (n) (cons (quote !:tensor) n))

(tio_tname lambda (th) (car th))

(tio_ilist lambda (th) (cadr th))

(tio_dlist lambda (th) (cddr th))

(tio_thead lambda (ten) (car ten))

(tio_pvect lambda (ten) (cdr ten))

(tio_mkten0 lambda (th pv) (cons th pv))

(tio_mkten lambda (th pv) (cons (quote !:tensor) (list (cons th pv))))

(id_cov lambda (u) (cadr u))

(id_cont lambda (u) u)

(careq_tilde lambda (u) (eqcar u (quote !~)))

(careq_minus lambda (u) (eqcar u (quote minus)))

(raiseind lambda (u) (cadr u))

(id_switch_variance lambda (u) (cond ((eqcar u (quote minus)) (cadr u)) (t (list
(quote minus) u))))

(get!-impfun!-args lambda (u) (cdr (assoc u depl!*)))

(get_prop_space lambda (u) (subla spaces!* u))

(pe_apply lambda (pe elt) (getv pe (difference elt 1)))

(sc_orbits lambda (sc k) (getv (getv (cdr sc) (difference k 1)) (difference 1 1)
))

(sc_transversal lambda (sc k) (getv (getv (cdr sc) (difference k 1)) (difference
2 1)))

(sc_generators lambda (sc k) (getv (getv (cdr sc) (difference k 1)) (difference
3 1)))

(sc_inv_generators lambda (sc k) (getv (getv (cdr sc) (difference k 1)) (
difference 4 1)))

(sc_stabdesc lambda (sc k) (getv (cdr sc) (difference k 1)))

(sd_orbrep lambda (sd elt) (getv (getv sd (difference 1 1)) (difference elt 1)))

(sd_orbreps lambda (sd) (getv sd (difference 5 1)))

(mkve lambda (n) (mkvect (difference n 1)))

(mkve!* lambda (n) (mkarray1 (list n) (quote algebraic)))

(putve lambda (ve i elt) (putv ve (difference i 1) elt))

(venth lambda (u i) (getv u (difference i 1)))

(array_to_vect lambda (u) (cadr (get u (quote avalue))))

(be_last lambda (u) (delete (lastcar u) u))

(mkar lambda (u) (cons (quote !:ar!:) u))

(divsf lambda (u v) (sqrt2top (cons u v)))

(maninp lambda (u v w) (interr
"MANINP called -- not implemented in this version"))

(readclock lambda nil (time))

(lsubs lambda (u) (car u))

(rsubs lambda (u) (cdr u))

(lfirstsubs lambda (u) (caar u))

(rfirstsubs lambda (u) (cdar u))

(tayshorten lambda (u) nil)

(taylordefn lambda (u) (car u))

(taylornumbers lambda (u) (cadr u))

(taylorfirst lambda (u) (caadr u))

(taylorlast lambda (u) (cdadr u))

(taylorlist lambda (u) (cddr u))

(taylormake lambda (fn nums alist) (cons fn (cons nums alist)))

(mod!+ lambda (a b) (general!-modular!-plus a b))

(rsolve_mod!* lambda (a b) (remainder (times a b) current!-modulus))

(mod!^ lambda (a n) (general!-modular!-expt a n))

(top lambda nil (car stack))

(depth lambda (frm) (car frm))

(indenting lambda (frm) (cadr frm))

(blankcount lambda (frm) (caddr frm))

(blanklist lambda (frm) (cdddr frm))

(setindenting lambda (frm val) (rplaca (cdr frm) val))

(setblankcount lambda (frm val) (rplaca (cddr frm) val))

(setblanklist lambda (frm val) (rplacd (cddr frm) val))

(newframe lambda (n) (list n nil 0))

(blankp lambda (char) (numberp (car char)))

(nestlevel lambda (u) (cond ((fixp u) 0) (t (cadr u))))

(nestdmode lambda (u) (cond ((fixp u) nil) (t (caddr u))))

(nestsq lambda (u) (cond ((fixp u) (simp u)) (t (cdddr u))))

(bb!:ordexp lambda (u v) (greaterp u v))

(argof lambda (u) (cadr u))

(int_mult lambda (a b) (cons a b))

(int_add lambda (a b) (cons a b))

(taylorfunction lambda (u) (caar u))

(mkg lambda (u l) (mksf (cons (quote g) (cons l u))))

(mka lambda (l) (mksf (list (quote g) l (quote a))))

(mkgamf lambda (u l) (mksf (cons (quote g) (cons l u))))

(mkpf lambda (u v) ((lambda (g544) (cond (!*physop!-loaded (physop!-multf g544 v
)) (t (poly!-multf g544 v)))) (list (cons u 1))))

(addfs lambda (u v) (addf u v))

(multfs lambda (u v) (cond (!*physop!-loaded (physop!-multf u v)) (t (
poly!-multf u v))))

(mkdot lambda (u v) (mksf (cons (quote cons) (ord2 u v))))

(get!-f!-numvec lambda (s) (cadr (cddr (cdddr s))))

(adjoin!-term lambda (p c r) (cond ((null c) r) (t (cons (cons p c) r))))

(polyzerop lambda (u) (null u))

(didntgo lambda (q) (null q))

(depends!-on!-var lambda (a v) ((lambda (!#!#z) (and (not (or (atom !#!#z) (atom
(car !#!#z)))) (equal (caaar !#!#z) v))) a))

(printstr lambda (l) (progn (prin2!* l) (terpri!* nil)))

(printvar lambda (v) (progn (prin2!* v) (terpri!* nil)))

(prinvar lambda (v) (prin2!* v))

(getm2 lambda (a i j) (getv (getv a i) j))

(putm2 lambda (a i j v) (putv (getv a i) j v))

(!*f2mod lambda (u) u)

(!*mod2f lambda (u) u)

(put!-image!-poly!-and!-content lambda (s imcont impol) (list (car s) (cadr s) (
caddr s) (caddr (cdr s)) imcont impol (caddr (cdddr (cdr s)))))

(comes!-before lambda (p1 p2) (or (and (equal (car p1) (car p2)) (igreaterp (cdr
p1) (cdr p2))) (and (not (equal (car p1) (car p2))) (ordop (car p1) (car p2)))))

(!*k2f lambda (u) (list (cons (cons u 1) 1)))

(!*kk2f lambda (u) (list (cons (getpower (fkern u) 1) 1)))

(!*kk2q lambda (u) (cons (list (cons (getpower (fkern u) 1) 1)) 1))

(!*k2q lambda (u) (cons (list (cons (cons u 1) 1)) 1))

(multpf lambda (u v) ((lambda (g544) (cond (!*physop!-loaded (physop!-multf g544
v)) (t (poly!-multf g544 v)))) (list (cons u 1))))

(evalgeq lambda (u v) (not (evalgreaterp v u)))

)
