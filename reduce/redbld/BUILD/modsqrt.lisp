(cl:declaim (cl:optimize cl:debug cl:safety))
(cl:declaim (sb-ext:muffle-conditions sb-ext:compiler-note cl:style-warning))
(MODULE (LIST 'MODSQRT)) 
(PUT 'MODSQRT 'NUMBER-OF-ARGS 2) 
(PUT 'MODSQRT 'DEFINED-ON-LINE '31) 
(PUT 'MODSQRT 'DEFINED-IN-FILE 'SOLVE/MODSQRT.RED) 
(PUT 'MODSQRT 'PROCEDURE_TYPE '(ARROW (TIMES GENERAL GENERAL) GENERAL)) 
(DE MODSQRT (A P)
    ((LAMBDA (CURRENT-MODULUS)
       (PROGN
        (COND
         ((OR (NOT (FIXP P)) (LESSP P 2))
          (TYPERR P "modulus for root computation")))
        (SETQ A (GENERAL-MODULAR-NUMBER A))
        (COND ((LESSP P 50) (MODSQRT1 A P)) (T (MODSQRT2 A P)))))
     P)) 
(PUT 'MODSQRT1 'NUMBER-OF-ARGS 2) 
(PUT 'MODSQRT1 'DEFINED-ON-LINE '40) 
(PUT 'MODSQRT1 'DEFINED-IN-FILE 'SOLVE/MODSQRT.RED) 
(PUT 'MODSQRT1 'PROCEDURE_TYPE '(ARROW (TIMES GENERAL GENERAL) GENERAL)) 
(DE MODSQRT1 (A P)
    (PROG (I W R)
      (SETQ I 0)
      (SETQ W 0)
      (PROG ()
       WHILELABEL
        (COND ((NOT (AND (NULL R) (LESSP I P))) (RETURN NIL)))
        (COND ((EQUAL W A) (SETQ R I))
              (T
               (PROGN
                (SETQ W (IPLUS2 (IPLUS2 (IPLUS2 W I) I) 1))
                (PROG ()
                 WHILELABEL
                  (COND ((NOT (IGREATERP W P)) (RETURN NIL)))
                  (SETQ W (IDIFFERENCE W P))
                  (GO WHILELABEL))
                (SETQ I (IPLUS2 I 1))
                NIL)))
        (GO WHILELABEL))
      (COND ((NULL R) (TYPERR (LIST 'SQRT A) "expression mod p")))
      (RETURN R))) 
(PUT 'MODSQRT2 'NUMBER-OF-ARGS 2) 
(PUT 'MODSQRT2 'DEFINED-ON-LINE '54) 
(PUT 'MODSQRT2 'DEFINED-IN-FILE 'SOLVE/MODSQRT.RED) 
(PUT 'MODSQRT2 'PROCEDURE_TYPE '(ARROW (TIMES GENERAL GENERAL) GENERAL)) 
(DE MODSQRT2 (A P)
    (PROG (B M R Y E Q TT N P-1 X Z)
      (SETQ B 0)
      (SETQ M 0)
      (SETQ R 0)
      (SETQ Y 0)
      (SETQ E 0)
      (SETQ Q 0)
      (SETQ TT 0)
      (SETQ N 0)
      (SETQ P-1 0)
      (SETQ X 0)
      (SETQ Z 0)
      (SETQ X A)
      (SETQ P-1 (DIFFERENCE P 1))
      (SETQ Q (DIFFERENCE P 1))
      (PROG ()
       WHILELABEL
        (COND ((NOT (EVENP Q)) (RETURN NIL)))
        (PROGN (SETQ Q (QUOTIENT Q 2)) (SETQ E (PLUS E 1)))
        (GO WHILELABEL))
     S1
      (PROG ()
       REPEATLABEL
        (SETQ N (RANDOM P))
        (COND ((NOT (EQUAL (LEGENDRE-SYMBOL N P) P-1)) (GO REPEATLABEL))))
      (SETQ Z (GENERAL-MODULAR-EXPT N Q))
     S2
      (SETQ Y Z)
      (SETQ R E)
      (SETQ X (GENERAL-MODULAR-EXPT A (QUOTIENT (DIFFERENCE Q 1) 2)))
      (SETQ B (MODP (TIMES A X X) P))
      (SETQ X (MODP (TIMES A X) P))
     S3
      (COND ((EQUAL (MODP B P) 1) (RETURN X)))
      (SETQ M 0)
      (PROG ()
       REPEATLABEL
        (SETQ M (PLUS M 1))
        (COND
         ((NOT (OR (EQUAL (GENERAL-MODULAR-EXPT B (EXPT 2 M)) 1) (EQUAL M R)))
          (GO REPEATLABEL))))
      (COND ((EQUAL M R) (TYPERR (LIST 'SQRT A) "expression mod p")))
     S4
      (SETQ TT
              (GENERAL-MODULAR-EXPT Y
                                    (EXPT 2 (DIFFERENCE (DIFFERENCE R M) 1))))
      (SETQ Y (GENERAL-MODULAR-TIMES TT TT))
      (SETQ R M)
      (SETQ X (GENERAL-MODULAR-TIMES X TT))
      (SETQ B (GENERAL-MODULAR-TIMES B Y))
      (GO S3))) 
(PUT 'MODSQRT* 'NUMBER-OF-ARGS 1) 
(PUT 'MODSQRT* 'DEFINED-ON-LINE '80) 
(PUT 'MODSQRT* 'DEFINED-IN-FILE 'SOLVE/MODSQRT.RED) 
(PUT 'MODSQRT* 'PROCEDURE_TYPE '(ARROW GENERAL GENERAL)) 
(DE MODSQRT* (U) (*MODULAR2F (MODSQRT (CDR U) CURRENT-MODULUS))) 
(PUT 'SQRT '|:MOD:| 'MODSQRT*) 
(AEVAL (OPERATOR (LIST 'LEGENDRE_SYMBOL))) 
(PUT 'LEGENDRE-SYMBOL 'NUMBER-OF-ARGS 2) 
(PUT 'LEGENDRE-SYMBOL 'DEFINED-ON-LINE '88) 
(PUT 'LEGENDRE-SYMBOL 'DEFINED-IN-FILE 'SOLVE/MODSQRT.RED) 
(PUT 'LEGENDRE-SYMBOL 'PROCEDURE_TYPE '(ARROW (TIMES GENERAL GENERAL) GENERAL)) 
(DE LEGENDRE-SYMBOL (A P)
    (GENERAL-MODULAR-EXPT A (QUOTIENT (DIFFERENCE P 1) 2))) 
(PUT 'LEGENDRE_SYMBOL1 'NUMBER-OF-ARGS 2) 
(FLAG '(LEGENDRE_SYMBOL1) 'OPFN) 
(PUT 'LEGENDRE_SYMBOL1 'DEFINED-ON-LINE '91) 
(PUT 'LEGENDRE_SYMBOL1 'DEFINED-IN-FILE 'SOLVE/MODSQRT.RED) 
(PUT 'LEGENDRE_SYMBOL1 'PROCEDURE_TYPE '(ARROW (TIMES GENERAL GENERAL) GENERAL)) 
(DE LEGENDRE_SYMBOL1 (A P)
    (PROG (*MODULAR CURRENT-MODULUS DMODE* RES)
      (COND ((EVALEQUAL (AEVAL P) 1) (RETURN 1)))
      (COND
       ((AND (PRIMEP (REVALX P)) (EVALEQUAL (AEVAL (LIST 'REMAINDER P 2)) 1))
        (PROGN
         (SETQ RES (AEVAL (LIST 'QUOTIENT (LIST 'DIFFERENCE P 1) 2)))
         (AEVAL (ON (LIST 'MODULAR)))
         (AEVAL (LIST 'SETMOD P))
         (SETQ RES (AEVAL (GENERAL-MODULAR-EXPT A RES)))
         (AEVAL (OFF (LIST 'MODULAR)))))
       (T
        (AEVAL
         (REDERR
          (REVALX
           "The second argument to legendre_symbol must be an odd prime")))))
      (RETURN
       (COND ((EVALEQUAL (AEVAL RES) (AEVAL (LIST 'DIFFERENCE P 1))) (MINUS 1))
             (T (AEVAL RES)))))) 
(AEVAL
 (LET
  '((REPLACEBY (LEGENDRE_SYMBOL (~ A) (~ P))
     (WHEN (LEGENDRE_SYMBOL1 A P) (AND (FIXP A) (FIXP P))))))) 
(ENDMODULE) 