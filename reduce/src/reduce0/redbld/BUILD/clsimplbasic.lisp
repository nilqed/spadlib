(cl:declaim (cl:optimize cl:debug cl:safety))
(cl:declaim (sb-ext:muffle-conditions sb-ext:compiler-note cl:style-warning))
(MODULE (LIST 'CLSIMPLBASIC)) 
(REVISION 'CLSIMPLBASIC
          "$Id: clsimplbasic.red 5964 2021-08-23 16:00:17Z thomas-sturm $") 
(COPYRIGHT 'CLSIMPLBASIC "(c) 1995-2021 A. Dolzmann, T. Sturm") 
(RL_PROVIDESERVICE 'RL_SIMPLBASIC 'CL_SIMPLBASIC '(RL_SIMPLAT1 RL_NEGATEAT)) 
(PUT 'CL_SIMPLBASIC 'NUMBER-OF-ARGS 3) 
(DE CL_SIMPLBASIC (F THEORY N)
    (PROGN (COND (NIL NIL)) (CL_BASICSIMPLIFY1 F N NIL))) 
(PUT 'CL_BASICSIMPLIFY1 'NUMBER-OF-ARGS 3) 
(DE CL_BASICSIMPLIFY1 (F N SOP)
    (PROG (OP)
      (COND ((EQN N 0) (RETURN F)))
      (SETQ OP (COND ((ATOM F) F) (T (CAR F))))
      (COND ((OR (EQ OP 'TRUE) (EQ OP 'FALSE)) (RETURN F)))
      (COND ((EQ OP 'NOT) (RETURN (CL_BASICSIMPLIFYNOT (CADR F) N))))
      (COND
       ((OR (EQ OP 'OR) (EQ OP 'AND))
        (RETURN (CL_BASICSIMPLIFYGENERICAND F N))))
      (COND
       ((OR (EQ OP 'EX) (EQ OP 'ALL))
        (RETURN (CL_BASICSIMPLIFYQUANTIFIER F N))))
      (COND
       ((EQ OP 'IMPL)
        (RETURN (CL_BASICSIMPLIFYIMPLICATION (CADR F) (CADDR F) N))))
      (COND
       ((EQ OP 'REPL)
        (RETURN (CL_BASICSIMPLIFYIMPLICATION (CADDR F) (CADR F) N))))
      (COND ((EQ OP 'EQUIV) (RETURN (CL_BASICSIMPLIFYEQUIVALENCE F N))))
      (COND
       ((OR (EQ OP 'BEX) (EQ OP 'BALL))
        (RETURN (CL_BASICSIMPLIFYBOUNDEDQUANTIFIER F N))))
      (COND (NIL NIL))
      (RETURN (CL_SIMPLAT F SOP)))) 
(PUT 'CL_BASICSIMPLIFYNOT 'NUMBER-OF-ARGS 2) 
(DE CL_BASICSIMPLIFYNOT (F N)
    (PROG (RESULT)
      (SETQ RESULT (CL_BASICSIMPLIFY1 (CADR F) (DIFFERENCE N 1) 'NOT))
      (COND
       ((OR (EQ RESULT 'TRUE) (EQ RESULT 'FALSE)) (RETURN (CL_FLIP RESULT))))
      (COND ((CL_ATFP RESULT) (RETURN (RL_NEGATEAT RESULT))))
      (RETURN (CL_INVOLUTIVENOT RESULT)))) 
(PUT 'CL_BASICSIMPLIFYGENERICAND 'NUMBER-OF-ARGS 2) 
(DE CL_BASICSIMPLIFYGENERICAND (F N)
    (PROG (GAND GTRUE GFALSE RESULT AL A)
      (SETQ GAND (COND ((ATOM F) F) (T (CAR F))))
      (COND ((EQ GAND 'AND) (PROGN (SETQ GTRUE 'TRUE) (SETQ GFALSE 'FALSE)))
            (T (PROGN (SETQ GTRUE 'FALSE) (SETQ GFALSE 'TRUE))))
      (SETQ AL (CDR F))
     NEXT
      (PROG ()
       WHILELABEL
        (COND ((NOT AL) (RETURN NIL)))
        (PROGN
         (SETQ A
                 (CL_BASICSIMPLIFY1 (PROG1 (CAR AL) (SETQ AL (CDR AL)))
                  (DIFFERENCE N 1) GAND))
         (COND ((EQ A GTRUE) (GO NEXT)))
         (COND ((EQ A GFALSE) (PROGN (SETQ RESULT (LIST GFALSE)) (GO BREAK))))
         (COND
          ((EQ (COND ((ATOM A) A) (T (CAR A))) GAND)
           (PROGN
            (PROG (SUBF)
              (SETQ SUBF (CDR A))
             LAB
              (COND ((NULL SUBF) (RETURN NIL)))
              ((LAMBDA (SUBF) (SETQ RESULT (LTO_INSERT SUBF RESULT)))
               (CAR SUBF))
              (SETQ SUBF (CDR SUBF))
              (GO LAB))
            (GO NEXT))))
         (SETQ RESULT (LTO_INSERT A RESULT)))
        (GO WHILELABEL))
     BREAK
      (RETURN
       ((LAMBDA (G130)
          (COND ((AND G130 (CDR G130)) (CONS GAND G130))
                ((NULL G130) (COND ((EQ GAND 'AND) 'TRUE) (T 'FALSE)))
                (T (CAR G130))))
        (REVERSIP RESULT))))) 
(PUT 'CL_BASICSIMPLIFYQUANTIFIER 'NUMBER-OF-ARGS 2) 
(DE CL_BASICSIMPLIFYQUANTIFIER (F N)
    (PROG (Q X W)
      (SETQ Q (COND ((ATOM F) F) (T (CAR F))))
      (SETQ X (CADR F))
      (SETQ W (CL_BASICSIMPLIFY1 (CADDR F) (DIFFERENCE N 1) Q))
      (COND ((NOT (MEMQ X (CL_FVARL1 W))) (RETURN W)))
      (RETURN (LIST Q X W)))) 
(PUT 'CL_BASICSIMPLIFYBOUNDEDQUANTIFIER 'NUMBER-OF-ARGS 2) 
(DE CL_BASICSIMPLIFYBOUNDEDQUANTIFIER (F N)
    (PROG (Q X B W)
      (SETQ Q (COND ((ATOM F) F) (T (CAR F))))
      (SETQ X (CADR F))
      (SETQ B (RL_BOUND F))
      (SETQ W (CL_BASICSIMPLIFY1 (CADDR F) (DIFFERENCE N 1) Q))
      (RETURN (LIST Q X W B)))) 
(PUT 'CL_BASICSIMPLIFYIMPLICATION 'NUMBER-OF-ARGS 3) 
(DE CL_BASICSIMPLIFYIMPLICATION (PREM CONCL N)
    (PROG ()
      (SETQ PREM (CL_BASICSIMPLIFY1 PREM (DIFFERENCE N 1) 'PREM))
      (COND ((EQ PREM 'FALSE) (RETURN 'TRUE)))
      (SETQ CONCL (CL_BASICSIMPLIFY1 CONCL (DIFFERENCE N 1) 'CONCL))
      (COND ((EQ CONCL 'TRUE) (RETURN 'TRUE)))
      (COND ((EQ PREM 'TRUE) (RETURN CONCL)))
      (COND
       ((EQ CONCL 'FALSE) (RETURN (CL_BASICSIMPLIFY1 (LIST 'NOT PREM) 1 NIL))))
      (COND ((EQUAL PREM CONCL) (RETURN 'TRUE)))
      (RETURN (LIST 'IMPL PREM CONCL)))) 
(PUT 'CL_BASICSIMPLIFYEQUIVALENCE 'NUMBER-OF-ARGS 2) 
(DE CL_BASICSIMPLIFYEQUIVALENCE (F N)
    (PROG (LHS RHS)
      (SETQ LHS (CL_BASICSIMPLIFY1 (CADR F) (DIFFERENCE N 1) 'EQUIV))
      (SETQ RHS (CL_BASICSIMPLIFY1 (CADDR F) (DIFFERENCE N 1) 'EQUIV))
      (COND ((EQ LHS 'TRUE) (RETURN RHS)))
      (COND ((EQ RHS 'TRUE) (RETURN LHS)))
      (COND ((EQ LHS 'FALSE) (RETURN (CL_INVOLUTIVENOT RHS))))
      (COND ((EQ RHS 'FALSE) (RETURN (CL_INVOLUTIVENOT LHS))))
      (COND ((EQUAL LHS RHS) (RETURN 'TRUE)))
      (RETURN (LIST 'EQUIV LHS RHS)))) 
(ENDMODULE) 