(cl:declaim (cl:optimize cl:debug cl:safety))
(cl:declaim (sb-ext:muffle-conditions sb-ext:compiler-note cl:style-warning))
(MODULE (LIST 'APPROX)) 
(FLUID '(*PRAPPROX)) 
(SWITCH (LIST 'PRAPPROX)) 
(SETQ *PRAPPROX NIL) 
(GLOBAL '(CURSYM* COORDS* ICOORDS* FUNCTIONS* HIPOW* LOWPOW*)) 
(SETQ ICOORDS* '(I J K L M N I1 J1 K1 L1 M1 N1)) 
(AEVAL (NULL (SETQ *MODE 'ALGEBRAIC))) 
(PUT 'FACT 'NUMBER-OF-ARGS 1) 
(FLAG '(FACT) 'OPFN) 
(PUT 'FACT 'DEFINED-ON-LINE '43) 
(PUT 'FACT 'DEFINED-IN-FILE 'FIDE/APPROX.RED) 
(PUT 'FACT 'PROCEDURE_TYPE '(ARROW GENERAL GENERAL)) 
(DE FACT (N)
    (COND ((EVALEQUAL (AEVAL N) 0) 1)
          (T (AEVAL (LIST 'TIMES N (LIST 'FACT (LIST 'DIFFERENCE N 1))))))) 
(PUT 'FIDE-TAYLOR 'NUMBER-OF-ARGS 4) 
(FLAG '(FIDE-TAYLOR) 'OPFN) 
(PUT 'FIDE-TAYLOR 'DEFINED-ON-LINE '47) 
(PUT 'FIDE-TAYLOR 'DEFINED-IN-FILE 'FIDE/APPROX.RED) 
(PUT 'FIDE-TAYLOR 'PROCEDURE_TYPE
     '(ARROW (TIMES GENERAL GENERAL GENERAL GENERAL) GENERAL)) 
(DE FIDE-TAYLOR (FCE VAR STEP ORD)
    (COND
     ((OR (EVALEQUAL (AEVAL STEP) 0) (EVALEQUAL (AEVAL ORD) 0)) (AEVAL FCE))
     (T
      (AEVAL
       (LIST 'PLUS FCE
             (PROG (J FORALL-RESULT)
               (SETQ J 1)
               (SETQ FORALL-RESULT 0)
              LAB1
               (COND
                ((|AMINUSP:| (LIST 'DIFFERENCE (AEVAL* ORD) J))
                 (RETURN FORALL-RESULT)))
               (SETQ FORALL-RESULT
                       (AEVAL*
                        (LIST 'PLUS
                              (AEVAL*
                               (LIST 'TIMES
                                     (LIST 'QUOTIENT (LIST 'EXPT STEP J)
                                           (LIST 'FACT J))
                                     (LIST 'DF FCE VAR J)))
                              FORALL-RESULT)))
               (SETQ J
                       ((LAMBDA (FORALL-RESULT)
                          (AEVAL* (LIST 'PLUS FORALL-RESULT 1)))
                        J))
               (GO LAB1))))))) 
(NULL (SETQ *MODE 'SYMBOLIC)) 
(PUT 'MAXORDER 'NUMBER-OF-ARGS 1) 
(PUT 'MAXORDER 'DEFINED-ON-LINE '53) 
(PUT 'MAXORDER 'DEFINED-IN-FILE 'FIDE/APPROX.RED) 
(PUT 'MAXORDER 'PROCEDURE_TYPE '(ARROW GENERAL GENERAL)) 
(DE MAXORDER (U)
    (PROG (MOVAR VAR)
     A
      (SETQ MOVAR (CAR U))
      (COND ((NOT (EQEXPR MOVAR)) (RETURN (ERRPRI2 MOVAR 'HOLD))))
      (SETQ MOVAR (CDR MOVAR))
      (SETQ VAR (CAR MOVAR))
      (SETQ MOVAR (REVAL1 (CADR MOVAR) T))
      (COND
       ((OR (NOT (ATOM VAR)) (NOT (MEMQ VAR COORDS*)))
        (RETURN (MSGPRI " Parameter " VAR " must be coordinate" NIL 'HOLD)))
       ((NOT (FIXP MOVAR))
        (RETURN (MSGPRI " Parameter " MOVAR " must be integer" NIL 'HOLD)))
       (T (PUT VAR 'MAXORDER MOVAR)))
      (SETQ U (CDR U))
      (COND (U (GO A)))
      (RETURN NIL))) 
(PUT 'MAXORDER 'STAT 'RLIS) 
(PUT 'CENTER 'NUMBER-OF-ARGS 1) 
(PUT 'CENTER 'DEFINED-ON-LINE '73) 
(PUT 'CENTER 'DEFINED-IN-FILE 'FIDE/APPROX.RED) 
(PUT 'CENTER 'PROCEDURE_TYPE '(ARROW GENERAL GENERAL)) 
(DE CENTER (U)
    (PROG (MOVAR VAR)
     A
      (SETQ MOVAR (CAR U))
      (COND ((NOT (EQEXPR MOVAR)) (RETURN (ERRPRI2 MOVAR 'HOLD))))
      (SETQ MOVAR (CDR MOVAR))
      (SETQ VAR (CAR MOVAR))
      (SETQ MOVAR (REVAL1 (CADR MOVAR) T))
      (COND
       ((OR (NOT (ATOM VAR)) (NOT (MEMQ VAR COORDS*)))
        (RETURN (MSGPRI " Parameter " VAR " must be coordinate" NIL 'HOLD)))
       ((NOT
         (OR (FIXP MOVAR)
             (AND (EQCAR MOVAR 'QUOTIENT)
                  (OR (FIXP (CADR MOVAR))
                      (AND (EQCAR (CADR MOVAR) 'MINUS) (FIXP (CADADR MOVAR))))
                  (FIXP (CADDR MOVAR)))))
        (RETURN
         (MSGPRI " Parameter " MOVAR " must be integer or rational number" NIL
                 'HOLD)))
       (T (PUT VAR 'CENTER MOVAR)))
      (SETQ U (CDR U))
      (COND (U (GO A)))
      (RETURN NIL))) 
(PUT 'CENTER 'STAT 'RLIS) 
(PUT 'FUNCTIONS 'NUMBER-OF-ARGS 1) 
(PUT 'FUNCTIONS 'DEFINED-ON-LINE '97) 
(PUT 'FUNCTIONS 'DEFINED-IN-FILE 'FIDE/APPROX.RED) 
(PUT 'FUNCTIONS 'PROCEDURE_TYPE '(ARROW GENERAL GENERAL)) 
(DE FUNCTIONS (U)
    (PROGN
     (SETQ FUNCTIONS* U)
     (PROG (A)
       (SETQ A U)
      LAB
       (COND ((NULL A) (RETURN NIL)))
       ((LAMBDA (A) (PUT A 'SIMPFN 'SIMPIDEN)) (CAR A))
       (SETQ A (CDR A))
       (GO LAB)))) 
(PUT 'FUNCTIONS 'STAT 'RLIS) 
(PUT 'FIDE-SIMPTAYLOR 'NUMBER-OF-ARGS 1) 
(PUT 'FIDE-SIMPTAYLOR 'DEFINED-ON-LINE '103) 
(PUT 'FIDE-SIMPTAYLOR 'DEFINED-IN-FILE 'FIDE/APPROX.RED) 
(PUT 'FIDE-SIMPTAYLOR 'PROCEDURE_TYPE '(ARROW GENERAL GENERAL)) 
(DE FIDE-SIMPTAYLOR (U)
    (PROG (IND VAR MOVAR STEP FCE IFCE)
      (SETQ FCE (CAR U))
      (COND ((NULL (CDR U)) (RETURN (SIMP FCE))))
      (SETQ IFCE (CADR U))
      (COND ((CDDR U) (SETQ FCE (CONS FCE (CDDR U)))))
      (SETQ IND (CAAAR (CAR (SIMP IFCE))))
      (SETQ VAR (TCAR (GET IND 'COORD)))
      (SETQ STEP
              (REVAL1
               (LIST 'DIFFERENCE IFCE
                     (LIST 'PLUS
                           (COND ((SETQ MOVAR (GET VAR 'CENTER)) MOVAR) (T 0))
                           IND))
               T))
      (SETQ STEP (LIST 'TIMES STEP (GET VAR 'GRIDSTEP)))
      (SETQ MOVAR (COND ((SETQ MOVAR (GET VAR 'MAXORDER)) MOVAR) (T 3)))
      (RETURN (SIMP (LIST 'FIDE-TAYLOR FCE VAR STEP MOVAR))))) 
(AEVAL (NULL (SETQ *MODE 'ALGEBRAIC))) 
(PUT 'APPROX 'NUMBER-OF-ARGS 1) 
(FLAG '(APPROX) 'OPFN) 
(PUT 'APPROX 'DEFINED-ON-LINE '132) 
(PUT 'APPROX 'DEFINED-IN-FILE 'FIDE/APPROX.RED) 
(PUT 'APPROX 'PROCEDURE_TYPE '(ARROW GENERAL GENERAL)) 
(DE APPROX (DIFSCH)
    (PROG (LDIFSCH RDIFSCH NRCOOR COORS REST LDIFEQ RDIFEQ ALGLIST*)
      (SETQ ALGLIST* (CONS NIL NIL))
      (PROGN
       (PROG (A)
         (SETQ A FUNCTIONS*)
        LAB
         (COND ((NULL A) (RETURN NIL)))
         ((LAMBDA (A)
            (PROGN
             (PUT A 'SIMPFN 'FIDE-SIMPTAYLOR)
             (EVAL (LIST 'DEPEND (MKQUOTE (CONS A COORDS*))))))
          (CAR A))
         (SETQ A (CDR A))
         (GO LAB))
       (FLAG FUNCTIONS* 'FULL)
       (PROG (A)
         (SETQ A COORDS*)
        LAB
         (COND ((NULL A) (RETURN NIL)))
         ((LAMBDA (A)
            (PUT A 'GRIDSTEP
                 (INTERN (COMPRESS (APPEND (EXPLODE 'H) (EXPLODE A))))))
          (CAR A))
         (SETQ A (CDR A))
         (GO LAB))
       (SETQ NRCOOR (DIFFERENCE (LENGTH COORDS*) 1))
       (EVAL
        (LIST 'ARRAY (MKQUOTE (LIST (CONS 'STEPS (ADD1LIS (LIST NRCOOR)))))))
       (SETQ COORS COORDS*)
       (PROG (J)
         (SETQ J 0)
        LAB
         (COND ((MINUSP (DIFFERENCE NRCOOR J)) (RETURN NIL)))
         (PROGN
          (SETEL (LIST 'STEPS J) (REVAL1 (GET (CAR COORS) 'GRIDSTEP) NIL))
          (SETQ COORS (CDR COORS)))
         (SETQ J (PLUS2 J 1))
         (GO LAB)))
      (SETQ LDIFSCH (AEVAL (LIST 'LHS DIFSCH)))
      (SETQ RDIFSCH (AEVAL (LIST 'RHS DIFSCH)))
      (SETQ LDIFEQ (AEVAL LDIFSCH))
      (SETQ RDIFEQ (AEVAL RDIFSCH))
      (SETQ LDIFEQ (AEVAL (LIST 'SUBSTEPS LDIFEQ)))
      (SETQ RDIFEQ (AEVAL (LIST 'SUBSTEPS RDIFEQ)))
      (SETQ REST
              (AEVAL
               (LIST 'PLUS
                     (LIST 'DIFFERENCE (LIST 'DIFFERENCE LDIFSCH LDIFEQ)
                           RDIFSCH)
                     RDIFEQ)))
      (PROG (J)
        (SETQ J 0)
       LAB
        (COND ((|AMINUSP:| (LIST 'DIFFERENCE (AEVAL* NRCOOR) J)) (RETURN NIL)))
        (SETK (LIST 'STEPS J)
              (AEVAL*
               (LIST 'EXPT (LIST 'STEPS J)
                     (LIST 'MINORDER REST (LIST 'STEPS J)))))
        (SETQ J
                ((LAMBDA (FORALL-RESULT) (AEVAL* (LIST 'PLUS FORALL-RESULT 1)))
                 J))
        (GO LAB))
      (PROGN
       (ASSGNPRI
        (AEVAL " Difference scheme approximates differential equation ") NIL
        'FIRST)
       (ASSGNPRI (AEVAL (LIST 'EQUAL LDIFEQ RDIFEQ)) NIL 'LAST))
      (ASSGNPRI (AEVAL " with orders of approximation:") NIL 'ONLY)
      (AEVAL (ON (LIST 'DIV)))
      (PROG (J)
        (SETQ J 0)
       LAB
        (COND ((|AMINUSP:| (LIST 'DIFFERENCE (AEVAL* NRCOOR) J)) (RETURN NIL)))
        (ASSGNPRI (AEVAL* (LIST 'STEPS J)) NIL 'ONLY)
        (SETQ J
                ((LAMBDA (FORALL-RESULT) (AEVAL* (LIST 'PLUS FORALL-RESULT 1)))
                 J))
        (GO LAB))
      (AEVAL (OFF (LIST 'DIV)))
      (COND
       (*PRAPPROX
        (PROGN
         (ASSGNPRI (AEVAL " Rest of approximation : ") NIL 'FIRST)
         (ASSGNPRI (AEVAL REST) NIL 'LAST))))
      (PROGN
       (PROG (A)
         (SETQ A FUNCTIONS*)
        LAB
         (COND ((NULL A) (RETURN NIL)))
         ((LAMBDA (A)
            (PROGN
             (PUT A 'SIMPFN 'SIMPIDEN)
             (EVAL (LIST 'NODEPEND (MKQUOTE (CONS A COORDS*))))))
          (CAR A))
         (SETQ A (CDR A))
         (GO LAB))
       (REMFLAG FUNCTIONS* 'FULL))
      (AEVAL (CLEAR (LIST 'STEPS))))) 
(PUT 'SUBSTEPS 'NUMBER-OF-ARGS 1) 
(FLAG '(SUBSTEPS) 'OPFN) 
(PUT 'SUBSTEPS 'DEFINED-ON-LINE '174) 
(PUT 'SUBSTEPS 'DEFINED-IN-FILE 'FIDE/APPROX.RED) 
(PUT 'SUBSTEPS 'PROCEDURE_TYPE '(ARROW GENERAL GENERAL)) 
(DE SUBSTEPS (U)
    (PROG (STEP NU DU)
      (SETQ NU (AEVAL (LIST 'NUM U)))
      (SETQ DU (AEVAL (LIST 'DEN U)))
      (PROG (A)
        (SETQ A COORDS*)
       LAB
        (COND ((NULL A) (RETURN NIL)))
        ((LAMBDA (A)
           (PROGN
            (SETQ STEP (GET A 'GRIDSTEP))
            (FLAG (LIST STEP) 'USED*)
            (PUT STEP 'AVALUE '(SCALAR 0))))
         (CAR A))
        (SETQ A (CDR A))
        (GO LAB))
      (RMSUBS)
      (SETQ NU (AEVAL NU))
      (SETQ DU (AEVAL DU))
      (PROG (A)
        (SETQ A COORDS*)
       LAB
        (COND ((NULL A) (RETURN NIL)))
        ((LAMBDA (A)
           (PROGN
            (SETQ STEP (GET A 'GRIDSTEP))
            (REMFLAG (LIST STEP) 'USED*)
            (REMPROP STEP 'AVALUE)))
         (CAR A))
        (SETQ A (CDR A))
        (GO LAB))
      (RMSUBS)
      (COND
       ((EVALEQUAL (AEVAL DU) 0)
        (PROGN
         (ASSGNPRI
          (AEVAL
           " Reformulate difference scheme, grid steps remain in denominators")
          NIL 'ONLY)
         (SETQ U (AEVAL 0))))
       (T (SETQ U (AEVAL (LIST 'QUOTIENT NU DU)))))
      (RETURN (AEVAL U)))) 
(PUT 'MINORDER 'NUMBER-OF-ARGS 2) 
(FLAG '(MINORDER) 'OPFN) 
(PUT 'MINORDER 'DEFINED-ON-LINE '198) 
(PUT 'MINORDER 'DEFINED-IN-FILE 'FIDE/APPROX.RED) 
(PUT 'MINORDER 'PROCEDURE_TYPE '(ARROW (TIMES GENERAL GENERAL) GENERAL)) 
(DE MINORDER (POL VAR)
    (PROG (LCOFS MORD)
      (AEVAL (LIST 'COEFF (LIST 'DEN POL) VAR))
      (SETQ MORD (AEVAL (LIST 'MINUS HIPOW*)))
      (SETQ LCOFS (AEVAL (LIST 'REST (LIST 'COEFF (LIST 'NUM POL) VAR))))
      (COND
       ((NOT (EVALEQUAL (AEVAL MORD) 0))
        (RETURN (AEVAL (LIST 'PLUS MORD LOWPOW*)))))
      (SETQ MORD (AEVAL 1))
     A
      (COND ((EVALEQUAL (AEVAL LCOFS) (AEVAL (LIST 'LIST))) (RETURN 0))
            ((EVALEQUAL (AEVAL (LIST 'FIRST LCOFS)) 0)
             (SETQ LCOFS (AEVAL (LIST 'REST LCOFS))))
            (T (RETURN (AEVAL MORD))))
      (SETQ MORD (AEVAL (LIST 'PLUS MORD 1)))
      (GO A))) 
(ENDMODULE) 