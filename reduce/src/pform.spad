)abbrev domain PFORM PForm
PForm:Exports == Implementation where
  REDBOOT ==> ReduceBootstrap
  NNI ==> NonNegativeInteger
  SEX ==> SExpression
  SYM ==> Symbol
  Exports == SetCategory with
    pform : (SYM,SYM) -> %
    pform : (SYM,NNI) -> %
    _* : (%,%) -> %
    _+ : (%,%) -> %
    _- : (%,%) -> %    
    exdegree : % -> SEX
    d : % -> %
    spacedim : PositiveInteger -> SEX
    spacedim : SYM -> SEX
    tvector : SYM -> %
    D: (%,List %) -> %
    innerprod : (%,%) -> %
    liedf : (%,%) -> %
    hodge : % -> %
    fdomain : (%,List %) -> %
    mkqsym : Symbol -> String
  Implementation == SExpression add
    Rep:=SEX
    
    mkqsym(s:Symbol):String ==
      if not scripted? s then
        string FORMAT('NIL,"'~A",s)$Lisp
      else
        ns:=name s
        ss:=scripts(s).sub
        string FORMAT('NIL,"(list '~A ~{'~A ~})",ns,ss)$Lisp
        
    pform(frm:SYM, deg:SYM):% ==
      fmt1:="(pform (list (list 'equal ~A ~A)))"
      fmt2:="(reval ~A)"
      cmd1:=string FORMAT('NIL,fmt1,mkqsym frm,mkqsym deg)$Lisp 
      cmd2:=string FORMAT('NIL,fmt2,mkqsym frm)$Lisp
      r1:SEX:=slEval(cmd1)$REDBOOT
      r2:SEX:=slEval(cmd2)$REDBOOT
      
    pform(frm:SYM, deg:NNI):% ==
      fmt1:="(pform (list (list 'equal ~A ~A)))"
      fmt2:="(reval ~A)"
      cmd1:=string FORMAT('NIL,fmt1,mkqsym frm,deg)$Lisp 
      cmd2:=string FORMAT('NIL,fmt2,mkqsym frm)$Lisp
      r1:SEX:=slEval(cmd1)$REDBOOT
      r2:SEX:=slEval(cmd2)$REDBOOT

    (u:% * v:%):% ==
      fmt:="(reval (list 'wedge '~A '~A))"
      cmd:=string FORMAT('NIL,fmt,u,v)$Lisp
      r:SEX:=slEval(cmd)$REDBOOT
      
    (u:% + v:%):% ==
      fmt:="(reval (list 'plus '~A '~A))"
      cmd:=string FORMAT('NIL,fmt,u,v)$Lisp
      r:SEX:=slEval(cmd)$REDBOOT
 
    (u:% - v:%):% ==
      fmt:="(reval (list 'difference '~A '~A))"
      cmd:=string FORMAT('NIL,fmt,u,v)$Lisp
      r:SEX:=slEval(cmd)$REDBOOT

    exdegree(u:%):SEX ==
      fmt:="(reval (list 'exdegree '~A))"
      cmd:=string FORMAT('NIL,fmt,u)$Lisp
      r:SEX:=slEval(cmd)$REDBOOT  
      
      
    d(u:%):% ==
      fmt:="(reval (list 'd '~A))"
      cmd:=string FORMAT('NIL,fmt,u)$Lisp
      r:SEX:=slEval(cmd)$REDBOOT  

    spacedim(n:PositiveInteger):SEX ==
      fmt:="(spacedim (list ~A))"
      cmd:=string FORMAT('NIL,fmt,n)$Lisp
      r:SEX:=slEval(cmd)$REDBOOT  
    
    spacedim(s:SYM):SEX ==
      fmt:="(spacedim (list '~A))"
      cmd:=string FORMAT('NIL,fmt,s)$Lisp
      r:SEX:=slEval(cmd)$REDBOOT  

    tvector(vec:SYM):% ==
      fmt1:="(tvector (list ~A))"
      fmt2:="(reval ~A)"
      cmd1:=string FORMAT('NIL,fmt1,mkqsym vec)$Lisp 
      cmd2:=string FORMAT('NIL,fmt2,mkqsym vec)$Lisp
      r1:SEX:=slEval(cmd1)$REDBOOT
      r2:SEX:=slEval(cmd2)$REDBOOT
      
    D(u:%,v:List %):% ==
      fmt:="(reval (list 'partdf '~A ~{'~A ~}))"
      cmd:=string FORMAT('NIL,fmt,u,v)$Lisp
      r:SEX:=slEval(cmd)$REDBOOT       

    innerprod(vec:%,frm:%):% ==
      fmt:="(reval (list 'innerprod '~A '~A))"
      cmd:=string FORMAT('NIL,fmt,vec,frm)$Lisp
      r:SEX:=slEval(cmd)$REDBOOT
      
    liedf(vec:%,frm:%):% ==
      fmt:="(reval (list 'liedf '~A '~A))"
      cmd:=string FORMAT('NIL,fmt,vec,frm)$Lisp
      r:SEX:=slEval(cmd)$REDBOOT
      
    hodge(u:%):% ==
      fmt:="(reval (list 'hodge '~A))"
      cmd:=string FORMAT('NIL,fmt,u)$Lisp
      r:SEX:=slEval(cmd)$REDBOOT  

    fdomain(op:%,vars:List %):% ==
      fmt:="(fdomain (list (list 'equal '~A (list '~A ~{'~A ~}))))"
      cmd:=string FORMAT('NIL,fmt,op,op,vars)$Lisp
      r:SEX:=slEval(cmd)$REDBOOT       
