quickLoad pchain
macro makePoints(plist) == plist:=map(point,plist)
makePoints [A,B,C,D,S,Z]


-- A,B,C,D collinear
C := A + p * (B-A)
D := A + q * (B-A)


A' := Z + a*(A-Z)
B' := Z + b*(B-Z)
C' := Z + c*(C-Z)
D' := Z + d*(D-Z)

C' := A' + r * (B'-A')
D' := A' + s * (B'-A')


eqc:=[s=0 for s in coefficients(normalize(C'-Z-c*(C-Z)))]
eqd:=[s=0 for s in coefficients(normalize(D'-Z-d*(D-Z)))]
cr:=first solve(eqc,[c,r])
ds:=first solve(eqd,[d,s])


-- AA'Z,..., DD'Z =0 
eq1:=leadingCoefficient normalize(C*C'*Z)=0
eq2:=leadingCoefficient normalize(D*D'*Z)=0

rs:=solve([eq1,eq2],[r,s])

A'C':=normalize(A'*C')
B'D':=normalize(B'*D')
B'C':=normalize(B'*C')
A'D':=normalize(A'*D')


c1:=coefficients(A'C')
c2:=coefficients(A'D')
c3:=coefficients(B'C')
c4:=coefficients(B'D')

test(c1.1/c2.1 = r/s)
test(c1.2/c2.2 = r/s)

test(c3.1/c4.1 = (r-1)/(s-1))
test(c3.2/c4.2 = (r-1)/(s-1))

CR := crossRatio(A,B,C,D) 

CR' := (r*s-r)/((r-1)*s)

CR' := eval(eval(CR',rs.1.1),rs.1.2)

if test(CR=CR') then output "Q.E.D"
