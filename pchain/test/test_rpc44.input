quickLoad pchain

-- plist, e.g. makePoints [A,B,C,D] creates the points A,B,C,D.
-- One can use them afterwards, e.g. C=a*A+b*B - 
macro makePoints(plist) == plist:=map(point,plist)

makePoints [A,B,C,D,Z]

-- A,B,C,D collinear
C := A + ca * (B-A)
D := A + da * (B-A)



A' := Z + a*(A-Z)
B' := Z + b*(B-Z)
C' := Z + c*(C-Z)
D' := Z + d*(D-Z)

C' := A' + x * (B'-A')
D' := A' + y * (B'-A')

-- A' =  a A + (1-a)Z
-- B' =  b B + (1-b)Z
-- C' =  a(1-x)A + b x B + (x(a-b) + 1-a)Z
-- D' =  a(1-y)A + b y B + (y(a-b) + 1-a)Z

-- Schnittpunkt der Geraden (kann im oo sein ...)
-- (1-a)*B' - (1-b)*A' = (a b - a)A + (- a + 1)b B
-- (y*(a-b)+1-a)*C' - (x*(a-b)+1-a)*D' = 
-- (a(1-b)y + a(b - 1)x)A + ((a - 1)b y + (1-a)b x)B 
--
-- Fall I (die Geraden schneiden sich in S)
-- use barycenter

--         a b - a     (- a + 1)b
--         ------- A + ---------- B = S
--          b - a         b - a
--
--
--         (b - a)y + a - 1           (- b + a)x - a + 1
--         --------------------- C' + --------------------- D'
--         (b - a)y + (- b + a)x       (b - a)y + (- b + a)x
--         
--
--         b - 1       - a + 1
--         ----- A' + ------- B'
--         b - a        b - a



eq1:=normalize(C'*Z-c*C*Z)=0$RPC
eq2:=normalize(D'*Z-d*D*Z)=0$RPC
CM:=coeffMatrix([eq1,eq2],[A*Z,B*Z])
--cmq:=[CM(1,1)=0,CM(1,2)=0,CM(2,1)=0,CM(2,2)=0]
cmq:=concat listOfLists(map(s+->s=0,CM))
cdxy:=solve(cmq,[c,d,x,y])

C':=eval(C',cdxy.1.3)
D':=eval(D',cdxy.1.4)

A'C':=normalize(A'*C')
B'D':=normalize(B'*D')
B'C':=normalize(B'*C')
A'D':=normalize(A'*D')

test(A'C' - B'C' = A'D' - B'D')

-- Schnittpunkt S 

eqS:=A+u*(B-A) = A'+v*(B'-A') -- Schnittpunkt

--- missing from RPC ***
--coefficients(c:RealPointChain):List(Expression Integer) ==
--  zero? c => []
--  append([leadingCoefficient c],coefficients reductum c)



cc:=(coefficients (lhs eqS - rhs eqS))

eqcc:=[s=0 for s in cc]

uv := solve(eqcc,[u,v])



S:=lhs eval(eval(eqS,uv.1.1),uv.1.2)

eqZ:=Z= p*A+q*A'+(1-p-q)*S

